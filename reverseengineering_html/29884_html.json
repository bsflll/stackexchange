{
    "title": "Is disassembly of standard gcc programs trivial, or just as difficult as video game ROMs?",
    "link": "https://reverseengineering.stackexchange.com/questions/29884/is-disassembly-of-standard-gcc-programs-trivial-or-just-as-difficult-as-video-g",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am attempting to do some reverse-engineering of ARM binaries, with the ultimate goal of reverse-engineering GBA ROMs. Of course, GBA ROMs contain a mixture of code and data, so a standard disassembler that just converts the hexdump to equivalent ARMv4 assembly won't work because of the parts that correspond to data. So clearly disassembling GBA ROMs is a tough task. (Please correct me if I'm wrong on any of that - I'm very much still learning.)\n </p>\n <p>\n  My question is, do standard C programs compiled to ARMv4 with\n  <code>\n   gcc\n  </code>\n  on Ubuntu have the problem I explained above of producing a mixture of data and code in the binary? If so, what kinds of programs have this (all of them, or only some special cases?)\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 0,
    "views": "73",
    "tags": [
        "disassembly",
        "disassemblers",
        "gcc",
        "rom"
    ],
    "user": "JBraha",
    "time": "Jan 18, 2022 at 2:57",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<html><body><span class=\"comment-copy\">\n I guess the tooling for ELF files (an assumption, as you don't say!) and ARMv4 is generally better and more versatile. Basically what I mean is that more generic tools will work than for GBA. So in that sense it's perhaps a little easier. But tools are just one variable in the equation ...\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}