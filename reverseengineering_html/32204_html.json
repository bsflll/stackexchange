{
    "title": "How can I tell ghidra what structure an address register points to?",
    "link": "https://reverseengineering.stackexchange.com/questions/32204/how-can-i-tell-ghidra-what-structure-an-address-register-points-to",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am reversing a raw bare-metal binary firmware for a tricore processor (TC1762/TC1766).\nIn many functions i'm currently reversing there is access to offsets of the address stored in the a0 register. Therefore a0 points to a definable stucture, that i analysed an defined in the Data Type Manager.\n </p>\n <p>\n  Examples of access:\n </p>\n <p>\n  Reading from the structure:\n </p>\n <pre><code>result = functionCall(*(int *)(a0 + 0x1478),1);\n</code></pre>\n <p>\n  Writing to the structure:\n </p>\n <pre><code>*(undefined4 *)(a0 + 0x147c) = timeOfLastRequest;\n</code></pre>\n <p>\n  The structure I setup to use:\n  <a href=\"https://i.sstatic.net/8atAu.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"Defined the offsets and names as they are accessed\" src=\"https://i.sstatic.net/8atAu.png\"/>\n  </a>\n </p>\n <p>\n  Now I want to tell ghidra, to handle a0 as a pointer to this struct. If a0 was just a pointer variable this would work as intented and would make \"a0 + 0x1478\" something like instanceOfCounter->currentNumber.\n </p>\n <p>\n  Trying to set a type to a0 will result in an UnsupportedOperationException:\nDatabase supports global memory variables only\njava.lang.UnsupportedOperationException: Database supports global memory variables only\n </p>\n <p>\n  I am sure there is a way to do this correctly since it would improve the readability of the disassembly so much and would just feel right. I just can't find a way to do this.\n </p>\n <p>\n  I understand that the context, that a0 points to this struct is probably limited, so this might need to be assigned only for the context of a defined function or something.\nAppreciate any hint\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "619",
    "tags": [
        "disassembly",
        "ghidra",
        "firmware-analysis",
        "register",
        "type-reconstruction"
    ],
    "user": "user103675",
    "time": "Aug 24, 2023 at 12:58",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  In Windows Assuming code as below is compiled without debugging info (no PDB)  and loaded in ghidra.\n </p>\n <p>\n  disabled analysis on loading.\n </p>\n <p>\n  followed label entry to find the address of function main\n </p>\n <p>\n  went to main (0x140001000) and hit D to Disassemble and hit F to create a Function\n </p>\n <pre><code>#include <windows.h>\n#include <winternl.h>\n#include <stdio.h>\nint main(void)\n{\n    PPEB mypeb = (PPEB)__readgsqword(0x60);\n    PRTL_USER_PROCESS_PARAMETERS proparm = mypeb->ProcessParameters;\n    printf(\"%S\n\", proparm->ImagePathName.Buffer);\n}\n</code></pre>\n <p>\n  the decompiled function main would look as below with fuzzy pointer arithmetics and ugly casts\n </p>\n <pre><code>   undefined8\nFUN_140001000(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  longlong unaff_GS_OFFSET;\n  \n  FUN_1400010a0((longlong)&DAT_1400132e0,\n                *(undefined8 *)(*(longlong *)(*(longlong *)(unaff_GS_OFFSET + 0x60) + 0x20) + 0x68),\n                param_3,param_4);\n  return 0;\n}\n</code></pre>\n <p>\n  there are three pointer arithmetic\n </p>\n <ol>\n  <li>\n   (unaff_GS_OFFSET + 0x60)\n  </li>\n  <li>\n   (unaff_GS_OFFSET + 0x60) + 0x20)\n  </li>\n  <li>\n   (unaff_GS_OFFSET + 0x60) + 0x20) + 0x68)\n  </li>\n </ol>\n <p>\n  so there must be three unknown structs/artifacts/something/anything...\n </p>\n <p>\n  lets start making this ugliness go away by adding structures\n </p>\n <p>\n  In DataTypeManager Select the binary -> right click ->new ->structure\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/DmRsV.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/DmRsV.png\"/>\n  </a>\n </p>\n <p>\n  create a new structure name it as\n  <strong>\n   unknown_struct_1\n  </strong>\n  for now\n  \n\n  under Description add a comment\n  <code>\n   using only offset 0x60\n  </code>\n  \n\n  enter\n  <strong>\n   0x100\n  </strong>\n  arbitrarily as size\n </p>\n <p>\n  create 2 more structs the same way\n  <strong>\n   unknown_struct_2\n  </strong>\n  \n\n  <strong>\n   using offset 0x20 only\n  </strong>\n </p>\n <p>\n  <strong>\n   unknown_struct_3\n  </strong>\n  \n\n  <strong>\n   using offset 0x68 only\n  </strong>\n </p>\n <p>\n  edit unknown_struct_1 go to offset 0x60 and embed a pointer to unknown_struct_2 and give a Name say \"Needs Name 1\"\n </p>\n <p>\n  edit unknown_struct_2 go to offset 0x20 and embed a pointer to unknown_struct_3 and give a Name say \"Needs Name 2\"\n </p>\n <p>\n  after this select the longlong type of GS_OFFSET right click and retype the variable as pointer to unknown_struct_1\n  \n\n  the decompilation will improve to\n </p>\n <pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  FUN_1400010a0((longlong)&DAT_1400132e0,\n                *(undefined8 *)&unaff_GS_OFFSET->NeedsName_1->NeedsName2->field_0x68,param_3,param_4\n               );\n  return 0;\n}\n</code></pre>\n <p>\n  now following 1400132e0 you get a tell tale sign of printf format string\n </p>\n <pre><code>                        DAT_1400132e0                                   XREF[1]:     FUN_140001000:140001029(*)  \n   1400132e0 25                     ??         25h    %\n   1400132e1 53                     ??         53h    S\n   1400132e2 0a                     ??         0Ah\n</code></pre>\n <p>\n  create a terminated c string at that address right click -> data -> terminatedcstring\n </p>\n <pre><code>                         s_%S_1400132e0                                  XREF[1]:     FUN_140001000:140001029(*)  \n   1400132e0 25 53 0a 00            ds         \"%S\n\"\n   1400132e4 00                     ??         00h\n</code></pre>\n <p>\n  the decompilation will further improve to\n </p>\n <pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  FUN_1400010a0((longlong)\"%S\n\",\n                *(undefined8 *)&unaff_GS_OFFSET->NeedsName_1->NeedsName2->field_0x68,param_3,param_4\n               );\n  return 0;\n}\n</code></pre>\n <p>\n  change the function signature of 0x1400010a0 to int __cdecl printf(char * formtstring,...) a vararg function\n </p>\n <p>\n  you will have a still better decompilation\n </p>\n <pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  printf(\"%S\n\",*(undefined8 *)&unaff_GS_OFFSET->NeedsName_1->NeedsName2->field_0x68);\n  return 0;\n}\n</code></pre>\n <p>\n  <a href=\"https://i.sstatic.net/FNTQ3.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/FNTQ3.png\"/>\n  </a>\n </p>\n <p>\n  the format string is %S so it must be printing a wide string (wchar_t *) or probably the buffer in a UNICODE_STRING structure\n </p>\n <p>\n  lets now go to the unknown_struct_3 at offset 0x68 embed a UNICODE_STRING * and give it a name\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/C2J7q.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/C2J7q.png\"/>\n  </a>\n </p>\n <p>\n  now the decompilation is almost nearer to the final shape\n </p>\n <pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  printf(\"%S\n\",unaff_GS_OFFSET->NeedsName_1->NeedsName2->Some_wide_string);\n  return 0;\n</code></pre>\n <p>\n  now after further reverse engineering  you can infer unaff_GS_OFFSET is pointer to _TEB ->\n  \n\n  whose 0ffset 0x60 Contains pointer to _PEB (Process Environemnt Block) ->\n  \n\n  whose offset 0x20 contains a pointer to RTL_USER_PROCESS_PARAMETER ->\n  \n\n  whose offset 0x68 contains a pointer to Unicode_string  ImagePathName  ->\nwhose offset 0x8 contains a pointer to wchar_t\n </p>\n <p>\n  so we need to shift the UNICODE_STRING * to 0x60 as UNICODE_STRING struct  so that the member Buffer a wchar_t* will be  at offset 0x68.\n </p>\n <pre><code>0:000> dt ntdll!_TEB ProcessEnvironmentBlock->ProcessParameters->ImagePathName.Buffer\n   +0x060 ProcessEnvironmentBlock                                          :\n      +0x020 ProcessParameters                                                :\n         +0x060 ImagePathName                                                    :\n            +0x008 Buffer                                                           : Ptr64 Wchar\n0:000>\n</code></pre>\n <p>\n  just rename the unknowns and need names\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/Q3WBr.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/Q3WBr.png\"/>\n  </a>\n  <a href=\"https://i.sstatic.net/bSFxR.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/bSFxR.png\"/>\n  </a>\n </p>\n <p>\n  and you have a clean decompilation after changing the function signature of main to int main (void)\n </p>\n <pre><code>int main(void)\n\n{\n  TEB *MyTeb;\n  \n  printf(\"%S\n\",(MyTeb->ProcessEnvironmentBlock->ProcessParameters->ImagePathName).Buffer);\n  return 0;\n}\n</code></pre>\n</div>\n</body></html>",
            "votes": "2",
            "user": "blabb",
            "time": "Aug 25, 2023 at 17:42",
            "is_accepted": false,
            "comments": [
                {
                    "user": "user103675",
                    "text": "<span class=\"comment-copy\">This is a great description of a nice workflow including the definition and assigning of structures. I think I am so far aware of how this works. My requirement is, that I need to assign a defined struct to a register used directly (a0 in this case). Its not a variable on stack or heap or alike.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">You mean you dont want to have a clean decompilation but  disassembly showing. [foo+ blah.bar] instead of [rbp+0x68]. No ghidra doesnt do it at the moment <a href=\"https://github.com/NationalSecurityAgency/ghidra/issues/2303\" rel=\"nofollow noreferrer\">there is an open issue in github iirc requesting such a feature</a></span>",
                    "time": null
                }
            ]
        }
    ]
}