{
    "title": "Force gcc to use more complex instructions",
    "link": "https://reverseengineering.stackexchange.com/questions/24980/force-gcc-to-use-more-complex-instructions",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am reverse engineering a piece of assembly. I am trying to write the equivalent code in C, however, when I compile my code, gcc prefers to use simple instructions instead of the complex ones that are used in my assembly. I was wondering if I can suggest or force gcc to use more complex instructions.\n </p>\n <p>\n  <strong>\n   EDIT:\n  </strong>\n  I have already tried using the\n  <code>\n   -O\n  </code>\n  options but they will change lots of other variables and therefore, don't look like a good solution.\n </p>\n <p>\n  You can find examples here:\n </p>\n <pre><code>// original assembly\nlea     rdx, [rax+0x20]\n\n// generated by gcc\nadd     rax, 0x20\nmov     rdx, rax\n\n// C code\n0x20+((uint8_t *)lParm1)  // long lParm1\n</code></pre>\n <pre><code>// original assembly\ntest    eax, eax\n\n// generated by gcc\nmov     [rbp-0x10], eax\ncmp     [rbp-0x10], 0x0\n\n// C code\nif (!iVar)  // int iVar\n</code></pre>\n <pre><code>// original assembly\nmov     eax, [rax+0x40]\n\n// generated by gcc\nadd     rax, 0x40\nmov     eax, [rax]\n\n// C code\n(float)*(int *)(lParm1 + 0x40)\n</code></pre>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 0,
    "views": "204",
    "tags": [
        "assembly",
        "decompilation",
        "gcc"
    ],
    "user": "Bat",
    "time": "May 11, 2020 at 14:07",
    "comments": [
        {
            "user": "sbluff",
            "text": "<html><body><span class=\"comment-copy\">\n can you please share the c code that generates that set of instructions?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Robert",
            "text": "<html><body><span class=\"comment-copy\">\n Often the original code smaller (is only one command vs. two). Therefore you may try to enable optimization for code size via\n <code>\n  -Os\n </code>\n parameter.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Bat",
            "text": "<html><body><span class=\"comment-copy\">\n I have already tried that. The thing is that it more or less achieves what I want but then changes lots of other variables. Therefore, doesn't seem like a good option\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Robert",
            "text": "<html><body><span class=\"comment-copy\">\n Please edit your question and include in detail what you already tried and why it  is not a suitable solution.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "0xC0000022L",
            "text": "<html><body><span class=\"comment-copy\">\n Actually in order to achieve what you want, you need to have a toolchain (including not just compiler frontend and backend, but also assembler and linker - linker if you use LTO or similar) which can produce the desired code. And then, depending on those (and the specs file - try\n <code>\n  gcc -dumpspecs\n </code>\n ) you can use\n <code>\n  -mtune\n </code>\n ,\n <code>\n  -mcpu\n </code>\n and\n <code>\n  -march\n </code>\n as well as some more architecture-specific options to optimize for a CPU model and so on. However, your question should be clarified further ... also, you may want to look at RetDec and LLVM IR, perhaps?!\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}