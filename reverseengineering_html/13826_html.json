{
    "title": "Locate address of function in DLL",
    "link": "https://reverseengineering.stackexchange.com/questions/13826/locate-address-of-function-in-dll",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I need to locate the address of a function in a DLL at runtime which isn't exported. The DLL in question is vbe7.dll related to Visual Basic (and macros). The function is\n  <code>\n   ___vbaInStr\n  </code>\n  , can be found in IDA if symbols are downloaded from Microsoft.\n </p>\n <p>\n  Locating it in IDA to get an offset is no biggie but I want to use it in Python and be able to locate it even if it's running on other machines. The reason being that I'm using winappdbg and need to place a breakpoint on the particular function to access the arguments pushed to the stack.\n </p>\n <p>\n  My theories so far have been:\n </p>\n <ol>\n  <li>\n   Find exported functions used close to a call to the targeted function and calculate the offset. Haven't tried it though.\n  </li>\n  <li>\n   Find a instruction pattern around the call to the targeted function. This failed depending on the DLL version and compiler used.\n  </li>\n  <li>\n   Look at the targeted function to locate the starting address, this failed for the same reason as above.\n  </li>\n </ol>\n <p>\n  So getting the address of an exported function is easy but getting the address of a non-exported function? Target is\n  <code>\n   .text:102242E3\n  </code>\n  .\n </p>\n <pre><code>.text:10224212 ; int __stdcall sub_10224212(int, LCID Locale, VARIANTARG *, VARIANTARG *pvarSrc, int)\n.text:10224212 sub_10224212    proc near               ; CODE XREF: sub_1000B164+859p\n.text:10224212                                         ; rtcInStrChar+52p\n.text:10224212\n.text:10224212 arg_0           = dword ptr  8\n.text:10224212 Locale          = dword ptr  0Ch\n.text:10224212 arg_8           = dword ptr  10h\n.text:10224212 pvarSrc         = dword ptr  14h\n.text:10224212 arg_10          = dword ptr  18h\n.text:10224212\n.text:10224212                 mov     edi, edi\n.text:10224214                 push    ebp\n.text:10224215                 mov     ebp, esp\n.text:10224217                 push    ebx\n.text:10224218                 push    edi\n.text:10224219                 mov     edi, [ebp+pvarSrc]\n.text:1022421C                 push    edi\n.text:1022421D                 call    rtcIsNull\n.text:10224222                 test    ax, ax\n.text:10224225                 jnz     loc_10224330\n.text:1022422B                 mov     ebx, [ebp+arg_8]\n.text:1022422E                 push    ebx\n.text:1022422F                 call    rtcIsNull\n.text:10224234                 test    ax, ax\n.text:10224237                 jnz     loc_10224330\n.text:1022423D                 push    esi\n.text:1022423E                 push    8\n.text:10224240                 pop     esi\n.text:10224241                 cmp     [edi], si\n.text:10224244                 jnz     short loc_1022424B\n.text:10224246                 mov     edi, [edi+8]\n.text:10224249                 jmp     short loc_10224261\n.text:1022424B ; ---------------------------------------------------------------------------\n.text:1022424B\n.text:1022424B loc_1022424B:                           ; CODE XREF: sub_10224212+32j\n.text:1022424B                 push    edi             ; pvarSrc\n.text:1022424C                 call    sub_1006D9C8\n.text:10224251                 mov     edi, eax\n.text:10224253                 mov     eax, esi\n.text:10224255                 mov     word ptr pvarg.anonymous_0, ax ; jumptable 1000BE78 cases 56231,63056\n.text:1022425B                 mov     dword ptr pvarg.anonymous_0+8, edi ; jumptable 1000BE78 cases 56231,63056\n.text:10224261\n.text:10224261 loc_10224261:                           ; CODE XREF: sub_10224212+37j\n.text:10224261                 movzx   eax, word ptr [ebx]\n.text:10224264                 cmp     ax, si\n.text:10224267                 jnz     short loc_1022426E\n.text:10224269                 mov     eax, [ebx+8]\n.text:1022426C                 jmp     short loc_102242DB\n.text:1022426E ; ---------------------------------------------------------------------------\n.text:1022426E\n.text:1022426E loc_1022426E:                           ; CODE XREF: sub_10224212+55j\n.text:1022426E                 cmp     word ptr pvarg.anonymous_0, si ; jumptable 1000BE78 cases 56231,63056\n.text:10224275                 jnz     short loc_102242C7\n.text:10224277                 cmp     ax, 9\n.text:1022427B                 jnz     short loc_102242C7\n.text:1022427D                 xor     eax, eax\n.text:1022427F                 mov     esi, offset pvarSrc\n.text:10224284                 push    esi\n.text:10224285                 mov     word ptr pvarg.anonymous_0, ax ; jumptable 1000BE78 cases 56231,63056\n.text:1022428B                 push    dword ptr [ebx+8]\n.text:1022428E                 call    sub_1022103A\n.text:10224293                 mov     ebx, eax\n.text:10224295                 test    ebx, ebx\n.text:10224297                 jz      short loc_102242A6\n.text:10224299                 push    edi             ; bstrString\n.text:1022429A                 call    ds:__imp_SysFreeString ; jumptable 1000BE78 cases 171,16878,16935,30141,31177,32098,43703,61383,65216\n.text:102242A0                 push    ebx\n.text:102242A1                 call    sub_1005DCF1\n.text:102242A6\n.text:102242A6 loc_102242A6:                           ; CODE XREF: sub_10224212+85j\n.text:102242A6                 push    8\n.text:102242A8                 pop     eax\n.text:102242A9                 push    eax             ; vt\n.text:102242AA                 push    esi             ; pvarSrc\n.text:102242AB                 push    esi             ; pvargDest\n.text:102242AC                 mov     word ptr pvarg.anonymous_0, ax ; jumptable 1000BE78 cases 56231,63056\n.text:102242B2                 mov     dword ptr pvarg.anonymous_0+8, edi ; jumptable 1000BE78 cases 56231,63056\n.text:102242B8                 call    sub_10082A4C\n.text:102242BD                 mov     eax, dword ptr pvarSrc.anonymous_0+8\n.text:102242C2                 push    8\n.text:102242C4                 pop     esi\n.text:102242C5                 jmp     short loc_102242DB\n.text:102242C7 ; ---------------------------------------------------------------------------\n.text:102242C7\n.text:102242C7 loc_102242C7:                           ; CODE XREF: sub_10224212+63j\n.text:102242C7                                         ; sub_10224212+69j\n.text:102242C7                 push    ebx             ; pvarSrc\n.text:102242C8                 call    sub_1006D9C8\n.text:102242CD                 mov     ecx, esi\n.text:102242CF                 mov     word ptr pvarSrc.anonymous_0, cx\n.text:102242D6                 mov     dword ptr pvarSrc.anonymous_0+8, eax\n.text:102242DB\n.text:102242DB loc_102242DB:                           ; CODE XREF: sub_10224212+5Aj\n.text:102242DB                                         ; sub_10224212+B3j\n.text:102242DB                 push    [ebp+arg_10]    ; int\n.text:102242DE                 push    edi             ; LPCWSTR\n.text:102242DF                 push    eax             ; lpSrcStr\n.text:102242E0                 push    [ebp+Locale]    ; Locale\n.text:102242E3                 call    sub_10083C60 \n.text:102242E8                 mov     edi, eax\n.text:102242EA                 cmp     word ptr pvarg.anonymous_0, si ; jumptable 1000BE78 cases 56231,63056\n.text:102242F1                 jnz     short loc_10224307\n.text:102242F3                 push    dword ptr pvarg.anonymous_0+8 ; bstrString\n</code></pre>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 4,
    "views": "3k",
    "tags": [
        "dll",
        "python",
        "breakpoint",
        "address"
    ],
    "user": "user17903",
    "time": "Oct 28, 2016 at 17:20",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  if you have pdb then this code can fetch you either Symbol or Type from it\n </p>\n <pre><code>#include <windows.h>\n#include <stdio.h>\n#include <dbghelp.h>\n#pragma comment(lib , \"dbghelp.lib\")\n\nHANDLE hProcess;\n\nBOOL CALLBACK EnumSymProc(PSYMBOL_INFO pSymInfo,ULONG ,PVOID UserContext){\n  size_t maxcmplen = strlen((PCHAR)UserContext);\n  if( maxcmplen == pSymInfo->NameLen ) {\n    if((strncmp(pSymInfo->Name,(PCHAR)UserContext,pSymInfo->NameLen)) == 0) {\n      TI_FINDCHILDREN_PARAMS childs = {0};\n      SymGetTypeInfo(hProcess,pSymInfo->ModBase,pSymInfo->TypeIndex,\n      TI_GET_CHILDRENCOUNT,&childs.Count);\n      printf(\"%8s%10s%10s%16s %s\" , \"Size\" ,\"TypeIndex\",\"Childs\",\"Address\",\"Name\n\");\n      printf (\"%8x %8x %8x %16I64x %10s\n\",pSymInfo->Size,pSymInfo->TypeIndex,\n      childs.Count,pSymInfo->Address , pSymInfo->Name );\n    }\n  }\n  return TRUE;\n}\nvoid main(int argc , char *argv[]) {\n  hProcess = GetCurrentProcess();\n  SymInitialize(hProcess, NULL, FALSE);  \n  DWORD64 BaseOfDll=SymLoadModuleEx(hProcess,NULL,argv[1],NULL,\n  0x400000,0x20000,NULL,0);\n  SymEnumSymbols(hProcess , BaseOfDll , \"*!*\" , EnumSymProc , argv[2]);\n  SymEnumTypes(hProcess, BaseOfDll, EnumSymProc, argv[2]);  \n  SymCleanup(hProcess);\n}\n</code></pre>\n <p>\n  usage\n </p>\n <pre><code>symenumtype.exe .\\vbe7.pdb __vbaInStr\n    Size TypeIndex    Childs         Address Name\n       0        0        0           4c3e4f __vbaInStr\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "blabb",
            "time": "Oct 28, 2016 at 11:32",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  If you target known versions you can hardcode the addresses as found it Ida. If you don't know for different versions than best approach is fetch pdb via api and find address that way.\n </p>\n <p>\n  This might help you tonget started:\n  <a href=\"https://stackoverflow.com/questions/3092609/how-to-get-field-names-and-offsets-of-a-struct-using-dbghlp-and-pdb\">\n   https://stackoverflow.com/questions/3092609/how-to-get-field-names-and-offsets-of-a-struct-using-dbghlp-and-pdb\n  </a>\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": [
                {
                    "user": "user17903",
                    "text": "<span class=\"comment-copy\">As there is too many unknown versions, hardcoded offsets wouldn't be a good solution, it was although my initial approach. I've noticed that IDA fails to get the symbols from Microsoft (E_PDB_NOT_FOUND) for many of the versions.</span>",
                    "time": null
                },
                {
                    "user": "Remko",
                    "text": "<span class=\"comment-copy\">In which case I think the only remaining option is to find out if your function is always following a known exported one. Then disassemble yourself eg with <a href=\"http://help.madshi.net/madDisAsm.htm\" rel=\"nofollow noreferrer\">help.madshi.net/madDisAsm.htm</a> to find the end of function then next address will be yours...</span>",
                    "time": null
                },
                {
                    "user": "Remko",
                    "text": "<span class=\"comment-copy\">or use pattern search...</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The best option here is probably your first suggestion - finding an exported function that calls your function, and then disassembling it in run time to figure out where the call points to.\n </p>\n <p>\n  This is pretty easily done by using IDA's cross-reference for example (\n  <kbd>\n   ctrl\n  </kbd>\n  +\n  <kbd>\n   x\n  </kbd>\n  when your cursor is on the function's name in IDA). Keep in mind that you'd want to avoid/reduce the amount of certain parameters used to find the function you're looking for. For example, you should be looking for the path with least dereferences.\n </p>\n <p>\n  Instead of a function you can look for a construct that points to the function you're looking for (if that function is used in a function pointer).\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "NirIzr",
            "time": "Oct 28, 2016 at 17:20",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I mangaged to solve it using pefile and capstone. Finding a exported function that leads to my target (as suggested above) and then using capstone to disassemble the function and find my way to the target.\n </p>\n <p>\n  In a nutshell what I did (can of course be beautified etc.):\n </p>\n <pre><code>import sys\nimport pefile\nfrom capstone import Cs, CS_ARCH_X86, CS_MODE_32\n\ndll = pefile.PE(sys.argv[1])\n#dll = pefile.PE('C:\\Program Files\\Common Files\\microsoft shared\\VBA\\VBA7\\VBE7.DLL')\n\n\nfor export in dll.DIRECTORY_ENTRY_EXPORT.symbols:\n    if export.name == 'rtcInStrChar':\n        exp_addr = export.address\n        break\n\nfor imp in dll.DIRECTORY_ENTRY_IMPORT:\n    for entry in imp.imports:\n        if entry.name == 'SysFreeString':\n            imp_addr = entry.address\n            break\n            #print('0x%x - %s' % (entry.address, entry.name))\n\nmemory = dll.get_memory_mapped_image()\n\ndsm = Cs(CS_ARCH_X86, CS_MODE_32)\n\nfor op in dsm.disasm(memory[exp_addr:exp_addr + 0xA0], (exp_addr + dll.OPTIONAL_HEADER.ImageBase)):\n    if op.mnemonic == 'call':\n        last_call = op.op_str[2:]\n    if op.mnemonic == 'ret':\n        break\n    #print(\"0x%x:\\t%s\\t%s\" %(op.address, op.mnemonic, op.op_str))\n\nnext_func = int(last_call, 16) - dll.OPTIONAL_HEADER.ImageBase\n\ncalls = 0\ncall_free = 0\nfor op in dsm.disasm(memory[next_func:next_func + 0x100], (next_func + dll.OPTIONAL_HEADER.ImageBase)):\n    print(\"0x%x:\\t%s\\t%s\" %(op.address, op.mnemonic, op.op_str))\n    if op.mnemonic == 'call' and '0x%x' % imp_addr in op.op_str:\n        call_free += 1\n    if call_free == 2:\n        print('GOT IT: 0x%x' % last_call)\n        break\n    if op.mnemonic == 'call':\n        last_call = op.address\n</code></pre>\n</div>\n</body></html>",
            "votes": "0",
            "user": "user17903",
            "time": "Oct 29, 2016 at 16:17",
            "is_accepted": true,
            "comments": []
        }
    ]
}