{
    "title": "J1939 message payload checksum",
    "link": "https://reverseengineering.stackexchange.com/questions/31666/j1939-message-payload-checksum",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am attempting to reverse engineer some proprietary J1939 CAN traffic so that I can remotely control some actions on a vehicle. I have collected a number of traces covering the events I want to control and have identified the controlling messages for several, but the payloads have some kind of authentication/checksum that I have not been able to figure out and was hoping someone might recognize what is going on.\n </p>\n <p>\n  I have so far attempted some different things like summing set bits (both data and ID) and a few quick CRC calculators, but I haven't had any luck. This is outside of my normal skillset, so apologies if there is something obvious I'm missing.\n </p>\n <p>\n  The checksums are in the last (8th) byte of the message payloads. There is appears to be a message counter used in the calculation as the value increments without any changes to the other data bytes. From what I can tell, the lower nibble increments by one each message and then resets on overflow.\n </p>\n <p>\n  The upper nibble also increments (though with only three bits), but the value will change with the payload. The counter also skips a value each iteration. The value is different between the two iterations that complete before the lower nibble overflows, but appears to increment by one the second iterations UNLESS the number skipped is 7, in which case both 7 and 0 are skipped. Note that I am not certain that the 7/0 skip is consistent across payloads nor if it is the only time multiple digits are skipped.\n </p>\n <p>\n  I have provided some data samples below (I have others I can provide) with specific notes immediately before them. If anyone recognizes this pattern or if there is anything to clarify or data to look for, please let me know!\n </p>\n <h3>\n  Data Samples\n </h3>\n <p>\n  This sample illustrates the behavior of both nibbles of the checksum byte. This pattern repeats until one of the other data bytes changes. Of note is that message 0x0CFF9\n  <strong>\n   7\n  </strong>\n  80 has the exact same checksum value and data bytes during this sample EXCEPT for byte 7, which is 0x39 instead of 0x00 (e.g., the first message is\n  <code>\n   0CFF9780  E8 03 E8 03 00 64 39 10\n  </code>\n  ). This appears to be a coincidence as the checksums do differ with different payloads (see following sample).\n </p>\n <pre><code>J1939_ID  Data_bytes-------------\n0CFF9880  E8 03 E8 03 00 64 00 10\n0CFF9880  E8 03 E8 03 00 64 00 21\n0CFF9880  E8 03 E8 03 00 64 00 32\n0CFF9880  E8 03 E8 03 00 64 00 53\n0CFF9880  E8 03 E8 03 00 64 00 64\n0CFF9880  E8 03 E8 03 00 64 00 75\n0CFF9880  E8 03 E8 03 00 64 00 06\n0CFF9880  E8 03 E8 03 00 64 00 17\n0CFF9880  E8 03 E8 03 00 64 00 28\n0CFF9880  E8 03 E8 03 00 64 00 39\n0CFF9880  E8 03 E8 03 00 64 00 4A\n0CFF9880  E8 03 E8 03 00 64 00 6B\n0CFF9880  E8 03 E8 03 00 64 00 7C\n0CFF9880  E8 03 E8 03 00 64 00 0D\n0CFF9880  E8 03 E8 03 00 64 00 1E\n0CFF9880  E8 03 E8 03 00 64 00 2F\n</code></pre>\n <p>\n  This sample is the data for 0x0CFF9780 after its data bytes (bytes 3 and 4) change from the above sample. The data for 0x0Cff9880 is the same as the first sample during this time frame.\n </p>\n <pre><code>J1939_ID  Data_bytes-------------\n0CFF9780  E8 03 D0 07 00 64 39 30\n0CFF9780  E8 03 D0 07 00 64 39 41\n0CFF9780  E8 03 D0 07 00 64 39 52\n0CFF9780  E8 03 D0 07 00 64 39 63\n0CFF9780  E8 03 D0 07 00 64 39 74\n0CFF9780  E8 03 D0 07 00 64 39 05\n0CFF9780  E8 03 D0 07 00 64 39 16\n0CFF9780  E8 03 D0 07 00 64 39 37\n0CFF9780  E8 03 D0 07 00 64 39 48\n0CFF9780  E8 03 D0 07 00 64 39 59\n0CFF9780  E8 03 D0 07 00 64 39 6A\n0CFF9780  E8 03 D0 07 00 64 39 7B\n0CFF9780  E8 03 D0 07 00 64 39 0C\n0CFF9780  E8 03 D0 07 00 64 39 1D\n0CFF9780  E8 03 D0 07 00 64 39 2E\n0CFF9780  E8 03 D0 07 00 64 39 4F\n</code></pre>\n <p>\n  This sample captures the upper nibble skipping both 7 and 0 on its second iteration.\n </p>\n <pre><code>J1939_ID  Data_bytes-------------\n18FF9980  03 00 00 00 00 00 00 32\n18FF9980  03 00 00 00 00 00 00 43\n18FF9980  03 00 00 00 00 00 00 54\n18FF9980  03 00 00 00 00 00 00 75\n18FF9980  03 00 00 00 00 00 00 06\n18FF9980  03 00 00 00 00 00 00 17\n18FF9980  03 00 00 00 00 00 00 28\n18FF9980  03 00 00 00 00 00 00 39\n18FF9980  03 00 00 00 00 00 00 4A\n18FF9980  03 00 00 00 00 00 00 5B\n18FF9980  03 00 00 00 00 00 00 6C\n18FF9980  03 00 00 00 00 00 00 1D\n18FF9980  03 00 00 00 00 00 00 2E\n18FF9980  03 00 00 00 00 00 00 3F\n18FF9980  03 00 00 00 00 00 00 10\n18FF9980  03 00 00 00 00 00 00 21\n</code></pre>\n <p>\n  These are two separate samples that are minor variations of the above sample that only have byte 1 change value.\n </p>\n <pre><code>J1939_ID  Data_bytes-------------\n18FF9980  11 00 00 00 00 00 00 20\n18FF9980  11 00 00 00 00 00 00 31\n18FF9980  11 00 00 00 00 00 00 42\n18FF9980  11 00 00 00 00 00 00 53\n18FF9980  11 00 00 00 00 00 00 64\n18FF9980  11 00 00 00 00 00 00 75\n18FF9980  11 00 00 00 00 00 00 06\n18FF9980  11 00 00 00 00 00 00 27\n18FF9980  11 00 00 00 00 00 00 38\n18FF9980  11 00 00 00 00 00 00 49\n18FF9980  11 00 00 00 00 00 00 5A\n18FF9980  11 00 00 00 00 00 00 6B\n18FF9980  11 00 00 00 00 00 00 7C\n18FF9980  11 00 00 00 00 00 00 0D\n18FF9980  11 00 00 00 00 00 00 1E\n18FF9980  11 00 00 00 00 00 00 3F\n\n18FF9980  01 00 00 00 00 00 00 70\n18FF9980  01 00 00 00 00 00 00 01\n18FF9980  01 00 00 00 00 00 00 12\n18FF9980  01 00 00 00 00 00 00 23\n18FF9980  01 00 00 00 00 00 00 34\n18FF9980  01 00 00 00 00 00 00 45\n18FF9980  01 00 00 00 00 00 00 56\n18FF9980  01 00 00 00 00 00 00 77\n18FF9980  01 00 00 00 00 00 00 08\n18FF9980  01 00 00 00 00 00 00 19\n18FF9980  01 00 00 00 00 00 00 2A\n18FF9980  01 00 00 00 00 00 00 3B\n18FF9980  01 00 00 00 00 00 00 4C\n18FF9980  01 00 00 00 00 00 00 5D\n18FF9980  01 00 00 00 00 00 00 6E\n18FF9980  01 00 00 00 00 00 00 1F\n</code></pre>\n <p>\n  Finally, this is one long sample that has a number of byte changes in it. Note that, unlike previous samples, this one does NOT repeat.\n </p>\n <pre><code>J1939_ID  Data_bytes-------------\n0CFF9880 E8 03 E8 03 00 64 00 10\n0CFF9880 E8 03 E8 03 00 64 00 21\n0CFF9880 E8 03 E8 03 00 64 00 32\n0CFF9880 52 04 71 03 00 64 00 73\n0CFF9880 52 04 71 03 00 64 00 04\n0CFF9880 52 04 71 03 00 64 00 15\n0CFF9880 52 04 71 03 00 64 00 26\n0CFF9880 52 04 71 03 00 64 00 47\n0CFF9880 52 04 71 03 00 64 00 58\n0CFF9880 52 04 71 03 00 64 00 69\n0CFF9880 79 05 B4 03 00 64 00 1A\n0CFF9880 10 06 CF 03 00 64 00 2B\n0CFF9880 10 06 CF 03 00 64 00 3C\n0CFF9880 47 06 CF 03 00 64 00 3D\n0CFF9880 47 06 CF 03 00 64 00 4E\n0CFF9880 47 06 CF 03 00 64 00 5F\n0CFF9880 47 06 CF 03 00 64 00 40\n0CFF9880 47 06 CF 03 00 64 00 51\n0CFF9880 47 06 CF 03 00 64 00 72\n0CFF9880 6C 06 CF 03 00 64 00 23\n0CFF9880 6C 06 CF 03 00 64 00 34\n0CFF9880 6C 06 CF 03 00 64 00 55\n0CFF9880 8B 06 CF 03 00 64 00 16\n0CFF9880 8B 06 CF 03 00 64 00 27\n0CFF9880 8B 06 CF 03 00 64 00 38\n0CFF9880 8B 06 CF 03 00 64 00 49\n0CFF9880 8B 06 CF 03 00 64 00 5A\n0CFF9880 AA 06 CF 03 00 64 00 6B\n0CFF9880 AA 06 CF 03 00 64 00 7C\n0CFF9880 AA 06 CF 03 00 64 00 0D\n0CFF9880 AA 06 CF 03 00 64 00 1E\n0CFF9880 CA 06 CF 03 00 64 00 7F\n</code></pre>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "1k",
    "tags": [
        "automation",
        "software-security",
        "checksum",
        "communication"
    ],
    "user": "tranzallos",
    "time": "Mar 13, 2023 at 16:37",
    "comments": [
        {
            "user": "MerseyViking",
            "text": "<html><body><span class=\"comment-copy\">\n It doesn't look like a checksum to me, more like two sequences. One device would transmit a message with a sequence number in one nibble, and the replying device responds with the next number, and it's own sequence number in the other nibble. Missing ones could be dropped packets or out-of-sequence packets that get filtered out.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Found the calculation in a newer version of the J1939 standard than I originally had access to. The manufacturer reused the following equation from SPN 4207:\n </p>\n <pre><code>Checksum = \n(Byte1 + Byte2 + Byte3 + Byte4 + Byte5 + Byte6 + Byte7 + \nmessage counter & 0x0F + \nmessage ID low byte + message ID mid low byte + message ID mid high byte + message ID high byte)\n\nMessage Checksum = (((Checksum >> 6) & 0x03) + (Checksum >>3) + Checksum) & 0x07\n</code></pre>\n</div>\n</body></html>",
            "votes": "3",
            "user": "tranzallos",
            "time": "Apr 19, 2023 at 13:24",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Dhoop",
                    "text": "<span class=\"comment-copy\">How can the checksum be greater than 0x07 since the very last operation is &amp; 0x07?</span>",
                    "time": null
                }
            ]
        }
    ]
}