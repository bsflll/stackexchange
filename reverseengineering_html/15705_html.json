{
    "title": "Reverse engineering unknown RS232/UART binary protocol",
    "link": "https://reverseengineering.stackexchange.com/questions/15705/reverse-engineering-unknown-rs232-uart-binary-protocol",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <h1>\n  Background story\n </h1>\n <p>\n  For couple of days I'm trying to crack the protocol used the old medical device, in order to collect data for a research in an automated way.\n </p>\n <p>\n  The device in question is\n  <strong>\n   Novametrix CO2SMO Plus\n  </strong>\n  , model\n  <strong>\n   8100\n  </strong>\n  . Manufacturer of this device was bought, long time ago, by Respironics and than Respironcis was bought by Philips. Their website doesn't exists for last 12-14 years and archived copy doesn't have any useful information. Since device was designed before 2000 there's no software over the Internet - it was distributed on floppy disks so as software updates.\n </p>\n <p>\n  Device is very similar to model 7100, which was released ~3 years prior to the 8100. Devices mainly differ in software - the one in 8100 is much more sophisticated.\n </p>\n <h1>\n  Physical layer\n </h1>\n <p>\n  At first I stared from obvious things like determining physical layer of the connection - that went easy, since\n  <a href=\"http://www.frankshospitalworkshop.com/equipment/documents/pulse_oximeter/service_manuals/Novametrix_8100_-_Service_manual.pdf\" rel=\"nofollow noreferrer\">\n   service manual\n  </a>\n  actually lists all signals in DB25, located on the back of the device.\n </p>\n <p>\n  At the beginning I hoped 8100 will use similar, well documented by manufacturer, ASCII protocol (called\n  <code>\n   NOVACOM1\n  </code>\n  ) as 7100 used. Unfortunately it's not the case. My device uses newer protocol called\n  <code>\n   NOVACOM3\n  </code>\n  - there's zero information about it in the Internet; it seems like\n  <code>\n   NOVACOM2\n  </code>\n  was never released.\n </p>\n <p>\n  I don't own oscilloscope (and I don't have an access to electronics labs on my college), so I determined baudrate of the port just observing the traffic with different baudrates with debugging mode enabled on device (more on that later). With high confidence I can say it's 9600 8N1 (like in previous model).\n </p>\n <p>\n  Device uses\n  <a href=\"http://www.nxp.com/products/microcontrollers-and-processors/more-processors/coldfire-plus-coldfire-32-bit-mcus/68k-processors-legacy/m683xx/32-bit-microcontroller:MC68332\" rel=\"nofollow noreferrer\">\n   NXP MC68332 MCU\n  </a>\n  , which according to the data sheet is a rugged 32 bit core with quite a few subunits useful in an automotive applications. It also seems to be a secure one - since I have almost no experience in EE I quickly dismissed any possibilities to attempt of physically attacking the CPU.\n </p>\n <h1>\n  PC software\n </h1>\n <p>\n  According to the service manual, manufacturer had developed PC software used for communication with the device -\n  <em>\n   \"CO2SMO Plus! for Windows\"\n  </em>\n  . Unfortunately it was sold as a separate package and it's nowhere to be found now.\n </p>\n <h1>\n  Diagnostic protocol\n </h1>\n <p>\n  The device has two Novametrix protocols -\n  <code>\n   NOVACOM3\n  </code>\n  and\n  <code>\n   SATDIAG\n  </code>\n  . Since diagnostic protocols are usually simpler I started from the later one:\n </p>\n <ul>\n  <li>\n   SATDIAG streams data continuously\n  </li>\n  <li>\n   Protocol, besides sending data to the computer, contains some unknown upload mode for firmware update (probably some XMODEM or so... I don't have firmeware blob, so obviously I didn't played with this)\n  </li>\n  <li>\n   After analysis I can say with high confidence each packet begins with\n   <code>\n    0x00\n   </code>\n   and ends with\n   <code>\n    0x0A\n   </code>\n   (LF)\n  </li>\n  <li>\n   Protocol streams packets few times a second (I didn't conducted any measurements on that, but it's 15-20/s)\n  </li>\n  <li>\n   Device alternates between sending 9 and 25 bytes (including 2B of header and footer) packets\n  </li>\n  <li>\n   Every few of seconds 41 bytes packet is transmitted\n  </li>\n  <li>\n   Most probably no checksum is used (the same payloads contain different last byte, I also calculated popular checksums for few)\n  </li>\n  <li>\n   Protocol seems to be aimed strictly for collecting performance data, some sort of resources usage or represents unknown internal state -  changes in measurements aren't causing any notable changes in packets. I also tried manually searching for numbers similar to these displayed by the device - no luck.\n  </li>\n </ul>\n <p>\n  In summary\n  <code>\n   SATDIAG\n  </code>\n  seems to be more like a debugger dumping some performance metrics or resources usage.\n </p>\n <h1>\n  Control protocol\n </h1>\n <p>\n  Next I started playing with the protocol used to talk to the PC software - NOVACOM3:\n </p>\n <ul>\n  <li>\n   The protocol follows request-response pattern\n  </li>\n  <li>\n   In order to display live waveforms protocol has to contain continuous mode which just streams data without additional queries:\n   <em>\n    that is what I want to get\n   </em>\n  </li>\n  <li>\n   By sending different characters I determined that\n   <code>\n    0x00\n   </code>\n   marks end of the packet. There's no signs of any character marking beginning the the packets.\n  </li>\n  <li>\n   It looks like device expects (some?) packets to be 8 bytes (including trailing\n   <code>\n    NULL-BYTE\n   </code>\n   ) long - while sending different lengths terminated by\n   <code>\n    0x00\n   </code>\n   I see for 8 bytes device is consistent with replying with 2 bytes.\n  </li>\n  <li>\n   Seems to have no checksum - I've got different 2 bytes responses with the same first byte and different 2nd\n  </li>\n  <li>\n   Response packets seems to have no length defined\n  </li>\n  <li>\n   Sending multiple\n   <code>\n    0x00\n   </code>\n   seems to \"zero\" the device input buffer - while I was playing with determining length sending 3-4\n   <code>\n    0x00\n   </code>\n   was causing device to behave consistently.\n  </li>\n  <li>\n   Sending multiple\n   <code>\n    0x00\n   </code>\n   generates no response\n  </li>\n  <li>\n   Protocol may have some blocks of commands: while I started scanning by sending 1 byte +\n   <code>\n    0x00\n   </code>\n   I've got no response for 7 bytes after each of the bytes:\n   <code>\n    0x10\n   </code>\n   ,\n   <code>\n    0x30\n   </code>\n   ,\n   <code>\n    0x50\n   </code>\n   ,\n   <code>\n    0x70\n   </code>\n   ,\n   <code>\n    0x90\n   </code>\n   ,\n   <code>\n    0xb0\n   </code>\n   ,\n   <code>\n    0xd0\n   </code>\n   ,\n   <code>\n    0xf0\n   </code>\n  </li>\n  <li>\n   All responses which I was able to get were 2 bytes or 4 bytes (and the longer ones seem to be 2 packets actually). Each packet was started with\n   <code>\n    0x2A\n   </code>\n  </li>\n  <li>\n   The only responses o was able to get were:\n   <code>\n    {0x2A, 0xA0}\n   </code>\n   ,\n   <code>\n    {0x2A, 0xA1}\n   </code>\n   ,\n   <code>\n    {0x2A, 0x80}\n   </code>\n  </li>\n  <li>\n   The packet\n   <code>\n    {0x2A, 0x80}\n   </code>\n   may actually be some sort of ACK, since a lot of times I had to wait for second packet for a 1-1.5s when responses were 4 bytes long.\n  </li>\n  <li>\n   <code>\n    0x20\n   </code>\n   (space) /\n   <code>\n    0x40\n   </code>\n   (@) /\n   <code>\n    0x60\n   </code>\n   seems to be a white character - sending it followed by 0x00 leads to no response. These characters are also very common in SATDIAG.  It's a little bit suspicious that they're spaced so evenly 20-40-60. Now while writing this I think it might be some connection with the ranges described few points before (10-30-50-70-90-...)\n  </li>\n </ul>\n <h1>\n  I'm stucked...\n </h1>\n <p>\n  I wasn't able to force device to start streaming - if I would manage to do that figuring out parameters shouldn't be that hard, since I have the display on the unit and I know which parameters to expect. Until than... I have no idea how to progress further. I also tried contacting Philips division which bought the company - no response whatsoever.\n </p>\n <p>\n  Any ideas?\n </p>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 0,
    "views": "2k",
    "tags": [
        "hardware",
        "embedded",
        "serial-communication",
        "protocol"
    ],
    "user": "kiler129",
    "time": "Jun 28, 2017 at 5:03",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<html><body><span class=\"comment-copy\">\n are the flash chips soldered or socketed? I would suggest dumping them to extract the firmware, from which you can RE the protocol details.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "kiler129",
            "text": "<html><body><span class=\"comment-copy\">\n @IgorSkochinsky: I just opened the device. Besides the fact it's built like a tank everything is in sockets (even polyfuses!). It has two 2Mbit AT29C020-12JC memory chips, and according to ten service manual they're both occupied by the software. However I have no idea how to read them (without breaking the bank) nor how to analyze the software for this CPU.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Antonio Quevedo",
            "text": "<html><body><span class=\"comment-copy\">\n I found out your question while searching for the CO2SMO protocol. In the next few days, I will try and run it with the original software, while running a serial data logger in the computer. Then I will check the results, and maybe we can crack the protocol together. Cheers Antonio\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}