{
    "title": "IDA PRO repairing stack variables / local variables hex-rays with arrays and proper types / structures any scripts/plugins?",
    "link": "https://reverseengineering.stackexchange.com/questions/4117/ida-pro-repairing-stack-variables-local-variables-hex-rays-with-arrays-and-pro",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  IDA PRO's Hex-Ray gives me these variables.\n </p>\n <pre><code>  void *v7; // esp@1\n  const char *v8; // ebx@1\n  PLAYER *v9; // ebp@1\n  int v10; // edi@5\n  PLAYER *v11; // edx@6\n  int v12; // ecx@9\n  int v13; // esi@17\n  int v14; // eax@33\n  const char v15; // al@36\n  const char *v16; // ebx@45\n  PLAYER *v17; // eax@50\n  int v18; // esi@51\n  const CHAR *v19; // ecx@54\n  int v20; // edx@56\n  unsigned int v21; // eax@61\n  signed int v22; // ebx@61\n  ARENA *v23; // eax@63\n  ARENA *v24; // edx@63\n  int v25; // ecx@63\n  int v26; // esi@64\n  signed int v27; // edi@65\n  int v28; // eax@66\n  ARENA *v29; // ecx@66\n  int v30; // esi@69\n  int v31; // edi@71\n  int v32; // esi@71\n  signed int v33; // ecx@74\n  int v34; // eax@75\n  const CHAR *v35; // edi@78\n  signed int v36; // ecx@78\n  signed int v37; // ecx@81\n  const void *v38; // esi@81\n  const CHAR *v39; // edi@81\n  unsigned int v40; // edx@81\n  signed int v41; // ecx@81\n  const char v42; // al@89\n  const char *v43; // ebx@89\n  const char v44; // al@90\n  const char v45; // al@96\n  const char *v46; // ebx@96\n  const char v47; // al@97\n  const char v48; // al@103\n  const char *v49; // ebx@103\n  const char v50; // al@104\n  int v51; // ebx@107\n  const char *v52; // edx@108\n  unsigned int v53; // kr48_4@108\n  unsigned int v54; // kr50_4@108\n  const char *v55; // edi@108\n  unsigned int v56; // kr58_4@110\n  const char *v57; // esi@110\n  const char *v58; // edi@110\n  int v59; // ecx@110\n  bool v60; // zf@110\n  int v61; // edi@121\n  int i; // esi@121\n  const char *v63; // eax@122\n  signed int v64; // esi@126\n  const char *v65; // ebx@134\n  PLAYER *v66; // eax@140\n  int v67; // edx@141\n  int v68; // ecx@141\n  PLAYER *v69; // eax@146\n  int v70; // edx@147\n  int v71; // ecx@147\n  const CHAR v72; // cl@153\n  int v73; // eax@153\n  const CHAR *j; // edx@153\n  char v75; // cl@156\n  const CHAR v76; // cl@157\n  int v77; // eax@157\n  const CHAR *k; // edx@157\n  char v79; // cl@160\n  const CHAR v80; // cl@161\n  int v81; // eax@161\n  const CHAR *l; // edx@161\n  char *v83; // eax@163\n  const CHAR v84; // al@171\n  int v85; // esi@171\n  const CHAR *m; // ecx@171\n  char v87; // al@174\n  const CHAR v88; // al@175\n  int v89; // esi@175\n  const CHAR *n; // ecx@175\n  const CHAR v91; // al@180\n  int v92; // esi@180\n  const CHAR *ii; // ecx@180\n  const char *v94; // ebx@189\n  const char v95; // al@200\n  const char *v96; // ebx@200\n  const char v97; // al@201\n  ARENA *v98; // eax@204\n  unsigned int v99; // kr68_4@208\n  int v100; // edi@208\n  PLAYER **v101; // ebx@209\n  int v102; // ebx@215\n  PLAYER *v103; // ecx@217\n  __int64 v104; // qax@218\n  int v105; // ecx@218\n  __int64 v106; // qax@218\n  int v107; // ST24_4@218\n  __int64 v108; // qax@218\n  PLAYER *v109; // esi@223\n  int v110; // ST24_4@224\n  int v111; // ST1C_4@224\n  int v112; // ST18_4@224\n  char *v113; // eax@224\n  ARENA *v114; // eax@226\n  signed int v115; // ecx@228\n  int v116; // eax@228\n  ENCRYPTION *v117; // ecx@230\n  int v118; // edi@230\n  int v119; // edx@233\n  int v120; // edi@233\n  unsigned __int64 v121; // st7@233\n  DWORD v122; // eax@235\n  int v123; // ecx@235\n  DWORD v124; // eax@237\n  unsigned __int64 v125; // st7@237\n  int v126; // ecx@237\n  int v127; // edx@239\n  DWORD v128; // edi@239\n  time_t v129; // ST20_8@242\n  signed __int64 v130; // qax@242\n  signed int v131; // edi@242\n  __int64 v132; // qax@243\n  __int64 v133; // ST20_8@243\n  signed int v134; // ecx@243\n  __int64 v135; // ST18_8@243\n  int v136; // ecx@247\n  PLAYER *v137; // eax@268\n  int v138; // ecx@269\n  const char v139; // al@276\n  const char *v140; // edi@276\n  const char v141; // al@277\n  const char v142; // al@279\n  __int16 v143; // ax@284\n  PLAYER *v144; // edi@289\n  ARENA *v145; // eax@292\n  int v146; // ecx@292\n  signed int v147; // edx@293\n  PLAYER *v148; // eax@294\n  ARENA *v149; // eax@296\n  int v150; // ecx@296\n  signed int v151; // edx@297\n  PLAYER *v152; // eax@298\n  PLAYER *v153; // eax@308\n  char *v154; // eax@309\n  const char v155; // al@312\n  const char *v156; // edi@312\n  const char v157; // al@313\n  ARENA *v158; // eax@318\n  unsigned int v159; // kr88_4@320\n  const char v160; // al@323\n  const char *v161; // edi@323\n  const char v162; // al@324\n  const char v163; // al@330\n  const char *v164; // edi@330\n  const char v165; // al@331\n  int v166; // eax@336\n  __int16 v167; // ax@342\n  PLAYER *v168; // esi@346\n  int v169; // edx@350\n  const char v170; // al@384\n  const char *v171; // edi@384\n  const char v172; // al@385\n  PLAYER *v173; // esi@392\n  int v174; // edx@397\n  PLAYER *v175; // esi@403\n  int v176; // edi@408\n  int v177; // eax@409\n  int v178; // esi@410\n  int v179; // eax@410\n  ARENA *v180; // ecx@413\n  int v181; // edi@415\n  ARENA **v182; // esi@416\n  PLAYER *v183; // ecx@423\n  int v184; // edi@427\n  PLAYER **v185; // esi@428\n  PLAYER *v186; // ecx@437\n  ARENA *v187; // ecx@443\n  FILE *v188; // eax@449\n  const char *v189; // edi@449\n  int v190; // ebx@451\n  int v191; // eax@451\n  FILE *v192; // eax@454\n  ARENA *v193; // eax@455\n  int v194; // esi@456\n  signed int v195; // edi@457\n  PLAYER *v196; // eax@458\n  const char *v197; // esi@461\n  int v198; // eax@461\n  signed int v199; // edi@463\n  int v200; // edx@471\n  time_t v201; // ST20_8@478\n  signed __int64 v202; // qax@478\n  signed int v203; // esi@478\n  signed int v204; // ecx@481\n  int v205; // edi@481\n  const char *v206; // esi@481\n  bool v207; // zf@481\n  const char *v208; // ebx@485\n  signed int v209; // ebx@490\n  char *v210; // eax@491\n  int v211; // ecx@491\n  int v212; // edi@494\n  signed int v213; // ecx@496\n  signed int v214; // ecx@499\n  const void *v215; // esi@499\n  const CHAR *v216; // edi@499\n  unsigned int v217; // edx@499\n  signed int v218; // ecx@499\n  const CHAR *v219; // edi@502\n  signed int v220; // ecx@502\n  signed int v221; // ecx@505\n  const void *v222; // esi@505\n  const CHAR *v223; // edi@505\n  unsigned int v224; // edx@505\n  signed int v225; // ecx@505\n  int v226; // ebx@516\n  signed int v227; // esi@516\n  ARENA *v228; // edx@520\n  int v229; // eax@520\n  int v230; // esi@520\n  int v231; // edi@520\n  int v232; // edx@520\n  int v233; // ecx@524\n  ARENA *v234; // eax@527\n  int v235; // edx@527\n  int v236; // ecx@527\n  __int16 v237; // ax@527\n  int v238; // eax@527\n  int v239; // ecx@527\n  int v240; // eax@527\n  int v241; // eax@540\n  ARENA *v242; // ecx@543\n  char *v243; // eax@543\n  char *v244; // edx@544\n  char *v245; // ebx@546\n  DWORD v246; // eax@546\n  ARENA *v247; // esi@547\n  char *v248; // esi@550\n  signed int v249; // ebp@554\n  int v250; // eax@557\n  int v251; // eax@562\n  signed int v252; // ecx@570\n  int v253; // edi@570\n  const char *v254; // esi@570\n  bool v255; // zf@570\n  int v256; // eax@575\n  const char *v257; // edx@578\n  ARENA *v258; // ecx@585\n  signed int v259; // ebx@586\n  PLAYER *v260; // ecx@587\n  signed int v261; // esi@587\n  __int64 v262; // qax@590\n  __int64 v263; // qax@591\n  int v264; // edi@602\n  signed int v265; // ecx@604\n  signed int v266; // ecx@607\n  const void *v267; // esi@607\n  const CHAR *v268; // edi@607\n  unsigned int v269; // edx@607\n  signed int v270; // ecx@607\n  const CHAR *v271; // edi@610\n  signed int v272; // ecx@610\n  signed int v273; // ecx@613\n  const void *v274; // esi@613\n  const CHAR *v275; // edi@613\n  unsigned int v276; // edx@613\n  signed int v277; // ecx@613\n  int v278; // edx@617\n  int v279; // ecx@621\n  int v280; // edx@638\n  char *v281; // ebx@638\n  unsigned int v282; // ebx@646\n  PLAYER *v283; // eax@646\n  signed int v284; // ecx@654\n  signed int v285; // ecx@658\n  signed int v286; // ecx@662\n  signed int v287; // ecx@671\n  int v288; // edi@671\n  const char *v289; // esi@671\n  bool v290; // zf@671\n  signed int v291; // ecx@675\n  int v292; // edi@675\n  const char *v293; // esi@675\n  bool v294; // zf@675\n  signed int v295; // ecx@682\n  int v296; // eax@683\n  const char v297; // al@688\n  const char *v298; // edi@688\n  const CHAR *jj; // ecx@688\n  const char v300; // al@691\n  const CHAR v301; // al@692\n  int v302; // edi@692\n  const CHAR *kk; // ecx@692\n  const char v304; // al@696\n  int *v305; // edi@704\n  int *v306; // esi@704\n  char v307; // al@707\n  int v308; // ecx@708\n  int v309; // edi@708\n  int v310; // esi@708\n  const char *v311; // eax@709\n  ARENA *v312; // edi@711\n  ARENA *v313; // ecx@718\n  int v314; // eax@718\n  int v315; // eax@723\n  __int64 v316; // qax@727\n  __int64 v317; // qax@728\n  __int64 v318; // qax@729\n  const char *v319; // ebx@730\n  int v320; // edi@737\n  char *v321; // ST1C_4@737\n  int v322; // esi@737\n  ARENA *v323; // eax@738\n  ARENA *v324; // eax@743\n  DWORD v325; // eax@748\n  int v326; // edx@749\n  PLAYER *v327; // esi@749\n  bool v328; // sf@749\n  ARENA **v329; // edi@750\n  ARENA *v330; // eax@751\n  int v331; // ebx@751\n  signed int v332; // esi@752\n  unsigned int v333; // krD8_4@774\n  ARENA **v334; // esi@775\n  int v335; // ebp@776\n  signed int v336; // edi@777\n  ARENA *v337; // edx@784\n  int v338; // esi@785\n  int v339; // ecx@785\n  const char *v340; // ecx@797\n  const char v341; // al@799\n  const CHAR *ll; // edx@799\n  const char v343; // al@803\n  const char v344; // al@804\n  const char *v345; // ecx@804\n  int v346; // eax@819\n  int v347; // eax@833\n  unsigned int v348; // krE8_4@836\n  int v349; // edi@836\n  PLAYER **v350; // ebp@837\n  char *v351; // [sp+4h] [bp-1608Ch]@668\n  const char *v352; // [sp+8h] [bp-16088h]@668\n  char *v353; // [sp+Ch] [bp-16084h]@52\n  char *v354; // [sp+Ch] [bp-16084h]@351\n  char *v355; // [sp+Ch] [bp-16084h]@598\n  char *v356; // [sp+Ch] [bp-16084h]@644\n  int v357; // [sp+Ch] [bp-16084h]@668\n  const char *v358; // [sp+10h] [bp-16080h]@52\n  const char *v359; // [sp+10h] [bp-16080h]@57\n  const char *v360; // [sp+10h] [bp-16080h]@218\n  const char *v361; // [sp+10h] [bp-16080h]@351\n  int v362; // [sp+10h] [bp-16080h]@525\n  const char *v363; // [sp+10h] [bp-16080h]@598\n  const char *v364; // [sp+10h] [bp-16080h]@644\n  int v365; // [sp+10h] [bp-16080h]@668\n  int v366; // [sp+14h] [bp-1607Ch]@52\n  char v367; // [sp+14h] [bp-1607Ch]@54\n  char v368; // [sp+14h] [bp-1607Ch]@218\n  int v369; // [sp+14h] [bp-1607Ch]@351\n  int v370; // [sp+14h] [bp-1607Ch]@525\n  int v371; // [sp+14h] [bp-1607Ch]@598\n  char *v372; // [sp+14h] [bp-1607Ch]@644\n  int v373; // [sp+14h] [bp-1607Ch]@668\n  time_t v374; // [sp+18h] [bp-16078h]@1\n  ARENA *a5[2]; // [sp+28h] [bp-16068h]@63\n  int v376; // [sp+30h] [bp-16060h]@69\n  int v377; // [sp+34h] [bp-1605Ch]@61\n  DWORD ExitCode; // [sp+38h] [bp-16058h]@233\n  char v379; // [sp+3Fh] [bp-16051h]@420\n  size_t Size; // [sp+40h] [bp-16050h]@69\n  int v381; // [sp+44h] [bp-1604Ch]@233\n  int v382; // [sp+48h] [bp-16048h]@69\n  int v383; // [sp+4Ch] [bp-16044h]@69\n  char v384; // [sp+50h] [bp-16040h]@527\n  __int16 v385; // [sp+51h] [bp-1603Fh]@527\n  int v386; // [sp+53h] [bp-1603Dh]@527\n  int v387; // [sp+57h] [bp-16039h]@527\n  __int16 v388; // [sp+5Bh] [bp-16035h]@527\n  __int16 v389; // [sp+5Dh] [bp-16033h]@527\n  int v390; // [sp+60h] [bp-16030h]@233\n  const CHAR KeyName; // [sp+64h] [bp-1602Ch]@157\n  const CHAR CommandLine; // [sp+84h] [bp-1600Ch]@52\n  char v393; // [sp+85h] [bp-1600Bh]@773\n  const CHAR Dest; // [sp+184h] [bp-15F0Ch]@69\n  __int16 v395; // [sp+185h] [bp-15F0Bh]@342\n  char v396; // [sp+187h] [bp-15F09h]@342\n  const CHAR Str1; // [sp+284h] [bp-15E0Ch]@153\n  const CHAR AppName; // [sp+2C4h] [bp-15DCCh]@76\n  int buf; // [sp+304h] [bp-15D8Ch]@45\n  char v400; // [sp+309h] [bp-15D87h]@208\n  char v401; // [sp+404h] [bp-15C8Ch]@255\n  char v402; // [sp+405h] [bp-15C8Bh]@255\n  char v403; // [sp+414h] [bp-15C7Ch]@255\n  CHAR StartupInfo[4]; // [sp+504h] [bp-15B8Ch]@163\n  int v405; // [sp+510h] [bp-15B80h]@309\n  char v406; // [sp+604h] [bp-15A8Ch]@741\n  char v407; // [sp+605h] [bp-15A8Bh]@741\n  char v408; // [sp+606h] [bp-15A8Ah]@741\n  __int16 v409; // [sp+607h] [bp-15A89h]@748\n  char v410; // [sp+609h] [bp-15A87h]@765\n  char v411; // [sp+804h] [bp-1588Ch]@638\n  char v412; // [sp+805h] [bp-1588Bh]@638\n  char v413; // [sp+2804h] [bp-1388Ch]@543\n  char Str; // [sp+2805h] [bp-1388Bh]@544\n  char v415; // [sp+2815h] [bp-1387Bh]@546\n  int v416; // [sp+16084h] [bp-Ch]@1\n  int (*v417)(); // [sp+16088h] [bp-8h]@1\n  int v418; // [sp+1608Ch] [bp-4h]@1\n  const char *Buf1b; // [sp+160A0h] [bp+10h]@485\n  const char *Buf1a; // [sp+160A0h] [bp+10h]@489\n</code></pre>\n <p>\n  I was told on email by a very skilled reverser how to handle this, I don't know if he wants me to say his/her name so I'll not say anything.\n  \n\n </p>\n <p>\n  But they said start doing repairs to arrays or structures starting at\n  <code>\n   [sp+####h]\n  </code>\n  and do calculations from that.\n </p>\n <p>\n  So the first part to start repairing is the since it begins with\n  <code>\n   [sp+#h]\n  </code>\n </p>\n <pre><code>char *v351; // [sp+4h] [bp-1608Ch]@668 \n</code></pre>\n <p>\n  Now you go down to\n </p>\n <pre><code>  char *v372; // [sp+14h] [bp-1607Ch]@644\n  int v373; // [sp+14h] [bp-1607Ch]@668\n  time_t v374; // [sp+18h] [bp-16078h]@1\n  ARENA *a5[2]; // [sp+28h] [bp-16068h]@63\n  int v376; // [sp+30h] [bp-16060h]@69\n</code></pre>\n <p>\n  So\n </p>\n <pre><code>  char *v372; // [sp+14h]                                      [0]\n  int v373; // [sp+14h]                     14-14 = 0 goes up  [4]\n  time_t v374; // [sp+18h] [bp-16078h]@1    18-14 = 4 goes up  [16]\n  ARENA *a5[2]; // [sp+28h] [bp-16068h]@63  28-18 = 16 goes up [8]\n  int v376; // [sp+30h] [bp-16060h]@69      30-28 = 8 goes up  [4]\n  int v377; // [sp+34h] [bp-1605Ch]@61       34-30 = 4 goes up  [ignored]\n</code></pre>\n <p>\n  So\n  <code>\n   0\n  </code>\n  would mean char? yet it's a pointer to a char (4 bytes)?, Probably shouldn't touch those\n  \n\n  The\n  <code>\n   4\n  </code>\n  after would be int which seems right.\n  \n\n  The\n  <code>\n   16\n  </code>\n  after looks like\n  <code>\n   2 x 8 bytes\n  </code>\n  .\n  \n\n  Since time_t could be 4 bytes or 8 bytes.\n  \n\n </p>\n <p>\n  I checked and time_t is defined as\n  \n\n </p>\n <pre><code>-00016080 var_16080       dd 6 dup(?)             ; offset\n</code></pre>\n <p>\n  So it thinks it's 4 bytes x 6 which would be 24 bytes? why does it think that? Yes I get that\n  <code>\n   var_16080\n  </code>\n  when I click on the\n  <code>\n   time_t\n  </code>\n </p>\n <p>\n  So this is where I get confused I think it's really 8 bytes and all I have to do is make it\n  <code>\n   time_t v374[2]\n  </code>\n </p>\n <p>\n  ARENA *a5[2]; looks right 2 pointers of 4 bytes. = 8 bytes and the int after looks right.\n </p>\n <p>\n  Can someone tell me how what to do in certain hard cases if I have to do it all manually I would do it..\n </p>\n <p>\n  But if there is a way to automate this I'd also appreciate that if anyone can tell me of a plugin or a script to do that.\n </p>\n <p>\n  Here is how I got it down to is it right?\n </p>\n <pre><code>  int v369; // [sp+14h] [bp-1607Ch]@351\n  int v370; // [sp+14h] [bp-1607Ch]@525\n  int v371; // [sp+14h] [bp-1607Ch]@598\n  char *v372; // [sp+14h] [bp-1607Ch]@644\n  int v373; // [sp+14h] [bp-1607Ch]@668\n  char v374[16]; // [sp+18h] [bp-16078h]@1\n  ARENA *a5[2]; // [sp+28h] [bp-16068h]@63\n  int v376; // [sp+30h] [bp-16060h]@69\n  int v377; // [sp+34h] [bp-1605Ch]@61\n  char ExitCode[7]; // [sp+38h] [bp-16058h]@233\n  char v379; // [sp+3Fh] [bp-16051h]@420\n  size_t Size; // [sp+40h] [bp-16050h]@69\n  int v381; // [sp+44h] [bp-1604Ch]@233\n  int v382; // [sp+48h] [bp-16048h]@69\n</code></pre>\n <p>\n  A bit lower you see this\n </p>\n <pre><code>  __int16 v385; // [sp+51h] [bp-1603Fh]@527                   2\n  int v386; // [sp+53h] [bp-1603Dh]@527               53-51 = 2 up [4]\n  int v387; // [sp+57h] [bp-16039h]@527               57-53 = 4 up [4]\n  __int16 v388; // [sp+5Bh] [bp-16035h]@527           5B-57 = 4 up [2]\n  __int16 v389; // [sp+5Dh] [bp-16033h]@527           5D-5B = 2 up [3] ???\n  int v390; // [sp+60h] [bp-16030h]@233               60-5D = 3 up\n</code></pre>\n <p>\n  Why is that one 3 bytes when it's a\n  <code>\n   __int16\n  </code>\n  or is it a\n  <code>\n   char[3]\n  </code>\n  ?\n </p>\n <p>\n  After I translated it to\n </p>\n <pre><code>  int v386; // [sp+53h] [bp-1603Dh]@527\n  int v387; // [sp+57h] [bp-16039h]@527\n  __int16 v388; // [sp+5Bh] [bp-16035h]@527\n  char v389[3]; // [sp+5Dh] [bp-16033h]@527\n  int v390; // [sp+60h] [bp-16030h]@233\n</code></pre>\n <p>\n  Now it does something like this in code, so it must of been\n  <code>\n   __int16\n  </code>\n  after all. Maybe it's a\n  <code>\n   __int16\n  </code>\n  followed by a\n  <code>\n   char\n  </code>\n  after, but you can't do that in Hex-Rays afaik.\n </p>\n <pre><code>                *(_WORD *)v389 = v236;\n</code></pre>\n <p>\n  Okay it's highly unpredictable and I don't think I can rely on the\n  <code>\n   [so+###h]\n  </code>\n  's too much just in some cases.\n </p>\n <p>\n  I managed to get it down to this, but it has problems all over the place\n </p>\n <p>\n  Trimmed off the top stuff that didn't change\n </p>\n <pre><code>  char *v351; // [sp+4h] [bp-1608Ch]@668\n  const char *v352; // [sp+8h] [bp-16088h]@668\n  char *v353; // [sp+Ch] [bp-16084h]@52\n  char *v354; // [sp+Ch] [bp-16084h]@351\n  char *v355; // [sp+Ch] [bp-16084h]@598\n  char *v356; // [sp+Ch] [bp-16084h]@644\n  int v357; // [sp+Ch] [bp-16084h]@668\n  const char *v358; // [sp+10h] [bp-16080h]@52\n  char *v359; // [sp+10h] [bp-16080h]@57\n  char *v360; // [sp+10h] [bp-16080h]@218\n  const char *v361; // [sp+10h] [bp-16080h]@351\n  int v362; // [sp+10h] [bp-16080h]@525\n  const char *v363; // [sp+10h] [bp-16080h]@598\n  const char *v364; // [sp+10h] [bp-16080h]@644\n  int v365; // [sp+10h] [bp-16080h]@668\n  int v366; // [sp+14h] [bp-1607Ch]@52\n  char v367; // [sp+14h] [bp-1607Ch]@54\n  char v368; // [sp+14h] [bp-1607Ch]@218\n  int v369; // [sp+14h] [bp-1607Ch]@351\n  int v370; // [sp+14h] [bp-1607Ch]@525\n  int v371; // [sp+14h] [bp-1607Ch]@598\n  char *v372; // [sp+14h] [bp-1607Ch]@644\n  int v373; // [sp+14h] [bp-1607Ch]@668\n  char v374[16]; // [sp+18h] [bp-16078h]@1\n  ARENA *a5[2]; // [sp+28h] [bp-16068h]@63\n  int v376; // [sp+30h] [bp-16060h]@69\n  int v377; // [sp+34h] [bp-1605Ch]@61\n  char ExitCode[7]; // [sp+38h] [bp-16058h]@233\n  char v379; // [sp+3Fh] [bp-16051h]@420\n  size_t Size; // [sp+40h] [bp-16050h]@69\n  int v381; // [sp+44h] [bp-1604Ch]@233\n  int v382; // [sp+48h] [bp-16048h]@69\n  int v383; // [sp+4Ch] [bp-16044h]@69\n  char v384; // [sp+50h] [bp-16040h]@527\n  __int16 v385; // [sp+51h] [bp-1603Fh]@527\n  int v386; // [sp+53h] [bp-1603Dh]@527\n  int v387; // [sp+57h] [bp-16039h]@527\n  __int16 v388; // [sp+5Bh] [bp-16035h]@527\n  char v389[3]; // [sp+5Dh] [bp-16033h]@527\n  int v390; // [sp+60h] [bp-16030h]@233\n  char array1[32]; // [sp+64h] [bp-1602Ch]@157\n  char array2[256]; // [sp+84h] [bp-1600Ch]@52\n  char Dest[256]; // [sp+184h] [bp-15F0Ch]@69\n  char Str1[64]; // [sp+284h] [bp-15E0Ch]@153\n  char AppName[64]; // [sp+2C4h] [bp-15DCCh]@76\n  char buf[512]; // [sp+304h] [bp-15D8Ch]@45\n  char StartupInfo[256]; // [sp+504h] [bp-15B8Ch]@163\n  char v398[512]; // [sp+604h] [bp-15A8Ch]@741\n  char v399[8192]; // [sp+804h] [bp-1588Ch]@638\n  char v400[80000]; // [sp+2804h] [bp-1388Ch]@543\n  int v401; // [sp+16084h] [bp-Ch]@1\n  int (*v402)(); // [sp+16088h] [bp-8h]@1\n  int v403; // [sp+1608Ch] [bp-4h]@1\n  const char *Buf1b; // [sp+160A0h] [bp+10h]@485\n  const char *Buf1a; // [sp+160A0h] [bp+10h]@489\n</code></pre>\n <p>\n  Seems all the array/buffers are only found at the bottom of all the variables all of them are buffers completely (maybe it's just the type of compiler / optimizer this program used).\n </p>\n <p>\n  I wonder what If it probably reuses all the buffers as just one big buffer?\n </p>\n</div>\n</body></html>",
    "votes": "5",
    "answers": 1,
    "views": "15k",
    "tags": [
        "ida",
        "ida-plugin",
        "local-variables",
        "stack-variables"
    ],
    "user": "SSpoke",
    "time": "Apr 22, 2014 at 9:16",
    "comments": [
        {
            "user": "w s",
            "text": "<html><body><span class=\"comment-copy\">\n Which DA version are you using ?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "SSpoke",
            "text": "<html><body><span class=\"comment-copy\">\n I use the IDA 6.1 version.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm not sure that it is possible to answer this question without seeing all the function because correctness of local variable type recovery can be done only by understanding of the context where variables are used.\n </p>\n <p>\n  However, I'd suggest the following algorithm for dealing with local variables \nin Hex-Rays:\n </p>\n <ol>\n  <li>\n   <p>\n    As your friend said, do nothing with variables allocated on the registers.\n   </p>\n  </li>\n  <li>\n   <p>\n    For all other variables allocated on the stack, do the following:\n   </p>\n  </li>\n  <li>\n   <p>\n    Look where this variable is used.\n   </p>\n  </li>\n  <li>\n   <p>\n    If you see one of patterns below, act accordingly, but press F5 after each change and review results. Remember, you can revert each type back by pressing Y and entering previous type on it.\n   </p>\n  </li>\n  <li>\n   <p>\n    If you see usage of some\n    <strong>\n     different\n    </strong>\n    offsets relative to this variable it may be a structure. Try to create one by right-click on the variable and choosing corresponding menu item. Usage of this variable as function parameter or other connections to already known types may give you a hint about type of the variable.\n   </p>\n  </li>\n  <li>\n   <p>\n    If you see not constant offsets (such as offset in another variable) it can be array. Press asterisk (*) on the variable, IDA will suggest the length of the array, it does it relatively good.\n   </p>\n  </li>\n  <li>\n   <p>\n    If you see both of those patterns, it is possibly array of structures or more complicated case like array of structures in structure which is member of array and vice versa :) In this case try to find a smallest structure/array and start with it.\n   </p>\n  </li>\n </ol>\n <p>\n  At all, there are the following possibilities to affect the function stack in Hex-Rays:\n </p>\n <ol>\n  <li>\n   Changing variable type (press y on the variable, enter type)\n  </li>\n  <li>\n   Making variable an array (press * on it)\n  </li>\n  <li>\n   Creating new structure\ntype on a variable basis (Right click on the variable, corresponding\nmenu item)\n  </li>\n  <li>\n   Undefining a variable: Doubleclick on stack variable\nwill open stack function stack window. Pressing u on a variable will\nundefine it.\n  </li>\n  <li>\n   Merging a variable: if you see that two different\nvariables are actually the same you can press = and tell to the\ndecompiler that they are really the same. AFAIR it works in IDA 6.5\nand IDA6.5\n  </li>\n </ol>\n <p>\n  Don't forget to refresh the decompiled code view by pressing F5 after each change to see results.\n </p>\n <p>\n  That's all.\n </p>\n <p>\n  By the way,  there is one point you are probably missing:\nIDA and HexRays can make more than one variable on the same place in stack, \nso v369, v370, v371, v372, v373 are using same place in the stack, but are different variables from decompiled code point of view.\n </p>\n</div>\n</body></html>",
            "votes": "7",
            "user": "w s",
            "time": "Apr 22, 2014 at 4:43",
            "is_accepted": true,
            "comments": [
                {
                    "user": "SSpoke",
                    "text": "<span class=\"comment-copy\">Yup I eliminated a bunch of those <code>v369, v370 v371 v372 v373</code> since it's just one array. I found the last gap in the [sp+###h] to be exactly 80000 bytes and I made it into a array. It's almost all right except for like a5[] seems to be pointer to a structure but in other area's it's set to value 1 casted to pointer which is not possible. Don't think I need to Press F5 everytime I change a variable it automatically re-decompiles it. Also guessing these local variables lead me to redo the project over at one point as it started to overwrite my rdata. Here full code: <a href=\"http://pastebin.com/4HdT0hdk\" rel=\"nofollow noreferrer\">pastebin.com/4HdT0hdk</a></span>",
                    "time": null
                },
                {
                    "user": "SSpoke",
                    "text": "<span class=\"comment-copy\">Here is my project too, <a href=\"https://www.mediafire.com/?qnqb00q4yk4kq6v\" rel=\"nofollow noreferrer\">mediafire.com/?qnqb00q4yk4kq6v</a> maybe you can run it under the 6.5 and give me the C file haha so I could use it as a reference sheet. I started fixing the C file in notepad not relying on IDA PRO which changes the stuff all over the place which I like but sometimes it just doesn't do right in one area after you do it right in another area kinda like one screws up the other nearly all the problems I encountered in this function <code>ChatProcesser()</code> the other is in the <code>PlayerHandleGamePacket()</code>. Now error <code>414850: could not find valid save-restore pair for edi</code></span>",
                    "time": null
                }
            ]
        }
    ]
}