{
    "title": "Reverse engineering checksum from RS-485 device",
    "link": "https://reverseengineering.stackexchange.com/questions/20686/reverse-engineering-checksum-from-rs-485-device",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Attempting to reverse-engineer a checksum for a serial timing device that updates a display. Protocol is partly understood, however the checksum calculation specified does not produce the expected value.\n </p>\n <p>\n  I would like to understand what is happening in this protocol, as I would like to write to the display with my own software and not just sniff the data.\n </p>\n <h1>\n  Known parameters:\n </h1>\n <ul>\n  <li>\n   RS-485 half duplex\n  </li>\n  <li>\n   8n1\n  </li>\n  <li>\n   DATA0...n transmitted unchanged, low nibbles are BCD (0-9)\n  </li>\n  <li>\n   <em>\n    (EDIT) this is likely not the case, as the spec I have does not seem to be the correct one. Disregard the following point.\n   </em>\n   ADDR byte and CSUM byte split into two bytes each, hi and lo nibbles might be split between the two bytes, however I'm confused as to why it appears that the ADDR byte is a start flag byte.\n  </li>\n  <li>\n   sub_ADDR matches the protocol specification, used to identify the data in the packet to a specific part of the display, and possibly to different displays\n  </li>\n  <li>\n   One-way communication\n   <em>\n    (EDIT) one-to-many master-slave likely\n   </em>\n  </li>\n  <li>\n   FEC appears to be \"repeat the message\" as all packets are immediately duplicated in the recorded stream, i.e. 1,1,2,2,3,3..etc.\n  </li>\n  <li>\n   Receiver likely \"pretends it never happened\" if packets are mangled as past data is irrelevant\n  </li>\n  <li>\n   <em>\n    (EDIT) All packets are of known length and the lengths do not change in the data set\n   </em>\n  </li>\n  <li>\n   <p>\n    <em>\n     (EDIT: CRITICAL INFO) Low nibbles of bytes labeled A3-A6 and B3-B6 represent digits 0-9 as BCD. A value of 0x0f would blank the digit on the display.\n    </em>\n    [1] Therefore:\n   </p>\n   <pre><code>0a 0c 02 00 60 00 80 0b -> \"20:00\"\n28 0c 02 00 60 00 80    -> \"20:00\"\n0a 0c 01 09 65 09 d8 0b -> \"19:59\"\n0a 0c 0f 09 65 09 80 0b -> \" 9:59\"\n</code></pre>\n  </li>\n  <li>\n   <em>\n    (EDIT) High nibbles of A3-A6 contain flag bits. Known flag bits include bit 6 in DATA2 (A5,B5) which indicates state == running, and bit 5 in DATA2 (A5,B5) which indicates colon == on.\n   </em>\n  </li>\n </ul>\n <p>\n  <strong>\n   First question:\n  </strong>\n  If the FEC is indeed \"repeat\", does it follow that the designer would incorporate a CSUM? Perhaps the packets that appear to be CSUM are something else not documented?\n </p>\n <hr/>\n <h2>\n  Packet format:\n </h2>\n <p>\n  as described in protocol spec, possibly incorrect or outdated.\n  <em>\n   (EDIT: the protocol spec does appear to be incorrect for my device. Corruption of the data is unlikely)\n  </em>\n </p>\n <p>\n  <strong>\n   \"X\"\n  </strong>\n  denotes a nibble that takes a value.\n  <strong>\n   \"?\"\n  </strong>\n  denotes a nibble that is used for flag bits.\n </p>\n <pre><code>| lo_ADDR | hi_ADDR | sub_ADDR | DATA_0 | DATA_1 | DATA_2 | DATA_3 | lo_CSUM | hi_CSUM |\n|   0x8X  |   0x9X  |   0x0c   |  0x?X  |  0x?X  |  0x?X  |  0x?X  |  0xAX   |   0xBX  |\n</code></pre>\n <p>\n  Some of the fields seem to match; others don't. As seen below, lo and hi ADDR and lo and hi CSUM don't seem to match the description.\n </p>\n <p>\n  Most packets in the stream appear to start with\n  <strong>\n   0x0a\n  </strong>\n  and end with\n  <strong>\n   0x0b\n  </strong>\n  , although some packets observed don't follow that pattern. Are they flag bytes?\n </p>\n <p>\n  An example of two packets of interest, bytes that work as specified marked\n  <strong>\n   ok\n  </strong>\n  , ones that don't with\n  <strong>\n   !k\n  </strong>\n </p>\n <pre><code>A1 A2 A3 A4 A5 A6 A7 A8     B1 B2 B3 B4 B5 B6 B7\n------------------------------------------------\n!k ok ok ok ok ok !k !k     !k ok ok ok ok ok !k\n0a 0c 02 00 60 00 80 0b     28 0c 02 00 60 00 80\n</code></pre>\n <p>\n  Straight from Pyserial, appears as follows:\n </p>\n <pre><code>b'\n\\x0c\\x02\\x00`\\x00\\x80\\x0b(\\x0c\\x02\\x00 \\x00\\x80'\n</code></pre>\n <p>\n  Ten lines of packets, two neighboring packets shown, repeats removed:\n  <em>\n   (edit: added more lines, formatting for clarity)\n  </em>\n </p>\n <pre><code>A1 A2 A3 A4 A5 A6 A7 A8          B1 B2 B3 B4 B5 B6 B7\n--------------------- state == running --------------\n----------------------(A3, B3 <= 0x09)---------------\n\n0a 0c 01 09 65 09 d8 0b .repeat. 28 0c 01 09 65 09 e0 .repeat. ...\n0a 0c 01 09 65 08 c0 0b ........ 28 0c 01 09 65 08 80 ...\n0a 0c 01 09 65 07 a8 0b ........ 28 0c 01 09 65 07 a0 ...\n0a 0c 01 09 65 06 90 0b ........ 28 0c 01 09 65 06 c0 ...\n0a 0c 01 09 65 05 f8 0b ........ 28 0c 01 09 65 05 e0 ...\n0a 0c 01 09 65 04 e0 0b ........ 28 0c 01 09 65 04 80 ...\n0a 0c 01 09 65 03 c8 0b ........ 28 0c 01 09 65 03 a0 ...\n0a 0c 01 09 65 02 b0 0b ........ 28 0c 01 09 65 02 c0 ...\n0a 0c 01 09 65 01 98 0b ........ 28 0c 01 09 65 01 e0 ...\n0a 0c 01 09 65 00 80 0b ........ 28 0c 01 09 65 00 80 ...\n0a 0c 01 09 64 09 e0 0b ........ 28 0c 01 09 64 09 80 ...\n0a 0c 01 09 64 08 80 0b ........ 28 0c 01 09 64 08 80 ...\n0a 0c 01 09 64 07 a0 0b ........ 28 0c 01 09 64 07 80 ...\n0a 0c 01 09 64 06 c0 0b ........ 28 0c 01 09 64 06 80 ...\n0a 0c 01 09 64 05 e0 0b ........ 28 0c 01 09 64 05 80 ...\n0a 0c 01 09 64 04 80 0b ........ 28 0c 01 09 64 04 80 ...\n0a 0c 01 09 64 03 a0 0b ........ 28 0c 01 09 64 03 80 ...\n0a 0c 01 09 64 02 c0 0b ........ 28 0c 01 09 64 02 80 ...\n0a 0c 01 09 64 01 e0 0b ........ 28 0c 01 09 64 01 80 ...\n0a 0c 01 09 64 00 80 0b ........ 28 0c 01 09 64 00 80 ...\n         ...                             ...\n0a 0c 01 09 64 04 a0 0b ........ 28 0c 01 09 63 04 80 ...\n         ...                             ...\n-------------------- state == stopped -------------------\n------------(high nibble A5, B5 0b110 -> 0b10)-----------\n------------(bit 6 in byte A5, B5 == flag bit)-----------\n\n0a 0c 01 09 23 04 a0 0b ........ 28 0c 01 09 23 04 80 ...\n         ...                             ...\n---------------- state == running | stopped -------------\n------------(if A3, B3 == 0x0f, then A7, B7 -> 80)-------\n------------(A3, B3 == 0x0f == no digit displayed)-------\n         ...                             ...\n0a 0c 0f ** ** ** 80 0b ........ 28 0c 0f ** ** ** 80 ...\n         ...                             ...\n</code></pre>\n <p>\n  <em>\n   0x0a << 2 == 0x28. Is that just coincidence? Or are some bits handled improperly?\n  </em>\n </p>\n <p>\n  It would appear that A7 and B7 are 8 bit CSUM values. However, when the following CSUM calculation is done as specified in the documentation:\n </p>\n <pre><code>CSUM = lo_ADDR ^ hi_ADDR ^ sub_ADDR ^ DATA_0 ^ DATA_1 ^ DATA_2 ^ DATA_3\n0x62 =   0xa   ^   0x0   ^   0x0c   ^  0x01  ^  0x09  ^  0x65  ^  0x09\n0x62 =   0x8   ^   0x2   ^   0x0c   ^  0x01  ^  0x09  ^  0x65  ^  0x09   \n</code></pre>\n <p>\n  The calculated value doesn't match A7 or B7. However:\n </p>\n <p>\n  <em>\n   \"The CSUM byte is then split into 2 bytes, 0xAX (low nibble) and 0xBX (high nibble)\"\n  </em>\n </p>\n <p>\n  I've tried\n  <a href=\"https://crccalc.com\" rel=\"nofollow noreferrer\">\n   https://crccalc.com\n  </a>\n  as well as others, thinking that the calculation in the specification is incorrect, however I can't get any matches on any 8-bit CSUMs that I've tried.\n </p>\n <p>\n  I think I'm missing something obvious, as I'm quite an amateur. I'm really trying to understand what's happening, where I've gone wrong, and not just get my problem solved. I'm now two days into trying to figure this out, and I just can't get it.\n </p>\n <p>\n  <strong>\n   Quesion two:\n  </strong>\n  Are those fields actually checksums, if they are, how are they calculated?\n </p>\n <p>\n  <strong>\n   Question three:\n  </strong>\n  If they're not, what are they?\n </p>\n <p>\n  <strong>\n   Question four:\n  </strong>\n  Why would some packets appear to be missing (or have a different) start and stop flag bytes?\n  <em>\n   (EDIT: Most likely because the specification I have is wrong)\n  </em>\n </p>\n <hr/>\n <p>\n  <em>\n   (EDIT) The CSUM calc in the spec does not apply to my data.\n  </em>\n </p>\n <p>\n  Check sum calculation spec, verbatim from documentation:\n </p>\n <pre><code>CSUM = LOW ADDR\nCSUM = CSUM XOR'ed with HIGH ADDR\nCSUM = CSUM XOR'ed with SUB ADDR\nCSUM = CSUM XOR'ed with Data0\n..\nCSUM = CSUM XOR'ed with DataN (the last data-byte)\nThe CSUM byte is then split into 2 byte, 0xAn (low nibble) and 0xBn (high nibble)\n</code></pre>\n <hr/>\n <p>\n  Some interesting patterns which seem to hold throughout my data set:\n </p>\n <ol>\n  <li>\n   if A3,B3 == 0x0f then A7,B7 == 0x80\n  </li>\n  <li>\n   High nibble A5,B5 == 0x6 | 0x2: change does not seem to affect A7,B7\n  </li>\n  <li>\n   if A6,B6 == 0x00 then A7,B7 == 0x80\n  </li>\n </ol>\n <hr/>\n <p>\n  <em>\n   (EDIT) UPDATE:\n  </em>\n  You know, the more I think about it and look around the internet, this system shares many similarities with DMX protocol. This system was made to work with many devices daisy-chained together.\n </p>\n <ol>\n  <li>\n   One-to-many connection, with termination required at the end\n  </li>\n  <li>\n   0x00 break on every line, similar to lo value inter-packet (line?) break, bursts of data about once a second\n  </li>\n  <li>\n   possibly no error correction at all\n  </li>\n  <li>\n   used to control a \"lighting\" device (7-segment display)\n  </li>\n  <li>\n   others ...?\n  </li>\n </ol>\n <hr/>\n <p>\n  [1] \"The Texas Instruments seven-segment display decoder chips 7446/7447/7448/7449 and 74246/74247/74248/74249 and the Siemens FLH551-7448/555-8448 chips used truncated versions of \"2\", \"3\", \"4\", \"5\" and \"6\" for digits Aâ€“E. Digit F (1111 binary) was blank.\" - wikipedia, 7-segment display\n </p>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 1,
    "views": "1k",
    "tags": [
        "serial-communication"
    ],
    "user": "r a",
    "time": "Mar 3, 2019 at 13:58",
    "comments": [
        {
            "user": "Bruce Abbott",
            "text": "<html><body><span class=\"comment-copy\">\n \"However, when the following CSUM calculation is done as specified in the documentation:\" - are you sure you interpreted it correctly? Can you show us the full specification?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Bruce Abbott",
            "text": "<html><body><span class=\"comment-copy\">\n The specified packet format has 9 bytes, but your packets only have 8 and 7 bytes. So where did the extra bytes go, and where are you getting hi_ADDR from? According the spec hi/low address bytes start with high nibbles 8/9 and hi/low checksum bytes start with A/B, but your data does not have this. Clearly the spec does not match your data, so either it's 'outdated' or the data is corrupt.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Igor Skochinsky",
            "text": "<html><body><span class=\"comment-copy\">\n do you have access to the code on either sending or receiving side? might be easier to RE it than trying to guess the algorithm.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "r a",
            "text": "<html><body><span class=\"comment-copy\">\n @BruceAbbott Yes, it would appear that the spec doesn't match. I'm pretty sure the data is not corrupt, I checked all the packets' duplicates and found no difference. The start and end bytes match on all subsequent packets, and the data inside DATA0...n matches the true values, which are known. I'll update the first post\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "r a",
            "text": "<html><body><span class=\"comment-copy\">\n @IgorSkochinsky I'll see if I can get the code used to record this stream. The source of the stream is a hardware device, used to drive 7-segment style dumb display.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The protocol spec clearly does not apply to your device, so don't bother trying to use its checksum calculation. However it may be similar enough to provide some clues to the actual protocol.\n </p>\n <p>\n  The protocol should include some method of synchronizing the serial data stream. In the (incorrect) spec this could be done using the high nibbles (8,9,A,B) that all have bit 7 set. In your data only bytes A7 and B7 have bit 7 set, which suggests that this bit is used for synchronization.\n </p>\n <p>\n  Bytes A4-A6 and B4-B6 appear to be digit and flag data. Bytes A2 and B2 match the fixed value for\n  <code>\n   sub_ADDR\n  </code>\n  in the spec, which suggests they perform the same function.\n </p>\n <p>\n  A1,A3,A8,B1,B3 and bits 6-0 of A7 and B7 are unaccounted for. A1,A3,B1,B3 may be the high and low address nibbles, and A8 appears to be a constant value. Bits 2-0 of A7 and bits 3-0 of B7 are always 0 in your data, which leaves bits 6-3 of A7 and bits 6-4 of B7 as potential checksum bits.\n </p>\n <p>\n  As the digits are different on each line, so the checksum should also be different (though some lines may produce the same checksum). Combining A7 bits 6-3 and B7 bits 6-4 to produce a single 7 bit Hex number,\n </p>\n <pre><code>A7   A7    B7   B7   B7+A7\n   (6..3)     (6.4)  (Hex) (ID#)\nd8  1011   e0  110    6B     1\nc0  1000   80  000    08     2\na8  0101   a0  010    25     3\n90  0010   c0  100    42     4\nf8  1111   e0  110    6F     5\ne0  1101   80  000    0B     6\nc8  1001   a0  010    29     7\nb0  1010   c0  100    4A     8\n98  0011   e0  110    63     9\n80  0000   80  000    00     10\ne0  1100   80  000    0C     11\n80  0000   80  000    00    (10)\na0  0100   80  000    04     12\nc0  1000   80  000    08     (2)\ne0  1100   80  000    0C    (11)\n80  0000   80  000    00    (10)\na0  0100   80  000    04    (12)\nc0  1000   80  000    08     (2)\ne0  1100   80  000    0C    (11)\n80  0000   80  000    00    (10)\n</code></pre>\n <p>\n  The first 11 lines in your data dump all have unique 'checksums'. Looking good so far!\n </p>\n <p>\n  The next 9 lines are not so good, as they have many duplicate values. However I have not attempted to calculate checksums of address and data bytes. Depending on the algorithm used, some lines may be expected to produce the same checksum.\n </p>\n <p>\n  For a thorough analysis I would capture more data with as many different digit and flag combinations as possible, then write a program to create checksums with various algorithms until one matches the bits in A7 and B7.\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Bruce Abbott",
            "time": "Feb 26, 2019 at 19:58",
            "is_accepted": false,
            "comments": [
                {
                    "user": "r a",
                    "text": "<span class=\"comment-copy\">Wow, thanks! I just realized that I have failed to mark in my op that the low nibbles of bytes A3-A6 are indeed simple BCD that represent clock values.  So in my first example,   <code>0a 0c 02 00 60 00 80 0b  == \"20:00\"</code>  I can't believe I left out that critical info. I'll edit the op.</span>",
                    "time": null
                },
                {
                    "user": "r a",
                    "text": "<span class=\"comment-copy\">I have made a pastebin which includes the data set I am working with. The format is:  <code>EPOCH [DATA]</code> The data was captured on approximately one second intervals.  <a href=\"https://pastebin.com/QuEqVns4\" rel=\"nofollow noreferrer\">pastebin.com/QuEqVns4</a></span>",
                    "time": null
                }
            ]
        }
    ]
}