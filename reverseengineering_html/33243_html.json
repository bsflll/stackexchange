{
    "title": "What is this 2D vector image (file) format?",
    "link": "https://reverseengineering.stackexchange.com/questions/33243/what-is-this-2d-vector-image-file-format",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <strong>\n   Context:\n  </strong>\n  I'm currently re-engineering an old (2015) E-paper display tag just for the fun of it. For the curious ones, I'm using\n  <a href=\"https://www.ghidra-sre.org/\" rel=\"nofollow noreferrer\">\n   Ghidra\n  </a>\n  to disassemble and decompile, and trying to make up some sense of the results. The tag uses an ARM Cortex M0 based MCU and a 1.44 inch EPD, and receives its display content via NFC.\n </p>\n <p>\n  After receiving some (RLE compressed) KB of data and inflating that data, the application interprets the data. This is my current knowledge about the contents:\n </p>\n <ul>\n  <li>\n   <p>\n    There is potentially a header of 16 bytes ignored by the application.\n   </p>\n  </li>\n  <li>\n   <p>\n    After the header there is an undetermined number of elements. The application stops at the end of the received data.\n   </p>\n  </li>\n  <li>\n   <p>\n    Each element is marked with a single byte (byte 0 in the table), followed by a length byte (byte 1 in the table, counted without these first two bytes)\n   </p>\n  </li>\n  <li>\n   <p>\n    After these two bytes more bytes can follow, depending on the element's type:\n   </p>\n   <div class=\"s-table-container\">\n    <table class=\"s-table\">\n     <thead>\n      <tr>\n       <th>\n        My finding so far\n       </th>\n       <th>\n        byte 0\n        \n\n        (element\n        \n\n        type)\n       </th>\n       <th>\n        byte 1\n        \n\n        (# of bytes\n        \n\n        to follow)\n       </th>\n       <th>\n        byte 2\n       </th>\n       <th>\n        byte 3\n       </th>\n       <th>\n        byte 4\n       </th>\n       <th>\n        byte 5\n       </th>\n       <th>\n        byte 6\n       </th>\n       <th>\n        byte 7 ...\n       </th>\n      </tr>\n     </thead>\n     <tbody>\n      <tr>\n       <td>\n        set geometry\n       </td>\n       <td>\n        0x01\n       </td>\n       <td>\n        3\n       </td>\n       <td>\n        x offset\n       </td>\n       <td>\n        y offset\n       </td>\n       <td>\n        rotation\n        \n\n        (0..3 = 0째/ 90째/ 180째/ 270째)\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n      </tr>\n      <tr>\n       <td>\n        define colors\n       </td>\n       <td>\n        0x02\n       </td>\n       <td>\n        2\n       </td>\n       <td>\n        color1\n       </td>\n       <td>\n        color2\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n      </tr>\n      <tr>\n       <td>\n        fill completely\n        \n\n        with background color\n       </td>\n       <td>\n        0x03\n       </td>\n       <td>\n        0\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n      </tr>\n      <tr>\n       <td>\n        invert image\n       </td>\n       <td>\n        0x04\n       </td>\n       <td>\n        0\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n      </tr>\n      <tr>\n       <td>\n        draw line\n       </td>\n       <td>\n        0x11\n       </td>\n       <td>\n        4\n       </td>\n       <td>\n        x1\n       </td>\n       <td>\n        y1\n       </td>\n       <td>\n        x2\n       </td>\n       <td>\n        y2\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n      </tr>\n      <tr>\n       <td>\n        draw text\n       </td>\n       <td>\n        0x12\n       </td>\n       <td>\n        #\n       </td>\n       <td>\n        x\n       </td>\n       <td>\n        y\n       </td>\n       <td>\n        font\n       </td>\n       <td>\n        opaque\n       </td>\n       <td>\n        centered\n       </td>\n       <td>\n        text...\n       </td>\n      </tr>\n      <tr>\n       <td>\n        draw pixels\n       </td>\n       <td>\n        0x13\n       </td>\n       <td>\n        #\n       </td>\n       <td>\n        x\n       </td>\n       <td>\n        y\n       </td>\n       <td>\n        w\n       </td>\n       <td>\n        h\n       </td>\n       <td>\n        bits per pixel\n       </td>\n       <td>\n        data...\n       </td>\n      </tr>\n      <tr>\n       <td>\n        draw rectangle\n       </td>\n       <td>\n        0x14\n       </td>\n       <td>\n        5\n       </td>\n       <td>\n        x1\n       </td>\n       <td>\n        y1\n       </td>\n       <td>\n        x2\n       </td>\n       <td>\n        y2\n       </td>\n       <td>\n        filled\n       </td>\n       <td>\n        -\n       </td>\n      </tr>\n      <tr>\n       <td>\n        draw circle\n       </td>\n       <td>\n        0x15\n       </td>\n       <td>\n        4\n       </td>\n       <td>\n        x\n       </td>\n       <td>\n        y\n       </td>\n       <td>\n        radius\n       </td>\n       <td>\n        filled\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n      </tr>\n      <tr>\n       <td>\n        stamp image\n       </td>\n       <td>\n        0x17\n       </td>\n       <td>\n        3\n       </td>\n       <td>\n        x\n       </td>\n       <td>\n        y\n       </td>\n       <td>\n        index\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n      </tr>\n      <tr>\n       <td>\n        prepare pixel data\n       </td>\n       <td>\n        0x20\n       </td>\n       <td>\n        #\n       </td>\n       <td>\n        data...\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n        -\n       </td>\n       <td>\n       </td>\n      </tr>\n     </tbody>\n    </table>\n   </div>\n  </li>\n </ul>\n <p>\n  Element type 0x20 is special. Each data chunk is appended to a buffer. When finally element type 0x13 is used, its data are also appended, and then the whole buffer is the image to draw.\n </p>\n <p>\n  I spent several hours in web research but could not find any hint. The \"usual suspects\" like CGM, EMF, EPS, SVG, WMF or Gerber do not match. I looked into few others, too.\n </p>\n <p>\n  What (file) format of a (simple) vector graphic is this?\n </p>\n <p>\n  The application is a mix of apparently assembler, C, and C++ code. Specifically all drawing functions receive the same pointer, which is certainly\n  <code>\n   this\n  </code>\n  . There is also a function pointer table in the structure pointed to, known as\n  <em>\n   vtable\n  </em>\n  . This makes me conclude that libraries are used.\n </p>\n <p>\n  Currently I'm at a bit-block transfer function that supports 16 colours. It\n  <em>\n   can\n  </em>\n  be that this is a proprietary format, but it makes no sense to support more than the two colours of EPDs of that time. That's why I think it is some more generic format.\n </p>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 0,
    "views": "82",
    "tags": [
        "file-format",
        "graphics"
    ],
    "user": "the busybee",
    "time": "Oct 10, 2024 at 19:00",
    "comments": [
        {
            "user": "jsotola",
            "text": "<html><body><span class=\"comment-copy\">\n could be custom file format\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Yotamz",
            "text": "<html><body><span class=\"comment-copy\">\n (These are only assumptions). Since the device has a simple display and that basic shapes are specified by a single byte of the protocol I would try to find a correlation between packet\n <i>\n  bits\n </i>\n and the actual visual result. This may be as simple as 1/0 to paint/clear pixel. Expect a checksum of the packet and/or parity bits inbetween.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "the busybee",
            "text": "<html><body><span class=\"comment-copy\">\n @jsotola Thanks for your hint, it's true, however, even though I'm in CS for decades and always learning, I cannot know all file formats. :-D\n <i>\n  If it is a known file format,\n </i>\n it would make my reengineering a lot simpler. Currently I need to interpret each element type's function in detail.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "the busybee",
            "text": "<html><body><span class=\"comment-copy\">\n @Yotamz Thanks for your suggestions, I will surely verify my findings with experiments. Currently the device is still in its code-readout fixture and I still need to find a way to communicate with NFC.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Yotamz",
            "text": "<html><body><span class=\"comment-copy\">\n True. I meant to say that it may be a common format for this type of embedded device - but not necessarily a well known graphics file format that is seen in PCs (for reducing overhead, memory use etc.). It makes identifying them harder, for lack of headers/magic values and so on\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}