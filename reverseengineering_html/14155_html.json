{
    "title": "C++ to assembly, GCC vs CL",
    "link": "https://reverseengineering.stackexchange.com/questions/14155/c-to-assembly-gcc-vs-cl",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have following C++ code:\n </p>\n <pre><code>int main(){\n\n  int a = 1;\n  double d = 1.2;\n\n  return 0;\n}\n</code></pre>\n <p>\n  and get the following assembly using GCC 6.2 -m32:\n </p>\n <pre><code>main:\n        lea     ecx, [esp+4]\n        and     esp, -8\n        push    DWORD PTR [ecx-4]\n        push    ebp\n        mov     ebp, esp\n        push    ecx\n        sub     esp, 20\n        mov     DWORD PTR [ebp-12], 1\n        fld     QWORD PTR .LC0\n        fstp    QWORD PTR [ebp-24]\n        mov     eax, 0\n        add     esp, 20\n        pop     ecx\n        pop     ebp\n        lea     esp, [ecx-4]\n        ret\n.LC0:\n        .long   858993459\n        .long   1072902963\n</code></pre>\n <p>\n  and using MS CL 19:\n </p>\n <pre><code>_d$ = -12                                         ; size = 8\n_a$ = -4                                                ; size = 4\n_main   PROC\n        push     ebp\n        mov      ebp, esp\n        sub      esp, 12              ; 0000000cH\n        mov      DWORD PTR _a$[ebp], 1\n        movsd    xmm0, QWORD PTR __real@3ff3333333333333\n        movsd    QWORD PTR _d$[ebp], xmm0\n        xor      eax, eax\n        mov      esp, ebp\n        pop      ebp\n        ret      0\n_main   ENDP\n</code></pre>\n <p>\n  I have several questions.\n </p>\n <ol>\n  <li>\n   <p>\n    what's  mean first three lines in GCC version?\n   </p>\n   <p>\n    <code>\n     lea     ecx, [esp+4]\n    </code>\n   </p>\n   <p>\n    <code>\n     and     esp, -8\n    </code>\n   </p>\n   <p>\n    <code>\n     push    DWORD PTR [ecx-4]\n    </code>\n   </p>\n  </li>\n  <li>\n   <p>\n    MS CL version allocates 12 bytes, 4 for int and 8 for double:\n   </p>\n   <p>\n    <code>\n     sub      esp, 12  // that's great.\n    </code>\n   </p>\n   <p>\n    But why GCC allocates 24?\n   </p>\n   <p>\n    <code>\n     push ecx\n    </code>\n   </p>\n   <p>\n    <code>\n     sub esp, 20\n    </code>\n   </p>\n  </li>\n </ol>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "850",
    "tags": [
        "disassembly",
        "assembly",
        "c++",
        "disassemblers",
        "gcc"
    ],
    "user": "Person.Junkie",
    "time": "Dec 12, 2016 at 22:01",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Given that you didn't specify any optimization flag and used -m32, GCC performed no optimization on your code. The -m32 flag specifies the generation of a 32 bit code for a compiler configured to generate 64 bit code by default. In 32 bit mode, even with optimizations activated, GCC will generate a sub-optimal code given that the only way to do floating point computations in 32 bit mode on Intel machines is through\n  <a href=\"https://en.wikipedia.org/wiki/X87\" rel=\"nofollow noreferrer\">\n   x87\n  </a>\n  instructions. If you remove the -m32 flag and add -O3 (third level of optimization in GCC) you'll obtain the following assembly code (quite similar to the one generated by Microsoft's CL) :\n </p>\n <pre><code>.LC1:\n        .string \"%d %lf\n\"\n        .section   .text.startup,\"ax\",@progbits\n        .p2align 4,,15\n        .globl  main\n        .type   main, @function\nmain:\n.LFB0:\n        .cfi_startproc\n        subq    $8, %rsp\n        .cfi_def_cfa_offset 16\n        movl    $1, %esi\n        movl    $.LC1, %edi\n        movsd   .LC0(%rip), %xmm0\n        movl    $1, %eax\n        call    printf\n        xorl    %eax, %eax\n        addq    $8, %rsp\n        .cfi_def_cfa_offset 8\n        ret\n        .cfi_endproc\n.LFE0:\n        .size   main, .-main\n        .section   .rodata.cst8,\"aM\",@progbits,8\n        .align 8\n.LC0:\n        .long   858993459\n        .long   1072902963 \n</code></pre>\n <p>\n  <strong>\n   Note :\n  </strong>\n  I added a\n  <strong>\n   printf\n  </strong>\n  to the code because if the GCC optimization pass sees no use of the two variables, they will be removed (dead code elimination). I invite you to check out my post on the subject of optimized vs. non optimized code (\n  <a href=\"https://reverseengineering.stackexchange.com/questions/4011/assembly-code-gcc-optimized-vs-not\">\n   Assembly Code - GCC optimized vs not\n  </a>\n  ).\n </p>\n <p>\n  You can also notice that CL used an\n  <em>\n   XMM\n  </em>\n  register to store the 64 bit\n  <em>\n   double\n  </em>\n  element stored in .LC0.\n  <em>\n   XMM\n  </em>\n  registers are part of the SSE (Streaming SIMD Extensions) instruction set used mainly for floating point scalar & vector operations. Its implementation is much cleaner and faster than the x87 instruction set.\n </p>\n <p>\n  Q1 :\n </p>\n <pre><code>lea     ecx, [esp+4]      //load the content of [esp + 4] into ecx\nand     esp, -8           //align the stack pointer to 8 bytes (same as esp & ~7)\npush    DWORD PTR [ecx-4] //push the content of [ecx - 4] on the stack \n\n[ecx - 4] = [[esp + 4] - 4]\n</code></pre>\n <p>\n  Let's suppose the stack is in this state :\n </p>\n <pre><code>     |       main      |\n     |      return     |\n     |      address @  |\n     +-----------------+  <--- esp + 4 ---> ecx\n     |    some value   |\n     +-----------------+  <--- esp = ebp\n</code></pre>\n <p>\n  The first instruction puts the existing stack content (main return address @) in ecx. It is equivalent to this :\n </p>\n <pre><code>mov ecx, esp\nsub ecx, 4\nmov ecx, [ecx]\n</code></pre>\n <p>\n  You can see that the lea instruction does in one take what these instructions do in three takes.\n </p>\n <p>\n  The second instruction aligns esp on an 8 byte boundary. What that means is that the lower 3 order bits of the address pointed by esp will be 0. Memory accesses are faster on Intel machines when aligned on a power of 2 boundary.\n </p>\n <p>\n  The third instruction changes the state of the stack to the following :\n </p>\n <pre><code>     |         @       |\n     +-----------------+  <--- esp + 4 ---> ecx\n     |    some value   |\n     +-----------------+  <--- ebp\n     |       @ - 4     |  \n     +-----------------+  <--- esp\n</code></pre>\n <p>\n  Therefore, when the main function is done, it will return to @ - 4.\n </p>\n <p>\n  Q2 :\n </p>\n <p>\n  Let's reason mathematically :\n </p>\n <pre><code>         We have : EBP = ESP0 \n         push ecx implies ESP1 = ESP0 - 4 \n         then : ESP2 = ESP1 - 20 \n         therefore : ESP0 = ESP2 - 24\n         mov DWORD PTR [ebp-12], 1 implies x = EBP - 12 = ESP0 - 12\n         We know that ESP0 = ESP2 - 24\n         Therefore x = ESP2 - 24 - 12 = ESP2 - 36\n         fstp    QWORD PTR [ebp-24] implies y = EBP - 24 = ESP0 - 24\n         Therefore y = ESP2 - 24 - 24 = ESP2 - 48\n</code></pre>\n <p>\n  Now, from this demonstration we extracted the location of the integer\n  <em>\n   x = ESP2 - 36\n  </em>\n  , and the location of the double\n  <em>\n   y = ESP2 - 48\n  </em>\n  .\nTo compute the distance between both variables, we subtract y from x and obtain the following :\n  <em>\n   x - y = ESP2 - 36 - ESP2 + 48 = 48 - 36 = 12\n  </em>\n  . And that's the amount of bytes used by GCC for storing both of your 32 bit/4 byte and 64 bit/8 byte variables.\n </p>\n</div>\n</body></html>",
            "votes": "4",
            "user": "Community",
            "time": "Apr 13, 2017 at 12:49",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Person.Junkie",
                    "text": "<span class=\"comment-copy\">Thanks, why we have this three lines in GCC 32-bit mode and don't have in 64-bit mode. What is the purpose of this three lines?</span>",
                    "time": null
                },
                {
                    "user": "yaspr",
                    "text": "<span class=\"comment-copy\">Check the Q1 update</span>",
                    "time": null
                }
            ]
        }
    ]
}