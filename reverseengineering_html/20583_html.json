{
    "title": "Extract a secret from an Android apk or .so file",
    "link": "https://reverseengineering.stackexchange.com/questions/20583/extract-a-secret-from-an-android-apk-or-so-file",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <h1>\n  Context\n </h1>\n <p>\n  As an exercise I am researching all methods of hiding a secret in an android mobile app binary... Yes I know that with more or less effort they can always be extracted with static analyses, run time introspection or with a MITM attack.\n </p>\n <p>\n  In my research to hide the secret, the best way I found for Android is by using JNI/NDK and until now I was not able to find a way of reverse engineer it.\n </p>\n <blockquote>\n  <p>\n   <strong>\n    NOTE\n   </strong>\n   : I understand the high level concept of reverse engineer but I don't have any experience of doing it.\n  </p>\n </blockquote>\n <h1>\n  My Attempts\n </h1>\n <pre><code>$ strings -aw lib/x86/libnative-lib.so | grep -C 1 -irn 'the-secret-api-key-goes-here' -\n932-[^_]\n933:the-secret-api-key-goes-here\n934-cannot allocate __cxa_eh_globals\n</code></pre>\n <p>\n  So I find the API key in the binary because I know it, but I would like to be able to find it by searching by the variable it is associated with:\n </p>\n <pre><code>$ strings -aw lib/x86/libnative-lib.so | grep -C 1 -irn 'JNI_API_KEY' -\n$\n</code></pre>\n <p>\n  or\n </p>\n <pre><code>$ strings -aw lib/x86/libnative-lib.so | grep -C 1 -irn 'SECRETS_API_KEY' -\n$\n</code></pre>\n <p>\n  Both doesn't return any result... I tried to use also\n  <code>\n   hexdump\n  </code>\n  and\n  <code>\n   objdump\n  </code>\n  without any success!!!\n </p>\n <p>\n  I tried also\n  <code>\n   radare2\n  </code>\n  and\n  <code>\n   retdec\n  </code>\n  but my lack of knowledge may have not helped me in finding the API keys to.\n </p>\n <p>\n  As a last attempt I have de-compiled the binary with\n  <a href=\"https://github.com/MobSF/Mobile-Security-Framework-MobSF\" rel=\"nofollow noreferrer\">\n   MobSF\n  </a>\n  and searched the smali code for the\n  <code>\n   JNI_API_KEY\n  </code>\n  ,\n  <code>\n   SECRETS_API_KEY\n  </code>\n  and\n  <code>\n   the-secret-api-key-goes-here\n  </code>\n  without any success.\n </p>\n <p>\n  At this point I don't want to resort to Frida or xPosed for a run-time reverse engineer technique or a MITM attack approach...\n </p>\n <p>\n  So for now I just want to know if I can employ other binary or de-compile techniques to find the API key?\n </p>\n <blockquote>\n  <p>\n   <strong>\n    NOTE\n   </strong>\n   : Looking for open source tools, not commercial ones.\n  </p>\n </blockquote>\n <h1>\n  The Code\n </h1>\n <p>\n  The code that I have used to hide the API key with JNI and NDK in the Android app is the following...\n </p>\n <p>\n  file: native-lib.cpp\n </p>\n <pre><code>#include <jni.h>\n#include <string>\n#include \"api_key.h\"\n\nextern \"C\" JNIEXPORT jstring JNICALL\nJava_com_example_secrets_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n\n    // To add the API_KEY to the mobile app when is compiled you need to:\n    //   * copy `api_key.h.example` to `api_key.h`\n    //   * edit the file and replace this text `place-the-api-key-here` with your desired API_KEY\n    std::string JNI_API_KEY = SECRETS_API_KEY;\n\n    return env->NewStringUTF(JNI_API_KEY.c_str());\n}\n</code></pre>\n <p>\n  file: api_key.h\n </p>\n <pre><code>#ifndef SECRETS_API_KEY\n#define SECRETS_API_KEY \"the-secret-api-key-goes-here\"\n\n#endif / SECRETS_API_KEY\n</code></pre>\n <p>\n  file: CMakeLists.txt\n </p>\n <pre><code># For more information about using CMake with Android Studio, read the\n# documentation: https://d.android.com/studio/projects/add-native-code.html\n\n# Sets the minimum version of CMake required to build the native library.\n\ncmake_minimum_required(VERSION 3.4.1)\n\n# Creates and names a library, sets it as either STATIC\n# orJNI_API_KEY SHARED, and provides the relative paths to its source code.\n# You can define multiple libraries, and CMake builds them for you.\n# Gradle automatically packages shared libraries with your APK.\n\nadd_library( # Sets the name of the library.\n        native-lib\n\n        # Sets the library as a shared library.\n        SHARED\n\n        # Provides a relative path to your source file(s).\n        native-lib.cpp)\n\n# Searches for a specified prebuilt library and stores the path as a\n# variable. Because CMake includes system libraries in the search path by\n# default, you only need to specify the name of the public NDK library\n# you want to add. CMake verifies that the library exists before\n# completing its build.\n\nfind_library( # Sets the name of the path variable.\n        log-lib\n\n        # Specifies the name of the NDK library that\n        # you want CMake to locate.\n        log)\n\n# Specifies libraries CMake should link to your target library. You\n# can link multiple libraries, such as libraries you define in this\n# build script, prebuilt third-party libraries, or system libraries.\n\ntarget_link_libraries( # Specifies the target library.\n        native-lib\n\n        # Links the target library to the log library\n        # included in the NDK.\n        ${log-lib})\n</code></pre>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 1,
    "views": "4k",
    "tags": [
        "disassembly",
        "binary-analysis",
        "android",
        "binary",
        "apk"
    ],
    "user": "Exadra37",
    "time": "Feb 9, 2019 at 23:23",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  If the API key is a string then just running\n  <code>\n   strings\n  </code>\n  would reveal it w/o\n  <code>\n   grep\n  </code>\n  as you do in your example. There might be some other strings but longer ones seems to stand out so it should be clearly visible that this is something meaningful. Having that API key I would probably go and use regular disassembler tools to see where and how it is used.\n </p>\n <p>\n  You can't search by variable names as those are not preserved in the binary (.so), with APK it might be a bit different.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Paweł Łukasik",
            "time": "Feb 10, 2019 at 8:21",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Exadra37",
                    "text": "<span class=\"comment-copy\">The problem is to search the <code>.so</code> for meaningful strings... in my case was easy to find because I know the string I want to find... Not aware that the <code>.so</code> binary was not preserving the variable names, good to know ;)</span>",
                    "time": null
                }
            ]
        }
    ]
}