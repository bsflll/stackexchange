{
    "title": "Why are those instructions generated?",
    "link": "https://reverseengineering.stackexchange.com/questions/6775/why-are-those-instructions-generated",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  After disassembling a program, I see the following asm code generated :\n </p>\n <pre><code>.text:004D5911 mov     [ebp+var_4], ecx\n.text:004D5914 mov     ecx, [ebp+var_4]\n.text:004D5917 test    ecx, ecx\n.text:004D5919 jnz     short loc_4D591F\n</code></pre>\n <p>\n  I don't get why\n  <code>\n   [ebp+var_4]\n  </code>\n  is copied back to\n  <code>\n   ecx\n  </code>\n  .\n </p>\n <p>\n  Is this an artifact (missed optimization) from the compiler which requires test to take registers as operands?\n </p>\n</div>\n</body></html>",
    "votes": "8",
    "answers": 1,
    "views": "240",
    "tags": [
        "disassembly",
        "compilers"
    ],
    "user": "Eric",
    "time": "Dec 7, 2014 at 12:57",
    "comments": [
        {
            "user": "Guntram Blohm",
            "text": "<html><body><span class=\"comment-copy\">\n You answered your own question. Yes.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Guntram Blohm",
            "text": "<html><body><span class=\"comment-copy\">\n This might also be part of a loop that starts at 4D5914, with the first instruction initializing the loop control variable. Though this seems unlikely, since a) the jnz jumps if cx is\n <i>\n  not\n </i>\n zero, and b) this seems to be an IDA disassembly, and ida would have generated a loc_... label if there was a jump to this address.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Fewmitz",
            "text": "<html><body><span class=\"comment-copy\">\n I've also seen compilers do this for alignment reasons. inside a particular section\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  This is a common pattern in assembly generated by gcc at least. When it is not asked to optimize the generated code, the translation between C and asm is really straightforward. One statement in C produces a few lines of asm. Next statement: a few more lines of asm, and so on.\n </p>\n <p>\n  In your case:\n </p>\n <pre><code>mov     [ebp+var_4], ecx\n</code></pre>\n <p>\n  is probably the end of a line of C, while:\n </p>\n <pre><code>mov     ecx, [ebp+var_4]\n</code></pre>\n <p>\n  is the beginning of the next one.\n </p>\n <p>\n  These instructions are optimized out as soon as\n  <code>\n   -O1\n  </code>\n  (or higher) is provided.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Celelibi",
            "time": "Dec 8, 2014 at 3:21",
            "is_accepted": false,
            "comments": [
                {
                    "user": "David Hoelzer",
                    "text": "<span class=\"comment-copy\">Optimization, as mentioned in this answer, will eliminate this oddity which you have correctly identified as a compiler artifact.  Things like these are quite useful for figuring out whether code was \"hand written\", compiled or, potentially, identifying which compiler was used to build a particular piece of code.</span>",
                    "time": null
                }
            ]
        }
    ]
}