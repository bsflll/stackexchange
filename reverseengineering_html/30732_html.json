{
    "title": "Reverse engineering ELF: The e_phentsize field in the ELF header is less than the size of an ELF program header",
    "link": "https://reverseengineering.stackexchange.com/questions/30732/reverse-engineering-elf-the-e-phentsize-field-in-the-elf-header-is-less-than-th",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have extracted the\n  <code>\n   .so\n  </code>\n  binary\n  <code>\n   libTheArmKing.so\n  </code>\n  (located in\n  <code>\n   lib\n  </code>\n  directory in\n  <code>\n   apk\n  </code>\n  file) from\n  <a href=\"https://platinmods.com/threads/world-war-heroes-ww2-fps-ver-1-33-2-mod-menu-apk-unlimited-ammo-ohk-god-mode-radar-anti-kick-more-15-features.120570/\" rel=\"nofollow noreferrer\">\n   a hack of World War Heroes game\n  </a>\n  (an Android game) from Plantimod Forum.\n </p>\n <p>\n  <code>\n   file\n  </code>\n  output:\n </p>\n <pre><code>libTheArmKing.so: ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV), corrupted program header size, stripped\n</code></pre>\n <p>\n  <code>\n   readelf\n  </code>\n  output:\n </p>\n <pre><code>ELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           ARM\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          712948 (bytes into file)\n  Flags:                             0x5000000, Version5 EABI\n  Size of this header:               52 (bytes)\n  Size of program headers:           17 (bytes)\n  Number of program headers:         8\n  Size of section headers:           40 (bytes)\n  Number of section headers:         28\n  Section header string table index: 27\n\nSection Headers:\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\n  [ 1] .interp           PROGBITS        00000134 000134 000013 00   A  0   0  1\n  [ 2] .dynsym           DYNSYM          00000148 000148 006210 10   A  3   1  4\n  [ 3] .dynstr           STRTAB          00006358 006358 007038 00   A  0   0  1\n  [ 4] .hash             HASH            0000d390 00d390 0028a8 04   A  2   0  4\n  [ 5] .rel.dyn          REL             0000fc38 00fc38 000c50 08   A  2   0  4\n  [ 6] .rel.plt          REL             00010888 010888 0002a8 08  AI  2   7  4\n  [ 7] .plt              PROGBITS        00010b30 010b30 000410 00  AX  0   0  4\n  [ 8] .text             PROGBITS        00010f40 010f40 048398 00  AX  0   0  4\n  [ 9] .turn             PROGBITS        000592d8 0592d8 000044 00  AX  0   0  4\n  [10] .main             PROGBITS        0005931c 05931c 001ba8 00  AX  0   0  4\n  [11] .maria            PROGBITS        0005aec4 05aec4 000010 00  AX  0   0  4\n  [12] .ARM.extab        PROGBITS        0005aed4 05aed4 002808 00   A  0   0  4\n  [13] .ARM.exidx        ARM_EXIDX       0005d6dc 05d6dc 000f80 08  AL  8   0  4\n  [14] .rodata           PROGBITS        0005e660 05e660 00340c 00   A  0   0 16\n  [15] .data.rel.ro[...] PROGBITS        00063688 062688 000048 00  WA  0   0  4\n  [16] .fini_array       FINI_ARRAY      000636d0 0626d0 000008 00  WA  0   0  4\n  [17] .init_array       INIT_ARRAY      000636d8 0626d8 000010 00  WA  0   0  4\n  [18] .data.rel.ro      PROGBITS        000636e8 0626e8 00063c 00  WA  0   0  8\n  [19] .dynamic          DYNAMIC         00063d24 062d24 000108 08  WA  3   0  4\n  [20] .got              PROGBITS        00063e30 062e30 0001d0 00  WA  0   0  4\n  [21] .data             PROGBITS        00064000 063000 04af6c 00  WA  0   0  8\n  [22] .ced              PROGBITS        000aef6c 0adf6c 000020 00  WA  0   0  4\n  [23] .bss              NOBITS          000aef90 0adf8c 06dc04 00  WA  0   0  8\n  [24] .comment          PROGBITS        00000000 0adf8c 000023 01  MS  0   0  1\n  [25] .note.gnu.go[...] NOTE            00000000 0adfb0 00001c 00      0   0  4\n  [26] .ARM.attributes   ARM_ATTRIBUTES  00000000 0adfcc 00002f 00      0   0  1\n  [27] .shstrtab         STRTAB          00000000 0adffb 0000f8 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  y (purecode), p (processor specific)\n\nThere are no section groups in this file.\nreadelf: Error: The e_phentsize field in the ELF header is less than the size of an ELF program header\n</code></pre>\n <p>\n  When I load this\n  <code>\n   .so\n  </code>\n  into IDA, IDA cannot detect it as\n  <code>\n   ELF\n  </code>\n  , and only show\n  <code>\n   Binary File\n  </code>\n  . Also, it cannot detect the entry point automatically.\n </p>\n <p>\n  I think the mod author made this corruption\n  <em>\n   on purpose\n  </em>\n  to make it harder to reverse engineering his mod.\n </p>\n <p>\n  <a href=\"https://transfer.sh/P1Gxoa/libTheArmKing.so\" rel=\"nofollow noreferrer\">\n   Here\n  </a>\n  is the binary.\n </p>\n <p>\n  So my question is: How to fix the header of this\n  <code>\n   .so\n  </code>\n  to make it loadable to IDA?\n </p>\n <p>\n  Thank you!\n </p>\n <p>\n  <strong>\n   EDIT 1\n  </strong>\n  : Ghidra is able to load and detect this as ELF, but skipped some sections due to incorrect address.\n </p>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 1,
    "views": "438",
    "tags": [
        "ida",
        "android",
        "arm",
        "elf",
        "apk"
    ],
    "user": "raspiduino",
    "time": "Aug 4, 2022 at 4:51",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  If you use a hex editor and set\n  <code>\n   e_phentsize\n  </code>\n  (offset 0x2a) to 0x20 it works fine, I believe 0x20 is standard for 32bit.\n </p>\n <pre><code>$ readelf -l libTheArmKing.so \n\nElf file type is DYN (Shared object file)\nEntry point 0x0\nThere are 8 program headers, starting at offset 52\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  PHDR           0x000034 0x00000034 0x00000034 0x00100 0x00100 R   0x4\n  INTERP         0x000134 0x00000134 0x00000134 0x00013 0x00013 R   0x1\n      [Requesting program interpreter: /system/bin/linker]\n  LOAD           0x000000 0x00000000 0x00000000 0x61a6c 0x61a6c R E 0x1000\n  LOAD           0x062688 0x00063688 0x00063688 0x4b904 0xb950c RW  0x1000\n  DYNAMIC        0x062d24 0x00063d24 0x00063d24 0x00108 0x00108 RW  0x4\n  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0\n  EXIDX          0x05d6dc 0x0005d6dc 0x0005d6dc 0x00f80 0x00f80 R   0x4\n  GNU_RELRO      0x062688 0x00063688 0x00063688 0x00978 0x00978 RW  0x8\n\n Section to Segment mapping:\n  Segment Sections...\n   00     \n   01     .interp \n   02     .interp .dynsym .dynstr .hash .rel.dyn .rel.plt .plt .text .turn .main .maria .ARM.extab .ARM.exidx .rodata \n   03     .data.rel.ro.local .fini_array .init_array .data.rel.ro .dynamic .got .data .ced .bss \n   04     .dynamic \n   05     \n   06     .ARM.exidx \n   07     .data.rel.ro.local .fini_array .init_array .data.rel.ro .dynamic .got \n</code></pre>\n <p>\n  Detailed info:\n </p>\n <p>\n  You can calculate the correct sizes by running\n  <code>\n   man 5 elf\n  </code>\n  and looking at the\n  <code>\n   Elf32_Phdr\n  </code>\n  or\n  <code>\n   Elf64_Phdr\n  </code>\n  structure definitions and adding up their element sizes, giving you 0x20 for\n  <code>\n   Elf32_Phdr\n  </code>\n  and 0x38 for\n  <code>\n   Elf64_Phdr\n  </code>\n  .\n </p>\n <pre><code>   typedef struct {\n       uint32_t   p_type;\n       Elf32_Off  p_offset;\n       Elf32_Addr p_vaddr;\n       Elf32_Addr p_paddr;\n       uint32_t   p_filesz;\n       uint32_t   p_memsz;\n       uint32_t   p_flags;\n       uint32_t   p_align;\n   } Elf32_Phdr;\n\n   typedef struct {\n       uint32_t   p_type;\n       uint32_t   p_flags;\n       Elf64_Off  p_offset;\n       Elf64_Addr p_vaddr;\n       Elf64_Addr p_paddr;\n       uint64_t   p_filesz;\n       uint64_t   p_memsz;\n       uint64_t   p_align;\n   } Elf64_Phdr;\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Mega Tonnage",
            "time": "Aug 4, 2022 at 10:32",
            "is_accepted": true,
            "comments": [
                {
                    "user": "raspiduino",
                    "text": "<span class=\"comment-copy\">Thanks! That worked for me! But how did you find this?</span>",
                    "time": null
                },
                {
                    "user": "Mega Tonnage",
                    "text": "<span class=\"comment-copy\">Edited the answer to provide more information. Fiddling with header fields is a common trick that's easy to implement, many fields can be zeroed or mangled and the executable or library will still work fine.</span>",
                    "time": null
                }
            ]
        }
    ]
}