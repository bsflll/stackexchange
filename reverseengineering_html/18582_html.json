{
    "title": "How do I find out what section variables and strings are defined in?",
    "link": "https://reverseengineering.stackexchange.com/questions/18582/how-do-i-find-out-what-section-variables-and-strings-are-defined-in",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Given a simple program like this,\n </p>\n <pre><code>void main (int argc, char * argv[] ) {\n    char * arr[] = {\"foo\", \"bar\", \"baz\"};\n    *(arr[0]) = 'F';\n    printf( \"%s\", arr[0] );\n}\n</code></pre>\n <p>\n  How do I find out what section the strings\n  <code>\n   foo\n  </code>\n  ,\n  <code>\n   bar\n  </code>\n  , and\n  <code>\n   baz\n  </code>\n  are defined in? As in, are they in the\n  <code>\n   .text\n  </code>\n  section or\n  <code>\n   .rodata\n  </code>\n  , and also check to make sure those section are\n  <code>\n   ro\n  </code>\n  , or\n  <code>\n   rw\n  </code>\n  ?\n </p>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 1,
    "views": "2k",
    "tags": [
        "c",
        "radare2",
        "elf",
        "section"
    ],
    "user": "Evan Carroll",
    "time": "Jun 23, 2018 at 0:42",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  In the following answer, I'll show you several ways to achieve what you want. I'll use different approaches to do this with radre2.\n </p>\n <p>\n  First, let's create a program with a bit longer strings:\n </p>\n <pre><code>$ cat helloworld.c \n\n#include <stdio.h>\n\nvoid main (int argc, char * argv[] ) {\n    char * arr[] = {\"Hello\", \"World\", \"Byebye\"};\n    arr[0] = \"F\";\n    printf( \"%s\n\", arr[0] );\n}\n\n$ gcc helloworld.c -o helloworld\n</code></pre>\n <p>\n  And open it in radare2:\n </p>\n <pre><code>$ r2 helloworld\n</code></pre>\n <p>\n  Now that we have a tiny binary, we can start.\n </p>\n <hr/>\n <h2>\n  Method 1: Strings in data sections\n </h2>\n <p>\n  Using the\n  <code>\n   iz\n  </code>\n  command you can list the strings in the data sections. For each string, you can see the section it belongs to:\n </p>\n <pre><code>[0x000005b0]> iz\n000 0x000007b4 0x000007b4   5   6 (.rodata) ascii Hello\n001 0x000007ba 0x000007ba   5   6 (.rodata) ascii World\n002 0x000007c0 0x000007c0   6   7 (.rodata) ascii Byeby\n</code></pre>\n <p>\n  And of course, you can always use radare's internal grep (\n  <code>\n   ~\n  </code>\n  ) to take only the relevant columns:\n </p>\n <pre><code>[0x000005b0]> iz~[5,7]\n(.rodata) Hello\n(.rodata) World\n(.rodata) Byebye\n</code></pre>\n <h2>\n  Method 2: Strings in the whole binary\n </h2>\n <p>\n  Unlike\n  <code>\n   iz\n  </code>\n  , the command\n  <code>\n   izz\n  </code>\n  will search for strings in the whole binary. This command will show you more strings than\n  <code>\n   iz\n  </code>\n  but it'll search for strings in other sections as well.\n </p>\n <pre><code>[0x000005b0]> izz\n000 0x00000034 0x00000034   4  10 (LOAD0) utf16le @8\\t@\n001 0x00000238 0x00000238  27  28 (.interp) ascii /lib64/ld-linux-x86-64.so.2\n002 0x00000379 0x00000379   9  10 (.dynstr) ascii libc.so.6\n003 0x00000383 0x00000383   4   5 (.dynstr) ascii puts\n004 0x00000388 0x00000388  16  17 (.dynstr) ascii __stack_chk_fail\n005 0x00000399 0x00000399  14  15 (.dynstr) ascii __cxa_finalize\n006 0x000003a8 0x000003a8  17  18 (.dynstr) ascii __libc_start_main\n007 0x000003ba 0x000003ba   9  10 (.dynstr) ascii GLIBC_2.4\n008 0x000003c4 0x000003c4  11  12 (.dynstr) ascii GLIBC_2.2.5\n009 0x000003d0 0x000003d0  27  28 (.dynstr) ascii _ITM_deregisterTMCloneTable\n010 0x000003ec 0x000003ec  14  15 (.dynstr) ascii __gmon_start__\n011 0x000003fb 0x000003fb  25  26 (.dynstr) ascii _ITM_registerTMCloneTable\n...\n019 0x000007b4 0x000007b4   5   6 (.rodata) ascii Hello\n020 0x000007ba 0x000007ba   5   6 (.rodata) ascii World\n021 0x000007c0 0x000007c0   6   7 (.rodata) ascii Byebye\n022 0x00000810 0x00000810   4   5 (.eh_frame) ascii \\e\\f\\a\\b\n023 0x00000840 0x00000840   4   5 (.eh_frame) ascii \\e\\f\\a\\b\n024 0x00000867 0x00000867   5   6 (.eh_frame) ascii ;*3$\"\n025 0x0000088a 0x0000088a   4   5 (.eh_frame) ascii h\\f\\a\\b\n026 0x00001038 0x00000000  16  17 (.comment) ascii GCC: (GNU) 7.2.0\n027 0x00001669 0x00000001   6   7 (.strtab) ascii init.c\n028 0x00001670 0x00000008  10  11 (.strtab) ascii crtstuff.c\n...\n</code></pre>\n <p>\n  Again, you can see that radare2 shows you the section name for each string. \nIf you are searching for specific strings, grep is your friend:\n </p>\n <pre><code>[0x000005b0]> izz~Hello, World, Byebye\n019 0x000007b4 0x000007b4   5   6 (.rodata) ascii Hello\n020 0x000007ba 0x000007ba   5   6 (.rodata) ascii World\n021 0x000007c0 0x000007c0   6   7 (.rodata) ascii Byebye\n\n[0x000005b0]> izz~Hello, World, Byebye[5,7]\n(.rodata) Hello\n(.rodata) World\n(.rodata) Byebye\n</code></pre>\n <h2>\n  Method 3: Section of a specific address\n </h2>\n <p>\n  In this method, you already know the address of the string and you want to know to which section it belongs. Let's take \"Hello\" for example. We saw that \"Hello\" address is\n  <code>\n   0x000007b4\n  </code>\n  . Let's verify it using\n  <code>\n   ps\n  </code>\n  (\n  <strong>\n   p\n  </strong>\n  rint\n  <strong>\n   s\n  </strong>\n  tring):\n </p>\n <pre><code>[0x000005b0]> ps @ 0x000007b4\nHello\n</code></pre>\n <p>\n  As you can see, we printed a zero-terminated string from\n  <code>\n   0x07b4\n  </code>\n  (\"@\" is radare's temporary seek). Now that we are sure that this is the address of \"Hello\", we can use\n  <code>\n   iS.\n  </code>\n  to show the current Section name:\n </p>\n <pre><code>[0x000005b0]> iS. @ 0x07b4\nCurrent section\n00 0x000007b0    25 0x000007b0    25 -r-- .rodata\n</code></pre>\n <p>\n  As expected, this address belongs to the\n  <code>\n   .rodata\n  </code>\n  section. Just as we saw before.\n </p>\n <hr/>\n <h2>\n  Show Sections' attributes\n </h2>\n <p>\n  Finally, you wanted to check whether the sections' attributes are read-only or read-write. Using\n  <code>\n   iS\n  </code>\n  you can list all the sections, including their attributes:\n </p>\n <pre><code>[0x000005b0]> iS\n[Sections]\n00 0x00000000     0 0x00000000     0 ---- \n01 0x00000238    28 0x00000238    28 -r-- .interp\n02 0x00000254    32 0x00000254    32 -r-- .note.ABI_tag\n03 0x00000274    36 0x00000274    36 -r-- .note.gnu.build_id\n04 0x00000298    28 0x00000298    28 -r-- .gnu.hash\n05 0x000002b8   192 0x000002b8   192 -r-- .dynsym\n06 0x00000378   157 0x00000378   157 -r-- .dynstr\n07 0x00000416    16 0x00000416    16 -r-- .gnu.version\n08 0x00000428    48 0x00000428    48 -r-- .gnu.version_r\n09 0x00000458   216 0x00000458   216 -r-- .rela.dyn\n10 0x00000530    48 0x00000530    48 -r-- .rela.plt\n11 0x00000560    23 0x00000560    23 -r-x .init\n12 0x00000580    48 0x00000580    48 -r-x .plt\n13 0x000005b0   498 0x000005b0   498 -r-x .text\n14 0x000007a4     9 0x000007a4     9 -r-x .fini\n15 0x000007b0    25 0x000007b0    25 -r-- .rodata\n16 0x000007cc    52 0x000007cc    52 -r-- .eh_frame_hdr\n17 0x00000800   240 0x00000800   240 -r-- .eh_frame\n18 0x00000de0     8 0x00200de0     8 -rw- .init_array\n19 0x00000de8     8 0x00200de8     8 -rw- .fini_array\n20 0x00000df0   480 0x00200df0   480 -rw- .dynamic\n21 0x00000fd0    48 0x00200fd0    48 -rw- .got\n22 0x00001000    40 0x00201000    40 -rw- .got.plt\n23 0x00001028    16 0x00201028    16 -rw- .data\n24 0x00001038     0 0x00201038     8 -rw- .bss\n25 0x00001038    17 0x00000000    17 ---- .comment\n26 0x00001050  1560 0x00000000  1560 ---- .symtab\n27 0x00001668   555 0x00000000   555 ---- .strtab\n28 0x00001893   259 0x00000000   259 ---- .shstrtab\n29 0x00000040   504 0x00000040   504 -r-x PHDR\n30 0x00000238    28 0x00000238    28 -r-- INTERP\n31 0x00000000  2288 0x00000000  2288 -r-x LOAD0\n32 0x00000de0   600 0x00200de0   608 -rw- LOAD1\n33 0x00000df0   480 0x00200df0   480 -rw- DYNAMIC\n34 0x00000254    68 0x00000254    68 -r-- NOTE\n35 0x000007cc    52 0x000007cc    52 -r-- GNU_EH_FRAME\n36 0x00000000     0 0x00000000     0 -rw- GNU_STACK\n37 0x00000de0   544 0x00200de0   544 -r-- GNU_RELRO\n38 0x00000000    64 0x00000000    64 -rw- ehdr\n</code></pre>\n <p>\n  Alternatively,  use\n  <code>\n   iSq\n  </code>\n  to show a less-verbose output (\n  <strong>\n   q\n  </strong>\n  is for\n  <strong>\n   quiet\n  </strong>\n  ), and you also can grep for read-write sections:\n </p>\n <pre><code>[0x000005b0]> iS~rw\n18 0x00000de0     8 0x00200de0     8 -rw- .init_array\n19 0x00000de8     8 0x00200de8     8 -rw- .fini_array\n20 0x00000df0   480 0x00200df0   480 -rw- .dynamic\n21 0x00000fd0    48 0x00200fd0    48 -rw- .got\n22 0x00001000    40 0x00201000    40 -rw- .got.plt\n23 0x00001028    16 0x00201028    16 -rw- .data\n24 0x00001038     0 0x00201038     8 -rw- .bss\n32 0x00000de0   600 0x00200de0   608 -rw- LOAD1\n33 0x00000df0   480 0x00200df0   480 -rw- DYNAMIC\n36 0x00000000     0 0x00000000     0 -rw- GNU_STACK\n38 0x00000000    64 0x00000000    64 -rw- ehdr\n</code></pre>\n <p>\n  If you want to see read-only sections, use grep like this\n  <code>\n   iS~r--\n  </code>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "4",
            "user": "Megabeets",
            "time": "Jun 23, 2018 at 6:50",
            "is_accepted": true,
            "comments": []
        }
    ]
}