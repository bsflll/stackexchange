{
    "title": "How to create an algorithm in C...(or C# or C++, basically in \"a programming language\")",
    "link": "https://reverseengineering.stackexchange.com/questions/27586/how-to-create-an-algorithm-in-c-or-c-or-c-basically-in-a-programming-lan",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  After a LOT of sending challenges and recording the responses I've 'broken' the \"encryption\" in my car's immobiliser...the reason for doing it is so I can use the engine and transmission in a project car, keeping the HS canbus - for the ECM to TCM comms, but removing the MS canbus - and all modules associated with it...including the body control module which handles the immobiliser functionality in the stock car.\n </p>\n <p>\n  So, \"encryption\" - it's basically a substitution cipher with a bunch of modifiers. The format is a 32-bit challenge, and 32-bit response - formatted into 4 bytes and 4 bytes.\n </p>\n <p>\n  I've currently coded it in C (for arduino) using arrays for the responses and a bunch of logic and it's working - however there's got to be a better way...right?\n </p>\n <p>\n  I'm a mechanic, not a programmer, and definitely not a mathematician...I just don't have the knowledge (or IQ XD) to make the jump from what I've done so far, to coding a functioning mathematical model/algorithm to do the same job.\n </p>\n <p>\n  As a couple of examples of the logic for the modifiers it's things like if challenge byte 2 >= 0xEC then increment the response by 1, or if bit 2 of challenge byte 3 >= 0x14 then do something else to the appropriate response etc.\n </p>\n <p>\n  But honestly...would love to reduce my 600 lines of code to 50!\n </p>\n <p>\n  I can post up as many C/R pairs as necessary to get some help here and post the flow chart of logic too.\n </p>\n <p>\n  Just hoping for a white knight right now!\n </p>\n <p>\n  <strong>\n   Edited to add coded block and other info...\n  </strong>\n </p>\n <pre><code>void CalcResp()\n\n  //Calculate response   \n\n{               \n\n  uint32_t  ResponsePreXOR = 0x00000000;\n  uint32_t  ResponsePostXOR;\n  uint8_t   ChalByte[4];\n  uint8_t   RawRespByte[4];\n  uint8_t   XORRespByte[4];\n  CAN_FRAME ChalFrame;\n  CAN_FRAME RespFrame;\n\n  Can0.watchFor(0x00040020);\n\n  if (Can0.available() > 0)\n    {\n      Can0.read(ChalFrame);\n\n  // Split the Challenge into raw bytes\n  \n  ChalByte[0] = ChalFrame.data.byte[0];\n  ChalByte[1] = ChalFrame.data.byte[1];\n  ChalByte[2] = ChalFrame.data.byte[2];\n  ChalByte[3] = ChalFrame.data.byte[3];\n\n\n  // if Challenge Byte 3 bit 1 is set\n\n  if (ChalByte[3]&0x02)\n  {\n    if (ChalByte[3]>=0x16)\n      {\n        RawRespByte[3] = TableB2A[(ChalByte[2]+1)&0xFF];\n      }\n    else\n      {\n        RawRespByte[3] = TableB2A[ChalByte[2]];\n      }\n      \n  RawRespByte[2] = TableB3[ChalByte[3]];\n  RawRespByte[1] = TableB1A[ChalByte[1]];\n\n    if (ChalByte[1]>=0xEC)\n      {\n        RawRespByte[0] = TableB0A[(ChalByte[0]+1)&0xFF];\n      }\n      else\n      {\n        RawRespByte[0] = TableB0A[ChalByte[0]];\n      }\n\n  }\n  // if Challenge Byte 3 bit 1 is not set\n\n  else\n\n  // Build Response Byte 0\n  {;\n      RawRespByte[3] = TableB3[ChalByte[3]];\n      \n  // Build Response Byte 2\n        if (RawRespByte[3]>=0x14)\n          {\n            RawRespByte[2] = TableB2N[(ChalByte[2]+1)&0xFF];\n          }\n         else\n          {\n            RawRespByte[2] = TableB2N[ChalByte[2]];\n          }\n\n  // if Challenge byte 1 is above or equal to 0xEC\n  // Build Response Byte 1\n\n        if (ChalByte[1]>=0xEC) \n          {\n            if (ChalByte[0]&0x0F==0x0F)\n              { \n                RawRespByte[1] = TableB016s[(ChalByte[0]/16)];\n              }\n            else\n              {\n              RawRespByte[1] = TableB0N[(ChalByte[0]+1)&0xFF];\n              }\n        if (ChalByte[1]<0xEC)\n          {\n            RawRespByte[1] = TableB0N[ChalByte[0]];\n          }\n        \n  //Build Response Byte 0 \n\n    RawRespByte[0] = TableB1N[ChalByte[1]];\n\n  }\n\n\n  //Construct the response out of the response bytes\n  \n  ResponsePreXOR = uint32_t (RawRespByte[0])<<24;\n  \n  ResponsePreXOR += uint32_t (RawRespByte[1])<<16;\n   \n  ResponsePreXOR += uint32_t (RawRespByte[2])<<8;\n  \n  ResponsePreXOR += uint32_t (RawRespByte[3]);\n</code></pre>\n <p>\n  The car's ECM is a Siemens SID 203 - the immo algo for this hasn't yet been broken I don't think...no-one produces an emulator for it.\n </p>\n <p>\n  I\n  <em>\n   think\n  </em>\n  the synchro is this code snippet from the ECM\n </p>\n <pre><code>u8\ndata_cs[8]={0xEC,0x68,0x27,0x65,0xEC,0x8E,0x14,0xE6};\n</code></pre>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 0,
    "views": "100",
    "tags": [
        "c++",
        "c",
        "encryption"
    ],
    "user": "joehodgy",
    "time": "Apr 30, 2021 at 15:50",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<html><body><span class=\"comment-copy\">\n this sounds like a programming question rather than RE as such, so may be a better fit for StackOverflow\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "joehodgy",
            "text": "<html><body><span class=\"comment-copy\">\n Added codes snippets and more info :)\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}