{
    "title": "Can I use the Rich Header To Find out Compiler and Linker used?",
    "link": "https://reverseengineering.stackexchange.com/questions/22218/can-i-use-the-rich-header-to-find-out-compiler-and-linker-used",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I heard that I can use look at the RICH HEADER to find out what compiler was used. I looked at the Rich header and I cannot seem to make sense of this.\n </p>\n <p>\n  Can I find the Compiler used for this program and is there a tool to decode this?\n </p>\n <p>\n  Here is the Rich header and I want to know what compiler was used for this. \nHEX\n </p>\n <pre><code>f1 0b 38 2f b5 6a 56 7c b5 6a 56 7c b5 6a 56 7c\n26 24 ce 7c b4 6a 56 7c bc 12 c3 7c b7 6a 56 7c\n00 f4 b6 7c b3 6a 56 7c 00 f4 89 7c b4 6a 56 7c\nbc 12 c5 7c ae 6a 56 7c b5 6a 57 7c 10 6a 56 7c\nae f7 f9 7c af 6a 56 7c ae f7 cd 7c b4 6a 56 7c\nae f7 cb 7c b4 6a 56 7c 52 69 63 68 b5 6a 56 7c\n</code></pre>\n <p>\n  ASCII\n </p>\n <pre><code>..8/.jV|.jV|.jV|\n&$.|.jV|...|.jV|\n...|.jV|...|.jV|\n...|.jV|.jW|.jV|\n...|.jV|...|.jV|\n...|.jV|Rich.jV|\n</code></pre>\n <p>\n  In case I missed something in selecting the header here is the MZ + DOS and Rich\n </p>\n <pre><code>4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00\nb8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 f0 00 00 00\n0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68\n69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f\n74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20\n6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00\nf1 0b 38 2f b5 6a 56 7c b5 6a 56 7c b5 6a 56 7c\n26 24 ce 7c b4 6a 56 7c bc 12 c3 7c b7 6a 56 7c\n00 f4 b6 7c b3 6a 56 7c 00 f4 89 7c b4 6a 56 7c\nbc 12 c5 7c ae 6a 56 7c b5 6a 57 7c 10 6a 56 7c\nae f7 f9 7c af 6a 56 7c ae f7 cd 7c b4 6a 56 7c\nae f7 cb 7c b4 6a 56 7c 52 69 63 68 b5 6a 56 7c\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n</code></pre>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "974",
    "tags": [
        "pe"
    ],
    "user": "LUser",
    "time": "Sep 30, 2019 at 16:50",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Yes, you can (assuming the info is not faked). I made\n  <a href=\"https://gist.github.com/skochinsky/07c8e95e33d9429d81a75622b5d24c8b\" rel=\"nofollow noreferrer\">\n   a script\n  </a>\n  which includes some of the common compiler/linker identifiers, and evening for missing ones you still have the build number from which you should be able to track down the specific Visual Studio version.\n </p>\n <p>\n  <strong>\n   Script in case if it is lost\n  </strong>\n </p>\n <pre><code># based on code from http://trendystephen.blogspot.be/2008/01/rich-header.html\nimport sys\nimport struct\n\n# I'm trying not to bury the magic number...\nCHECKSUM_MASK = 0x536e6144 # DanS (actuall SnaD)\nRICH_TEXT = 'Rich'\nRICH_TEXT_LENGTH = len(RICH_TEXT)\nPE_START = 0x3c\nPE_FIELD_LENGTH = 4\n\n# most of values up to AliasObj900 are from old MSVC leak with private PDBs; \n# rest is from guesses/observations\nPRODID_MAP = {\n  0: \"Unknown\",\n  1: \"Import0\",\n  2: \"Linker510\",\n  3: \"Cvtomf510\",\n  4: \"Linker600\",\n  5: \"Cvtomf600\",\n  6: \"Cvtres500\",\n  7: \"Utc11_Basic\",\n  8: \"Utc11_C\",\n  9: \"Utc12_Basic\",\n  10: \"Utc12_C\",\n  11: \"Utc12_CPP\",\n  12: \"AliasObj60\",\n  13: \"VisualBasic60\",\n  14: \"Masm613\",\n  15: \"Masm710\",\n  16: \"Linker511\",\n  17: \"Cvtomf511\",\n  18: \"Masm614\",\n  19: \"Linker512\",\n  20: \"Cvtomf512\",\n  21: \"Utc12_C_Std\",\n  22: \"Utc12_CPP_Std\",\n  23: \"Utc12_C_Book\",\n  24: \"Utc12_CPP_Book\",\n  25: \"Implib700\",\n  26: \"Cvtomf700\",\n  27: \"Utc13_Basic\",\n  28: \"Utc13_C\",\n  29: \"Utc13_CPP\",\n  30: \"Linker610\",\n  31: \"Cvtomf610\",\n  32: \"Linker601\",\n  33: \"Cvtomf601\",\n  34: \"Utc12_1_Basic\",\n  35: \"Utc12_1_C\",\n  36: \"Utc12_1_CPP\",\n  37: \"Linker620\",\n  38: \"Cvtomf620\",\n  39: \"AliasObj70\",\n  40: \"Linker621\",\n  41: \"Cvtomf621\",\n  42: \"Masm615\",\n  43: \"Utc13_LTCG_C\",\n  44: \"Utc13_LTCG_CPP\",\n  45: \"Masm620\",\n  46: \"ILAsm100\",\n  47: \"Utc12_2_Basic\",\n  48: \"Utc12_2_C\",\n  49: \"Utc12_2_CPP\",\n  50: \"Utc12_2_C_Std\",\n  51: \"Utc12_2_CPP_Std\",\n  52: \"Utc12_2_C_Book\",\n  53: \"Utc12_2_CPP_Book\",\n  54: \"Implib622\",\n  55: \"Cvtomf622\",\n  56: \"Cvtres501\",\n  57: \"Utc13_C_Std\",\n  58: \"Utc13_CPP_Std\",\n  59: \"Cvtpgd1300\",\n  60: \"Linker622\",\n  61: \"Linker700\",\n  62: \"Export622\",\n  63: \"Export700\",\n  64: \"Masm700\",\n  65: \"Utc13_POGO_I_C\",\n  66: \"Utc13_POGO_I_CPP\",\n  67: \"Utc13_POGO_O_C\",\n  68: \"Utc13_POGO_O_CPP\",\n  69: \"Cvtres700\",\n  70: \"Cvtres710p\",\n  71: \"Linker710p\",\n  72: \"Cvtomf710p\",\n  73: \"Export710p\",\n  74: \"Implib710p\",\n  75: \"Masm710p\",\n  76: \"Utc1310p_C\",\n  77: \"Utc1310p_CPP\",\n  78: \"Utc1310p_C_Std\",\n  79: \"Utc1310p_CPP_Std\",\n  80: \"Utc1310p_LTCG_C\",\n  81: \"Utc1310p_LTCG_CPP\",\n  82: \"Utc1310p_POGO_I_C\",\n  83: \"Utc1310p_POGO_I_CPP\",\n  84: \"Utc1310p_POGO_O_C\",\n  85: \"Utc1310p_POGO_O_CPP\",\n  86: \"Linker624\",\n  87: \"Cvtomf624\",\n  88: \"Export624\",\n  89: \"Implib624\",\n  90: \"Linker710\",\n  91: \"Cvtomf710\",\n  92: \"Export710\",\n  93: \"Implib710\",\n  94: \"Cvtres710\",\n  95: \"Utc1310_C\",\n  96: \"Utc1310_CPP\",\n  97: \"Utc1310_C_Std\",\n  98: \"Utc1310_CPP_Std\",\n  99: \"Utc1310_LTCG_C\",\n  100: \"Utc1310_LTCG_CPP\",\n  101: \"Utc1310_POGO_I_C\",\n  102: \"Utc1310_POGO_I_CPP\",\n  103: \"Utc1310_POGO_O_C\",\n  104: \"Utc1310_POGO_O_CPP\",\n  105: \"AliasObj710\",\n  106: \"AliasObj710p\",\n  107: \"Cvtpgd1310\",\n  108: \"Cvtpgd1310p\",\n  109: \"Utc1400_C\",\n  110: \"Utc1400_CPP\",\n  111: \"Utc1400_C_Std\",\n  112: \"Utc1400_CPP_Std\",\n  113: \"Utc1400_LTCG_C\",\n  114: \"Utc1400_LTCG_CPP\",\n  115: \"Utc1400_POGO_I_C\",\n  116: \"Utc1400_POGO_I_CPP\",\n  117: \"Utc1400_POGO_O_C\",\n  118: \"Utc1400_POGO_O_CPP\",\n  119: \"Cvtpgd1400\",\n  120: \"Linker800\",\n  121: \"Cvtomf800\",\n  122: \"Export800\",\n  123: \"Implib800\",\n  124: \"Cvtres800\",\n  125: \"Masm800\",\n  126: \"AliasObj800\",\n  127: \"PhoenixPrerelease\",\n  128: \"Utc1400_CVTCIL_C\",\n  129: \"Utc1400_CVTCIL_CPP\",\n  130: \"Utc1400_LTCG_MSIL\",\n  131: \"Utc1500_C\",\n  132: \"Utc1500_CPP\",\n  133: \"Utc1500_C_Std\",\n  134: \"Utc1500_CPP_Std\",\n  135: \"Utc1500_CVTCIL_C\",\n  136: \"Utc1500_CVTCIL_CPP\",\n  137: \"Utc1500_LTCG_C\",\n  138: \"Utc1500_LTCG_CPP\",\n  139: \"Utc1500_LTCG_MSIL\",\n  140: \"Utc1500_POGO_I_C\",\n  141: \"Utc1500_POGO_I_CPP\",\n  142: \"Utc1500_POGO_O_C\",\n  143: \"Utc1500_POGO_O_CPP\",\n\n  144: \"Cvtpgd1500\",\n  145: \"Linker900\",\n  146: \"Export900\",\n  147: \"Implib900\",\n  148: \"Cvtres900\",\n  149: \"Masm900\",\n  150: \"AliasObj900\",\n  151: \"Resource900\",\n\n  152: \"AliasObj1000\",\n  154: \"Cvtres1000\",\n  155: \"Export1000\",\n  156: \"Implib1000\",\n  157: \"Linker1000\",\n  158: \"Masm1000\",\n\n  170: \"Utc1600_C\",\n  171: \"Utc1600_CPP\",\n  172: \"Utc1600_CVTCIL_C\",\n  173: \"Utc1600_CVTCIL_CPP\",\n  174: \"Utc1600_LTCG_C \",\n  175: \"Utc1600_LTCG_CPP\",\n  176: \"Utc1600_LTCG_MSIL\",\n  177: \"Utc1600_POGO_I_C\",\n  178: \"Utc1600_POGO_I_CPP\",\n  179: \"Utc1600_POGO_O_C\",\n  180: \"Utc1600_POGO_O_CPP\",\n\n  # vvv\n  183: \"Linker1010\",\n  184: \"Export1010\",\n  185: \"Implib1010\",\n  186: \"Cvtres1010\",\n  187: \"Masm1010\",\n  188: \"AliasObj1010\",\n  # ^^^\n\n  199: \"AliasObj1100\",\n  201: \"Cvtres1100\",\n  202: \"Export1100\",\n  203: \"Implib1100\",\n  204: \"Linker1100\",\n  205: \"Masm1100\",\n\n  206: \"Utc1700_C\",\n  207: \"Utc1700_CPP\",\n  208: \"Utc1700_CVTCIL_C\",\n  209: \"Utc1700_CVTCIL_CPP\",\n  210: \"Utc1700_LTCG_C \",\n  211: \"Utc1700_LTCG_CPP\",\n  212: \"Utc1700_LTCG_MSIL\",\n  213: \"Utc1700_POGO_I_C\",\n  214: \"Utc1700_POGO_I_CPP\",\n  215: \"Utc1700_POGO_O_C\",\n  216: \"Utc1700_POGO_O_CPP\",\n}\n\n##\n# A convenient exception to raise if the Rich Header doesn't exist.\nclass RichHeaderNotFoundException(Exception):\n    def __init__(self):\n        Exception.__init__(self, \"Rich footer does not appear to exist\")\n\n##\n# Locate the body of the data that contains the rich header This will be\n# (roughly) between 0x3c and the beginning of the PE header, but the entire\n# thing up to the last checksum will be needed in order to verify the header.\ndef get_file_header(file_name):\n    f = open(file_name,'rb')\n\n    #start with 0x3c\n    f.seek(PE_START)\n    data = f.read(PE_FIELD_LENGTH)\n\n    if data == '': #File is empty, bail\n        raise RichHeaderNotFoundException()\n    end = struct.unpack('<L',data)[0] # get the value at 0x3c\n\n    f.seek(0)\n    data = f.read( end ) # read until that value is reached\n    f.close()\n\n    return data\n\n##\n# This class assists in parsing the Rich Header from PE Files.\n# The Rich Header is the section in the PE file following the dos stub but\n# preceding the lfa_new header which is inserted by link.exe when building with\n# the Microsoft Compilers.  The Rich Heder contains the following:\n# <pre>\n# marker, checksum, checksum, checksum, \n# R_compid_i, R_occurrence_i, \n# R_compid_i+1, R_occurrence_i+1, ...  \n# R_compid_N-1, R_occurrence_N-1, Rich, marker\n#\n# marker = checksum XOR 0x536e6144\n# R_compid_i is the ith compid XORed with the checksum\n# R_occurrence_i is the ith occurrence  XORed with the checksum\n# Rich = the text string 'Rich'\n# The checksum is the sum of all the PE Header values rotated by their\n# offset and the sum of all compids rotated by their occurrence counts.  \n# </pre>\n# @see _validate_checksum code for checksum calculation\nclass ParsedRichHeader:\n    ##\n    # Creates a ParsedRichHeader from the specified PE File.\n    # @throws RichHeaderNotFoundException if the file does not contain a rich header\n    # @param file_name The PE File to be parsed\n    def __init__(self, file_name):\n        ## The file that was parsed\n        self.file_name = file_name\n        self._parse( file_name )\n\n    ##\n    # Used internally to parse the PE File and extract Rich Header data.\n    # Initializes self.compids and self.valid_checksum. \n    # @param file_name The PE File to be parsed\n    # @throws RichHeaderNotFoundException if the file does not contain a rich header\n    def _parse(self,file_name):\n        #make sure there is a header:\n        data = get_file_header( file_name )\n\n        compid_end_index = data.find(RICH_TEXT) \n        if compid_end_index == -1:\n            raise RichHeaderNotFoundException()\n\n        rich_offset = compid_end_index + RICH_TEXT_LENGTH\n\n        checksum_text = data[rich_offset:rich_offset+4] \n        checksum_value = struct.unpack('<L', checksum_text)[0]\n        #start marker denotes the beginning of the rich header\n        start_marker = struct.pack('<LLLL',checksum_value ^ CHECKSUM_MASK, checksum_value, checksum_value, checksum_value )[0] \n\n        rich_header_start = data.find(start_marker)\n        if rich_header_start == -1:\n            raise RichHeaderNotFoundException()\n\n        compid_start_index = rich_header_start + 16 # move past the marker and 3 checksums\n\n        compids = dict()\n        for i in range(compid_start_index, compid_end_index, 8):\n            compid = struct.unpack('<L',data[i:i+4])[0] ^ checksum_value\n            count = struct.unpack('<L',data[i+4:i+8])[0] ^ checksum_value\n            compids[compid]=count\n\n        ## A dictionary of compids and their occurrence counts\n        self.compids = compids\n        ## A value for later reference to see if the checksum was valid\n        self.valid_checksum = self._validate_checksum( data, rich_header_start, checksum_value )\n\n    ##\n    # Compute the checksum value and see if it matches the checksum stored in\n    # the Rich Header.\n    # The checksum is the sum of all the PE Header values rotated by their\n    # offset and the sum of all compids rotated by their occurrence counts\n    # @param data A blob of binary data that corresponds to the PE Header data\n    # @param rich_header_start The offset to marker, checksum, checksum, checksum\n    # @returns True if the checksum is valid, false otherwise\n    def _validate_checksum(self, data, rich_header_start, checksum):\n\n        #initialize the checksum offset at which the rich header is located\n        cksum = rich_header_start\n\n        #add the value from the pe header after rotating the value by its offset in the pe header\n        for i in range(0,rich_header_start):\n            if PE_START <= i <= PE_START+PE_FIELD_LENGTH-1:\n                continue\n            temp = ord(data[i])\n            cksum+= ((temp << (i%32)) | (temp >> (32-(i%32))) & 0xff)\n            cksum &=0xffffffff\n\n        #add each compid to the checksum after rotating it by its occurrence count\n        for k in self.compids.keys():\n            cksum += (k << self.compids[k]%32 | k >> ( 32 - (self.compids[k]%32)))\n            cksum &=0xffffffff\n\n        ## A convenient place for storing the checksum that was computing during checksum validation\n        self.checksum = cksum\n\n        return cksum == checksum\n\nif __name__ == \"__main__\":\n    ph = ParsedRichHeader(sys.argv[1])\n    print (\"PRODID   name            build count\")\n    for key in ph.compids.keys():\n        count = ph.compids[key]\n        prodid, build = (key>>16), key&0xFFFF\n        prodid_name = PRODID_MAP[prodid] if prodid in PRODID_MAP else \"<unknown>\"\n        print ('%6d   %-15s %5d %5d' % (prodid, prodid_name, build, count))\n    if ph.valid_checksum:\n        print (\"Checksum valid\")\n    else:\n        print(\"Checksum not valid!\")\n</code></pre>\n <p>\n  <strong>\n   Output\n  </strong>\n </p>\n <pre><code>PRODID   name            build count\n     1   Import0             0   165\n   155   Export1000      40219     1\n   149   Masm900         30729     2\n   152   AliasObj1000    20115     1\n   224   <unknown>       40629     6\n   147   Implib900       30729    27\n   157   Linker1000      40219     1\n   175   Utc1600_LTCG_CPP 40219    26\n   223   <unknown>       40629     1\n</code></pre>\n <p>\n  More info from\n  <a href=\"http://bytepointer.com/articles/the_microsoft_rich_header.htm\" rel=\"nofollow noreferrer\">\n   http://bytepointer.com/articles/the_microsoft_rich_header.htm\n  </a>\n  (emphasis mine).\n </p>\n <blockquote>\n  <p>\n   Most of the entries above have an associated build number of the tool\n  being represented, such as the compiler, assembler and linker. One\n  exception to this is the imported functions count, which happens to be\n  the total number of imported functions referenced in all DLLs. This is\n  usually the only entry with a\n   <strong>\n    build number of zero\n   </strong>\n   . Note that the\n  \"Rich\" structure does not store information on the number of\n  static/private functions within each OBJ/source file.\n  </p>\n </blockquote>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Igor Skochinsky",
            "time": "Oct 1, 2019 at 19:46",
            "is_accepted": true,
            "comments": [
                {
                    "user": "LUser",
                    "text": "<span class=\"comment-copy\">Checking this out now.</span>",
                    "time": null
                },
                {
                    "user": "LUser",
                    "text": "<span class=\"comment-copy\">What does Import0 supposed to mean?  I assume Import0 is the compiler in question from count.</span>",
                    "time": null
                },
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">not 100% sure but IIRC Import0 are for pseudo-object entries for the import table entries generated by the linker</span>",
                    "time": null
                }
            ]
        }
    ]
}