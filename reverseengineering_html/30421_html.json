{
    "title": "Understanding disassembly information from Visual Studio's dumpbin and GNU's objdump",
    "link": "https://reverseengineering.stackexchange.com/questions/30421/understanding-disassembly-information-from-visual-studios-dumpbin-and-gnus-obj",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I usually write my code on Windows, and there are two different types of development environments, each providing their own tools to view the assembly code of an object file(\n  <code>\n   *.obj\n  </code>\n  ) or executable (\n  <code>\n   *.exe\n  </code>\n  ).\n </p>\n <p>\n  If I am working with Visual Studio build system from command line, the\n  <code>\n   dumpbin /disasm file.obj\n  </code>\n  command can generate disassemble a binary file. A snippet of a disassembly from an executable, produced by\n  <code>\n   dumpbin\n  </code>\n  :\n </p>\n <pre><code>  000000014000E712: 41 81 F0 6E 74 65  xor         r8d,6C65746Eh\n                    6C\n  000000014000E719: 41 81 F1 47 65 6E  xor         r9d,756E6547h\n                    75\n  000000014000E720: 44 8B D2           mov         r10d,edx\n  000000014000E723: 8B F0              mov         esi,eax\n  000000014000E725: 33 C9              xor         ecx,ecx\n  000000014000E727: 41 8D 43 01        lea         eax,[r11+1]\n  000000014000E72B: 45 0B C8           or          r9d,r8d\n  000000014000E72E: 0F A2              cpuid\n  000000014000E730: 41 81 F2 69 6E 65  xor         r10d,49656E69h\n                    49\n  000000014000E737: 89 04 24           mov         dword ptr [rsp],eax\n</code></pre>\n <p>\n  However, if I am working with the GNU toolkit (I mean mingw64, which works with native windows binaries), then running\n  <code>\n   objdump -D file.obj\n  </code>\n  gives a disassembly like this:\n </p>\n <pre><code>   14000e712:   41 81 f0 6e 74 65 6c    xor    $0x6c65746e,%r8d\n   14000e719:   41 81 f1 47 65 6e 75    xor    $0x756e6547,%r9d\n   14000e720:   44 8b d2                mov    %edx,%r10d\n   14000e723:   8b f0                   mov    %eax,%esi\n   14000e725:   33 c9                   xor    %ecx,%ecx\n   14000e727:   41 8d 43 01             lea    0x1(%r11),%eax\n   14000e72b:   45 0b c8                or     %r8d,%r9d\n   14000e72e:   0f a2                   cpuid  \n   14000e730:   41 81 f2 69 6e 65 49    xor    $0x49656e69,%r10d\n   14000e737:   89 04 24                mov    %eax,(%rsp)\n</code></pre>\n <p>\n  Now, it is immediately clear that both are providing the same information. However, I want to know what the numbers on the left column mean (e.g.\n  <code>\n   14000e712\n  </code>\n  )? Also why is the instruction written differently (e.g. on the first line,\n  <code>\n   dumpbin\n  </code>\n  writes\n  <code>\n   r8d,6C65746Eh\n  </code>\n  , while\n  <code>\n   objdump\n  </code>\n  writes\n  <code>\n   $0x6c65746e,%r8d\n  </code>\n  ). Why is this, and what do the different representations mean? Additionally dumpbin seems to write extra information such as\n  <code>\n   dword ptr\n  </code>\n  that\n  <code>\n   objdump\n  </code>\n  doesn't write.\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "2k",
    "tags": [
        "disassembly",
        "windows",
        "assembly",
        "objdump"
    ],
    "user": "S R Maiti",
    "time": "May 20, 2022 at 9:59",
    "comments": [
        {
            "user": "fpmurphy",
            "text": "<html><body><span class=\"comment-copy\">\n <code>\n  dumpbin\n </code>\n is using what is known as Intel (dis)assembly syntax.\n <code>\n  By default, objdump\n </code>\n , being a GNU utility is using what is known as AT&T (dis)assembly syntax. If you want\n <code>\n  objdump\n </code>\n to display output in Intel syntax, add\n <code>\n  -Mintel\n </code>\n to your\n <code>\n  objdump\n </code>\n command line.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Let's break it down. The first and most obvious difference is Intel syntax (\n  <code>\n   dumpbin\n  </code>\n  ) vs. AT&T syntax (\n  <code>\n   objdump\n  </code>\n  ) for the output you give. That's be the part of your question:\n </p>\n <blockquote>\n  <p>\n   Also why is the instruction written differently (e.g. on the first line, dumpbin writes\n   <code>\n    r8d,6C65746Eh\n   </code>\n   , while objdump writes\n   <code>\n    $0x6c65746e,%r8d\n   </code>\n   ). Why is this, and what do the different representations mean?\n  </p>\n </blockquote>\n <p>\n  However,\n  <code>\n   objdump\n  </code>\n  lets you choose between the two and just defaults to AT&T (aka\n  <code>\n   att\n  </code>\n  ). Excerpt from the\n  <code>\n   man\n  </code>\n  page:\n </p>\n <pre><code>\"intel\"\n\"att\"\n    Select between intel syntax mode and AT&T syntax mode.\n</code></pre>\n <p>\n  So you could simply use:\n  <code>\n   objdump -D -M intel ...\n  </code>\n  (also\n  <code>\n   -Mintel\n  </code>\n  ) to get way closer to the output from\n  <code>\n   dumpbin\n  </code>\n  .\n </p>\n <p>\n  However, a comparison of the syntax variants can be found\n  <a href=\"https://en.wikipedia.org/wiki/X86_assembly_language#Syntax\" rel=\"nofollow noreferrer\">\n   on Wikipedia\n  </a>\n  .\n  <a href=\"http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html\" rel=\"nofollow noreferrer\">\n   This dated overview\n  </a>\n  may also help. The most important difference is that Intel syntax places the target first and the source last, whereas with AT&T it's the opposite.\n </p>\n <p>\n  Let's take the instruction you gave:\n </p>\n <ul>\n  <li>\n   Intel:\n   <code>\n    xor r8d,6C65746Eh\n   </code>\n   <ul>\n    <li>\n     <code>\n      xor\n     </code>\n     instruction\n    </li>\n    <li>\n     (first) target operand is\n     <code>\n      r8d\n     </code>\n     (lower 32-bit of the\n     <code>\n      r8\n     </code>\n     register)\n    </li>\n    <li>\n     (second) source operand is a literal\n     <code>\n      6C65746Eh\n     </code>\n     (the hexadecimal is denoted via the trailing\n     <code>\n      h\n     </code>\n     here)\n    </li>\n   </ul>\n  </li>\n  <li>\n   AT&T:\n   <code>\n    xor $0x6c65746e,%r8d\n   </code>\n   <ul>\n    <li>\n     <code>\n      xor\n     </code>\n     instruction\n    </li>\n    <li>\n     (first) source operand is a literal\n     <code>\n      $0x6c65746e\n     </code>\n     (the hexadecimal is denoted via the leading\n     <code>\n      0x\n     </code>\n     here, IIRC\n     <code>\n      $\n     </code>\n     is for literals/addresses)\n    </li>\n    <li>\n     (second) target operand is\n     <code>\n      %r8d\n     </code>\n     (lower 32-bit of the\n     <code>\n      r8\n     </code>\n     register)\n    </li>\n   </ul>\n  </li>\n </ul>\n <p>\n  NB: This is largely a matter of taste. Binutils (the set of tools around\n  <code>\n   objdump\n  </code>\n  ) and others like GDB default to AT&T syntax, but you can tell them to use the Intel syntax. Most of the disassembly I work with is Intel syntax, but it's good to be aware of the two syntax variants and know how they compare.\n </p>\n <blockquote>\n  <p>\n   However, I want to know what the numbers on the left column mean (e.g. 14000e712)?\n  </p>\n </blockquote>\n <p>\n  Those are the addresses. You probably know that executables typically take a different form when mapped into memory than on disk and that address implies two things:\n </p>\n <ol>\n  <li>\n   it pretends that the image is mapped at base address 0x140000000\n  </li>\n  <li>\n   0x14000e712 is simply an address with offset 0xe712\n   <em>\n    into\n   </em>\n   the mapped image\n  </li>\n </ol>\n <p>\n  Edit 1: Oh and perhaps one word about this\n  <code>\n   mov dword ptr [rsp],eax\n  </code>\n  versus\n  <code>\n   mov %eax,(%rsp)\n  </code>\n  business. I find the Intel syntax more readable, since it doesn't make be think where the syntax can give the clue. \"Write DWORD to address pointed to by\n  <code>\n   rsp\n  </code>\n  , fair enough\". However, I suppose the reasoning behind the more concise AT&T syntax is that the knowledge about the operation's size (DWORD) can be deduced from the operand (\n  <code>\n   eax\n  </code>\n  ) and so it simply leaves out the more or less cosmetic hint of\n  <code>\n   dword ptr\n  </code>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "May 20, 2022 at 10:03",
            "is_accepted": true,
            "comments": []
        }
    ]
}