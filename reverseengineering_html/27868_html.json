{
    "title": "Attempting to understand non-XZ file signatures within PBZX chunks",
    "link": "https://reverseengineering.stackexchange.com/questions/27868/attempting-to-understand-non-xz-file-signatures-within-pbzx-chunks",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  After my\n  <a href=\"https://reverseengineering.stackexchange.com/q/25419/33705\">\n   previous question\n  </a>\n  from nearly a year ago directing me to the YAA format to make sense of the chunks that could be decompressed, this time we're dealing with the chunks that made\n  <code>\n   pbzx\n  </code>\n  tell us that\n  <a href=\"https://kittywhiskers.eu/the-chronicles-of-big-sur-conclusion/\" rel=\"nofollow noreferrer\">\n   we're dealing with non-xz chunks\n  </a>\n  .\n </p>\n <p>\n  I've tried to slowly rewrite\n  <a href=\"http://newosxbook.com/articles/OTA.html\" rel=\"nofollow noreferrer\">\n   Jonathan Levin's first pbzx extractor\n  </a>\n  in Rust, the code I've written so far just reads out the flag of the file and each chunk's flag, length and signature (which for the most part should be the XZ header magic).\n </p>\n <pre><code>use std::io::{self, BufReader, Read, Seek, SeekFrom};\nuse std::fs::File;\nuse std::path::Path;\nuse binread::{BinRead, BinReaderExt};\n\n#[derive(Debug, BinRead)]\npub struct block {\n    flg: u64,\n    len: i64,\n    sig: u64\n}\n\n#[derive(Debug, BinRead)]\n#[br(magic = b\"pbzx\")]\npub struct pbzx  {\n    flag0: u64,\n    chunk: block\n}\n\nfn main() -> io::Result<()>  {\n    // Read file\n    let file = File::open(\"payload.008\")?;\n    let mut reader = BufReader::new(file);\n    // Apply it\n    let header: pbzx = reader.read_be().unwrap();\n    println!(\" {:#04x}\", header.flag0);\n    // Zeroth block\n    println!(\" {:#04x}, {}, {:#04x}\", header.chunk.flg, header.chunk.len, header.chunk.sig);\n    reader.seek(SeekFrom::Current(header.chunk.len-8)).expect(\"Could not get current position!\");\n    // All the other blocks\n    while (true) {  //\n                    // I should actually be using \"chunk.flg & ((1 << 24) | (1 << 23)) != 0\" but I don't know\n                    // where that's come from\n                    // How does someone exactly calculate these bitshifts?\n                    //\n        let chunk: block = reader.read_be().unwrap();\n        println!(\" {:#04x}, {}, {:#04x}\", chunk.flg, chunk.len, chunk.sig);\n        reader.seek(SeekFrom::Current(chunk.len-8)).expect(\"Could not get current position!\");\n    }\n\n    Ok(())\n}\n</code></pre>\n <p>\n  Running it makes it behave as expected, showing us a majority of chunks being XZ but some others, especially at the beginning, show non-repeating values that don't seem to make much sense.\n </p>\n <pre><code>kitty@kitty ~/Projects/pbzx                      \n> $ ./target/debug/pbzx             \n 0x800000\n 0x800000, 8386152, 0xfd377a585a000000\n 0x800000, 8388608, 0xf5278dda2c95573c\n 0x800000, 8387764, 0xfd377a585a000000\n 0x800000, 8388608, 0x7ec3ca75b21ecca8\n 0x800000, 8377552, 0xfd377a585a000000\n 0x800000, 8387576, 0xfd377a585a000000\n 0x800000, 8388608, 0x2cb02061c42ec23b\n 0x800000, 8388608, 0x94f8a22d86b5b145\n 0x800000, 8388608, 0x7cf626aff7e56be6\n 0x800000, 8388608, 0xd053c8e78ee64674\n 0x800000, 8388608, 0xafac0d53e933e247\n 0x800000, 8388608, 0xcc6c78f45ab958a5\n 0x800000, 5815664, 0xfd377a585a000000\n 0x800000, 3505580, 0xfd377a585a000000 \n _____________repeating_______________\n 0x800000, 4876720, 0xfd377a585a000000\n 0x800000, 4761144, 0xfd377a585a000000\n 0x800000, 4905372, 0xfd377a585a000000\n _____________repeating_______________\n 0x51e0b5, 4568784, 0xfd377a585a000000\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Io(Custom { kind: UnexpectedEof, error: \"Out of bytes in reader\" })', src/main.rs:35:45\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre>\n <p>\n  Searching for them in Hex Fiend, they are\n  <em>\n   confirmed\n  </em>\n  to be non-repeating, adjacent to a valid chunk (see\n  <code>\n   YZ\n  </code>\n  end signature) and don't match any known signatures. I tried converting between endians and got nothing, just in case.\n </p>\n <p>\n  <img alt=\"1\" src=\"https://i.sstatic.net/jKqDc.png\"/>\n </p>\n <p>\n  <img alt=\"2\" src=\"https://i.sstatic.net/fYYH9.png\"/>\n </p>\n <p>\n  I can go out on a limb and say they're encrypted but that begs the question but then that begs the question, how do I confirm that it is encrypted\n  <em>\n   before\n  </em>\n  exploring that path?\n </p>\n <p>\n  <a href=\"https://gist.github.com/pudquick/ff412bcb29c9c1fa4b8d\" rel=\"nofollow noreferrer\">\n   Pudquick's\n  </a>\n  version, modified with the new flag, goes ahead and treats it like a decompressed cpio chunk but gives me some valid chunks and some chunks containing unknown or no data, Levin's\n  <a href=\"http://newosxbook.com/src.jl?tree=listings&file=pbzx.c\" rel=\"nofollow noreferrer\">\n   updated version, which I used about a year ago\n  </a>\n  skipped those chunks altogether\n </p>\n <pre><code>-rw-r--r--  1 kitty  staff  388745580 May 12 19:10 payload.008\n-rw-r--r--  1 kitty  staff    8386152 Jun 21 02:30 payload.008.part00.cpio.xz\n-rw-r--r--  1 kitty  staff    8388608 Jun 21 02:30 payload.008.part01.cpio\n-rw-r--r--  1 kitty  staff    8387764 Jun 21 02:30 payload.008.part02.cpio.xz\n-rw-r--r--  1 kitty  staff    8388608 Jun 21 02:30 payload.008.part03.cpio\n-rw-r--r--  1 kitty  staff   16765128 Jun 21 02:30 payload.008.part04.cpio.xz\n-rw-r--r--  1 kitty  staff    8388608 Jun 21 02:30 payload.008.part05.cpio\n-rw-r--r--  1 kitty  staff          0 Jun 21 02:30 payload.008.part06.cpio.xz\n-rw-r--r--  1 kitty  staff    8388608 Jun 21 02:30 payload.008.part07.cpio\n-rw-r--r--  1 kitty  staff          0 Jun 21 02:30 payload.008.part08.cpio.xz\n-rw-r--r--  1 kitty  staff    8388608 Jun 21 02:30 payload.008.part09.cpio\n-rw-r--r--  1 kitty  staff          0 Jun 21 02:30 payload.008.part10.cpio.xz\n-rw-r--r--  1 kitty  staff    8388608 Jun 21 02:30 payload.008.part11.cpio\n-rw-r--r--  1 kitty  staff          0 Jun 21 02:30 payload.008.part12.cpio.xz\n-rw-r--r--  1 kitty  staff    8388608 Jun 21 02:30 payload.008.part13.cpio\n-rw-r--r--  1 kitty  staff          0 Jun 21 02:30 payload.008.part14.cpio.xz\n-rw-r--r--  1 kitty  staff    8388608 Jun 21 02:30 payload.008.part15.cpio\n-rw-r--r--  1 kitty  staff  288096620 Jun 21 02:30 payload.008.part16.cpio.xz\n</code></pre>\n <ul>\n  <li>\n   <p>\n    How do you tell that a chunk of data is encrypted?\n   </p>\n  </li>\n  <li>\n   <p>\n    How did the original PBZX decompression tools figure out the binary operations to be performed on a flag to signal the archive's end? I couldn't figure out the relationship between\n    <code>\n     0x51e0b5\n    </code>\n    and\n    <code>\n     0x800000\n    </code>\n   </p>\n   <p>\n    If it was just a matter of comparing the flag, then wouldn't a\n    <code>\n     while (flag == 0x800000)\n    </code>\n    be enough, why bother with those values in the first place?\n   </p>\n  </li>\n  <li>\n   <p>\n    What would be a good next step in understanding what those magic values mean?\n   </p>\n  </li>\n </ul>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 0,
    "views": "81",
    "tags": [
        "decompress",
        "ios",
        "macos"
    ],
    "user": "Kittywhiskers Van Gogh",
    "time": "Jun 21, 2021 at 9:56",
    "comments": [],
    "answers_data": []
}