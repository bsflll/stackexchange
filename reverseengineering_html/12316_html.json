{
    "title": "Fixing corrupt ELF header field \"e_shnum\" for use in GDB",
    "link": "https://reverseengineering.stackexchange.com/questions/12316/fixing-corrupt-elf-header-field-e-shnum-for-use-in-gdb",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  If the ELF header which usually can be read using\n  <code>\n   readelf\n  </code>\n  has been manually manipulated, let's say by increasing the value for the \"Size of section headers\" the binary still can be executed and works well.\n </p>\n <p>\n  However, this manipulation seems to trip up reverse engineering tools like GDC and GDB gives me the error:\n  <code>\n   not in executable format: File format not recognized\n  </code>\n  .\n </p>\n <p>\n  Is there a way to fix the ELF header without knowing the original value of \"Size of section headers\" in order to be able again to analyze the file using\n  <em>\n   standard tools\n  </em>\n  ?\n </p>\n <h1>\n  Detailed info:\n </h1>\n <p>\n  GDB is failing to run the binary because it says the file is\n  <code>\n   not in executable format : File format not recognized\n  </code>\n  but it works outside the GDB. The same things happen with the\n  <code>\n   libbfd\n  </code>\n  parser, it can't parse because file format is not recognized. The fact is I only change the number of section headers.\n </p>\n <h2>\n  Code\n </h2>\n <pre><code>#include <stdio.h>\n\nint main()\n{\n    printf(\"Hello World!\n\");\n    return 0;\n}\n</code></pre>\n <p>\n  Build by invoking\n  <code>\n   make hello\n  </code>\n  or on a 64-bit system\n  <code>\n   make CFLAGS=-m32 hello\n  </code>\n  .\n </p>\n <h2>\n  ELF header before\n </h2>\n <pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x8048320\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          4472 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         30 <-- notice me!\n  Section header string table index: 27\n</code></pre>\n <h2>\n  ELF header after\n </h2>\n <pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x8048320\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          4472 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         52 <-- already changed!\n  Section header string table index: 27\n</code></pre>\n <p>\n  GDB will output,\n </p>\n <blockquote>\n  <p>\n   not in executable format: File format not recognized\n  </p>\n </blockquote>\n <p>\n  But if I run it outside of GDB,\n </p>\n <pre><code>$ ./hello output:\nHello World!\n</code></pre>\n <p>\n  So is there either a method to fix the value for\n  <code>\n   e_shnum\n  </code>\n  <strong>\n   without\n  </strong>\n  knowing the correct value, or a workaround so I can debug this file in GDB?\n </p>\n</div>\n</body></html>",
    "votes": "7",
    "answers": 2,
    "views": "14k",
    "tags": [
        "gdb",
        "elf",
        "crackme"
    ],
    "user": "Fakhri Zulkifli",
    "time": "Nov 21, 2018 at 1:01",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  In this particular case, repairing the header can be automated. Since the section header string table is present, the original value of\n  <code>\n   e_shnum\n  </code>\n  can be found by counting the number of strings in the table.\n </p>\n <p>\n  Original:\n </p>\n <pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x3e0\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          6056 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         29  <-----------------\n  Section header string table index: 28\n</code></pre>\n <p>\n  Corrupted:\n </p>\n <pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x3e0\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          6056 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         52  <------------------\n  Section header string table index: 28\nreadelf: Error: Reading 2080 bytes extends past end of file for section headers\nreadelf: Error: Reading 7216 bytes extends past end of file for dynamic string table\n</code></pre>\n <p>\n  Reading the section header string table:\n </p>\n <blockquote>\n  <pre><code>#!/usr/bin/python3\n\nfrom elftools.elf.elffile import ELFFile\n\nwith open('hello', 'rb') as f:\n    elffile = ELFFile(f)\n    print(\"original e_shnum:\\t\" + str(len(elffile.get_section(28).data().decode('ascii').split('\\x00')) + 1))\n</code></pre>\n </blockquote>\n <p>\n  When run against the binary with the corrupted header, the output is as follows:\n </p>\n <pre><code>$ python3 recover_e_shnum.py \noriginal e_shnum:   29\n</code></pre>\n <p>\n  This script will repair the header automatically:\n </p>\n <blockquote>\n  <pre><code>#!/usr/bin/python3\n\nfrom elftools.elf.elffile import ELFFile\nfrom struct import pack\n\nwith open('hello', 'rb+') as f:\n    elffile = ELFFile(f)\n    e_shnum = len(elffile.get_section(28).data().decode('ascii').split('\\x00')) + 1 \n    f.seek(48)\n    f.write(pack('h', e_shnum))\n</code></pre>\n </blockquote>\n</div>\n</body></html>",
            "votes": "3",
            "user": "julian",
            "time": "Jan 1, 2020 at 2:54",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I recreated your binary and then used Radare to\n  <a href=\"https://reverseengineering.stackexchange.com/a/19924/22669\">\n   corrupt the header exactly as you did\n  </a>\n  , changing the number of section headers to 52.\n </p>\n <pre><code>r2 -w a.out -1c's 0; pfo elf64; .pf.elf_header.shnum=52'\n</code></pre>\n <p>\n  This only generated a warning with subsequent invocations of\n  <code>\n   readelf\n  </code>\n  .\n </p>\n <pre><code>$ readelf -h a.out \nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x1050\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          14624 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         11\n  Size of section headers:           64 (bytes)\n  Number of section headers:         52\n  Section header string table index: 28\nreadelf: Error: Reading 3328 bytes extends past end of file for section headers\n</code></pre>\n <p>\n  But I got the similar error from GDB,\n </p>\n <blockquote>\n  <p>\n   not in executable format: file truncated\n  </p>\n </blockquote>\n <p>\n  And, if I try to debug that file, I get\n </p>\n <blockquote>\n  <p>\n   No executable file specified.\n  </p>\n </blockquote>\n <p>\n  I could go back to the original easily with\n </p>\n <pre><code>r2 -w a.out -c's 0; pfo elf64; .pf.elf_header.shnum=52'\n</code></pre>\n <p>\n  However to answer your question about tooling,\n </p>\n <ul>\n  <li>\n   Radare works with it even if the header is set to 52. You can still debug it.\n  </li>\n  <li>\n   <p>\n    You can get gdb to work if the header is less than the original\n    <code>\n     shnum\n    </code>\n    , for instance setting it to\n    <code>\n     1\n    </code>\n    will only warn you,\n   </p>\n   <blockquote>\n    <p>\n     BFD: warning: /tmp/a.out has a corrupt string table index - ignoring\n    </p>\n   </blockquote>\n   <p>\n    but you can still debug the program.\n   </p>\n  </li>\n </ul>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Evan Carroll",
            "time": "Nov 20, 2018 at 22:59",
            "is_accepted": false,
            "comments": []
        }
    ]
}