{
    "title": "How to recover the exception info from .gcc_except_table and .eh_handle sections?",
    "link": "https://reverseengineering.stackexchange.com/questions/6311/how-to-recover-the-exception-info-from-gcc-except-table-and-eh-handle-sections",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  For\n  <code>\n   C++\n  </code>\n  program with\n  <code>\n   try\n  </code>\n  <code>\n   catch\n  </code>\n  defined, when using\n  <code>\n   g++\n  </code>\n  to compile it into assembly code (test is on x86 32bit Linux,\n  <code>\n   g++\n  </code>\n  4.6.3)\n </p>\n <pre><code>g++ -S cppexcept.cc\n</code></pre>\n <p>\n  A specified section called\n  <code>\n   .gcc_except_table\n  </code>\n  is produced like below:\n </p>\n <pre><code>        .section        .gcc_except_table\n        .align 4\n.LLSDA980:\n        .byte   0xff\n        .byte   0\n        .uleb128 .LLSDATT980-.LLSDATTD980\n.LLSDATTD980:\n        .byte   0x1\n        .uleb128 .LLSDACSE980-.LLSDACSB980\n.LLSDACSB980:\n        .uleb128 .LEHB3-.LFB980\n        .uleb128 .LEHE3-.LEHB3\n        .uleb128 0\n        .uleb128 0\n        .uleb128 .LEHB4-.LFB980\n        .uleb128 .LEHE4-.LEHB4\n        .uleb128 .L19-.LFB980\n        .uleb128 0x3\n        .uleb128 .LEHB5-.LFB980\n        .uleb128 .LEHE5-.LEHB5\n        .uleb128 0\n        .uleb128 0\n        .uleb128 .LEHB6-.LFB980\n        .uleb128 .LEHE6-.LEHB6\n        .uleb128 .L20-.LFB980\n        .uleb128 0\n        .uleb128 .LEHB7-.LFB980\n        .uleb128 .LEHE7-.LEHB7\n        .uleb128 .L21-.LFB980\n        .uleb128 0\n</code></pre>\n <p>\n  After the compilation into\n  <code>\n   exe file\n  </code>\n  with\n  <code>\n   ELF\n  </code>\n  format, it seems that there are two sections related to exception handling, which are\n  <code>\n   .gcc_except_table\n  </code>\n  and\n  <code>\n   .eh_frame\n  </code>\n  .\n </p>\n <p>\n  However, I dumped the contents of these two section with the following commands, comparing the labels' memory addresses with what are defined in\n  <code>\n   .gcc_except_table\n  </code>\n  , but it seems too blur to me...\n </p>\n <pre><code>objdump -s -j .gcc_except_table cppexcept\nobjdump -s -j .eh_frame cppexcept\n</code></pre>\n <p>\n  So my question is:\n </p>\n <p>\n  Is there any way to recover the information defined in the\n  <code>\n   .gcc_except_table\n  </code>\n  (which is shown above) from\n  <code>\n   ELF\n  </code>\n  file's\n  <code>\n   .gcc_except_table\n  </code>\n  and\n  <code>\n   eh_frame\n  </code>\n  tables?\n </p>\n</div>\n</body></html>",
    "votes": "7",
    "answers": 1,
    "views": "4k",
    "tags": [
        "disassembly",
        "assembly",
        "x86",
        "c++",
        "exception"
    ],
    "user": "lllllllllllll",
    "time": "Sep 25, 2014 at 1:01",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  (I think you may get some extra comments if you use\n  <code>\n   -fverbose-asm\n  </code>\n  .)\n </p>\n <p>\n  Recovering information from these tables is definitely possible, although documentation is scarce and is often present only in the code which parses them.\n </p>\n <p>\n  The\n  <code>\n   .eh_frame\n  </code>\n  layout is described briefly in the\n  <a href=\"http://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html\">\n   LSB documentation\n  </a>\n  . Ian Lance Taylor (author of the gold linker) also made some blog posts on\n  <a href=\"http://www.airs.com/blog/archives/460\">\n   <code>\n    .eh_frame\n   </code>\n  </a>\n  and\n  <a href=\"http://www.airs.com/blog/archives/464\">\n   <code>\n    .gcc_except_table\n   </code>\n   layout\n  </a>\n  .\n </p>\n <p>\n  For a more reference-like description, check my\n  <a href=\"http://www.hexblog.com/wp-content/uploads/2012/06/Recon-2012-Skochinsky-Compiler-Internals.pdf\">\n   Recon 2012 slides\n  </a>\n  (start at 37 or so).\n </p>\n <p>\n  I've made\n  <a href=\"http://www.hexblog.com/wp-content/uploads/2012/06/recon-2012-skochinsky-scripts.zip\">\n   an IDA script\n  </a>\n  (\n  <code>\n   gcc_extab.py\n  </code>\n  ) which parses\n  <code>\n   .eh_frame\n  </code>\n  and\n  <code>\n   .gcc_except_table\n  </code>\n  and formats them nicely.\n </p>\n <p>\n  Taking a sample program:\n </p>\n <pre><code>void f()\n{\n    throw 1;\n}\n\nint main()\n{\n    int j;\n    try {\n        f();\n    } catch (int i) {\n        j = i;\n    }   \n    return 0;\n}\n</code></pre>\n <p>\n  I'll show the commented structures produced by GCC.\n </p>\n <p>\n  First, the\n  <code>\n   .eh_table\n  </code>\n  (some parts omitted for clarity):\n </p>\n <pre><code>.Lframe1:                     # start of CFI 1\n    .long   .LECIE1-.LSCIE1   # length of CIE 1 data\n.LSCIE1:                      # start of CIE 1 data\n    .long   0                 # CIE id\n    .byte   0x1               # Version\n    .string \"zPL\"             # augmentation string:\n                              # z: has augmentation data\n                              # P: has personality routine pointer\n                              # L: has LSDA pointer\n    .uleb128 0x1              # code alignment factor\n    .sleb128 -4               # data alignment factor\n    .byte   0x8               # return address register no.\n    .uleb128 0x6              # augmentation data length (z)\n    .byte   0                 # personality routine pointer encoding (P): DW_EH_PE_ptr|DW_EH_PE_absptr\n    .long   __gxx_personality_v0 # personality routine pointer (P)\n    .byte   0                 # LSDA pointer encoding: DW_EH_PE_ptr|DW_EH_PE_absptr\n    .byte   0xc               # Initial CFI Instructions\n    [...]\n    .align 4\n.LECIE1:                      # end of CIE 1\n    [...]\n\n.LSFDE3:                      # start of FDE 3\n    .long   .LEFDE3-.LASFDE3  # length of FDE 3\n.LASFDE3:                     # start of FDE 3 data\n    .long   .LASFDE3-.Lframe1 # Distance to parent CIE from here\n    .long   .LFB1             # initial location                \n    .long   .LFE1-.LFB1       # range length                    \n    .uleb128 0x4              # Augmentation data length (z)    \n    .long   .LLSDA1           # LSDA pointer (L)                \n    .byte   0x4               # CFI instructions                \n    .long   .LCFI2-.LFB1\n    [...]\n    .align 4\n.LEFDE3:                      # end of FDE 3\n</code></pre>\n <p>\n  Next, the LSDA (language-specific data area) in\n  <code>\n   .gcc_except_table\n  </code>\n  , referenced by FDE 3:\n </p>\n <pre><code>.LLSDA1:                           # LSDA 1\n    .byte   0xff                   # LPStart encoding: DW_EH_PE_omit\n    .byte   0                      # TType encoding: DW_EH_PE_ptr|DW_EH_PE_absptr\n    .uleb128 .LLSDATT1-.LLSDATTD1  # TType offset\n.LLSDATTD1:                        # LSDA 1 action table\n    .byte   0x1                    # call site encoding: DW_EH_PE_uleb128|DW_EH_PE_absptr\n    .uleb128 .LLSDACSE1-.LLSDACSB1 # call site table length\n.LLSDACSB1:                        # LSDA 1 call site entries\n    .uleb128 .LEHB0-.LFB1          # call site 0 start\n    .uleb128 .LEHE0-.LEHB0         # call site 0 length\n    .uleb128 .L8-.LFB1             # call site 0 landing pad\n    .uleb128 0x1                   # call site 0 action (1=action 1)\n    .uleb128 .LEHB1-.LFB1          # call site 1 start\n    .uleb128 .LEHE1-.LEHB1         # call site 1 length\n    .uleb128 0                     # call site 1 landing pad\n    .uleb128 0                     # call site 1 action (0=no action)\n.LLSDACSE1:                        # LSDA 1 action table entries\n    .byte   0x1                    # action 1 filter (1=T1 typeinfo)\n    .byte   0                      # displacement to next action (0=end of chain)\n    .align 4\n    .long   _ZTIi                  # T1 typeinfo (\"typeinfo for int\")\n.LLSDATT1:                         # LSDA 1 TTBase\n</code></pre>\n</div>\n</body></html>",
            "votes": "10",
            "user": "Igor Skochinsky",
            "time": "Sep 25, 2014 at 10:38",
            "is_accepted": true,
            "comments": [
                {
                    "user": "lllllllllllll",
                    "text": "<span class=\"comment-copy\">Hello Igor, thank you a lot for this helpful answer! Do you mind to attach how you compile the simple program.? I tried on my computer and process the script with IDA 6.4, but I can not get your output.</span>",
                    "time": null
                },
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">This output is not from the script, it's annotated assembler output from the compiler.</span>",
                    "time": null
                }
            ]
        }
    ]
}