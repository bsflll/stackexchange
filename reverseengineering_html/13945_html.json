{
    "title": "What does the author mean in these reverse engineering notes?",
    "link": "https://reverseengineering.stackexchange.com/questions/13945/what-does-the-author-mean-in-these-reverse-engineering-notes",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am trying to write a decoder for an old video format used in a DOS game, the\n  <a href=\"https://wiki.multimedia.cx/index.php?title=Psygnosis_SMV\" rel=\"noreferrer\">\n   Psygnosis SMV video format\n  </a>\n  , but I'm having a hard time understanding the image decoding process, specifically this section:\n </p>\n <pre><code>Macroblocks drawing\n\nMacroblocks are stored in the following format:\n\n u8 pixels[16 * num_mblocks]\n u4 nibbles[num_mblocks]\n\nSize of pixels[] is equal to ST chunk's nibbles.\nFor each macroblock draw it by indexing its pixels by nibbles.\nFirst nibble stored in top 4 bits of byte.\n</code></pre>\n <p>\n  Here are the properties of the frame I am trying to decode:\n </p>\n <ul>\n  <li>\n   image width = 320\n  </li>\n  <li>\n   image height = 192\n  </li>\n  <li>\n   macroblock width = 16\n  </li>\n  <li>\n   macroblock height = 16\n  </li>\n  <li>\n   nibbles = 3840\n  </li>\n  <li>\n   frame size in bytes = 34560\n  </li>\n </ul>\n <p>\n  So according these, I computed the following values:\n </p>\n <pre><code>num_mblocks = nibbles / 16 = 3840 / 16 = 240 macroblocks\n\nfurther checking:\n(image width / macroblock width) * (image height / macroblock height)\n= (320 / 16) * (192 / 16)\n= 20 * 12\n= 240 macroblocks\n</code></pre>\n <p>\n  <strong>\n   1st problem:\n  </strong>\n </p>\n <p>\n  The size of\n  <code>\n   u8 pixels[16 * num_mblocks]\n  </code>\n  is indeed 3840 bytes, but what is the size of\n  <code>\n   u4 nibbles[num_mblocks]\n  </code>\n  supposed to be ? 240 bytes or half that amount since the type is\n  <code>\n   u4\n  </code>\n  ?\n </p>\n <p>\n  <strong>\n   2nd problem:\n  </strong>\n </p>\n <p>\n  When I divide the\n  <code>\n   frame size in bytes\n  </code>\n  by the number of\n  <code>\n   macroblocks\n  </code>\n  I end up with only 144 bytes per macroblock (34560 / 240 = 144), but to me this is very far from what it's supposed to be, I guess I'm wrong somewhere.\n </p>\n <p>\n  <strong>\n   3rd problem:\n  </strong>\n </p>\n <p>\n  The author wrote:\n </p>\n <p>\n  <em>\n   For each macroblock draw it by indexing its pixels by nibbles.\n  </em>\n </p>\n <p>\n  But what does that mean exactly ?\n </p>\n <p>\n  <strong>\n   Question\n  </strong>\n </p>\n <p>\n  Can you explain/shed some light on how one is supposed to decode a frame ?\n </p>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 1,
    "views": "176",
    "tags": [
        "file-format"
    ],
    "user": "aybe",
    "time": "Nov 16, 2016 at 13:46",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  NB: This is an assumption which may or may not be true; I haven't tested that against any real file.\n </p>\n <p>\n  It seems like the creators of the file format have been trying to save some space. They want to encode 256 colors (\"to encode 8-bit palettized video\"), so they'd need one byte per pixel. However, a certain smaller area of the screen ise likely to contain the same color pixels repeatedly. So, I'd say that each macroblock can contain only 16 different colors, representable in 4 bits/one nibble.\n </p>\n <p>\n  From\n  <code>\n   u8 pixels[16 * num_mblocks]\n  </code>\n  it seems like each macroblock has 16 pixel definitions, which are indexes into the general palette table, and need 1 byte each. What follows is one nibble per pixel which is an index into\n  <code>\n   pixels\n  </code>\n  .\n </p>\n <p>\n  So, for example, the pixels for one macro block would have 16 bytes which are indexes into the palette; which may look like this: (Sorry for some of the color names; i ran out of names that fit in 5 characters ...)\n </p>\n <pre><code>+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----\n+  1  +  2  +  3  +  4  +  5  +  6  +  7  +  8  +  9  +  A  +  B  +  C  +  D  +  E  +  F  +\n+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----\n| red |green|blue |yellw|magnt|cyan |grey |black|orang|gold |aqua |azure|ivory|plum |wheat|\n+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----\n</code></pre>\n <p>\n  Next, you need one nibble per pixel which is an index into that table. So the bytes CA 53 2D would represent 6 pixels being azure, gold, magenta, blue, green, and ivory.\n </p>\n <p>\n  So for a macroblock of 256 pixels you need 16 bytes for the pixel table, and 256/2=128 bytes for the pixels. Which sums up to the 144 that you calculated. The\n  <code>\n   u4 nibbles[num_mblocks]\n  </code>\n  is probably wrong and should be\n  <code>\n   u4 nibbles[num_mblocks*pixels_per_mblock]\n  </code>\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Guntram Blohm",
            "time": "Nov 16, 2016 at 18:18",
            "is_accepted": false,
            "comments": [
                {
                    "user": "aybe",
                    "text": "<span class=\"comment-copy\">Thank you, I've been digging using your answer, however, I have an incorrect picture ... I started to suspect my implementation of that LZ77-like decompression and decided to attack the simplest thing in the format : decompress packed music chunks; while the algo produces the exact number of bytes, the content is wrong ... I'm actually struggling with this part !</span>",
                    "time": null
                }
            ]
        }
    ]
}