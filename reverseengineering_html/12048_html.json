{
    "title": "What is contained in this transmission? (RF pool-temperature sensor base unit receiver)",
    "link": "https://reverseengineering.stackexchange.com/questions/12048/what-is-contained-in-this-transmission-rf-pool-temperature-sensor-base-unit-re",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Note: I've made progress over at the EE stackexchange on pulling bits out of the signal (see\n  <a href=\"https://electronics.stackexchange.com/questions/145714/what-encoding-is-used-in-this-signal\">\n   https://electronics.stackexchange.com/questions/145714/what-encoding-is-used-in-this-signal\n  </a>\n  ), but now i think this group might be more interested in determining the\n  <em>\n   meaning\n  </em>\n  .\n </p>\n <p>\n  Sniffing the data pin on the\n  <em>\n   receiver's\n  </em>\n  module, i'm getting a 64-bit packet every minute.\n </p>\n <p>\n  The manufacturer states the temperature range as being 0F-158F (see\n  <a href=\"https://support.acurite.com/acurite/topics/what-is-the-temperature-range-of-the-00617\" rel=\"nofollow noreferrer\">\n   https://support.acurite.com/acurite/topics/what-is-the-temperature-range-of-the-00617\n  </a>\n  )\n </p>\n <p>\n  Changing the station code (there's an A/B/C switch on both sensor and base station), i've been able to determine that the first two bits are the only thing that affects (00=A, 01=B, 10=C).\n </p>\n <p>\n  The sensor and base each have C/F switches, but since a) 1F is smaller than 1C and there is no fractional display, and b) the manufacturer seems to prefer to state the range in F, and c) the F range is strictly nonnegative, it seems\n  <em>\n   likely\n  </em>\n  to me that the data is transmitted in terms of F.\n </p>\n <p>\n  In order to send 159 different levels, it only needs 8 bits, so the remaining 54 (64 - 2 station - 8 minimum data) bits are probably some combination of product ID, battery-level info (it has a \"low sensor battery\" indicator on the base), extra (unshown) precision, and checksums/crcs. (Of note, despite both sensor and base displays showing min/max readings, they appear to be uncoupled -- resetting one resets its min/max to the next current reading -- so i\n  <em>\n   don't\n  </em>\n  think the sensor transmits its min/max.)\n </p>\n <p>\n  Here are some example captures. I realize i haven't put enough rigor into controlling the temperature yet, but it's interesting to note that the bits change a little even when the display doesn't. There are two things that i suspect could cause this -- 1) maybe there\n  <em>\n   are\n  </em>\n  extra, unshown bits of precision, and/or 2) there\n  <strong>\n   <em>\n    is some noise\n   </em>\n  </strong>\n  in the signal, as confirmed by viewing the trace on an analog scope, which frequently shows some bits whose length is indeterminately between zero and one. (This also lends support to the idea of a checksum, as i have\n  <em>\n   not\n  </em>\n  observed glitchy data on the base station's display.)\n </p>\n <p>\n  Also note that i have no idea of the bit-order (or endianness) of any of the data in here (other than the tiny hint that it might be MSB-first b/c station code B is \"01\" and C is \"10\", but i wouldn't put too much weight on that).\n </p>\n <p>\n  Some very raw initial captures:\n </p>\n <pre><code>0000011110011000110000000000000000000000100011100000001100101101 # 73F (h76F,l69F,bat ok)\n0000011110011000110000000000000000000000100011100000001100101101\n00000111 10011000 11000000 00000000 00000000 10001110 00000011 00101101 # bytes? probably not.\n0000011110011000110000000000000000000000100011101000010010101010\n000001111001100011[22x0                ]100011101000010010101010 # lotta zeroes.\n0000011110011000110000000000000000000000100011100000001100101101 # 73F (h76F,l69F,bat ok)\n0000011110011000110000000000000000000000100011101000010010101010 # 73F (h76F,l69F,bat ok)\n0000011110011000110000000000000000000000100011100000010100101011 # 73F (h76F,l69F,bat ok)\n                                                ^--first difference.\n</code></pre>\n <p>\n  When \"sitting still\", a few bits near then end change:\n </p>\n <pre><code>0000011110011000110000000000000000000000100011101000010010101010 # 20(min)/23(cur)/25(max)\n0000011110011000110000000000000000000000100011100000010100101011\n0000011110011000110000000000000000000000100011100000011000101000\n0000011110011000110000000000000000000000100011100000010100101011\n0000011110011000110000000000000000000000100011101000010010101010\n------------------------------------------------x-----xxx-----xx changing bits.\n0000011110011000110000000000000000000000100011100000001100101101\n                                                     x       x   add'l changing bits.\n</code></pre>\n <p>\n  I initially looked for 23d, since Celsius seemed more likely as a sensor output:\n </p>\n <pre><code>0000 0111 1001 1000 1100 0000 0000 0000 0000 0000 1000 1110   0000 0101 0010 1011\n   0    7    9    8    C    0    0    0    0    0    8    E      0    5    2    B\n0    E    9    1    3    0    0    0    0    0    1    7      0    A    4    D\n\n0000 0111 1001 1000 1100 0000 0000 0000 0000 0000 1000 1110   1000 0100 1010 1010\n   0    7    9    8    C    0    0    0    0    0    8    E      8    4    A    A\n0    E    9    1    3    0    0    0    0    0    1    7      1    2    5    5\n\n                                                  ^^^^^^-- 0x17 = 23C, which is 73.4F ?\n                                                       ^^^^^^^^-- a more realistic 0x17 ?\n                                                            no, b/c of the 0x07 above it.\n\nMaybe we need to be looking for ~230(dec) instead of 23? 230=0xE6, 225=0xE1, 235=0xEB, 239=0xEF.\nThose are (from 225 up): 11100001, 11100110, 11101011, 11101111. the \"1110\" is here, MSB-first:\n      vvvv                                  vvvv\n0000011110011000110000000000000000000000100011100000001100101101\n0000011110011000110000000000000000000000100011100000010100101011\n0000011110011000110000000000000000000000100011100000010100101011\n0000011110011000110000000000000000000000100011100000011000101000\n0000011110011000110000000000000000000000100011101000000110101111 <--.\n0000011110011000110000000000000000000000100011101000001010101100    |\n0000011110011000110000000000000000000000100011101000010010101010    |\n0000011110011000110000000000000000000000100011101000010010101010    |\n    ^^^^                                   ^^^^            ^^^^(but only once)\nand here, LSB-first.\n\nA pair of them is interesting b/c the cur and max are both 23C, while the min is 21C.\n\n21C is listed as the min temp seen, and 210(degC*10)=0xD2=11010010. (21.9C=0xDB).\nSo that means we'd expect to see a 1101. Do we? MSB first, then LSB first:\n                                             vvvv      vvvv vvvv (not consistent)\n0000011110011000110000000000000000000000100011100000001100101101\n0000011110011000110000000000000000000000100011100000010100101011\n0000011110011000110000000000000000000000100011100000010100101011\n0000011110011000110000000000000000000000100011100000011000101000\n0000011110011000110000000000000000000000100011101000000110101111\n0000011110011000110000000000000000000000100011101000001010101100\n0000011110011000110000000000000000000000100011101000010010101010\n0000011110011000110000000000000000000000100011101000010010101010\n                                                          ^^^^\n                                                            ^^^^ (not consistent)\nNot really.\n\nLet's reset the sender. Now min/cur/max are all 23C / 74F (yes, up from the 73F before).\n\n0000011110011000110000000000000000000000100011101000100010100110\n\nDo we see 3 of the same pattern anywhere?\n\n       vvvvvvvv vvvv 3x 1100 MSB-first\n0000011110011000110000000000000000000000100011101000100010100110\n\n0000011110011000110000000000000000000000100011101000100010100110\n   ^^^^  ^^^^ ^^^^                        ^^^^             ^^^^ 5x 1100 LSB-first\n\n\n0000011110011000110000000000000000000000100011101000100010100110\n  ^^^^^      ^^^^^                       ^^^^^             ^^^^ 3x 11000 LSB-first\n\nOddly, 11000b=24d, which is a bit of a near-miss for 23C readings. Probably not\nrelevant for the 74F unless there's a 50F offset... though come to think of it,\nreading down to 50F probably covers the range people would want... Let's see\nwhat the product manual says it can do:\n\n  Temperature Range: 0º to 158º F, -18º C to 70º C\n  Temperature Accuracy: +/- 2°\n\nThat... looks like degF might be worthwhile to consider.\n\nOh, but that was the webpage... the PDF says:\n\n  32ºF to 158ºF; 0ºC to 70ºC\n\nwhich frankly seems more likely.\n</code></pre>\n <p>\n  I started coarsely manipulating the temperature and watching bits rise (^) and fall (v):\n </p>\n <pre><code>(Initially around 23C/74F):\n0000011110011000110000000000000000000000100011101000100010100110\n                                                v     ^ v     v\n0000011110011000110000000000000000000000100011100000101000100100\n\nBreathed on it up to 27C (81F):\n                                ^      ^    vvv^    v v ^    v\n0000011110011000110000000000000010000001100000010000000010100000\n\nIt fell to 24C (75F):\n                                v      vv   ^^^ ^    ^  v   ^ ^^\n0000011110011000110000000000000000000000000011111000010000101011\n                                                v    v  ^    ^\n0000011110011000110000000000000000000000000011110000000010101111\n\nThen to 24C (74F):\n                                        ^      v    ^^^^v   vvv\n0000011110011000110000000000000000000000100011100000111100100001\n\nThen to 23C (74F):\n                                                     vv      ^^\n0000011110011000110000000000000000000000100011100000100100100111\n                                                      ^v      vv\n0000011110011000110000000000000000000000100011100000101000100100\n\nStill 23C (74F)  [max 27C (81F), min 23C (74F)].\n\nMoved the sensor outside to let the temp fall.\nCurrent & min fell to 20C (68F):\n                                        v     v ^     v\n0000011110011000110000000000000000000000000011001000100000100100\n\nThen to 19C (66F):\n                                        ^    v^^      ^^^    v\n0000011110011000110000000000000000000000100010111000101110100000\n\nDown to 17C (63F):\n                                        v      v        v      ^\n0000011110011000110000000000000000000000000010101000101100100001\n\nDown to 16C (62F):\n                                                    v^vv    ^^^v\n0000011110011000110000000000000000000000000010101000010000101110\n</code></pre>\n <p>\n  Where does the temperature data start? The only time we had a bit change in the first 40 bits was when i breathed on it. Let's repeat that to see if those were glitches:\n </p>\n <pre><code>33C (91F):\n                                ^      ^^   v^v v     ^ ^   vv ^\n0000011110011000110000000000000010000001100001000000011010100011\n</code></pre>\n <p>\n  Apparently not a glitch. That's a 1 in the 33rd bit, just like before. Maybe the first 32bits are ID?\n  <strong>\n   OR\n  </strong>\n  , since the temperature goes up another 67F(!!!), maybe all those zeroes are just the high bits of the temperature. (The observed range so far is only 62F-91F (29degF), which is only the middle 1/5 of 0F-158F (158degF)).\n </p>\n <p>\n  Here's where i determined station codes. It had been set to \"A\" so far. There are also B and C.\n </p>\n <pre><code>73F A:\n0000011110011000110000000000000000000000100011101000000110101111\n\n72F B:\n ^                                            v^v   ^^^ v^  vv v\n0100011110011000110000000000000000000000100011010000111101100010\n                                                ^     v ^     v\n0100011110011000110000000000000000000000100011011000110111100000\n\n72F C:\n^v                                                      vv\n1000011110011000110000000000000000000000100011011000110100100000\n                                                v     ^ ^     ^\n1000011110011000110000000000000000000000100011010000111110100010\n\nOkay, well, the first two bits are clearly station code.\n  00=A, 01=B, 10=C\n</code></pre>\n <p>\n  I explored the idea of some of the bits being the model number, but to no avail:\n </p>\n <pre><code>What are the ways to represent 00617, the model number?\n617d=0x269=1001101001b\n\n6 1 7 = 110 001 111b = 0110 0001 0111b\n\nASCII for \"617\" is x36 x31 x37 = 00110110 00110001 00110111\n\nNot seeing it in [000111100110001100000000000000]\n</code></pre>\n <p>\n  More drift without a display change:\n </p>\n <pre><code>1000011110011000110000000000000000000000100011011000101100100110 a\n                                                v      v^      ^\n1000011110011000110000000000000000000000100011010000101010100111  b\n                                                ^     v v     v\n1000011110011000110000000000000000000000100011011000100000100101   c\n                                                v     ^ ^     ^\n1000011110011000110000000000000000000000100011010000101010100111  b\n22C (71F):\n                                                ^     v v     v\n1000011110011000110000000000000000000000100011011000100000100101   c\n</code></pre>\n <p>\n  Looking back at the data, i really need to explore more of the temperature range before drawing conclusions. Water baths below 32F are going to need salt, which is annoying, but at least 158F isn't too terrible for the plastic enclosure (according to\n  <a href=\"http://www.machinist-materials.com/comparison_table_for_plastics.htm\" rel=\"nofollow noreferrer\">\n   http://www.machinist-materials.com/comparison_table_for_plastics.htm\n  </a>\n  and\n  <a href=\"http://plastictroubleshooter.com/ThePlasticTroubleshooter/melt_temps.htm\" rel=\"nofollow noreferrer\">\n   http://plastictroubleshooter.com/ThePlasticTroubleshooter/melt_temps.htm\n  </a>\n  , though it does feel like it\n  <em>\n   could\n  </em>\n  be PVC...).\n </p>\n <p>\n  Current assumption:\n </p>\n <pre><code>ss0001111001100011dddddddddddddddddddddddddddddddddddddddddddddd\n--________________----------------------------------------------\n|  |               |\n|  |               `-- 46 bits of data (temp and maybe batt and checksum\n|  |\n|  `-- 16 bits of ID (and/or maybe battery health?). Hasn't changed yet.\n|\n`-- 2 bits of station code (00=A, 01=B, 10=C)\n</code></pre>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 1,
    "views": "466",
    "tags": [
        "file-format",
        "unpacking",
        "serial-communication",
        "encodings"
    ],
    "user": "Rob Starling",
    "time": "Apr 13, 2017 at 12:33",
    "comments": [
        {
            "user": "Rob Starling",
            "text": "<html><body><span class=\"comment-copy\">\n Hi Rob, and welcome to the Reverse Engineering SE beta! We're excited to have new people contribute and your bonus rep indicates that you're already familiar with how SE sites work. That said, we've voted down your question for the following reasons... ???\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Folks back on the Electronics SE (\n  <a href=\"https://electronics.stackexchange.com/a/257112/24681\">\n   https://electronics.stackexchange.com/a/257112/24681\n  </a>\n  ) have cracked the case.\n </p>\n <p>\n  There are, in fact, 8 bytes of data in a message.\n </p>\n <p>\n  The last byte(8) is an XOR checksum -- that is, XOR-ing all the bytes including it yields 0xFF.\n </p>\n <p>\n  The three bytes just before the checksum(5-7) are the temperature in Celsius, but encoded a little strangely -- of each byte, the low nibble (4-bits) is temperature data and the high bit (of the high nibble) is used to give the whole byte even parity.\n </p>\n <p>\n  The first two bits of the whole message are the station code (A=00, B=01, C=10).\n </p>\n <p>\n  The remaining bits are still unknown, but I haven't seen them change, either. They might be low-battery & product ID.\n </p>\n <p>\n  e.g.\n </p>\n <pre><code>1000011110011000110000000000000000000000100011100000001110101101\n</code></pre>\n <p>\n  breaks into bytes:\n </p>\n <pre><code>10000111 10011000 11000000 00000000 00000000 10001110 00000011 10101101\n^^-- station \"C\"                                               ^^^^^^^^-- checksum\n                       temperature--^^^^^^^^-^^^^^^^^-^^^^^^^^\n</code></pre>\n <p>\n  the temperature is encoded:\n </p>\n <pre><code>                                    00000000 10001110 00000011\n        even parity for each byte --^--------^--------^\n                                        ^^^^-----^^^^-----^^^^-- data (0E3h)\n</code></pre>\n <p>\n  <code>\n   0E3h\n  </code>\n  is\n  <code>\n   227d\n  </code>\n  , which is simply\n  <code>\n   22.7°C\n  </code>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Community",
            "time": "Apr 13, 2017 at 12:33",
            "is_accepted": false,
            "comments": []
        }
    ]
}