{
    "title": "Intel ME partitions EFFS and FCRS?",
    "link": "https://reverseengineering.stackexchange.com/questions/23324/intel-me-partitions-effs-and-fcrs",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <ol>\n  <li>\n   What is the purpose of partitions\n   <strong>\n    EFFS\n   </strong>\n   and\n   <strong>\n    FCRS\n   </strong>\n   on systems with Intel ME 8.x?\n  </li>\n  <li>\n   Is it currently possible to parse data in\n   <strong>\n    EFFS\n   </strong>\n   partition on a ME image?\n  </li>\n </ol>\n <p>\n  I hope anyone can help, there is so little information about this available.\n </p>\n <p>\n  Thanks.\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 2,
    "views": "412",
    "tags": [
        "firmware",
        "intel"
    ],
    "user": null,
    "time": "Feb 23, 2020 at 7:46",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I was working on this this weekend.  Turns out it's pretty straight-forward.  Simple list of contiguous files. Just copies files when they change, and marks the allocation-table entries as dead, for later collection.\n </p>\n <p>\n  The following is incomplete, but it should let you tweak and special-case your way through a specific MFS partition.  I've tried to document in comments where I've made large assumptions.\n </p>\n <p>\n  <strong>\n   EDIT: There do seem to be metadata in the data.\n  </strong>\n  E.g., when looking at the content of UKS, the copy in the SCA partition is clearly\n  <code>\n   0E f4 00 00\n  </code>\n  whereas in MFS, the data there is\n  <code>\n   80 06 0e f4 00 00\n  </code>\n  , so it looks like there's\n  <em>\n   leading\n  </em>\n  metadata.\n </p>\n <p>\n  <strong>\n   EDIT 2: Figured out the metadata.\n  </strong>\n  It gives a much better method for deterministically identifying files by number within a block than the method I devised without it.  Updated the code with a description and a rather complicated state-machine for successfully processing the metadata.\n </p>\n <pre><code>import sys\n\n#litte-endian integer readers\ndef read_leuint8(file):\n    data = file.read(1)\n    return data[0]\n\ndef read_leuint16(file):\n    data = file.read(2)\n    return data[0] | (data[1] << 8)\n\ndef read_leuint24(file):\n    data = file.read(3)\n    return data[0] | (data[1] << 8) | (data[2] << 16)\n\ndef read_leuint32(file):\n    data = file.read(4)\n    return data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24)\n\n\nclass MEFileSystemFileMetadataStateMachine:\n    \"\"\" \n    MEFileSystemFileMetadata:\n\n    Files in MFS have internal metadata entries.  Each file begins with a metadata \n    record, observed values are:\n        0xa# <bytes ahead until next metadata>  <0x01> <next meta block num> <0x00>\n        0xb# <blocks ahead until next metadata> <0x01> <next meta block num> <0x00>\n        0x8# <bytes remaining in file (including this metadata)>\n\n    where\n        #                   --  is the file number within the block.  This is the \n                                target for the fno field of the allocation table \n                                entry.\n        <bytes ahead...>    --  the number of bytes to move ahead to find the next \n                                metadata record (including this metadata).\n        <next meta block...>--  the 0x100-byte block number where the next metadata \n                                record is to be found. This value should be looked \n                                up through the data-page's block-indirection table.\n        <blocks ahead...>   --  the number of 0x100 byte blocks to move ahead to \n                                find the next metadata record (including this \n                                metadata).\n        <bytes remaining...>--  pretty straight-forward.\n\n    So, 0x8# metadata are file-end records; 0xa# are short-range references; and \n    0xb# are longer range references.  This metadata chain provides unamiguous file \n    numbers within the blocks, and since they're put at the block start of any \n    block that contains a file-start, it's easy to pick up from an allocation table \n    reference.\n\n    Note: 0x8# records don't point to the next metadata block, so we may have to \n    consume file-end padding (0xff until the next multiple of 0x10) if we get an \n    intermediate 0x8# metadata while searching for our target file.\n    \"\"\"\n    STATE_NEED_META = 0\n    STATE_NEED_SKIP_DATA = 1\n    STATE_NEED_FILE_DATA = 2\n    STATE_COMPLETE = 3\n\n    def __init__(self, file_no, file_len):\n        self.file_no = file_no\n\n        self.state = MEFileSystemFileMetadataStateMachine.STATE_NEED_META\n        self.bytes_needed = 1\n        self.byte_offset = 0\n        self.cur_meta = bytearray(5)\n        self.file_data = bytearray(file_len)\n        self.file_filled = 0\n        self.found_fileno = False\n\n        self.work_buf = self.cur_meta\n\n    def is_complete(self):\n        return self.state == self.STATE_COMPLETE\n\n    def get_file_data(self):\n        return self.file_data\n\n    def get_bytes_needed(self):\n        return self.bytes_needed\n\n    #returns the number of bytes consumed\n    def add_bytes(self, bytes, start_index, data_len=None, log_file = None):\n        \"\"\"\n        supplies data to satisfy the state-machine's need for data as reported\n        via get_bytes_needed().\n\n        bytes       -- the buffer containing the bytes to be fed in\n        start_index -- the start location of the bytes within the buffer\n        data_len    -- number of bytes in the array, starting at start_index.\n                       if None, then len(bytes) - start_index is assumed\n        \"\"\"\n\n        #shuffling data from potentially multiple calls to fill the data request from the \n        #state machine (get_bytes_needed)\n        data_len = len(bytes) - start_index if data_len is None else data_len\n\n        if data_len == 0: return 0 # nothing to do\n\n        #take the min of what's available and what we need\n        to_copy = data_len if data_len < self.bytes_needed else self.bytes_needed\n        if self.work_buf:\n            self.work_buf[self.byte_offset:(self.byte_offset+to_copy)] = bytes[start_index:(start_index+to_copy)]\n            self.byte_offset = self.byte_offset + to_copy\n        self.bytes_needed = self.bytes_needed - to_copy\n\n        #if we don't have enough to process, return so they can feed more\n        if self.bytes_needed > 0:\n            return to_copy\n\n        #we only make it this far once we've got the full bytes_needed data\n\n        meta_type = self.cur_meta[0] & 0xf0\n        if self.state == self.STATE_NEED_META:\n            if self.byte_offset == 1:\n                if meta_type in [0xa0, 0xb0]:\n                    self.bytes_needed = 4\n                else:\n                    self.bytes_needed = 1\n            else:\n                #Have we found the file number we seek yet?\n                if self.found_fileno or (self.file_no == self.cur_meta[0] & 0x0f):\n                    self.found_fileno = True\n                    self.state = self.STATE_NEED_FILE_DATA\n                    self.work_buf = self.file_data\n                    self.byte_offset = self.file_filled\n                else:\n                    self.state = self.STATE_NEED_SKIP_DATA\n                    self.work_buf = None\n                    self.byte_offset = None\n\n                #determine the data required based on metadata type, and whether we're\n                #skipping (so need to eat EOF padding on type 0x8# entries) or whether\n                #we're copying out file data.\n                if meta_type == 0x80:\n                    if self.state == self.STATE_NEED_SKIP_DATA:\n                        #if we're skipping a 0x8# entry, we need to eat EOF padding too\n                        padding = (0x10 - (self.cur_meta[1] & 0xf)) & 0xf\n                        self.bytes_needed = padding + self.cur_meta[1] - 2 #remove header len, too\n                    else:\n                        self.bytes_needed = self.cur_meta[1] - 2 #remove header len\n                elif meta_type == 0xa0:\n                    self.bytes_needed = self.cur_meta[1] - 5 #remove header len\n                elif meta_type == 0xb0:\n                    self.bytes_needed = self.cur_meta[1] * 0x100 - 5 #remove header len\n                else:\n                    if log_file:\n                        log_file.write(\"That's not a metadata type I've seen before...: 0x%02x\n\" % self.cur_meta[0])\n                    return None\n\n        elif self.state == self.STATE_NEED_SKIP_DATA: #recall: this is the state just *completed*\n            self.state = self.STATE_NEED_META\n            self.work_buf = self.cur_meta\n            self.byte_offset = 0\n            self.bytes_needed = 1\n\n        elif self.state == self.STATE_NEED_FILE_DATA: #recall: this is the state just *completed*\n            self.file_filled = self.byte_offset\n            self.state = self.STATE_NEED_META\n            self.work_buf = self.cur_meta\n            self.byte_offset = 0\n            if meta_type == 0x80: #just completed a file-end record...we're done.\n                self.bytes_needed = 0\n                self.state = self.STATE_COMPLETE\n            elif meta_type in [0xa0, 0xb0]:\n                self.bytes_needed = 1\n            else:\n                if log_file:\n                    log_file.write(\"That's not a metadata type I've seen before...: 0x%02x\n\" % self.cur_meta[0])\n                return None\n\n        elif self.state == self.STATE_COMPLETE: #can't leave this state\n            pass\n\n        else:\n            if log_file:\n                log_file.write(\"Bad state-machine state: %d\n\" % self.state)\n\n        #recurse to consume as much as we can, for easier calling convention\n        if to_copy < data_len:\n            return  to_copy + add_bytes(bytes, start_index+to_copy, data_len-to_copy)\n\n        #else, return what we consumed\n        return to_copy\n\n\ndef read_me_fs_file(file_no, file_len, me_file, log_file = sys.stdout):\n    sm = MEFileSystemFileMetadataStateMachine(file_no, file_len)\n\n    while not sm.is_complete():\n        res = sm.add_bytes(\n            bytes=me_file.read(sm.get_bytes_needed()), \n            start_index=0,    \n            data_len=None, #shorthand for len(bytes)-start_index\n            log_file=log_file)\n        if not res:\n            log_file.write(\"Aborting file read.\n\")\n            break\n\n    return sm.get_file_data()\n\nclass MEFileSystemDataHeader:\n    \"\"\"\n    Data Page Header: (Top of a 0x4000-byte data page in the MFS)\n           0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f\n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n     00 | pgno|     pgflags     | 0x00| 0x00| 0x00| 0x00| mystery bits                                  | \n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n     10 | freed_flags...                                                                                |\n        +-----------------------------------------------------------------------------------------------+\n    ... | ...                                                                                           |\n        +-----------------------------------------------------------------------------------------------+\n     80 | ...                                                                                           |\n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n     90 | block indirection table...                                                                    |\n        +-----------------------------------------------------------------------------------------------+\n    ... | ...                                                                                           |\n        +-----------------------------------------------------------------------------------------------+\n     c0 | ...                                                                                           |\n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n     d0+| (file data follows)                                                                           |\n        +-----------------------------------------------------------------------------------------------+\n\n    pgno       -- page identifier within the MFS.  All MFS page headers \n                  have this field, be they AT or Data.\n    pgflags    -- have seen 0x78 0xfe 0xff for AT header. Data pages have\n                  had this or 0x78 0xfc 0xff.\n    (zeros)    -- a useless value for flash...must be part of the signature\n                  of the header?  Or reserved region for later version of\n                  the format.\n    myst_bits  -- TBD\n    freed_flags-- each bit marks whether a written 0x10-byte chunk is no \n                  longer required.  Bits exist for the header chunks, as\n                  well as the chunks for file data.  lsb of the first byte\n                  corresponds to the first chunk of the header. 0=freed.\n    blk_itab   -- translates ATFileEntry's okey value into a block offset \n                  within the data page.  offset = blk_itab[okey] * 0x100.\n                  This is the location from which to begin the search. Note\n                  that an offset of 0 must still respect that the page\n                  header consumes bytes [0x00, 0xd0) for the search.\n    (filedata) -- File are padded with 0xff at the end. Note files\n                  have internal metadata.  See routines above.\n    \"\"\"\n\n    def __init__(self, page_no, flags, bytes_00000000, myst_bits, freed_flags, blk_itab):\n        self.page_no = page_no\n        self.flags = flags\n        self.zeros_good = bytes_00000000 == b'\\x00\\x00\\x00\\x00'\n        self.myst_bits = myst_bits\n        self.freed_flags = freed_flags\n        self.blk_itab = blk_itab\n\n    def debug_print(self, log = sys.stdout):\n        log.write(\"Debug Print of MEFileSystemDataHeader %x:\n\" % id(self))\n        if self.page_no != 0xff:\n            log.write(\"  page no: 0x%x\n\" % self.page_no)\n            log.write(\"  flags: 0x%06x\n\" % self.flags)\n            log.write(\"  zeros good: %s\n\" % str(self.zeros_good))\n            log.write(\"  mystery bits: %s\n\" % \" \".join(\"%02x\"%x for x in self.myst_bits))\n            log.write(\"  freed_flags: %s\n\" % \"\".join(\"%02x\"%x for x in self.freed_flags))\n            log.write(\"  block ind. tab.: [%s]\n\" % \" \".join(\"%02x\"%x for x in self.blk_itab))\n        else:\n            log.write(\"  (empty)\n\")\n\n\nclass MEFileSystemATEntry:\n    \"\"\"\n    Allocation Table Entry:\n        0     1     2     3     4     5     6     7     8     9     a     \n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n     00 |state| flgs|    identifier   | type|  filelen  | pgid| okey| fno |\n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n\n    state      -- status of the entry: 0xdc=present; \n                  0xc8=overwritten(i.e., there will be another entry below)\n    flags      -- has value 0xf0 in every example...so hard to tell.\n    identifier -- 3-byte identifier...seem to be a preference for ASCII,\n                  but there are counterexamples\n    type       -- no idea...maybe permissions?  Observed values:\n                  0x00, 0x0a, 0x0c, 0x0d, 0x0e, 0x18, 0x1a\n    filelen    -- 16-bit, little endian.  actual content seems to be a few\n                  bytes more...might just be pollution of the structures\n                  used to write the file.\n    pgid       -- the pgno for the MEFileSystemDataHeader that holds the \n                  data.  The ATHeader is numbered 0, each data page seems\n                  to get sequentially numbered in my examples, though that \n                  could change with more use. 0xff indicates \"not\n                  yet used / nonumber assigned\" --- a fact that hints page\n                  numbers aren't guaranteed to be sequentially\n    okey       -- key for indexing the block_indirection table of the\n                  MEFileSystemDataHeader holding this file's content, to \n                  find the right 0x100 byte block from which to start the\n                  file search according to the 'fno' field.\n    fno        -- file number within the block-offset determined from okey. \n                  This is to be looked up using the metadata *within* the \n                  file data of the data pages.  See \n                  MEFileSystemFileMetadataStateMachine above\n    \"\"\"\n    def __init__(self, state, flags, identifier, type, filelen, pgid, okey, fno):\n        self.state = state\n        self.flags = flags\n        self.identifier = identifier\n        self.type = type\n        self.filelen = filelen\n        self.pgid = pgid\n        self.okey = okey\n        self.fno = fno\n\n    def debug_print(self, log = sys.stdout):\n        log.write(\"%15s len=0x%04x [pg=0x%02x k=0x%02x f=0x%02x] ty=0x%02x st=0x%02x, fg=0x%02x\" % (str(self.identifier), self.filelen, self.pgid, self.okey, self.fno, self.type, self.state, self.flags))\n\nclass MEFileSystemATHeader:\n    \"\"\"\n    Allocation Table Header:\n           0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f\n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n     00 | pgno|      flags      | 0x00| 0x00| 0x00| 0x00|\"MFS\\0\"                |bitfields?             | \n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n     10 | bitfields?            |\n        +-----+-----+-----+-----+\n\n    pgno       -- page identifier within the MFS.  All MFS page headers \n                  have this field, be they AT or Data.\n    flags      -- have seen 0x78 0xfe 0xff for AT header. Data pages have\n                  had this or 0x78 0xfc 0xff.\n    (zeros)    -- a useless value for flash...must be part of the signature\n                  of the header?  Or reserved region for later version of\n                  the format.\n    \"MFS\\0\"    -- ASCIIZ signature for the MFS AT Header\n    bitfields  -- 64 bits of apparent bitfields\n    \"\"\"\n\n    max_files = int((0x4000 - 0x14) / 11) #page size, less the header, divided by file entry size\n\n    def __init__(self, page_no, flags, bytes_00000000, sig, bitfields): \n        self.page_no = page_no\n        self.flags = flags\n        self.zeros_good = bytes_00000000 == b'\\x00\\x00\\x00\\x00'\n        self.sig_good = sig == b'MFS\\x00'\n        self.bitfields = bitfields\n\n    def debug_print(self, log = sys.stdout):\n        log.write(\"Debug Print of MEFileSystemATHeader %x:\n\" % id(self))\n        log.write(\"  page no: 0x%x\n\" % self.page_no)\n        log.write(\"  flags: 0x%06x\n\" % self.flags)\n        log.write(\"  zeros good: %s\n\" % str(self.zeros_good))\n        log.write(\"  sig good: %s\n\" % str(self.sig_good))\n        log.write(\"  bitfields: %s\n\" % \" \".join(\"%02x\"%x for x in self.bitfields))\n\nclass MEFileSystemAT:\n    \"\"\"\n    Allocation Table (a 0x4000-byte page in the MFS):\n           0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f\n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n     00 | Allocation Table Header...                                                                    |             \n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n     10 |...                    | File Entry                                                      |FE...|\n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n     ...|...                                                                                            |             \n        +-----------------------------------------------------------------------------------+-----+-----+\n    3fe0|...                                                                                |File Ent...|            \n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n    3ff0|...                                                  |Padding                                  |             \n        +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n    \"\"\"\n\n    def __init__(self, header, entry_list):\n        self.header = header\n        self.entry_list = entry_list\n\n    def debug_print(self, log = sys.stdout):\n        log.write(\"Debug Print of MEFileSystemAT %x:\n\" % id(self))\n        self.header.debug_print(log)\n\n        log.write(\"File entries:\n\")\n        for ent in self.entry_list:\n            if(ent):\n                log.write(\"  \")\n                ent.debug_print(log)\n                log.write(\"\n\")\n\nclass MEFileSystem:\n    \"\"\"\n    MFS Partition: (Making the assumption the AT is the first page)\n         +------------------------------------+\n    0000 | Allocation Table                   |\n         +------------------------------------+\n    4000 | Data Page                          |\n         +------------------------------------+\n    8000 | Data Page                          |\n         +------------------------------------+\n    c000 | Data Page                          |\n         +------------------------------------+\n    ...  |...                                 |\n         +------------------------------------+\n    \"\"\"\n\n    def __init__(self, allocation_table, data_page_list):\n        self.allocation_table = allocation_table\n        self.data_page_list = data_page_list\n\n    def debug_print(self, log = sys.stdout):\n        log.write(\"Debug Print of MEFileSystem %x:\n\" % id(self))\n        self.allocation_table.debug_print(log)\n\n        for page in self.data_page_list:\n            if(page):\n                page.debug_print(log)\n            else:\n                log.write(\"(Not parsed)\n\")\n\ndef parse_me_fs_at_entry(me_file, log_file = sys.stdout):\n    return MEFileSystemATEntry(\n        state = read_leuint8(me_file),\n        flags = read_leuint8(me_file),\n        identifier = me_file.read(3),\n        type = read_leuint8(me_file),\n        filelen = read_leuint16(me_file),\n        pgid = read_leuint8(me_file),\n        okey = read_leuint8(me_file),\n        fno = read_leuint8(me_file))\n\ndef parse_me_fs_at_header(me_file, log_file = sys.stdout):\n    return MEFileSystemATHeader(\n        page_no = read_leuint8(me_file),\n        flags = read_leuint24(me_file),\n        bytes_00000000 = me_file.read(4),\n        sig = me_file.read(4),\n        bitfields = me_file.read(8))\n\ndef parse_me_fs_at(me_file, log_file = sys.stdout):\n    hdr = parse_me_fs_at_header(me_file, log_file)\n\n    entry_list = [None] * MEFileSystemATHeader.max_files\n    for i in range(MEFileSystemATHeader.max_files):\n        ent = parse_me_fs_at_entry(me_file, log_file)\n        if ent.state == 0xff:\n            break\n        entry_list[i] = ent\n\n    return MEFileSystemAT(hdr, entry_list)\n\n\ndef parse_me_fs_data_header(me_file, log_file = sys.stdout):\n    return MEFileSystemDataHeader(\n        page_no = read_leuint8(me_file),\n        flags = read_leuint24(me_file),\n        bytes_00000000 = me_file.read(4),\n        myst_bits = me_file.read(0x8),\n        freed_flags = me_file.read(0x80),\n        blk_itab = me_file.read(0x40))\n\ndef parse_me_fs(length, me_file, log_file = sys.stdout):\n    \"\"\"\n    ARGS:\n       length -- length in bytes of the ME partition holding the MFS/MFSB data\n       me_file -- a file handle whose present position is the start of the MFS(B) partition\n       log_file -- if there is diagnostic output, put it here\n\n    RETURNS:\n       an MEFileSystem instance populated with the allocation table and data-page headers\n    \"\"\"\n\n    total_pages = int(length/0x4000)\n    start_offset = me_file.tell()\n\n    #NOTE: I'm presuming the allocation table is the first page...\n    #that might not be reliable...\n    at = parse_me_fs_at(me_file, log_file)\n\n    data_pages = [None] * (total_pages-1)\n    for page in range(0, total_pages-1):\n        me_file.seek(start_offset + 0x4000 * (page+1))\n        data_pages[page] = parse_me_fs_data_header(me_file, log_file)\n\n    return MEFileSystem(\n        allocation_table=at, \n        data_page_list = data_pages)\n\n\ndef get_mfs_file(mefs, me_file, mfs_file_offset, id, log_file = sys.stdout):\n    \"\"\"\n    Example of how to use the MEFileSystem structures to retrieve\n    MFS and MFSB files.\n\n    ARGS:\n        mefs -- a MEFileSystem instance parsed from mfs_data\n        me_file -- a filehandle containing the ME image\n        mfs_file_offset -- the file offset within me_file where the MFS partition begins\n        id -- a 3-byte byte array with the file identifier\n        log -- if there is diagnostic output, put it here\n\n    RETURNS:\n        an array containing [state, The data from the corresponding file].\n        else None if the file identifier does not exist within the data.\n\n    Example driver, given the known offset and size for a MFS partition:\n        MFS_OFFSET = 0x64000 #typical location\n        MFS_LENGTH = 0x40000 #typical size\n        spi_image_file.seek(MFS_OFFSET)\n        mefs = parse_me_fs(MFS_LENGTH, spi_image_file)\n        result_tuple = get_mfs_file(mefs, spi_image_file, MFS_OFFSET, b'UKS')\n        if result_tuple:\n            print(\"State: %x, data: %s\n\" % tuple(result_tuple))\n    \"\"\"\n\n    #Find the file identifer in the Allocation Table\n    best_ent = None\n    for ent in mefs.allocation_table.entry_list:\n        if ent and ent.identifier == id:\n            best_ent = ent\n\n            if ent.state == 0xdc:\n                break; # got a current entry\n\n            log.write(\"Error: found an item w/ state %02x...continuing\n\" % ent.state)\n\n    #if found, lookup which data page matches the entry's pgid value\n    if best_ent:\n        page_found = False\n\n        for list_idx in range(len(mefs.data_page_list)):\n            page = mefs.data_page_list[list_idx]\n\n            if page.page_no == best_ent.pgid:\n                page_found = True\n\n                #we found the right data page, so start the file search\n\n                search_start = page.blk_itab[best_ent.okey] * 0x100\n\n                #In the following lines:\n                #  The value d0 is to skip over the datapage header if we're in the first block\n                #\n                #  The multiple of 0x4000 selects the data offset that goes with list_idx\n                #  since the parsed data-page list is in the same order as found in the file.\n                #\n                #  Because mefs.data_page_list doesn't include the allocation table page, we +1 \n                #  to the index before multiplying.  The result is a set of offsets into the MFS data\n                #  bounding the file search\n                ##\n                search_off = 0x4000 * (list_idx+1) + (0xd0 if search_start == 0 else search_start)\n\n                me_file.seek(mfs_file_offset + search_off)\n                data = read_me_fs_file(best_ent.fno, best_ent.filelen, me_file, log_file)\n                if data:\n                    return [best_ent.state, data]\n\n    return None\n\n\nif __name__ == \"__main__\":\n    with open(\"image.bin\", \"rb\") as spi_image_file:\n        MFS_OFFSET = 0x64000 #typical location\n        MFS_LENGTH = 0x40000 #typical size\n        spi_image_file.seek(MFS_OFFSET)\n        mefs = parse_me_fs(MFS_LENGTH, spi_image_file)\n\n        #Dump the allocation table\n        mefs.allocation_table.debug_print()\n        print(\"\")\n\n        first_file = mefs.allocation_table.entry_list[0].identifier\n        print(\"looking up the first file (%s):\" % first_file)\n        result_tuple = get_mfs_file(mefs, spi_image_file, MFS_OFFSET, first_file)\n        if result_tuple:\n            print(\"State: %x, data: %s\n\" % tuple(result_tuple))\n</code></pre>\n <p>\n  Oh, you can dump the file list with:\n  <code>\n   mefs.allocation_table.debug_print()\n  </code>\n </p>\n <p>\n  E.g.,\n </p>\n <pre><code>           b'UKS' len=0x0004 [pg=0x01 k=0x00 f=0x00] ty=0x0a st=0xdc, fg=0xf0\n           b'LRT' len=0x01c0 [pg=0x01 k=0x00 f=0x01] ty=0x0e st=0xdc, fg=0xf0\n           b'MIA' len=0x0003 [pg=0x01 k=0x02 f=0x01] ty=0x0e st=0xdc, fg=0xf0\n           b'BLV' len=0x0004 [pg=0x01 k=0x02 f=0x02] ty=0x0a st=0xdc, fg=0xf0\n           b'SDV' len=0x00ff [pg=0x01 k=0x02 f=0x03] ty=0x0a st=0xdc, fg=0xf0\n           b'ICP' len=0x0042 [pg=0x01 k=0x03 f=0x01] ty=0x0e st=0xdc, fg=0xf0\n        b'\\x00NP' len=0x0001 [pg=0x01 k=0x04 f=0x01] ty=0x0e st=0xdc, fg=0xf0\n           b'PPN' len=0x0042 [pg=0x01 k=0x04 f=0x02] ty=0x0e st=0xdc, fg=0xf0\n           b'SCO' len=0x00af [pg=0x01 k=0x04 f=0x03] ty=0x0a st=0xdc, fg=0xf0\n           b'PCO' len=0x0a24 [pg=0x01 k=0x05 f=0x01] ty=0x0a st=0xdc, fg=0xf0\n           b'GFC' len=0x0004 [pg=0x01 k=0x07 f=0x01] ty=0x18 st=0xdc, fg=0xf0\n           b'YHP' len=0x06fe [pg=0x01 k=0x07 f=0x02] ty=0x0a st=0xdc, fg=0xf0\n           b'FCP' len=0x0002 [pg=0x01 k=0x09 f=0x01] ty=0x0b st=0xdc, fg=0xf0\n           b'PPR' len=0x0001 [pg=0x01 k=0x09 f=0x02] ty=0x0b st=0xdc, fg=0xf0\n           b'TCM' len=0x0005 [pg=0x01 k=0x09 f=0x03] ty=0x10 st=0xdc, fg=0xf0\n           b'BHM' len=0x0004 [pg=0x01 k=0x09 f=0x04] ty=0x10 st=0xdc, fg=0xf0\n           b'GCN' len=0x0018 [pg=0x01 k=0x09 f=0x05] ty=0x0e st=0xdc, fg=0xf0\n           b'CSM' len=0x000f [pg=0x01 k=0x0a f=0x00] ty=0x0e st=0xdc, fg=0xf0\n        b'\\x00HS' len=0x0127 [pg=0x01 k=0x0a f=0x01] ty=0x0e st=0xdc, fg=0xf0\n        b'\\x01HS' len=0x0127 [pg=0x01 k=0x0b f=0x01] ty=0x0e st=0xdc, fg=0xf0\n        b'\\x02HS' len=0x0127 [pg=0x01 k=0x0c f=0x01] ty=0x0e st=0xdc, fg=0xf0\n        b'\\x03HS' len=0x0127 [pg=0x01 k=0x0d f=0x01] ty=0x0e st=0xdc, fg=0xf0\n           b'PCF' len=0x0010 [pg=0x01 k=0x0e f=0x01] ty=0x0e st=0xdc, fg=0xf0\n...\n\n</code></pre>\n</div>\n</body></html>",
            "votes": "3",
            "user": "lockcmpxchg8b",
            "time": "Apr 7, 2020 at 20:52",
            "is_accepted": true,
            "comments": [
                {
                    "user": "user31201",
                    "text": "<span class=\"comment-copy\">Amazing work. More than I could hope for. Do you by any chance have an URL for the SPI image you used in testing this?</span>",
                    "time": null
                },
                {
                    "user": "lockcmpxchg8b",
                    "text": "<span class=\"comment-copy\">They were unfortunately proprietary, but derived from a relatively recent AMI BIOS for a Broadwell Xeon board.  Dediprog flash programmers support an interesting <a href=\"https://www.dediprog.com/product/ISP-TC-16\" rel=\"nofollow noreferrer\">\"clip\" accessory</a> that can attach onto the outside of certain SPI chips, with lots of caveats, while they're still on the board.  Else, perhaps you can find a board with a socketed SPI chip to read?</span>",
                    "time": null
                },
                {
                    "user": "user31201",
                    "text": "<span class=\"comment-copy\">No problem, it was just to have something known working to compare with, as I begin adapting the script for my special case, but with \"zeros good: True\" and \"sig good: True\" it must ok. One more question. Have you been able to make sense of data in the file list and figure out what kind of file an entry represent? e.g. text file, certificate etc. or have you only seen random data?</span>",
                    "time": null
                },
                {
                    "user": "lockcmpxchg8b",
                    "text": "<span class=\"comment-copy\">Only one I've really looked at is the one named b'\\x00\\x02\\x00'.  It seems to capture a date-stamp (in seconds from some epoch) approximately weekly.  Has some special case values I haven't looked much into.  I presume it's for defense against clock rollback for DRM and things like that, which might imply it gets monthly and yearly writes of a different kind...I don't think I have that kind of patience. :)</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have not encountered FCRS but EFFS is the legacy Flash Filesystem partition, used to store configuration and runtime ME data. The only known tool that can parse it (besides ME firmware itself) is Intel’s Flash Image Tool (FIT) for the corresponding firmware version.\n </p>\n <p>\n  However, the format is likely very similar to that of the newer MFS in ME 11 and later, so possibly the research on MFS would help:\n </p>\n <ul>\n  <li>\n   <a href=\"https://www.blackhat.com/docs/eu-17/materials/eu-17-Sklyarov-Intel-ME-Flash-File-System-Explained-wp.pdf\" rel=\"nofollow noreferrer\">\n    ME Flash File System Explained\n   </a>\n  </li>\n  <li>\n   <a href=\"https://github.com/ptresearch/parseMFS\" rel=\"nofollow noreferrer\">\n    ME EFS parser\n   </a>\n  </li>\n </ul>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Igor Skochinsky",
            "time": "Feb 23, 2020 at 12:37",
            "is_accepted": false,
            "comments": [
                {
                    "user": "user31201",
                    "text": "<span class=\"comment-copy\">Reason for asking is that I'm wondering why loading ME firmware into FIT and just building the SPI image without making ANY changes to the configuration, results in thousands of modified bytes in EFFS partition of output ME firmware, compared binary to the input ME firmware. So I'm trying to find out what FIT is doing to the EFFS partition.</span>",
                    "time": null
                }
            ]
        }
    ]
}