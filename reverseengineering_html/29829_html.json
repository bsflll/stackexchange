{
    "title": "Does Microsoft's C++ compiler add functions?",
    "link": "https://reverseengineering.stackexchange.com/questions/29829/does-microsofts-c-compiler-add-functions",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm working on reverse engineering a classic game (early 2000s) and am fortunate enough to have debug symbols for a different platform other than PC for reference.\n </p>\n <p>\n  I've noticed that the same functions on the PC version (compiled using visual studio) often have several other functions inside the actual function, breaking functionality into smaller chunks. But on the other platform (compiled using GCC), it's just one large function, are these compiler generated? Or maybe GCC optimized them out?\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 2,
    "views": "449",
    "tags": [
        "ghidra",
        "game-hacking"
    ],
    "user": "user18776",
    "time": "Jan 7, 2022 at 22:59",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  That really depends. There are two primary explanations to this phenomenon, which point to opposite answers.\n </p>\n <p>\n  First, a compiler optimization known as \"inlining\" inserts the body of the called function into the calling function, thereby eliminating the\n  <code>\n   call\n  </code>\n  instruction, but making the calling function bigger.\n </p>\n <p>\n  Secondly, games are usually written in C++. Different compilers have different implementations for the C++ standard library (and standard template library). That is to say, both binaries will have completely different implementations for C++ library functions, such as\n  <code>\n   std::vector<GameObject>::push_back\n  </code>\n  . They can differ in every aspect, such as how many functions they call internally, the control flow structure of the function, and so on.\n </p>\n <p>\n  Either one of, or both of, those phenomena could be the cause of what you're seeing.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Rolf Rolles",
            "time": "Jan 8, 2022 at 1:31",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The generated machine code is going to vary by compiler, and even within the same compiler depending on compiler optimization settings. Sometimes optimizations will \"inline\" functions, removing what was a function call in the code. Sometimes external libraries will be compiled \"statically\" i.e. their functions get incorporated directly into the module vs being call externally (i.e. via a DLL in Windows)\nI find a very good way to explore some of this behavior is with online tool\n  <a href=\"https://godbolt.org/\" rel=\"nofollow noreferrer\">\n   https://godbolt.org/\n  </a>\n </p>\n <p>\n  For most accurate results related to your game you would need to work out which specific compiler was used i.e. Microsoft Visual C++ 6.0 and you can specify compiler options to output assembly to see what kind of code it can generate.\n </p>\n <p>\n  Taking a very simplistic example:\n </p>\n <p>\n  The following code:\n </p>\n <pre><code>#include <iostream>\n\nint main()\n{\n    printf(\"Hello, World!\");\n    return 0;\n}\n</code></pre>\n <p>\n  We can see the output with x86 msvc v19 latest:\n </p>\n <pre><code>$SG34000 DB     'Hello, World!', 00H\nstd::_Fake_allocator const std::_Fake_alloc ORG $+1         ; std::_Fake_alloc\nunsigned __int64 `__local_stdio_printf_options'::`2'::_OptionsStorage DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage\n\n_main   PROC\n        push    ebp\n        mov     ebp, esp\n        push    OFFSET $SG34000\n        call    _printf\n        add     esp, 4\n        xor     eax, eax\n        pop     ebp\n        ret     0\n_main   ENDP\n</code></pre>\n <p>\n  But with optimize for speed:\n </p>\n <pre><code>unsigned __int64 `__local_stdio_printf_options'::`2'::_OptionsStorage DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage\n`string' DB 'Hello, World!', 00H ; `string'\n\n_main   PROC                                      ; COMDAT\n        push    OFFSET `string'\n        call    _printf\n        add     esp, 4\n        xor     eax, eax\n        ret     0\n_main   ENDP\n</code></pre>\n <p>\n  But if optimized for size:\n </p>\n <pre><code>    unsigned __int64 `__local_stdio_printf_options'::`2'::_OptionsStorage DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage\n`string' DB 'Hello, World!', 00H ; `string'\n\n_main   PROC                                      ; COMDAT\n        push    OFFSET `string'\n        call    _printf\n        pop     ecx\n        xor     eax, eax\n        ret     0\n_main   ENDP\n</code></pre>\n <p>\n  Then look at GCC default output:\n </p>\n <pre><code>    .LC0:\n        .string \"Hello, World!\"\nmain:\n        push    rbp\n        mov     rbp, rsp\n        mov     edi, OFFSET FLAT:.LC0\n        mov     eax, 0\n        call    printf\n        mov     eax, 0\n        pop     rbp\n        ret\n__static_initialization_and_destruction_0(int, int):\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 16\n        mov     DWORD PTR [rbp-4], edi\n        mov     DWORD PTR [rbp-8], esi\n        cmp     DWORD PTR [rbp-4], 1\n        jne     .L5\n        cmp     DWORD PTR [rbp-8], 65535\n        jne     .L5\n        mov     edi, OFFSET FLAT:_ZStL8__ioinit\n        call    std::ios_base::Init::Init() [complete object constructor]\n        mov     edx, OFFSET FLAT:__dso_handle\n        mov     esi, OFFSET FLAT:_ZStL8__ioinit\n        mov     edi, OFFSET FLAT:_ZNSt8ios_base4InitD1Ev\n        call    __cxa_atexit\n.L5:\n        nop\n        leave\n        ret\n_GLOBAL__sub_I_main:\n        push    rbp\n        mov     rbp, rsp\n        mov     esi, 65535\n        mov     edi, 1\n        call    __static_initialization_and_destruction_0(int, int)\n        pop     rbp\n        ret\n</code></pre>\n <p>\n  With optimization -O3 gcc produces:\n </p>\n <pre><code>  .LC0:\n            .string \"Hello, World!\"\n    main:\n            sub     rsp, 8\n            mov     edi, OFFSET FLAT:.LC0\n            xor     eax, eax\n            call    printf\n            xor     eax, eax\n            add     rsp, 8\n            ret\n    _GLOBAL__sub_I_main:\n            sub     rsp, 8\n            mov     edi, OFFSET FLAT:_ZStL8__ioinit\n            call    std::ios_base::Init::Init() [complete object constructor]\n            mov     edx, OFFSET FLAT:__dso_handle\n            mov     esi, OFFSET FLAT:_ZStL8__ioinit\n            mov     edi, OFFSET FLAT:_ZNSt8ios_base4InitD1Ev\n            add     rsp, 8\n            jmp     __cxa_atexit\n</code></pre>\n <p>\n  Meanwhile clang produces:\n </p>\n <pre><code>    __cxx_global_var_init:                  # @__cxx_global_var_init\n        push    rbp\n        mov     rbp, rsp\n        movabs  rdi, offset std::__ioinit\n        call    std::ios_base::Init::Init() [complete object constructor]\n        movabs  rdi, offset std::ios_base::Init::~Init() [complete object destructor]\n        movabs  rsi, offset std::__ioinit\n        movabs  rdx, offset __dso_handle\n        call    __cxa_atexit\n        pop     rbp\n        ret\nmain:                                   # @main\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 16\n        mov     dword ptr [rbp - 4], 0\n        movabs  rdi, offset .L.str\n        mov     al, 0\n        call    printf\n        xor     eax, eax\n        add     rsp, 16\n        pop     rbp\n        ret\n_GLOBAL__sub_I_example.cpp:             # @_GLOBAL__sub_I_example.cpp\n        push    rbp\n        mov     rbp, rsp\n        call    __cxx_global_var_init\n        pop     rbp\n        ret\n.L.str:\n        .asciz  \"Hello, World!\"\n</code></pre>\n <p>\n  Clang with optimizations:\n </p>\n <pre><code>main:                                   # @main\n        push    rax\n        mov     edi, offset .L.str\n        xor     eax, eax\n        call    printf\n        xor     eax, eax\n        pop     rcx\n        ret\n_GLOBAL__sub_I_example.cpp:             # @_GLOBAL__sub_I_example.cpp\n        push    rax\n        mov     edi, offset std::__ioinit\n        call    std::ios_base::Init::Init() [complete object constructor]\n        mov     edi, offset std::ios_base::Init::~Init() [complete object destructor]\n        mov     esi, offset std::__ioinit\n        mov     edx, offset __dso_handle\n        pop     rax\n        jmp     __cxa_atexit                    # TAILCALL\n.L.str:\n        .asciz  \"Hello, World!\"\n</code></pre>\n <p>\n  If we have a simple function called:\n </p>\n <pre><code>    #include <iostream>\n\nint addone(int n)\n{\n    return n+1;\n}\n\nint main()\n{\n    printf(\"%i\",addone(1));\n    return 0;\n}\n</code></pre>\n <p>\n  Without optimization msvc produces:\n </p>\n <pre><code>$SG34003 DB     '%i', 00H\nstd::_Fake_allocator const std::_Fake_alloc ORG $+1         ; std::_Fake_alloc\nunsigned __int64 `__local_stdio_printf_options'::`2'::_OptionsStorage DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage\n\n_n$ = 8                                       ; size = 4\nint addone(int) PROC                                    ; addone\n        push    ebp\n        mov     ebp, esp\n        mov     eax, DWORD PTR _n$[ebp]\n        add     eax, 1\n        pop     ebp\n        ret     0\nint addone(int) ENDP                                    ; addone\n\n_main   PROC\n        push    ebp\n        mov     ebp, esp\n        push    1\n        call    int addone(int)               ; addone\n        add     esp, 4\n        push    eax\n        push    OFFSET $SG34003\n        call    _printf\n        add     esp, 8\n        xor     eax, eax\n        pop     ebp\n        ret     0\n_main   ENDP\n</code></pre>\n <p>\n  but with optimizations the function \"addone\" is no longer called, and just the direct value \"2\" is used:\n </p>\n <pre><code>unsigned __int64 `__local_stdio_printf_options'::`2'::_OptionsStorage DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage\n`string' DB '%i', 00H                    ; `string'\n\n_n$ = 8                                       ; size = 4\nint addone(int) PROC                                    ; addone, COMDAT\n        mov     eax, DWORD PTR _n$[esp-4]\n        inc     eax\n        ret     0\nint addone(int) ENDP                                    ; addone\n\n_main   PROC                                      ; COMDAT\n        push    2\n        push    OFFSET `string'\n        call    _printf\n        add     esp, 8\n        xor     eax, eax\n        ret     0\n_main   ENDP\n</code></pre>\n</div>\n</body></html>",
            "votes": "2",
            "user": "chentiangemalc",
            "time": "Jan 11, 2022 at 22:47",
            "is_accepted": false,
            "comments": [
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">Keep in mind, however, that between now and that game there are ~20 years of  compiler evolution. Still a valid and valuable explanation.</span>",
                    "time": null
                }
            ]
        }
    ]
}