{
    "title": "PinTools Multi-threaded example (inscount_Tls.cpp): only one thread outputs",
    "link": "https://reverseengineering.stackexchange.com/questions/31492/pintools-multi-threaded-example-inscount-tls-cpp-only-one-thread-outputs",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am studying\n  <a href=\"https://software.intel.com/sites/landingpage/pintool/docs/98690/Pin/doc/html/index.html#InscountTLS\" rel=\"nofollow noreferrer\">\n   PinTools multithread example inscount_tls.cpp\n  </a>\n  . When I change the number of thread to 3, only 1 thread outputs the result. Is anyone familiar with\n  <code>\n   Intel Pintools instruments\n  </code>\n  that can give some advice?\nIf I run the example\n  <code>\n   inscount_tls.cpp\n  </code>\n  as in the manual (i.e.,\n  <code>\n   numThreads\n  </code>\n  set to 0), the output:\n </p>\n <pre><code>Count[0] = 1141027\nTotal number of threads = 1\n</code></pre>\n <p>\n  But if I change the\n  <code>\n   numThreads\n  </code>\n  to 3, there is only one thread outputs (instead of 4) its result:\n </p>\n <pre><code>Count[0] = 1141027\nTotal number of threads = 4\n</code></pre>\n <p>\n  My Linux machine has 8 cores, and the below is how I build and run Pin:\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/9yvwx.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/9yvwx.png\"/>\n  </a>\n </p>\n <p>\n  In the source file, I only change the number thread to 3, and the output log file to \"inscount_tls.out\"\n </p>\n <pre><code>/*\n * Copyright (C) 2004-2021 Intel Corporation.\n * SPDX-License-Identifier: MIT\n */\n \n#include <iostream>\n#include <fstream>\n#include \"pin.H\"\nusing std::cerr;\nusing std::cout;\nusing std::endl;\nusing std::ostream;\nusing std::string;\n \nKNOB< string > KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"inscount_tls.out\", \"specify output file name\");\n \nINT32 numThreads = 3;\nostream* OutFile = NULL;\n \n// Force each thread's data to be in its own data cache line so that\n// multiple threads do not contend for the same data cache line.\n// This avoids the false sharing problem.\n#define PADSIZE 56 // 64 byte line size: 64-8\n \n// a running count of the instructions\nclass thread_data_t\n{\n  public:\n    thread_data_t() : _count(0) {}\n    UINT64 _count;\n    UINT8 _pad[PADSIZE];\n};\n \n// key for accessing TLS storage in the threads. initialized once in main()\nstatic TLS_KEY tls_key = INVALID_TLS_KEY;\n \n// This function is called before every block\nVOID PIN_FAST_ANALYSIS_CALL docount(UINT32 c, THREADID threadid)\n{\n    thread_data_t* tdata = static_cast< thread_data_t* >(PIN_GetThreadData(tls_key, threadid));\n    tdata->_count += c;\n}\n \nVOID ThreadStart(THREADID threadid, CONTEXT* ctxt, INT32 flags, VOID* v)\n{\n    numThreads++;\n    thread_data_t* tdata = new thread_data_t;\n    if (PIN_SetThreadData(tls_key, tdata, threadid) == FALSE)\n    {\n        cerr << \"PIN_SetThreadData failed\" << endl;\n        PIN_ExitProcess(1);\n    }\n}\n \n// Pin calls this function every time a new basic block is encountered.\n// It inserts a call to docount.\nVOID Trace(TRACE trace, VOID* v)\n{\n    // Visit every basic block  in the trace\n    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))\n    {\n        // Insert a call to docount for every bbl, passing the number of instructions.\n \n        BBL_InsertCall(bbl, IPOINT_ANYWHERE, (AFUNPTR)docount, IARG_FAST_ANALYSIS_CALL, IARG_UINT32, BBL_NumIns(bbl),\n                       IARG_THREAD_ID, IARG_END);\n    }\n}\n \n// This function is called when the thread exits\nVOID ThreadFini(THREADID threadIndex, const CONTEXT* ctxt, INT32 code, VOID* v)\n{\n    thread_data_t* tdata = static_cast< thread_data_t* >(PIN_GetThreadData(tls_key, threadIndex));\n    *OutFile << \"Count[\" << decstr(threadIndex) << \"] = \" << tdata->_count << endl;\n    delete tdata;\n}\n \n// This function is called when the application exits\nVOID Fini(INT32 code, VOID* v) { *OutFile << \"Total number of threads = \" << numThreads << endl; }\n \n/* ===================================================================== */\n/* Print Help Message                                                    */\n/* ===================================================================== */\n \nINT32 Usage()\n{\n    cerr << \"This tool counts the number of dynamic instructions executed\" << endl;\n    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;\n    return 1;\n}\n \n/* ===================================================================== */\n/* Main                                                                  */\n/* ===================================================================== */\n \nint main(int argc, char* argv[])\n{\n    // Initialize pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc, argv)) return Usage();\n \n    OutFile = KnobOutputFile.Value().empty() ? &cout : new std::ofstream(KnobOutputFile.Value().c_str());\n \n    // Obtain  a key for TLS storage.\n    tls_key = PIN_CreateThreadDataKey(NULL);\n    if (tls_key == INVALID_TLS_KEY)\n    {\n        cerr << \"number of already allocated keys reached the MAX_CLIENT_TLS_KEYS limit\" << endl;\n        PIN_ExitProcess(1);\n    }\n \n    // Register ThreadStart to be called when a thread starts.\n    PIN_AddThreadStartFunction(ThreadStart, NULL);\n \n    // Register Fini to be called when thread exits.\n    PIN_AddThreadFiniFunction(ThreadFini, NULL);\n \n    // Register Fini to be called when the application exits.\n    PIN_AddFiniFunction(Fini, NULL);\n \n    // Register Instruction to be called to instrument instructions.\n    TRACE_AddInstrumentFunction(Trace, NULL);\n \n    // Start the program, never returns\n    PIN_StartProgram();\n \n    return 1;\n}\n</code></pre>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 0,
    "views": "234",
    "tags": [
        "instrumentation",
        "pintool",
        "multi-process"
    ],
    "user": "Tony Nguyen",
    "time": "Jan 31, 2023 at 16:24",
    "comments": [
        {
            "user": "josh poley",
            "text": "<html><body><span class=\"comment-copy\">\n Based on the code pasted,\n <code>\n  numThreads\n </code>\n is not a configuration, but just for display.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Tony Nguyen",
            "text": "<html><body><span class=\"comment-copy\">\n @joshpoley I see.\n <code>\n  numThreads\n </code>\n is just to display (increased by one) each time\n <code>\n  ThreadStart()\n </code>\n is called. How do I configure to have more than one thread with\n <code>\n  Intel Pin\n </code>\n ? I don't see any references in\n <a href=\"https://software.intel.com/sites/landingpage/pintool/docs/98690/Pin/doc/html/index.html#MT\" rel=\"nofollow noreferrer\">\n  Intel Pintool manual\n </a>\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "josh poley",
            "text": "<html><body><span class=\"comment-copy\">\n You only see one thread because\n <code>\n  ls\n </code>\n uses a single thread. How would\n <code>\n  ls\n </code>\n know what to do with another thread?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Tony Nguyen",
            "text": "<html><body><span class=\"comment-copy\">\n @joshpoley I see what I misunderstood. I executed the\n <code>\n  ls\n </code>\n command instead of an multithreaded executable file. I now have it working correctly.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}