{
    "title": "Problems with extracting firmware",
    "link": "https://reverseengineering.stackexchange.com/questions/20070/problems-with-extracting-firmware",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am currently trying to reverse-engineer the firmware of an E-Cigarette but I cannot find any clues with the common tools. Heres everything I found so far.\n </p>\n <ul>\n  <li>\n   <p>\n    Binwalk doesnt recognize anything even with\n    <code>\n     -E\n    </code>\n    or\n    <code>\n     -A\n    </code>\n    .\n   </p>\n  </li>\n  <li>\n   <p>\n    Entropy = 7.611435 bits per byte.\n   </p>\n  </li>\n  <li>\n   <p>\n    Optimum compression would reduce the size of this 80896 byte file by 4 percent.\n   </p>\n  </li>\n  <li>\n   <p>\n    Chi square distribution for 80896 samples is 99630.01, and randomly\nwould exceed this value less than 0.01 percent of the times.\n   </p>\n  </li>\n  <li>\n   <p>\n    Arithmetic mean value of data bytes is 117.2996 (127.5 = random).\n   </p>\n  </li>\n  <li>\n   <p>\n    Monte Carlo value for Pi is 3.078178312 (error 2.02 percent).\n   </p>\n  </li>\n  <li>\n   <p>\n    Serial correlation coefficient is 0.107920 (totally uncorrelated = 0.0).\n   </p>\n  </li>\n </ul>\n <p>\n  Is it possible that this file is encrypted or compressed?\n </p>\n <p>\n  Here is a visualization of the entropy:\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/rzF9c.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"Entropy\" src=\"https://i.sstatic.net/rzF9c.png\"/>\n  </a>\n </p>\n <p>\n  And here is the graph of the entropy:\n  <a href=\"https://i.sstatic.net/fMYNn.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"Entropy_graph\" src=\"https://i.sstatic.net/fMYNn.png\"/>\n  </a>\n </p>\n <p>\n  Here is a download of the Firmware.\n  <a href=\"https://www.file-upload.net/download-13422170/HW718V40_20171008.firmware.html\" rel=\"nofollow noreferrer\">\n   https://www.file-upload.net/download-13422170/HW718V40_20171008.firmware.html\n  </a>\n </p>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 1,
    "views": "730",
    "tags": [
        "firmware",
        "firmware-analysis"
    ],
    "user": "Cubzer",
    "time": "Dec 7, 2018 at 11:44",
    "comments": [
        {
            "user": "julian",
            "text": "<html><body><span class=\"comment-copy\">\n Can you share a link to the file? If not, can you post the entropy plot generated by\n <code>\n  binwalk -E <your file>\n </code>\n ? The distribution of higher-entropy data is not as uniform as what I would expect from compressed or encrypted data. Furthermore, there are sizable low entropy regions. What are the results of running\n <code>\n  strings -n 9 <your file>\n </code>\n ? Have you looked at a hex dump of the first few hundred bytes?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Cubzer",
            "text": "<html><body><span class=\"comment-copy\">\n Hi I added the download to my question. I looked at the hexdump of the file and tried to disassemble it with radare2 and different flavours but nothing helpful came out of it. Im not at home so i unfortunatly cant provide you with a entropy Plot. The ASCII strings in the hexdump are also nothing that makes sense to me but maybe you find something. Thanks for the help.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "eggyal",
            "text": "<html><body><span class=\"comment-copy\">\n Wouldn’t it be wise to first identify the processor, and from that (hopefully) the instruction set?\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <h1>\n  TL;DR\n </h1>\n <p>\n  Yes the file is encrypted, it is a simple XOR cipher with a key length of 0x800 bytes.\n </p>\n <p>\n  Python script for getting decrypted firmware:\n </p>\n <pre><code>import struct\n\nFILENAME = \"HW718V40_20171008.firmware\"\n\ndef xor_cipher(data, key):\n    import sys\n    from itertools import cycle\n    if (sys.version_info > (3, 0)):\n        return bytes(a ^ b for a, b in zip(data, cycle(key)))\n    else:\n        return bytes(bytearray(a ^ b for a, b in zip(bytearray(data), cycle(bytearray(key)))))\n\nkey = struct.pack('<I', 0x00001AE7) * 8 + struct.pack('<I', 0x000026EF) \\\n* 8 + struct.pack('<I', 0x0000565C) * 8 + struct.pack('<I',\n    0x00001109) * 8 + struct.pack('<I', 0x00005618) * 8 \\\n+ struct.pack('<I', 0x000077D6) * 8 + struct.pack('<I', 0x00000F45) \\\n* 8 + struct.pack('<I', 0x000024AE) * 8 + struct.pack('<I',\n    0x00001C42) * 8 + struct.pack('<I', 0x00006D4C) * 8 \\\n+ struct.pack('<I', 0x0000754E) * 8 + struct.pack('<I', 0x0000449C) \\\n* 8 + struct.pack('<I', 0x000056A2) * 8 + struct.pack('<I',\n    0x00003EED) * 8 + struct.pack('<I', 0x0000106C) * 8 \\\n+ struct.pack('<I', 0x00000C7D) * 8 + struct.pack('<I', 0x0000578C) \\\n* 8 + struct.pack('<I', 0x000045CB) * 8 + struct.pack('<I',\n    0x0000253C) * 8 + struct.pack('<I', 0x00007F0F) * 8 \\\n+ struct.pack('<I', 0x00006513) * 8 + struct.pack('<I', 0x000004C0) \\\n* 8 + struct.pack('<I', 0x00006BFF) * 8 + struct.pack('<I',\n    0x0000711C) * 8 + struct.pack('<I', 0x00004829) * 8 \\\n+ struct.pack('<I', 0x00000B03) * 8 + struct.pack('<I', 0x000038E2) \\\n* 8 + struct.pack('<I', 0x000020AC) * 8 + struct.pack('<I',\n    0x00005708) * 8 + struct.pack('<I', 0x000064FA) * 8 \\\n+ struct.pack('<I', 0x00007984) * 8 + struct.pack('<I', 0x00004C79) \\\n* 8 + struct.pack('<I', 0x00007ED1) * 8 + struct.pack('<I',\n    0x00000F4F) * 8 + struct.pack('<I', 0x00002BB2) * 8 \\\n+ struct.pack('<I', 0x00005FA3) * 8 + struct.pack('<I', 0x00001073) \\\n* 8 + struct.pack('<I', 0x00002046) * 8 + struct.pack('<I',\n    0x00003175) * 8 + struct.pack('<I', 0x000005A5) * 8 \\\n+ struct.pack('<I', 0x000054CF) * 8 + struct.pack('<I', 0x00001B4E) \\\n* 8 + struct.pack('<I', 0x0000264E) * 8 + struct.pack('<I',\n    0x00003A88) * 8 + struct.pack('<I', 0x00002C1A) * 8 \\\n+ struct.pack('<I', 0x000022D6) * 8 + struct.pack('<I', 0x000019C0) \\\n* 8 + struct.pack('<I', 0x00002B57) * 8 + struct.pack('<I',\n    0x00003C82) * 8 + struct.pack('<I', 0x00007C61) * 8 \\\n+ struct.pack('<I', 0x0000530F) * 8 + struct.pack('<I', 0x00007AD2) \\\n* 8 + struct.pack('<I', 0x00007414) * 8 + struct.pack('<I',\n    0x00001ADD) * 8 + struct.pack('<I', 0xD6ADBCEF) * 8 \\\n+ struct.pack('<I', 0x00003E66) * 8 + struct.pack('<I', 0x000061DD) \\\n* 8 + struct.pack('<I', 0x00002330) * 8 + struct.pack('<I',\n    0xDEADBEEF) * 8 + struct.pack('<I', 0x0000475D) * 8 \\\n+ struct.pack('<I', 0x00002A4F) * 8 + struct.pack('<I', 0x00001F15) \\\n* 8 + struct.pack('<I', 0x00001162) * 8 + struct.pack('<I',\n    0xE3ADBEEF) * 8\n\nbuf = open(FILENAME, \"rb\").read()\nxbuf = xor_cipher(buf, key)\nopen(FILENAME + \".out\", \"wb\").write(xbuf)\n</code></pre>\n <h1>\n  Walk-through\n </h1>\n <p>\n  Looking at the header of the firmware, we can make some guess (all values stored in Little-endian):\n </p>\n <pre><code>Offset(h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n\n00000000  04 83 57 48 9C 3B 01 00 C8 CF 28 00 00 1E 2B 6A  .ƒWHœ;..ÈÏ(...+j\n00000010  47 00 0B 00 80 01 00 00 E4 CF 28 00 38 FE 28 00  G...€...äÏ(.8þ(.\n</code></pre>\n <ul>\n  <li>\n   0x48578304 : Maybe a signature\n  </li>\n  <li>\n   0x00013B9C : Almost the length of the firmware file length (originally 0x13C00)\n  </li>\n </ul>\n <p>\n  If we look further in the firmware hexdump and assume we are dealing with a CORTEX device or something similar, at offset 0x20 we could think that there is a vector table:\n </p>\n <pre><code>Offset(h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n\n00000020  CF 36 00 20 3E 1B 00 08 F2 D5 00 08 A4 D5 00 08  Ï6. >...òÕ..¤Õ..\n00000030  A2 D5 00 08 A0 D5 00 08 BE D5 00 08 EF 26 00 00  ¢Õ.. Õ..¾Õ..ï&..\n</code></pre>\n <ul>\n  <li>\n   0x200036CF : Initial SP Value\n  </li>\n  <li>\n   0x08001B3E : Reset Vector\n  </li>\n  <li>\n   0x0800D5F2 : NMI Vector\n  </li>\n  <li>\n   0x0800D5A4 : Hard Fault\n  </li>\n  <li>\n   0x0800D5A2 : Memory Management Fault\n  </li>\n  <li>\n   0x0800D5A0 : Bus Fault\n  </li>\n  <li>\n   0x0800D5BE : Usage Fault\n  </li>\n  <li>\n   0x000026EF : RESERVED\n  </li>\n  <li>\n   0x0000565C : RESERVED\n  </li>\n  <li>\n   0x0000565C : RESERVED\n  </li>\n  <li>\n   0x0000565C : RESERVED\n  </li>\n </ul>\n <p>\n  Here we can notice few problems:\n </p>\n <ol>\n  <li>\n   Why the Initial SP Value is not aligned?\n  </li>\n  <li>\n   Why the reserved vector are not NULL?\n  </li>\n </ol>\n <p>\n  At this point, grepping the sequence of bytes\n  <code>\n   EF 26 00 00\n  </code>\n  end up in an interesting place:\n </p>\n <pre><code>Offset(h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n\n00012000  E7 1A 00 00 E7 1A 00 00 E7 1A 00 00 E7 1A 00 00  ç...ç...ç...ç...\n00012010  E7 1A 00 00 E7 1A 00 00 E7 1A 00 00 E7 1A 00 00  ç...ç...ç...ç...\n00012020  EF 26 00 00 EF 26 00 00 EF 26 00 00 EF 26 00 00  ï&..ï&..ï&..ï&.. << 0x000026EF REPEATED 4 TIMES\n00012030  EF 26 00 00 EF 26 00 00 EF 26 00 00 EF 26 00 00  ï&..ï&..ï&..ï&.. << 0x000026EF REPEATED 4 TIMES\n00012040  5C 56 00 00 5C 56 00 00 5C 56 00 00 5C 56 00 00  \\V..\\V..\\V..\\V..\n00012050  5C 56 00 00 5C 56 00 00 5C 56 00 00 5C 56 00 00  \\V..\\V..\\V..\\V..\n00012060  09 11 00 00 09 11 00 00 09 11 00 00 09 11 00 00  ................\n00012070  09 11 00 00 09 11 00 00 09 11 00 00 09 11 00 00  ................\n00012080  18 56 00 00 18 56 00 00 18 56 00 00 18 56 00 00  .V...V...V...V..\n00012090  18 56 00 00 18 56 00 00 18 56 00 00 18 56 00 00  .V...V...V...V..\n</code></pre>\n <p>\n  We can see that the value 0x000026EF is repeated 8 times, and we have the value 0x0000565C (the other reserved vector) repeated 8 times, and some others values are repeated too.\n </p>\n <p>\n  There is a big chance that we are inside some ZERO pages and it is a simple XOR cipher which is applied on the whole file.\n </p>\n <p>\n  Maybe the XOR cipher key is in the following form:\n </p>\n <ul>\n  <li>\n   key[0] repeated 8 times\n  </li>\n  <li>\n   key[1] repeated 8 times\n  </li>\n  <li>\n   key[2] repeated 8 times\n  </li>\n  <li>\n   ...\n  </li>\n  <li>\n   key[63] repeated 8 times\n  </li>\n </ul>\n <p>\n  By looking at all the offset where are stored the value the 0x000026EF, we can compute the delta between them, we can make a guess that the key length is 0x800 bytes.\n </p>\n <p>\n  Hopefully we can find 3 version of the firmware on the internet:\n </p>\n <ul>\n  <li>\n   f553e034ba70138c270dac03e7dcda6f :\n   <code>\n    HW718V38_20170216.firmware\n   </code>\n  </li>\n  <li>\n   7440def1011f50749ff7f1ca8f7bcced :\n   <code>\n    HW718V39_20170221.firmware\n   </code>\n  </li>\n  <li>\n   0850c80192dcad7a0ce9a5446fb97f16 :\n   <code>\n    HW718V40_20171008.firmware\n   </code>\n  </li>\n </ul>\n <p>\n  In order to extract the full key, we split each firmware file in block of 0x800 bytes chuncks, and compute the number of occurence of every 0x04 bytes repeated every 0x20 bytes.\n </p>\n <p>\n  With this we are able to extract the full key, some adjustments were required using the previous method:\n </p>\n <ul>\n  <li>\n   keys[34] = 0x2BB2\n  </li>\n  <li>\n   keys[38] = 0x3175\n  </li>\n  <li>\n   keys[54] = 0xD6ADBCEF             # 4 bytes key ... wat !?\n  </li>\n  <li>\n   keys[58] = 0xDEADBEEF             # 4 bytes key ... wat !?\n  </li>\n  <li>\n   keys[60] = 0x2A4F\n  </li>\n  <li>\n   keys[62] = 0x1162\n  </li>\n  <li>\n   keys[63] = 0xE3ADBEEF             # 4 bytes key ... wat !?\n  </li>\n </ul>\n <p>\n  The last step is now to know the exact value for the loading address, by starting to disassemble the firmware with a processor ARM little-endian at a loading address 0x08000000 and file offset 0x20, we can find an interesting disassembly:\n </p>\n <pre><code>ROM:0800B854                 LDR             R1, =0xE000ED08\nROM:0800B856                 LDR             R0, =0x8003C00\nROM:0800F458                 STR             R0, [R1]\n</code></pre>\n <p>\n  0xE000ED08 is the Vector Table Offset Register and the value 0x8003C00 is written inside it.\n </p>\n <p>\n  Now we can reaload our firmware with an ARM processor in little-endian at the loading address 0x8003C00 and file offset 0x20 and we can start working on the reverse engineering.\n </p>\n</div>\n</body></html>",
            "votes": "6",
            "user": "w4kfu",
            "time": "Oct 26, 2019 at 7:32",
            "is_accepted": true,
            "comments": []
        }
    ]
}