{
    "title": "Why does this piece of code modify itself?",
    "link": "https://reverseengineering.stackexchange.com/questions/32283/why-does-this-piece-of-code-modify-itself",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm reading the famous\n  <a href=\"http://phrack.org/archives/issues/49/14.txt\" rel=\"nofollow noreferrer\">\n   \"Smash the stack and profit\" paper\n  </a>\n  , and to reiterate, the whole point of the idea is to put some binary code in a buffer, overflows it to rewrite the return address (RET) and go from there.\n </p>\n <p>\n  In the middle of paper there is a picture for this:\n </p>\n <pre><code>bottom of  DDDDDDDDEEEEEEEEEEEE  EEEE  FFFF  FFFF  FFFF  FFFF     top of\nmemory     89ABCDEF0123456789AB  CDEF  0123  4567  89AB  CDEF     memory\n           buffer                sfp   ret   a     b     c\n\n<------   [JJSSSSSSSSSSSSSSCCss][ssss][0xD8][0x01][0x02][0x03]\n           ^|^             ^|            |\n           |||_____________||____________| (1)\n       (2)  ||_____________||\n             |______________| (3)\ntop of                                                            bottom of\nstack                                                                 stack\n</code></pre>\n <p>\n  And there is a code block with calculated offsets (because we have to manually count the bytes for JMP and CALL):\n </p>\n <pre><code>------------------------------------------------------------------------------\n        jmp    0x26                     # 2 bytes\n        popl   %esi                     # 1 byte\n        movl   %esi,0x8(%esi)           # 3 bytes\n        movb   $0x0,0x7(%esi)           # 4 bytes\n        movl   $0x0,0xc(%esi)           # 7 bytes\n        movl   $0xb,%eax                # 5 bytes\n        movl   %esi,%ebx                # 2 bytes\n        leal   0x8(%esi),%ecx           # 3 bytes\n        leal   0xc(%esi),%edx           # 3 bytes\n        int    $0x80                    # 2 bytes\n        movl   $0x1, %eax       # 5 bytes\n        movl   $0x0, %ebx       # 5 bytes\n        int    $0x80            # 2 bytes\n        call   -0x2b                    # 5 bytes\n        .string \\\"/bin/sh\\\"     # 8 bytes\n------------------------------------------------------------------------------\n</code></pre>\n <p>\n  And then it says:\n </p>\n <blockquote>\n  <p>\n   Looks good. To make sure it works correctly we must compile it and run it.\nBut there is a problem.  Our code modifies itself, but most operating system\nmark code pages read-only.\n  </p>\n </blockquote>\n <p>\n  I got confused here and feel that I actually don't fully understand the idea. Here are my two questions:\n </p>\n <p>\n  Q1: Let's go back to the original idea (put binary code into buffer and rewrites RET to fire that binary code). I know that code lives in text segment, which is independent of stack and heap. So, even if we are able to rewrite the RET, how come the OS permits code run from stack? After all the binary code still lives in a buffer on stack.\n </p>\n <p>\n  Q2: Where does the code rewrite itself? My understanding is that, the code simply rewrites part of the stack:\n </p>\n <ul>\n  <li>\n   Step 1:\n   <code>\n    popl\n   </code>\n   top of stack to\n   <code>\n    esi\n   </code>\n   , but since this \"code\" is in the buffer, it is also sitting on top of the stack, so basically this means, I'm going to pass the base address of the string/buffer to\n   <code>\n    esi\n   </code>\n  </li>\n  <li>\n   Step 2: and then move a bunch of data to an offset of that address. The string/buffer is definitely larger than\n   <code>\n    0x8\n   </code>\n   or even\n   <code>\n    oxc\n   </code>\n   bytes, so that means the string itself got rewritten.\n  </li>\n </ul>\n <p>\n  Is my understanding correct? I still don't see how this piece of code work, but I'll drill deeper whence the two questions are cleared.\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 3,
    "views": "183",
    "tags": [
        "buffer-overflow",
        "stack"
    ],
    "user": "Nicholas Humphrey",
    "time": "Sep 14, 2023 at 11:43",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <h2>\n  Q1\n </h2>\n <p>\n  The paper was written in 1996 (\n  <a href=\"http://phrack.org/issues/49/1.html\" rel=\"nofollow noreferrer\">\n   published on 8 November 1996 to be exact\n  </a>\n  ).  In those days, it was the norm for the stack to be executable.\n </p>\n <p>\n  In fact, x86 CPUs of that era basically lacked the\n  <em>\n   capability\n  </em>\n  to make the stack non-executable.  Nowadays this is done by setting the\n  <a href=\"https://en.wikipedia.org/wiki/NX_bit\" rel=\"nofollow noreferrer\">\n   NX bit\n  </a>\n  in the page table entries.  But no such bit existed in the original 32-bit x86 architecture.  An NX bit was only added as part of the 64-bit AMD64 extension, which didn't hit the market until 2003-2004, and of course older 32-bit chips remained in use for much longer still.\n </p>\n <p>\n  So in effect, on x86 platforms of those days, every page that was readable was also executable, and the hardware didn't support any way to change that.\n </p>\n <p>\n  The only way to make the stack non-executable would have been to use the x86 segmentation feature, instead of page-based protection.  The OS could set up the segment descriptor for the CS segment with a limit value that would exclude the stack region.  But this would be awkward, as it can't be done page-by-page; it would effectively just set a single \"cutoff\" address in memory, such that everything below that address is executable and everything above it is not.  It could interfere with programs that, for whatever reason, wanted to use a more unusual memory layout.  It would also run counter to Linux's general philosophy of not wanting to use the segmentation features, preferring a perfectly flat memory model as was common for most other Unix-like systems, and so would normally set the segment limit parameters to cover all of memory.\n </p>\n <p>\n  (It's important to note here that \"segmentation\", referring to the Intel/x86 memory protection feature, is unrelated to the platform-independent use of the word \"segment\" for generic regions of program memory like \"code\" and \"data\".  It is also not directly related to the generic term \"segmentation fault\"; indeed, on typical x86 Unix platforms, most \"segmentation faults\" are really page faults, caused by the paging mechanism instead of x86 segment-based memory protection.)\n </p>\n <p>\n  There were legitimate uses for executing code from the stack, for things like\n  <a href=\"https://en.wikipedia.org/wiki/Trampoline_(computing)\" rel=\"nofollow noreferrer\">\n   trampolines\n  </a>\n  .  If I recall correctly, Linux's original mechanism for returning from signal handlers worked like this.  GCC's \"nested function\" extension to the C language uses it too, and indeed I believe to this day you have to enable executable stack if you want to make full use of that extension.\n </p>\n <h2>\n  Q2\n </h2>\n <p>\n  You're right, the code does not modify itself in the sense of modifying its own instructions.  But it writes to memory\n  <em>\n   adjacent\n  </em>\n  to itself, to construct the argument vector for\n  <code>\n   execve\n  </code>\n  .  Since the code is going to be run from the stack, you can certainly think of this as \"rewriting part of the stack\".\n </p>\n <p>\n  The point that the author's making here is that because of this, the code can\n  <em>\n   only\n  </em>\n  be run from memory which is writable, such as the stack.  This part of the paper is talking about how to test the shellcode, and the author is pointing out that it won't work to just assemble the asm source as a standalone program (slapping a\n  <code>\n   main\n  </code>\n  label at the top) and then run it.  If we did that, then the code\n  <em>\n   would\n  </em>\n  be placed in the read-only code segment, and so the adjacent memory it tries to modify would be read-only as well, and the code would crash when it tried to write to it.  So that's why the author goes through the additional steps of assembling the code, dumping it as hex bytes, and using it to populate a\n  <code>\n   char shellcode[]\n  </code>\n  array in a test program.  The\n  <code>\n   shellcode\n  </code>\n  array would be in a writable static data section, not the stack, but that's still fine for testing purposes.\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Nate Eldredge",
            "time": "Sep 16, 2023 at 14:11",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Nicholas Humphrey",
                    "text": "<span class=\"comment-copy\">Thanks Nate and sorry for the late reply. For Q1, thanks for pointing out that the stack is also executable. I always thought only the code segment is executable. I need to find some assembly resources to further my understanding of the topic. Probably some legacy documentation first, and 64-bit next.  For Q2, thanks for reminding me that code segment is not writable. Apparently I kinda mixed \"writable\" and \"executable\" when I was writing the question, although I do understand they are completely different.</span>",
                    "time": null
                },
                {
                    "user": "Nate Eldredge",
                    "text": "<span class=\"comment-copy\">@NicholasHumphrey: \"I always thought only the code segment is executable.\" And for modern systems with NX page protection, that's generally true.  But not on a '90s x86 machine.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  If I'm wrong at anything, someone please correct me.\n </p>\n <ul>\n  <li>\n   <p>\n    Q1: the current OSes or compilers (one of these. There are protections on the files themselves enabled by the compiler and others on the OS itself) have protection against running stuff on the stack - old ones didn't. Maybe whenever that paper was released the protection didn't exist yet or wasn't too used (around 1995 from the GCC copyright year?).\n   </p>\n  </li>\n  <li>\n   <p>\n    Q2: It does indeed rewrite part of the stack with the mov instructions - because it was put on the stack. What I imagine the author was trying to exemplify with that is if you'd manage to rewrite the code section with the buffer overflow. Like maybe a long enough buffer that would get to the code section and rewrite part of it. Just doesn't make a lot of sense to me (I'm no expert whatsoever though. But still not sure why one would try to get to the code section like that anyway). Or maybe they could be saying that you could never put that code on the executable file itself (locally modify it), after all the code in it or in some place where it fits and then use the buffer overflow technique to get to it (instead of modifying the file too to have it just jump there instead of needing the overflow, which would end with the stack smashing idea... - added the code to the file, why not change the RET instruction on it too right there...). Both don't make a lot of sense to me, but they're the ones that come to my mind about this.\n   </p>\n  </li>\n </ul>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Edw590",
            "time": "Sep 14, 2023 at 17:09",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  the paper is quiet old and the compilers have improved a lot\n  \n\n  it my not be easy to churn out a byte for byte similar code with latest compilers\n  \n\n  they may not even compile such code\n </p>\n <p>\n  it is better not to stick to word for word in the paper but move ahead and grasp the concept\n </p>\n <p>\n  a buffer overflow with copy functions happens\n  \n\n  when the destination buffer is smaller than the source buffer.\n </p>\n <p>\n  when such an over flow happens the spill overwrites what already exists\n  \n\n  and in doing so might overwrite important addresses like return addresses\n </p>\n <p>\n  if you carefully craft an address and overwrite a specific return address that already exists\n  \n\n  with the crafted address you can divert the execution flow\n  \n\n  this kind of diverted execution is called buffer overflow exploit\n </p>\n <p>\n  I will use msvc 2019 x86 in windows 10\n  \n\n  to show a small self contained example\n  \n\n  it exploits itself by using a fixed address to trash a original return address in stack\n </p>\n <pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\nvoid exploit(void){\n    printf(\"i was exploited to print this by trashing a return address\n\");\n    exit(0);\n}\n// first 0x20 bytes will be copied to stackbuff the last 4 bytes  \n// will trash the return address of main\nvoid cpdat(char *cpbuff) {\n    strcpy(cpbuff,\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaapq@\\0\");\n    return; // this will return to main but main will not \n            // return to __scrt_common_main_seh+0xfa. \n            // instead main will return to  0x407170 or \"pq@\"\n}\nint main (void) {\n    char stackbuff[0x20];   // this buffer will be local and will be in stack \n    cpdat(stackbuff);       // buffer overflow will trash the return address \n    return 0;               // this will return to (pq@\\0 / 0x00407170) \n                            // and  the exploit function will be called \n}\n</code></pre>\n <p>\n  compile and link with no GS cookies , no ASLR , no Relocation ,\n  \n\n  so that the function exploit()  always loads at a fixed address\n  \n\n  in my case\n  <strong>\n   0x00407170  or \"pq@\\0\"\n  </strong>\n </p>\n <pre><code>cl /Zi /GS- vuln.cpp /link /fixed /dynamicbase:no\n</code></pre>\n <p>\n  on running the binary the exploit function will run\nwithout being called explicitly\n  \n\n  but by implicit exploitation of a buffer overflow\n  \n\n  which overwrote the original return address __scrt_common_main_seh+0xfa\n </p>\n <pre><code>:\\>vuln.exe\nno on called me but i still came here\n</code></pre>\n <p>\n  stack trace when main is called\n </p>\n <pre><code>0:000> k\nChildEBP RetAddr\n0019ff28 00407473 vuln!main\n(Inline) -------- vuln!invoke_main+0x1c\n0019ff70 773d00c9 vuln!__scrt_common_main_seh+0xfa\n0019ff80 777a7b4e KERNEL32!BaseThreadInitThunk+0x19\n0019ffdc 777a7b1e ntdll!__RtlUserThreadStart+0x2f\n0019ffec 00000000 ntdll!_RtlUserThreadStart+0x1b\n</code></pre>\n <p>\n  as can be seen the return address that will be overwritten is as below\n </p>\n <pre><code>0:000> $$ the return address is 0x407473\n0:000> dd @esp l4\n0019ff2c  00407473 00000001 007884a0 0078fda0\n</code></pre>\n <p>\n  we are at the start of main function\n </p>\n <pre><code>0:000> r\neax=00472f28 ebx=003d9000 ecx=00000000 edx=92fffefd esi=007884a0 edi=0078fda0\neip=004071b0 esp=0019ff2c ebp=0019ff70 iopl=0         nv up ei pl nz na pe nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206\nvuln!main:\n004071b0 55              push    ebp\n</code></pre>\n <p>\n  lets run until the return and see where we are returning\n </p>\n <pre><code>0:000> pt\neax=00000000 ebx=003d9000 ecx=004662ac edx=00407170 esi=007884a0 edi=0078fda0\neip=004071c7 esp=0019ff2c ebp=61616161 iopl=0         nv up ei pl zr na pe nc\ncs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246\nvuln!main+0x17:\n004071c7 c3              ret\n</code></pre>\n <p>\n  the original return address has been replaced by the overflown crafted address\n </p>\n <pre><code>0:000> dd @esp l4\n0019ff2c  00407170 00000001 007884a0 0078fda0\n</code></pre>\n <p>\n  notice the stack address 0x19ff2c\n </p>\n <pre><code>0019ff2c  00407473 00000001 007884a0 0078fda0 \nnow contains \n0019ff2c  00407170 00000001 007884a0 0078fda0\n</code></pre>\n <p>\n  check what is the function it is returning to\n </p>\n <pre><code>0:000> ln poi(@esp)\n(00407170)   vuln!exploit   |  (00407190)   vuln!cpdat\nExact matches:\n    vuln!exploit (void)\n0:000>\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "blabb",
            "time": "Sep 15, 2023 at 23:07",
            "is_accepted": false,
            "comments": []
        }
    ]
}