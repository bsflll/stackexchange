{
    "title": "IDA interpretation of switch-case statement",
    "link": "https://reverseengineering.stackexchange.com/questions/29629/ida-interpretation-of-switch-case-statement",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  This is my first question on this forum, so I hope that it would not be offensive or redundant.\n </p>\n <p>\n  So recently I am attempting to developing some kernel extensions for Apple's macOS using the IOKit framework. However, in the debugging process, I encountered some confusions while looking at the assembly and pseudocode of my binaries generated by IDA.\n </p>\n <p>\n  Currently, the greatest issue is how the normal switch case statement is interrupted by the decompiler —\n  <code>\n   _bittest64\n  </code>\n  commands would be yielded with huge numbers as arguments. I am somewhat sure that it has to do with the “lower-bound” of the cases, but I don't know how exactly should I comprehend it. Here is an example:\n </p>\n <p>\n  <img alt=\"Actual code\" src=\"https://i.sstatic.net/LOxqp.png\"/>\n  <img alt=\"Hex-Rays decompiler pseudocde\" src=\"https://i.sstatic.net/Qf0zs.png\"/>\n </p>\n <p>\n  I can't really see how they relate, particularly the\n  <code>\n   _bittest64\n  </code>\n  part. Just by the way, the enum\n  <code>\n   kBluetoothIntelHardwareVariantJfP = 0x11\n  </code>\n  and\n  <code>\n   kBluetoothIntelHardwareVariantSlrF = 0x19\n  </code>\n  .\n </p>\n <p>\n  Happy thanksgiving!\n </p>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 1,
    "views": "651",
    "tags": [
        "ida",
        "c++"
    ],
    "user": "vv001",
    "time": "Nov 27, 2021 at 21:04",
    "comments": [
        {
            "user": "MarianD",
            "text": "<html><body><span class=\"comment-copy\">\n Welcome to Reverse Engineering StackExchange! Please copy / paste your code\n <i>\n  as a text\n </i>\n instead of pictures. It will help others to help you.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  It's a compiler optimization used to implement\n  <code>\n   switch\n  </code>\n  statements that have many cases leading to one location. Note that the weird output is not Hex-Rays' doing, but rather, a more-or-less direct translation of what's in the assembly language. You didn't show the assembly for your snippet, but here's similar disassembly from a database I have open:\n </p>\n <pre><code>.text:0000000061FEA1C8     lea     eax, [rdi-33h]\n.text:0000000061FEA1CB     cmp     eax, 0Eh\n.text:0000000061FEA1CE     ja      short loc_61FEA1F8\n.text:0000000061FEA1CE\n.text:0000000061FEA1D0     mov     edx, 6381h\n.text:0000000061FEA1D5     bt      edx, eax ; <- this becomes _bittest\n.text:0000000061FEA1D8     jnb     short loc_61FEA1F8\n</code></pre>\n <p>\n  And here's its Hex-Rays decompilation:\n </p>\n <pre><code>  if ( (vChildOp - 51) > 0xE )\n    return /* ... */;\n\n  v6 = 25473;\n  if ( !_bittest(&v6, vChildOp - 51) )\n    return /* ... */;\n</code></pre>\n <p>\n  Let's take a closer look at your snippet. You said that\n  <code>\n   kBluetoothIntelHardwareVariantJfP = 0x11\n  </code>\n  and\n  <code>\n   kBluetoothIntelHardwareVariantSlrF = 0x19\n  </code>\n  . Now look at the constant,\n  <code>\n   0x39E0000LL\n  </code>\n  . This is\n  <code>\n   11100111100000000000000000b\n  </code>\n  in binary:\n </p>\n <pre><code>11 1001 1110 0000 0000 0000 0000\n|| |  | |||- bits 0-16 clear   \n|| |  | ||-- bit 17 (i.e., 0x11): first bit set\n|| |  | |--- bit 0x12 set\n|| |  | ---- bit 0x13 set\n|| |  ------ bit 0x14 set\n|| --------- bit 0x17 set\n|----------- bit 0x18 set\n------------ bit 0x19: last bit set\n</code></pre>\n <p>\n  Notice that the\n  <code>\n   switch\n  </code>\n  statement in your example has 7 cases leading to the same label, and that two of the cases correspond to bits\n  <code>\n   0x19\n  </code>\n  and\n  <code>\n   0x11\n  </code>\n  ? It is not a coincidence that the constant in the snippet has 7 bits set, including bits\n  <code>\n   0x11\n  </code>\n  and\n  <code>\n   0x19\n  </code>\n  ! The\n  <code>\n   bt\n  </code>\n  instruction, translated as the\n  <code>\n   _bittest\n  </code>\n  intrinsic, is just checking to see whether\n  <code>\n   hardwareVariant\n  </code>\n  , or\n  <code>\n   a2\n  </code>\n  in the decompilation, is one of the values\n  <code>\n   0x11\n  </code>\n  -\n  <code>\n   0x14\n  </code>\n  or\n  <code>\n   0x17-0x19\n  </code>\n  . It performs all 7 comparisons at the same time.\n </p>\n <p>\n  The\n  <code>\n   if\n  </code>\n  -statement on the outside is the\n  <code>\n   default\n  </code>\n  check: it ensures that the value of\n  <code>\n   a2\n  </code>\n  is at most\n  <code>\n   0x19\n  </code>\n  -- if it's not, it jumps to the\n  <code>\n   default\n  </code>\n  location, i.e., does nothing.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Rolf Rolles",
            "time": "Nov 28, 2021 at 21:39",
            "is_accepted": true,
            "comments": [
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">OT on a simple glance  result is an unassigned local a garbage only assigned a value inside the if block{} so does this function return garbage?</span>",
                    "time": null
                },
                {
                    "user": "Rolf Rolles",
                    "text": "<span class=\"comment-copy\">@blabb Note that, in the source code, the function's true return type is <code>void</code>. Hex-Rays erroneously thinks this function returns a value, so it tries to create an assignment expression for the <code>rax</code> register. In this case, the only such assignment takes place as part of the <code>bt</code> sequence, which is why we get garbage inside of an <code>if</code>-statement.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">Thanks and again OT  so the Function Type also needs to be modified manually as void blah(x,y) instead of __int64  to fix this but if there was no source to rely how to grapple with this apparently erroneous return in general</span>",
                    "time": null
                },
                {
                    "user": "Rolf Rolles",
                    "text": "<span class=\"comment-copy\">@blabb I rely on clues like the one you identified. If some paths through a function don't return a value,  it probably returns <code>void</code>. If none of the calling functions use the return value, it may or may not be <code>void</code>, but there's no harm in marking it as such. If a function supposedly returns <code>void</code>, but calling functions show usage of uninitialized values allocated in the <code>rax</code> register after the call, it does not return <code>void</code>. There's a recursive effect; if you determine a called function returns <code>void</code>, that may give you evidence that a calling function does also.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">ok thanks again actually i was looking for some magic recipes :) to peer at decompiled output  without  accompanying disassembly or source</span>",
                    "time": null
                }
            ]
        }
    ]
}