{
    "title": "Nested Structures in IDA",
    "link": "https://reverseengineering.stackexchange.com/questions/20069/nested-structures-in-ida",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm trying to figure out how to explore structs in IDA, and getting stuck on the basics. I wrote a very basic test app;\n </p>\n <pre><code>int main() {\n    const int kBits = 1024;\n    const int kExp = 3;\n\n    RSA *rsa = RSA_generate_key(kBits, kExp, 0, 0);\n    RSA_print_fp(stdout, rsa, 0);\n\n    RSA_free(rsa);\n    return 0;\n}\n</code></pre>\n <p>\n  Then I imported the OpenSSL headers, so IDA now understands what\n  <code>\n   RSA*\n  </code>\n  and\n  <code>\n   BIGNUM*\n  </code>\n  are.\n  <code>\n   BIGNUM\n  </code>\n  is actually pointing to\n  <a href=\"https://github.com/openssl/openssl/blob/367ace6870e9cbc8fe21dff2ffe4673a98ea42f8/crypto/bn/bn_lcl.h#L218\" rel=\"nofollow noreferrer\">\n   <code>\n    bignum_st\n   </code>\n  </a>\n  which is referenced from RSA, which is\n  <a href=\"https://github.com/openssl/openssl/blob/39c44eee7fd89ce13e805873e1c43bd8e488a93f/crypto/rsa/rsa_locl.h#L28\" rel=\"nofollow noreferrer\">\n   <code>\n    rsa_st\n   </code>\n  </a>\n  .\n </p>\n <p>\n  Then, dropped a breakpoint in the pseudocode view;\n  <a href=\"https://i.sstatic.net/WPheF.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/WPheF.png\"/>\n  </a>\n </p>\n <p>\n  Now, if I hover over\n  <code>\n   v3\n  </code>\n  , I see it's parsing the struct. So I want to do something like grab the value of\n  <code>\n   rsa->d->dmax\n  </code>\n  , but there doesn't seem to be a way to do this? I can't seem to find a way to access\n  <code>\n   v3\n  </code>\n  by name in IDAPython, nor can I seem to 'walk' the structure to get to the int that lives at\n  <code>\n   dmax\n  </code>\n  . Is there some way to do this?\n </p>\n</div>\n</body></html>",
    "votes": "5",
    "answers": 3,
    "views": "1k",
    "tags": [
        "ida",
        "debugging",
        "idapython",
        "linux",
        "hexrays"
    ],
    "user": "XeroxDucati",
    "time": "Jan 18, 2023 at 8:13",
    "comments": [
        {
            "user": "Biswapriyo",
            "text": "<html><body><span class=\"comment-copy\">\n Your code works as usual but it raises exception code in IDA+windbg. Can you share the compiled Windows binary?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Pororo",
            "text": "<html><body><span class=\"comment-copy\">\n Can I assume what you want to do is to dump the value of\n <code>\n  v3->d->dmax\n </code>\n upon reaching this breakpoint?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "XeroxDucati",
            "text": "<html><body><span class=\"comment-copy\">\n @Pororo yes, exactly!\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "XeroxDucati",
            "text": "<html><body><span class=\"comment-copy\">\n @Biswapriyo I can't imagine it would work in windows.. I'm doing this under Linux (CentOS 7 if it matters)\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Jane",
            "text": "<html><body><span class=\"comment-copy\">\n for some reason I thought this was the writing stack exchange, anyway -  +1 good question! will follow this.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  My knowledge of the IDAPython API isn't the most complete, but what I would do is\n </p>\n <ol>\n  <li>\n   Read the source (or look in IDA) to find the location (byte offsets) of\n   <code>\n    d\n   </code>\n   in\n   <code>\n    rsa_st\n   </code>\n   and\n   <code>\n    dmax\n   </code>\n   in\n   <code>\n    bignum_st\n   </code>\n   . This is easy since the members of the structures above\n   <code>\n    d\n   </code>\n   and\n   <code>\n    dmax\n   </code>\n   are pointers or int types.\n  </li>\n  <li>\n   Inspect the disassembly just before the call and determine the location of\n   <code>\n    v3\n   </code>\n   -\nfrom the pseudocode it appears to be stored in the stack. If you are lucky, pressing tab while your cursor is on\n   <code>\n    v3\n   </code>\n   will take you to some mov operation in disassembly.\n  </li>\n  <li>\n   When the breakpoint is hit, use a combination of\n   <code>\n    idc.get_reg_value\n   </code>\n   and\n   <code>\n    idc.get_bytes\n   </code>\n   commands (see\n   <a href=\"https://www.hex-rays.com/products/ida/support/idadoc/162.shtml\" rel=\"nofollow noreferrer\">\n    https://www.hex-rays.com/products/ida/support/idadoc/162.shtml\n   </a>\n   ), using the result from step 2 as a starting point.\n  </li>\n </ol>\n</div>\n</body></html>",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "Jan 18, 2023 at 10:17",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Here are the steps:\n </p>\n <ol>\n  <li>\n   Set breakpoint. Run the local debugger with\n   <kbd>\n    F9\n   </kbd>\n   . Open Debugger dropdown menu form menu bar and choose \"Take memory snapshot\". Here is the screenshot:\n  </li>\n </ol>\n <p>\n  <a href=\"https://i.sstatic.net/pDPZG.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"Take_Memory_Snapshot\" src=\"https://i.sstatic.net/pDPZG.png\"/>\n  </a>\n </p>\n <ol start=\"2\">\n  <li>\n   Double click on the variables that you want to know (here the\n   <code>\n    RSA*\n   </code>\n   pointer). IDA will take you to the stack view (aka. IDA View-RIP). Do not move the cursor otherwise you will get different value. Press\n   <kbd>\n    N\n   </kbd>\n   to name the variable in that stack view. \"Rename address\" window will pop-up. Here is the screenshot:\n  </li>\n </ol>\n <p>\n  <a href=\"https://i.sstatic.net/JdOnz.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"Enter_Variable_Name\" src=\"https://i.sstatic.net/JdOnz.png\"/>\n  </a>\n </p>\n <ol start=\"3\">\n  <li>\n   After naming the variable in that stack view, press\n   <kbd>\n    Y\n   </kbd>\n   to add the data type i.e. structure type. For this case it will be\n   <code>\n    RSA\n   </code>\n   , not the pointer because all stack variables placed linearly. Here is the screenshot:\n  </li>\n </ol>\n <p>\n  <a href=\"https://i.sstatic.net/Ae3y8.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"Enter_Data_type\" src=\"https://i.sstatic.net/Ae3y8.png\"/>\n  </a>\n </p>\n <p>\n  Now you can see all the struct members value.\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "Biswapriyo",
            "time": "Dec 8, 2018 at 5:05",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  \"Setting a breakpoint\" suggests that you are doing dynamic analysis. Assuming that and assuming this happens on a real system, may I suggest an alternative route for Linux, based on my other assumption that you are linking OpenSSL dynamically?\n </p>\n <p>\n  When on Linux (and a number of other unixoid systems) you can guide\n  <a href=\"https://man7.org/linux/man-pages/man8/ld.so.8.html\" rel=\"nofollow noreferrer\">\n   the dynamic linker/loader\n  </a>\n  to override a function. If you know Windows and DLLs it could probably be compared a little to DLL placement attacks, but it is more flexible and requires less effort.\n </p>\n <p>\n  NB: Obviously\n  <em>\n   this\n  </em>\n  approach doesn't teach you how about dealing with structs in IDA, but I think it is a very powerful technique to keep in mind. Because it is an alternative approach that doesn't satisfy your constraint of wanting to learn more about dealing with structs in IDA, I am making this a CW.\n </p>\n <p>\n  There are some components for this approach:\n </p>\n <ol>\n  <li>\n   you need a \"wrapper\" shared object, let's call it\n   <code>\n    mock_openssl_rsagenkey.so\n   </code>\n   , exporting\n   <code>\n    RSA_generate_key()\n   </code>\n   with a binary compatible signature to that from the original OpenSSL shared object (something like\n   <code>\n    libcrypto.so\n   </code>\n   )\n  </li>\n  <li>\n   you need to tell\n   <code>\n    ld.so\n   </code>\n   via environment variable to preload\n   <code>\n    mock_openssl_rsagenkey.so\n   </code>\n   (see below)\n  </li>\n </ol>\n <p>\n  <code>\n   ld.so\n  </code>\n  will take care -- when resolving symbols -- that the preloaded ones take precedence. This is how one of the modes of operation\n  <a href=\"https://linux.die.net/man/3/efence\" rel=\"nofollow noreferrer\">\n   for eFence is implemented (look for\n   <code>\n    LD_PRELOAD\n   </code>\n   , the man page also lists the exported symbols)\n  </a>\n  .\n </p>\n <p>\n  So now your only remaining task would be to turn up the correct prototype\n  <a href=\"https://www.openssl.org/docs/man1.1.1/man3/RSA_generate_key.html\" rel=\"nofollow noreferrer\">\n   for\n   <code>\n    RSA_generate_key\n   </code>\n  </a>\n  from the\n  <code>\n   libcrypto.so\n  </code>\n  that your binary uses (try\n  <code>\n   ldd ./your_binary\n  </code>\n  to list dependencies) and write the wrapper\n  <code>\n   .so\n  </code>\n  , using\n  <a href=\"https://man7.org/linux/man-pages/man3/dlopen.3.html\" rel=\"nofollow noreferrer\">\n   <code>\n    dlopen()\n   </code>\n  </a>\n  and\n  <a href=\"https://man7.org/linux/man-pages/man3/dlsym.3.html\" rel=\"nofollow noreferrer\">\n   <code>\n    dlsym()\n   </code>\n  </a>\n  to locate the\n  <em>\n   original\n  </em>\n  <code>\n   RSA_generate_key\n  </code>\n  symbols from the\n  <em>\n   actual\n  </em>\n  <code>\n   libcrypto.so\n  </code>\n </p>\n <hr/>\n <h3>\n  Full example\n </h3>\n <h4>\n  <code>\n   main.c\n  </code>\n </h4>\n <p>\n  This is approximately the program you created and are analyzing.\n </p>\n <pre><code>#include <stdio.h>\n#include <stdlib.h>\n#include <openssl/rsa.h>\n\nint main(int argc, char const ** argv, char const** envp)\n{\n    int const kBits = 1024;\n    int const kExp = 3;\n\n    RSA *rsa = RSA_generate_key(kBits, kExp, 0, 0);\n    RSA_print_fp(stdout, rsa, 0);\n\n    RSA_free(rsa);\n    return EXIT_SUCCESS;\n}\n</code></pre>\n <h4>\n  <code>\n   mock_openssl.c\n  </code>\n </h4>\n <p>\n  This is the wrapper shared object, which we'll load with\n  <code>\n   LD_PRELOAD\n  </code>\n  .\n </p>\n <pre><code>#include <dlfcn.h>\n#include <openssl/rsa.h>\n\ntypedef RSA* (*RSA_generate_key_t)(int, unsigned long, void (*)(int, int, void *), void *);\nstatic RSA_generate_key_t real_RSA_generate_key = 0;\nstatic void* libcrypto = 0;\n\nstatic void init() __attribute__((constructor));\nstatic void fini() __attribute__((destructor));\n\nvoid init()\n{\n    if (!libcrypto)\n    {\n        libcrypto = dlopen(\"libcrypto.so.3\", RTLD_NOW);\n        if (!libcrypto)\n        {\n            libcrypto = dlopen(\"libcrypto.so\", RTLD_NOW);\n        }\n        fprintf(stderr, \"Loaded libcrypto: %p\n\", libcrypto);\n        if (libcrypto)\n        {\n            real_RSA_generate_key = (RSA_generate_key_t)dlsym(libcrypto, \"RSA_generate_key\");\n        }\n        fprintf(stderr, \"\\tRSA_generate_key == %p\n\", (void*)real_RSA_generate_key);\n    }\n}\n\nvoid fini()\n{\n    if (libcrypto)\n    {\n        dlclose(libcrypto);\n        libcrypto = 0;\n        real_RSA_generate_key = 0;\n    }\n}\n\nRSA* RSA_generate_key(int bits, unsigned long e, void (*callback)(int, int, void *), void *cb_arg)\n{\n    if (!real_RSA_generate_key)\n    {\n        fprintf(stderr, \"FATAL: Have no function pointer for original RSA_generate_key()\n\");\n        return 0;\n    }\n    fprintf(stderr, \"Calling real_RSA_generate_key(%i, %lu, %p, %p)\n\", bits, e, callback, cb_arg);\n    RSA* ret = real_RSA_generate_key(bits, e, callback, cb_arg);\n    /* do something with ret here */\n    if (ret)\n    {\n        fprintf(stderr, \"Returned RSA key: %p ... I can do what I want with it ... MUHAHAHA!\n\", ret);\n    }\n    return ret;\n}\n</code></pre>\n <p>\n  Explanation:\n </p>\n <ul>\n  <li>\n   <code>\n    RSA_generate_key_t\n   </code>\n   parrots the prototype of the original function as\n   <code>\n    typedef\n   </code>\n  </li>\n  <li>\n   <code>\n    real_RSA_generate_key\n   </code>\n   is going to hold the function pointer retrieved from the real\n   <code>\n    libcrypto.so\n   </code>\n  </li>\n  <li>\n   <code>\n    libcrypto\n   </code>\n   is going to hold the handle to the loaded\n   <code>\n    libcrypto.so\n   </code>\n  </li>\n  <li>\n   <code>\n    init()\n   </code>\n   -- declared as constructor -- will run when\n   <em>\n    our\n   </em>\n   wrapper\n   <code>\n    .so\n   </code>\n   gets loaded\n   <ul>\n    <li>\n     it attempts to load\n     <code>\n      libcrypto.so.3\n     </code>\n    </li>\n    <li>\n     failing that, attempts to load\n     <code>\n      libcrypto.so\n     </code>\n    </li>\n    <li>\n     if successful in either of the preceding steps, it uses\n     <code>\n      dlsym()\n     </code>\n     to fetch the address of the real\n     <code>\n      RSA_generate_key\n     </code>\n     and stores it in\n     <code>\n      real_RSA_generate_key\n     </code>\n    </li>\n    <li>\n     ... also outputs the steps, something like:\n     <pre><code>Loaded libcrypto: 0x7f9ad86e3700\n        RSA_generate_key == 0x7f9ad8478b50\n</code></pre>\n    </li>\n   </ul>\n  </li>\n  <li>\n   <code>\n    finit()\n   </code>\n   -- declared as destructor -- will run when our wrapper\n   <code>\n    .so\n   </code>\n   gets unloaded\n  </li>\n  <li>\n   <code>\n    RSA_generate_key()\n   </code>\n   is our wrapper to the original function and will be called in place of the one from\n   <code>\n    libcrypto.so\n   </code>\n   by a program that preloads this\n   <code>\n    .so\n   </code>\n  </li>\n </ul>\n <h4>\n  <code>\n   GNUmakefile\n  </code>\n </h4>\n <p>\n  The GNU\n  <code>\n   make\n  </code>\n  recipes to build our stuff.\n </p>\n <pre><code>CC:=gcc\nCFLAGS:=$(strip -Wno-deprecated-declarations $(CFLAGS))\nall: bin so\nbin: your_binary\nso: mock_openssl_rsagenkey.so\n\nbin: LDLIBS=-lcrypto\n\nyour_binary: main.c\n        $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@\n\nso: CFLAGS=-shared -fPIC\nso: LDFLAGS=-Wl,-soname,libcrypto.so\nso: LDLIBS=-ldl\n\nmock_openssl_rsagenkey.so: mock_openssl.c\n        $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@\n\n.PHONY: all so bin\n</code></pre>\n <h4>\n  Steps\n </h4>\n <ol>\n  <li>\n   write each of the above with the name I gave in the subsection titles into a file\n  </li>\n  <li>\n   run\n   <code>\n    make\n   </code>\n   (on Debian/Ubuntu you may want to install\n   <code>\n    build-essential\n   </code>\n   , for other systems consult your documentation)\n  </li>\n  <li>\n   invoke, e.g. with this\n   <code>\n    env LD_PRELOAD=./mock_openssl_rsagenkey.so ./your_binary\n   </code>\n  </li>\n </ol>\n <h5>\n  Output (excerpt)\n </h5>\n <pre><code>$ LD_PRELOAD=./mock_openssl_rsagenkey.so ./your_binary\nLoaded libcrypto: 0x7f9ad86e3700\n        RSA_generate_key == 0x7f9ad8478b50\nCalling real_RSA_generate_key(1024, 3, (nil), (nil))\nReturned RSA key: 0x55d1bfc40c10 ... I can do what I want with it ... MUHAHAHA!\nRSA Private-Key: (1024 bit, 2 primes)\nmodulus:\n    00:d2:85:86:68:fb:1f:b0:92:c7:dd:09:08:7a:39:\n    21:7e:74:27:36:08:23:0d:1f:6c:7a:ec:47:5d:fc:\n    27:c9:95:c2:a4:e1:9f:99:1b:3f:d9:f8:88:65:30:\n    93:c6:7d:2b:31:9b:b1:cb:5c:5a:b8:7a:20:c0:4b:\n    63:25:c4:3a:30:c3:81:16:56:28:ac:f7:74:93:6b:\n    93:64:db:c9:d5:0f:64:f8:15:b4:0d:18:1d:86:c1:\n    60:4b:5a:2f:2f:b7:fb:90:03:13:d5:be:1e:05:05:\n    0e:91:54:79:5b:58:2f:02:de:0a:1f:ef:06:a4:0a:\n    28:e4:55:3f:31:9d:a9:26:53\npublicExponent: 3 (0x3)\nprivateExponent:\n...\n</code></pre>\n <p>\n  Explanation:\n </p>\n <ul>\n  <li>\n   Lines 1..2 are from\n   <code>\n    init()\n   </code>\n  </li>\n  <li>\n   Lines 3..4 are from\n   <code>\n    RSA_generate_key()\n   </code>\n   in our wrapper\n   <code>\n    .so\n   </code>\n   <ul>\n    <li>\n     <strong>\n      NB:\n     </strong>\n     this shows you have full access to all the arguments! While it may be a little more intricate to do, it would also clearly be possible to wrap the callback mechanism provided by OpenSSL into our own, e.g.:\n     <ul>\n      <li>\n       prior to calling\n       <code>\n        real_ RSA_generate_key()\n       </code>\n       , allocate a struct holding original\n       <code>\n        callback\n       </code>\n       pointer and\n       <code>\n        cb_arg\n       </code>\n      </li>\n      <li>\n       pass our own callback function\n       <ul>\n        <li>\n         inside our callback function unwrap the struct and pass arguments to the original callback if and as needed\n        </li>\n       </ul>\n      </li>\n      <li>\n       after\n       <code>\n        real_ RSA_generate_key()\n       </code>\n       clean up the allocated struct\n      </li>\n     </ul>\n    </li>\n   </ul>\n  </li>\n </ul>\n <p>\n  The above as Base64-encoded\n  <code>\n   .tar.xz\n  </code>\n  file for convenience:\n </p>\n <pre><code>/Td6WFoAAATm1rRGAgAhARwAAAAQz1jM4Cf/BCJdACOThvK+tJ2QH6+woi2u3zkiEOlUoV1cX9AZ\n+FC3A1WH7iUCMxAdurFVdxDDlniCFn58+KgLrhSGdLxvJiWTMjuOBhIYwKHirauzr5++28b5NTbw\n5OiW8LJArEPs+IWgu/EuT61aIKGLFonGy9apeCHMMEzdN9wUILkS5CNSFe5L1gKJCeVZ2PTWGqzA\nyu0nBvlpA0e7H81rA/msgoO1us3mbbQkkYuZ0lOkt5t5qn8H7c7oZe/gip3oyXmFlfJsscG2OmjK\nKmKWZbFLgb3EQuM0929MRGATHYCl5McORvugai2AeHPJRTLVTKrZC2rYj9buuEY5PH6ufW1b8NT1\nklXJkPU0gfOhGsEVcYQUMmp56aXGqzp6kq6xhAcIH+U+oEbbZBAC9QSSyFMH40nmRrPUOfIHnwhn\no/QclEtbierPsRwJMLjXS5uuz7IP1zxdOtshXJUDfmkXhj7/AIOCoLJ1PTWOIW4wq54yFSokdBUA\nlbzUk/VluIqyIx0D81HMRU2qJuptH2c28ij92+c7nHcH7M+WncwXoUPSZL2M31SUvS7DsFQkgqbM\nbeWSW2XgnV9vSKGomuCUY5vT671UD7hYddEuoR+vtJdEnEXENHfIu6rmK/3Zg9UwzYrHIMvkxm9B\nl1rxP+4C3x3Sy4qBzBup44Q7p62bVMG3CiSD2ZCkktQgeQFyPklGJLw3KriMexMoLc4eSA0EwfhU\nrr33b6n5uW3JN3pJ8IfwRW+KXS+DI0wnroLCGHdwzfXDhFPSMTaeFL4oICzQoX6gyPjLWRPciwZR\ng/2fZp9xA25j/6YP1M8i8eUcckB3Z2ispYtTsDa+D2osEcK4JAtHaDCJ/6gH3wSIJh3Dx5upaHz1\n0wQDQkS4T4O3Igf7B4wigAHWSHIih8Cl9bN8L36S5ZC58o3VeMgsLpLUkcRhf0bl6dhD113rJkqO\nG5GTlyp13YB7U2pynt9EY4TfVqCj7NvEAXHpt67MmNSqwl4c6Eslm/XplS0gTzKbP1tZo70AvkYO\noks0eYGhmE6HmcwwolqNJ3UQWkmPeUrBA5WHILHDvS3fhZkuoRgSJ+swyez8oKtOo5Y6sxGH1yDH\n0Bt5SeDmk6wErTqUb+YTDKQw1wMzY3DdeUSOny6PJumC/D9HBwmIehhDB7YxMVaQ2jcW02//bngq\nJ+zcjmBbjvKhMSOcCBVAPD7EAYyB6uerSAg4DrpsUkyYAw8+49lYe6STGKpy8OOt4OXah6WnG8/E\nGsbYlHm1RfJuMIgfYRU0+O+//xipV/q5EF/FzaQoDYuV2mPsx6TvYAganEUh78E4P9+GXBC8FsPE\nZjUrahpKmyLFm9zVmN0l3BYa20EpXmujuePO/51T3TZlxgcf5fjV87vF7BBmj8vcaVe+U02IcB1M\nZ6OAl1cAAAAAtSETkCuEMZwAAb4IgFAAAJJ1AFKxxGf7AgAAAAAEWVo=\n</code></pre>\n <hr/>\n <h3>\n  Telling\n  <code>\n   ld.so\n  </code>\n  to preload the wrapper\n  <code>\n   .so\n  </code>\n </h3>\n <p>\n  Bash and some other shells will be contend to do it with:\n </p>\n <pre><code>LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so ./your_binary\n</code></pre>\n <p>\n  but the more portable way is:\n </p>\n <pre><code>env LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so ./your_binary\n</code></pre>\n <p>\n  which uses\n  <code>\n   /usr/bin/env\n  </code>\n  -- instead of relying on a shell-builtin facility 00 to set the environment variable for a single invocation.\n </p>\n <p>\n  Obviously you could also at the prompt (\n  <code>\n   $\n  </code>\n  signifies it!) to:\n </p>\n <pre><code>$ export LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so\n$ ./your_binary\n</code></pre>\n <p>\n  or on some less comfortable (or older) shells:\n </p>\n <pre><code>$ LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so\n$ export LD_PRELOAD\n$ ./your_binary\n</code></pre>\n <p>\n  Last, but not least, you could create a little wrapper script, which we'll name\n  <code>\n   your_binary.sh\n  </code>\n  based on\n  <code>\n   your_binary\n  </code>\n  :\n </p>\n <pre><code>#!/usr/bin/env bash\nexport LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so\nexec \"${0%.sh}\" \"$@\"\n</code></pre>\n <ul>\n  <li>\n   <code>\n    #!/usr/bin/env bash\n   </code>\n   is the most portable hashbang, compared to hardcoding the path to a particular\n   <code>\n    bash\n   </code>\n   binary\n  </li>\n  <li>\n   <code>\n    export LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so\n   </code>\n   exports\n   <code>\n    LD_PRELOAD\n   </code>\n   as environment variable with the shown value\n  </li>\n  <li>\n   <code>\n    exec \"${0%.sh}\" \"$@\"\n   </code>\n   :\n   <ul>\n    <li>\n     <code>\n      \"${0%.sh}\"\n     </code>\n     strips the\n     <code>\n      .sh\n     </code>\n     suffix, yielding the name without it\n    </li>\n    <li>\n     <code>\n      \"$@\"\n     </code>\n     expanding to the quoted arguments passed to our script (e.g.\n     <code>\n      \"$1\" \"$2\"\n     </code>\n     ...)\n    </li>\n    <li>\n     <code>\n      exec\n     </code>\n     isn't strictly necessary here, but I prefer it for these small wrapper scripts; it replaces the current shell with the given command\n    </li>\n   </ul>\n  </li>\n </ul>\n</div>\n</body></html>",
            "votes": "0",
            "user": "2 revs0xC0000022L",
            "time": "Jan 18, 2023 at 10:23",
            "is_accepted": false,
            "comments": []
        }
    ]
}