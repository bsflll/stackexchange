{
    "title": "Strange or encrypted ipcam firmware",
    "link": "https://reverseengineering.stackexchange.com/questions/18519/strange-or-encrypted-ipcam-firmware",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm trying to extract an IP camera firmware. I am searching for a sleeping service that could be a major threat. According to\n  <code>\n   nmap\n  </code>\n  there are no running services such as telnet, SSH, FTP or similar; there are only few open ports such as HTTP, RSTP and\n  <code>\n   unknown\n  </code>\n  .\nThe firmware is\n  <a href=\"https://www.jovision.de/images/Firmware/Kamera%20und%20NVR/JVS-N5FL-DW/Update1-HI3516CS-WM-7601-v2.2.5608-20171109.zip\" rel=\"nofollow noreferrer\">\n   jvs3516cs-7601.bin\n  </a>\n  from Jovision (my ipcam is a clone) and it comes from the German branch of the company.\nI've tried all the usual steps for the analysis but have not had much success. I've installed all the usual firmware analysis tools (lzmao, squash, cpio, cramfs) and tried to extract the firmware with,\n  <code>\n   gzip\n  </code>\n  ,\n  <code>\n   unzip\n  </code>\n  ,\n  <code>\n   7z\n  </code>\n  and\n  <code>\n   binwalk\n  </code>\n  with no luck.\n </p>\n <pre><code># binwalk -Bv jvs3516cs-7601.bin\n\nScan Time:     2018-06-13 17:52:52\nTarget File:   /root/jvs3516cs-7601.bin\nMD5 Checksum:  8903156ca04081c393e16d6dff1580a0\nSignatures:    344\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n\n# binwalk -EJ jvs3516cs-7601.bin\n\nDECIMAL       HEXADECIMAL     ENTROPY\n--------------------------------------------------------------------------------\n0             0x0             Falling entropy edge (0.316584)\n270336        0x42000         Rising entropy edge (0.993798)\n1904640       0x1D1000        Falling entropy edge (0.724715)\n2031616       0x1F0000        Rising entropy edge (0.993043)\n7753728       0x765000        Falling entropy edge (0.362255)\n\nEntropy Exception: 'float' object cannot be interpreted as an integer\n\n\n\n\n# xxd -a jvs3516cs-7601.bin | head\n00000000: 5c1b 44f5 50ef dbfa 50ef dbfa 50ef dbfa  \\.D.P...P...P...\n00000010: 50ef dbfa 50ef dbfa 50ef dbfa 50ef dbfa  P...P...P...P...\n00000020: 040c c49f e40c c49f 440b c49f 240b c49f  ........D...$...\n00000030: 840b c49f 640a c49f c40a c49f 3c49 700d  ....d.......<Ip.\n00000040: 441f 473f 441f 440e 441f 441f b91f 441f  D.G?D.D.D.D...D.\n00000050: 401f 473f 2a2f 2c1f 441f 441f b91f 441f  @.G?*/,.D.D...D.\n00000060: 4c1f 473f 441f 440d 441f 441f b91f 441f  L.G?D.D.D.D...D.\n00000070: 481f 473f 273f 381f 441f 441f b91f 441f  H.G?'?8.D.D...D.\n00000080: 541f 473f 441f 440e 441f 441f b91f 441f  T.G?D.D.D.D...D.\n00000090: 501f 473f 2a2f 2c1f 441f 441f b91f 441f  P.G?*/,.D.D...D\n\n\n# fdisk -l jvs3516cs-7601.bin\nDisk jvs3516cs-7601.bin: 7,4 MiB, 7798784 bytes, 15232 sectors\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\n</code></pre>\n <p>\n  Is there anyone with better ideas then mine?\nThanks in advance.\n </p>\n <p>\n  PS There's also a jvs3516cs-7601-ver.bin whit inside:\n </p>\n <pre><code>#####################3\n#file format:\n#module=name, the name want to update. such as boot,kernel,fs,config ...\n#ver=3, version of the module\n#offset=0, offset in the file\n#size=0x100000, size in byte\n#dev=/dev/mtdblock/0, dev used to update\n#\n\nmodule=uboot\nver=20\noffset=0\nsize=0x40000\ndev=/dev/mtdblock0\n\nmodule=kernel\nver=3\noffset=0x40000\nsize=0x1B0000\ndev=/dev/mtdblock1\n\nmodule=fs\nver=5608\noffset=0x1F0000\nsize=0x580000\ndev=/dev/mtdblock2\n\nproduct=JVS-HI3516CS-7601\nfileSize=0x770000\n\nchecksum=0x4b0163fa\n</code></pre>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 1,
    "views": "1k",
    "tags": [
        "firmware"
    ],
    "user": "Cristian Alberti",
    "time": "Jun 13, 2018 at 18:32",
    "comments": [
        {
            "user": "julian",
            "text": "<html><body><span class=\"comment-copy\">\n share the file or a link to where you downloaded it from\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Cristian Alberti",
            "text": "<html><body><span class=\"comment-copy\">\n Here it is:\n <a href=\"https://www.jovision.de/images/Firmware/Kamera%20und%20NVR/JVS-N5FL-DW/Update1-HI3516CS-WM-7601-v2.2.5608-20171109.zip\" rel=\"nofollow noreferrer\">\n  jovision.de/images/Firmware/Kamera%20und%20NVR/JVS-N5FL-DW/â€¦\n </a>\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Now I don't have the time to help you\n  <em>\n   all the way\n  </em>\n  , but I believe I can get you started. Let's think like some company trying to obfuscate something from the layperson, right? The first choice is usually bitwise\n  <code>\n   xor\n  </code>\n  .\n </p>\n <p>\n  We know the offsets of the bits and pieces already, thanks to\n  <code>\n   jvs3516cs-7601-ver.bin\n  </code>\n  .\n </p>\n <p>\n  Now looking at the\n  <code>\n   jvs3516cs-7601.bin\n  </code>\n  in a hex editor turns up a fascinating pattern:\n  <code>\n   44 1F\n  </code>\n  (or\n  <code>\n   D.\n  </code>\n  ). Typically we'd expect to see quite a few\n  <code>\n   00\n  </code>\n  occurrences on data with this entropy (start of file), but instead we see that\n  <code>\n   D.\n  </code>\n  pattern.\n </p>\n <p>\n  Don't ask me if there is some connection to the name of a developer or something like that, but we now have a working theory. The\n  <code>\n   .bin\n  </code>\n  file may have been xored word-wise with\n  <code>\n   0x1F44\n  </code>\n  (or\n  <code>\n   0x441F\n  </code>\n  if it's Big Endian). Excerpt:\n </p>\n <pre><code>5C 1B 44 F5 50 EF DB FA 50 EF DB FA 50 EF DB FA\n50 EF DB FA 50 EF DB FA 50 EF DB FA 50 EF DB FA\n04 0C C4 9F E4 0C C4 9F 44 0B C4 9F 24 0B C4 9F\n84 0B C4 9F 64 0A C4 9F C4 0A C4 9F 3C 49 70 0D\n44 1F 47 3F 44 1F 44 0E 44 1F 44 1F B9 1F 44 1F\n40 1F 47 3F 2A 2F 2C 1F 44 1F 44 1F B9 1F 44 1F\n4C 1F 47 3F 44 1F 44 0D 44 1F 44 1F B9 1F 44 1F\n48 1F 47 3F 27 3F 38 1F 44 1F 44 1F B9 1F 44 1F\n54 1F 47 3F 44 1F 44 0E 44 1F 44 1F B9 1F 44 1F\n50 1F 47 3F 2A 2F 2C 1F 44 1F 44 1F B9 1F 44 1F\n64 1F 47 3F 44 1F 44 04 44 1F 44 1F B9 1F 44 1F\n60 1F 47 3F A5 5F 38 1F 44 1F 44 1F B9 1F 44 1F\n6C 1F 47 3F 54 1F 44 1F 44 1F 44 1F B9 1F 44 1F\nAC 1F 47 3F 4B 1F 44 1F 44 1F 44 1F 44 1F 59 1F\n6C 1F 47 3F 44 1F 44 1F 44 1F 44 1F 61 37 44 1F\n6C 1F 47 3F 44 1F 44 1F 44 1F 44 1F 41 4F 44 1F\n6C 1F 47 3F 45 1F 44 1F 44 1F 44 1F 41 4F 44 1F\n40 1F 44 0F EE 15 44 1F 44 1F 44 1F 19 1F 44 1F\n</code></pre>\n <p>\n  The following little Python script takes the knowledge from\n  <code>\n   jvs3516cs-7601-ver.bin\n  </code>\n  and places it into the\n  <code>\n   parts\n  </code>\n  variable (a list of triplets/tuples). It then opens the input file (no sophisticated error or path handling here, so run from same folder as the\n  <code>\n   jvs3516cs-7601.bin\n  </code>\n  is located in) and reads the parts one by one and then dumps them into an output file as per tuple contents:\n </p>\n <pre><code># Tested with Python 2.7!\nimport io\nimport struct\n\nparts = [(\"uboot.img\", 0, 0x40000), (\"kernel.img\", 0x40000, 0x1B0000), (\"fs.img\", 0x1F0000, 0x580000)]\ninpname = \"jvs3516cs-7601.bin\"\n\nwith io.open(inpname, \"rb\") as infile:\n    for nm, offset, size in parts:\n        infile.seek(offset)\n        x = infile.read(size)\n        assert len(x) / 2, \"%s has odd length.\" % (nm)\n        newx = \"\"\n        for woffs in range(0, len(x), 2):\n            word = struct.unpack(\"H\", x[woffs:woffs+2])\n            val = word[0] ^ 0x1F44 # the magic xor value we assume based on \"D.\"\n            newx += struct.pack(\"H\", val)\n        assert len(newx) == len(x), \"Input and output size differ.\"\n        assert len(newx) == size, \"Output size (%d) for %s differs from expected value %d.\" % (len(newx), nm, size)\n        with io.open(nm, \"wb\") as outf:\n            outf.write(newx)\n</code></pre>\n <p>\n  The outcome are three files that after a cursory look, seem like the real deal. I.e. the deobfuscated uImage, kernel image and file system image.\n </p>\n <p>\n  Once we have those files, using\n  <code>\n   file\n  </code>\n  on the shell gives something like this:\n </p>\n <pre><code>$ file *.img\nfs.img:     Squashfs filesystem, little endian, version 4.0, 5722880 bytes, 614 inodes, blocksize: 262144 bytes, created: Fri Oct 20 10:32:21 2017\nkernel.img: u-boot legacy uImage, Linux-3.0.8, Linux/ARM, OS Kernel Image (Not compressed), 1644712 bytes, Thu Nov  5 07:18:50 2015, Load Address: 0x80008000, Entry Point: 0x80008000, Header CRC: 0xAAC0A340, Data CRC: 0x1FDABC77\nuboot.img:  data\n</code></pre>\n <p>\n  I am unsure why it doesn't recognize the U-Boot image. But it might just as well be a proprietary loader replacing what was formerly a U-Boot image.\n </p>\n <p>\n  If you create a folder\n  <code>\n   rootfs\n  </code>\n  and have the (Debian) package\n  <code>\n   squashfuse\n  </code>\n  installed, you can run\n  <code>\n   sudo mount -t squashfs fs.img rootfs\n  </code>\n  to mount the SquashFS image. The outcome will look like this:\n </p>\n <pre><code>$ ls -l rootfs/\ntotal 2\ndrwxrwxrwx 2 root root 1386 2017-09-30 08:11 bin\ndrwxrwxrwx 2 1001 1001    3 2006-04-19 06:05 boot\ndrwxrwxrwx 2 1001 1001    3 2017-06-30 05:57 dev\ndrwxrwxrwx 7 root root  259 2017-10-20 12:32 etc\ndrwxrwxrwx 5 root root  149 2017-09-30 08:11 home\nlrwxrwxrwx 1 1001 1001    9 2013-09-23 12:46 init -> sbin/init\ndrwxrwxrwx 2 1001 1001  650 2014-05-04 08:36 lib\nlrwxrwxrwx 1 1001 1001   11 2013-09-23 12:46 linuxrc -> bin/busybox\ndrwxrwxrwx 2 1001 1001    3 2006-04-19 06:04 lost+found\n-rwxrwxrwx 1 1001 1001 1341 2011-04-21 05:40 mkimg.rootfs\n-rwxrwxrwx 1 1001 1001  431 2011-04-21 05:40 mknod_console\ndrwxrwxrwx 2 1001 1001    3 2006-04-19 06:05 mnt\ndrwxrwxrwx 2 1001 1001    3 2008-05-21 11:17 nfsroot\ndrwxrwxrwx 2 1001 1001    3 2006-04-19 06:04 opt\ndrwxrwxrwx 2 1001 1001    3 2006-04-19 06:04 proc\ndrwxrwxrwx 7 root root  143 2017-09-30 08:11 progs\ndrwxrwxrwx 2 1001 1001   31 2013-08-22 03:35 root\ndrwxrwxrwx 2 1001 1001  878 2017-10-20 12:32 sbin\ndrwxrwxrwx 2 1001 1001    3 2006-04-19 06:05 share\ndrwxrwxrwx 2 1001 1001    3 2006-04-19 06:04 sys\ndrwxrwxrwx 2 1001 1001    3 2006-04-19 10:46 tmp\ndrwxrwxrwx 6 1001 1001   62 2013-08-22 03:35 usr\ndrwxrwxrwx 3 1001 1001   26 2013-08-22 03:35 var\nlrwxrwxrwx 1 root root   10 2017-10-20 12:32 wifi -> /home/wifi\n</code></pre>\n <p>\n  So it seems that the SquashFS is readable and sound. At least that part has been verified.\n </p>\n <p>\n  Now, as I mentioned at the beginning, I don't have the time to verify my findings so far, but my findings will give you a clue of the mindset the developers of the company where in and what else they may have in store. It looks like the real deal, but I may have overlooked some details. Either way this should get you started.\n </p>\n</div>\n</body></html>",
            "votes": "7",
            "user": "0xC0000022L",
            "time": "Jun 13, 2018 at 21:53",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Cristian Alberti",
                    "text": "<span class=\"comment-copy\">Ok I've got all three .img files and I'm going to analyze them. Thanks a lot: this script is the Open Sesame I was looking for.</span>",
                    "time": null
                },
                {
                    "user": "Cristian Alberti",
                    "text": "<span class=\"comment-copy\">The <code>kernel.img</code> was binwalked (so I've found that's a <code>uImage fs</code>) and was converted with <code>dd if=kernel.img bs=64 skip=1 of=kernel.custom </code>. Another way could be the <code>extract-uimage.sh script</code>.</span>",
                    "time": null
                }
            ]
        }
    ]
}