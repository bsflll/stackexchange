{
    "title": "ida_hexrays.lvar_t.stk.get_stkoff() incorrect Â± 0x10",
    "link": "https://reverseengineering.stackexchange.com/questions/27507/ida-hexrays-lvar-t-stk-get-stkoff-incorrect-%c2%b1-0x10",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  When using the stack offset for a variable obtained via\n  <code>\n   ida_hexrays.lvar_t.stk.get_stkoff()\n  </code>\n  or\n  <code>\n   ida_hexrays.vdloc_t.stkoff()\n  </code>\n  the results vary between \"correct\", and 8 or 16 bytes out as measured either manually or as compared to the results obtained from:\n </p>\n <pre><code>id = idc.get_frame_id(here())\nfor member in idautils.StructMembers(id):\n    offset, name, size = member\n</code></pre>\n <p>\n  The incorrect offsets are sourced from:\n </p>\n <pre><code>func = idaapi.get_func(ea)\nvu = idaapi.open_pseudocode(func.start_ea, 0)\n[n.get_stkoff() for n in vu.cfunc.lvars if n.is_stk_var()]\n</code></pre>\n <p>\n  <em>\n   [edit]: the difference appears to be caused by the pseudo-code vu reporting offsets relative to the minimal SPD, whilst everything else uses the post-prologue SPD (code beneath)\n  </em>\n </p>\n <pre><code>def GetPseudoStackOffsetCorrection(funcea):\n    func = ida_funcs.get_func(funcea)\n    return func.frsize + func.frregs + idc.get_spd(idc.get_min_spd_ea(func.start_ea))\n</code></pre>\n <p>\n  <em>\n   [edit 2]: this alternate method works\n   <strong>\n    sometimes\n   </strong>\n   . it functions by looking at the insn located at\n   <code>\n    lvar_t.defea\n   </code>\n   (assumedly \"defined at ea\") and calculating from there.  However 10% of the time\n   <code>\n    lvar.defea\n   </code>\n   points at a conditional jmp, so again -- very kludgy\n  </em>\n </p>\n <pre><code>def get_stkoff_from_lvar(lvar, debug=1):\n    ea = idc.get_item_head(lvar.defea)\n    func = ida_funcs.get_func(ea)\n    if not func:\n        return idc.BADADDR\n    \n    for n in range(2):\n        if idc.get_operand_type(ea, n) == idc.o_displ:\n            offset = idc.get_operand_value(ea, n) + func.frsize - func.fpd\n\n            if debug:\n                lvar_name = lvar.name\n                sid = idc.get_frame_id(func.start_ea)\n                frame_name = idc.get_member_name(sid, offset)\n                print(\"[debug] offset:0x{:x}, lvar_name:{}, frame_name:{}\"\n                        .format(offset, lvar_name, frame_name))\n\n            return offset \n</code></pre>\n <p>\n  <em>\n   [edit]: kludges aside (which I would prefer not to use) I have issues with my\n  </em>\n  [...] \"rename, retype and remap\" (with regex) package, which I recently noted does not update the \"stack\" (visible in assembly) names when calling\n  <code>\n   vu.rename_lvar\n  </code>\n  as would normally happen when performing a rename via\n  <kbd>\n   N\n  </kbd>\n </p>\n <p>\n  Without an accurate offset, there is no way for the code to rename the corresponding stack variable\n  <code>\n   var_18\n  </code>\n  when renaming the pseudo-code variable\n  <code>\n   v1\n  </code>\n  (for example).\n </p>\n <p>\n  Any solution to this general problem is welcome, though preferentially one that allows the correct stack location of pseudo-code variables would be best as I will shortly be attempting \"watch-variables\" via flare-emu.\n </p>\n <p>\n  These are some results from a test function written to compare the conflicting results I have been receiving, and to confirm to myself that there is no magic \"just deduct func.frregs\" type answer.\n </p>\n <p>\n  Function 1.\n </p>\n <pre><code>func.flags                  : FUNC_FRAME | FUNC_PURGED_OK | FUNC_SP_READY\nfunc.frregs                 :   8\nfunc.frsize                 :  c0\nfunc.fpd                    :  a0\nida_frame.frame_off_retaddr :  c8\nida_frame.frame_off_lvars   :   0\nida_frame.frame_off_args    :  d0\nida_frame.frame_off_savregs :  c0\n\nname           lvar_offset1 stk_offset \n-------------- ------------ ---------- \nrange          0x30         0x28       \nguide          0x38         0x30       \nImageBase      0x58         0x50       \n_stack_padding 0xd8         0xd0    \n</code></pre>\n <p>\n  Function 2\n </p>\n <pre><code>func.flags                  : FUNC_FRAME | FUNC_PURGED_OK | FUNC_SP_READY\nfunc.frregs                 :   8\nfunc.frsize                 : 1c0\nfunc.fpd                    : 190\nida_frame.frame_off_retaddr : 1c8\nida_frame.frame_off_lvars   :   0\nida_frame.frame_off_args    : 1d0\nida_frame.frame_off_savregs : 1c0\n\nname                      lvar_offset1 stk_offset \n------------------------- ------------ ---------- \nlpTopLevelExceptionFilter 0x50         0x40       \nLibFileName               0x88         0x78       \nHandle                    0xc8         0xb8       \nlpProcName                0x110        0x100      \nhObject                   0x198        0x188      \nhModule                   0x1a0        0x190      \n</code></pre>\n <p>\n  Function 3\n </p>\n <pre><code>func.flags                  : FUNC_FRAME | FUNC_PURGED_OK | FUNC_SP_READY\nfunc.frregs                 :   8\nfunc.frsize                 :  40\nfunc.fpd                    :  20\nida_frame.frame_off_retaddr :  48\nida_frame.frame_off_lvars   :   0\nida_frame.frame_off_args    :  50\nida_frame.frame_off_savregs :  40\n\nname   lvar_offset1 stk_offset \n------ ------------ ---------- \naccum1 0x20         0x20       \naccum2 0x2c         0x2c \n</code></pre>\n <p>\n  I can provide the test code if required, though it's not small.\n </p>\n <p>\n  <em>\n   [edit: test code attached, warning: not pretty]\n  </em>\n </p>\n <pre><code># test code: \n#     sync_lvars_to_stk(func_ea)\n\ndef get_func_flag_names(f):\n    return [x for x in [k for k in dir(idc) \n            if k.startswith('FUNC_')] \n            if f.flags & getattr(idc, x)]\n\ndef _get_vu(ea, vu):\n    if vu: return vu\n    return idaapi.open_pseudocode(idaapi.get_func(ea).start_ea, 0)\n\ndef get_lvars(ea, vu=None):\n    vu = _get_vu(ea, vu)\n    return [n.get_stkoff() for n in vu.cfunc.lvars if n.is_stk_var()]\n\ndef dump_stkvars(ea=None, iteratee=None):\n    def get_member_tinfo(sid, offset):\n        s = ida_struct.get_struc(sid)\n        m = ida_struct.get_member(s, offset)\n        tif = ida_typeinf.tinfo_t()\n        try:\n            if ida_struct.get_member_tinfo(tif, m):\n                return tif\n        except TypeError:\n            pass\n\n    results = []\n    sid = idc.get_frame_id(ea)\n    for member in idautils.StructMembers(sid):\n        o = AttrDict()\n        o.offset, o.name, o.size = member\n        o.mid     = idc.get_member_id(sid,    o.offset)\n        o.name    = idc.get_member_name(sid,  o.offset)\n        o.size    = idc.get_member_size(sid,  o.offset)\n        o.flags   = idc.get_member_flag(sid,  o.offset)\n        tif       = get_member_tinfo(sid,     o.offset)\n        o.tifname = str(tif) if tif else ''\n        o.sid     = sid\n        if callable(iteratee): iteratee(o)\n        results.append(o)\n    return results\n\ndef indexBy(o, key):\n    r = {}\n    for x in o:\n        r[x[key]] = x\n    return r\n\ndef sync_lvars_to_stk(ea, vu=None):\n    vu = _get_vu(ea, vu)\n    func = idaapi.get_func(ea)\n    print(\"\n{:28}: {}\n{:28}: {:3x}\n{:28}: {:3x}\n{:28}: {:3x}\n{:28}: {:3x}\n{:28}: {:3x}\n{:28}: {:3x}\n{:28}: {:3x}\n\"\n            .format(\n                \"func.flags\",                  \" | \".join(get_func_flag_names(func)),\n                \"func.frregs\",                 func.frregs,\n                \"func.frsize\",                 func.frsize,\n                \"func.fpd\",                    func.fpd,\n                \"ida_frame.frame_off_retaddr\", ida_frame.frame_off_retaddr(func),\n                \"ida_frame.frame_off_lvars\",   ida_frame.frame_off_lvars(func),\n                \"ida_frame.frame_off_args\",    ida_frame.frame_off_args(func),\n                \"ida_frame.frame_off_savregs\", ida_frame.frame_off_savregs(func),\n                ))\n\n    stkvars = indexBy(dump_stkvars(ea), 'name')\n    lvars = []\n    if vu and func:\n        stk_lvars = [(n.name, n.tif.get_size(), \n            n.location.stkoff(),\n            ) for n in vu.cfunc.lvars if n.location.is_stkoff()]\n\n        for name, size, offset in stk_lvars:\n            o = AttrDict()\n            o.update({\n                'name': name,\n                'size': size,\n                'lvar_offset': offset,\n            })\n            lvars.append(o)\n    lvars = indexBy(lvars, 'name')\n\n    lvar_names = lvars.keys()\n    for name in lvar_names:\n        if name in stkvars:\n            print({\n                'name': name,\n                'lvar_offset': lvars[name].lvar_offset,\n                'stk_offset': stkvars[name].offset,\n            })\n\nclass AttrDict(dict):\n    def __init__(self, *args, **kwargs):\n        super(AttrDict, self).__init__(*args, **kwargs)\n        self.__dict__ = self\n\n</code></pre>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 2,
    "views": "257",
    "tags": [
        "ida",
        "idapython"
    ],
    "user": "Orwellophile",
    "time": "Apr 21, 2021 at 4:37",
    "comments": [
        {
            "user": "R4444",
            "text": "<html><body><span class=\"comment-copy\">\n can you post function prologues (in assembly) of these three functions?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Orwellophile",
            "text": "<html><body><span class=\"comment-copy\">\n @R4444 all three are of the form\n <code>\n  push rbp\n </code>\n <code>\n  sub rsp, 1C0h\n </code>\n <code>\n  lea rbp, [rsp + 30h]\n </code>\n , do you want specific values? That example was from the second (most wayward) example, the working one is rsp - 30h, rbp +20h and and the \"off by 8\" is\n <code>\n  push rbp; sub rsp, 0C0h; lea rbp, [rsp+20h]\n </code>\n .  And yes, it was not lost on me that there is a certain co-incidental correlation with the stack size and the offset discrepancy.   I can (if required) prepare a nasm-viable or ida patch with a sample function.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Orwellophile",
            "text": "<html><body><span class=\"comment-copy\">\n It is probably also worth mentioning that IDA incorrectly defines these wayward functions as \"FAR\" (which I have corrected) but I guess that says something about how it's viewing them.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "R4444",
            "text": "<html><body><span class=\"comment-copy\">\n the reason I asked this because I observed such differences when rbp or rsp relative addressing is used. in former case the offsets get measured from frame base (after \"pushing\" rbp) and later case, they get measured from return address.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Orwellophile",
            "text": "<html><body><span class=\"comment-copy\">\n @R4444 I believe I have tracked the cause -- the function that is out by 8 has a single\n <code>\n  push rcx\n </code>\n ..\n <code>\n  pop rcx\n </code>\n and the  out by 16 has two pushes.  So it would seem the idaapi.open_pseudocode.vu calculation for stack offset is relative to the minimum SPD whilst everything else operates based on the post-prologue SPD.  Unfortunately knowing this will not make for the most robust fix.  There must be an alternative for locating the stack offsets of pseudo-code variables (e.g. you've probably noticed that if you delete a variable name in Hexrays it temporarily takes on the name of the stack var).\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I just found what appears to be the official version of the adjustment function for the transmigration of worthless min-spd based offsets into heaven sent frame based offsets.\n </p>\n <h3>\n  cfunc.get_stkoff_delta()\n </h3>\n <p>\n  <em>\n   Possible implementation:\n  </em>\n </p>\n <pre><code>def GetMinSpdAdjustment(funcea):\n    func = ida_funcs.get_func(funcea)\n    return 0 - (func.frsize + func.frregs + idc.get_spd(idc.get_min_spd_ea(func.start_ea)))\n</code></pre>\n <p>\n  <em>\n   Example usage:\n  </em>\n </p>\n <pre><code>vu = idaapi.open_pseudocode(funcea, 0)\nvu.cfunc.lvars[10].get_stkoff() - vu.cfunc.get_stkoff_delta()\n</code></pre>\n <p>\n  <em>\n   Complete example:\n  </em>\n </p>\n <pre><code>\n# call rename_lvar(old, new, ea)\n\ndef get_pseudocode_vu(ea, vu):\n    if vu:\n        return vu\n    \n    return idaapi.open_pseudocode(ea, 0)\n\ndef label_stkvar(offset, name, ea=None, vu=None):\n    sid = idc.get_frame_id(ea)\n    old_name = idc.get_member_name(sid, offset)\n    if old_name:\n        if old_name == name:\n            return old_name\n\n        if idc.set_member_name(sid, offset, name):\n            return old_name\n\ndef rename_lvar(old, new, ea, uniq=0, vu=None):\n    def make_unique_name(name, taken):\n        if name not in taken:\n            return name\n        fmt = \"%s_%%i\" % name\n        for i in range(3, 1<<10):\n            name = fmt % i\n            if name not in taken:\n                return name\n\n    old = old.strip()\n    new = new.strip()\n    if old == new:\n        return True\n\n    vu = get_pseudocode_vu(ea, vu)\n    names = [n.name for n in vu.cfunc.lvars]\n\n    if new in names:\n        if uniq:\n            return False\n\n        new = make_unique_name(new, names)\n\n    lvars = [n for n in vu.cfunc.lvars if n.name == old]\n    if lvars:\n        lvar = lvars[0]\n        if lvar.is_stk_var():\n            offset = lvar.get_stkoff() - vu.cfunc.get_stkoff_delta()\n            old_name = label_stkvar(offset, new, ea=ea, vu=vu)\n\n        return vu.rename_lvar(lvar, new, 1)\n</code></pre>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Orwellophile",
            "time": "Apr 21, 2021 at 11:49",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Based on the information we discuss in the comments, I have an idea about supporting such cases. You can use\n  <code>\n   idc.get_frame_regs_size(ea)\n  </code>\n  to adjust the offset. Thus can do something like:\n </p>\n <pre><code>adjust_offset = idc.get_frame_regs_size(ea)\n[n.get_stkoff()+-adjust_offset for n in vu.cfunc.lvars if n.is_stk_var()]\n</code></pre>\n <p>\n  according to your implementation.\n </p>\n <p>\n  You might as well want to consider other endpoints like -\n </p>\n <pre><code>print(idc.get_frame_lvar_size(ea))\nprint(idc.get_frame_args_size(ea))\nprint(idc.get_frame_size(ea))\n</code></pre>\n <p>\n  to experiment more about adjusting the offset.\n </p>\n <p>\n  I am sure there has to be a robust solution, and this may not be perfect (I believe this should work in theory). But, give it a try.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "R4444",
            "time": "Apr 20, 2021 at 23:08",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Orwellophile",
                    "text": "<span class=\"comment-copy\">Sorry, I shouldn't have left that code in.  That was something I tried in my previously mentioned attempt to find a \"rule of thumb\" fix, and also the reason I ended up writing the complete (with pretty columns) testing function which disproved this theory by showing that the difference can be 16 or it can be 0 -- with the same (relative to each other) values of the various frame sizes.  I believe there is some misleading documentation, get_stkoff says: \"Get offset of the varialbe in the stack frame.\"  which may better read as <code>lvars_t.find_stkvar</code>: offset from the minimal sp (C++: sval_t)</span>",
                    "time": null
                },
                {
                    "user": "Orwellophile",
                    "text": "<span class=\"comment-copy\">Also whilst searching through ida_hexrays.py, I noted that <code>block_chains_t</code>, <code>mop_pair_t</code>, <code>qvector_history_t</code> and <code>vivl_t</code> also have <code>get_stkoff</code> methods, which may (or may not) return min-spd based results.  It's quite alarming really.    I could use <code>GetPseudoStackOffsetCorrection</code> as added to my Q in later edit, but I feel that to be very kludgy.  If there were simply a way to precisely emulate &lt;kbd&gt;N&lt;/kbd&gt; and rename stack and pseudo-code vars at the same time, it would at least allow cross-referencing to be sure.  Understand that I am running mass renames across a literal thousand func</span>",
                    "time": null
                },
                {
                    "user": "R4444",
                    "text": "<span class=\"comment-copy\">i think that's a good observation. I too interesting to see a robust approach to solve this. upvoting for better reach. there's one more way - <code>stack_size = idc.get_func_attr(ea, idc.FUNCATTR_FRSIZE);[-stack_size + mem.get_soff() for mem in ida_struct.get_struc(idc.get_frame_id(ea)).members]</code> but I guess this is equivalent to what you are currently doing</span>",
                    "time": null
                },
                {
                    "user": "Orwellophile",
                    "text": "<span class=\"comment-copy\">rewriting that (for added information) as <code>[(name, -stack_size + offset) for offset, name, size in idautils.StructMembers(idc.get_frame_id(ea))]</code> which while being an excellent example of extracting the frame-relative position of stack variables and better than my own <code>stkzero = ida_frame.frame_off_retaddr(func) - 8</code> (what was I thinking) won't solve the problem.  But I'll be using your line in my StackInfo function (generates a list and also a struct.unpack string for inspecting stack variables).</span>",
                    "time": null
                }
            ]
        }
    ]
}