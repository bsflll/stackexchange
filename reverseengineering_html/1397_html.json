{
    "title": "How can I reverse optimized integer division/modulo by constant operations?",
    "link": "https://reverseengineering.stackexchange.com/questions/1397/how-can-i-reverse-optimized-integer-division-modulo-by-constant-operations",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  When compiling a division or modulo by a constant, my compiler (LLVM GCC) generates a series of instructions that I don't understand.\n </p>\n <p>\n  When I compile the following minimal examples:\n </p>\n <pre><code>int mod7(int x) {\n    return x % 7;\n}\n\nint div7(int x) {\n    return x / 7;\n}\n</code></pre>\n <p>\n  The following code is generated:\n </p>\n <pre><code>_mod7:\n    push   rbp\n    mov    rbp,rsp\n\n    mov    ecx,0x92492493\n    mov    eax,edi\n    imul   ecx\n    add    edx,edi\n    mov    eax,edx\n    shr    eax,0x1f\n    sar    edx,0x2\n    add    edx,eax\n    imul   ecx,edx,0x7\n    mov    eax,edi\n    sub    eax,ecx\n\n    pop    rbp\n    ret    \n\n\n_div7:\n    push   rbp\n    mov    rbp,rsp\n\n    mov    ecx,0x92492493\n    mov    eax,edi\n    imul   ecx\n    add    edx,edi\n    mov    ecx,edx\n    shr    ecx,0x1f\n    sar    edx,0x2\n    mov    eax,edx\n    add    eax,ecx\n\n    pop    rbp\n    ret\n</code></pre>\n <ul>\n  <li>\n   How is this mathematically equivalent, and where do the constants come from?\n  </li>\n  <li>\n   What's the easiest way to turn the assembly back in to C (for arbitrary constants on the right-hand side)?\n  </li>\n  <li>\n   How could a tool, such as a decompiler or analysing disassembler, automate this process?\n  </li>\n </ul>\n</div>\n</body></html>",
    "votes": "37",
    "answers": 3,
    "views": "12k",
    "tags": [
        "disassembly",
        "static-analysis"
    ],
    "user": "Dougall",
    "time": "Mar 30, 2013 at 7:14",
    "comments": [
        {
            "user": "DCoder",
            "text": "<html><body><span class=\"comment-copy\">\n This is sometimes called\n <i>\n  reciprocal multiplication\n </i>\n . Here is a\n <a href=\"http://www.nynaeve.net/?p=115\" rel=\"nofollow noreferrer\">\n  short explanation\n </a>\n with links to more detailed resources. I've seen Hex-Rays digest this with no problems.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <h1>\n  First\n </h1>\n <p>\n  Unfortunately we don't seem to have MathJax turned on in this stackexchange so the math parts below are pretty horribly formatted. I'm also far from a mathematician so the notation may be off in some places.\n </p>\n <h1>\n  Understanding the magic number and code\n </h1>\n <p>\n  The goal of the code above is to rewrite a division into a multiplication because division takes more clock cycles than a multiplication. It's in the area of about twice as many cycles, depending very much on CPU. So we need to find a nice branchless way of doing that. If we branch we're very likely to lose to simply doing division.\n </p>\n <p>\n  One way is to simply realize that division is the same as multiplication with the inverse of the number, i.e\n  <img alt=\"\" src=\"https://i.sstatic.net/yhMdN.gif\"/>\n  . The problem is that\n  <img alt=\"\" src=\"https://i.sstatic.net/V3EXb.gif\"/>\n  is a pretty poor number to store as an integer. So we need to multiply both the divisor and dividend by some number. Since we're operating on 32-bit numbers and we get multiplication results in 64-bit numbers we get the best precision with\n  <img alt=\"\" src=\"https://i.sstatic.net/GAbp5.gif\"/>\n  and we also avoid overflow issues. So we basically get\n  <img alt=\"\" src=\"https://i.sstatic.net/66B6M.gif\"/>\n  . Now that fractional part is what causes us issues because it will cause rounding errors.\n </p>\n <p>\n  So let's try to formalize this:\n </p>\n <p>\n  <img alt=\"\" src=\"https://i.sstatic.net/CXkJ4.gif\"/>\n </p>\n <p>\n  Where\n  <img alt=\"\" src=\"https://i.sstatic.net/85yOF.gif\"/>\n  is our multiplicand, e.g\n  <img alt=\"\" src=\"https://i.sstatic.net/GKdkC.gif\"/>\n  , or really any number\n  <img alt=\"\" src=\"https://i.sstatic.net/4sVUA.gif\"/>\n  but\n  <img alt=\"\" src=\"https://i.sstatic.net/mb7TH.gif\"/>\n  works very well with our register sizes as we can simply discard the lower 32-bit register.\n  <img alt=\"\" src=\"https://i.sstatic.net/p5VNy.gif\"/>\n  is the number you must add to make\n  <img alt=\"\" src=\"https://i.sstatic.net/85yOF.gif\"/>\n  evenly divisible by\n  <img alt=\"\" src=\"https://i.sstatic.net/FObhE.gif\"/>\n  .\n  <img alt=\"\" src=\"https://i.sstatic.net/31LSW.gif\"/>\n  is the number we wish to divide.\n </p>\n <p>\n  We can rewrite the equation above, as\n </p>\n <p>\n  <img alt=\"\" src=\"https://i.sstatic.net/S56kc.gif\"/>\n </p>\n <p>\n  Which illustrates the point that we have our dividend\n  <img alt=\"\" src=\"https://i.sstatic.net/8dTDm.gif\"/>\n  divided by our divisor\n  <img alt=\"\" src=\"https://i.sstatic.net/7kJpl.gif\"/>\n  and then an error factor of\n  <img alt=\"\" src=\"https://i.sstatic.net/lKedW.gif\"/>\n  .\n </p>\n <p>\n  Studying our original equation of\n  <img alt=\"\" src=\"https://i.sstatic.net/ZP83c.gif\"/>\n  it's clear that we can affect very little.\n  <img alt=\"\" src=\"https://i.sstatic.net/QvBxq.gif\"/>\n  needs to be a power of 2, can't be too large or we risk an overflow and can't be too small as it has a direct negative effect on our error factor\n  <img alt=\"\" src=\"https://i.sstatic.net/W87D3.gif\"/>\n  .\n  <img alt=\"\" src=\"https://i.sstatic.net/J5UAz.gif\"/>\n  directly depends on\n  <img alt=\"\" src=\"https://i.sstatic.net/tFARj.gif\"/>\n  and\n  <img alt=\"\" src=\"https://i.sstatic.net/IS3SB.gif\"/>\n  .\n </p>\n <p>\n  So let's try\n  <img alt=\"\" src=\"https://i.sstatic.net/qAwQ9.gif\"/>\n  which gives a maximum error fraction of\n  <img alt=\"\" src=\"https://i.sstatic.net/W87D3.gif\"/>\n  with the maximum value of\n  <img alt=\"\" src=\"https://i.sstatic.net/boZtv.gif\"/>\n  being\n  <img alt=\"\" src=\"https://i.sstatic.net/Sppdl.gif\"/>\n  , so\n  <img alt=\"\" src=\"https://i.sstatic.net/5GbVt.gif\"/>\n  , unfortunately this is not less than\n  <img alt=\"\" src=\"https://i.sstatic.net/Q9RYV.gif\"/>\n  so we can get rounding errors.\n </p>\n <p>\n  We'll increase the exponent of\n  <img alt=\"\" src=\"https://i.sstatic.net/IAyRL.gif\"/>\n  to\n  <img alt=\"\" src=\"https://i.sstatic.net/yqG5j.gif\"/>\n  , which gives\n  <img alt=\"\" src=\"https://i.sstatic.net/SV70X.gif\"/>\n  , maximum error fraction\n  <img alt=\"\" src=\"https://i.sstatic.net/CN6ya.gif\"/>\n  which is less than\n  <img alt=\"\" src=\"https://i.sstatic.net/wOBpa.gif\"/>\n  . This means that our multiplicand is\n  <img alt=\"\" src=\"https://i.sstatic.net/vNO9f.gif\"/>\n  which is not less than or equal to the maximum signed value we can store in a 32-bit register (\n  <img alt=\"\" src=\"https://i.sstatic.net/up1Y5.gif\"/>\n  ). So we instead make the multiplicand\n  <img alt=\"\" src=\"https://i.sstatic.net/aaEyn.gif\"/>\n  . As a side note, thanks to the magic of two's complement when we subtract\n  <img alt=\"\" src=\"https://i.sstatic.net/vwBYh.gif\"/>\n  the number\n  <img alt=\"\" src=\"https://i.sstatic.net/jZA7P.gif\"/>\n  is\n  <img alt=\"\" src=\"https://i.sstatic.net/jBOeP.gif\"/>\n  which is\n  <img alt=\"\" src=\"https://i.sstatic.net/xwp6c.gif\"/>\n  when interpreted as an unsigned number. But we're doing signed arithmetic here. So we need to fix the final expression by adding\n  <img alt=\"\" src=\"https://i.sstatic.net/2xny2.gif\"/>\n  . This also only solves the problem for\n  <img alt=\"\" src=\"https://i.sstatic.net/PevID.gif\"/>\n  , for negative numbers we will be off by 1 so we need to add 1 if we have a negative number.\n </p>\n <p>\n  That's the explanation for the constant in the multiplication and how to arrive at it. Now let's look at the code:\n </p>\n <pre><code>; Load -1840700269\nmov    ecx,0x92492493\n\n; Load n\nmov    eax,edi\n\n; n * -1840700269\nimul   ecx\n\n; add n to compensate for 2^32 subtraction\nadd    edx,edi\n\n; check the sign bit of our result\nmov    ecx,edx\nshr    ecx,0x1f\n\n; divide by 2^2 to compensate for us using y=2^34 instead of 2^32\nsar    edx,0x2\n\nmov    eax,edx\n; add the value of the sign bit to the final result\nadd    eax,ecx\n</code></pre>\n <h1>\n  Calculating divisor from magic number and code\n </h1>\n <p>\n  I have not proven this mathematically, however if you want to recover the divisor from an assembly dump such as the one you showed we can do some simple mental excercises. First we need to realize that the following holds\n </p>\n <p>\n  <img alt=\"\" src=\"https://i.sstatic.net/JscHH.gif\"/>\n </p>\n <p>\n  Where\n  <img alt=\"\" src=\"https://i.sstatic.net/dAO7x.gif\"/>\n  is the adjustment we made in order to bring the value into the range of a 32-bit value. From the code we can devise the following, the right shift by two means that we have\n  <img alt=\"\" src=\"https://i.sstatic.net/65UtM.gif\"/>\n  ,\n  <img alt=\"\" src=\"https://i.sstatic.net/5UvZn.gif\"/>\n  ,\n  <img alt=\"\" src=\"https://i.sstatic.net/NV0rJ.gif\"/>\n  ,\n  <img alt=\"\" src=\"https://i.sstatic.net/TR2L6.gif\"/>\n  is unknown. This means that we're missing one variable in order to perform a perfect solution. However the effect of\n  <img alt=\"\" src=\"https://i.sstatic.net/TR2L6.gif\"/>\n  if negligible as its purpose is to bring the divisor as close to its integer value as possible. This means that the solution can be found by solving\n </p>\n <p>\n  <img alt=\"\" src=\"https://i.sstatic.net/Nke6h.gif\"/>\n </p>\n <p>\n  <img alt=\"\" src=\"https://i.sstatic.net/jh1mk.gif\"/>\n </p>\n <p>\n  Another example with divisor 31337 which has the multiplicand magic number 140346763 and right shifts 10 bits.\n </p>\n <p>\n  <img alt=\"\" src=\"https://i.sstatic.net/JuH6C.gif\"/>\n </p>\n <h1>\n  Finally\n </h1>\n <p>\n  For a complete mathematical breakdown of how this works, including all the appropriate proofs and algorithms for calculating the magic numbers, shifts and adds, see\n  <a href=\"http://rads.stackoverflow.com/amzn/click/0321842685\" rel=\"noreferrer\">\n   Hacker's Delight\n  </a>\n  , chapter 10-3.\n </p>\n</div>\n</body></html>",
            "votes": "41",
            "user": "13 revs, 2 users 100%Peter Andersson",
            "time": "Jan 2, 2014 at 22:11",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">The question was not just how to calculate the magic constants, but also how to get back the divisor.</span>",
                    "time": null
                },
                {
                    "user": "Peter Andersson",
                    "text": "<span class=\"comment-copy\">I tried to answer it. Didn't really have time to formulate a proof so I'm not 100% sure it's correct.</span>",
                    "time": null
                },
                {
                    "user": "rwong",
                    "text": "<span class=\"comment-copy\">Under the assumptions of reverse engineering (if the const division/modulo by multiplication is mixed up with other operations), one can convert the integer multiplication constant into a binary fraction, whose reciprocal is related to the division/modulo constant operand up to an unknown power of 2 multiplicative factor. Deducing the unknown power of 2 factor is sometimes impossible due to intermixing and optimization with other operations.</span>",
                    "time": null
                },
                {
                    "user": "Ferrybig",
                    "text": "<span class=\"comment-copy\">FYI: the answer looks good with the stack exchange app, as it has mathjax turned on for every site</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Here's a late response. The\n  <a href=\"https://github.com/uxmal/reko\" rel=\"noreferrer\">\n   Reko decompiler\n  </a>\n  recovers the integer divisors by performing a divide and conquer search using\n  <a href=\"https://en.wikipedia.org/wiki/Mediant_%28mathematics%29\" rel=\"noreferrer\">\n   mediants\n  </a>\n  .\n </p>\n <p>\n  Reko starts by recognizing the pattern where the high word of a 64-bit product (\n  <code>\n   r * c\n  </code>\n  ) is used. The constant multiplier\n  <code>\n   c\n  </code>\n  is divided by 2^32 to yield a double precision floating point number between 0.0 and 1.0. Starting with the rational numbers 0 / 0 and 1 / 1, Reko computes a sequence of mediants that brackets the floating point number. From this sequence of mediants it chooses the rational number that comes closest to the floating point number and returns it.\n </p>\n <p>\n  The code is not fully tested yet -- I haven't had a chance to work with negative numbers yet, for one, but seems to give reasonable results. The code is here if you're curious:\n  <a href=\"https://github.com/uxmal/reko/blob/master/src/Decompiler/Analysis/ConstDivisionImplementedByMultiplication.cs\" rel=\"noreferrer\">\n   https://github.com/uxmal/reko/blob/master/src/Decompiler/Analysis/ConstDivisionImplementedByMultiplication.cs\n  </a>\n </p>\n</div>\n</body></html>",
            "votes": "7",
            "user": "John Källén",
            "time": "Mar 30, 2016 at 18:32",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  This paper might be of interest:\n  <a href=\"https://gmplib.org/~tege/divcnst-pldi94.pdf\" rel=\"nofollow noreferrer\">\n   Division by invariant multiplication\n  </a>\n  .\n </p>\n <p>\n  Bumped into this\n  <a href=\"https://stackoverflow.com/questions/30790184/perform-integer-division-using-multiplication\">\n   here\n  </a>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": []
        }
    ]
}