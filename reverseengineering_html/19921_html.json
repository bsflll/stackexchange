{
    "title": "Writing ELF headers in Radare?",
    "link": "https://reverseengineering.stackexchange.com/questions/19921/writing-elf-headers-in-radare",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Reading\n  <a href=\"https://blog.k3170makan.com/2018/09/introduction-to-elf-format-elf-header.html\" rel=\"noreferrer\">\n   Keith Makan's,\n   <em>\n    \"Introduction to the ELF Format : The ELF Header\"\n   </em>\n  </a>\n  , he modifies\n  <code>\n   e_entry\n  </code>\n  ,\n </p>\n <blockquote>\n  <p>\n   The\n   <code>\n    e_entry\n   </code>\n   field lists the offset in the file where the program should start executing.Normally it points to your _start method (of course if you compiled it with the usual stuff). You can point the e_entry anywhere you like, as an example I'm going to show that you can call a function that would other wise be impossible under normal execution.\n  </p>\n </blockquote>\n <p>\n  Also documented in\n  <a href=\"https://linux.die.net/man/5/elf\" rel=\"noreferrer\">\n   <code>\n    man 5 elf\n   </code>\n  </a>\n  , I'm wondering if Radare has any functionality to rewrite ELF-specific headers or if writing the bits manually is the current way to do this? For example, I know it'll show the entry point with\n  <code>\n   ie\n  </code>\n  .\n </p>\n</div>\n</body></html>",
    "votes": "7",
    "answers": 2,
    "views": "3k",
    "tags": [
        "radare2",
        "elf"
    ],
    "user": "Evan Carroll",
    "time": "Nov 19, 2018 at 22:14",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<html><body><span class=\"comment-copy\">\n You absolutely want to do this with radare2? If not, have a look at the bfd project (used by binutils).\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Evan Carroll",
            "text": "<html><body><span class=\"comment-copy\">\n @0xC0000022L I'm not sure there is a way to do this, generally speaking I assume that Radare can't do something, and then I ask and I find out it can (a huge value of this site). I assume it can only parse ELF. If it can only parse ELF, I think a workaround is a great contribution because I'm pretty spankin new to RE, and I'm sure others are testing the waters just like me. If Radare grows the ability later, I will just come back and mark the newer answer as chosen.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Yes, obviously you can. radare2 has built-in features to handle binary headers. This including reading, parsing and modifying the headers of the binary. And this is not different for\n  <code>\n   elf\n  </code>\n  or\n  <code>\n   pe\n  </code>\n  files, it will work great with both.\n </p>\n <h2>\n  TL;DR\n </h2>\n <pre><code>$ ./example.elf\n[*] you ran this binary!\n\n$ r2 -w -nn example.elf\n[0x00000000]> .pf.elf_header.entry=0x0000063a\n[0x00000000]> q\n\n$ ./example.elf\n[*] wow how did you manage to call this?\n</code></pre>\n <hr/>\n <h2>\n  Creating our test file\n </h2>\n <p>\n  As described in the article you linked in your question, it is easy to create a binary with a function that should never be executed under regular circumstances. Here's the exact code that was used in the linked article:\n </p>\n <pre><code>$ cat example.c\n\n#include <stdio.h>\n\n\nvoid never_call (void) {\n    printf (\"[*] wow how did you manage to call this?\n\");\n    return;\n}\n\nint main (int argc, char **argv) {\n    printf (\"[*] you ran this binary!\n\");\n    return 0;\n}\n</code></pre>\n <p>\n  As you can see, the function\n  <code>\n   never_call\n  </code>\n  would, well... never be called. The program would execute the entrypoint which would execute the\n  <code>\n   main\n  </code>\n  function and will return.\n </p>\n <p>\n  Now let's compile it using the command line used in the article, and execute the program:\n </p>\n <pre><code>$ gcc -Wall -o example.elf example.c\n$ ./example.elf\n[*] you ran this binary!\n</code></pre>\n <p>\n  As we said, only\n  <code>\n   main()\n  </code>\n  was executed. Now let's open the binary in radare2 to see the magic happens.\n </p>\n <hr/>\n <h2>\n  radare2 time!\n </h2>\n <p>\n  <strong>\n   Finding the address of the function\n  </strong>\n </p>\n <p>\n  As you requested, we want to modify the entry point of the binary by modifying the pointed address in the elf header to be our\n  <code>\n   never_call\n  </code>\n  function. So first, we need to find the address of\n  <code>\n   never_call\n  </code>\n  in the binary.\n </p>\n <pre><code>$ r2 example.elf\n[0x00000530]> f~never_call\n0x0000063a 19 sym.never_call\n</code></pre>\n <p>\n  We can see that the function\n  <code>\n   never_call\n  </code>\n  is at address\n  <em>\n   0x0000063a\n  </em>\n  . As you probably know by now, the\n  <code>\n   f\n  </code>\n  command is used to list the\n  <a href=\"https://radare.gitbooks.io/radare2book/basic_commands/flags.html\" rel=\"noreferrer\">\n   flags\n  </a>\n  that was marked by radare2, this including symbols as functions names. Then, we used\n  <code>\n   ~\n  </code>\n  which is r2's internal\n  <em>\n   grep\n  </em>\n  and grepped for the relevant function.\n </p>\n <p>\n  <strong>\n   Parsing the ELF Header\n  </strong>\n </p>\n <p>\n  First, we need to seek to address\n  <code>\n   0\n  </code>\n  using\n  <code>\n   s 0\n  </code>\n  and then and only then we can parse the header with a new command\n  <code>\n   pf\n  </code>\n  . The command\n  <code>\n   pf\n  </code>\n  is used to print formatted data such as structures, enums, and types. Let's load the format definition for\n  <code>\n   elf64\n  </code>\n  using\n  <code>\n   pfo elf64\n  </code>\n  and use the\n  <code>\n   pf.\n  </code>\n  command to list the format definitions:\n </p>\n <pre><code>[0x00002400]> s 0        # Seek to pos 0 in the binary\n\n[0x00000000]> pfo elf64  # Load a Format Definition File for elf\n\n[0x00000000]> pf.\npf.elf_header [16]z[2]E[2]Exqqqxwwwwww ident (elf_type)type (elf_machine)machine version entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\n\npf.elf_phdr [4]E[4]Eqqqqqq (elf_p_type)type (elf_p_flags)flags offset vaddr paddr filesz memsz align\n\npf.elf_shdr x[4]E[8]Eqqqxxqq name (elf_s_type)type (elf_s_flags_64)flags addr offset size link info addralign entsize\n</code></pre>\n <p>\n  One of the loaded definitions is the\n  <code>\n   elf_header\n  </code>\n  which holds the structure for the elf64 header. We can print the header like this:\n </p>\n <pre><code>[0x00000000]> pf.elf_header\n     ident : 0x00000000 = .ELF...\n      type : 0x00000010 = type (enum elf_type) = 0x3 ; ET_DYN\n   machine : 0x00000012 = machine (enum elf_machine) = 0x3e ; EM_AMD64\n   version : 0x00000014 = 0x00000001\n     entry : 0x00000018 = (qword)0x0000000000000530\n     phoff : 0x00000020 = (qword)0x0000000000000040\n     shoff : 0x00000028 = (qword)0x0000000000001948\n     flags : 0x00000030 = 0x00000000\n    ehsize : 0x00000034 = 0x0040\n phentsize : 0x00000036 = 0x0038\n     phnum : 0x00000038 = 0x0009\n shentsize : 0x0000003a = 0x0040\n     shnum : 0x0000003c = 0x001d\n  shstrndx : 0x0000003e = 0x001c\n</code></pre>\n <p>\n  As you can see, radare2 printed the elf64 header in a readable format so now we can see that\n  <code>\n   entry\n  </code>\n  , at 0x18, points to\n  <code>\n   0x530\n  </code>\n  which is our original entrypoint function. We can verify it by using\n  <code>\n   ie\n  </code>\n  , a radare2 command to print the entrypooint:\n </p>\n <pre><code>[0x00000000]> ie\n[Entrypoints]\nvaddr=0x00000530 paddr=0x00000530 baddr=0x00000000 laddr=0x00000000 haddr=0x00000018 hvaddr=0x00000018 type=program\n</code></pre>\n <p>\n  Indeed, you can see that the entry point is 0x530 and the\n  <code>\n   haddr\n  </code>\n  , which is the header address, is 0x18.\n </p>\n <p>\n  <strong>\n   Modifying the entry point\n  </strong>\n </p>\n <p>\n  In order to modify this entry, we would need to open the file in writing mode. We can simply execute\n  <code>\n   oo+\n  </code>\n  from our current session in order to re-open the file in write mode, or use the\n  <code>\n   -w\n  </code>\n  argument to\n  <code>\n   radare2\n  </code>\n  .\n </p>\n <p>\n  Then, we can simply use the\n  <code>\n   pf\n  </code>\n  command to write to the parsed structure the address of\n  <code>\n   never_call\n  </code>\n  function.\n </p>\n <pre><code>[0x00000000]> oo+\n[0x00000000]> pf.elf_header.entry=0x0000063a\nwv8 0x0000063a @ 0x00000018\n</code></pre>\n <p>\n  This printed us a radare2 command to execute which will modify this address in the header. We can either execute it ourselves or use the\n  <code>\n   .\n  </code>\n  command to \"interpret the output of the command as r2 commands\".\n </p>\n <p>\n  So instead of executing\n  <code>\n   wv8 ...\n  </code>\n  , we will simply do:\n </p>\n <pre><code>[0x00000000]> .pf.elf_header.entry=0x0000063a\n</code></pre>\n <p>\n  And now\n  <code>\n   entry\n  </code>\n  should be overridden with 0x63a which is our\n  <code>\n   never_call\n  </code>\n  function.\n </p>\n <pre><code>[0x00000000]> pf.elf_header\n     ident : 0x00000000 = .ELF...\n      type : 0x00000010 = type (enum elf_type) = 0x3 ; ET_DYN\n   machine : 0x00000012 = machine (enum elf_machine) = 0x3e ; EM_AMD64\n   version : 0x00000014 = 0x00000001\n     entry : 0x00000018 = (qword)0x000000000000063a\n     phoff : 0x00000020 = (qword)0x0000000000000040\n     shoff : 0x00000028 = (qword)0x0000000000001948\n     flags : 0x00000030 = 0x00000000\n    ehsize : 0x00000034 = 0x0040\n phentsize : 0x00000036 = 0x0038\n     phnum : 0x00000038 = 0x0009\n shentsize : 0x0000003a = 0x0040\n     shnum : 0x0000003c = 0x001d\n  shstrndx : 0x0000003e = 0x001c\n\n[0x00000000]> pf.elf_header.entry\n     entry : 0x00000018 = (qword)0x000000000000063a\n</code></pre>\n <p>\n  <strong>\n   Executing\n  </strong>\n </p>\n <p>\n  Great! We can now exit radare and execute the program.\n </p>\n <pre><code>$ ./example.elf\n[*] wow how did you manage to call this?\n</code></pre>\n <hr/>\n <h2>\n  Last words\n </h2>\n <p>\n  This long answer explained every step in the way but can really be narrowed to a simple command\n  <code>\n   .pf.elf_header.entry=0x0000063a\n  </code>\n  which sets the\n  <code>\n   entry\n  </code>\n  in the elf header to be the desired address. In the\n  <strong>\n   TL;DR\n  </strong>\n  version I demonstrated the use of\n  <code>\n   -w\n  </code>\n  to open the binary in\n  <code>\n   write-mode\n  </code>\n  and the use of\n  <code>\n   -nn\n  </code>\n  to load the binary structure (\n  <code>\n   pfo elf64\n  </code>\n  , etc...). So simply, opening radare2 like this\n  <code>\n   r2 -w -nn example.elf\n  </code>\n  and executing\n  <code>\n   .pf.elf_header.entry=<address>\n  </code>\n  would solve your problem.\n </p>\n <p>\n  Don't be afraid to ask how to do things in radare2. Although it is quite a scary framework, it is really powerful and with proper knowledge, can do much more things than seems like at first.\n </p>\n <h2>\n  Read more\n </h2>\n <ul>\n  <li>\n   radare.today |\n   <a href=\"http://radare.today/posts/parsing-a-fileformat-with-radare2/\" rel=\"noreferrer\">\n    Parsing a fileformat with radare2\n   </a>\n  </li>\n  <li>\n   r2book |\n   <a href=\"https://radare.gitbooks.io/radare2book/analysis/types.html\" rel=\"noreferrer\">\n    Types\n   </a>\n  </li>\n </ul>\n</div>\n</body></html>",
            "votes": "15",
            "user": "Evan Carroll",
            "time": "Nov 21, 2018 at 6:34",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Evan Carroll",
                    "text": "<span class=\"comment-copy\">Wow, this is really cool. From the UI standpoint, it would be nice if the <code>.pf.elf_header.entry=0x0000063a</code> didn't write to <code>$$</code> but to <code>@ 0</code>. Got it right the second time though.</span>",
                    "time": null
                },
                {
                    "user": "Evan Carroll",
                    "text": "<span class=\"comment-copy\">I just used this to answer another question on the site, thanks again for answering all my questions on re.se. I'll keep them coming. =) <a href=\"https://reverseengineering.stackexchange.com/a/19936/22669\">reverseengineering.stackexchange.com/a/19936/22669</a></span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <em>\n   I don't think this feature is supported according to the\n   <a href=\"https://github.com/radare/radare2/search?q=%22e_entry%22\" rel=\"nofollow noreferrer\">\n    source code\n   </a>\n   .\n  </em>\n  Edit: I was wrong, sorry about that.\n </p>\n <p>\n  However, if you really need a library/tool to do that, I recommend\n  <a href=\"https://github.com/lief-project/LIEF\" rel=\"nofollow noreferrer\">\n   LIEF\n  </a>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "wisk",
            "time": "Nov 20, 2018 at 19:43",
            "is_accepted": false,
            "comments": []
        }
    ]
}