{
    "title": "ELF binary injection",
    "link": "https://reverseengineering.stackexchange.com/questions/26386/elf-binary-injection",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am currently working on an ELF-injector and my approach is standard: find code cave (long enough sequence of 0's), rewrite it with the instructions I want to execute and then jump back to the start of the original program to execute it as it normally would.\n </p>\n <p>\n  To actually execute code in the code cave I tried two different approaches, both of which result in sigsegv.\n </p>\n <p>\n  First one was changing entry point to the start of the code cave. The second one was \"stealing\" some of the first instructions from the original code and write jump to my code cave there and then after executing my injected code I would first execute stolen instructions and then jump to the instruction after the last stolen one in the original program.\n </p>\n <p>\n  I am also changing the access flags for the section, in which code cave resides.\n </p>\n <p>\n  Here are some screenshots of debugging the program in gdb:\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/IHC5I.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"Instructions at entry point - 0x555555556156 is the address of code cave\" src=\"https://i.sstatic.net/IHC5I.png\"/>\n  </a>\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/wpJzp.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"Instructions in the code cave - executing stolen ones and jumping back\" src=\"https://i.sstatic.net/wpJzp.png\"/>\n  </a>\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/KikfO.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"Executing the code\" src=\"https://i.sstatic.net/KikfO.png\"/>\n  </a>\n </p>\n <p>\n  And here are the flags for the section the code cave is in:\n </p>\n <p>\n  <code>\n   [19]     0x555555556058->0x555555556160 at 0x00002058: .eh_frame ALLOC LOAD READONLY CODE HAS_CONTENTS\n  </code>\n </p>\n <p>\n  This is the Valgrind output.\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/I6P0g.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/I6P0g.png\"/>\n  </a>\n </p>\n <p>\n  So is there a way to actually allow the execution of code in this section.\n </p>\n <p>\n  I also thought about adding new section to the binary and writing my code there. If someone had experience in doing so, I would appreciate the info.\n </p>\n <p>\n  <strong>\n   EDIT:\n  </strong>\n  I think I know what my mistake is - I set the executable flag for the section, but the segment it's in isn't executable. But it also seems like the code cave I found doesn't belong to any section, since the start of the code cave is actually the end of one section and the end of the code cave is the start of another section. And there are no other sections in between.\n </p>\n <p>\n  <strong>\n   EDIT 2:\n  </strong>\n  I changed the code cave to the one, that is in\n  <code>\n   .fini\n  </code>\n  section, which belongs to executable segment. However I am still confused about the empty space between sections (and segments).\n </p>\n <p>\n  Here are the screenshots of the\n  <code>\n   readelf\n  </code>\n  output\n </p>\n <pre><code>Section Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .interp           PROGBITS         0000000000000318  00000318\n       000000000000001c  0000000000000000   A       0     0     1\n  [ 2] .note.gnu.propert NOTE             0000000000000338  00000338\n       0000000000000020  0000000000000000   A       0     0     8\n  [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358\n       0000000000000024  0000000000000000   A       0     0     4\n  [ 4] .note.ABI-tag     NOTE             000000000000037c  0000037c\n       0000000000000020  0000000000000000   A       0     0     4\n  [ 5] .gnu.hash         GNU_HASH         00000000000003a0  000003a0\n       0000000000000024  0000000000000000   A       6     0     8\n  [ 6] .dynsym           DYNSYM           00000000000003c8  000003c8\n       00000000000000a8  0000000000000018   A       7     1     8\n  [ 7] .dynstr           STRTAB           0000000000000470  00000470\n       0000000000000082  0000000000000000   A       0     0     1\n  [ 8] .gnu.version      VERSYM           00000000000004f2  000004f2\n       000000000000000e  0000000000000002   A       6     0     2\n  [ 9] .gnu.version_r    VERNEED          0000000000000500  00000500\n       0000000000000020  0000000000000000   A       7     1     8\n  [10] .rela.dyn         RELA             0000000000000520  00000520\n       00000000000000c0  0000000000000018   A       6     0     8\n  [11] .rela.plt         RELA             00000000000005e0  000005e0\n       0000000000000018  0000000000000018  AI       6    24     8\n  [12] .init             PROGBITS         0000000000001000  00001000\n       000000000000001b  0000000000000000  AX       0     0     4\n  [13] .plt              PROGBITS         0000000000001020  00001020\n       0000000000000020  0000000000000010  AX       0     0     16\n  [14] .plt.got          PROGBITS         0000000000001040  00001040\n       0000000000000010  0000000000000010  AX       0     0     16\n  [15] .plt.sec          PROGBITS         0000000000001050  00001050\n       0000000000000010  0000000000000010  AX       0     0     16\n  [16] .text             PROGBITS         0000000000001060  00001060\n       0000000000000185  0000000000000000  AX       0     0     16\n  [17] .fini             PROGBITS         00000000000011e8  000011e8\n       000000000000000d  0000000000000000  AX       0     0     4\n  [18] .rodata           PROGBITS         0000000000002000  00002000\n       0000000000000012  0000000000000000   A       0     0     4\n  [19] .eh_frame_hdr     PROGBITS         0000000000002014  00002014\n       0000000000000044  0000000000000000   A       0     0     4\n  [20] .eh_frame         PROGBITS         0000000000002058  00002058\n       0000000000000108  0000000000000000   A       0     0     8\n  [21] .init_array       INIT_ARRAY       0000000000003db8  00002db8\n       0000000000000008  0000000000000008  WA       0     0     8\n  [22] .fini_array       FINI_ARRAY       0000000000003dc0  00002dc0\n       0000000000000008  0000000000000008  WA       0     0     8\n  [23] .dynamic          DYNAMIC          0000000000003dc8  00002dc8\n       00000000000001f0  0000000000000010  WA       7     0     8\n  [24] .got              PROGBITS         0000000000003fb8  00002fb8\n       0000000000000048  0000000000000008  WA       0     0     8\n  [25] .data             PROGBITS         0000000000004000  00003000\n       0000000000000010  0000000000000000  WA       0     0     8\n  [26] .bss              NOBITS           0000000000004010  00003010\n       0000000000000008  0000000000000000  WA       0     0     1\n  [27] .comment          PROGBITS         0000000000000000  00003010\n       000000000000002a  0000000000000001  MS       0     0     1\n  [28] .symtab           SYMTAB           0000000000000000  00003040\n       0000000000000618  0000000000000018          29    46     8\n  [29] .strtab           STRTAB           0000000000000000  00003658\n       0000000000000202  0000000000000000           0     0     1\n  [30] .shstrtab         STRTAB           0000000000000000  0000385a\n       000000000000011a  0000000000000000           0     0     1\n\n\n</code></pre>\n <pre><code>Program Headers:\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040\n                 0x00000000000002d8 0x00000000000002d8  R E    0x8\n  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318\n                 0x000000000000001c 0x000000000000001c  R E    0x1\n      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\n  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000\n                 0x00000000000005f8 0x00000000000005f8  R E    0x1000\n  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000\n                 0x00000000000001f5 0x00000000000001f5  R E    0x1000\n  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000\n                 0x0000000000000160 0x0000000000000160  R E    0x1000\n  LOAD           0x0000000000002db8 0x0000000000003db8 0x0000000000003db8\n                 0x0000000000000258 0x0000000000000260  RWE    0x1000\n  DYNAMIC        0x0000000000002dc8 0x0000000000003dc8 0x0000000000003dc8\n                 0x00000000000001f0 0x00000000000001f0  RWE    0x8\n  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338\n                 0x0000000000000020 0x0000000000000020  R E    0x8\n  NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358\n                 0x0000000000000044 0x0000000000000044  R E    0x4\n  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338\n                 0x0000000000000020 0x0000000000000020  R E    0x8\n  GNU_EH_FRAME   0x0000000000002014 0x0000000000002014 0x0000000000002014\n                 0x0000000000000044 0x0000000000000044  R E    0x4\n  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000\n                 0x0000000000000000 0x0000000000000000  RWE    0x10\n  GNU_RELRO      0x0000000000002db8 0x0000000000003db8 0x0000000000003db8\n                 0x0000000000000248 0x0000000000000248  R E    0x1\n\n Section to Segment mapping:\n  Segment Sections...\n   00     \n   01     .interp \n   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt \n   03     .init .plt .plt.got .plt.sec .text .fini \n   04     .rodata .eh_frame_hdr .eh_frame \n   05     .init_array .fini_array .dynamic .got .data .bss \n   06     .dynamic \n   07     .note.gnu.property \n   08     .note.gnu.build-id .note.ABI-tag \n   09     .note.gnu.property \n   10     .eh_frame_hdr \n   11     \n   12     .init_array .fini_array .dynamic .got \n\n\n</code></pre>\n <p>\n  As can be seen, section .fini starts at\n  <code>\n   11e8\n  </code>\n  and has the size of\n  <code>\n   d\n  </code>\n  . The next section - .rodata starts at\n  <code>\n   2000\n  </code>\n  . Does that mean that the space between\n  <code>\n   11e8 + d\n  </code>\n  and\n  <code>\n   2000\n  </code>\n  does not belong to any section? That segment also ends at\n  <code>\n   11F5\n  </code>\n  , which is the end of last section belonging to it -\n  <code>\n   .fini\n  </code>\n  .\n </p>\n <p>\n  <strong>\n   EDIT 3:\n  </strong>\n  managed to solve the problem - had to choose the section, that belongs to the executable segment. Still a bit confused about the sizes of sections.\n </p>\n <p>\n  Actually managed to inject the code into the binary, however, I got the instructions from an assembly, which only has\n  <code>\n   .text\n  </code>\n  section:\n </p>\n <pre><code>.text\n.globl _start\n_start:\n  #save the base pointer\n  pushq %rbp\n  pushq %rbx\n  mov %rsp,%rbp\n\n  #write syscall = 1\n  movq $1, %rax\n  #print to stdout\n  movq $1, %rdi\n  #9 character long string\n  movq $9, %rdx\n\n  # push \"INJECTED\n\" to the stack  \n  movq $0x0a, %rcx\n  pushq %rcx\n  movq $0x44455443454a4e49, %rcx\n  pushq %rcx\n\n  movq %rsp, %rsi\n\n  syscall\n\n  #remove the string\n  pop %rcx\n  pop %rcx\n\n  movq $0, %rax\n  movq $0, %rdi\n  movq $0, %rdx\n\n  \n  pop %rbx\n  pop %rbp\n  ret\n</code></pre>\n <p>\n  It prints \"INJECTED\" before the original program execution. While this kind of payload works, what are other ideas of implementing better and actually usable injector? Maybe with the possibility of calling\n  <code>\n   libc\n  </code>\n  functions or some other library functions, that are linked by our victim binary? Because it seems like getting actual instruction from the code, we would like to inject, is kind of pain in the ass.\n </p>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 1,
    "views": "2k",
    "tags": [
        "linux",
        "c",
        "gdb",
        "elf",
        "injection"
    ],
    "user": "Nazar Pasternak",
    "time": "Nov 28, 2020 at 22:05",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<html><body><span class=\"comment-copy\">\n Thanks. Could you replace images by code snippets so it’s easier to read and copy/paste?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Nazar Pasternak",
            "text": "<html><body><span class=\"comment-copy\">\n @IgorSkochinsky done. Also wrote another EDIT regarding my progress. Maybe you will have some ideas on how to implement a better injector? I would appreciate the help !\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Igor Skochinsky",
            "text": "<html><body><span class=\"comment-copy\">\n added answer on bounds. It may be better to make a separate question about using libc functions.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  When executing ELF files, the OS loader does not care about sections but only segments (aka program headers). You need to ensure your code belongs to an executable segment.\n </p>\n <blockquote>\n  <p>\n   As can be seen, section .fini starts at 11e8 and has the size of d.\nThe next section - .rodata starts at 2000. Does that mean that the\nspace between 11e8 + d and 2000 does not belong to any section? That\nsegment also ends at 11F5, which is the end of last section belonging\nto it - .fini.\n  </p>\n </blockquote>\n <p>\n  Yes, the space between 11F5 and 2000 is a kind of \"no man's land\". In theory, the bytes there would not be present in the memory. However, in practice, the memory protections and mappings work on a page granularity (0x1000) so these bytes\n  <em>\n   are\n  </em>\n  mapped into memory and made executable so your patch works. To make everything \"legit\" it may be better to extend the segment length so it extends up to 2000.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Igor Skochinsky",
            "time": "Nov 29, 2020 at 14:42",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Nazar Pasternak",
                    "text": "<span class=\"comment-copy\">Yes, thank you. Correct me if I'm wrong, but looking at readelf output, section .fini starts at <code>11e8</code> and has the size of <code>d</code>. The next section starts at <code>2000</code>. Does that actually mean that the space from <code>11e8 + d</code> to <code>2000</code> does not belong to any section?</span>",
                    "time": null
                },
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">@NazarPasternak sorry I don’t see your screen from here ;) anyway, you should be looking at segments, not sections.</span>",
                    "time": null
                },
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">@NazarPasternak just add all relevant info to the question (segments too)</span>",
                    "time": null
                },
                {
                    "user": "Nazar Pasternak",
                    "text": "<span class=\"comment-copy\">that's right, but to figure out in which segment my code is going to reside, I need to know in which section it currently is :(</span>",
                    "time": null
                }
            ]
        }
    ]
}