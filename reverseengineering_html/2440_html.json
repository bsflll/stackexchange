{
    "title": "Mixed 16/32-bit code reversing using IDA",
    "link": "https://reverseengineering.stackexchange.com/questions/2440/mixed-16-32-bit-code-reversing-using-ida",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am trying to reverse engineer a binary blob I expect to transition from 16-bit real mode into 32-bit protected mode (it is boot time code), so I expect the code to contain code of both sorts.\n </p>\n <p>\n  When I launch IDA, I am given the option of 16 or 32-bit code, but not mixed.\n </p>\n <p>\n  How do I instruct IDA to attempt to disassemble data at a given address as 32-bit mode?\n </p>\n <p>\n  I can using the 16-bit analyzer deduce the initial jump (unoriginally) and IDA happily analyses the code from there. I can see where the 32-bit code jumps to (far jump, so IDA doesn't try to analyze it), but IDA treats this as 16-bit when I hit\n  <kbd>\n   C\n  </kbd>\n  .\n </p>\n <p>\n  Other than launching a 16, and a 32-bit dissasmbly session, can I do this in one?\n </p>\n</div>\n</body></html>",
    "votes": "10",
    "answers": 2,
    "views": "9k",
    "tags": [
        "ida",
        "x86"
    ],
    "user": null,
    "time": "Jul 9, 2013 at 20:36",
    "comments": [
        {
            "user": "Willem Hengeveld",
            "text": "<html><body><span class=\"comment-copy\">\n The arm processor module can do exactly this. So i guess it is a feature that could be implemented in theory.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <strong>\n   Ida Free 5\n  </strong>\n </p>\n <pre><code>Edit -> Segments ->CreateSegment\n</code></pre>\n <p>\n  in the dialog\n </p>\n <pre><code>segment name  = seg001....seg00n\nstart         = <start address viz 0x0A\nend           = <end address viz 0x1e\nbase          = 0x0 \nclass         = some text viz 32one,32two,16three\nradio button  = 32 bit segment or 16 bit segment as needed\nclick yes to a cryptic dialog \n</code></pre>\n <p>\n  example \nthe binary stream contains 16 bit dos puts routine and 32 bit random pushes intermixed\n </p>\n <pre><code>C:\\Documents and Settings\\Admin\\Desktop>xxd -g 1 1632blob.bin\n0000000: b4 01 cd 21 88 c2 b4 02 cd 21 68 78 56 34 12 68  ...!.....!hxV4.h\n0000010: 0d d0 37 13 68 be ba 37 13 68 00 0d db ba b4 01  ..7.h..7.h......\n0000020: cd 21 88 c2 b4 02 cd 21 68 78 56 34 12 68 0d d0  .!.....!hxV4.h..\n0000030: 37 13 68 be ba 37 13 68 00 0d db ba b4 01 cd 21  7.h..7.h.......!\n0000040: 88 c2 b4 02 cd 21 68 78 56 34 12 68 0d d0 37 13  .....!hxV4.h..7.\n0000050: 68 be ba 37 13 68 00 0d db ba                    h..7.h....\n\nC:\\Documents and Settings\\Admin\\Desktop>\n</code></pre>\n <p>\n  loading this blob as binary file moving to\n  <code>\n   offset 0\n  </code>\n  and pressing\n  <code>\n   c\n  </code>\n  would disassemble all bytes as\n  <code>\n   16 bit\n  </code>\n </p>\n <p>\n  now you can move to\n  <code>\n   offset 0x0a\n  </code>\n  and create a\n  <code>\n   32 bit segment\n  </code>\n  with start as\n  <code>\n   0x0a end as 0x1e base as 0x0 class as 32one use 32bitsegment radio button\n  </code>\n  and press\n  <code>\n   c\n  </code>\n  again to create 32 bit disassembly\n </p>\n <p>\n  see below\n </p>\n <pre><code>seg000:0000                ;\nseg000:0000                ; +-------------------------------------------------------------------------+\nseg000:0000                ; ¦     This file is generated by The Interactive Disassembler (IDA)        ¦\nseg000:0000                ; ¦     Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>           ¦\nseg000:0000                ; ¦                      Licensed to: Freeware version                      ¦\nseg000:0000                ; +-------------------------------------------------------------------------+\nseg000:0000                ;\nseg000:0000                ; Input MD5   : AEB17B9F8C4FD00BF2C04A4B3399CED1\nseg000:0000\nseg000:0000                ; ---------------------------------------------------------------------------\nseg000:0000\nseg000:0000                                .686p\nseg000:0000                                .mmx\nseg000:0000                                .model flat\nseg000:0000\nseg000:0000                ; ---------------------------------------------------------------------------\nseg000:0000\nseg000:0000                ; Segment type: Pure code\nseg000:0000                seg000          segment byte public 'CODE' use16\nseg000:0000                                assume cs:seg000\nseg000:0000                                assume es:seg005, ss:seg005, ds:seg005, fs:seg005, gs:seg005\nseg000:0000 B4 01                          mov     ah, 1\nseg000:0002 CD 21                          int     21h\nseg000:0004 88 C2                          mov     dl, al\nseg000:0006 B4 02                          mov     ah, 2\nseg000:0008 CD 21                          int     21h\nseg000:0008                seg000          ends\nseg000:0008\nseg001:0000000A                ; ---------------------------------------------------------------------------\nseg001:0000000A\nseg001:0000000A                ; Segment type: Regular\nseg001:0000000A                seg001          segment byte public '32one' use32\nseg001:0000000A                                assume cs:seg001\nseg001:0000000A                                ;org 0Ah\nseg001:0000000A                                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\nseg001:0000000A 68 78 56 34 12                 push    12345678h\nseg001:0000000F 68 0D D0 37 13                 push    1337D00Dh\nseg001:00000014 68 BE BA 37 13                 push    1337BABEh\nseg001:00000019 68 00 0D DB BA                 push    0BADB0D00h\nseg001:00000019                seg001          ends\nseg001:00000019\nseg002:001E                ; ---------------------------------------------------------------------------\nseg002:001E\nseg002:001E                ; Segment type: Pure code\nseg002:001E                seg002          segment byte public 'CODE' use16\nseg002:001E                                assume cs:seg002\nseg002:001E                                ;org 1Eh\nseg002:001E                                assume es:seg005, ss:seg005, ds:seg005, fs:seg005, gs:seg005\nseg002:001E B4 01                          mov     ah, 1\nseg002:0020 CD 21                          int     21h\nseg002:0022 88 C2                          mov     dl, al\nseg002:0024 B4 02                          mov     ah, 2\nseg002:0026 CD 21                          int     21h\nseg002:0026                seg002          ends\nseg002:0026\nseg003:00000028                ; ---------------------------------------------------------------------------\nseg003:00000028\nseg003:00000028                ; Segment type: Regular\nseg003:00000028                seg003          segment byte public '32two' use32\nseg003:00000028                                assume cs:seg003\nseg003:00000028                                ;org 28h\nseg003:00000028                                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\nseg003:00000028 68 78 56 34 12                 push    12345678h\nseg003:0000002D 68 0D D0 37 13                 push    1337D00Dh\nseg003:00000032 68 BE BA 37 13                 push    1337BABEh\nseg003:00000037 68 00 0D DB BA                 push    0BADB0D00h\nseg003:00000037                seg003          ends\nseg003:00000037\nseg004:003C                ; ---------------------------------------------------------------------------\nseg004:003C\nseg004:003C                ; Segment type: Pure code\nseg004:003C                seg004          segment byte public 'CODE' use16\nseg004:003C                                assume cs:seg004\nseg004:003C                                ;org 3Ch\nseg004:003C                                assume es:seg005, ss:seg005, ds:seg005, fs:seg005, gs:seg005\nseg004:003C B4 01                          mov     ah, 1\nseg004:003E CD 21                          int     21h\nseg004:0040 88 C2                          mov     dl, al\nseg004:0042 B4 02                          mov     ah, 2\nseg004:0044 CD 21                          int     21h\nseg004:0044                seg004          ends\nseg004:0044\nseg005:00000046                ; ---------------------------------------------------------------------------\nseg005:00000046\nseg005:00000046                ; Segment type: Regular\nseg005:00000046                seg005          segment byte public '32three' use32\nseg005:00000046                                assume cs:seg005\nseg005:00000046                                ;org 46h\nseg005:00000046                                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\nseg005:00000046 68 78 56 34 12                 push    12345678h\nseg005:0000004B 68 0D D0 37 13                 push    1337D00Dh\nseg005:00000050 68 BE BA 37 13                 push    1337BABEh\nseg005:00000055 68 00 0D DB BA                 push    0BADB0D00h\nseg005:00000055                seg005          ends\nseg005:00000055\nseg005:00000055\nseg005:00000055                                end\n</code></pre>\n</div>\n</body></html>",
            "votes": "7",
            "user": "blabb",
            "time": "Jul 10, 2013 at 5:09",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  You could either do it manually or create a custom loader module for your binary blob. What you need to do is separate code into 2 segments: 32-bit segment and 16-bit segment, and specify appropriate addressing mode. IDA supports 16, 32, 64 bit modes. If needed you could manually create 2 different code segments and change address mode manually by pressing\n  <kbd>\n   Alt\n  </kbd>\n  +\n  <kbd>\n   S\n  </kbd>\n </p>\n <p>\n  In order to incorporate it in a loader, you may utilize\n  <code>\n   getseg\n  </code>\n  and\n  <code>\n   set_segm_addressing\n  </code>\n  from\n  <em>\n   segment.hpp\n  </em>\n  out of\n  <a href=\"https://www.hex-rays.com/products/ida/support/download.shtml\">\n   IDA SDK\n  </a>\n  :\n </p>\n <pre><code>// Get pointer to segment by linear address\n//      ea - linear address belonging to the segment\n// returns: NULL or pointer to segment structure\n\ninline segment_t *getseg(ea_t ea) { return (segment_t *)(segs.get_area(ea)); } \n</code></pre>\n <p>\n  <p>\n  </p>\n  <pre><code>// Change segment addressing mode (16, 32, 64 bits)\n// You must use this function to change segment addressing, never change\n// the 'bitness' field directly.\n// This function will delete all instructions, comments and names in the segment\n//      s      - pointer to segment\n//      bitness- new addressing mode of segment\n//                 2: 64bit segment\n//                 1: 32bit segment\n//                 0: 16bit segment\n// returns: 1-ok, 0-failure\n\nidaman bool ida_export set_segm_addressing(segment_t *s, size_t bitness);\n</code></pre>\n  <p>\n   Firstly, you will need to get a pointer to a segment structure using\n   <code>\n    getseg\n   </code>\n   . Thereafter, you could change segment addressing mode to 16 or 32 bit using\n   <code>\n    set_segm_addressing\n   </code>\n   .\n  </p>\n </p>\n</div>\n</body></html>",
            "votes": "10",
            "user": "PSS",
            "time": "Jul 10, 2013 at 5:21",
            "is_accepted": false,
            "comments": []
        }
    ]
}