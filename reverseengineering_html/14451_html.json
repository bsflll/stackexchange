{
    "title": "Why is IDAPython decompiler API returning the same effective address for both the current item and its parent?",
    "link": "https://reverseengineering.stackexchange.com/questions/14451/why-is-idapython-decompiler-api-returning-the-same-effective-address-for-both-th",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Following this\n  <a href=\"http://www.hexblog.com/?p=107\" rel=\"nofollow noreferrer\">\n   blog\n  </a>\n  post, I am writing an IDAPython code to traverse the AST generated by the decompiler in order to extract some information. I am providing both my AST, the Python code and the output. The problem is, the effective address is the same for both the current item and its parent which shouldn't be the case.\n </p>\n <p>\n  <strong>\n   Python code:\n  </strong>\n </p>\n <pre><code>import idaapi\n\n\nclass sample_visitor_t(ctree_visitor_t):\n    def __init__(self, log_message_xref_addr):\n        self.log_message_xref_addr = log_message_xref_addr\n        ctree_visitor_t.__init__(self, CV_PARENTS)\n        return\n\n    def visit_expr(self, expr):\n        if expr.op != cot_call:\n            return 0\n\n        method_name = get_func_name(expr.x.obj_ea)\n        if expr.a.size() > 0:\n            args = expr.a\n            for arg in args:\n                if arg.ea == self.log_message_xref_addr:\n                    print method_name, hex(expr.ea)\n                    pexpr = self.parent_expr()\n                    print(hex(pexpr.ea), pexpr.op)\n\n        return 0\n\n\ndef traverse(func_addr, log_message_xref_addr):\n    function = get_func(func_addr)\n    cfunc = decompile(function)\n    visitor = sample_visitor_t(log_message_xref_addr)\n    visitor.apply_to(cfunc.body, None)\n\n\ntraverse(0x8F62635C, 0x8F626570)    # emmc_recovery_init = 0x8F62635C\n</code></pre>\n <p>\n  <strong>\n   Decompilation:\n  </strong>\n </p>\n <pre><code>int emmc_recovery_init()\n{\n  int v0; // lr@0\n  unsigned __int64 v1; // r6@1\n  size_t v2; // r0@1\n  recovery_message *v3; // r4@1\n  uint32_t v4; // r8@2\n  int v5; // r0@2\n  int v6; // r10@2\n  uint8_t v7; // r0@3\n  unsigned __int8 v8; // r3@5\n  int result; // r0@12\n  unsigned int status; // [sp+8h] [bp-28h]@1\n  void *v11; // [sp+Ch] [bp-24h]@13\n\n  status = 0;\n  LODWORD(v1) = v0;\n  v2 = mmc_get_device_blocksize();\n  v3 = (recovery_message *)memalign(0x40u, v2);\n  if ( !v3 )\nLABEL_29:\n    panic((void *)v1, \"msg\");\n  v4 = mmc_get_device_blocksize();\n  v5 = partition_get_index(\"misc\");\n  v6 = v5;\n  if ( v5 < 0 )\n  {\n    dprintf(\"%s: Partition not found\n\", \"misc\");\n  }\n  else\n  {\n    v1 = partition_get_offset(v5);\n    v7 = partition_get_lun(v6);\n    mmc_set_lun(v7);\n    if ( v1 )\n    {\n      if ( !mmc_read(v1, HIDWORD(v1), v3, v4) )\n      {\n        v8 = v3->command[0];\n        v3->command[31] = 0;\n        if ( (unsigned __int8)(v8 - 1) <= 0xFDu )\n          dprintf(\"Recovery command: %d %s\n\", 32, v3);\n        if ( !strcmp(v3->command, \"boot-recovery\") )\n          boot_into_recovery = 1;\n        if ( !strcmp(\"update-radio\", v3->command) )\n        {\n          if ( !get_boot_info_apps(2u, &status) && status & 1 )\n          {\n            dprintf(\"radio update success\n\");\n            strlcpy(v3->status, \"OKAY\", 0x20u);\n          }\n          else\n          {\n            dprintf(\"radio update failed\n\");\n            strlcpy(v3->status, \"failed-update\", 0x20u);\n          }\n          boot_into_recovery = 1;\n          if ( strcmp(\"reset-device-info\", v3->command) )\n          {\nLABEL_11:\n            if ( strcmp(\"root-detect\", v3->command) )\n            {\nout:\n              free(v3);\n              result = 0;\n              goto LABEL_13;\n            }\nLABEL_15:\n            set_device_root();\n            strlcpy(v3->command, (const unsigned __int8 *)\"\", 0x20u);\n            emmc_set_recovery_msg(v3);\n            goto out;\n          }\n        }\n        else if ( strcmp(\"reset-device-info\", v3->command) )\n        {\n          goto LABEL_11;\n        }\n        reset_device_info();\n        if ( strcmp(\"root-detect\", v3->command) )\n          goto out;\n        goto LABEL_15;\n      }\n      dprintf(\"mmc read failure %s %d\n\", \"misc\", v4);\n    }\n    else\n    {\n      dprintf((const unsigned __int8 *)\"partition %s doesn't exist\n\", \"misc\");\n    }\n  }\n  if ( v3 )\n  {\n    free(v3);\n    result = -1;\n  }\n  else\n  {\n    result = -1;\n  }\nLABEL_13:\n  if ( v11 != _stack_chk_guard )\n    goto LABEL_29;\n  return result;\n}\n</code></pre>\n <p>\n  <strong>\n   Output:\n  </strong>\n </p>\n <pre><code>_dprintf 0x8f626574L\n('0x8f626574L', 72)\n</code></pre>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 0,
    "views": "555",
    "tags": [
        "ida",
        "decompilation",
        "idapython",
        "decompile",
        "decompiler"
    ],
    "user": "sherlock",
    "time": "Jan 19, 2017 at 21:49",
    "comments": [
        {
            "user": "Nordwald",
            "text": "<html><body><span class=\"comment-copy\">\n Note that when lifting assembler code it is very usual to generate several nodes / instructions per instruction since x86 is very bloated (more than 1000 instructions) and an abundance of side effects.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "sherlock",
            "text": "<html><body><span class=\"comment-copy\">\n <code>\n  72\n </code>\n is\n <code>\n  if\n </code>\n instruction as defined in\n <code>\n  hexrays.hpp\n </code>\n . If I place cursor on the enclosing\n <code>\n  if\n </code>\n statement in the disassembly and press\n <code>\n  TAB\n </code>\n , it takes me to a different address.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}