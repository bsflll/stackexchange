{
    "title": "Struggling between syscall or sysenter ( Windows )",
    "link": "https://reverseengineering.stackexchange.com/questions/16454/struggling-between-syscall-or-sysenter-windows",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  As I understand, from windows XP, there is a\n  <code>\n   sysenter\n  </code>\n  instruction introduced, instead of\n  <code>\n   int 2e\n  </code>\n  interrupt.\n </p>\n <p>\n  But on win 10 there is\n  <code>\n   syscall\n  </code>\n  instruction used in ntdll. So is the\n  <code>\n   sysenter\n  </code>\n  used only for x86 windows systems? And\n  <code>\n   syscall\n  </code>\n  only for x64 bit systems?\n </p>\n</div>\n</body></html>",
    "votes": "11",
    "answers": 3,
    "views": "9k",
    "tags": [
        "windows",
        "x86",
        "x86-64",
        "operating-systems",
        "system-call"
    ],
    "user": "PastaAlaCarbonara",
    "time": "Dec 29, 2023 at 2:39",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The Intel and AMD instruction sets are similar but not identical.\n </p>\n <p>\n  There are many examples of that: FMA3/FMA4, AMD-V and VT-x (and their extensions), etc.\n </p>\n <p>\n  The fast system call interface is yet another difference.\n </p>\n <ul>\n  <li>\n   <p>\n    Intel supports\n    <code>\n     SYSENTER\n    </code>\n    in all modes\n    <sup>\n     1\n    </sup>\n    - Legacy Mode (or, on the few 32-bit only Intel CPUs, simply Protected Mode), Long Mode and Compatibility Mode. (It doesn't work in Real Mode, obviously, and the from now on I'm ignoring it.)\n   </p>\n  </li>\n  <li>\n   <p>\n    Intel supports\n    <code>\n     SYSCALL\n    </code>\n    only in 64-bit Long Mode\n    <sup>\n     2\n    </sup>\n    (not compat. mode). It also requires setting a bit in some MSR.\n   </p>\n  </li>\n  <li>\n   <p>\n    AMD supports\n    <code>\n     SYSENTER\n    </code>\n    only in Legacy Mode\n    <sup>\n     3\n    </sup>\n    , not in any of the Long Mode submodes.\n   </p>\n  </li>\n  <li>\n   <p>\n    AMD supports\n    <code>\n     SYSCALL\n    </code>\n    in all modes\n    <sup>\n     4\n    </sup>\n    .\n   </p>\n  </li>\n </ul>\n <p>\n  So as the\n  <a href=\"http://wiki.osdev.org/SYSENTER\" rel=\"noreferrer\">\n   OSDEV page on the topic says\n  </a>\n  :\n </p>\n <ul>\n  <li>\n   In 64-bit Long Mode - only\n   <code>\n    SYSCALL\n   </code>\n   works on both ISAs. (\n   <code>\n    SYSENTER\n   </code>\n   doesn't work on AMD.)\n  </li>\n  <li>\n   In Legacy Mode - only\n   <code>\n    SYSENTER\n   </code>\n   works on both ISAs. (\n   <code>\n    SYSCALL\n   </code>\n   doesn't work on Intel.)\n  </li>\n  <li>\n   There's no single instruction that works on both Intel and AMD in Compatibility Mode (\n   <code>\n    SYSENTER\n   </code>\n   doesn't work on AMD and\n   <code>\n    SYSCALL\n   </code>\n   doesn't work on Intel), but there's no need for one. A 32-bit kernel will stay in Legacy Mode after boot.\n  </li>\n </ul>\n <hr/>\n <p>\n  <sup>\n   1\n  </sup>\n  <a href=\"https://software.intel.com/sites/default/files/managed/7c/f1/253667-sdm-vol-2b.pdf\" rel=\"noreferrer\">\n   Intel® 64 and IA-32 architectures software developer's manual volume 2B: Instruction set reference, M-U\n  </a>\n  , p. 4-668\n </p>\n <p>\n  <sup>\n   2\n  </sup>\n  <a href=\"https://software.intel.com/sites/default/files/managed/7c/f1/253667-sdm-vol-2b.pdf\" rel=\"noreferrer\">\n   Intel® 64 and IA-32 architectures software developer's manual volume 2B: Instruction set reference, M-U\n  </a>\n  , p. 4-666\n </p>\n <p>\n  <sup>\n   3\n  </sup>\n  <a href=\"http://support.amd.com/TechDocs/24594.pdf\" rel=\"noreferrer\">\n   AMD64 Architecture Programmer’s Manual Volume 3: General-Purpose and System Instructions\n  </a>\n  , p. 423\n </p>\n <p>\n  <sup>\n   4\n  </sup>\n  <a href=\"http://support.amd.com/TechDocs/24594.pdf\" rel=\"noreferrer\">\n   AMD64 Architecture Programmer’s Manual Volume 3: General-Purpose and System Instructions\n  </a>\n  , p. 419\n </p>\n</div>\n</body></html>",
            "votes": "16",
            "user": "conio",
            "time": "Oct 9, 2017 at 1:26",
            "is_accepted": false,
            "comments": [
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">Comments have been <a href=\"https://chat.stackexchange.com/rooms/150411/discussion-on-answer-by-conio-struggling-between-syscall-or-sysenter-windows\">moved to chat</a>.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  64-bit user-space always uses\n  <code>\n   syscall\n  </code>\n  , across all x86-64 OSes.\n </p>\n <p>\n  32-bit user-space under a 32-bit Windows kernel uses\n  <code>\n   sysenter\n  </code>\n  if available.\n </p>\n <p>\n  WoW64 (32-bit user-space aka Windows, on a 64-bit kernel aka Windows64) uses a\n  <code>\n   call far\n  </code>\n  into a 64-bit ntdll which uses 64-bit\n  <code>\n   syscall\n  </code>\n  .\n </p>\n <p>\n  Some other OSes, such as Linux, do enter a 64-bit kernel directly from 32-bit user-space, with\n  <code>\n   sysenter\n  </code>\n  or\n  <code>\n   syscall\n  </code>\n  depending on which the CPU supports (via the VDSO which the kernel maps into the address-space of user-space processes).  See\n  <a href=\"https://stackoverflow.com/questions/77678700/calling-system-api-from-32-bit-processes-under-linux-64-bit/77680771#77680771\">\n   Calling system API from 32-bit processes under Linux 64-bit\n  </a>\n  for more details on\n  <code>\n   syscall\n  </code>\n  vs.\n  <code>\n   sysenter\n  </code>\n  and which modes they're available in on different CPUs, and the fact that legacy-mode (32-bit kernel)\n  <code>\n   syscall\n  </code>\n  is so badly designed (from a Linux kernel perspective at least) that Linux doesn't use it even if that means a fallback to\n  <code>\n   int 0x80\n  </code>\n  .\n </p>\n <hr/>\n <p>\n  WoW64's\n  <code>\n   call far\n  </code>\n  /\n  <code>\n   retf\n  </code>\n  nearly doubles the cost of getting into the kernel and back for 32-bit user-space (compared to\n  <code>\n   sysenter\n  </code>\n  ), but isn't a big fraction of the total time for most system calls.  This has always seemed like an inefficient design to me, so I wonder if they chose it only because there's no single instruction that works from 32-bit compat mode under a 64-bit kernel on both Intel and AMD x86-64 CPUs.  Or it there's useful stuff that can be done in user-space to avoid calling into the kernel at all, but only with 64-bit code?\n </p>\n <p>\n  A faster system-call instruction is something that OS devs do care about, e.g.\n  <a href=\"https://devblogs.microsoft.com/oldnewthing/20041215-00/?p=37003\" rel=\"nofollow noreferrer\">\n   Raymond Chen's blog\n  </a>\n  about how on 386, the illegal instruction trap was the fastest way into the kernel so Windows used that.\n </p>\n <p>\n  A\n  <code>\n   call far [mem]\n  </code>\n  /\n  <code>\n   retf\n  </code>\n  pair on i7-6700k Skylake takes 220 core clock cycles when measured in a simple microbenchmark loop.  From 32-bit user-space to 64-bit user-space, or from 32 to 32 costs the same.\n  <a href=\"https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1BMFSlgCNaAT1JL6yAngGVG6AMKpaAVxYMQANlJXABk8BkwAOR9zTGIQAFYNUgAHVAVCJwYPb18AlLSMgVDwqItYhKS7TAdMoQImYgJsnz9AqpqBOoaCYsjo8sTbesbm3LbhnrC%2BsrjEgEpbVC9iZHYOAFIAZgAhLe2AahMWAFpaMIBrfeOGffWAJjuAEgJ7u4A6I9u7/3v/ffqFOclAQrsh9lx9slYlR9gp6iDjscxLRjl4lMQrpgAedjshaKhkOdSGhBJhVARjgoAO6EZAITAKYnJLzHFh4YDEJiOASM5JMYCYY5UJheWgERnIKx4hmkcychh0mVhOHELwdBiMryoZIKAD6eFMXkw6A%2BDBsWp1uuIWLw1pN1sc1t1Cnx4tIFr1ZOqXgIxreBAQ1qY6CuxDu%2BzeAHpXs9XusNABBeNJnZ7fbMBQsK5UTC0KibcO%2BuH47UfTPJvZp2gh1m5qj6zYADj%2Bx1Q/wZBBLyXbxdQpdQFdTO3%2BJiBWNB4Mh0Nh8KuSNoKLRsUx2Nx%2BMJxNkZIp1Np9IlzNZ7M53I1KX5guFordkuljOVBFV6s12r1BoURpNhnNr91XuQPp%2BgGQboOQ6AAI5vGyvq6h6sryoqCihhCUZFp2fbJBWiZYFeYr7NatAVnc8RLrCLDdGI7IMMmlHAAwLAYJgkKBPs/iSFhCbAPi5hiPszoTMm/HdCAyb7GJkJogg%2BwaKomybOJCkKWmMl3PJBr7MUXiqGAHBIQWxzmIQ%2BxLsQlJ8qs%2BxoFgsKYMAbCCGmhA6UhDBtsKcKxGAYCieJzIKFJaE%2BWJDEAG5idUqikPsDKYYmCmhYpmDmMkUVcBo6UZRoNFnHRrHsYmbxdiJiZpuJogLtJsmbCAaGKWmmmqMZShIW4QhbAAIjJcn7PwGImWZTAWWxBlGQxWCDgcZXIpVck1R2dXDncjXlbQPUNJCj5cP4IAFiO5wMvskh3I2llSvQjKwm2dxSNFg0IEFlnTcKGLrPE2wRa97ULQcS2PRVz23G9bAsJ9e0HZIkgaKdd5RQoV13FDmB3Q9K1rS9b0ffE7UPVgYJJbFCYKdoDAAF4Rl2yZvK4xVJnF4mqCQ0XmJFSWqA9CVI5FELfXxuoRAASn%2BqhGT1xCoFmkZosQkZhHiXhYJGRySwwBoEOguoFm89102JYQgjJjZQ4ptzDgoViesLBAQBocwcbRNwFsmhninlyZoTTYlprj%2BFMI1xsmwcAbqVSSzVvsuOMYcSEECH%2BwPk%2Bp5xw7dwjSCY2YLDbZQsQMJoF4pLEEhJI0MQWZUkxwCoCC9LWkneWp/s6c%2BQ6VAcfc8R4DCWUlUOuy95Ww6HA4Xi8dnMLWh%2BYpIVQYtZiwViN3dUxRXgADsxz%2BKv6WXDSAb7NgyjKB1PEGAqmC6mPJDkWfE0D3399pgI%2BwJisUkAOIRHIkYNVF%2B3EOEq1DAhjHvsEKsR0hP38G8eIHFsTAgnBCEBcIuRzmRKidEK5RxrgJESEkvpySUl3ohJkLI2Qci5JkXkF4hQiinsSM6SoNSPjVKeF8lp3yflND%2BS0/5AImmAkjUCeAIJQUIOfOCcpDCITEqhDsFMSpxWUNCK%2BUimJ5wLjOLk09GY6Vkb2bUOkaYPWNlwUgXA7gAE43ir3kiwJQYJVx4hwf7FxLj7jyXElwN4GV9huGUIoYyjgzgk2NK4pSOswkKSNgpPB25CF7gOpEuqqkonePSvsSM9iklhOMUk6JZVDxkJPJQ7Jxt3GpJ8Zk6opS3EROydzBSfIBQ0OvEhGpZSUniQ0G8RsjZ4gZKye0uqdTpCQzuKQRsmwLGkHiH042t5zpDJyZ0sSmwekWNXvsN%2BAAJMmSzwmE39v4JIGVSCbHiJIY28cWElP2V8DxYlukaG5sqG42dob0CScY0x8Q0qkA0L0iZFiHniQ9PqQ0fpvxLPKZ4t4clNlvyqWCO53yZl/IBYEVe/h%2BmKTBbw30/DAyCOyTCsSXj4VbKRXc24dTPEnPSv835VyRHQXEa%2BFFKz9iNh6fEcMABZKlKLaViUGKczYkgGniUkQqfc1KlIrIhm8YiFj9gCsGfsji/svFcE2OleImxV6r36fYgQ6Bo54DYNFAwOpjSapMW8cxFjJAWOOekk1DAzVNViLk6SaTMo%2BPdZ6s2CgiLxFcJ3DgCxaCcHiLwPwHAtCkFQJwBMphMAWGsJdZYFl3E8FIAQTQkaFjnB2tyixLqNmbH8HcGxqlGzEX0JwSQcbC1Js4LwBQIAkgFoTZG0gcBYAwEQCgcWyQ6CxHIJQNALAx30DiBmFg11jmmJoGKcBlBzCtsMswYgVhOB5u3Q0KwAB5cw2hqg9rzdO%2ByBBj0MGsK2rA5gvDADcMiTt3BeBYGvlxNYib8DWhqGAj9ib8VrDzXrXMraziSN3R4LArbHwWv3X2qgBhgAKAAGp4EwFSY9UJ415v4IIEQYh2BSBkIIRQKh1C9tILoUxp9jBpozTYGDnbIALG1KwzgQorX5juLwVAYDiDEGEQyeACx2inhcB60YfhxVBA9b0UoMQ4jTNSOkU88mdrSE04UBgKn%2BjqdsLmC9tQJg6cU9Jiz3QjMzBANM5BIxPAtF00MOzUxVPlAsVJpYKxyNRpjS2ujyaOD7AiAmIQfL9jvC2t4iEEBcCEEZrmuYvAe1aDmMWiQDLo0cGbaQFgIBV5xYeDqiGsyuBcGBeM%2BNiawsdq7fmwtCwB3DqWAQZkBBJ0QGnbO2IERWBrFUM2DelzgDIDBDqpVvBjQpbE%2BgPQxHhDlXI9IFb1G1CtoY6QKknJkgoaCxwWNpB6tCc4Men03X9ioBhJF6LsWHVQOefsCAHgZ3jpeqpLg6WWu9uy6QekwZygQGO4V4rNaemGubPEC5XBekaH8IC87baOBNe7a1nL/gvHpV1d8A13wsUI8bRwTYIWGvtv%2B1l47gmzutsa9TotpARMQL8JIIAA\" rel=\"nofollow noreferrer\">\n   NASM source with\n   <code>\n    perf\n   </code>\n   results\n  </a>\n  for a static Linux executable I used to test by running\n  <code>\n   perf\n  </code>\n  on the whole program.  With basically no startup overhead, and running enough iterations to run for over a second, this gives pretty accurate measurements.\n </p>\n <p>\n  A do-nothing system call with an invalid syscall number (EAX=-1) takes 1209 cycles on the same system, Linux kernel 6.5 with Spectre + Meltdown mitigation, including swapping page tables.  So an extra call far + retf is about 18% extra cost for a do-nothing system call in the best case with caches hot.\n </p>\n <p>\n  I also tested\n  <code>\n   call far\n  </code>\n  / 64-bit\n  <code>\n   syscall\n  </code>\n  /\n  <code>\n   retf\n  </code>\n  (1439 cycles) vs.\n  <code>\n   int 0x80\n  </code>\n  (1772 cycles) vs.\n  <code>\n   sysenter\n  </code>\n  (1305 cycles), average cost in a tight loop.  This is on x86-64 Linux 6.5 on my i7-6700k Skylake, with EAX=-1, so it returns\n  <code>\n   -ENOSYS\n  </code>\n  without dispatching to a\n  <code>\n   sys_whatever\n  </code>\n  function, but still does a bunch of stuff inside the kernel.  (It's optimized for the case of system calls that don't error, so it doesn't check that until it's ready to dispatch to a handler function.)  So WoW64's strategy is better than using\n  <code>\n   int 0x2e\n  </code>\n  , at least on Skylake and probably most CPUs.  But it's worse than using\n  <code>\n   sysenter\n  </code>\n  on CPUs that support that from compat mode.\n </p>\n <p>\n  The 134 cycle delta between the WoW64 strategy and\n  <code>\n   sysenter\n  </code>\n  isn't as big as\n  <code>\n   call far\n  </code>\n  /\n  <code>\n   retf\n  </code>\n  alone, so maybe 32-bit\n  <code>\n   sysenter\n  </code>\n  is slower than 64-bit\n  <code>\n   syscall\n  </code>\n  , or the Linux kernel internals are different for compat-mode system calls vs. native 64-bit syscalls.\n </p>\n <hr>\n  <p>\n   <code>\n    call far\n   </code>\n   /\n   <code>\n    retf\n   </code>\n   was somewhat less slow on older CPUs (when 32-bit code was even more common on Windows), for example\n   <a href=\"https://agner.org/optimize/\" rel=\"nofollow noreferrer\">\n    Agner Fog\n   </a>\n   measured\n   <code>\n    call far [mem]\n   </code>\n   at 79 cycles on Nehalem (microcoded as 47 uops), plus\n   <code>\n    retf\n   </code>\n   taking 120 cycles, for a total of 199 cycles for a pair.  Or 153 for call far+retf on Core 2.  But only 33 cycles in AMD K8 and K10.  Agner didn't measure\n   <code>\n    call far\n   </code>\n   or\n   <code>\n    retf\n   </code>\n   for CPUs newer than that.\n  </p>\n  <p>\n   32-bit code is still not rare on Windows, where some projects are built around binary-only DLLs.  The software ecosystem around other OSes is less binary-centric, and some current Linux distros are even considering disabling running 32-bit executables in the kernel, at least by default.\n  </p>\n </hr>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Peter Cordes",
            "time": "Dec 19, 2023 at 23:27",
            "is_accepted": false,
            "comments": [
                {
                    "user": "conio",
                    "text": "<span class=\"comment-copy\">Wow, great answer. Really knowledgeable. There's quite a lot of information here. Could you cite a <i>reputable</i> source that says that \"32-bit code is still not rare on Windows\" and <i>how common</i> is it? I've spent quite some time looking for <i>public</i> data on this and couldn't find any. On my machine I have 9/405 processes that are 32-bit (4 of those belong to VMware Workstation), which doesn't sounds like a lot. I might actually describe 9 out of 405 as \"rare\". But my machine probably doesn't represent the entire world, and I'm sure you have better data available. Mind you sharing it?</span>",
                    "time": null
                },
                {
                    "user": "Peter Cordes",
                    "text": "<span class=\"comment-copy\">@conio: I could be wrong about that!  I was under the impression that a decent amount of 3rd-party software was still 32-bit only, but maybe that's changed in the past several years.  My Linux desktop has zero 32-bit processes, normal for GNU/Linux systems.  In any case, when the WoW64 design-decisions were being made in the early 2000s, 32-bit software was absolutely widespread, and they expected 32-bit user-space to be important for years.  It's probably not worth changing now, but it's interesting to evaluate the choices of different OSes.</span>",
                    "time": null
                },
                {
                    "user": "Peter Cordes",
                    "text": "<span class=\"comment-copy\">@conio: In chat linked under your answer, you claimed that it was common for OSes to deprecate 32-bit user-space entirely.  Yes, x86-64 macOS did that for example, and Linux is starting to, but this is a Windows question.  Stack Overflow questions about how to use a 32-bit DLL still get asked in 2023, so people are still actively developing code but wanting to use a 32-bit DLL they have.  Google <code>site:stackoverflow.com 32-bit dll 64-bit</code> (filter to this year) to find Qs like <a href=\"https://stackoverflow.com/q/75951175\">How to link against x86 .lib on x64 machine with rustc (64 bit) on Windows?</a></span>",
                    "time": null
                },
                {
                    "user": "Peter Cordes",
                    "text": "<span class=\"comment-copy\">@conio: And re: Visual Studio (the IDE itself) being 32-bit for performance reasons (or because the codebase took a lot of work to get it 64-bit clean?), that was a true fact for many years. It only changed in 2022!  Before that, no 64-bit version was available!  A 2010 MS blog attempted to justify it (<a href=\"https://web.archive.org/web/20160309232651/http://blogs.msdn.com/b/ricom/archive/2009/06/10/visual-studio-why-is-there-no-64-bit-version.aspx\" rel=\"nofollow noreferrer\">web.archive.org/web/20160309232651/http://blogs.msdn.com/b/…</a>).  But <a href=\"https://stackoverflow.com/q/2516436\">Visual Studio 64 bit?</a> on SO has lots of comments from people unimpressed with a 4GiB limit.</span>",
                    "time": null
                },
                {
                    "user": "Peter Cordes",
                    "text": "<span class=\"comment-copy\">@conio: So WoW64 was necessary for one of MS's own flagship apps until 2022. I think that's sufficient evidence of it being relevant.  The major selling point of x86 has historically been backwards-compatibility, and the Windows + x86 software ecosystem has always been more binary-centric than most, and encumbered with legacy binaries that people don't have source for.  As well as some new binaries being built as 32-bit.  That's getting rarer, but due to 32-bit DLLs it's not going away any time soon.  It's implausible that MS would drop WoW64 this decade.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <code>\n   syscall\n  </code>\n  (created by AMD) and\n  <code>\n   sysenter\n  </code>\n  (created by Intel) are competing implementations of fast switch-to-ring0 instructions.  For compatibility, x64 systems support both types.  That wasn't deemed to be necessary for 32-bit systems.\n </p>\n</div>\n</body></html>",
            "votes": "-1",
            "user": "0xC0000022L",
            "time": "Dec 19, 2023 at 10:29",
            "is_accepted": false,
            "comments": [
                {
                    "user": "conio",
                    "text": "<span class=\"comment-copy\">This is wrong. And mentioned in the links I put in my comment on the question. In Long Mode, <code>SYSCALL</code> is the only one supported both on AMD64 and on Intel 64. The AMD manual says explicitly on the page on <code>SYSENTER</code> \"An invalid-opcode exception occurs if this instruction is used in long mode. Software should use the SYSCALL (and SYSRET) instructions in long mode.\"</span>",
                    "time": null
                }
            ]
        }
    ]
}