{
    "title": "Decoding serial data",
    "link": "https://reverseengineering.stackexchange.com/questions/11241/decoding-serial-data",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have an energy monitory and I managed to get into the feed. I got the handshake packets sorted but I am stuck on working out how to decode this data from HEX.\n </p>\n <p>\n  All I know are the following values as shown on the monitor at time of dump.\n </p>\n <ol>\n  <li>\n   Pac = 81 W\n  </li>\n  <li>\n   Vac = 236.1 V\n  </li>\n  <li>\n   Energy Total = 45.7 kWh\n  </li>\n  <li>\n   Hours Total = 72 h\n  </li>\n </ol>\n <p>\n  and have the following packets, that are send by the monitor every 10 seconds\n </p>\n <pre><code> AA 55 00 01 01 00 11 82 32 00 AA 00 9A 06 DE 06   ªU.....‚2.ª.š.Þ.\n D4 00 03 00 03 00 04 09 59 13 8C 00 51 00 00 00   Ô.......Y.Œ.Q...\n 00 01 C9 00 00 00 48 00 01 00 00 00 00 FF FF 00   ..É...H......ÿÿ.\n 00 00 00 00 00 00 00 00 00 00 00 09 35            ............5\n\n AA 55 00 01 01 00 11 82 32 00 A3 00 9A 07 01 07   ªU.....‚2.£.š...\n 11 00 03 00 03 00 04 09 51 13 8E 00 4F 00 00 00   ........Q.Ž.O...\n 00 01 C9 00 00 00 48 00 01 00 00 00 00 FF FF 00   ..É...H......ÿÿ.\n 00 00 00 00 00 00 00 00 00 00 00 07 88            ............ˆ\n\n AA 55 00 01 01 00 11 82 32 00 A3 00 9A 06 C2 06   ªU.....‚2.£.š.Â.\n E3 00 03 00 03 00 04 09 39 13 8E 00 51 00 00 00   ã.......9.Ž.Q...\n 00 01 C9 00 00 00 48 00 01 00 00 00 00 FF FF 00   ..É...H......ÿÿ.\n 00 00 00 00 00 00 00 00 00 00 00 09 03            .............\n\n AA 55 00 01 01 00 11 82 32 00 A3 00 9A 06 B8 06   ªU.....‚2.£.š.¸.\n B2 00 03 00 03 00 04 09 39 13 90 00 51 00 00 00   ².......9..Q...\n 00 01 C9 00 00 00 48 00 01 00 00 00 00 FF FF 00   ..É...H......ÿÿ.\n 00 00 00 00 00 00 00 00 00 00 00 08 CA            ............Ê\n</code></pre>\n <p>\n  I can see the exact same things on start until\n  <code>\n   ,2<ascii>\n  </code>\n  , after that it seems to contain the data. The last packet dump should be the one resembling the data on the monitor at the time of receiving and as I mentioned.\n </p>\n <p>\n  I have tried converted each HEX into integer, and maybe just finding similar numbers, like the easiest would be hours,\n  <code>\n   72\n  </code>\n  since that only changes every hour. But my futile attempts got me nowhere. Nothing close to 72.\n </p>\n <p>\n  I doubt the data is obfuscated, or encrypted. I just don't know how else I can try and work this out and seek some advice from experienced developers in this sort of field.\n </p>\n <p>\n  All packets end the same with\n  <code>\n   FF FF 00 ..\n  </code>\n  and the last hex is different each time, I suspect a CRC value for checking. There may be other values mixed in between all these but I am only interested in the main ones I can see on the monitor.\n </p>\n</div>\n</body></html>",
    "votes": "6",
    "answers": 1,
    "views": "2k",
    "tags": [
        "serial-communication"
    ],
    "user": "Piotr Kula",
    "time": "Nov 3, 2015 at 16:25",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  You know that 72 will be in the data each time. Lets convert that to hex which is\n  <code>\n   48\n  </code>\n  . We can see that clearly in each packet.\n </p>\n <p>\n  It's preceded by 3\n  <code>\n   0\n  </code>\n  bytes presumable because it's written out as a 32 bit int (for some reason).\n </p>\n <p>\n  preceding that we can see a\n  <code>\n   00 00 01 c9\n  </code>\n  lets convert that in its entirety to decimal: That turns out to be\n  <code>\n   457\n  </code>\n  10 times more than what another value you are looking for is.\n </p>\n <p>\n  The next set is\n  <code>\n   00 51 00 00\n  </code>\n  , maybe there is a 2 byte\n  <code>\n   0\n  </code>\n  in between this value and the next one them so lets focus on the\n  <code>\n   51\n  </code>\n  , converted to decimal that is\n  <code>\n   81\n  </code>\n  . Another value you are looking for!\n </p>\n <p>\n  The last value you are looking for is\n  <code>\n   236.1\n  </code>\n  however after seeing the energy total maybe the value was scaled first by\n  <code>\n   10\n  </code>\n  so lets check 2361 in hex, that is\n  <code>\n   0939\n  </code>\n  . Lo and behold that's in the last packet:\n  <code>\n   <pre>AA 55 00 01 01 00 11 82 32 00 A3 00 9A 06 B8 06\nB2 00 03 00 03 00 04 <strong><em>09 39</em></strong> 13 90 00 <strong><em>51</em></strong> 00 00 00\n00 <strong><em>01 C9</em></strong> 00 00 00 <strong><em>48</em></strong> 00 01 00 00 00 00 FF FF 00\n00 00 00 00 00 00 00 00 00 00 00 08 CA</pre>\n  </code>\n </p>\n <p>\n  Remember that the highest value a single hex digit (0-f) can contain is 15, put 2 of them together and you can go up to 255. Double the amount of bits again and you are at 65535. Also handy to remember is that engineers are cheap and won't put in floating point arithmetic when they can just use fixed point instead. The trick is to find the scaling factor they used.\n </p>\n</div>\n</body></html>",
            "votes": "8",
            "user": "ratchet freak",
            "time": "Nov 3, 2015 at 16:46",
            "is_accepted": true,
            "comments": []
        }
    ]
}