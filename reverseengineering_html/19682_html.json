{
    "title": "x86-64 bit Buffer Overflow, help with overwriting %rip",
    "link": "https://reverseengineering.stackexchange.com/questions/19682/x86-64-bit-buffer-overflow-help-with-overwriting-rip",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am trying to get a buffer overflow exploit to work on Ubuntu 16.04 LTS 64bit.\n </p>\n <p>\n  To this end I use the following vulnerable program:\n </p>\n <pre><code>#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main(int argc, char* argv[])\n{\n\n    char buffer[256];\n    strcpy(buffer, argv[1]);\n    printf(\"%s\n\", buffer);\n    return 0;\n}\n</code></pre>\n <p>\n  I deactivate ALSR (temporarily set\n  <code>\n   /proc/sys/kernel/randomize_va_space\n  </code>\n  to\n  <code>\n   0\n  </code>\n  ) and compile my code with\n </p>\n <pre><code>gcc vuln.c -o vuln -z execstack -fno-stack-protector\n</code></pre>\n <p>\n  I manage to overwrite\n  <code>\n   rip\n  </code>\n  with 6\n  <code>\n   B\n  </code>\n  's using\n </p>\n <pre><code>gdb$ run $(python -c 'print \"A\"*264 + \"B\"*6')\n</code></pre>\n <p>\n  and get the following result in gdb:\n </p>\n <pre><code>RSI: 0x602010 ('A' <repeats 200 times>...)\nRDI: 0x1 \nRBP: 0x4141414141414141 ('AAAAAAAA')\nRSP: 0x7fffffffd9d0 --> 0x0 \nRIP: 0x424242424242 ('BBBBBB')\nStopped reason: SIGSEGV\n0x0000424242424242 in ?? ()\n</code></pre>\n <p>\n  Which makes perfect sense to me.\n </p>\n <p>\n  I would like to overwrite\n  <code>\n   rip\n  </code>\n  with the beginning of my buffer of \"\n  <code>\n   A\n  </code>\n  \"'s so I can later place my shellcode at the beginning of the buffer (preceeded by some noop's):\n </p>\n <p>\n  So, knowing, how many\n  <code>\n   A\n  </code>\n  's I wrote in the buffer I have a look at\n  <code>\n   rsp\n  </code>\n  minus an offset (I am just playing with the offset until I get a line starting with\n  <code>\n   A\n  </code>\n  's:\n </p>\n <pre><code>gdb$ x/20x $rsp-288\n0x7fffffffd8b0: 0x00007fffffffdaa8  0x0000000200000000\n0x7fffffffd8c0: 0x4141414141414141  0x4141414141414141\n0x7fffffffd8d0: 0x4141414141414141  0x4141414141414141\n</code></pre>\n <p>\n  So, from this I am taking, that my buffer starts at\n  <code>\n   0x7fffffffd8c0\n  </code>\n  on the stack.\n </p>\n <p>\n  Next I'll redirect\n  <code>\n   rip\n  </code>\n  to\n  <code>\n   0x7fffffffd8c0\n  </code>\n  as follows:\n </p>\n <pre><code>gdb$ run $(python -c 'print \"A\"*264 + \"\\x7f\\xff\\xff\\xff\\xd8\\xc0\"[::-1]')\n</code></pre>\n <p>\n  Which works:\n </p>\n <pre><code>RBP: 0x4141414141414141 ('AAAAAAAA')\nRSP: 0x7fffffffd9d0 --> 0x0 \nRIP: 0x7fffffffd8c0 ('A' <repeats 200 times>...)\n</code></pre>\n <p>\n  As I am planning to put shellcode at the beginning of the buffer I just assume, my shellcode will be 10 bytes long and see if this works:\n </p>\n <pre><code>gdb$ run $(python -c 'print \"S\"*10 + \"A\"*254 + \"\\x7f\\xff\\xff\\xff\\xd8\\xc0\"[::-1]')\n</code></pre>\n <p>\n  and now something I don't understand happens: Despite the fact, that I write exactly the same amount of characters into my buffer, the value of\n  <code>\n   rip\n  </code>\n  changes, apparently it no longer points to the start of my buffer:\n </p>\n <pre><code>RSI: 0x602010 (\"SSSSSSSSSS\", 'A' <repeats 190 times>...)\nRDI: 0x1 \nRBP: 0x4141414141414141 ('AAAAAAAA')\nRSP: 0x7fffffffd980 --> 0x0 \nRIP: 0x7fffffffd8ca ('A' <repeats 182 times>)\n</code></pre>\n <p>\n  Instead of\n  <code>\n   0x7fffffffd8c0\n  </code>\n  <code>\n   rip\n  </code>\n  now contains\n  <code>\n   0x7fffffffd8ca\n  </code>\n  .\n </p>\n <p>\n  So it is actually still pointing to the beginning of my\n  <code>\n   A\n  </code>\n  's instead of the\n  <code>\n   S\n  </code>\n  's which I injected in my python command:\n </p>\n <pre><code>gdb-peda$ x/20 $rip-10\n0x7fffffffd8c0: 0x5353535353535353  0x4141414141415353\n0x7fffffffd8d0: 0x4141414141414141  0x4141414141414141\n</code></pre>\n <p>\n  Obviously I am just getting started with this stuff.\n </p>\n <p>\n  Why is this happening?\n </p>\n <p>\n  What am I missing?\n </p>\n</div>\n</body></html>",
    "votes": "5",
    "answers": 1,
    "views": "8k",
    "tags": [
        "buffer-overflow",
        "amd64"
    ],
    "user": "schtopps",
    "time": "Oct 22, 2018 at 8:38",
    "comments": [
        {
            "user": "perror",
            "text": "<html><body><span class=\"comment-copy\">\n Have you tried with another number of 'S' characters ? Does it work the same or is it really linked to the fact you have 0xa characters ?\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Don't worry, the shellcode is executing properly, just that the debugger \"skipped\" past the execution.\n </p>\n <p>\n  Remember that\n  <code>\n   rip\n  </code>\n  is the instruction pointer and whatever code present at the\n  <code>\n   rip\n  </code>\n  is executed. If the code is invalid however, something will go wrong (for example a SIGSEGV will be raised)\n </p>\n <p>\n  In this particular case, a\n  <code>\n   S\n  </code>\n  (byte\n  <code>\n   \\x53\n  </code>\n  ) corresponds to a\n  <code>\n   push rbx\n  </code>\n  command (which is valid, and push 8 bytes to the stack), while an\n  <code>\n   A\n  </code>\n  is a\n  <code>\n   rex.B\n  </code>\n  - basically speaking, it causes a SIGSEGV in this case.\n </p>\n <p>\n  So in the latter case, ten\n  <code>\n   push rbx\n  </code>\n  commands get executed. (note the\n  <code>\n   esp\n  </code>\n  is decreased by\n  <code>\n   0x7fffffffd9d0 - 0x7fffffffd980 = 0x50\n  </code>\n  , which is 10 times the size of\n  <code>\n   rbx\n  </code>\n  )\n </p>\n <p>\n  What you can do instead: Break at the\n  <code>\n   ret\n  </code>\n  instruction in the\n  <code>\n   main\n  </code>\n  function. After the breakpoint is hit, execute 1 more instruction then the\n  <code>\n   rip\n  </code>\n  should have the desired value.\n </p>\n</div>\n</body></html>",
            "votes": "6",
            "user": "user202729",
            "time": "Oct 22, 2018 at 10:27",
            "is_accepted": true,
            "comments": []
        }
    ]
}