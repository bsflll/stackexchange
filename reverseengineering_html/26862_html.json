{
    "title": "How to simplify a function \"calling itself's reference\"",
    "link": "https://reverseengineering.stackexchange.com/questions/26862/how-to-simplify-a-function-calling-itselfs-reference",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I encounter often a function calling itself (in the pseudo code) such as:\n </p>\n <pre><code>result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))lambda)(lambda);\n</code></pre>\n <ol>\n  <li>\n   Since the disassembly is\n   <code>\n    call qword ptr [rax]\n   </code>\n   , can't this be simplified into\n   <code>\n    result = lambda();\n   </code>\n   if I translate the pseudo code in c ?\n  </li>\n  <li>\n   Why in the pseudo code the function is having itself as argument ?\n  </li>\n  <li>\n   What is happening when there is a call such as\n   <code>\n    lambda + 8i64\n   </code>\n   ?\n  </li>\n </ol>\n <p>\n  Here a more complete context:\n </p>\n <pre><code>__int64 __fastcall CR_maybeParseWithLambda(_QWORD *a1, __int64 newPtr, __int64 positionOrCounter)\n{\n  volatile signed __int32 *lambda; // rdi\n  __int64 result; // rax\n\n  lambda = (volatile signed __int32 *)a1[1];\n  if ( lambda )\n  {\n    result = (unsigned int)_InterlockedExchangeAdd(lambda + 2, 0xFFFFFFFF);\n    if ( (_DWORD)result == 1 )\n    {\n      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))lambda)(lambda);\n      if ( _InterlockedExchangeAdd(lambda + 3, 0xFFFFFFFF) == 1 )\n        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)lambda + 8i64))(lambda);\n      a1[1] = positionOrCounter;\n      *a1 = newPtr;\n    }\n    else\n    {\n      a1[1] = positionOrCounter;\n      *a1 = newPtr;\n    }\n  }\n  else\n  {\n    a1[1] = positionOrCounter;\n    *a1 = newPtr;\n  }\n  return result;\n}\n</code></pre>\n <p>\n  The disassembly:\n </p>\n <pre><code>.text:0000000180005F70 ; __int64 __fastcall CR_maybeParseWithLambda(_QWORD *a1, __int64 newPtr, __int64 positionOrCounter)\n.text:0000000180005F70 CR_maybeParseWithLambda proc near       ; CODE XREF: sub_180005B10+10F↑p\n.text:0000000180005F70                                         ; sub_180005B10+14A↑p ...\n.text:0000000180005F70\n.text:0000000180005F70 arg_0           = qword ptr  8\n.text:0000000180005F70 arg_8           = qword ptr  10h\n.text:0000000180005F70 arg_10          = qword ptr  18h\n.text:0000000180005F70 arg_18          = qword ptr  20h\n.text:0000000180005F70\n.text:0000000180005F70                 mov     [rsp+arg_8], rbx\n.text:0000000180005F75                 mov     [rsp+arg_10], rbp\n.text:0000000180005F7A                 mov     [rsp+arg_18], rsi\n.text:0000000180005F7F                 push    rdi\n.text:0000000180005F80                 sub     rsp, 20h\n.text:0000000180005F84                 mov     rdi, [rcx+8]\n.text:0000000180005F88                 mov     rsi, r8\n.text:0000000180005F8B                 mov     rbp, rdx\n.text:0000000180005F8E                 mov     rbx, rcx\n.text:0000000180005F91                 test    rdi, rdi\n.text:0000000180005F94                 jz      short loc_180005FF3\n.text:0000000180005F96\n.text:0000000180005F96 loc_180005F96:                          ; DATA XREF: .rdata:0000000180401E74↓o\n.text:0000000180005F96                                         ; .rdata:0000000180401E84↓o ...\n.text:0000000180005F96                 mov     [rsp+28h+arg_0], r14\n.text:0000000180005F9B                 or      r14d, 0FFFFFFFFh\n.text:0000000180005F9F                 mov     eax, r14d\n.text:0000000180005FA2                 lock xadd [rdi+8], eax\n.text:0000000180005FA7                 cmp     eax, 1\n.text:0000000180005FAA                 jnz     short loc_180005FEA\n.text:0000000180005FAC                 mov     rax, [rdi]\n.text:0000000180005FAF                 mov     rcx, rdi\n.text:0000000180005FB2                 call    qword ptr [rax]\n.text:0000000180005FB4                 lock xadd [rdi+0Ch], r14d\n.text:0000000180005FBA                 cmp     r14d, 1\n.text:0000000180005FBE                 jnz     short loc_180005FC9\n.text:0000000180005FC0                 mov     rax, [rdi]\n.text:0000000180005FC3                 mov     rcx, rdi\n.text:0000000180005FC6                 call    qword ptr [rax+8]\n.text:0000000180005FC9\n.text:0000000180005FC9 loc_180005FC9:                          ; CODE XREF: CR_maybeParseWithLambda+4E↑j\n.text:0000000180005FC9                 mov     [rbx+8], rsi\n.text:0000000180005FCD                 mov     [rbx], rbp\n.text:0000000180005FD0\n.text:0000000180005FD0 loc_180005FD0:                          ; CODE XREF: CR_maybeParseWithLambda+81↓j\n.text:0000000180005FD0                 mov     r14, [rsp+28h+arg_0]\n.text:0000000180005FD5\n.text:0000000180005FD5 loc_180005FD5:                          ; CODE XREF: CR_maybeParseWithLambda+8A↓j\n.text:0000000180005FD5                                         ; DATA XREF: .pdata:0000000180483888↓o ...\n.text:0000000180005FD5                 mov     rbx, [rsp+28h+arg_8]\n.text:0000000180005FDA                 mov     rbp, [rsp+28h+arg_10]\n.text:0000000180005FDF                 mov     rsi, [rsp+28h+arg_18]\n.text:0000000180005FE4                 add     rsp, 20h\n.text:0000000180005FE8                 pop     rdi\n.text:0000000180005FE9                 retn\n</code></pre>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 1,
    "views": "159",
    "tags": [
        "ida",
        "disassembly",
        "assembly",
        "c",
        "static-analysis"
    ],
    "user": "Soleil",
    "time": "Jan 24, 2021 at 22:54",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  It's not calling itself; you're overlooking the\n  <code>\n   *\n  </code>\n  dereferences at the beginning of the call expression. As in:\n </p>\n <p>\n  <code>\n   result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))lambda)(lambda);\n  </code>\n </p>\n <p>\n  Notice the two\n  <code>\n   **\n  </code>\n  inside of the first parenthesis? It's dereferencing the address held in the variable named\n  <code>\n   lambda\n  </code>\n  , which the assembly makes clear:\n </p>\n <pre><code>.text:0000000180005FAC    mov     rax, [rdi]      ; dereference #1\n.text:0000000180005FAF    mov     rcx, rdi\n.text:0000000180005FB2    call    qword ptr [rax] ; dereference #2\n</code></pre>\n <p>\n  This is a call to a virtual function.\n  <code>\n   #1\n  </code>\n  loads the VTable pointer out of the object;\n  <code>\n   #2\n  </code>\n  calls the function pointer at\n  <code>\n   +0\n  </code>\n  into the VTable.\n </p>\n <p>\n  In general, this is always going to look nasty in the decompilation before you have created a structure type for\n  <code>\n   lambda\n  </code>\n  , and a second type for its VTable. Once you do that, it will show you something pretty like this (taken from\n  <a href=\"https://www.msreverseengineering.com/blog/2020/8/31/an-exhaustively-analyzed-idb-for-comrat-v4\" rel=\"nofollow noreferrer\">\n   my ComRAT IDB\n  </a>\n  ):\n </p>\n <pre><code>if ( v9 )\n{\n  if ( !_InterlockedDecrement(&v9->_Uses) )\n  {\n    v9->_Destroy(v9);\n    if ( !_InterlockedDecrement(&v9->_Weaks) )\n      v9->_Delete_this(v9);\n  }\n}\n</code></pre>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Rolf Rolles",
            "time": "Jan 25, 2021 at 8:57",
            "is_accepted": false,
            "comments": []
        }
    ]
}