{
    "title": "What is Hardware Breakpoint and when we need to use it?",
    "link": "https://reverseengineering.stackexchange.com/questions/28045/what-is-hardware-breakpoint-and-when-we-need-to-use-it",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  In part 5 of the lena151 RE tutorial I saw the Hardware BP.\nThe explanation he gave was very difficult for me to understand.\n </p>\n <p>\n  Can anyone explain what is a hardware breakpoint and when we need to use it?\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "2k",
    "tags": [
        "breakpoint"
    ],
    "user": "Jason",
    "time": "Jul 26, 2021 at 7:39",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <strong>\n   The short answer:\n  </strong>\n </p>\n <p>\n  From the user point of view, software breakpoints are\n  <em>\n   only for instructions,\n  </em>\n  and you may set them\n  <em>\n   as many as you want\n  </em>\n  , while hardware breakpoints are\n  <em>\n   universal,\n  </em>\n  but you may use only a few of them (typically 4) at the same time.\n </p>\n <p>\n  <strong>\n   TL,DR;\n  </strong>\n </p>\n <p>\n  The hardware breakpoints are implemented by a special logic circuit\n  <em>\n   integrated directly in the CPU,\n  </em>\n  connected to\n </p>\n <ul>\n  <li>\n   the\n   <em>\n    address bus\n   </em>\n   on the one side, and\n  </li>\n  <li>\n   the special\n   <em>\n    debug registers\n   </em>\n   on the other one.\n  </li>\n </ul>\n <p>\n  <a href=\"https://i.sstatic.net/OFzl3.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/OFzl3.png\"/>\n  </a>\n </p>\n <p>\n  To set a hardware breakpoint, you fill the debug registers (generally indirectly by your debugger) with this information:\n </p>\n <ul>\n  <li>\n   the (starting)\n   <strong>\n    address\n   </strong>\n   ,\n  </li>\n  <li>\n   the\n   <strong>\n    length\n   </strong>\n   (byte, word, or double-word),\n  </li>\n  <li>\n   the\n   <strong>\n    access mode\n   </strong>\n   to watch for (read, read/write, or instruction execution),\n  </li>\n  <li>\n   the\n   <strong>\n    local/global\n   </strong>\n   mode (not used for the decision whether the code execution have to break).\n  </li>\n </ul>\n <p>\n  You may do it only for small number of addresses, it's hardware dependent, the common number is 2 to 6 (e.g. for x86 you may set 4 hardware breakpoints: addresses are written to the\n  <em>\n   debug registers DB0 to DB3\n  </em>\n  , while other info — for all addresses individually as appropriate bit flags — to the\n  <em>\n   DB7 register\n  </em>\n  ).\n </p>\n <p>\n  The circuit watches every access to the memory (RAM or ROM) and\n  <em>\n   compares address, length, and access mode\n  </em>\n  with values in the debug registers. If they correspond, the circuit sends the Halt signal and the debugger interrupts the execution of the debugged program.\n </p>\n <hr/>\n <p>\n  So the\n  <strong>\n   differences\n  </strong>\n  between hardware breakpoints (HB) and software ones (SB) are:\n </p>\n <ol>\n  <li>\n   <p>\n    In the\n    <strong>\n     number of them\n    </strong>\n    :\n   </p>\n   <ul>\n    <li>\n     you may set\n     <em>\n      as many SBs as you wish,\n     </em>\n     but\n    </li>\n    <li>\n     only\n     <em>\n      very small number of HBs\n     </em>\n     (typically 4).\n    </li>\n   </ul>\n  </li>\n  <li>\n   <p>\n    In\n    <strong>\n     usability\n    </strong>\n    :\n   </p>\n   <ul>\n    <li>\n     SB is set to a\n     <em>\n      particular instruction\n     </em>\n     (there is no way to set them for memory access), while\n    </li>\n    <li>\n     HB is set to address ranges and for the desired access mode.\n    </li>\n   </ul>\n  </li>\n  <li>\n   <p>\n    In the applicable\n    <strong>\n     type of memory\n    </strong>\n    :\n   </p>\n   <ul>\n    <li>\n     SB\n     <em>\n      writes\n     </em>\n     into memory (the\n     <code>\n      INT 3\n     </code>\n     instruction in the place of the first byte of the watched instruction), so\n     <em>\n      it is not capable to set a breakpoint for instruction in read-only memory (ROM),\n     </em>\n     while\n    </li>\n    <li>\n     HB don't write anything into memory, so it has not such a limitation.\n    </li>\n   </ul>\n  </li>\n  <li>\n   <p>\n    In the\n    <strong>\n     speed\n    </strong>\n    (hardware is always faster than software, so HB is faster than SB).\n   </p>\n  </li>\n </ol>\n <p>\n  For example, if you know the address of some string in memory and you are interested\n  <em>\n   when\n  </em>\n  it will be read, SB doesn't help you, but HW does.\n </p>\n <hr/>\n <p>\n  Some references:\n </p>\n <ul>\n  <li>\n   <a href=\"https://wiki.osdev.org/CPU_Registers_x86-64#DR0_-_DR3\" rel=\"nofollow noreferrer\">\n    Debug registers for x86\n   </a>\n  </li>\n  <li>\n   <a href=\"https://hypervsir.blogspot.com/2014/09/debug-registers-on-intel-x86-processor.html\" rel=\"nofollow noreferrer\">\n    Debug Registers on Intel x86 Processor Architecture (with or without VT-x)\n   </a>\n  </li>\n  <li>\n   <a href=\"https://www.sandpile.org/x86/drx.htm\" rel=\"nofollow noreferrer\">\n    x86 architecture debug registers\n   </a>\n  </li>\n </ul>\n</div>\n</body></html>",
            "votes": "4",
            "user": "MarianD",
            "time": "Jul 26, 2021 at 10:12",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Jeremy",
                    "text": "<span class=\"comment-copy\">In actual practice of applying dynamic analysis on code with a debugger, the difference that really is significant is that software breakpoints can be overwritten (and modify contents of program memory). This is especially important if you are dealing with self -modifying code or code that writes to the executable sections of memory (ie unpackers) For example if you know OEP is at address X and you want to run till you hit that address from EP, you need to use a hw breakpoint because the unpacking stub will overwrite your int3 breakpoint at oep. Other more complex nuances as well.</span>",
                    "time": null
                }
            ]
        }
    ]
}