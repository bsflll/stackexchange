{
    "title": "Why is mhook failing to hook my function?",
    "link": "https://reverseengineering.stackexchange.com/questions/3565/why-is-mhook-failing-to-hook-my-function",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  So I'm exploring mhook 2.3 and have build a sample executable specifically for this purpose.  I have an injector that injects a dll containing mhook into the target process.\n </p>\n <p>\n  This all works correctly and I can verify that my code is being called by the target process by checking my log file.\n </p>\n <p>\n  However, when I go to hook my target function mhook simply returns and says that it failed to hook the function.  I've used OllyDBG and IDA to verify that the address for the target function that I'm passing in to mhook is correct and the function signature for the trampoline is exactly the same as the target function but it still fails.\n </p>\n <p>\n  I'm at my wits end.  Can someone please tell me what I'm doing wrong here?\n </p>\n <p>\n  Here is the target program that I've built.  It's a simple Windows console application that prints out a random message every second.\n </p>\n <pre><code>// reverse me.cpp : This is the program that I will be attempting to hook into.\n//\n\n#include \"stdafx.h\"\n\n#include <stdlib.h>\n#include <Windows.h>\n#include <Psapi.h>\n#include <string>\n\nclass blargClass1\n{\npublic:\n    blargClass1();\n    void WINAPI blargFunction1(void);\n};\n\n__declspec(noinline) blargClass1::blargClass1()\n{\n    printf(\"blargClass1::blargClass1\n\");\n};\n\n__declspec(noinline) void  WINAPI blargClass1::blargFunction1( void )\n{\n    switch( rand() % 10 + 1 )\n    {\n    case 1:\n        printf(\"blargFunction1 - case 1\n\");\n        break;\n    case 2:\n        printf(\"blargFunction1 - case 2\n\");\n        break;\n    case 3:\n        printf(\"blargFunction1 - case 3\n\");\n        break;\n    case 4:\n        printf(\"blargFunction1 - case 4\n\");\n        break;\n    case 5:\n        printf(\"blargFunction1 - case 5\n\");\n        break;\n    default:\n        printf(\"blargFunction1 - default\n\");\n    }\n};\n\n#pragma comment( lib, \"psapi.lib\")\n\nDWORD GetCurrentModuleBase( LPWSTR targetModule )\n{ \n    HMODULE hMods[1024];\n    HANDLE hProcess;\n    DWORD cbNeeded;\n    DWORD baseAddress = -1;\n    unsigned int i;\n\n    // Get the current process id.\n    DWORD processID = GetCurrentProcessId();\n    printf( \"GetCurrentProcessId = %u\n\", processID );\n\n    // Get a handle to the process.\n    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID );\n\n    // Sanity checking on process handle.\n    if( hProcess == NULL )\n    {\n        printf( \"hProcess is NULL.\n\" );\n        return 1;\n    }\n\n   // Get a list of all the modules in this process.\n    if( EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))\n    {\n        // Iterate through each module\n        for ( i = 0; i < (cbNeeded / sizeof(HMODULE)); i++ )\n        {\n            WCHAR szModName[MAX_PATH];\n\n            // Get the full path to the module's file.\n            if ( GetModuleFileNameEx( hProcess, hMods[i], szModName, sizeof(szModName) / sizeof(TCHAR)))\n            {\n                // Print the module name and handle value.\n                //wprintf( L\"\\t%s (0x%08X)\n\", szModName, hMods[i] );\n\n                // Is this the module that we're looking for?\n                std::wstring moduleName = szModName;\n                if( moduleName.find( targetModule ) != std::wstring::npos )\n                {\n                    baseAddress = (DWORD)hMods[i];\n                }\n            }\n\n        }\n    }\n\n    // Release the handle to the process.\n    CloseHandle( hProcess );\n\n    return baseAddress;\n}\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    blargClass1 blarg_class_1;\n\n    printf( \"GetCurrentModuleBase = 0x%08X\n\", GetCurrentModuleBase( L\"reverse me.exe\" ) );\n\n    while( true )\n    {\n\n        // Call the target function\n        blarg_class_1.blargFunction1();\n\n        Sleep(1000);\n    }\n\n    return 0;\n};\n</code></pre>\n <p>\n  And here is the DLL containing the mhook code that I inject into that process.  All I'm trying to do is hook blargFunction1 so that it prints out an additional line when it's called.\n </p>\n <pre><code>//SimpleDLL.cpp\n#include \"Stdafx.h\"\n#include \"SimpleDLL.h\"\n#include \"mhook-lib/mhook.h\"\n#include <Psapi.h>\n#include <string>\n#include <wchar.h>\n\n// Open the log file.\nFILE *file;\n\n//=========================================================================\n// Define the target functions so we can dynamically bind to the function\n//\ntypedef void (WINAPI *_blargFunction1)( void );\n\n\n//=========================================================================\n// Get the current (original) address to the functions to be hooked\n//\n_blargFunction1 TrueBlargFunction1 = (_blargFunction1)(0x1770);\n\n//=========================================================================\n// This is the function that will replace the target function once the hook \n// is in place\n//\nvoid WINAPI blargFunction1(void)\n{\n    fprintf( file, \"***** Call to blargFunction1 from mhook sample.\n\");\n    return TrueBlargFunction1();\n}\n\n#pragma comment(lib, \"psapi.lib\")\n\nDWORD GetCurrentModuleBase( LPWSTR targetModule )\n{ \n    HMODULE hMods[1024];\n    HANDLE hProcess;\n    DWORD cbNeeded;\n    DWORD baseAddress = -1;\n    unsigned int i;\n\n    // Get the current process id.\n    DWORD processID = GetCurrentProcessId();\n    fprintf( file, \"Process ID: %u\n\", processID );\n\n    // Get a handle to the process.\n    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID );\n\n    // Sanity checking on process handle.\n    if( hProcess == NULL )\n    {\n        fprintf( file, \"hProcess is NULL.\n\" );\n        return 1;\n    }\n\n   // Get a list of all the modules in this process.\n    if( EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))\n    {\n        // Iterate through each module\n        for ( i = 0; i < (cbNeeded / sizeof(HMODULE)); i++ )\n        {\n            WCHAR szModName[MAX_PATH];\n\n            // Get the full path to the module's file.\n            if ( GetModuleFileNameEx( hProcess, hMods[i], szModName, sizeof(szModName) / sizeof(TCHAR)))\n            {\n                // Print the module name and handle value.\n                //fwprintf( file, L\"\\t%s (0x%08X)\n\", szModName, hMods[i] );\n\n                // Is this the module that we're looking for?\n                std::wstring moduleName = szModName;\n                if( moduleName.find( targetModule ) != std::wstring::npos )\n                {\n                    //fprintf( file, \"Found it.\n\");\n\n                    baseAddress = (DWORD)hMods[i];\n                }\n            }\n\n        }\n    }\n\n    // Release the handle to the process.\n    CloseHandle( hProcess );\n\n    return baseAddress;\n}\n\n\nextern \"C\" int WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved ) {\n\n    time_t now = time(NULL);\n    struct tm nowTM;\n    char datetime[32];\n    DWORD baseAddress = 0;\n\n    localtime_s( &nowTM, &now );\n\n    // Generate a date/time string.\n    strftime(datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM);\n\n    fopen_s( &file, \"simpledll.log\", \"a+\");\n\n    // Perform different actions based on why this function is being called.\n    switch( fdwReason )\n    {\n        case DLL_PROCESS_ATTACH:\n\n            fprintf(file, \"----------------------------------\n\");\n            fprintf(file, \"%s SimpleDll - DLL_PROCESS_ATTACH.\n\",  datetime);\n\n            // Determine the base address of this process.\n            baseAddress = GetCurrentModuleBase( L\"reverse me.exe\" );\n            strftime(datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM);\n            fprintf( file, \"%s SimpleDll - GetCurrentModuleBase = 0x%08X\n\", datetime, baseAddress );\n\n            // Determine the memory address of the target function.\n            TrueBlargFunction1 = (_blargFunction1)( (DWORD)TrueBlargFunction1 + baseAddress);\n            strftime( datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM );\n            fprintf( file, \"%s SimpleDll - TrueBlargFunction1 = 0x%08X.\n\",  datetime, TrueBlargFunction1 );\n\n            //strftime(datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM);\n            //fprintf(file, \"%s SimpleDll - Before Mhook_SetHook.\n\",  datetime);\n\n            // Set the hook\n            if( Mhook_SetHook( (PVOID*)&TrueBlargFunction1, blargFunction1) ) \n            {\n                strftime(datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM);\n                fprintf(file, \"%s SimpleDll - Successfully set hook.\n\",  datetime);\n\n                // Remove the hook\n                //Mhook_Unhook((PVOID*)&TrueBlargFunction1);\n\n                //strftime(datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM);\n                //fprintf(file, \"%s SimpleDll - Unset hook.\n\",  datetime);\n\n            }\n            else\n            {\n                strftime(datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM);\n                fprintf(file, \"%s SimpleDll - Failed to set hook.\n\",  datetime);\n            }\n\n            strftime(datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM);\n            fprintf(file, \"%s SimpleDll - After Mhook_SetHook.\n\",  datetime);\n\n            break;\n\n        case DLL_PROCESS_DETACH:\n            strftime(datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM);\n            fprintf(file, \"%s SimpleDll - DLL_PROCESS_DETACH.\n\",  datetime);\n            break;\n        case DLL_THREAD_ATTACH:\n            strftime(datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM);\n            fprintf(file, \"%s SimpleDll - DLL_THREAD_ATTACH.\n\",  datetime);\n            break;\n        case DLL_THREAD_DETACH:\n            strftime(datetime, 32, \"%Y%m%d %H:%M:%S\", &nowTM);\n            fprintf(file, \"%s SimpleDll - DLL_THREAD_DETACH.\n\",  datetime);\n            break;\n    }\n\n    fclose( file );\n\n    return TRUE;\n};\n</code></pre>\n <p>\n  Addendum: I'm using a Windows 32 bit environment because ultimately I'll be trying this approach on an older legacy 32 bit application and the injector doesn't seem to work unless they're on the same platform.\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "1k",
    "tags": [
        "ida",
        "windows",
        "ollydbg",
        "c++"
    ],
    "user": "blargfoot",
    "time": "Jan 27, 2014 at 17:18",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<html><body><span class=\"comment-copy\">\n Just curious, how come you make this weird assumption about the address of\n <code>\n  TrueBlargFunction1\n </code>\n and don't follow the example given on the project's website and use\n <code>\n  GetProcAddress\n </code>\n ?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "blargfoot",
            "text": "<html><body><span class=\"comment-copy\">\n Well, all of my assumptions are probably weird but which one are you referring to?    I have implemented the example from mhooks documentation and it works correctly so I know the platform is sound and my ide works.  I'm sure I'm doing something else wrong but can't figure out what it is.  Oh, if you mean the 0x1770 magic number.  That's the offset that I found for the start of blargFunction1 in the executable.  I verified it through decompiling it with both IDA and OllyDbg.  I take that offset and add it to the base address of the module to determine the location in memory to insert my hook.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "0xC0000022L",
            "text": "<html><body><span class=\"comment-copy\">\n Uhm, nope ... it reads:\n <code>\n  _blargFunction1 TrueBlargFunction1 = (_blargFunction1)(0x1770);\n </code>\n ... that address is likely not even in the address range of the module anyway.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "blargfoot",
            "text": "<html><body><span class=\"comment-copy\">\n I agree.  0x1770 represents the offset from the base address of the module, not the address of the function in memory.  I determine the base address of the module after the dll has been loaded into the target process space and add the offset to that. // Determine the memory address of the target function. TrueBlargFunction1 = (_blargFunction1)( (DWORD)TrueBlargFunction1 + baseAddress);  In theory, it should give me the address of the target function in memory.  Of course, something's wrong somewhere so I could be completely off base.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  This is more a comment than an answer (but comments are to short and limited in formatting), so I'll make it community wiki:\n </p>\n <pre><code>EXTERN_C IMAGE_DOS_HEADER __ImageBase;\n#define GetCurrentModuleBase() ((HMODULE)&__ImageBase)\n</code></pre>\n <p>\n  Basically you can save the effort with your implementation completely and use the above as a replacement. Also, the era of 32bit-only-Windows is over. Using\n  <code>\n   DWORD\n  </code>\n  for a memory address is improper and definitely out of style by now.\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "2 revs, 2 users 72%0xC0000022L",
            "time": "Sep 19, 2014 at 0:19",
            "is_accepted": false,
            "comments": [
                {
                    "user": "blargfoot",
                    "text": "<span class=\"comment-copy\">Thank you for the useful function.  That certainly helps!  Unfortunately, my hands are tied with Win32.  Ultimately, I'll be using this technique on a legacy Win32 application and am locked into that platform.  Bearing that in mind, what would you suggest as an alternative to DWORD for my memory values?</span>",
                    "time": null
                },
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">@blargfoot: easy, <code>HMODULE</code> is the proper type in this particular case and <code>DWORD_PTR</code> a sensible one, as well. <code>DWORD</code> on the other hand isn't.</span>",
                    "time": null
                },
                {
                    "user": "evlncrn8",
                    "text": "<span class=\"comment-copy\">legacy win32 or not, doesnt matter.. the __ImageBase is a linker directive, the linker does it for you, and adds the reloc information if you're making a dll, so you are not locked at all..      also, are you trying to inject into yourself? why not just loadlibrary the injectable, as for getting your own base .. GetModuleHandle(NULL) kinda works, if you're still not wanting to do the __ImageBase method..       and is the compiler actually compiling the function, or is it making it a vtable (you have defined it as a class) ?...</span>",
                    "time": null
                }
            ]
        }
    ]
}