{
    "title": "Reversing an obfuscation through a long linear switch statement",
    "link": "https://reverseengineering.stackexchange.com/questions/29950/reversing-an-obfuscation-through-a-long-linear-switch-statement",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have a program (ELF, 32 bits) that is probably quite short and simple, but which have been obfuscated with the following construction:\n </p>\n <pre><code>i = 0\nswitch(i):\n    case 0:\n        one small instruction\n        i = 1\n    case 1:\n        one small instruction\n        i = 2\n    case 2:\n        ....\n</code></pre>\n <p>\n  An example of assembly would be:\n </p>\n <pre><code>loc_804E5E8:                                                             \n                pop     eax             \n                push    eax\n                mov     eax, 20h\n                push    eax\n                mov     eax, 4B3h\n                jmp     loc_804FE24\n</code></pre>\n <p>\n  where loc_804FE24 contains the loading of the offset from the table, and the\n  <code>\n   jmp eax\n  </code>\n  .\n </p>\n <p>\n  There are some minor differences sometimes, it is not always perfectly linear like this, but it mostly follow this schema. How should I approach the reversing of this program? I'm pretty sure there is a simple and basic way to handle this, but I am pretty new to the field of reverse engineering. Thank you.\n </p>\n <p>\n  EDIT : if there is a way to recover all the instructions that are effectively executed one after the another, maybe writing a parser would be efficient ?\n </p>\n <p>\n  EDIT2 : I wondered if using a symbolic execution engine would be appropriate or not. Based on\n  <a href=\"https://doar-e.github.io/blog/2013/09/16/breaking-kryptonites-obfuscation-with-symbolic-execution/\" rel=\"nofollow noreferrer\">\n   this link\n  </a>\n  , symbolic execution is best used when:\n </p>\n <ul>\n  <li>\n   there is no branches, no loops,\n  </li>\n  <li>\n   the instruction aren't playing with the EFLAGS register.\n  </li>\n  <li>\n   the instruction only used 32 bits registers (not 16 bits, or 8 bits).\n  </li>\n  <li>\n   the number of unique instruction is really small (i.e. only mov, shr, shl, xor, and, xor, add)\n  </li>\n  <li>\n   the instructions used are easy to emulate.\n  </li>\n </ul>\n <p>\n  though in my case, there are a couple branches, some EFLAGS uses with\n  <code>\n   pushf / popf\n  </code>\n  , and some low sized registers. But if this approach really isn't pertinent here, I really am at a loss for ideas.\n </p>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 2,
    "views": "515",
    "tags": [
        "c",
        "elf",
        "deobfuscation"
    ],
    "user": "Katoptriss",
    "time": "Feb 3, 2022 at 11:23",
    "comments": [
        {
            "user": "sudhackar",
            "text": "<html><body><span class=\"comment-copy\">\n Can you attach the ELF as well?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Katoptriss",
            "text": "<html><body><span class=\"comment-copy\">\n Sorry, I can't.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Johann Aydinbas",
            "text": "<html><body><span class=\"comment-copy\">\n This technique is called \"control-flow flattening\"! People have dealt with it in all kinds of ways and the term itself should lead you to further reading but I'm not aware of a finished applicable solution. You'll probably have to tailor something to your exact use case.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <blockquote>\n  <p>\n   if there is a way to recover all the instructions that are effectively\nexecuted one after the another\n  </p>\n </blockquote>\n <p>\n  do you mean you need to automatically single step each instruction and log the results including registers ?\n </p>\n <p>\n  if that is what you are looking for then some emulators like unicorn\nor unicorn based Qiling should be able to do that  have you checked them out ?\n </p>\n <p>\n  here is a small src and emulation of a windows executable\n </p>\n <p>\n  source\n </p>\n <pre><code>:\\>cat mcall.cpp\nint foo(int a, int b, int c);\nint main(void)\n{\n    int p = foo(1, 2, 3);\n    int q = foo(8, 7, 6);\n    int r = foo(3, 4, 5);\n    int s = foo(1, 1, 5);\n    int t = foo(8, 8, 5);\n    int u = foo(5, 5, 5);\n    return foo(p, q, r) * foo(s, t, u);\n}\nint foo(int a, int b, int c)\n{\n    return a + b + c;\n}\n:\\>\n</code></pre>\n <p>\n  compiled as x64 under win 10 using vs community dev prompt\n  \n\n  most of the arguments are not required\n  \n\n  unless you are trying to build a teensy executable with just one section and one header with no crt or no imports and no debug info\n </p>\n <pre><code>:\\>cat complink.bat\ncl /W4 /analyze:autolog- /Gs- /Od %1.cpp /link /release /FIXED /ENTRY:main /SUBSYSTEM:WINDOWS /DYNAMICBASE:NO /MERGE:.rdata=.text /MERGE:.pdata=.text\n:\\>\n</code></pre>\n <p>\n  compiled executable details\n </p>\n <pre><code>:\\>file mcall.exe\nmcall.exe: PE32+ executable (GUI) x86-64, for MS Windows\n\n:\\>ls -lg mcall.exe\n-rwxr-xr-x 1 197121 1536 Feb  3 18:51 mcall.exe\n</code></pre>\n <p>\n  using Qiling to emulate from start to end\n </p>\n <pre><code>:\\>cat qilthis.py\nimport os\nimport sys\nfrom qiling import *\nfrom qiling.const import QL_VERBOSE\nfrom qiling.extensions import trace\nos.system('')\nrootfs = r\"F:\\QILING\\examples\\rootfs\\x8664_windows\"\nql = Qiling([sys.argv[1]],rootfs,verbose=QL_VERBOSE.DEBUG,stop_on_exit_trap=True)\ntrace.enable_full_trace(ql)\nql.run()\n:\\>\n</code></pre>\n <p>\n  traced the main() and sub-function foo(x,y,z) and logged results.\n </p>\n <pre><code>:\\>python qilthis.py mcall.exe\n[+] Profile: Default\n[+] Windows Registry PATH: F:\\QILING\\examples\\rootfs\\x8664_windows\\Windows\\registry\n[=] Initiate stack address at 0x7ffffffde000\n[=] Loading mcall.exe to 0x140000000\n[=] PE entry point at 0x1400010e0\n[=] TEB addr is 0x6000030\n[=] PEB addr is 0x60000b8\n[=] Loading F:\\QILING\\examples\\rootfs\\x8664_windows\\Windows\\System32\ntdll.dll ...\n[!] Warnings while loading F:\\QILING\\examples\\rootfs\\x8664_windows\\Windows\\System32\ntdll.dll:\n[!]  - SizeOfHeaders is smaller than AddressOfEntryPoint: this file cannot run under Windows 8.\n[!]  - AddressOfEntryPoint lies outside the sections' boundaries. AddressOfEntryPoint: 0x0\n[+] DLL preferred base address: 0x180000000\n[=] Done with loading F:\\QILING\\examples\\rootfs\\x8664_windows\\Windows\\System32\ntdll.dll\n[=] Loading F:\\QILING\\examples\\rootfs\\x8664_windows\\Windows\\System32\\kernel32.dll ...\n[+] DLL preferred base address: 0x180000000\n[+] DLL preferred base address is taken, loading to: 0x1801f0000\n[=] Done with loading F:\\QILING\\examples\\rootfs\\x8664_windows\\Windows\\System32\\kernel32.dll\n[+] Done with loading mcall.exe\n[+] Setting up exit trap at 0x0x140002000\n[+] 1400010e0 | b848000000         mov        eax, 0x48               |\n[+] 1400010e5 | e8e6000000         call       0x1400011d0             | rsp = 0x0, rip = 0x0\n[+] 1400011d0 | 4883ec10           sub        rsp, 0x10               | rsp = 0x0\n[+] 1400011d4 | 4c891424           mov        qword ptr [0x0], r10    | rsp = 0x0, r10 = 0x0\n[+] 1400011d8 | 4c895c2408         mov        qword ptr [0x8], r11    | rsp = 0x0, r11 = 0x0\n[+] 1400011dd | 4d33db             xor        r11, r11                | r11 = 0x0\n[+] 1400011e0 | 4c8d542418         lea        r10, [0x18]             | rsp = 0x0\n[+] 1400011e5 | 4c2bd0             sub        r10, rax                | r10 = 0x0, rax = 0x80000001d000\n[+] 1400011e8 | 4d0f42d3           cmovb      r10, r11                | rflags = 0x14, r10 = 0x0, r11 = 0x0\n[+] 1400011ec | 654c8b1c2510000000 mov        r11, qword ptr [0x10]   | gs = 0x11ec\n[+] 1400011f5 | 4d3bd3             cmp        r10, r11                | r10 = 0x0, r11 = 0x0\n[+] 1400011f8 | f27317             bnd jae    0x140001212             | rflags = 0x4\n[+] 140001212 | 4c8b1424           mov        r10, qword ptr [0x0]    | rsp = 0x0\n[+] 140001216 | 4c8b5c2408         mov        r11, qword ptr [0x8]    | rsp = 0x0\n[+] 14000121b | 4883c410           add        rsp, 0x10               | rsp = 0x0\n[+] 14000121f | f2c3               bnd ret                            | rsp = 0x0\n[+] 1400010ea | 482be0             sub        rsp, rax                | rsp = 0x0, rax = 0x80000001d000\n[+] 1400010ed | 41b803000000       mov        r8d, 0x3                |\n[+] 1400010f3 | ba02000000         mov        edx, 0x2                |\n[+] 1400010f8 | b901000000         mov        ecx, 0x1                |\n[+] 1400010fd | e8aeffffff         call       0x1400010b0             | rsp = 0x0, rip = 0x0\n[+] 1400010b0 | 4489442418         mov        dword ptr [0x18], r8d   | rsp = 0x0, r8d = 0x0\n[+] 1400010b5 | 89542410           mov        dword ptr [0x10], edx   | rsp = 0x0, edx = 0x2\n[+] 1400010b9 | 894c2408           mov        dword ptr [0x8], ecx    | rsp = 0x0, ecx = 0x1\n[+] 1400010bd | 8b442410           mov        eax, dword ptr [0x10]   | rsp = 0x0\n[+] 1400010c1 | 8b4c2408           mov        ecx, dword ptr [0x8]    | rsp = 0x0\n[+] 1400010c5 | 03c8               add        ecx, eax                | ecx = 0x1, eax = 0x2\n[+] 1400010c7 | 8bc1               mov        eax, ecx                | ecx = 0x3\n[+] 1400010c9 | 03442418           add        eax, dword ptr [0x18]   | eax = 0x3, rsp = 0x0\n[+] 1400010cd | c3                 ret                                | rsp = 0x0\n[+] 140001102 | 89442428           mov        dword ptr [0x28], eax   | rsp = 0x0, eax = 0x6\n[+] 140001106 | 41b806000000       mov        r8d, 0x6                |\n[+] 14000110c | ba07000000         mov        edx, 0x7                |\n[+] 140001111 | b908000000         mov        ecx, 0x8                |\n[+] 140001116 | e895ffffff         call       0x1400010b0             | rsp = 0x0, rip = 0x0\n[+] 1400010b0 | 4489442418         mov        dword ptr [0x18], r8d   | rsp = 0x0, r8d = 0x0\n[+] 1400010b5 | 89542410           mov        dword ptr [0x10], edx   | rsp = 0x0, edx = 0x7\n[+] 1400010b9 | 894c2408           mov        dword ptr [0x8], ecx    | rsp = 0x0, ecx = 0x8\n[+] 1400010bd | 8b442410           mov        eax, dword ptr [0x10]   | rsp = 0x0\n[+] 1400010c1 | 8b4c2408           mov        ecx, dword ptr [0x8]    | rsp = 0x0\n[+] 1400010c5 | 03c8               add        ecx, eax                | ecx = 0x8, eax = 0x7\n[+] 1400010c7 | 8bc1               mov        eax, ecx                | ecx = 0xf\n[+] 1400010c9 | 03442418           add        eax, dword ptr [0x18]   | eax = 0xf, rsp = 0x0\n[+] 1400010cd | c3                 ret                                | rsp = 0x0\n[+] 14000111b | 89442424           mov        dword ptr [0x24], eax   | rsp = 0x0, eax = 0x15\n[+] 14000111f | 41b805000000       mov        r8d, 0x5                |\n[+] 140001125 | ba04000000         mov        edx, 0x4                |\n[+] 14000112a | b903000000         mov        ecx, 0x3                |\n[+] 14000112f | e87cffffff         call       0x1400010b0             | rsp = 0x0, rip = 0x0\n[+] 1400010b0 | 4489442418         mov        dword ptr [0x18], r8d   | rsp = 0x0, r8d = 0x0\n[+] 1400010b5 | 89542410           mov        dword ptr [0x10], edx   | rsp = 0x0, edx = 0x4\n[+] 1400010b9 | 894c2408           mov        dword ptr [0x8], ecx    | rsp = 0x0, ecx = 0x3\n[+] 1400010bd | 8b442410           mov        eax, dword ptr [0x10]   | rsp = 0x0\n[+] 1400010c1 | 8b4c2408           mov        ecx, dword ptr [0x8]    | rsp = 0x0\n[+] 1400010c5 | 03c8               add        ecx, eax                | ecx = 0x3, eax = 0x4\n[+] 1400010c7 | 8bc1               mov        eax, ecx                | ecx = 0x7\n[+] 1400010c9 | 03442418           add        eax, dword ptr [0x18]   | eax = 0x7, rsp = 0x0\n[+] 1400010cd | c3                 ret                                | rsp = 0x0\n[+] 140001134 | 89442420           mov        dword ptr [0x20], eax   | rsp = 0x0, eax = 0xc\n[+] 140001138 | 41b805000000       mov        r8d, 0x5                |\n[+] 14000113e | ba01000000         mov        edx, 0x1                |\n[+] 140001143 | b901000000         mov        ecx, 0x1                |\n[+] 140001148 | e863ffffff         call       0x1400010b0             | rsp = 0x0, rip = 0x0\n[+] 1400010b0 | 4489442418         mov        dword ptr [0x18], r8d   | rsp = 0x0, r8d = 0x0\n[+] 1400010b5 | 89542410           mov        dword ptr [0x10], edx   | rsp = 0x0, edx = 0x1\n[+] 1400010b9 | 894c2408           mov        dword ptr [0x8], ecx    | rsp = 0x0, ecx = 0x1\n[+] 1400010bd | 8b442410           mov        eax, dword ptr [0x10]   | rsp = 0x0\n[+] 1400010c1 | 8b4c2408           mov        ecx, dword ptr [0x8]    | rsp = 0x0\n[+] 1400010c5 | 03c8               add        ecx, eax                | ecx = 0x1, eax = 0x1\n[+] 1400010c7 | 8bc1               mov        eax, ecx                | ecx = 0x2\n[+] 1400010c9 | 03442418           add        eax, dword ptr [0x18]   | eax = 0x2, rsp = 0x0\n[+] 1400010cd | c3                 ret                                | rsp = 0x0\n[+] 14000114d | 89442434           mov        dword ptr [0x34], eax   | rsp = 0x0, eax = 0x7\n[+] 140001151 | 41b805000000       mov        r8d, 0x5                |\n[+] 140001157 | ba08000000         mov        edx, 0x8                |\n[+] 14000115c | b908000000         mov        ecx, 0x8                |\n[+] 140001161 | e84affffff         call       0x1400010b0             | rsp = 0x0, rip = 0x0\n[+] 1400010b0 | 4489442418         mov        dword ptr [0x18], r8d   | rsp = 0x0, r8d = 0x0\n[+] 1400010b5 | 89542410           mov        dword ptr [0x10], edx   | rsp = 0x0, edx = 0x8\n[+] 1400010b9 | 894c2408           mov        dword ptr [0x8], ecx    | rsp = 0x0, ecx = 0x8\n[+] 1400010bd | 8b442410           mov        eax, dword ptr [0x10]   | rsp = 0x0\n[+] 1400010c1 | 8b4c2408           mov        ecx, dword ptr [0x8]    | rsp = 0x0\n[+] 1400010c5 | 03c8               add        ecx, eax                | ecx = 0x8, eax = 0x8\n[+] 1400010c7 | 8bc1               mov        eax, ecx                | ecx = 0x10\n[+] 1400010c9 | 03442418           add        eax, dword ptr [0x18]   | eax = 0x10, rsp = 0x0\n[+] 1400010cd | c3                 ret                                | rsp = 0x0\n[+] 140001166 | 89442430           mov        dword ptr [0x30], eax   | rsp = 0x0, eax = 0x15\n[+] 14000116a | 41b805000000       mov        r8d, 0x5                |\n[+] 140001170 | ba05000000         mov        edx, 0x5                |\n[+] 140001175 | b905000000         mov        ecx, 0x5                |\n[+] 14000117a | e831ffffff         call       0x1400010b0             | rsp = 0x0, rip = 0x0\n[+] 1400010b0 | 4489442418         mov        dword ptr [0x18], r8d   | rsp = 0x0, r8d = 0x0\n[+] 1400010b5 | 89542410           mov        dword ptr [0x10], edx   | rsp = 0x0, edx = 0x5\n[+] 1400010b9 | 894c2408           mov        dword ptr [0x8], ecx    | rsp = 0x0, ecx = 0x5\n[+] 1400010bd | 8b442410           mov        eax, dword ptr [0x10]   | rsp = 0x0\n[+] 1400010c1 | 8b4c2408           mov        ecx, dword ptr [0x8]    | rsp = 0x0\n[+] 1400010c5 | 03c8               add        ecx, eax                | ecx = 0x5, eax = 0x5\n[+] 1400010c7 | 8bc1               mov        eax, ecx                | ecx = 0xa\n[+] 1400010c9 | 03442418           add        eax, dword ptr [0x18]   | eax = 0xa, rsp = 0x0\n[+] 1400010cd | c3                 ret                                | rsp = 0x0\n[+] 14000117f | 8944242c           mov        dword ptr [0x2c], eax   | rsp = 0x0, eax = 0xf\n[+] 140001183 | 448b442420         mov        r8d, dword ptr [0x20]   | rsp = 0x0\n[+] 140001188 | 8b542424           mov        edx, dword ptr [0x24]   | rsp = 0x0\n[+] 14000118c | 8b4c2428           mov        ecx, dword ptr [0x28]   | rsp = 0x0\n[+] 140001190 | e81bffffff         call       0x1400010b0             | rsp = 0x0, rip = 0x0\n[+] 1400010b0 | 4489442418         mov        dword ptr [0x18], r8d   | rsp = 0x0, r8d = 0x0\n[+] 1400010b5 | 89542410           mov        dword ptr [0x10], edx   | rsp = 0x0, edx = 0x15\n[+] 1400010b9 | 894c2408           mov        dword ptr [0x8], ecx    | rsp = 0x0, ecx = 0x6\n[+] 1400010bd | 8b442410           mov        eax, dword ptr [0x10]   | rsp = 0x0\n[+] 1400010c1 | 8b4c2408           mov        ecx, dword ptr [0x8]    | rsp = 0x0\n[+] 1400010c5 | 03c8               add        ecx, eax                | ecx = 0x6, eax = 0x15\n[+] 1400010c7 | 8bc1               mov        eax, ecx                | ecx = 0x1b\n[+] 1400010c9 | 03442418           add        eax, dword ptr [0x18]   | eax = 0x1b, rsp = 0x0\n[+] 1400010cd | c3                 ret                                | rsp = 0x0\n[+] 140001195 | 89442438           mov        dword ptr [0x38], eax   | rsp = 0x0, eax = 0x27\n[+] 140001199 | 448b44242c         mov        r8d, dword ptr [0x2c]   | rsp = 0x0\n[+] 14000119e | 8b542430           mov        edx, dword ptr [0x30]   | rsp = 0x0\n[+] 1400011a2 | 8b4c2434           mov        ecx, dword ptr [0x34]   | rsp = 0x0\n[+] 1400011a6 | e805ffffff         call       0x1400010b0             | rsp = 0x0, rip = 0x0\n[+] 1400010b0 | 4489442418         mov        dword ptr [0x18], r8d   | rsp = 0x0, r8d = 0x0\n[+] 1400010b5 | 89542410           mov        dword ptr [0x10], edx   | rsp = 0x0, edx = 0x15\n[+] 1400010b9 | 894c2408           mov        dword ptr [0x8], ecx    | rsp = 0x0, ecx = 0x7\n[+] 1400010bd | 8b442410           mov        eax, dword ptr [0x10]   | rsp = 0x0\n[+] 1400010c1 | 8b4c2408           mov        ecx, dword ptr [0x8]    | rsp = 0x0\n[+] 1400010c5 | 03c8               add        ecx, eax                | ecx = 0x7, eax = 0x15\n[+] 1400010c7 | 8bc1               mov        eax, ecx                | ecx = 0x1c\n[+] 1400010c9 | 03442418           add        eax, dword ptr [0x18]   | eax = 0x1c, rsp = 0x0\n[+] 1400010cd | c3                 ret                                | rsp = 0x0\n[+] 1400011ab | 8b4c2438           mov        ecx, dword ptr [0x38]   | rsp = 0x0\n[+] 1400011af | 0fafc8             imul       ecx, eax                | ecx = 0x27, eax = 0x2b\n[+] 1400011b2 | 8bc1               mov        eax, ecx                | ecx = 0x68d\n[+] 1400011b4 | 4883c448           add        rsp, 0x48               | rsp = 0x0\n[+] 1400011b8 | c3                 ret                                | rsp = 0x0\n[+] 140002000 | 90                 nop                                |\n[=] Process returned from entrypoint (exit_trap)!\n[+] Syscalls called:\n[+] Registries accessed:\n[+] Strings:\n\n:\\>\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "blabb",
            "time": "Feb 3, 2022 at 14:48",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Katoptriss",
                    "text": "<span class=\"comment-copy\">Thank you very much for suggesting Qiling, I didn't know about this framework and the fact that the values of the registers are available in the tracing log is extremely useful.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  You could, like you mentioned, write a parser that removes jumps by glueing the code at the target address where the jump was. Just be careful to take note of the jump targets already encountered before, as to not get an infinite loop by accident.\n </p>\n <p>\n  You could also view it with the satelite view in Ghidra or IDA to figure out if somewhere in there is a bigger block which executes some code that they tried to hide with this tactic.\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "ConstVoidPtr",
            "time": "Feb 3, 2022 at 12:46",
            "is_accepted": false,
            "comments": []
        }
    ]
}