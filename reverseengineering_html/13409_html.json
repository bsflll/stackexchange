{
    "title": "Help me reverse this",
    "link": "https://reverseengineering.stackexchange.com/questions/13409/help-me-reverse-this",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  It's been 4 nights I'm struggling decompiling this one. It's an Android native library that I ran through IDA to get C code.\n </p>\n <p>\n  Java signature :\n </p>\n <pre><code>byte[] resultArray = new byte[-2 + dataArray.length];\ndataLength= dataArray.length;\ndecryptData(byte[] resultArray, byte[] dataArray, int dataLength, int enumValue /* in our case should be 01 */, long paramLong /* dunno */)\n</code></pre>\n <p>\n  The disassembly in C :\n </p>\n <pre><code>//----- (00001354) --------------------------------------------------------\nint __fastcall doXor(int result, int a2, int a3, int a4, int a5, int a6, char a7)\n{\n  int v7; // r5@1\n  int v8; // r6@1\n  int v9; // r7@1\n  int v10; // r1@1\n  char v11; // lr@3\n  char v12; // t1@3\n  char v13; // t1@3\n\n  v7 = a2 - 1;\n  v8 = a3 - 1;\n  v9 = result - 1;\n  v10 = a2 + a5 - 1;\n  while ( v7 != v10 )\n  {\n    v12 = *(_BYTE *)(v7++ + 1);\n    v11 = v12;\n    v13 = *(_BYTE *)(v8++ + 1);\n    *(_BYTE *)(v9++ + 1) = v11 ^ v13;\n  } // ====== so far this one just does a xor in the full array\n  //   ===>what does this one do?\n  *(_BYTE *)(result + a5) = *(_BYTE *)(a3 + a5) ^ a7;\n\n  return result;\n}\n\n//----- (00001384) --------------------------------------------------------\nint getNumber()\n{\n  __int32 v0; // r0@1\n\n  v0 = time(0);\n  srand48(v0);\n  return (unsigned __int8)lrand48();\n}\n\n//----- (00001398) --------------------------------------------------------\nint __fastcall getKey(void *a1, unsigned int a2, unsigned __int8 a3, int a4, char a5)\n{\n  void *v5; // r8@1\n  unsigned int v6; // r7@1\n  unsigned int v7; // r10@1\n  void *v8; // r5@1\n  __int64 v9; // r0@1\n  signed int v10; // r6@1\n  __int64 v12; // [sp+8h] [bp-30h]@1\n  int v13; // [sp+14h] [bp-24h]@1\n\n  v5 = a1;\n  v6 = a2;\n  v7 = a2 >> 3;\n  v8 = a1;\n  v13 = _stack_chk_guard; //a stack guard\n  LODWORD(v9) = crc64(a3, (int)&a5, _stack_chk_guard, 8);\n  v10 = 0;\n  v12 = v9;\n  do\n  {\n    ++v10;\n    if ( 8 * v10 > v6 )\n    {\n      if ( v6 >= 8 * v10 - 8 )\n        LODWORD(v9) = memcpy(v8, &v12, (size_t)((char *)v5 + v6 - (_DWORD)v8));\n    }\n    else\n    {\n      v9 = v12;\n      *(_QWORD *)v8 = v12;\n    }\n    v8 = (char *)v8 + 8;\n  }while ( v10 <= (signed int)v7 );\n  if ( v13 != _stack_chk_guard )\n    _stack_chk_fail(v9);\n  return v9;\n}\n\n\n//----- (000014E4) --------------------------------------------------------\nsigned int __fastcall decryptData(void *a1, unsigned int *a2, int a3, int a4, __int64 a5)\n{\n  int v5; // r4@1\n  void *v6; // r11@1\n  unsigned int *v7; // r10@1\n  unsigned int v8; // r7@3\n  int v9; // r9@3\n  int v10; // ST10_4@3\n  void *v11; // r8@3\n  const void *v12; // r5@3\n  int v13; // r6@3\n  signed int result; // r0@5\n\n  v5 = a3;\n  v6 = a1;\n  v7 = a2;\n  if ( check == 1 )\n  {\n    if ( a5 )\n    {\n      result = 0;\n    }\n    else\n    {\n      v8 = *(_BYTE *)a2;\n      v9 = a4 + v8;\n      v10 = *((_BYTE *)a2 + a3 - 1);\n      v11 = malloc(a3 - 1);\n      v12 = malloc(v5 - 1);\n      getKey(v11, (unsigned __int16)(v5 - 1), v9, (2596069104u * (unsigned __int64)v8 >> 32) + 305419896 * v8, -16 * v8);\n      v13 = v5 - 2;\n      doXor((int)v12, (int)((char *)v7 + 1), (int)v11, v10, v13, (unsigned __int64)v13 >> 32, v10);\n      memcpy(v6, v12, v5 - 2);\n      if ( *((char *)v12 + v5 - 2) != v9 )\n        v13 = 0;\n      if ( v11 )\n        free(v11);\n      free((void *)v12);\n      result = v13;\n    }\n  }\n  else\n  {\n    result = -1;\n  }\n  return result;\n}\n</code></pre>\n <p>\n  I have the implementation of crc64.\nWhat I fail to understand is where does it get the seed from the data array for the getKey.\n </p>\n <p>\n  I'm not sure, I think it stores in the last 2 bytes the key that is used to generated the bigger key for xor. Please help, I'm really struggling and my C skills are a rusty.\n </p>\n <p>\n  Here is a set of data :\n </p>\n <pre><code>$type = \"01\";\n$length = \"37\";\n$data=\"ea8bf72287a0af8aa65edf259a43\".\n\"e1d8a67f71bce448273199848e401b33\".\n\"da379966a12ce4442e31991b71bde449\".\n\"39bb907d71bce448cc\";\n</code></pre>\n <p>\n  Normally, first 8 bytes gives the latitude and second longitude which in this case is :\n  <code>\n   f8869e63e888bb3f29ae997e0bc6e93f\n  </code>\n </p>\n <p>\n  So basically I assume we can expect this to be the coded version :\n  <code>\n   ea8bf72287a0af8aa65edf259a43e1d8\n  </code>\n  The inverse of xor is a xor so after xor it gives :\n  <code>\n   120d69416f2814b58ff0465b918508e7\n  </code>\n </p>\n <p>\n  Which\n  <em>\n   hypothetically\n  </em>\n  is our partial xor key.\n </p>\n <p>\n  Now questions :\n </p>\n <ul>\n  <li>\n   what is the length of the seed stored in data?\n  </li>\n  <li>\n   how the xor key is computed?\n  </li>\n  <li>\n   are we sure about latitude/longitude position in data?\n  </li>\n </ul>\n <p>\n  If you want to help outside stack and discuss this please contact me.\nMany thanks\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "3k",
    "tags": [
        "decompilation",
        "c",
        "decryption",
        "xor"
    ],
    "user": "TecHunter",
    "time": "Sep 6, 2016 at 18:26",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Here's your code with names given to most variables. That's quite a bit of code so I'll try to only iterate the important parts. I also added a few comments in the code to help reading, although I didn't try to cover all code with comments. Make sure you go over the named parameters, I believe those will help you understand the code quickly. Viewing the code in a syntax highlighting editor will also help (couldn't get SO to highlight).\n </p>\n <p>\n  Please add a comment about anything that's not clear enough.\n </p>\n <p>\n  the\n  <code>\n   NI\n  </code>\n  prefix is my initials, you can ignore it.\n </p>\n <p>\n  First,\n  <code>\n   doXor\n  </code>\n  :\n </p>\n <p>\n  This function simply XORs all bytes except the last byte, which is treated a bit differently, but more on that later. This is not part of the\n  <code>\n   while\n  </code>\n  loop simply because it's recevied differently in\n  <code>\n   doXor\n  </code>\n  . A possible reasoning behind this is to force any user of\n  <code>\n   doXor\n  </code>\n  to explicitly deal with this value, as it's somewhat important for asserting the validity of the decrpyed message.\n </p>\n <pre><code>//----- (00001354) --------------------------------------------------------\nint __fastcall doXor(int result, int a2_NI_source, int a3_NI_key, int a4_NI_unused_copy_source_last_byte, int a5_NI_length, int a6_NI_unused, char a7_NI_source_last_byte)\n{\n  int v7; // r5@1\n  int v8; // r6@1\n  int v9; // r7@1\n  int v10; // r1@1\n  char v11; // lr@3\n  char v12; // t1@3\n  char v13; // t1@3\n\n  v7_NI_source_pos = a2_NI_source - 1;\n  v8_NI_key_pos = a3_NI_key - 1;\n  v9_NI_result_pos = result - 1;\n  v10_NI_source_end_loc = a2_NI_source + a5_NI_length - 1;\n  while ( v7_NI_source_pos != v10_NI_source_end_loc )\n  {\n    // Ready bytes from v7_NI_source_pos and v8_NI_key_pos\n    v12 = *(_BYTE *)(v7_NI_source_pos++ + 1); // READ BYTE OF a2 + offset\n    v11 = v12;\n    v13 = *(_BYTE *)(v8_NI_key_pos++ + 1); // READ BYTE OF a2 + offset\n\n    // Xor two values and place in v9_NI_result_pos\n    *(_BYTE *)(v9_NI_result_pos++ + 1) = v11 ^ v13;\n  } // ====== so far this one just does a xor in the full array\n  //   ===>what does this one do?\n\n  // XOR LAST BYTE OF key with a7_NI_source_last_byte (see decryptData for code that retreives the byte)\n  *(_BYTE *)(result + a5_NI_length) = *(_BYTE *)(a3_NI_key + a5_NI_length) ^ a7_NI_source_last_byte;\n\n  return result;\n}\n</code></pre>\n <p>\n  Second,\n  <code>\n   getNumber\n  </code>\n  :\n </p>\n <p>\n  This is never actually used, but generates a single byte of random data which is somewhat biased for sepcificaly the value 255 because casting a \"nonnegative long integer uniformly distributed between 0 and 2^31\" to a unsigned byte will, in most cases, yield a number above 255.\n </p>\n <p>\n  <a href=\"http://linux.die.net/man/2/time\" rel=\"nofollow\">\n   time\n  </a>\n  will return the current local time in seconds since Epoch,\n  <a href=\"http://linux.die.net/man/3/srand48\" rel=\"nofollow\">\n   srand48\n  </a>\n  will seed the builtin PRNG with that result and\n  <a href=\"http://linux.die.net/man/3/lrand48\" rel=\"nofollow\">\n   lrand48\n  </a>\n  return the random number.\n </p>\n <pre><code>//----- (00001384) --------------------------------------------------------\n// This is never used in provided code! :S\nint getNumber()\n{\n  __int32 v0; // r0@1\n\n  // Seed srand48 using current local time in seconds since Epoch\n  v0 = time(0);\n  srand48(v0);\n  // Return 1 byte integer casted from nonnegative long integer uniformly distributed between 0 and 2^31 \n  return (unsigned __int8)lrand48();\n}\n</code></pre>\n <p>\n  Third,\n  <code>\n   getKey\n  </code>\n  :\n </p>\n <p>\n  <strong>\n   [EDIT]\n  </strong>\n  A simple stream padding based on passed values. It is unclear what\n  <code>\n   crc64\n  </code>\n  does and how are it's parameters used, but it appears as if it does not receive a buffer.\nThe low dword returned from\n  <code>\n   crc64\n  </code>\n  is copied repeatedly to create the key sequence, and is used as the internal PRNG state.\n  <code>\n   crc64\n  </code>\n  is there for the function creating the initial state, or the seed function for\n  <code>\n   geyKey\n  </code>\n  .\nIt has some decompliation bloat (that is, extra redundant C statements caused by the decompiler not doing the best job it could) but basically this function fills the requested buffer with the same value over and over.\n </p>\n <pre><code>//----- (00001398) --------------------------------------------------------\nint __fastcall getKey(void *a1_NI_key_buffer, unsigned int a2_NI_key_length, unsigned __int8 a3, int a4_NI_unused, char a5)\n{\n  void *v5; // r8@1\n  unsigned int v6; // r7@1\n  unsigned int v7; // r10@1\n  void *v8; // r5@1\n  __int64 v9; // r0@1\n  signed int v10; // r6@1\n  __int64 v12; // [sp+8h] [bp-30h]@1\n  int v13; // [sp+14h] [bp-24h]@1\n\n  v5_NI_key_buffer = a1_NI_key_buffer;\n  v6_NI_key_length = a2_NI_key_length;\n  v7_NI_key_8byte_chunks = a2_NI_key_length >> 3;\n  v8_NI_key_buffer_pos = a1_NI_key_buffer;\n  v13_NI_stack_guard = _stack_chk_guard; //a stack guard\n  LODWORD(v9_NIl_partial_crc_state) = crc64(a3, (int)&a5, _stack_chk_guard, 8);\n  v10_NI_current_8byte_chunk = 0;\n  v12_NI_full_crc_state = v9_NIl_partial_crc_state;\n\n  // Loop on 8 byte long chunks of the required key length\n  do\n  {\n    // increase the counter for the current 8byte chunk we're using\n    ++v10_NI_current_8byte_chunk;\n\n    // If current 8byte chunk exceeds the required length\n    if ( 8 * v10_NI_current_8byte_chunk > v6_NI_key_length )\n    {\n      // If some bytes of the 8byte chunks are needed\n      if ( v6_NI_key_length >= 8 * v10_NI_current_8byte_chunk - 8 )\n      {\n        // Copy portion of v12_NI_full_crc_state needed to fill the buffer\n        LODWORD(v9_NIl_partial_crc_state) = memcpy(v8_NI_key_buffer_pos, &v12_NI_full_crc_state, (size_t)((char *)v5_NI_key_buffer + v6_NI_key_length - (_DWORD)v8_NI_key_buffer_pos));\n      }\n    }\n    else\n    {\n      // Set v9_NIl_partial_crc_state to the initial v12_NI_full_crc_state\n      v9_NIl_partial_crc_state = v12_NI_full_crc_state;\n      *(_QWORD *)v8_NI_key_buffer_pos = v12_NI_full_crc_state;\n    }\n    v8_NI_key_buffer_pos = (char *)v8_NI_key_buffer_pos + 8;\n  }while ( v10_NI_current_8byte_chunk <= (signed int)v7_NI_key_8byte_chunks );\n\n  // Make sure stack wasn't damaged in the process\n  if ( v13_NI_stack_guard != _stack_chk_guard )\n    _stack_chk_fail(v9_NIl_partial_crc_state);\n  return v9_NIl_partial_crc_state;\n}\n</code></pre>\n <p>\n  Last but not least,\n  <code>\n   decryptData\n  </code>\n  :\n </p>\n <p>\n  This is where the magic happens, buy it's not too magical. Basically, the first byte is used to feed\n  <code>\n   getKey\n  </code>\n  with a state, togather with\n  <code>\n   a4_NI_unknown_constant\n  </code>\n  parameter passed to\n  <code>\n   decryptData\n  </code>\n  . These two bytes are what determines the entire\n  <code>\n   getKey\n  </code>\n  function.\n </p>\n <p>\n  The last byte (treated strangly in\n  <code>\n   doXor\n  </code>\n  is used as a basic sanify/error detection byte and must result in the correct value for the message to be accepted and properly decrypted.\n </p>\n <pre><code>//----- (000014E4) --------------------------------------------------------\nsigned int __fastcall decryptData(void *a1_NI_result, unsigned int *a2_NI_source, int a3_NI_length, int a4_NI_unknown_constant, __int64 a5)\n{\n  int v5; // r4@1\n  void *v6; // r11@1\n  unsigned int *v7; // r10@1\n  unsigned int v8; // r7@3\n  int v9; // r9@3\n  int v10; // ST10_4@3\n  void *v11; // r8@3\n  const void *v12; // r5@3\n  int v13; // r6@3\n  signed int result; // r0@5\n\n  v5_NI_length_copy = a3_NI_length;\n  v6_NI_result_copy = a1_NI_result;\n  v7_NI_source_copy = a2_NI_source;\n  if ( check == 1 )\n  {\n    if ( a5 )\n    {\n      result = 0;\n    }\n    else\n    {\n      v8_NI_source_first_byte = *(_BYTE *)a2_NI_source;\n      v9_NI_unknown_plus_first_byte = a4_NI_unknown_constant + v8_NI_source_first_byte;\n      v10_NI_source_last_byte = *((_BYTE *)a2_NI_source + a3_NI_length - 1);\n      v11_NI_key = malloc(a3_NI_length - 1);\n      v12_NI_temp_result = malloc(v5_NI_length_copy - 1);\n\n      // generate xor key based on:\n      // 1. length of data\n      // 2. unknown constant provided to decryptData as a4_NI_unknown_constant\n      // 3. first byte of encrypted string\n      getKey(v11_NI_key, (unsigned __int16)(v5_NI_length_copy - 1), v9_NI_unknown_plus_first_byte, (2596069104u * (unsigned __int64)v8_NI_source_first_byte >> 32) + 305419896 * v8_NI_source_first_byte, -16 * v8_NI_source_first_byte);\n      v13_result_length = v5_NI_length_copy - 2;\n\n      // XOR\n      doXor((int)v12_NI_temp_result, (int)((char *)v7_NI_source_copy + 1), (int)v11_NI_key, v10_NI_source_last_byte, v13_result_length, (unsigned __int64)v13_result_length >> 32, v10_NI_source_last_byte);\n\n      // Copy result from v12_NI_temp_result to user provided reulst buffer v6_NI_result_copy\n      memcpy(v6_NI_result_copy, v12_NI_temp_result, v5_NI_length_copy - 2);\n\n      // If last byte in v12_NI_temp_result is not the same as v9_NI_unknown_plus_first_byte, return Null\n      if ( *((char *)v12_NI_temp_result + v5_NI_length_copy - 2) != v9_NI_unknown_plus_first_byte )\n        v13_result_length = 0;\n\n      // If key allocated, free it\n      if ( v11_NI_key )\n        free(v11_NI_key);\n\n      // Free v12_NI_temp_result\n      free((void *)v12_NI_temp_result);\n\n      // return v13_result_length\n      result = v13_result_length;\n    }\n  }\n  else\n  {\n    result = -1;\n  }\n  return result;\n}\n</code></pre>\n <p>\n  Finally, sepcific answers to your questions:\n </p>\n <ol>\n  <li>\n   The length of the seed is a single byte, as generated in\n   <code>\n    getNumber\n   </code>\n   and used for key generation in\n   <code>\n    getKey\n   </code>\n   . It is used at\n   <code>\n    getKey\n   </code>\n   by expanding it and the other arguments calculated based on\n   <code>\n    v9_NI_unknown_plus_first_byte\n   </code>\n   to generate a\n   <code>\n    QWORD\n   </code>\n   .\n  </li>\n  <li>\n   For that you'll need to further RE the\n   <code>\n    crc64\n   </code>\n   function. Sorry about that. But understanding the\n   <code>\n    getKey\n   </code>\n   function better makes it possible to use another (more interesting) approach to decrypting streams of data. Since we now know the \"key\" is an 8byte sequeces used repeatedly, every known byte of the original message reveals all other bytes at the same 8byte offset. Messages with fixed headers, or known types of data (textual, for example) reveal a lot of information about the xor key.\n  </li>\n  <li>\n   I have no idea what's the actual content of the data, nor how to interpret it. That is required in order to validate the type and use. You should gather enough sample sets, decrypt them and see if they look like valid latitude/longitude values.\n  </li>\n </ol>\n <p>\n  I think the best way for you to proceed now is implementing a simulator that receives a message and tries to decrypt it using the information above. I may have made mistakes or overlooked some small details, but those will be eaier to identify by seeing errors in the produced decryption and following up on those.\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "NirIzr",
            "time": "Sep 6, 2016 at 10:46",
            "is_accepted": true,
            "comments": [
                {
                    "user": "TecHunter",
                    "text": "<span class=\"comment-copy\">thank you, I will review this later and give you feedback and hopefully the bounty.</span>",
                    "time": null
                },
                {
                    "user": "NirIzr",
                    "text": "<span class=\"comment-copy\">You're welcome! If you have any further questions or issues you'd like me to focus more on go ahead and point those out.</span>",
                    "time": null
                },
                {
                    "user": "TecHunter",
                    "text": "<span class=\"comment-copy\">The getKey function is the most important part here. I need to understand how we retrieve the key from the data</span>",
                    "time": null
                },
                {
                    "user": "NirIzr",
                    "text": "<span class=\"comment-copy\">@TecHunter: it's actually simpler than I thought, I described it and now we're after crc64 which is missing here. Mostly, crc64 is used repeatedly as the actual XOR key which makes decrypting messages quite easy. Yay! I've edited my answer to reflect the additional details.</span>",
                    "time": null
                },
                {
                    "user": "TecHunter",
                    "text": "<span class=\"comment-copy\">@Nirlzr great, here is the full C code <a href=\"https://gist.github.com/TecHunter/dfdd8c86b661697b022df6742d11fe87\" rel=\"nofollow noreferrer\">gist</a> i've reversed completely the crc64 function</span>",
                    "time": null
                }
            ]
        }
    ]
}