{
    "title": "How to get the information of \"how many and which symbols are resolved by linker\"?",
    "link": "https://reverseengineering.stackexchange.com/questions/8306/how-to-get-the-information-of-how-many-and-which-symbols-are-resolved-by-linker",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The test is on 32-bit Linux, x86. With\n  <code>\n   gcc\n  </code>\n  4.6.3 and GNU\n  <code>\n   ld\n  </code>\n  2.22.\n </p>\n <p>\n  So I am trying to get the information of \"how many symbols are resolved by linker\" during link time? And how can I list the information of all the resolved symbols? say, the symbol name, memory address.\n </p>\n <p>\n  I am thinking I should manipulate the linker to do so, but I have no idea how to do it. I have some experiences to fed linker with a link-script, but I didn't find anything related to resolved symbol information in the link-scripts..\n </p>\n <p>\n  Could anyone give me some help? I really appreciate that! Thank you!\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "3k",
    "tags": [
        "c",
        "elf",
        "gcc"
    ],
    "user": "lllllllllllll",
    "time": "Feb 21, 2015 at 2:19",
    "comments": [
        {
            "user": "user3629249",
            "text": "<html><body><span class=\"comment-copy\">\n you could start with the 'external symbols' table in each object file.  You could have the linker(gcc) output a map file.  This: '-Xlinker -Map=output.map' will cause a .map file to be output, named 'output.map'\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Information about symbols resolved at link time, including the symbol name and memory address, can be acquired by by executing\n  <code>\n   ld\n  </code>\n  with the\n  <code>\n   -M\n  </code>\n  option plus the name of the object file to be linked:\n </p>\n <pre><code>$ ld -M <OBJECT FILE>\n</code></pre>\n <p>\n  This will result in a link map being printed to STDOUT. Of course, this output can also be redirected to a file:\n </p>\n <pre><code>$ ld -M <OBJECT FILE>  >  <OUTPUT FILE>\n</code></pre>\n <p>\n  The following description of the\n  <code>\n   -M\n  </code>\n  option is given in the\n  <a href=\"http://man7.org/linux/man-pages/man1/ld.1.html\" rel=\"nofollow noreferrer\">\n   manual page for ld(1)\n  </a>\n  as well as in\n  <a href=\"https://sourceware.org/binutils/docs/ld/Options.html\" rel=\"nofollow noreferrer\">\n   section 2.1 \"Command Line Options\"\n  </a>\n  in the\n  <a href=\"https://sourceware.org/binutils/docs/ld/\" rel=\"nofollow noreferrer\">\n   sourceware.org documentation of ld\n  </a>\n  :\n </p>\n <blockquote>\n  <p>\n   -M\n  </p>\n  <p>\n   --print-map\n  </p>\n  <p>\n   Print a link map to the standard output. A link map provides information                      about the link, including the following:\n  </p>\n  <ul>\n   <li>\n    <p>\n     Where object files are mapped into memory.\n    </p>\n   </li>\n   <li>\n    <p>\n     How common symbols are allocated.\n    </p>\n   </li>\n   <li>\n    <p>\n     All archive members included in the link, with a mention of the symbol which caused the archive member to be brought in.\n    </p>\n   </li>\n   <li>\n    <p>\n     The values assigned to symbols.\n    </p>\n    <p>\n     Note - symbols whose values are computed by an expression which involves a reference to a previous value of the same symbol may not have correct result displayed in the link map. This is because the linker discards intermediate results and only retains the final value of an expression. Under such circumstances the linker will display the final value enclosed by square brackets. Thus for example a linker script containing:\n    </p>\n    <pre><code>                 foo = 1\n                 foo = foo * 4\n                 foo = foo + 8\n</code></pre>\n   </li>\n  </ul>\n  <p>\n   will produce the following output in the link map if the -M option is used:\n  </p>\n  <pre><code>                     0x00000001                foo = 0x1\n                     [0x0000000c]                foo = (foo * 0x4)\n                     [0x0000000c]                foo = (foo + 0x8)\n</code></pre>\n  <p>\n   See\n   <a href=\"https://sourceware.org/binutils/docs/ld/Expressions.html#Expressions\" rel=\"nofollow noreferrer\">\n    Expressions\n   </a>\n   for more information about expressions in linker scripts.\n  </p>\n </blockquote>\n <p>\n  Here is an example link map snippet for an i386 ELF32 object file:\n </p>\n <pre><code><<= snip =>>\n\n.plt.got\n *(.plt.got)\n\n.text           0x0000000008048074        0xa\n *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n *(.text.exit .text.exit.*)\n *(.text.startup .text.startup.*)\n *(.text.hot .text.hot.*)\n *(.text .stub .text.* .gnu.linkonce.t.*)\n .text          0x0000000008048074        0xa test.o\n                0x0000000008048074                main\n *(.gnu.warning)\n\n.fini\n *(SORT(.fini))\n                [!provide]                        PROVIDE (__etext, .)\n                [!provide]                        PROVIDE (_etext, .)\n                [!provide]                        PROVIDE (etext, .)    \n.rodata\n *(.rodata .rodata.* .gnu.linkonce.r.*)\n\n.rodata1\n *(.rodata1)\n\n.eh_frame_hdr\n *(.eh_frame_hdr)\n *(.eh_frame_entry .eh_frame_entry.*)\n\n.eh_frame       0x0000000008048080       0x38\n *(.eh_frame)\n .eh_frame      0x0000000008048080       0x38 test.o\n *(.eh_frame.*)\n\n<<= snip =>>\n</code></pre>\n <p>\n  If this is insufficient for your purposes and would like to manipulate the linker with a custom script, section \"\n  <a href=\"https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts\" rel=\"nofollow noreferrer\">\n   3: Linker Scripts\n  </a>\n  \" at sourceware.org may be helpful. Some documentation of the Link Editor Command Language can also be found on page 524 in the\n  <a href=\"http://tenox.net/docs/attunixpc/ATT_UnixPC_Model_7300_Unix_System_V_Programmers_Guide.pdf\" rel=\"nofollow noreferrer\">\n   AT&T UNIXâ„¢ PC Model 7300 Unix System V Programmers Guide\n  </a>\n  .\n </p>\n <p>\n  More information can also be found in the\n  <a href=\"https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=blob;f=ld/ld.texinfo\" rel=\"nofollow noreferrer\">\n   ld.texinfo\n  </a>\n  file which is part of the\n  <a href=\"https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=tree;f=ld\" rel=\"nofollow noreferrer\">\n   source for\n   <code>\n    ld\n   </code>\n  </a>\n  . There is also a document called\n  <a href=\"https://www.eecs.umich.edu/courses/eecs373/readings/Linker.pdf\" rel=\"nofollow noreferrer\">\n   The GNU Linker\n  </a>\n  , which discusses linker scripts in 40 pages or so.\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "julian",
            "time": "Feb 6, 2017 at 18:49",
            "is_accepted": true,
            "comments": []
        }
    ]
}