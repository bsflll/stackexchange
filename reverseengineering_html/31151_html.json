{
    "title": "Access to CPU registers in GMM space",
    "link": "https://reverseengineering.stackexchange.com/questions/31151/access-to-cpu-registers-in-gmm-space",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  AMD's BIOS and Kernel Developerâ€™s Guide (BKDG) documents GMM registers and access to them:\n </p>\n <blockquote>\n  <p>\n   GMMxXXXXX: GPU memory mapped registers; XXXXX specifies the hexadecimal byte address offset (this may be 2 to 5 digits) from the base address register; The base address for this space is specified by D1F0x18 [Graphics Memory Mapped Registers Base Address].\n  </p>\n </blockquote>\n <p>\n  <code>\n   D1F0x18\n  </code>\n  has the following structure (I also add a column with values that I get):\n </p>\n <div class=\"s-table-container\">\n  <table class=\"s-table\">\n   <thead>\n    <tr>\n     <th>\n      Bits\n     </th>\n     <th>\n      My value\n     </th>\n     <th>\n      Description\n     </th>\n    </tr>\n   </thead>\n   <tbody>\n    <tr>\n     <td>\n      31:18\n     </td>\n     <td>\n      0x3c08\n     </td>\n     <td>\n      BaseAddr[31:18]: base address.\n     </td>\n    </tr>\n    <tr>\n     <td>\n      17:16\n     </td>\n     <td>\n      0\n     </td>\n     <td>\n      BaseAddr[17:16]: base address.\n     </td>\n    </tr>\n    <tr>\n     <td>\n      15:4\n     </td>\n     <td>\n      0\n     </td>\n     <td>\n      BaseAddr[15:4]: base address.\n     </td>\n    </tr>\n    <tr>\n     <td>\n      3\n     </td>\n     <td>\n      0\n     </td>\n     <td>\n      prefetchable. 0=Non-prefetchable memory region.\n     </td>\n    </tr>\n    <tr>\n     <td>\n      2:1\n     </td>\n     <td>\n      0\n     </td>\n     <td>\n      base address register type. 00b=32-bit BAR. 10b=64-bit BAR.\n     </td>\n    </tr>\n    <tr>\n     <td>\n      0\n     </td>\n     <td>\n      0\n     </td>\n     <td>\n      memory space type. 0=Memory mapped base address.\n     </td>\n    </tr>\n   </tbody>\n  </table>\n </div>\n <p>\n  How to properly access registers in the GMM space?\n </p>\n <p>\n  There are three base address fields in the\n  <code>\n   D1F0x18\n  </code>\n  register, and the guide doesn't explain any further how to compile the base address. I tried to read memory (in Linux with\n  <code>\n   root\n  </code>\n  privileges) at the following memory offsets, but all of them return me\n  <code>\n   Segmentation fault\n  </code>\n  error.\n </p>\n <pre><code>printf(\"%02x\n\", (unsigned)*(unsigned char*)0x3c08); // Base address itself\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0x4378); // 0x3c08+0x770 (GMMx770)\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0x4381); // 0x3c08+0x770+3\n\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0x3c080000); // Base address appended with zeroes\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0x3c080770); // plus GMMx770 offset\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0x3c080773); // plus size of the GMMx770\n\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0xf0200000); // 0x3c08 shifted left by 2 bits (so that to align 31:18 field to 16 bits)\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0xf0200770); // plus GMMx770 offset\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0xf0200773); // plus size GMMx770 offset\n\n</code></pre>\n <h3>\n  Edit\n </h3>\n <p>\n  There is a source code of the\n  <a href=\"https://en.wikipedia.org/wiki/Coreboot\" rel=\"nofollow noreferrer\">\n   Coreboot\n  </a>\n  project available on the Internet.\n  <s>\n   There are clear footprints that they implement access to the GMM space, but I couldn't extract the method from their code either.\n  </s>\n  The code gives some clues:\n </p>\n <ol>\n  <li>\n   <s>\n    It looks, like they use the base address as is, i.e. it is\n    <code>\n     0x3c080000\n    </code>\n    in my case.\n   </s>\n  </li>\n  <li>\n   They set bits 0 and 1 in\n   <code>\n    D1F0x04\n   </code>\n   so that apparently to enable access to the device's memory area (I have both of these bits set by default).\n  </li>\n  <li>\n   They read memory with\n   <code>\n    __readfsdword\n   </code>\n   . Because I am on GCC, I redefined this function as follows, but still get the\n   <code>\n    Segmentation fault\n   </code>\n   :\n  </li>\n </ol>\n <pre><code>unsigned long __readfsdword(const unsigned long Offset)\n{\n    unsigned long value;\n    __asm__ __volatile__(\"movl %%fs:%a[Offset], %k[value]\" : [value] \"=r\" (value) : [Offset] \"ir\" (Offset));\n    return value;\n}\n</code></pre>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 0,
    "views": "57",
    "tags": [
        "firmware",
        "hardware",
        "register"
    ],
    "user": "Hweaker",
    "time": "Nov 20, 2022 at 4:07",
    "comments": [],
    "answers_data": []
}