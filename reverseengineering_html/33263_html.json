{
    "title": "How can I compile an EXE with GCC such that the .idata and .text sections are merged together?",
    "link": "https://reverseengineering.stackexchange.com/questions/33263/how-can-i-compile-an-exe-with-gcc-such-that-the-idata-and-text-sections-are-me",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Given this classic helloworld.c example,\n </p>\n <pre><code>#include <stdio.h>\nint main() \n{\n    printf(\"Hello world!\n\");\n}\n</code></pre>\n <p>\n  Under normal circumstances, a compiled EXE file consists of several sections, such as .text, .rdata, .idata, and so on.\nVC (Visual C++) has a very useful /MERGE: option, which allows all sections to be merged into a single segment in versions prior to VC2010.\n </p>\n <p>\n  However, GCC (MinGW) does not have such a command. Online resources suggest that this can only be achieved through custom linker scripts.\n </p>\n <p>\n  But I've found that merging .text and .rdata sections together is fine, but once .idata is also included in the merge, the program fails to run.\n </p>\n <p>\n  Can anyone help identify the issue? Is it possible that the linker script (LDS) is not written correctly?\n </p>\n <pre><code>OUTPUT_FORMAT(pei-i386)\nSECTIONS\n{\n  . = SIZEOF_HEADERS;\n  . = ALIGN(__section_alignment__);\n  .text  __image_base__ + ( __section_alignment__ < 0x1000 ? . : __section_alignment__ ) :\n  {\n    *(.text) *(.data) *(.rdata) *(SORT(.rdata$*)) KEEP(*(.pdata*)) *(.bss) *(.idata) *(SORT(.idata$*))\n  }\n}\n</code></pre>\n <p>\n  Or alternatively, is there a way to achieve this without using an LDS linker script, solely with the GCC MinGW compiler? Excluding manual modification.\n </p>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 1,
    "views": "121",
    "tags": [
        "debugging",
        "x86"
    ],
    "user": "wqte45",
    "time": "Oct 16, 2024 at 7:03",
    "comments": [
        {
            "user": "the busybee",
            "text": "<html><body><span class=\"comment-copy\">\n Welcome to SE/RE! Please take the\n <a href=\"https://reverseengineering.stackexchange.com/tour\">\n  tour\n </a>\n to learn how this site works, and you might want to read some of the pages of the\n <a href=\"https://reverseengineering.stackexchange.com/help\">\n  help center\n </a>\n . Then come back and\n <a href=\"https://reverseengineering.stackexchange.com/posts/33263/edit\">\n  edit\n </a>\n your question to add new information. -- What does it mean the \"\n <i>\n  the program fails to run\n </i>\n \"? When you tried to run it under debugger control, where did it fail?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "the busybee",
            "text": "<html><body><span class=\"comment-copy\">\n Don't you think that\n <a href=\"https://stackoverflow.com\">\n  Stack Overflow\n </a>\n would be a better site to ask this question?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Ali Rizvi-Santiago",
            "text": "<html><body><span class=\"comment-copy\">\n You can't do anything with .idata because the rtld needs to write to it (and your linker script combines everything into one section). That section contains the addreses for your imports (from the data directory entry) resolved by the runtime linker. Some of the other sections like .data will also be written to by your generated code, so you can't combine them into a single .text section (which the rtld will map non-writable).  You can skip over those reqs, if you do the loading yourself (like prior to executing shellcode)... but if you're depending on your platform's loader. Then, no.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "the busybee",
            "text": "<html><body><span class=\"comment-copy\">\n @AliRizvi-Santiago How does your first statement match with\n <a href=\"https://stackoverflow.com/a/19021377/11294831\">\n  this answer on StackOverflow\n </a>\n ?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "wqte45",
            "text": "<html><body><span class=\"comment-copy\">\n @Ali Rizvi-Santiago  Thank you for your reply. I don't think it's impossible at all. Visual C++ can merge them into one section, so why can't GCC do the same? Perhaps I'm just not using the correct method.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  As per the comments in the question, I took the time to download the Visual Studio Dev Essentials VM in order to prove what had been claimed. I haven't gone towards proving the loader's exact requirements because I figured that it would've been out-of-scope for the original question.\n </p>\n <h1>\n  Binutils\n </h1>\n <p>\n  As per the question and what was suggested in the comments, we'll use the original\n  <code>\n   ld(1)\n  </code>\n  script and examine the executable it produces.\n </p>\n <pre><code>OUTPUT_FORMAT(pei-i386)\nSECTIONS\n{\n  . = SIZEOF_HEADERS;\n  . = ALIGN(__section_alignment__);\n  .text  __image_base__ + ( __section_alignment__ < 0x1000 ? . : __section_alignment__ ) :\n  {\n    *(.text) *(.data) *(.rdata) *(SORT(.rdata$*)) KEEP(*(.pdata*)) *(.bss) *(.idata) *(SORT(.idata$*))\n  }\n}\n</code></pre>\n <p>\n  For this linker script we'll create a file with no dependencies to prove that the linker script is capable of producing \"valid\" executables.\n </p>\n <pre><code>$ cat >| sample.c\nstatic int for_a_data_section = 0;\nint\nWinMain(void* hInst, void* hPrev, char* lpCmdLine, int nShow)\n{  for_a_data_section++; return 0; }\n^D\n$ mingw32-make sample.o\ni686-w64-mingw32-gcc  -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions --param=ssp-buffer-size=4   -c -o sample.o sample.c\n</code></pre>\n <p>\n  Next we'll link the object using the prior linker script which should produce an executable file.\n </p>\n <pre><code>$ i686-w64-mingw32-ld.bfd -T example.ld -o sample.non-working.exe sample.o\ni686-w64-mingw32-ld.bfd: sample.exe:/4: section below image base\ni686-w64-mingw32-ld.bfd: sample.exe:/16: section below image base\ni686-w64-mingw32-ld.bfd: sample.exe:/30: section below image base\ni686-w64-mingw32-ld.bfd: sample.exe:/45: section below image base\ni686-w64-mingw32-ld.bfd: sample.exe:/57: section below image base\ni686-w64-mingw32-ld.bfd: sample.exe:/73: section below image base\n\n# these error messages are a result of not including all the sections\n</code></pre>\n <p>\n  Now we'll look at the sections that will be mapped as segments by the loader. Notice that we only have two sections,\n  <code>\n   .reloc\n  </code>\n  and\n  <code>\n   .text\n  </code>\n  . Both of these are set with the\n  <code>\n   MEM_READ\n  </code>\n  characteristic. The\n  <code>\n   .text\n  </code>\n  section is set with\n  <code>\n   MEM_EXECUTE\n  </code>\n  . (This should've probably been done with a regular PECOFF viewer/editor, but this is what I have available on my current platform.)\n </p>\n <pre><code>$ python -m pecoff -O print -s sample.non-working.exe\n<class headers.SectionTableArray> 'Sections' headers.IMAGE_SECTION_HEADER[8]\n[178] headers.IMAGE_SECTION_HEADER{0}  Name:.eh_frame       Raw[0x00000400:+0x00000800] Virtual[0xffc00000:+0x0000062c] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n[1a0] headers.IMAGE_SECTION_HEADER{1}  Name:.debug_abbrev   Raw[0x00000c00:+0x00000200] Virtual[0xffc00000:+0x0000013c] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n[1c8] headers.IMAGE_SECTION_HEADER{2}  Name:.debug_aranges  Raw[0x00000e00:+0x00000200] Virtual[0xffc00000:+0x00000020] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n[1f0] headers.IMAGE_SECTION_HEADER{3}  Name:.debug_line     Raw[0x00001000:+0x00000200] Virtual[0xffc00000:+0x00000078] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n[218] headers.IMAGE_SECTION_HEADER{4}  Name:.debug_line_str Raw[0x00001200:+0x00000200] Virtual[0xffc00000:+0x00000090] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n[240] headers.IMAGE_SECTION_HEADER{5}  Name:.eh_frame       Raw[0x00001400:+0x00000200] Virtual[0xffc01000:+0x00000040] Characteristics:(0x40000040,32) :> MEM_READ CNT_INITIALIZED_DATA\n[268] headers.IMAGE_SECTION_HEADER{6}  Name:.text           Raw[0x00001600:+0x00000200] Virtual[0x00001000:+0x0000006c] Characteristics:(0x60000060,32) :> MEM_READ MEM_EXECUTE CNT_INITIALIZED_DATA CNT_CODE\n[290] headers.IMAGE_SECTION_HEADER{7}  Name:.reloc          Raw[0x00001800:+0x00000200] Virtual[0x00002000:+0x00000010] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n</code></pre>\n <p>\n  Running this in Windows 11 Enterprise Evaluation results in either the \"This app can't run on your PC\" modal popup, or the following:\n </p>\n <pre><code>> .\\sample.non-working.exe\nProgram 'sample.non-working.exe' failed to run: The specified executable is not a valid application\nfor this OS platform.At line:1 char:1\n+ .\\sample.non-working.exe\n+ ~~~~~~~~~~~~~~.\nAt line:1 char:1\n+ .\\sample.non-working.exe\n+ ~~~~~~~~~~~~~~\n    + CategoryInfo          : ResourceUnavailable: (:) [], ApplicationFailedException\n    + FullyQualifiedErrorId : NativeCommandFailed\n</code></pre>\n <p>\n  Now we'll link the same object without the linker script as a parameter. This will not produce the executable with merged sections that we are demanding, but we are doing this for the sake of having something to compare the previous results to. Running the linker without the\n  <code>\n   -T\n  </code>\n  parameter will result in binutils'\n  <code>\n   ld(1)\n  </code>\n  using the script that it was configured with (\n  <code>\n   ld --verbose\n  </code>\n  ).\n </p>\n <pre><code>$ i686-w64-mingw32-ld.bfd -o sample.original.exe sample.o\n</code></pre>\n <p>\n  When we dump the sections from the executable, we can see the\n  <code>\n   .text\n  </code>\n  section has\n  <code>\n   MEM_READ\n  </code>\n  and\n  <code>\n   MEM_EXECUTE\n  </code>\n  set. The\n  <code>\n   .data\n  </code>\n  section and the rest have\n  <code>\n   MEM_READ\n  </code>\n  , or both\n  <code>\n   MEM_WRITE\n  </code>\n  and\n  <code>\n   MEM_READ\n  </code>\n  set.\n </p>\n <pre><code>$ python -m pecoff -O print -s sample.original.exe\n<class headers.SectionTableArray> 'Sections' headers.IMAGE_SECTION_HEADER[11]\n[178] headers.IMAGE_SECTION_HEADER{0}  Name:.text           Raw[0x00000400:+0x00000200] Virtual[0x00001000:+0x00000040] Characteristics:(0x60000020,32) :> MEM_READ MEM_EXECUTE CNT_CODE\n[1a0] headers.IMAGE_SECTION_HEADER{1}  Name:.data           Raw[0x00000600:+0x00000200] Virtual[0x00002000:+0x00000004] Characteristics:(0xc0000040,32) :> MEM_WRITE MEM_READ CNT_INITIALIZED_DATA\n[1c8] headers.IMAGE_SECTION_HEADER{2}  Name:.rdata          Raw[0x00000800:+0x00000200] Virtual[0x00003000:+0x00000038] Characteristics:(0x40000040,32) :> MEM_READ CNT_INITIALIZED_DATA\n[1f0] headers.IMAGE_SECTION_HEADER{3}  Name:.eh_frame       Raw[0x00000a00:+0x00000200] Virtual[0x00004000:+0x00000040] Characteristics:(0x40000040,32) :> MEM_READ CNT_INITIALIZED_DATA\n[218] headers.IMAGE_SECTION_HEADER{4}  Name:.idata          Raw[0x00000c00:+0x00000200] Virtual[0x00005000:+0x00000014] Characteristics:(0xc0000040,32) :> MEM_WRITE MEM_READ CNT_INITIALIZED_DATA\n[240] headers.IMAGE_SECTION_HEADER{5}  Name:.reloc          Raw[0x00000e00:+0x00000200] Virtual[0x00006000:+0x00000010] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n[268] headers.IMAGE_SECTION_HEADER{6}  Name:.debug_aranges  Raw[0x00001000:+0x00000200] Virtual[0x00007000:+0x00000020] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n[290] headers.IMAGE_SECTION_HEADER{7}  Name:.debug_info     Raw[0x00001200:+0x00000800] Virtual[0x00008000:+0x0000062c] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n[2b8] headers.IMAGE_SECTION_HEADER{8}  Name:.debug_abbrev   Raw[0x00001a00:+0x00000200] Virtual[0x00009000:+0x0000013c] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n[2e0] headers.IMAGE_SECTION_HEADER{9}  Name:.debug_line     Raw[0x00001c00:+0x00000200] Virtual[0x0000a000:+0x00000078] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n[308] headers.IMAGE_SECTION_HEADER{10} Name:.debug_line_str Raw[0x00001e00:+0x00000200] Virtual[0x0000b000:+0x00000090] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n</code></pre>\n <p>\n  Let's now go back and fix our linker script to ensure the data section being written to by our example is writable. The following example is the same as the one you provided, but it places the two segments that will be written to in the\n  <code>\n   .data\n  </code>\n  segment. We also discard the\n  <code>\n   .debug\n  </code>\n  segments so they're not included in our final executable. It is worth noting that the section names for your object file only have meaning during the linking process. i.e. We only know that the\n  <code>\n   .data\n  </code>\n  section is written to because we implicitly know that our compiler uses this section for writing.\n </p>\n <pre><code>OUTPUT_FORMAT(pei-i386)\nSECTIONS\n{\n  . = SIZEOF_HEADERS;\n  . = ALIGN(__section_alignment__);\n\n  .text  __image_base__ + ( __section_alignment__ < 0x1000 ? . : __section_alignment__ ) :\n  {\n    *(.text)\n    *(.rdata)\n    *(SORT(.rdata$*))\n    KEEP(*(.pdata*))\n    *(.idata)\n    *(SORT(.idata$*))\n  }\n\n  .data BLOCK(__section_alignment__) :\n  {\n    *(.data) \n    *(.bss) \n  }\n\n  /DISCARD/ :\n  {\n    *(.debug*)\n  }\n}\n</code></pre>\n <p>\n  Now we'll link using the new linker script, and then follow up by dumping out the sections in the resulting file. Note that only one of our sections,\n  <code>\n   .data\n  </code>\n  , has\n  <code>\n   MEM_WRITE\n  </code>\n  set. It's worth noting that there seems to be a section that was forgotten in the original linker script, the\n  <code>\n   .reloc\n  </code>\n  section. This is supposed to contain the relocations for the executable, (\n  <code>\n   IMAGE_DIRECTORY_ENTRY_BASERELOC\n  </code>\n  ), and probably needs to be aligned for that reason. However, none of that is relevant since the linker included it anyways.\n </p>\n <pre><code>$ i686-w64-mingw32-ld.bfd -o sample.working.exe sample.o -T working.lds \n\n$ python -m pecoff -O print -s sample.working.exe\n<class headers.SectionTableArray> 'Sections' headers.IMAGE_SECTION_HEADER[4]\n[178] headers.IMAGE_SECTION_HEADER{0}  Name:.text     Raw[0x00000400:+0x00000200] Virtual[0x00001000:+0x00000068] Characteristics:(0x60000060,32) :> MEM_READ MEM_EXECUTE CNT_INITIALIZED_DATA CNT_CODE\n[1a0] headers.IMAGE_SECTION_HEADER{1}  Name:.eh_frame Raw[0x00000600:+0x00000200] Virtual[0x00002000:+0x00000040] Characteristics:(0x40000040,32) :> MEM_READ CNT_INITIALIZED_DATA\n[1c8] headers.IMAGE_SECTION_HEADER{2}  Name:.data     Raw[0x00000800:+0x00000200] Virtual[0x00003000:+0x00000004] Characteristics:(0xc0000040,32) :> MEM_WRITE MEM_READ CNT_INITIALIZED_DATA\n[1f0] headers.IMAGE_SECTION_HEADER{3}  Name:.reloc    Raw[0x00000a00:+0x00000200] Virtual[0x00004000:+0x00000010] Characteristics:(0x42000040,32) :> MEM_READ MEM_DISCARDABLE CNT_INITIALIZED_DATA\n</code></pre>\n <p>\n  Running this executable appears to work without the platform having any complaints.\n </p>\n <h1>\n  Microsoft's Linker\n </h1>\n <p>\n  As stated in the question, \"Under normal circumstances, a compiled EXE file consists of several sections, such as .text, .rdata, .idata, and so on. VC (Visual C++) has a very useful /MERGE: option, which allows all sections to be merged into a single segment in versions prior to VC2010.\" So, let's explore this.\n </p>\n <p>\n  One caveat, however, is that Microsoft does not appear to have the Visual C++ 2010 Build Tools available publicly. This is amplified due to\n  <a href=\"https://archive.org\" rel=\"nofollow noreferrer\">\n   https://archive.org\n  </a>\n  being down at the moment. The Python wiki, lists\n  <a href=\"https://wiki.python.org/moin/WindowsCompilers\" rel=\"nofollow noreferrer\">\n   https://wiki.python.org/moin/WindowsCompilers\n  </a>\n  , but all of those links appear down. So, this is the version of\n  <code>\n   LINK.EXE\n  </code>\n  that I am forced to use for this answer:\n </p>\n <pre><code>> link nonexist.obj\nMicrosoft (R) Incremental Linker Version 14.39.33523.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nLINK : fatal error LNK1181: cannot open input file 'nonexist.obj'\n</code></pre>\n <p>\n  Checking the help to ensure that it supports the\n  <code>\n   /MERGE\n  </code>\n  parameter.\n </p>\n <pre><code>> link /? | findstr /N \"MERGE\"\n74:      /MERGE:from=to\n</code></pre>\n <p>\n  We will now use the\n  <code>\n   /MERGE\n  </code>\n  parameter to combine the\n  <code>\n   .rdata\n  </code>\n  ,\n  <code>\n   .idata\n  </code>\n  , and\n  <code>\n   .data\n  </code>\n  sections into the\n  <code>\n   .text\n  </code>\n  section. We will also include\n  <code>\n   .reloc\n  </code>\n  too...just in case.\n </p>\n <pre><code>> link.exe /merge:.data=.text /merge:.idata=.text /merge:.rdata=.text /merge:/out:sample.mslink.exe sample.obj\nMicrosoft (R) Incremental Linker Version 14.39.33523.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nLINK : warning LNK4254: section '.data' (C0000040) merged into '.text' (60000020) with different attributes\nLINK : fatal error LNK1272: cannot merge '.idata' with any section\n</code></pre>\n <p>\n  It appears to complain about it. So, we have no real choice but to remove it from the parameters and try again.\n </p>\n <pre><code>> link.exe /merge:.data=.text /merge:.rdata=.text /merge:.reloc=.text /out:sample.mslink.exe sample.obj\nMicrosoft (R) Incremental Linker Version 14.39.33523.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nLINK : warning LNK4254: section '.data' (C0000040) merged into '.text' (60000020) with different attributes\nLINK : fatal error LNK1272: cannot merge '.reloc' with any section\n</code></pre>\n <p>\n  It appears to complain about merging the\n  <code>\n   .reloc\n  </code>\n  section as well.  If we remove that section, then we're only left with being able to merge\n  <code>\n   .data\n  </code>\n  and\n  <code>\n   .rdata\n  </code>\n  into the\n  <code>\n   .text\n  </code>\n  section. This unfortunately means that the most recent version of Microsoft's linker appears to guard against merging the\n  <code>\n   .idata\n  </code>\n  and\n  <code>\n   .text\n  </code>\n  sections together.\n </p>\n <pre><code>> link.exe /merge:.data=.text /merge:.rdata=.text /out:sample.mslink.exe sample.obj\nMicrosoft (R) Incremental Linker Version 14.39.33523.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nLINK : warning LNK4254: section '.data' (C0000040) merged into '.text' (60000020) with different attributes\n\n> dir /b sample.mslink.exe\nsample.mslink.exe \n</code></pre>\n <h1>\n  Linker scripts\n </h1>\n <p>\n  Although the linker script capabilities of\n  <code>\n   ld(1)\n  </code>\n  are very useful, they have no knowledge of what is required by the target platform to run its output. This, of course, is up to the developer writing the linker script.\n </p>\n <p>\n  At the end of an\n  <a href=\"https://blog.talosintelligence.com/exploiting-low-severity-vulnerability-using-a-frame-pointer-overwrite/#using-a-compiler\" rel=\"nofollow noreferrer\">\n   article\n  </a>\n  I'd written, I included a linker script that can be used with MinGW build tools in order to output each of the required segments into one contiguous binary. This is possible because the developer is responsible for performing the load process. The script exports symbols that can be used by the entry point implementation specifically for this purpose.\n </p>\n <p>\n  Although not related to Windows, there's another good example of a linker script at\n  <a href=\"https://secret.club/2023/12/24/riscy-business.html\" rel=\"nofollow noreferrer\">\n   https://secret.club/2023/12/24/riscy-business.html\n  </a>\n </p>\n <hr/>\n <p>\n  As requested in comment for reproduceability (with the imports used by the CRT). This is specific to MinGW CRT's requirements and not at all related to the compiler.\n </p>\n <pre><code>$ cat >| t.c\n#include <stdio.h>\nint main()\n{\n    printf(\"Hello world!\n\");\n    return 0;\n}\n\n$ cat working.lds\nOUTPUT_FORMAT(pei-i386)\nSECTIONS\n{\n  . = SIZEOF_HEADERS;\n  . = ALIGN(__section_alignment__);\n\n  .text  __image_base__ + ( __section_alignment__ < 0x1000 ? . : __section_alignment__ ) :\n  {\n    *(.text)\n    *(SORT(.text*))\n    *(.rdata)\n    *(SORT(.rdata$*))\n    KEEP(*(.pdata*))\n    *(.eh_frame)\n    *(.ctors*)\n  }\n\n  .data BLOCK(__section_alignment__) :\n  {\n    *(.data) \n    *(.bss) \n    *(.CRT)\n    *(SORT(.CRT$*))\n  }\n\n  .idata BLOCK(__section_alignment__) :\n  {\n    // start of imports\n    KEEP (SORT(*)(.idata$2))\n    KEEP (SORT(*)(.idata$3))\n    // sentinel import entry\n    LONG (0); LONG (0); LONG (0); LONG (0); LONG (0);\n    KEEP (SORT(*)(.idata$4))\n    // import address tables\n    __IAT_start__ = .;\n    KEEP (SORT(*)(.idata$5))\n    __IAT_end__ = .;\n    KEEP (SORT(*)(.idata$6))\n    KEEP (SORT(*)(.idata$7))\n    *(.reloc) \n  }\n\n  /DISCARD/ :\n  {\n    *(.debug*)\n  }\n}\n\n$ i686-w64-mingw32-gcc -o t.exe t.c -T working.lds \n\n$ python -m pecoff -s -Oprint t.exe \n<class headers.SectionTableArray> 'Sections' headers.IMAGE_SECTION_HEADER[4]\n[178] headers.IMAGE_SECTION_HEADER{0}  Name:.text  Raw[0x00000400:+0x00002800] Virtual[0x00001000:+0x000027a4] Characteristics:(0x60000060,32) :> MEM_READ MEM_EXECUTE CNT_INITIALIZED_DATA CNT_CODE\n[1a0] headers.IMAGE_SECTION_HEADER{1}  Name:.data  Raw[0x00002c00:+0x00000200] Virtual[0x00004000:+0x00000114] Characteristics:(0xc0000040,32) :> MEM_WRITE MEM_READ CNT_INITIALIZED_DATA\n[1c8] headers.IMAGE_SECTION_HEADER{2}  Name:.tls   Raw[0x00002e00:+0x00000200] Virtual[0x00005000:+0x00000004] Characteristics:(0xc0000040,32) :> MEM_WRITE MEM_READ CNT_INITIALIZED_DATA\n[1f0] headers.IMAGE_SECTION_HEADER{3}  Name:.idata Raw[0x00003000:+0x00000800] Virtual[0x00006000:+0x000006d0] Characteristics:(0xc0000040,32) :> MEM_WRITE MEM_READ CNT_INITIALIZED_DATA\n\n$ python -m pecoff -d -Oprint t.exe \n<class datadirectory.DataDirectory> 'DataDirectory' _object_[16]\n[f8]         datadirectory.IMAGE_DIRECTORY_ENTRY_EXPORT{0}  *0x0:+0x0\n[100]         datadirectory.IMAGE_DIRECTORY_ENTRY_IMPORT{1}  *0x6000:+0x6d0\n[108]       datadirectory.IMAGE_DIRECTORY_ENTRY_RESOURCE{2}  *0x0:+0x0\n[110]      datadirectory.IMAGE_DIRECTORY_ENTRY_EXCEPTION{3}  *0x0:+0x0\n[118]       datadirectory.IMAGE_DIRECTORY_ENTRY_SECURITY{4}  *0x0:+0x0\n[120]      datadirectory.IMAGE_DIRECTORY_ENTRY_BASERELOC{5}  *0x0:+0x0\n[128]          datadirectory.IMAGE_DIRECTORY_ENTRY_DEBUG{6}  *0x0:+0x0\n[130]   datadirectory.IMAGE_DIRECTORY_ENTRY_ARCHITECTURE{7}  *0x0:+0x0\n[138]      datadirectory.IMAGE_DIRECTORY_ENTRY_GLOBALPTR{8}  *0x0:+0x0\n[140]            datadirectory.IMAGE_DIRECTORY_ENTRY_TLS{9}  *0x26ec:+0x18\n[148]    datadirectory.IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG{10} *0x0:+0x0\n[150]   datadirectory.IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT{11} *0x0:+0x0\n[158]            datadirectory.IMAGE_DIRECTORY_ENTRY_IAT{12} *0x60e4:+0xa8\n[160]   datadirectory.IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT{13} *0x0:+0x0\n[168] datadirectory.IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR{14} *0x0:+0x0\n[170]       datadirectory.IMAGE_DIRECTORY_ENTRY_RESERVED{15} *0x0:+0x0\n</code></pre>\n <p>\n  On Windows 11 Enterprise using Developer Essentials VM.\n </p>\n <pre><code>PS Z:\\shared> ./t.exe\nHello world!\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Ali Rizvi-Santiago",
            "time": "Oct 20, 2024 at 17:27",
            "is_accepted": false,
            "comments": [
                {
                    "user": "wqte45",
                    "text": "<span class=\"comment-copy\">Thank you for your answer and analysis. However, the EXE file linked using the modified LDS script you provided still cannot run. I checked it with a PE analysis tool and found that there is no Import Table, which may be the main reason for the issue.</span>",
                    "time": null
                },
                {
                    "user": "Ali Rizvi-Santiago",
                    "text": "<span class=\"comment-copy\">I'll edit my answer to include the exact input and output files that I'm using, but what platform are you running it on, and what error message are you seeing? I'm building with these packages specifically: mingw32-filesystem-148-3.fc40.noarch mingw32-crt-11.0.1-3.fc40.noarch mingw32-winpthreads-11.0.1-3.fc40.noarch mingw32-headers-11.0.1-3.fc40.noarch mingw32-winpthreads-static-11.0.1-3.fc40.noarch mingw32-binutils-2.41-3.fc40.x86_64 mingw32-cpp-14.1.1-3.fc40.x86_64 mingw32-libgcc-14.1.1-3.fc40.x86_64 mingw32-gcc-14.1.1-3.fc40.x86_64 mingw32-gcc-c++-14.1.1-3.fc40.x86_64.</span>",
                    "time": null
                },
                {
                    "user": "wqte45",
                    "text": "<span class=\"comment-copy\">I used your first LDS linker script, and the generated EXE file indeed only has one section, .text. However, this EXE file fails to run, and analysis software reveals that there is no Import Table found. Perhaps it is included, but the addresses are not correctly resolved.  Using your second LDS script, the compilation is successful and the program can run. But it merely merges other sections into .text, while .idata remains a separate section.</span>",
                    "time": null
                },
                {
                    "user": "Ali Rizvi-Santiago",
                    "text": "<span class=\"comment-copy\">As per my comment on the question, you can't merge .idata into .text. it needs to be writable as per the constraints of the rtld (which dispatches into the crt) that you're using. the original answer uses <code>ld</code> to show that it is not linked with any c-runtime which results in no need for an import table and allowing for all sections to be merged. the answer also shows that link.exe doesn't appear to do what was considered.</span>",
                    "time": null
                },
                {
                    "user": "Ali Rizvi-Santiago",
                    "text": "<span class=\"comment-copy\">@thebusybee, fair enough. edited out the reference. apologies in that case. i originally didn't want to write a proper answer due to not being at home or having access to a windows env, hence my polluting of the comments thinking it could just be briefly explained. but the author's doubt and your poking kind of drove me to proving it. i guess that's a good thing, though, and I'll be more aware next time.</span>",
                    "time": null
                }
            ]
        }
    ]
}