{
    "title": "Reverse engineer 4-bit checksum (?) in Sanyo air conditioning IR packet",
    "link": "https://reverseengineering.stackexchange.com/questions/11794/reverse-engineer-4-bit-checksum-in-sanyo-air-conditioning-ir-packet",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am reverse engineering IR protocol of Sanyo air conditioner. AC sends the whole current state of remote on each key press. Data sent is 67 bits long, last 4 bits seem to be the some kind of error checking.\n </p>\n <p>\n  I figured most things out, but I can not find how the error checking is done. Temp + mode are part of it, but I can not find a solution to the entire puzzle. Also any suggestions as to what col. 16 may be (am i missing functionality in the overview?) would be great.\n </p>\n <p>\n  Here are sample values:\n </p>\n <pre><code> 1  2  3 4 5   6   7   8   9  10 11 12      13      14    15  16        17          18\n100 1 00 0 0 1011 00 1111 000 1   1  0 00001010010 0000 00000 0 000100000000000000 1010 ->\n100 1 00 0 0 1011 00 1111 000 1   1  1 00001010010 0000 00000 0 000100000000000000 1010 ->\n100 1 00 1 0 0000 00 0000 000 1   1  0 00001010010 1110 00000 1 000100000000000000 1010\n100 1 00 1 0 1000 00 0000 000 1   1  0 00001010010 1110 00000 1 000100000000000000 0110\n100 1 00 1 0 0100 00 0000 000 1   1  0 00001010010 1110 00000 1 000100000000000000 1110\n100 1 00 1 0 1011 00 0000 000 1   1  0 00001010010 1110 00000 1 000100000000000000 0100\n100 1 00 0 0 0011 00 1111 000 1   1  0 00001010010 0000 00000 0 000100000000000000 0010 ->\n100 1 00 0 0 0011 00 1111 000 1   1  0 00001010010 0000 00000 0 000100000000000000 0010 ->\n100 1 00 0 0 1011 00 0000 000 1   1  0 00001010010 0100 00000 1 000100000000000000 0100\n100 1 00 0 0 1011 00 0000 000 1   1  0 00001010010 1100 00000 1 000100000000000000 0100\n100 1 00 0 0 1011 00 0000 000 1   1  0 00001010010 0010 00000 1 000100000000000000 0100\n100 1 00 0 0 1011 00 0000 000 1   1  0 00001010010 1010 00000 1 000100000000000000 0100\n100 1 00 0 0 1011 00 0000 000 1   1  0 00001010010 0110 00000 1 000100000000000000 0100\n100 1 00 1 0 1011 00 0000 000 1   1  0 00001010010 1000 00000 1 000100000000000000 0100\n100 1 00 1 0 1011 00 0000 000 1   1  0 00001010010 1101 00000 1 000100000000000000 0100\n100 1 00 1 0 1011 00 0000 000 1   1  0 00001010010 1110 00000 1 000100000000000000 0100\n100 1 00 1 0 1011 00 0000 000 1   1  0 00001010010 1001 00000 1 000100000000000000 0100\n100 1 00 0 0 1011 00 0000 000 1   1  0 00001010010 0000 00000 1 000100000000000000 0100\n100 1 10 1 0 1011 00 0000 000 1   1  0 00001010010 1110 00000 1 000100000000000000 0100\n100 1 01 1 0 1011 00 0000 000 1   1  0 00001010010 1110 00000 1 000100000000000000 0100\n100 1 11 1 0 1011 00 0000 000 1   1  0 00001010010 1110 00000 1 000100000000000000 0100\n100 1 00 1 0 1011 00 0000 000 1   1  0 00001010010 1110 00000 1 000100000000000000 0100\n100 1 00 0 0 0011 00 0000 000 0   1  0 00001010010 0000 00000 0 000100000000000000 1000\n100 1 00 0 0 0011 00 0000 000 1   1  0 00001010010 0000 00000 0 000100000000000000 1000\n000 1 10 0 0 1001 00 0000 000 1   1  0 00001010010 0000 00000 0 000100000000000000 1011\n100 1 00 0 0 0011 00 0000 000 1   1  0 00001010010 0000 00000 0 000100000000000000 1000\n010 1 10 0 0 0100 00 0000 000 1   1  0 00001010010 0000 00000 0 000100000000000000 0001\n110 1 00 1 0 1011 00 0000 000 1   1  0 00001010010 1110 00000 0 000100000000000000 0010\n001 1 00 0 0 0011 00 0000 000 1   1  0 00001010010 0000 00000 0 000100000000000000 0010\n100 0 00 1 0 1011 00 0000 000 1   0  0 00001010010 1110 00000 1 000100000000000000 0101\n</code></pre>\n <p>\n  What I found out so far:\n </p>\n <pre><code>1: mode (cool, dry, fan, etc.)\n2: appliance on\n3: fan speed (00 = auto)\n4: sweep motor\n5: constant 0\n6: temperature (16 + bit pattern)\n7: constant 00\n8: 0000, but 1111 if an additional packet is sent with time data ( -> )\n9: constant 000\n10: light on\n11: appliance on\n12: blower on\n13: constant\n14: direction of airflow (low, high, and various angles)\n15: constant\n16: yet unknown\n17: constant\n18: error checking (at least temp + mode is a component of this magic number)\n</code></pre>\n <p>\n  <strong>\n   EDIT1\n  </strong>\n  Stripped rows/cols that don't add information:\n </p>\n <pre><code> 1  2   6   8   11 16  18\n100 1 1011 1111  1  0 1010 ->\n100 1 0000 0000  1  1 1010\n100 1 1000 0000  1  1 0110\n100 1 0100 0000  1  1 1110\n100 1 0011 1111  1  0 0010 ->\n100 1 1011 0000  1  1 0100\n100 1 0011 0000  1  0 1000\n000 1 1001 0000  1  0 1011\n010 1 0100 0000  1  0 0001\n110 1 1011 0000  1  0 0010\n001 1 0011 0000  1  0 0010\n100 0 1011 0000  0  1 0101\n</code></pre>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 2,
    "views": "1k",
    "tags": [
        "binary-analysis",
        "decryption",
        "protocol"
    ],
    "user": "Adhy",
    "time": "Jan 28, 2016 at 6:09",
    "comments": [
        {
            "user": "Sergey",
            "text": "<html><body><span class=\"comment-copy\">\n Please take a look a\n <a href=\"http://www.atomigy.com/blog/?p=227\" rel=\"nofollow noreferrer\">\n  link\n </a>\n , it should help in your reverse engineering\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I approached this from the perspective of a boolean logic simplifier: The more values you can trim, the less inputs your checksum function has and the simpler it will be to understand.\n </p>\n <p>\n  Not a complete solution by any measure, but a few thoughts:\n </p>\n <ul>\n  <li>\n   Trim the rows with identical values from your dataset. They're just noise.\n  </li>\n  <li>\n   Columns 5, 7, 9, 13, 15, and 17 have the same values for every row, so you can only guess as to how they are factored into the checksum. They therefore do not help with determining how the other values are used.\n  </li>\n  <li>\n   Columns 3, 4, 10, 12, and 14 are not included in the checksum, because there are rows with all other values the same and the same checksum.\n  </li>\n  <li>\n   Columns 1, 6, and 8 are definitely included in the checksum, because there are rows with all other values the same, but have a different checksum.\n  </li>\n </ul>\n <p>\n  TL;DR : Simplify your dataset.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Moshe",
            "time": "Jan 27, 2016 at 3:26",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I know this question is old but I found it by sheer chance while working out the bit mappings for this same kind of AC. Look at the post by Catalyn here:\n  <a href=\"https://myesp8266.blogspot.com.ar/2016/05/keep-your-house-cool-with-esp8266.html\" rel=\"nofollow noreferrer\">\n   https://myesp8266.blogspot.com.ar/2016/05/keep-your-house-cool-with-esp8266.html\n  </a>\n  . It seems to be about the same AC protocol and there's something in there about how to calculate the CRC. I haven't tried it yet as I'm currently mapping the bits to the functionality. You have a few I hadn't found yet and saved me some time. BTW Your constant 0 in the 5th column is actually the sleep function.\n </p>\n <p>\n  Edit: I have this sorted out! I found some other good sources of intel, some with crappy code that sometimes worked, and some good documentation with missing assumptions. Merged them and now I have working code. I ignored some bits that I didn't care about but you can figure out how to add them. The CRC calculation I made already takes all into account regardless of them being fixed.\n </p>\n <p>\n  This (java)script will generate a packet according to the the parameters with a proper CRC:\n </p>\n <pre><code>const header = [9050, 4450];\nconst zero_bit = [700, 550];\nconst one_bit = [700, 1650];\n\nconst separator = [700, 19900];\n\nconst MODE = {\n  AUTO:   0x0,\n  COOL:   0x1,\n  DRY:    0x2,\n  FAN:    0x3,\n  HEAT:   0x4\n};\n\nconst POWER = {\n  OFF: 0x0,\n  ON: 0x1\n};\n\nconst FAN = {\n  AUTO: 0x0,\n  SPEED_1: 0x1,\n  SPEED_2: 0x2,\n  SPEED_3: 0x3,\n  SPEED_4: 0x4,\n};\n\nconst SWING = {\n  OFF: 0x0,\n  ON: 0x1\n};\n\nconst SLEEP = {\n  OFF: 0x0,\n  ON: 0x1\n};\n\nconst TURBO = {\n  OFF: 0x0,\n  ON: 0x1\n};\n\nconst LIGHT = {\n  OFF: 0x0,\n  ON: 0x1\n}\n\nconst HEALTH = {\n  OFF: 0x0,\n  ON: 0x1\n}\n\nconst XFAN = {\n  OFF: 0x0,\n  ON: 0x1\n}\n\nconst TEMPERATURE = {\n  BASE: 16\n};\n\nlet state = {\n  mode: MODE.COOL,\n  power: POWER.ON,\n  temperature: 27 - TEMPERATURE.BASE,\n  xfan: XFAN.ON,\n  health: HEALTH.ON,\n  light: LIGHT.ON,\n  turbo: TURBO.OFF,\n  swing: SWING.ON,\n  fan: FAN.AUTO\n};\n\nfunction reverseBits(x, bitLength) {\n    let result = 0;\n\n    for (let index = 0; index < bitLength; ++index) {\n      result |= ((x >> index) & 1) << (bitLength - index - 1)\n    }\n    return result\n}\n\nfunction reverseByte(value) {\n  return reverseBits(value, 8);\n}\n\nfunction reverseNibble(value) {\n  return reverseBits(value, 4);\n}\n\nfunction buildPacket(state) {\n  const byte1 = (reverseBits(state.mode, 3) << 5) | (reverseBits(state.power, 1) << 4) | (reverseBits(state.fan, 2) << 2) | (reverseBits(state.swing, 1) << 1) | (reverseBits(state.sleep, 1) << 0);\n  const byte2 = (reverseBits(state.temperature, 4) << 4);\n  const byte3 = (reverseBits(state.turbo, 1) << 3) | (reverseBits(state.light, 1) << 2) | (reverseBits(state.health, 1) << 1) | (reverseBits(state.xFan, 1) << 1);\n  const byte4 = 0x0A;\n\n  const byte5 = 0;\n  const byte6 = 4;\n  const byte7 = 0;\n  const byte8 = reverseNibble(\n  (\n    (reverseByte(byte1) & 0x0F) +\n    (reverseByte(byte2) & 0x0F) + \n    (reverseByte(byte3) & 0x0F) +\n    (reverseByte(byte4) & 0x0F) +\n    ((reverseByte(byte5) & 0xF0) >> 4 ) +\n    ((reverseByte(byte6) & 0xF0) >> 4 ) + \n    ((reverseByte(byte7) & 0xF0) >> 4 ) + 10\n  ) & 0x0F);\n\n  let data = [];\n  data = data.concat(header);\n  data = pushBits(data, byte1);\n  data = pushBits(data, byte2);\n  data = pushBits(data, byte3);\n  data = pushBits(data, byte4);\n  data = data.concat(zero_bit);\n  data = data.concat(one_bit);\n  data = data.concat(zero_bit);\n  data = data.concat(separator);\n  data = pushBits(data, byte5);\n  data = pushBits(data, byte6);\n  data = pushBits(data, byte7);\n  data = pushBits(data, byte8);\n  data = data.concat([650]);\n\n  return data;\n}\n\nfunction pushBits(data, byte) {\n  for (let i = 7; i >= 0; --i) {\n    if ((byte & (1 << i)) !== 0) {\n      data = data.concat(one_bit);\n    }\n    else {\n      data = data.concat(zero_bit);\n    }\n  }\n  return data;\n}\n\nconst data = buildPacket(state);\nconsole.log(data)\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Fernando Mazzon",
            "time": "Apr 22, 2018 at 19:09",
            "is_accepted": false,
            "comments": []
        }
    ]
}