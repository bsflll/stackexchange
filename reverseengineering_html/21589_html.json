{
    "title": "Identify function in cpp static binary",
    "link": "https://reverseengineering.stackexchange.com/questions/21589/identify-function-in-cpp-static-binary",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  When I open cpp static binary, how can identify known functions like fopen/ioctl/printf? They have been compiled statically into the binary.\n </p>\n <p>\n  I dont know the compiler of this binary .\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "1k",
    "tags": [
        "ida",
        "static-analysis",
        "compilers"
    ],
    "user": "Keystone",
    "time": "Dec 5, 2019 at 3:43",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  As far as I know, there are 3 approaches that have been implemented to identify library functions:\n </p>\n <ol>\n  <li>\n   <a href=\"https://www.hex-rays.com/products/ida/tech/flirt/in_depth.shtml\" rel=\"nofollow noreferrer\">\n    IDA FLIRT\n   </a>\n   essentially uses byte patterns to create function signatures\n  </li>\n  <li>\n   Ghidra's\n   <a href=\"https://github.com/NationalSecurityAgency/ghidra/tree/49c2010b63b56c8f20845f3970fedd95d003b1e9/Ghidra/Features/FunctionID\" rel=\"nofollow noreferrer\">\n    FunctionID\n   </a>\n   feature takes mnemonic and operand type into account when hashing instructions to match functions to their well-known name\n   <ul>\n    <li>\n     this is according to\n     <a href=\"https://twitter.com/williballenthin/status/1144031730963140608\" rel=\"nofollow noreferrer\">\n      Willi Ballenthin's analysis\n     </a>\n    </li>\n    <li>\n     <a href=\"https://github.com/NationalSecurityAgency/ghidra/blob/49c2010b63b56c8f20845f3970fedd95d003b1e9/Ghidra/Features/FunctionID/src/main/java/ghidra/feature/fid/hash/MessageDigestFidHasher.java\" rel=\"nofollow noreferrer\">\n      hashing implementation\n     </a>\n    </li>\n   </ul>\n  </li>\n  <li>\n   JEB's disassembler creates\n   <a href=\"https://docs.google.com/presentation/d/17Vlv5JD8fGeeNMQqDuwDQXN3d9U6Yxmfb1aebfbMM98/view#slide=id.g597565ee72_1_16\" rel=\"nofollow noreferrer\">\n    function signatures by hashing the assembly (not binary code) of the function with a custom hashing algorithm\n   </a>\n   .\n  </li>\n </ol>\n <p>\n  An experimental approach based on machine learning techniques was explored by Google Project Zero's Thomas Dullien in his article \"\n  <a href=\"https://googleprojectzero.blogspot.com/2018/12/searching-statically-linked-vulnerable.html\" rel=\"nofollow noreferrer\">\n   Searching statically-linked vulnerable library functions in executable code: \nHelping researchers find 0ld days\n  </a>\n  \", in which he experimented with using similarity hashing combined with distance metrics in an attempt to identify functions across binaries generated by different compiler toolchains and compilation options. The article also mentions alternative approaches in published research, but besides\n  <a href=\"https://github.com/ANSSI-FR/polichombr/blob/dev/docs/MACHOC_HASH.md\" rel=\"nofollow noreferrer\">\n   MACHOC\n  </a>\n  there is no public code or implementation available.\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "julian",
            "time": "Jul 3, 2019 at 5:28",
            "is_accepted": false,
            "comments": []
        }
    ]
}