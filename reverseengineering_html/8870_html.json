{
    "title": "Extracting arguments from IDA",
    "link": "https://reverseengineering.stackexchange.com/questions/8870/extracting-arguments-from-ida",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Let's say I have the following function in IDA:\n </p>\n <pre><code>int __usercall function<eax>(char* message<ebp>, unsigned int count<edi>)\n</code></pre>\n <p>\n  What's the fastest way to extract the argument information using IDAPython, such that I get the following:\n </p>\n <pre><code>[['char*', 'message', 'ebp'],['unsigned int','count','edi']]\n</code></pre>\n <p>\n  Not that it also needs to handle situations like:\n </p>\n <pre><code>void *__usercall sub_4508B0@<rax>(void *(__usercall *function)@<rax>(int one@<eax>)@<rax>);\n</code></pre>\n <p>\n  Which should give me something along the lines of:\n </p>\n <pre><code>[['void * ...', 'function', 'rax']]\n</code></pre>\n</div>\n</body></html>",
    "votes": "10",
    "answers": 2,
    "views": "6k",
    "tags": [
        "ida",
        "disassembly",
        "idapython",
        "python"
    ],
    "user": "Zach Riggle",
    "time": "May 12, 2015 at 7:32",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I received an answer from HexRays support which has a solution which does not rely on parsing the C string retrieved by\n  <code>\n   GetType(ea)\n  </code>\n  .\n </p>\n <p>\n  Let's imagine we start with a function prototype:\n </p>\n <pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n</code></pre>\n <p>\n  That's from an ELF file, x86 abi; stuff is passed on the stack.\n </p>\n <p>\n  Then, I can do the following:\n </p>\n <pre><code>Python>from idaapi import *\nPython>tif = tinfo_t()\nPython>get_tinfo2(here(), tif)\nTrue\nPython>funcdata = func_type_data_t()\nPython>tif.get_func_details(funcdata)\nTrue\nPython>funcdata.size()\n3\nPython>for i in xrange(funcdata.size()):\nPython>    print \"Arg %d: %s (of type %s, and of location: %s)\" % (i, funcdata[i].name, print_tinfo('', 0, 0, PRTYPE_1LINE, funcdata[i].type, '', ''), funcdata[i].argloc.atype())\nPython>\nArg 0: argc (of type int, and of location: 1)\nArg 1: argv (of type const char **, and of location: 1)\nArg 2: envp (of type const char **, and of location: 1)\n</code></pre>\n <p>\n  Note that it tells me the location type is\n  <code>\n   1\n  </code>\n  , which corresponds\nto 'stack':\n  <a href=\"https://www.hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\">\n   https://www.hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\n  </a>\n </p>\n <p>\n  Now, let's assume I change the prototype to this:\n </p>\n <pre><code>.text:0804ABA1 ; int __usercall main@<eip>(int argc@<eax>, const char **argv@<esp>, const char **envp@<edx>)\n</code></pre>\n <p>\n  Then:\n </p>\n <pre><code>Python>get_tinfo2(here(), tif)\nTrue\nPython>tif.get_func_details(funcdata)\nTrue\nPython>for i in xrange(funcdata.size()):\nPython>    print \"Arg %d: %s (of type %s, and of location: %s)\" % (i, funcdata[i].name, print_tinfo('', 0, 0, PRTYPE_1LINE, funcdata[i].type, '', ''), funcdata[i].argloc.atype())\nPython>\nArg 0: argc (of type int, and of location: 3)\nArg 1: argv (of type const char **, and of location: 3)\nArg 2: envp (of type const char **, and of location: 3)\n</code></pre>\n <p>\n  Argument location type is\n  <code>\n   3\n  </code>\n  now, which corresponds to 'inside\nregister'.\n </p>\n <p>\n  (Then, I would have to use\n  <code>\n   reg1()\n  </code>\n  to retrieve the actual\nregister number to know\n  <em>\n   what\n  </em>\n  register the argument is\npassed in)\n </p>\n <p>\n  Credit goes to Arnaud of Hex Rays.\n </p>\n</div>\n</body></html>",
            "votes": "15",
            "user": "Zach Riggle",
            "time": "May 12, 2015 at 16:28",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Using the minsc plugin at\n  <a href=\"https://github.com/arizvisa/ida-minsc/tree/persistence-refactor\" rel=\"nofollow noreferrer\">\n   https://github.com/arizvisa/ida-minsc\n  </a>\n  , you can access information about a function (address, or\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/classfunc__t-members.html\" rel=\"nofollow noreferrer\">\n   <code>\n    func_t\n   </code>\n  </a>\n  ) or its prototype (\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/classtinfo__t-members.html\" rel=\"nofollow noreferrer\">\n   <code>\n    tinfo_t\n   </code>\n  </a>\n  ) using the\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type\n   </code>\n  </a>\n  namespace.\n </p>\n <p>\n  <em>\n   Disclaimer: I maintain the ida-minsc plugin.\n  </em>\n </p>\n <p>\n  In this namespace are\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-argument\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.argument\n   </code>\n  </a>\n  (for a single parameter), which is aliased as\n  <code>\n   function.arg\n  </code>\n  , or\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-arguments\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.arguments\n   </code>\n  </a>\n  (for all parameters), which is aliased as\n  <code>\n   function.args\n  </code>\n  . For the result of a prototype, there is also the\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-result\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.result\n   </code>\n  </a>\n  namespace, which is aliased as\n  <code>\n   function.result\n  </code>\n  . These namespaces include 3 classes of functions that can be used to fetch or modify their target.\n </p>\n <h1>\n  Types\n </h1>\n <p>\n  The\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-argument\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.arg\n   </code>\n  </a>\n  and\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-arguments\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.args\n   </code>\n  </a>\n  namespaces can be used as a function to interact with the type of a parameter for a prototype.\n </p>\n <pre><code>Python>func.t()\n__int64 __fastcall(char *Handle, __int64, __int64)\n\n# Get type of first parameter (0).\nPython>func.arg(idc.here(), 0)\nchar *\n\n# Return a list containing the type used for each of the parameters\nPython>func.args(idc.here())\n[char *, __int64, __int64]\n\n# Return the type of result, and then change it to void. Each of\n# these return their previous value if you change your mind.\nPython>func.result()\n__int64\n\nPython>func.result('void')\n__int64\n\n# Show the type being changed.\nPython>func.t()\nvoid __fastcall(char *Handle, __int64, __int64)\n</code></pre>\n <p>\n  <em>\n   Something worth noting about\n   <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-arguments\" rel=\"nofollow noreferrer\">\n    <code>\n     function.type.args\n    </code>\n   </a>\n   is that it has the ability to change the number of function arguments depending on the length of its parameter.\n  </em>\n </p>\n <h1>\n  Names\n </h1>\n <p>\n  The next class of functions would be to interact with the parameter names. These are handled by the\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.argument.name\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.argument.name\n   </code>\n  </a>\n  and\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.arguments.names\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.arguments.names\n   </code>\n  </a>\n  .\n </p>\n <p>\n  <em>\n   It is worth nothing that\n   <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.arguments.names\" rel=\"nofollow noreferrer\">\n    <code>\n     function.type.arguments.names\n    </code>\n   </a>\n   does not affect the number of function parameters. Therefore it can also be used to erase all of the names associated with a function in case you only want IDA to propagate the types (rather than the parameter names). This can be combined with\n   <a href=\"https://arizvisa.github.io/ida-minsc/tagging.html\" rel=\"nofollow noreferrer\">\n    tags\n   </a>\n   to identify the changes that have been mistakenly propagated.\n  </em>\n </p>\n <pre><code>Python>h = idc.here()\nPython>func.t()\n__int64 __fastcall(char *Handle, __int64, __int64)\n\nPython>func.tag('__typeinfo__')\n'void __fastcall NtUserGetProcessDpiAwarenessContext(char *Handle, __int64, __int64)' \n\n# Return the name of the first argument.\nPython>func.arg.name(idc.here(), 0)\n'Handle'\n\n# Return all the names for each parameter. As opposed to using the\n# address, this acts directly on the tinfo_t for the function.\nPython>func.args.names(func.type(h()))\n['Handle', '', '']\n\n# Change the name for all of the parameters for the current function.\nPython>func.args.names('a b c'.split(' '))\n['Handle', '', '']\n\n# Render the full function prototype (extracting it from a tag).\nPython>func.tag('__typeinfo__')\n'void __fastcall NtUserGetProcessDpiAwarenessContext(char *a, __int64 b, __int64 c)'\n\n# Remove each parameter name from the function prototype.\nPython>func.t()\nvoid __fastcall(char *a, __int64 b, __int64 c)\n\nPython>func.args.names([])\n['a', 'b', 'c']\n\nPython>func.t()\nvoid __fastcall(char *, __int64, __int64)\n</code></pre>\n <h1>\n  Storage\n </h1>\n <p>\n  The final class of functions is for accessing the storage being used for a parameter. This is exposed via the\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.argument.storage\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.argument.storage\n   </code>\n  </a>\n  and\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.arguments.storage\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.arguments.storage\n   </code>\n  </a>\n  functions. The storage can be returned in multiple ways depending on how the prototype is defined. The most general case is a register (\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\">\n   <code>\n    ALOC_REG1\n   </code>\n  </a>\n  ) or storage location relative to the stack pointer (\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\">\n   <code>\n    ALOC_STACK\n   </code>\n  </a>\n  ). Another way is via a phrase, being an offset relative to a register (\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\">\n   <code>\n    ALOC_RREL\n   </code>\n  </a>\n  ). Some other ways are a static address (\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\">\n   <code>\n    ALOC_STATIC\n   </code>\n  </a>\n  ), a list of contiguous registers (\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\">\n   <code>\n    ALOC_REG2\n   </code>\n  </a>\n  ), or a dictionary (\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\">\n   <code>\n    ALOC_DIST\n   </code>\n  </a>\n  )\n </p>\n <pre><code>Python>func.t()\n__int64 __usercall@<rax>(unsigned int@<ecx>, unsigned int@<edx>, unsigned int@<r8d>, unsigned int@<r9d>, int, unsigned int, unsigned int)\n\nPython>func.convention() == idaapi.CM_CC_SPECIAL\nTrue\n\n# Get the storage location for the 3rd parameter (2) and the result.\nPython>func.arg.storage(2), func.result.storage()\n(<class 'register_t' index=8 dtype=dt_dword name='r8d' position=0+32>, <class 'register_t' index=0 dtype=dt_qword name='rax' position=0+64>) \n\n# Stringify all of the storage locations for the prototype.\nPython>[\"{!s}\".format(x) for x in func.args.storage()]\n['%ecx', '%edx', '%r8d', '%r9d', 'location_t(offset=0x20, size=4)', 'location_t(offset=0x28, size=4)', 'location_t(offset=0x30, size=4)'] \n\n# Translate the location relative to the current stack pointer.\nPython>func.arg.storage(5)\nlocation_t(offset=0x28, size=4)\n\nPython>ins.reg.esp\n<class 'register_t' index=4 dtype=dt_dword name='esp' position=0+32>\n\nPython>func.arg.storage(5) + ins.reg.esp\nlocation_t(offset=0xffffc404, size=4)\n</code></pre>\n <h1>\n  Spoiled\n </h1>\n <p>\n  If you need to access the spoiled registers of a prototype, you can accomplish this with the\n  <a href=\"https://github.com/arizvisa/ida-minsc/blob/persistence-refactor/base/function.py#L3834\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.spoiled\n   </code>\n  </a>\n  function.\n </p>\n <pre><code>Python>func.t()\n__int64 __usercall@<rax>(unsigned int@<ecx>, unsigned int@<edx>, unsigned int@<r8d>, unsigned int@<r9d>, int, unsigned int, unsigned int)\n\n# Verify there are no spoiled registers, then assign some by name or symbol.\nPython>func.t.spoiled()\n[]\n\nPython>func.t.spoiled(['eax', ins.reg.rsi])\n[]\n\nPython>func.t()\n__int64 __usercall __spoils<eax,rsi>@<rax>(unsigned int@<ecx>, unsigned int@<edx>, unsigned int@<r8d>, unsigned int@<r9d>, int, unsigned int, unsigned int)\n\n# Clear the spoiled registers from the prototype.\nPython>func.t.spoiled([])\n[]\n\nPython>func.t()\n__int64 __usercall __spoils<>@<rax>(unsigned int@<ecx>, unsigned int@<edx>, unsigned int@<r8d>, unsigned int@<r9d>, int, unsigned int, unsigned int)\n\n# Remove the spoiled attribute entirely.\nPython>func.t.spoiled(None)\n[<class 'register_t' index=0 dtype=dt_dword name='eax' position=0+32>, <class 'register_t' index=6 dtype=dt_qword name='rsi' position=0+64>]\n\nPython>func.t()\n__int64 __usercall@<rax>(unsigned int@<ecx>, unsigned int@<edx>, unsigned int@<r8d>, unsigned int@<r9d>, int, unsigned int, unsigned int)\n</code></pre>\n <h1>\n  Combined\n </h1>\n <p>\n  Combining all of these together can be done individually or by using the\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.arguments.iterate\" rel=\"nofollow noreferrer\">\n   <code>\n    function.type.arguments.iterate\n   </code>\n  </a>\n  function.\n </p>\n <pre><code>Python>for type, name, storage in zip(func.args(), func.args.names(), func.args.storage()):\nPython> print([\"{!s}\".format(type), name, \"{:s}\".format(storage)])\nPython>\n['unsigned int', '', 'ecx']\n['unsigned int', '', 'edx']\n['unsigned int', '', 'r8d']\n['unsigned int', '', 'r9d']\n['int', '', '0x20+4']\n['unsigned int', '', '0x28+4']\n['unsigned int', '', '0x30+4']\n\nPython>for index, (name, type, storage) in enumerate(func.args.iterate()):\nPython> print(index, [\"{!s}\".format(item) for item in [type, name, storage]])\nPython>\n0 ['unsigned int', '', '%ecx']\n1 ['unsigned int', '', '%edx']\n2 ['unsigned int', '', '%r8d']\n3 ['unsigned int', '', '%r9d']\n4 ['int', '', 'location_t(offset=0x20, size=4)']\n5 ['unsigned int', '', 'location_t(offset=0x28, size=4)']\n6 ['unsigned int', '', 'location_t(offset=0x30, size=4)'] \n</code></pre>\n</div>\n</body></html>",
            "votes": "0",
            "user": "Ali Rizvi-Santiago",
            "time": "Jul 22, 2024 at 17:38",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Ali Rizvi-Santiago",
                    "text": "<span class=\"comment-copy\">(Sorry for the advert on your q, ebeip90).</span>",
                    "time": null
                }
            ]
        }
    ]
}