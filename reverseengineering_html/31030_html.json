{
    "title": "Need help with modifying DOS game extracting graphics codes",
    "link": "https://reverseengineering.stackexchange.com/questions/31030/need-help-with-modifying-dos-game-extracting-graphics-codes",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have the following two Codes which make up a DOS Game Graphics Image Extracting Program, written in C# :-\n </p>\n <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.IO;\n\n\nnamespace Unpac {\nclass Program {\n\n    //_____________________________________________________________________\n    static string       input_filename_no_ext;\n    static int          current_output_index;\n    static string       output_directory;\n    static List<byte>   output_buffer;\n    static int          image_height;\n    static int          line_min_length;\n    static int          line_max_length;\n\n    //_____________________________________________________________________\n    static void Main(string[] args) {\n\n        int?        forced_image_width;\n        string      input_fullpath;\n        string      input_directory;\n        string      input_filename;\n        byte[]      input_data;\n        long        input_max_valid_position;\n        long        current_input_position;\n        byte        input_byte;\n        byte        RLE_sumador;\n        int         count;\n        byte        b;\n        int         n;\n        bool        RLE_FC_swap;\n        byte        b2;\n        int         width_current;\n\n\n        if(args.Length<2) {\n            Console.WriteLine(\"Use: unpac.exe <InputFile.pac> <OutputDir> [ImageWidth]\");\n            return;\n        }\n\n        if(args.Length>2) {\n            forced_image_width = int.Parse(args[2]);\n        } else {\n            forced_image_width = null;\n        }\n        \n        try {\n            input_fullpath      = Path.GetFullPath(args[0]);\n            input_directory     = Path.GetDirectoryName(input_fullpath);\n            input_filename      = Path.GetFileName(input_fullpath);\n\n            input_fullpath      = Path.Combine(input_directory, input_filename);\n            if(!File.Exists(input_fullpath)) throw new Exception();\n\n            int p = input_filename.LastIndexOf('.');\n            if(p==-1) {\n                input_filename_no_ext = input_filename;\n            } else {\n                input_filename_no_ext = input_filename.Substring(0, p);\n            }\n\n        } catch {\n            Console.WriteLine(\"ERROR: invalid input file\");\n            return;\n        }\n\n        try {\n            output_directory = Path.GetFullPath(args[1]);\n            if(!Directory.Exists(output_directory)) {\n                Directory.CreateDirectory(output_directory);\n            }\n        } catch {\n            Console.WriteLine(\"ERROR: invalid output directory\");\n            return;\n        }\n\n        try {\n            input_data = File.ReadAllBytes(input_fullpath);\n        } catch {\n            Console.WriteLine(\"ERROR: cannot read from input file\");\n            return;\n        }\n\n        Console.WriteLine($\"{input_filename}\");\n\n        input_max_valid_position    = input_data.Length - 1;\n        current_input_position      = 0;\n        current_output_index        = 1;\n        output_buffer               = new List<byte>();\n\n        RLE_sumador                 = 0;\n        line_min_length             = int.MaxValue;\n        line_max_length             = 0;\n        width_current               = 0;\n        image_height                = 0;\n\n        while(current_input_position <= input_max_valid_position) {\n\n            input_byte = input_data[current_input_position];\n            current_input_position++;\n\n            if(input_byte == 0xFF) {\n                //==============\n                // Fin de chunk\n                //==============\n                Save();\n                current_output_index++;\n\n                RLE_sumador         = 0;\n                line_min_length     = int.MaxValue;\n                line_max_length     = 0;\n                width_current       = 0;\n                image_height        = 0;\n\n            } else if(input_byte == 0xFE) {\n                //=================\n                // Siguiente linea\n                //=================\n                if(width_current < line_min_length) line_min_length = width_current;\n                if(width_current > line_max_length) line_max_length = width_current;\n\n                if(forced_image_width!=null) {\n                    count = forced_image_width.Value - width_current;\n                    if(count > 0) {\n                        for(n=0; n<count; n++) {\n                            output_buffer.Add(0);\n                        }\n                    }\n                }\n\n                image_height++;\n                width_current = 0;\n\n            } else if(input_byte == 0xFD) {\n                count = (int) (input_data[current_input_position]) + 1;\n                current_input_position++;\n\n                b = input_data[current_input_position];\n                current_input_position++;\n\n                for(n=0; n<count; n++) {\n                    output_buffer.Add(b);\n                }\n\n                width_current += count;\n\n            } else if(input_byte == 0xFC) {\n                b = input_data[current_input_position];\n                current_input_position++;\n\n                b2 = (byte)(b + 1);\n\n                count = (int) (input_data[current_input_position]) + 1;\n                current_input_position++;\n\n                RLE_FC_swap = false;\n                for(n=0; n<count; n++) {\n                    output_buffer.Add(\n                        RLE_FC_swap ? b2 : b\n                    );\n                    RLE_FC_swap = !RLE_FC_swap;\n                }\n\n                width_current += count;\n\n            } else if(input_byte == 0xFB) {\n                RLE_sumador = input_data[current_input_position];\n                current_input_position++;\n\n            } else {\n                b = (byte)(input_byte >> 2);\n                b += RLE_sumador;\n                count = (input_byte & 3) + 1;\n\n                for(n=0; n<count; n++) {\n                    output_buffer.Add(b);\n                }\n\n                width_current += count;\n            }\n        }\n\n        Save();\n    }\n\n    //_____________________________________________________________________\n    static void Save() {\n\n        if(output_buffer.Count == 0) return;\n\n        string  output_filename;\n        string  output_fullpath;\n        byte[]  output_array;\n        int     output_length;\n        bool    is_valid_image;\n\n\n        output_filename = $\"{input_filename_no_ext}.{current_output_index:D3}\";\n        output_fullpath = Path.Combine(output_directory, output_filename);\n        output_array    = output_buffer.ToArray();\n        output_length   = output_array.Length;\n        is_valid_image  = false;\n\n\n        if(image_height > 0) {\n            if(line_min_length != line_max_length) {\n                Console.WriteLine($\" -> {output_filename} ({output_length}) (min width:{line_min_length}) (max width:{line_max_length}) (height:{image_height})\");\n            } else {\n                Console.WriteLine($\" -> {output_filename} ({output_length}) (width:{line_min_length}) (height:{image_height})\");\n                is_valid_image = true;\n            }\n        } else {\n            Console.WriteLine($\" -> {output_filename} ({output_length})\");\n        }\n\n        try {\n            if(is_valid_image) {\n                Bitmap.Save(output_fullpath + \".bmp\", output_array, line_min_length, image_height);\n            } else {\n                File.WriteAllBytes(output_fullpath, output_array);\n            }\n        } catch {\n            Console.WriteLine(\"ERROR: cannot save to output file\");\n        }\n\n        output_buffer.Clear();\n    }\n\n}\n}\n</code></pre>\n <p>\n  And :-\n </p>\n <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\n\nnamespace Unpac {\npublic static class Bitmap {\n\n    private static byte[]           Header;\n    private readonly static byte[]  Paleta;\n\n    static Bitmap() {\n        Header = new byte[0x436];\n        Header[0] = 0x42;\n        Header[1] = 0x4D;\n        Header[0xA] = 0x36;\n        Header[0xB] = 0x04;\n        Header[0xE] = 0x28;\n        Header[0x1A] = 1;\n        Header[0x1C] = 8;\n        Header[0x26] = 0x12;\n        Header[0x27] = 0x0B;\n        Header[0x2A] = 0x12;\n        Header[0x2B] = 0x0B;\n\n        \n        // Grayscale palette\n        int dst_pos = 0x36;\n        int color;\n        for(color=0; color<0x100; color++) {\n            Header[dst_pos++] = (byte) (color << 2);\n            Header[dst_pos++] = (byte) (color << 2);\n            Header[dst_pos++] = (byte) (color << 2);\n            dst_pos++;\n        }\n\n        \n        /*Paleta = new byte[] {\n            0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x05, 0x05, 0x05, 0x08, 0x08, 0x08, 0x0A, 0x0A, 0x0A, 0x0D,\n            0x0D, 0x0D, 0x10, 0x10, 0x10, 0x13, 0x13, 0x13, 0x16, 0x16, 0x16, 0x19, 0x19, 0x19, 0x1C, 0x1C,\n            0x1C, 0x1F, 0x1F, 0x1F, 0x22, 0x22, 0x22, 0x25, 0x25, 0x25, 0x27, 0x27, 0x27, 0x2A, 0x2A, 0x2A,\n            0x2D, 0x2D, 0x2D, 0x30, 0x30, 0x30, 0x33, 0x33, 0x33, 0x36, 0x36, 0x36, 0x39, 0x39, 0x39, 0x3C,\n            0x3C, 0x3C, 0x3F, 0x3F, 0x3F, 0x19, 0x3F, 0x19, 0x0F, 0x32, 0x0F, 0x08, 0x25, 0x08, 0x03, 0x19,\n            0x03, 0x39, 0x0C, 0x0C, 0x2E, 0x06, 0x06, 0x23, 0x01, 0x01, 0x18, 0x00, 0x00, 0x15, 0x3F, 0x3F,\n            0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0x2C, 0x00, 0x00, 0x00, 0x17, 0x00, 0x3F, 0x38, 0x1F, 0x3C,\n            0x34, 0x1A, 0x39, 0x30, 0x16, 0x36, 0x2C, 0x12, 0x33, 0x28, 0x0E, 0x31, 0x24, 0x0B, 0x2E, 0x20,\n            0x08, 0x2B, 0x1D, 0x05, 0x28, 0x19, 0x03, 0x25, 0x16, 0x01, 0x23, 0x13, 0x00, 0x19, 0x27, 0x2E,\n            0x18, 0x18, 0x18, 0x1E, 0x1E, 0x1E, 0x0B, 0x0B, 0x0B, 0x2A, 0x00, 0x2A, 0x2A, 0x00, 0x2A, 0x2A,\n            0x00, 0x2A, 0x2A, 0x00, 0x2A, 0x2A, 0x00, 0x2A, 0x2A, 0x00, 0x2A, 0x2A, 0x00, 0x2A, 0x2A, 0x00,\n            0x2A, 0x2A, 0x00, 0x2A, 0x2A, 0x00, 0x2A, 0x2A, 0x00, 0x2A, 0x2A, 0x00, 0x2A, 0x2A, 0x00, 0x2A,\n            0x1E, 0x20, 0x20, 0x12, 0x12, 0x12, 0x10, 0x10, 0x10, 0x0F, 0x0F, 0x0F, 0x0E, 0x0E, 0x0E, 0x0D,\n            0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x00, 0x0C, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x08,\n            0x00, 0x00, 0x06, 0x00, 0x0B, 0x0C, 0x06, 0x0A, 0x0B, 0x06, 0x09, 0x0A, 0x06, 0x06, 0x06, 0x00,\n            0x09, 0x0A, 0x0A, 0x0D, 0x0D, 0x0D, 0x12, 0x12, 0x12, 0x19, 0x19, 0x19, 0x2B, 0x02, 0x00, 0x33,\n            0x1A, 0x06, 0x39, 0x2B, 0x0C, 0x3C, 0x33, 0x0F, 0x02, 0x11, 0x03, 0x07, 0x16, 0x06, 0x0F, 0x1B,\n            0x0D, 0x2F, 0x19, 0x12, 0x31, 0x31, 0x31, 0x35, 0x35, 0x35, 0x3A, 0x3A, 0x3A, 0x3F, 0x3F, 0x3F,\n            0x31, 0x3D, 0x3D, 0x2E, 0x3D, 0x3D, 0x2B, 0x3D, 0x3D, 0x28, 0x3D, 0x3D, 0x22, 0x3D, 0x3D, 0x1A,\n            0x3D, 0x3D, 0x17, 0x3B, 0x3D, 0x17, 0x39, 0x3D, 0x16, 0x38, 0x3D, 0x15, 0x37, 0x3D, 0x14, 0x36,\n            0x3D, 0x12, 0x34, 0x3D, 0x14, 0x28, 0x12, 0x00, 0x22, 0x0A, 0x00, 0x20, 0x09, 0x00, 0x1F, 0x08,\n            0x00, 0x1E, 0x07, 0x00, 0x1D, 0x06, 0x00, 0x1C, 0x05, 0x00, 0x1B, 0x04, 0x0E, 0x18, 0x2D, 0x00,\n            0x12, 0x22, 0x00, 0x11, 0x21, 0x00, 0x10, 0x20, 0x00, 0x0F, 0x1F, 0x00, 0x0E, 0x1E, 0x00, 0x0D,\n            0x1D, 0x00, 0x0C, 0x1C, 0x0F, 0x23, 0x0E, 0x01, 0x1A, 0x05, 0x00, 0x19, 0x04, 0x00, 0x18, 0x03,\n            0x00, 0x17, 0x02, 0x00, 0x16, 0x01, 0x00, 0x15, 0x00, 0x00, 0x14, 0x00, 0x13, 0x27, 0x15, 0x00,\n            0x1F, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x1D, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x1A,\n            0x00, 0x00, 0x19, 0x00, 0x22, 0x22, 0x22, 0x18, 0x18, 0x17, 0x16, 0x16, 0x16, 0x15, 0x15, 0x15,\n            0x14, 0x14, 0x14, 0x13, 0x13, 0x13, 0x12, 0x12, 0x12, 0x11, 0x11, 0x11, 0x11, 0x25, 0x13, 0x00,\n            0x1D, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x19, 0x00, 0x00, 0x18,\n            0x00, 0x00, 0x17, 0x00, 0x0A, 0x06, 0x00, 0x0E, 0x09, 0x00, 0x0F, 0x0C, 0x00, 0x13, 0x0F, 0x00,\n            0x19, 0x14, 0x00, 0x1A, 0x16, 0x00, 0x22, 0x1C, 0x12, 0x26, 0x22, 0x18, 0x2A, 0x2B, 0x1D, 0x20,\n            0x21, 0x0A, 0x1E, 0x1F, 0x08, 0x1D, 0x1E, 0x07, 0x1C, 0x1D, 0x06, 0x1B, 0x1C, 0x06, 0x1A, 0x1B,\n            0x06, 0x19, 0x1A, 0x06, 0x1B, 0x00, 0x00, 0x15, 0x00, 0x00, 0x20, 0x0A, 0x00, 0x1C, 0x08, 0x00,\n            0x04, 0x16, 0x09, 0x06, 0x1A, 0x0B, 0x09, 0x1C, 0x0D, 0x0A, 0x21, 0x2D, 0x06, 0x1C, 0x2E, 0x2B,\n            0x29, 0x35, 0x26, 0x25, 0x34, 0x2F, 0x2D, 0x36, 0x00, 0x12, 0x09, 0x38, 0x38, 0x38, 0x00, 0x0E,\n            0x08, 0x0A, 0x21, 0x22, 0x06, 0x1C, 0x1C, 0x2B, 0x29, 0x35, 0x26, 0x25, 0x34, 0x2F, 0x2D, 0x36,\n            0x00, 0x0E, 0x00, 0x04, 0x15, 0x04, 0x00, 0x18, 0x00, 0x08, 0x1D, 0x08, 0x1E, 0x20, 0x32, 0x2B,\n            0x29, 0x35, 0x3F, 0x15, 0x3F, 0x32, 0x00, 0x32, 0x08, 0x0E, 0x00, 0x0A, 0x11, 0x04, 0x11, 0x13,\n            0x00, 0x16, 0x18, 0x00, 0x23, 0x23, 0x1D, 0x2A, 0x29, 0x24, 0x3F, 0x15, 0x3F, 0x32, 0x00, 0x32,\n            0x03, 0x13, 0x07, 0x05, 0x17, 0x0A, 0x08, 0x1A, 0x0C, 0x0A, 0x1D, 0x0E, 0x1A, 0x2C, 0x3F, 0x14,\n            0x28, 0x3F, 0x00, 0x26, 0x3F, 0x3F, 0x15, 0x3F, 0x05, 0x0B, 0x05, 0x00, 0x0A, 0x00, 0x00, 0x12,\n            0x00, 0x00, 0x15, 0x00, 0x1D, 0x23, 0x23, 0x1A, 0x1F, 0x1F, 0x16, 0x1A, 0x19, 0x3F, 0x15, 0x3F,\n            0x10, 0x14, 0x00, 0x12, 0x18, 0x00, 0x0F, 0x11, 0x00, 0x25, 0x25, 0x2A, 0x21, 0x21, 0x27, 0x21,\n            0x21, 0x26, 0x06, 0x0D, 0x00, 0x0B, 0x0F, 0x00, 0x30, 0x30, 0x36, 0x2A, 0x2C, 0x30, 0x27, 0x2A,\n            0x2D, 0x29, 0x29, 0x2E, 0x25, 0x25, 0x2B, 0x26, 0x26, 0x2B, 0x30, 0x32, 0x3C, 0x34, 0x35, 0x3F,\n            0x00, 0x00, 0x00, 0x00, 0x0C, 0x20, 0x00, 0x20, 0x00, 0x0E, 0x0E, 0x0E, 0x28, 0x00, 0x00, 0x10,\n            0x14, 0x00, 0x0A, 0x0A, 0x0A, 0x29, 0x29, 0x29, 0x0F, 0x0F, 0x0F, 0x00, 0x22, 0x2E, 0x00, 0x2C,\n            0x00, 0x00, 0x39, 0x39, 0x39, 0x00, 0x00, 0x38, 0x28, 0x00, 0x3F, 0x34, 0x00, 0x3F, 0x3F, 0x3F\n        };\n\n        \n        int src_pos = 0;\n        int dst_pos = 0x36;\n        int color;\n        for(color=0; color<0x100; color++) {\n            Header[dst_pos++] = (byte) (Paleta[src_pos++] << 2);\n            Header[dst_pos++] = (byte) (Paleta[src_pos++] << 2);\n            Header[dst_pos++] = (byte) (Paleta[src_pos++] << 2);\n            dst_pos++;\n        }*/\n\n        /*Paleta2 = new byte[] {\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03,\n            0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08,\n            0x09, 0x09, 0x09, 0x0A, 0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0E,\n            0x0E, 0x0E, 0x0F, 0x0E, 0x0E, 0x10, 0x0F, 0x0F, 0x11, 0x10, 0x10, 0x12, 0x11, 0x11, 0x13, 0x12,\n            0x12, 0x14, 0x13, 0x13, 0x15, 0x14, 0x14, 0x16, 0x15, 0x15, 0x17, 0x16, 0x16, 0x18, 0x17, 0x17,\n            0x19, 0x18, 0x18, 0x1A, 0x18, 0x18, 0x1B, 0x19, 0x19, 0x1C, 0x1A, 0x1A, 0x1D, 0x1B, 0x1B, 0x1E,\n            0x1C, 0x1C, 0x1F, 0x1D, 0x1D, 0x20, 0x1E, 0x1E, 0x21, 0x1F, 0x1F, 0x22, 0x20, 0x20, 0x23, 0x21,\n            0x21, 0x24, 0x22, 0x22, 0x25, 0x23, 0x23, 0x26, 0x24, 0x24, 0x27, 0x24, 0x24, 0x28, 0x25, 0x25,\n            0x29, 0x26, 0x26, 0x2A, 0x27, 0x27, 0x2B, 0x28, 0x28, 0x2C, 0x29, 0x29, 0x2D, 0x2A, 0x2A, 0x2E,\n            0x2B, 0x2B, 0x2F, 0x2C, 0x2C, 0x30, 0x2D, 0x2D, 0x31, 0x2E, 0x2E, 0x32, 0x2E, 0x2E, 0x33, 0x30,\n            0x30, 0x35, 0x30, 0x30, 0x36, 0x31, 0x31, 0x37, 0x32, 0x32, 0x38, 0x33, 0x33, 0x39, 0x34, 0x34,\n            0x3A, 0x35, 0x35, 0x3B, 0x36, 0x36, 0x3C, 0x37, 0x37, 0x3D, 0x38, 0x38, 0x3E, 0x39, 0x39, 0x3F\n        };\n\n        src_pos = 0;\n        dst_pos = 0x36;\n        for(color=0; color<64; color++) {\n            Header[dst_pos++] = (byte) (Paleta2[src_pos++] << 2);\n            Header[dst_pos++] = (byte) (Paleta2[src_pos++] << 2);\n            Header[dst_pos++] = (byte) (Paleta2[src_pos++] << 2);\n            dst_pos++;\n        }*/\n    }\n\n    public static bool Save(string filename, byte[] image_data, int width, int height) {\n        \n        byte[]  output_array;\n        int     image_length;\n        int     file_size;\n        int     width_dword_align_padding;\n        int     width_virtual;\n        bool    fix_alignment;\n        int     n;\n        int     pos_src, pos_dst;\n        \n\n        width_dword_align_padding = 4 - (width & 3);\n        width_virtual = width;\n        if(width_dword_align_padding != 4) width_virtual += width_dword_align_padding;\n        fix_alignment = width != width_virtual;\n\n        try {\n            image_length    = width_virtual * height;\n            file_size       = 0x436 + image_length;\n            output_array    = new byte[file_size];\n        \n            // Header\n            System.Buffer.BlockCopy(Header, 0, output_array, 0, 0x436);\n            // Header File size\n            System.Buffer.BlockCopy(BitConverter.GetBytes(file_size), 0, output_array, 2, 4);\n            // Header image width\n            System.Buffer.BlockCopy(BitConverter.GetBytes(width), 0, output_array, 0x12, 4);\n            // Header image height\n            System.Buffer.BlockCopy(BitConverter.GetBytes(0 - height), 0, output_array, 0x16, 4);\n\n            if(fix_alignment) {\n                pos_src = 0;\n                pos_dst = 0x436;\n                for(n=0; n<height; n++) {\n                    System.Buffer.BlockCopy(image_data, pos_src, output_array, pos_dst, width);\n                    pos_src += width;\n                    pos_dst += width_virtual;\n                }\n\n            } else {\n                System.Buffer.BlockCopy(image_data, 0, output_array, 0x436, image_length);\n            }\n\n            System.IO.File.WriteAllBytes(filename, output_array);\n        } catch {\n            return false;\n        }\n\n        return true;\n    }\n\n}\n\n}\n</code></pre>\n <p>\n  The Codes were written by someone else for me, and I have permission from him, to post them here. The DOS Game uses custom RLE Graphics Encoding. He was unable, to fully explain how the Codes work.\n </p>\n <p>\n  The first Code Program.cs written in C# extracts the Graphics Image, from a Graphics File, and the Bitmap.cs Code i.e. the second one saves the image as a .bmp bitmap File so it can be viewed. According to the person who wrote both Codes, the image width and height is guessed, rather than being known.\n </p>\n <p>\n  However I tried the Codes i.e. unpac Program on a game the previous one made, which also uses Custom RLE Graphics encoding and the Graphics images from .PAC Files don't extract properly. i.e. the Aircraft Cockpit view Image.\n </p>\n <p>\n  What I have tried :-\n </p>\n <p>\n  I tried changing the input bytes in the Program.cs Code, i.e. 0xFF to 0xFE for example in the first part based on what I saw, after opening a File in a Hex Editor its the\n </p>\n <pre><code>input_byte == 0x\n</code></pre>\n <p>\n  parts of the code, which I think need amending.\n </p>\n <p>\n  But nothing useful is extracted, when I use the Program, on the relevant Files from the forerunner game, after making that change. Could someone look at the Program.cs Code for me, i.e. the first one posted by me here ? and suggest what I could change in the Code, to achieve an extracted image, i.e. what I should be looking for when I open relevant Files in a Hex Editor ?\n </p>\n <p>\n  I will post Google Drive links to one File that the cockpit view image that Extracts properly and one that doesn't from the forerunner game. Could someone look at those Files in a Hex editor For me, and suggest what amendments I could make to the Program.cs Code ?\n </p>\n <p>\n  Here are two links the first File extracts properly giving a cockpit view Image, the second one doesn't :-\n </p>\n <p>\n  <a href=\"https://drive.google.com/file/d/1Cr3IV6DkQPYBfPC0HdT6xloFQdimUW12/view?usp=sharing\" rel=\"nofollow noreferrer\">\n   https://drive.google.com/file/d/1Cr3IV6DkQPYBfPC0HdT6xloFQdimUW12/view?usp=sharing\n  </a>\n </p>\n <p>\n  <a href=\"https://drive.google.com/file/d/15EJUGYYoHPk9VJzNRDgL04LaNZ3XnCEj/view?usp=sharing\" rel=\"nofollow noreferrer\">\n   https://drive.google.com/file/d/15EJUGYYoHPk9VJzNRDgL04LaNZ3XnCEj/view?usp=sharing\n  </a>\n </p>\n <p>\n  I believe it is this part, of the Program.cs Code, that needs changing, i.e. where the problem lies, with unsuccessful extraction of Files, to .bmp format. Could someone look at the File that doesn't extract properly and the one that does, and suggest what possible amendments, I need to make to the two codes I posted, i.e. things to try ? can anyone understand the logic ?\n </p>\n <p>\n  Any help would be much appreciated\n </p>\n <p>\n  Regards\n </p>\n <p>\n  Eddie Winch\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 0,
    "views": "88",
    "tags": [
        "c#",
        "dos",
        "dos-exe",
        "graphics",
        "game"
    ],
    "user": "Edward Winch",
    "time": "Oct 22, 2022 at 14:56",
    "comments": [
        {
            "user": "Robert",
            "text": "<html><body><span class=\"comment-copy\">\n DOS is an 16 bit OS and I don't think there is a .Net or Mono runtime available for DOS. Most likely you wanted to say it is a text-mode application which looks like the DOS command line in Windows 9x but that doesn't make it a \"DOS game\".\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Edward Winch",
            "text": "<html><body><span class=\"comment-copy\">\n Hi Robert, the WW2 Aircraft games, were originally made for DOS, many thanks for your comment. Eddie Winch\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}