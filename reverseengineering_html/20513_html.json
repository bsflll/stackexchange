{
    "title": "Which operators use sal, shl, sar or shr",
    "link": "https://reverseengineering.stackexchange.com/questions/20513/which-operators-use-sal-shl-sar-or-shr",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Which operators in C language would result in assembly commands such as\n  <code>\n   sal, shl, sar or shr\n  </code>\n  for example?\n </p>\n</div>\n</body></html>",
    "votes": "7",
    "answers": 2,
    "views": "6k",
    "tags": [
        "assembly",
        "c"
    ],
    "user": "PaHa",
    "time": "Jan 31, 2019 at 9:19",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<html><body><span class=\"comment-copy\">\n Hi and welcome to RE.SE. Given the role optimizers play during the transformation of source code to binary, this is a rather tough question which will be hard to answer unless you also provide details on the compiler (and version) you're interested in. Now my guess is also that these are the usual IA-32 mnemonics, but you may also want to indicate the ISA.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  First it should be noted that there are so many architectures out there,\n  <em>\n   each with its own instruction set\n  </em>\n  . Here I assume you mean\n  <a class=\"post-tag\" href=\"/questions/tagged/x86\" rel=\"tag\" title=\"show questions tagged 'x86'\">\n   x86\n  </a>\n  (and you should indeed tag the proper architecture as 0xC0000022L said above). Most parts of the below answer would apply to other architectures as well, but they may use different mnemonics or lack some mentioned instructions\n </p>\n <p>\n  <strong>\n   <code>\n    SAL\n   </code>\n   and\n   <code>\n    SHL\n   </code>\n   are the same.\n  </strong>\n  They're simply\n  <a href=\"http://www.felixcloutier.com/x86/SAL:SAR:SHL:SHR.html\" rel=\"noreferrer\">\n   aliases to the same opcode\n  </a>\n  because shifting left\n  <em>\n   always fill the vacant bits with 0s\n  </em>\n  . In C\n  <code>\n   <<\n  </code>\n  will do a shift left, and whether the shift instruction is printed as\n  <em>\n   SAL\n  </em>\n  or\n  <em>\n   SHL\n  </em>\n  depends on the compiler/disassembler\n </p>\n <p>\n  OTOH there are 2 versions of right shift because you can fill the bits that were shifted out with zero\n  <em>\n   (\n   <a href=\"https://en.wikipedia.org/wiki/Logical_shift\" rel=\"noreferrer\">\n    logical shift\n   </a>\n   )\n  </em>\n  or the high bit of the old value\n  <em>\n   (\n   <a href=\"https://en.wikipedia.org/wiki/Arithmetic_shift\" rel=\"noreferrer\">\n    arithmetic shift\n   </a>\n   )\n  </em>\n  .\n  <code>\n   SAR\n  </code>\n  does an arithmetic shift and\n  <code>\n   SHR\n  </code>\n  does a logical shift. In C the operator for right shifting is\n  <code>\n   >>\n  </code>\n  , but the rule depends on the signness of the type:\n </p>\n <ul>\n  <li>\n   A right shift on an unsigned type is always a logical shift, therefore\n   <code>\n    SHR\n   </code>\n   will be used\n  </li>\n  <li>\n   A right shift on a signed type is implementation defined, i.e. the compiler can choose to do an arithmetic or a logical shift. However almost all modern compilers will do an arithmetic shift (\n   <code>\n    SAR\n   </code>\n   ) on signed types (otherwise doing arithmetic shift would be too tricky/clumsy). Some compilers may have an option to select the right shift variant though\n  </li>\n </ul>\n <p>\n  Per the\n  <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"noreferrer\">\n   C99 standard\n  </a>\n  , section 6.5.7:\n </p>\n <blockquote>\n  <p>\n   The integer promotions are performed on each of the operands. The type of the result is that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.\n  </p>\n  <p>\n   The result of\n   <strong>\n    E1\n   </strong>\n   <<\n   <strong>\n    E2\n   </strong>\n   is\n   <strong>\n    E1\n   </strong>\n   left-shifted\n   <strong>\n    E2\n   </strong>\n   bit positions; vacated bits are filled with zeros. If\n   <strong>\n    E1\n   </strong>\n   has an unsigned type, the value of the result is\n   <strong>\n    E1\n   </strong>\n   × 2\n   <sup>\n    <strong>\n     E2\n    </strong>\n   </sup>\n   , reduced modulo one more than the maximum value representable in the result type. If\n   <strong>\n    E1\n   </strong>\n   has a signed type and nonnegative value, and\n   <strong>\n    E1\n   </strong>\n   × 2\n   <sup>\n    <strong>\n     E2\n    </strong>\n   </sup>\n   is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.\n  </p>\n  <p>\n   The result of\n   <strong>\n    E1\n   </strong>\n   >>\n   <strong>\n    E2\n   </strong>\n   is\n   <strong>\n    E1\n   </strong>\n   right-shifted\n   <strong>\n    E2\n   </strong>\n   bit positions. If\n   <strong>\n    E1\n   </strong>\n   has an unsigned type or if\n   <strong>\n    E1\n   </strong>\n   has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of\n   <strong>\n    E1\n   </strong>\n   / 2\n   <sup>\n    <strong>\n     E2\n    </strong>\n   </sup>\n   . If\n   <strong>\n    E1\n   </strong>\n   has a signed type and a negative value, the resulting value is implementation-defined.\n  </p>\n </blockquote>\n <hr/>\n <p>\n  However there are a lot of\n  <em>\n   other operations that can produce a shift instruction\n  </em>\n  , and various cases that\n  <em>\n   shift operators don't produce a shift instruction\n  </em>\n </p>\n <p>\n  It's less common to see\n  <code>\n   <</>>\n  </code>\n  that are not compiled to a shift instruction, but compilers may optimize\n  <code>\n   x << 1\n  </code>\n  to\n  <code>\n   x += x\n  </code>\n  and you'll see things like\n  <code>\n   ADD eax, eax\n  </code>\n  or\n  <code>\n   LEA ecx, [eax + eax]\n  </code>\n  . On x86\n  <code>\n   x << i\n  </code>\n  with i ⩽ 3 can also be compiled to\n  <code>\n   LEA eax, [eax*2ⁱ]\n  </code>\n  instead of shift. Of course an output like\n  <code>\n   MUL x, 2\n  </code>\n  is also possible on a hypothetical architecture without shift, or where shift is slower than multiplication\n </p>\n <p>\n  Compilers are also able to transform complex statements like\n  <code>\n   (x << 1) + (x << 4) + (x << 13)\n  </code>\n  into simpler ones such as a single multiplication by 8210, no more shifts.\n  \n\n  Or GCC recognizes\n  <code>\n   (a ^ b) + (a & b) + (a & b)\n  </code>\n  as well as its the inverse condition\n  <code>\n   (a + b) - (a & b) - (a & b)\n  </code>\n  and optimize them to\n  <code>\n   a + b\n  </code>\n  and\n  <code>\n   a ^ b\n  </code>\n  respectively, so it's possible (in the future) that they'll be able to convert the equivalents\n  <code>\n   (a ^ b) + ((a & b) << 1)\n  </code>\n  and\n  <code>\n   (a + b) - ((a & b) << 1)\n  </code>\n  into\n  <code>\n   ADD\n  </code>\n  and\n  <code>\n   XOR\n  </code>\n  without any shifts at all.\n  \n\n  <a href=\"https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSAbAQwDtRkBSAJgCFufSAZ1QBXYskwgA5CJaC8wFpnQBqAIIARDRFnzFylU1IrdCpaoBGASg4AGNRwDsfeyrcrimAmJYqITFQ4AVmwVa0DePwDuADYwqwieKIi46w4AZhcHRw07B3tTfVUADQB5ACUdOTMDIxNqovi8pyz3Dy8fZP54lQBaLq5UhP7/FKbM5pzmgobzFQBbEQYqvTmADxt7Fry2z29iXwg1wPSAYQzTlVoE7qOT87OVABYbyLuLi6v0mwmtqfspFZGNIglJSCxpLYwahpOdeN1hGIJBF0rQwQRIYCgQhMEwsMRKECANZ0AAcADpSbRaFx0k8nqTHIN0lwuE9gVInmCIVIoaQYVIwYIQLZSBjeYDSHBYEg0PMAA54BiYMgUCByxXKgnAUlcUgAMyVBBVwogFkxpAseBYTGIAE9pGjSHL5pgWARSiwGA6JaQsPNWMBlRb8J5kAQ8AA3TDC32YNaYZAiY2OsHW40MC0MPAWYi2u2nDCSKROgjEPDzVNA5hsFD8fiMHPCyBA1DyiOoOTSXqldJC0TiSTXDmg8EWgVrUkxXoxJ4qYDIZAqClcPy4QgkFH0FSFhVKlVbhJwvi8dGYoEQWWoPda8iUDX7gny%2BXIWfK4AxdKiw0MY3EU3mr6Vo2vaqbOterrup63ohpgAZsMGvqhomEbRrGfLxomybFk66aYJmvrZrm%2BaFlgYFlhWVaMIGdbwrwjYWM2ECtu2eCdrGPbpH08yeIoTCuoI/ZIkO1Ygty47SPKqAAO4qm%2BmDzouKgxOS6TkrYa74EQxBbsYu6age3DpN8O71qeYrnlKV43iqd7qteBkEsgNbAI4tjfkaJqUIBfLAfmYEum6Hpej6fL%2BoGiFhXgYaoTGFqYUmKYlmm7r4VmOZ5vapE4ei5aVsl1Y0ZwdECERTEsR2XZSJxfT6tGxAWKggiYL0TCCPMQmDnQolSKOPJ8hOU4znOzmBiojjqepmkbjpRnbvpj4olwR5mTwZ4She1mOXZD5aiAtrzLOOpcB5v5eWaFp%2BaByXgfMkHBTBSFwRFxZRTFUZxXGCaJTl5CpQRfJEZlBZFuReVUS5tEnqVTbwBVbFVZxnUSN1I7ib6ApqOUACys6KUuK7Tdpuk7g5i1GS8pkletUJWNiuL4oSpAklS5K0KSjIxEEQQ0o46QxI4jgclypCVrQ7ljhj0hCiKFkbT1XDowN0ty7TQL1fInYgE8QA%3D\" rel=\"noreferrer\">\n   See them in action\n  </a>\n </p>\n <p>\n  For the other case there are various examples:\n </p>\n <ul>\n  <li>\n   <strong>\n    Multiplication by a power of 2\n   </strong>\n   is done by a\n   <em>\n    left shift\n   </em>\n   . On x86 there exists the more versatile\n   <code>\n    LEA\n   </code>\n   instruction, so for exponent ⩽ 8 the choice between\n   <code>\n    LEA\n   </code>\n   and\n   <code>\n    SHL\n   </code>\n   depends on the compiler. Array arithmetic also need a lot of multiplication, so a shift is also usually used\n  </li>\n  <li>\n   <strong>\n    Multiplication by many other constants\n   </strong>\n   can also be optimized to a series of ADD/SUB and shifts if that's faster than the\n   <code>\n    MUL\n   </code>\n   instruction itself. Again in x86 occasionally LEA is used instead of shifts\n  </li>\n  <li>\n   <strong>\n    Division by a power of 2\n   </strong>\n   is done by a\n   <em>\n    right shift\n   </em>\n   . For unsigned types it's a simple logical shift. For signed types it's an arithmetic shift followed by some other shifts and ADDs to correct the result (since division rounds towards zero, and arithmetic right shift rounds towards -inf)\n  </li>\n  <li>\n   <strong>\n    Division by constants\n   </strong>\n   will be\n   <a href=\"https://stackoverflow.com/q/41183935/995714\">\n    optimized into a multiplication by the corresponding multiplicative inverse\n   </a>\n   , which may involve some shifts to round the result\n  </li>\n  <li>\n   <a href=\"https://stackoverflow.com/q/54438477/995714\">\n    Clang even emits an\n    <code>\n     SHR\n    </code>\n    for checking the high bits\n   </a>\n   while doing a\n   <strong>\n    division by a non-constant\n   </strong>\n   if tuning for microarchitectures from Sandy Bridge onward\n  </li>\n  <li>\n   <strong>\n    Bitfield\n   </strong>\n   accesses of course need to use a lot of shifts in architectures without efficient bitfield manipulation like x86.\n   <a href=\"https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSAbAQwDtRkBSAJgCFufSAZ1QBXYskwgA5IILERyAgGoARoQBmeTA3RKOAdj4AGAIJLzSvC2UqQS2lw4BmY2YtXlyO7QAsz1xZKIiyCeMAsmLrodgCs/hymgR5KkvbxpgYAIukmCSbJ6hBqBJraugBuAJR5BgEWxJgEYixK5QB0KgBUTlx6vK1tyJ0AbD5KALQD6J20wxMDmJ1%2BLjX62aZSlYzSMVKkLNJGe6jSAML8/ErCYhJ9TrR7BIebWwDWdPptPk4AnDEAHLQfvouDFhsM/lxtlIfHsDlIjqQTlI9oIQEZSE8EZtSHBYEg0ABbAAOeAYmDIFAgRNJ5OIICYxEJo2A/y4GM0DAIFLRRWepDULEZAE9pA9SETCZhrAB5FgMUXY0hYQmsYDk/n4BqKPDlTBopWYAAemGQIm5Yr2Hm0/IYeBUxBFpwwkik4rkeEJlq2zDYKAuvEY9rRkC2qGJBDwqBC0nGMqcqNE4kktB9Ozh/ORJgASgBZUZKYDIZBKf5tXoQXCEEh3ehKZ0kskUu4%2BSr1gM8R7PLYQAmoRt08iUGlN%2BnIX3AfRGDlk7nEXm2JWCkWWiX9qWy%2BWKxEqtUapVa02RvUGxHG03m13i60MW32x3EYXOrCrj1et04if%2B3j8IMqEMQGGEZRjGUhxk4EzqHqxAqKggiYOMTCCISiY3CmaZSLs%2ByZtIRr/MM4wFuOapKJ8RhtEYSiVvgRDELWpD1v2tLNtwPRtucP68F22I9n2A4UkO1JMaOICslCnJzgu/LLo%2Bq6StKBBygqmqYKqbD7jueDase%2Br8ueZoWh%2B5DWDaSp2g6Touq%2BxCet6jBqt%2BfCBuZAFAZG0YGuBqHJnQGFYfCiLInhBEFkWJZlhWVa0fRjH8XRrGpu2nGdpi3a4nxzGUsOwl0iAxLEsgozksAwxODOXI8pQi6IjJirivJm7KQeql7q6mnabqumGiaBlXlaJm3mZ96WS%2BRlvnZX6cMlf6uUiwEebG8YTISDThEwUqCN5Ei%2BdC/k4VIxKoAA7hSRWYIWxZKMMbROBRVFRTWCUMQ2mV3E47EdtxRyVFsCCYEwWD0oBpDvGybRgkYPi0P8RhcPo3xlT40KwqQXq0NO2FKsiqLoqlPEYVwGZY9IX0vKQ0GhNGIA%2BEAA\" rel=\"noreferrer\">\n    See demo\n   </a>\n  </li>\n  <li>\n   ...\n  </li>\n </ul>\n <p>\n  <a href=\"https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSAbAQwDtRkBSAJgCFufSAZ1QBXYskwgA5NwDMeFsgYisAag6yAwskEF8LAhuwcADAEFTZhQVlcA%2BgVUBbEQwAcEa7YeqAHgEpLDgB2PnNVCNViTAIxFj8AKjd1WTCLYIARSy97R3wANw8cn19SVWLHbgA2J0DzELTI5xSMv3UuAFZVNw1GyOjY4njfAHoe1KDMyxEK1QK3EQgZg29HUtVlm1z2mrr0voinFrbuLvGDqJi4vzHeyaz681mXBloOzxXtgMmLgevfBJvO71KZPT4%2BApvD5bEplWbVWo/SxNI4aVq%2BdpdIETcL9K5DG7YtIhB4WMEwxwvWSyaGrPx7BrIvGDYYJanA9Kk2YFam0r5w8GVLi7JG4w7HDGnVTsnFmJp/AmjGXEzJSfyMaQdKSkFjSEza1DSTT8fiqYRiCTtWS0bUEPVq9UAazoAE4AHTBF0mF1uKpcNyyAAswUDbg6gY1UkD2t1Un1pENUm1ghAJlIdrjatIcFgSDQTgADngGJgyBQIPmiyXiCBgG4uKQAGbFgillMQABG9tIHYUTGIAE9pDbSPmnJgDAB5FgMIeZ0hYJysYAl7v4aLIAh4fKYFPzzC%2BTDIESt4fa6yYBjdhh4DvEfsDzQYSRSEcEYh4Jxn9XMNgoE28Iwt4ppA6qoAWW6oCwe4ALSTrIyaiOIki0D%2Bmoxt2ia%2BL6MFVIGqjAMgyDdG6XCqBAuCECQVr0KoT6FsWpY0f4dEATwtr2uqEB5qgDHVuQlCVoxNZ4ERtAuvQzYMK2xDtl2869iwD5nqOvHjlOM5zvGi7Lqu87rkeW47nu8YHkeJ4viOF5XvON53g%2BT5YCp76ft%2BjDLv%2BvD8EBHYgRAYEQXgUGwfBqgwY2O7EB2qCCJgMFMIITiIRaKFoVIWo6ph0jYVUuH4aJxHiW6JhurQ5GUUQxA0WU9FVkxchcCxxpebwHGZlxPF8aWAkVrxdU1v2Th4XWXBplJMlyd2inKa%2B2pjhOBDTrOa6YEubB6dpeAbkZu7dmZx6nrN5AGJe163veg6OZZtofl%2Bs0/h5nAtQIdl%2BQFkHQdIcEIUISESHQaUZbG8aJmYABKACyeEEURJFkRR%2BCVdVdF9cJVqBk1bFtfqHUoKj/HlkJ1YgAWBbIHhJbAFUshjS2baUPJ8bTYOKnzRpy36atukvpt23brt%2B6Hgd13Ha2NnxnZF2Ps%2Bzm3W5v7sGxPlvQmgXBV9oUwU40TAEp46CMlyEA5GQNZVIBaoAA7qWFOYDDxFVG6sjFeViPUXItG1WjciyJjz3Yw6pAIJgTBYDW/mkM6bglaNXq0LIwS0FUHSdG8kbRqQX60CYabAwa0jJqm6acWlXAYfOiYB/46qRYIQW6oGQA\" rel=\"noreferrer\">\n   Here are some illustrations for the mul/div examples\n  </a>\n  . You can easily see that\n  <code>\n   x*15\n  </code>\n  is replaced by\n  <code>\n   x*16 - x\n  </code>\n  and\n  <code>\n   x*33\n  </code>\n  is done by\n  <code>\n   x*32 + x\n  </code>\n  , i.e.\n  <code>\n   (x << 4) - x\n  </code>\n  and\n  <code>\n   (x << 5) + x\n  </code>\n  . Besides,\n  <code>\n   x*8\n  </code>\n  is optimized to\n  <code>\n   lea eax, [0+rdi*8]\n  </code>\n  or\n  <code>\n   shl edi, 3\n  </code>\n  depending on the compiler. The mnemonics\n  <code>\n   SAL\n  </code>\n  and\n  <code>\n   SHL\n  </code>\n  are also freely chosen by the compiler\n </p>\n <p>\n  I've also put some non-x86 compilers for comparison, because they don't have\n  <code>\n   LEA\n  </code>\n  but may have other shift-related instructions or different shift capabilities beside the normal shift instructions. You can change between various x86 as well as non-x86 compilers to see the differences between their outputs. Another example that combines multiple things I've said above:\n </p>\n <pre><code>struct bitfield {\n    int x: 10;\n    int y: 12;\n    int z: 10;\n};\n\nint f(bitfield b)\n{\n    int i = b.x*65;\n    int j = b.y/25;\n    int k = b.z/8;\n    return (i << j) + (k >> j);\n}\n</code></pre>\n <p>\n  <a href=\"https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSAbAQwDtRkBSAJgCFufSAZ1QBXYskwgA5IILERyAgGoARoQBmeTA3RKOAdj4AGAIJLzSvC2UAPEEtpGOAZmNmLV5QE97tLi7cLS2slAC9fJ1cOUwMAEQDok0TPJXUINQJNbV0VAEpEg0CPELw9Z1jVADobACoANgBWBNMglKoyipVKrwB6LiaoluLlAGsOqtCegA5m93NiTAIxFiUIUpcAYU2lKly9XlWxl2xjnfzBpP140ylcxmkGqVIWaSMn1Gkt3n4lYTEJfbOWhPAivW53EZ0fSVLgAFmcdSBdVozmccLqcPuUlhTxeUjepA%2BUieghARlIoPxt1IcFgSDQAFsAA54BiYMgUCCMlls4ggYBTLikTQMAjs0npMGkNQsJjEHxSYGkRkMzDWADyLAYCoJWAZrGAbKl%2BAWijwADdMKSqaRMDZMMgRGLpErPNopQw8CpiHKvBsMJJFSDiHgGS7qcw2Ch%2BPxGF7SZA7qgmQQ8KgWNaALTq5wk0TiSS0O4MB64qVEmxTOqZuqwpTAZDIJRTGGrXCEEiA%2BhKf3M1nsrt7L58XggsF3CD01B93nkSjc/t85CR4D6IzkkVi4gSlRSmW%2B8PK6eqjVanVPPUGo02k0O1OW60Eu0Op2B13Wd02z3e33%2BrCHuRQ3DYsDWjb5eDjFQEwgJMUzTDNpGzZwlEzdRLWIFRUEETBMyYQQGTzf5C2LUtnnLaRK2rWslGXA0lGhIxKiMNt8CIYgu1IHtpx5AduDRIcY1HClxxpKcZ3ZOcuW4xcQCZJlkFrNlgERDdWS3Hc9ysA8gyPBkTwITVtWNTB9TYa9dTwU17ytKVn0dZ0dLdEsvy9H15T/N9gyAoMQKjThwIEb9oNg1N0yzHMUIZBZgFlVVBEIgs6BIqRHjIm0iSZVAAHd2UUzB60bJQ6kqZwmJYjt2L47tex4yquFRASArHKkJzE2rJIXXkQDlBlawFLhVNFcVKF3G193lQ8VTVAyz2M0zDUDCyrItGybTs19Dycj1XN/AMAJDMMfMYUD/JHQL43gEL4PC3MhHzCQkqxVK8QJIkTAAJQAWWohsmxbLhyrYjiuPEurnFhRqzuat5cjuBBMCYLA%2BRg0hIUFSp9AaRE6imZwqzqTG8axHFSDDRxyRe95pBJMlhJa5KuDLdLqbpmG7nQwR4JAWEgA%3D%3D\" rel=\"noreferrer\">\n   That compiles to\n  </a>\n </p>\n <pre><code>f(bitfield):\n        mov     eax, edi\n        mov     edx, edi\n        sar     edi, 22\n        sal     eax, 10\n        sal     edx, 6\n        sar     eax, 20\n        sar     dx, 6\n        imul    ecx, eax, 5243\n        sar     ax, 15\n        sar     ecx, 17\n        sub     ecx, eax\n        movsx   eax, dx\n        mov     edx, eax\n        movsx   ecx, cx\n        sal     edx, 6\n        add     edx, eax\n        lea     eax, [rdi+7]\n        sal     edx, cl\n        test    di, di\n        cmovns  eax, edi\n        sar     ax, 3\n        cwde\n        sar     eax, cl\n        add     eax, edx\n        ret\n</code></pre>\n <p>\n  You can open the Godbolt link to see\n  <em>\n   which instruction corresponds to which line of code\n   <strong>\n    in color\n   </strong>\n  </em>\n </p>\n <p>\n  <strong>\n   In summary:\n  </strong>\n  Compilers nowadays are really smart and can output \"surprising\" results to a normal people. They can emit a shift instruction for pretty much any operators in C.\n  <strong>\n   With an optimizing compiler, all bets are off\n  </strong>\n </p>\n <h1>\n  See also\n </h1>\n <ul>\n  <li>\n   <a href=\"https://stackoverflow.com/q/7622/995714\">\n    Are the shift operators (<<, >>) arithmetic or logical in C?\n   </a>\n  </li>\n  <li>\n   <a href=\"https://stackoverflow.com/q/4009885/995714\">\n    Arithmetic bit-shift on a signed integer\n   </a>\n  </li>\n  <li>\n   <a href=\"https://stackoverflow.com/q/39853049/995714\">\n    Implementation of logical right shift of negative numbers in c\n   </a>\n  </li>\n  <li>\n   <a href=\"https://stackoverflow.com/q/6487918/995714\">\n    Signed right shift: which compiler use logical shift\n   </a>\n  </li>\n  <li>\n   <a href=\"https://docs.microsoft.com/en-us/cpp/c-language/bitwise-shift-operators?view=vs-2017\" rel=\"noreferrer\">\n    Bitwise Shift Operators in MSVC\n   </a>\n  </li>\n  <li>\n   <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html#Integers-implementation\" rel=\"noreferrer\">\n    Bitwise shift in GCC\n   </a>\n  </li>\n  <li>\n   <a href=\"https://en.cppreference.com/w/c/language/operator_arithmetic#Shift_operators\" rel=\"noreferrer\">\n    Shift operators - cppreference\n   </a>\n  </li>\n </ul>\n</div>\n</body></html>",
            "votes": "12",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <pre><code>int main (void){\n    unsigned int    uin =  0x1000;\n    signed int      sin = -0x1000;\n   return (uin<<8)+(uin>>8)+(sin<<8)+(sin>>8);   \n}\n</code></pre>\n <p>\n  compiled and linked with\n </p>\n <pre><code>cl /Zi /W4 /Od /analyze /nologo salsaar.cpp /link /release\n</code></pre>\n <p>\n  disassembled\n </p>\n <pre><code>:\\>cdb -c \"uf salsaar!main;q\" salsaar.exe | grep -A 20 Reading\n0:000> cdb: Reading initial command 'uf salsaar!main;q'\nsalsaar!main:\n01121000 55              push    ebp\n01121001 8bec            mov     ebp,esp\n01121003 83ec08          sub     esp,8\n01121006 c745fc00100000  mov     dword ptr [ebp-4],1000h\n0112100d c745f800f0ffff  mov     dword ptr [ebp-8],0FFFFF000h\n01121014 8b45fc          mov     eax,dword ptr [ebp-4]\n01121017 c1e008          shl     eax,8\n0112101a 8b4dfc          mov     ecx,dword ptr [ebp-4]\n0112101d c1e908          shr     ecx,8\n01121020 03c1            add     eax,ecx\n01121022 8b55f8          mov     edx,dword ptr [ebp-8]\n01121025 c1e208          shl     edx,8\n01121028 03c2            add     eax,edx\n0112102a 8b4df8          mov     ecx,dword ptr [ebp-8]\n0112102d c1f908          sar     ecx,8\n01121030 03c1            add     eax,ecx\n01121032 8be5            mov     esp,ebp\n01121034 5d              pop     ebp\n01121035 c3              ret\n</code></pre>\n <p>\n  note shl and sal are both same (opcodes are same and work same ) shr and sar are not same due to signed unsigned diffferences\n </p>\n</div>\n</body></html>",
            "votes": "4",
            "user": "blabb",
            "time": "Jan 30, 2019 at 18:50",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Nordwald",
                    "text": "<span class=\"comment-copy\">Also: Division and Multiplication through optimization: <a href=\"https://en.wikipedia.org/wiki/Multiplication_algorithm#Shift_and_add\" rel=\"nofollow noreferrer\">en.wikipedia.org/wiki/Multiplication_algorithm#Shift_and_add</a></span>",
                    "time": null
                },
                {
                    "user": "PaHa",
                    "text": "<span class=\"comment-copy\">I noticed that in my case 2*30 produced: shl  dword ptr [rbp-4], 1</span>",
                    "time": null
                }
            ]
        }
    ]
}