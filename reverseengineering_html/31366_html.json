{
    "title": "Two examples of the same code looks different",
    "link": "https://reverseengineering.stackexchange.com/questions/31366/two-examples-of-the-same-code-looks-different",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  These are two examples of the same code. The same code in IDA looks different. Why? For compilation this C++ code was used VS2019.\n </p>\n <pre><code>.text:004E27A0 ; =============== S U B R O U T I N E =======================================\n.text:004E27A0\n.text:004E27A0 ; Attributes: bp-based frame\n.text:004E27A0\n.text:004E27A0 ; int __cdecl WinMainCRTStartup()\n.text:004E27A0                 public _WinMainCRTStartup\n.text:004E27A0 _WinMainCRTStartup proc near\n.text:004E27A0                 push    ebp\n.text:004E27A1                 mov     ebp, esp\n.text:004E27A3                 call    __scrt_common_main\n.text:004E27A8                 pop     ebp\n.text:004E27A9                 retn\n.text:004E27A9 _WinMainCRTStartup endp\n.text:004E27A9\n.text:004E27A9 ; ---------------------------------------------------------------------------\n</code></pre>\n <pre><code>.text:005AC230 ; =============== S U B R O U T I N E =======================================\n.text:005AC230\n.text:005AC230 ; Attributes: bp-based frame\n.text:005AC230\n.text:005AC230 ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n.text:005AC230 WinMain         proc near               ; CODE XREF: j_WinMainj\n.text:005AC230\n.text:005AC230 var_C           = dword ptr -0Ch\n.text:005AC230 var_8           = dword ptr -8\n.text:005AC230 var_4           = dword ptr -4\n.text:005AC230 hInstance       = dword ptr  8\n.text:005AC230 hPrevInstance   = dword ptr  0Ch\n.text:005AC230 lpCmdLine       = dword ptr  10h\n.text:005AC230 nShowCmd        = dword ptr  14h\n.text:005AC230\n.text:005AC230                 push    ebp\n.text:005AC231                 mov     ebp, esp\n.text:005AC233                 sub     esp, 4Ch\n.text:005AC236                 push    ebx\n.text:005AC237                 push    esi\n.text:005AC238                 push    edi\n.text:005AC239                 mov     eax, [ebp+lpCmdLine]\n.text:005AC23C                 mov     GpCmdLine, eax\n.text:005AC241                 push    498h            ; size_t\n.text:005AC246                 push    0               ; int\n.text:005AC248                 push    offset App      ; void *\n.text:005AC24D                 call    j__memset\n.text:005AC252                 add     esp, 0Ch\n.text:005AC255                 mov     eax, [ebp+hInstance]\n.text:005AC258                 mov     hinst, eax\n</code></pre>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 1,
    "views": "175",
    "tags": [
        "ida"
    ],
    "user": "black4joss",
    "time": "Jan 8, 2023 at 9:00",
    "comments": [
        {
            "user": "josh poley",
            "text": "<html><body><span class=\"comment-copy\">\n What do you mean \"same code\"? Those are two very different functions.\n <code>\n  WinMainCRTStartup\n </code>\n Is provided by the CRT and gives the CRT a chance to do it's initialization; the CRT will then call your\n <code>\n  WinMain\n </code>\n when it is ready.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Rolf Rolles",
            "text": "<html><body><span class=\"comment-copy\">\n +1, that is not the same code. One is part of the CRT, the other is the\n <code>\n  main\n </code>\n function written by the application developer.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "black4joss",
            "text": "<html><body><span class=\"comment-copy\">\n I compiled the same C++ code with different project settings, and got that in the first code example, I can't find the WinMain function. Why it's not there I don't understand.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <strong>\n   TL;DR:\n  </strong>\n  the gist is roughly the same as commented before on the question.\n  <code>\n   WinMainCRTStartup\n  </code>\n  is the function which performs some boilerplate initialization for the C/C++ runtime (\"CRT\") and eventually calls your\n  <code>\n   WinMain\n  </code>\n  . So the former isn't your own code, but code supplied by the compiler toolchain and the latter gets eventually called by the former. The leading underscore(s) originate from name mangling.\n </p>\n <hr/>\n <p>\n  Frankly you are giving too little context, but based on experience I will fill the gaps with assumptions ðŸ˜‰\n </p>\n <p>\n  You may want to have a look at\n  <a href=\"https://reverseengineering.stackexchange.com/a/21989/245\">\n   this answer\n  </a>\n  first and\n  <a href=\"https://reverseengineering.stackexchange.com/a/2089/245\">\n   this answer\n  </a>\n  second, I'll wait.\n </p>\n <p>\n  Okay, so not assuming too much prior knowledge (i.e. in case you skipped the reading part), you should know that we have several levels here.\n </p>\n <ol>\n  <li>\n   The PE optional header has a field\n   <code>\n    IMAGE_OPTIONAL_HEADER::AddressOfEntryPoint\n   </code>\n   which contains the RVA of the entry point to the software\n  </li>\n  <li>\n   in your C/C++ program -- and further assuming MSVC based on the names from your question -- the\n   <code>\n    main\n   </code>\n   or\n   <code>\n    wmain\n   </code>\n   (but I'll subsume them under \"\n   <code>\n    main\n   </code>\n   \") function for\n   <strong>\n    console programs\n   </strong>\n   or\n   <code>\n    WinMain\n   </code>\n   /\n   <code>\n    wWinMain\n   </code>\n   for\n   <strong>\n    GUI programs\n   </strong>\n   , respectively, is what you\n   <em>\n    perceive\n   </em>\n   as the entry point to your program, but it's not\n   <strong>\n    prior\n   </strong>\n   to\n   <em>\n    your\n   </em>\n   the C/C++ runtime (msvcrt.dll or the newer msvcr1xx.dll) takes control (in case of statically linked C/C++ runtime, this boilerplate code gets embedded into your binary).\n  </li>\n </ol>\n <p>\n  We can prove this easily. Suppose we take a trivial C++ program like this (go ahead, follow along):\n </p>\n <pre><code>// File is named test.cpp\n#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n\nint APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, PSTR cmdline, int cmdshow)\n{\n    return MessageBox(NULL, \"Hello, world\", \"Hellow Windows world\", 0);\n}\n</code></pre>\n <p>\n  And compile it from a Visual C++/Studio \"Developer Command Prompt\" (32-bit/x86 default) with:\n </p>\n <pre><code>cl /nologo /permissive- /Zi /Fe:test.exe test.cpp /link /opt:ref /opt:icf user32.lib\n</code></pre>\n <p>\n  <code>\n   /Zi\n  </code>\n  removes optimizations as it implies\n  <code>\n   /debug\n  </code>\n  , so we counter with\n  <code>\n   /opt:ref\n  </code>\n  and\n  <code>\n   /opt:icf\n  </code>\n  passed directly to the linker.\n </p>\n <p>\n  Looking at the resulting\n  <code>\n   test.exe\n  </code>\n  first with\n  <code>\n   dumpbin /nologo /headers test.exe\n  </code>\n  from the same prompt you should be seeing something along the lines of (excerpt):\n </p>\n <pre><code>OPTIONAL HEADER VALUES\n             10B magic # (PE32)\n           14.34 linker version\n            C600 size of code\n            8400 size of initialized data\n               0 size of uninitialized data\n            125C entry point (0040125C) _WinMainCRTStartup\n            1000 base of code\n</code></pre>\n <p>\n  The penultimate line contains the reference to\n  <code>\n   _WinMainCRTStartup\n  </code>\n  which is set as entry point for the PE file. Exactly what you are seeing, right?\n </p>\n <p>\n  Well, turns out if you have the Professional edition or higher of Visual Studio, you have the source code to this stuff probably installed already (it's still proprietary code!). It's inside\n  <code>\n   $(VCToolsInstallDir)\\crt\n  </code>\n  (\n  <code>\n   $(VCToolsInstallDir)\n  </code>\n  can be retrieved by invoking\n  <code>\n   \"%Program Files(x86)%\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -nologo -property installationPath\n  </code>\n  and drilling down into\n  <code>\n   VC\\Tools\\MSVC\\*\n  </code>\n  ).\n </p>\n <p>\n  Now you can find the files for the entry point(s):\n </p>\n <ul>\n  <li>\n   Console subsystem,\n   <code>\n    _UNICODE\n   </code>\n   <em>\n    not defined\n   </em>\n   :\n   <code>\n    $(VCToolsInstallDir)\\crt\\src\\vcruntime\\exe_main.cpp\n   </code>\n  </li>\n  <li>\n   Console subsystem,\n   <code>\n    _UNICODE\n   </code>\n   <em>\n    defined\n   </em>\n   :\n   <code>\n    $(VCToolsInstallDir)\\crt\\src\\vcruntime\\exe_wmain.cpp\n   </code>\n  </li>\n  <li>\n   GUI (\"windows\") subsystem,\n   <code>\n    _UNICODE\n   </code>\n   <em>\n    not defined\n   </em>\n   :\n   <code>\n    $(VCToolsInstallDir)\\crt\\src\\vcruntime\\exe_winmain.cpp\n   </code>\n  </li>\n  <li>\n   GUI (\"windows\") subsystem,\n   <code>\n    _UNICODE\n   </code>\n   <em>\n    defined\n   </em>\n   :\n   <code>\n    $(VCToolsInstallDir)\\crt\\src\\vcruntime\\exe_wwinmain.cpp\n   </code>\n  </li>\n </ul>\n <p>\n  So in your case we're looking at a GUI program without\n  <code>\n   _UNICODE\n  </code>\n  defined (\"ANSI entry point\").\n </p>\n <p>\n  Loading this file into IDA we will land right at\n  <code>\n   _WinMain@16\n  </code>\n  :\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/Sk44I.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"IDA View-A and Exports\" src=\"https://i.sstatic.net/Sk44I.png\"/>\n  </a>\n </p>\n <p>\n  But pay attention to the Exports view which I added here as well. We can see the\n  <code>\n   _WinMainCRTStartup\n  </code>\n  . That function is defined by Visual Studio and the linker is hardcoded to \"know\" about a bunch of names for entry points, this one included, by default.\n </p>\n <p>\n  The code (also seen in\n  <code>\n   exe_winmain.cpp\n  </code>\n  ) amounts to:\n </p>\n <pre><code>extern \"C\" DWORD WinMainCRTStartup(LPVOID)\n{\n    return __scrt_common_main();\n}\n</code></pre>\n <p>\n  And the\n  <code>\n   extern \"C\"\n  </code>\n  is what causes the name to be mangled and prepended an underscore.\n </p>\n <p>\n  It's worthwhile peeking at the code for the C/C++ runtime startup code yourself and getting to know it. Potentially the thread local storage (TLS) callbacks also get to run prior to\n  <em>\n   your\n  </em>\n  entry point.\n </p>\n <hr/>\n <h3>\n  Bonus exercise\n </h3>\n <p>\n  NB: A prior look\n  <a href=\"https://devblogs.microsoft.com/oldnewthing/20110525-00/?p=10573\" rel=\"nofollow noreferrer\">\n   at The Old New Thing\n  </a>\n  can't hurt ðŸ˜‰\n </p>\n <p>\n  Alright, let's swap the contents of the\n  <code>\n   test.cpp\n  </code>\n  for this one:\n </p>\n <pre><code>#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n\nDWORD CALLBACK TrueEntryPoint(void)\n{\n    (void)::MessageBeep(0xFFFFFFFFU);\n    return 42;\n}\n</code></pre>\n <p>\n  (Note: the choice of\n  <code>\n   MessageBeep\n  </code>\n  was deliberate so we could rebuild still with only importing from\n  <code>\n   user32.dll\n  </code>\n  .)\n </p>\n <p>\n  ... and rebuild, this time telling the linker to use\n  <code>\n   TrueEntryPoint\n  </code>\n  as the PE entry point:\n </p>\n <pre><code>cl /nologo /permissive- /Zi /Fe:test.exe test.cpp /link /opt:ref /opt:icf user32.lib /entry:TrueEntryPoint\n</code></pre>\n <p>\n  Executing the code you should now hear a beep (speaker) or some short sound which you also get otherwise in the GUI on occasion.\n </p>\n <p>\n  But wait, the binary is now 2.5 KiB in size, as compared to a staggering 81.0 KiB for the original binary.\n </p>\n <p>\n  <em>\n   That size difference\n  </em>\n  is owed to all the C/C++ runtime functionality such as\n  <code>\n   printf\n  </code>\n  , but also some default exception handling, buffer overrun checks etc. Some may consider it bloat, but if you don't have it you aren't allowed to call any of the C/C++ runtime functionality without first performing the initialization steps yourself.\n </p>\n <p>\n  Note that if we hadn't statically linked the C/C++ runtime but instead used it dynamically, things would be slightly different, as all of that \"bloat\" would now be in the C/C++ runtime DLLs which hopefully only exist once (per version) on a given system. But it requires you to install the \"Runtime Redistriutables\" in order to run your application.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "Jan 9, 2023 at 8:19",
            "is_accepted": false,
            "comments": [
                {
                    "user": "black4joss",
                    "text": "<span class=\"comment-copy\">I'm just wondering why I enabled Incremental:NO in the linker settings of Visual Studio 2019 and the look of the code in IDA has changed.</span>",
                    "time": null
                },
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">@black4 makes sense as a question, but it wasn't the question you asked. The mention of <code>incremental:no</code> in your comment is the only mention in this whole Q&amp;A.</span>",
                    "time": null
                },
                {
                    "user": "black4joss",
                    "text": "<span class=\"comment-copy\">I'm sorry, I didn't ask the question objectively. I have a Visual Studio 2019 project. I compiled it. Opened the exe file in IDA. I see the WinMain function. Then I changed the project settings Linker-&gt;Incremental No, compiled it, and again opened the exe file in IDA. I didn't see the WinMain function. Instead, the IDA opened the _WinMainCRTStartup function. The question is why is this happening? That is, now you need to look for WinMain yourself. I don't know what project settings to enable to always have the WinMain function in IDA. I can open a new topic with this question if needed.</span>",
                    "time": null
                },
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">@black4 I know this may be annoying, but you should actually write that up as a separate question. You may very well refer to this one and that you understand the difference between entry point and main function, but that your question is about the code differences you see from toggling that switch. I think this could even be a rather interesting Q&amp;A (although I'll admit I'd have to research for the answer). But since the idea behind incremental linking is to lower link times, I have at least a guess where to look and what for ...</span>",
                    "time": null
                }
            ]
        }
    ]
}