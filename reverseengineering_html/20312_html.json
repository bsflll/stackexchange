{
    "title": "rip adress not visible with dr command",
    "link": "https://reverseengineering.stackexchange.com/questions/20312/rip-adress-not-visible-with-dr-command",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I just finished\n  <a href=\"https://www.root-me.org/fr/Challenges/Cracking/ELF-C-0-protection\" rel=\"nofollow noreferrer\">\n   this challenge\n  </a>\n  . This is the content of main function :\n </p>\n <pre><code>[0x08048a86]> pdf\n/ (fcn) main 417\n|   main (int argc, char **argv, char **envp);\n|           ; var int local_16h @ ebp-0x16\n|           ; var int local_15h @ ebp-0x15\n|           ; var int local_14h @ ebp-0x14\n|           ; var int local_10h @ ebp-0x10\n|           ; var int local_ch @ ebp-0xc\n|           ; var int local_8h_2 @ ebp-0x8\n|           ; var char *local_4h @ esp+0x4\n|           ; var int local_8h @ esp+0x8\n|           ; DATA XREF from entry0 (0x80488a7)\n|           0x08048a86      8d4c2404       lea ecx, [local_4h]         ; 4\n|           0x08048a8a      83e4f0         and esp, 0xfffffff0\n|           0x08048a8d      ff71fc         push dword [ecx - 4]\n|           0x08048a90      55             push ebp\n|           0x08048a91      89e5           mov ebp, esp\n|           0x08048a93      53             push ebx\n|           0x08048a94      51             push ecx\n|           0x08048a95      83ec20         sub esp, 0x20\n|           0x08048a98      89cb           mov ebx, ecx\n|           0x08048a9a      833b01         cmp dword [ebx], 1\n|       ,=< 0x08048a9d      7f4f           jg 0x8048aee\n|       |   0x08048a9f      8b4304         mov eax, dword [ebx + 4]    ; [0x4:4]=-1 ; 4\n|       |   0x08048aa2      8b18           mov ebx, dword [eax]\n|       |   0x08048aa4      c7442404b18d.  mov dword [local_4h], str.usage_: ; [0x8048db1:4]=0x67617375 ; \"usage : \"\n|       |   0x08048aac      c7042460b004.  mov dword [esp], obj._ZSt4cerr__GLIBCXX_3.4 ; [0x804b060:4]=0\n|       |   0x08048ab3      e838fdffff     call sym.std::basic_ostream_char_std::char_traits_char___std::operator___std::char_traits_char___std::basic_ostream_char_std::char_traits_char____charconst\n|       |   0x08048ab8      895c2404       mov dword [local_4h], ebx\n|       |   0x08048abc      890424         mov dword [esp], eax\n|       |   0x08048abf      e82cfdffff     call sym.std::basic_ostream_char_std::char_traits_char___std::operator___std::char_traits_char___std::basic_ostream_char_std::char_traits_char____charconst\n|       |   0x08048ac4      c7442404ba8d.  mov dword [local_4h], str.password ; [0x8048dba:4]=0x73617020 ; \" password\"\n|       |   0x08048acc      890424         mov dword [esp], eax\n|       |   0x08048acf      e81cfdffff     call sym.std::basic_ostream_char_std::char_traits_char___std::operator___std::char_traits_char___std::basic_ostream_char_std::char_traits_char____charconst\n|       |   0x08048ad4      c74424045088.  mov dword [local_4h], sym.std::basic_ostream_char_std::char_traits_char___std::endl_char_std::char_traits_char___std::basic_ostream_char_std::char_traits_char ; [0x8048850:4]=0xb04425ff\n|       |   0x08048adc      890424         mov dword [esp], eax\n|       |   0x08048adf      e85cfdffff     call sym.std::ostream::operator___std::ostream_____std::ostream\n|       |   0x08048ae4      bb05000000     mov ebx, 5\n|      ,==< 0x08048ae9      e92b010000     jmp 0x8048c19\n|      ||   ; CODE XREF from main (0x8048a9d)\n|      |`-> 0x08048aee      8d45eb         lea eax, [local_15h]\n|      |    0x08048af1      890424         mov dword [esp], eax\n|      |    0x08048af4      e867fdffff     call sym.std::allocator_char_::allocator\n|      |    0x08048af9      8d45eb         lea eax, [local_15h]\n|      |    0x08048afc      89442408       mov dword [local_8h], eax\n|      |    0x08048b00      c7442404c48d.  mov dword [local_4h], 0x8048dc4 ; [0x8048dc4:4]=0xca15d618\n|      |    0x08048b08      8d45f4         lea eax, [local_ch]\n|      |    0x08048b0b      890424         mov dword [esp], eax\n|      |    0x08048b0e      e80dfdffff     call sym.std::basic_string_char_std::char_traits_char__std::allocator_char__::basic_string_charconst__std::allocator_char_const\n|      |    0x08048b13      8d45ea         lea eax, [local_16h]\n|      |    0x08048b16      890424         mov dword [esp], eax\n|      |    0x08048b19      e842fdffff     call sym.std::allocator_char_::allocator\n|      |    0x08048b1e      8d45ea         lea eax, [local_16h]\n|      |    0x08048b21      89442408       mov dword [local_8h], eax\n|      |    0x08048b25      c7442404cc8d.  mov dword [local_4h], 0x8048dcc ; [0x8048dcc:4]=0xaf67b350\n|      |    0x08048b2d      8d45f0         lea eax, [local_10h]\n|      |    0x08048b30      890424         mov dword [esp], eax\n|      |    0x08048b33      e8e8fcffff     call sym.std::basic_string_char_std::char_traits_char__std::allocator_char__::basic_string_charconst__std::allocator_char_const\n|      |    0x08048b38      8d45ec         lea eax, [local_14h]\n|      |    0x08048b3b      8d55f4         lea edx, [local_ch]\n|      |    0x08048b3e      89542408       mov dword [local_8h], edx\n|      |    0x08048b42      8d55f0         lea edx, [local_10h]\n|      |    0x08048b45      89542404       mov dword [local_4h], edx\n|      |    0x08048b49      890424         mov dword [esp], eax\n|      |    0x08048b4c      e83cfeffff     call sym.plouf_std::string_std::string\n|      |    0x08048b51      83ec04         sub esp, 4\n|      |    0x08048b54      8d45f0         lea eax, [local_10h]\n|      |    0x08048b57      890424         mov dword [esp], eax\n|      |    0x08048b5a      e8a1fcffff     call sym.std::basic_string_char_std::char_traits_char__std::allocator_char__::_basic_string\n|      |    0x08048b5f      8d45ea         lea eax, [local_16h]\n|      |    0x08048b62      890424         mov dword [esp], eax\n|      |    0x08048b65      e8c6fcffff     call sym.std::allocator_char_::_allocator\n|      |    0x08048b6a      8d45f4         lea eax, [local_ch]\n|      |    0x08048b6d      890424         mov dword [esp], eax\n|      |    0x08048b70      e88bfcffff     call sym.std::basic_string_char_std::char_traits_char__std::allocator_char__::_basic_string\n|      |    0x08048b75      8d45eb         lea eax, [local_15h]\n|      |    0x08048b78      890424         mov dword [esp], eax\n|      |    0x08048b7b      e8b0fcffff     call sym.std::allocator_char_::_allocator\n|      |    0x08048b80      8b4304         mov eax, dword [ebx + 4]    ; [0x4:4]=-1 ; 4\n|      |    0x08048b83      83c004         add eax, 4\n|      |    0x08048b86      8b00           mov eax, dword [eax]\n|      |    0x08048b88      89442404       mov dword [local_4h], eax\n|      |    0x08048b8c      8d45ec         lea eax, [local_14h]\n|      |    0x08048b8f      890424         mov dword [esp], eax\n|      |    0x08048b92      e860010000     call sym.boolstd::operator___char_std::char_traits_char__std::allocator_char___std::basic_string_char_std::char_traits_char__std::allocator_char__const__charconst\n|      |    0x08048b97      84c0           test al, al\n|      |,=< 0x08048b99      744a           je 0x8048be5\n|      ||   0x08048b9b      c7442404fc8d.  mov dword [local_4h], str.Bravo__tu_peux_valider_en_utilisant_ce_mot_de_passe... ; [0x8048dfc:4]=0x76617242 ; \"Bravo, tu peux valider en utilisant ce mot de passe...\"\n|      ||   0x08048ba3      c7042400b104.  mov dword [esp], obj._ZSt4cout__GLIBCXX_3.4 ; [0x804b100:4]=0\n|      ||   0x08048baa      e841fcffff     call sym.std::basic_ostream_char_std::char_traits_char___std::operator___std::char_traits_char___std::basic_ostream_char_std::char_traits_char____charconst\n|      ||   0x08048baf      c74424045088.  mov dword [local_4h], sym.std::basic_ostream_char_std::char_traits_char___std::endl_char_std::char_traits_char___std::basic_ostream_char_std::char_traits_char ; [0x8048850:4]=0xb04425ff\n|      ||   0x08048bb7      890424         mov dword [esp], eax\n|      ||   0x08048bba      e881fcffff     call sym.std::ostream::operator___std::ostream_____std::ostream\n|      ||   0x08048bbf      c7442404348e.  mov dword [local_4h], str.Congratz._You_can_validate_with_this_password... ; [0x8048e34:4]=0x676e6f43 ; \"Congratz. You can validate with this password...\"\n|      ||   0x08048bc7      c7042400b104.  mov dword [esp], obj._ZSt4cout__GLIBCXX_3.4 ; [0x804b100:4]=0\n|      ||   0x08048bce      e81dfcffff     call sym.std::basic_ostream_char_std::char_traits_char___std::operator___std::char_traits_char___std::basic_ostream_char_std::char_traits_char____charconst\n|      ||   0x08048bd3      c74424045088.  mov dword [local_4h], sym.std::basic_ostream_char_std::char_traits_char___std::endl_char_std::char_traits_char___std::basic_ostream_char_std::char_traits_char ; [0x8048850:4]=0xb04425ff\n|      ||   0x08048bdb      890424         mov dword [esp], eax\n|      ||   0x08048bde      e85dfcffff     call sym.std::ostream::operator___std::ostream_____std::ostream\n|     ,===< 0x08048be3      eb24           jmp 0x8048c09\n|     |||   ; CODE XREF from main (0x8048b99)\n|     ||`-> 0x08048be5      c7442404658e.  mov dword [local_4h], str.Password_incorrect. ; [0x8048e65:4]=0x73736150 ; \"Password incorrect.\"\n|     ||    0x08048bed      c7042400b104.  mov dword [esp], obj._ZSt4cout__GLIBCXX_3.4 ; [0x804b100:4]=0\n|     ||    0x08048bf4      e8f7fbffff     call sym.std::basic_ostream_char_std::char_traits_char___std::operator___std::char_traits_char___std::basic_ostream_char_std::char_traits_char____charconst\n|     ||    0x08048bf9      c74424045088.  mov dword [local_4h], sym.std::basic_ostream_char_std::char_traits_char___std::endl_char_std::char_traits_char___std::basic_ostream_char_std::char_traits_char ; [0x8048850:4]=0xb04425ff\n|     ||    0x08048c01      890424         mov dword [esp], eax\n|     ||    0x08048c04      e837fcffff     call sym.std::ostream::operator___std::ostream_____std::ostream\n|     ||    ; CODE XREF from main (0x8048be3)\n|     `---> 0x08048c09      bb00000000     mov ebx, 0\n|      |    0x08048c0e      8d45ec         lea eax, [local_14h]\n|      |    0x08048c11      890424         mov dword [esp], eax\n|      |    0x08048c14      e8e7fbffff     call sym.std::basic_string_char_std::char_traits_char__std::allocator_char__::_basic_string\n|      |    ; CODE XREF from main (0x8048ae9)\n|      `--> 0x08048c19      89d8           mov eax, ebx\n|       ,=< 0x08048c1b      eb75           jmp 0x8048c92\n..\n|       |   ; CODE XREF from main (0x8048c1b)\n|       `-> 0x08048c92      8d65f8         lea esp, [local_8h_2]\n|           0x08048c95      59             pop ecx\n|           0x08048c96      5b             pop ebx\n|           0x08048c97      5d             pop ebp\n|           0x08048c98      8d61fc         lea esp, [ecx - 4]\n\\           0x08048c9b      c3             ret\n</code></pre>\n <p>\n  I solved it by placing a breakpoint to\n  <code>\n   0x08048b99\n  </code>\n  adress and printing the stack when I hit it using the command\n  <code>\n   pxr @ esp\n  </code>\n  The result was :\n </p>\n <p>\n  <code>\n   0xffe4a170  0xffe4a184  .... @esp stack R W 0x9f61c8c -->  (Here_you_have_to_understand_a_little_C++_stuffs)\n0xffe4a174  0xffe4b367  g... edx stack R W 0x43007373 (ss) -->  ascii\n  </code>\n </p>\n <p>\n  So now, I would like to solve this challenge again in a different way. I have two questions.\n </p>\n <p>\n  <strong>\n   First question :\n  </strong>\n  At first, before solve it by this way, I tried to put breakpoint on each comparaison function and my idea was to change the rip adress like in\n  <a href=\"https://youtu.be/hy81mnLMvnE?t=540\" rel=\"nofollow noreferrer\">\n   this video\n  </a>\n  .\nThe problem in my case is when I enter the command\n  <code>\n   dr\n  </code>\n  , I don't have the rip adress. This is the output I have :\n </p>\n <pre><code>hit breakpoint at: 8048b99\n[0x08048b99]> dr\neax = 0xffffff00\nebx = 0xffceafa0\necx = 0x00000004\nedx = 0xffceb365\nesi = 0xf7d54000\nedi = 0xf7d54000\nesp = 0xffceaf60\nebp = 0xffceaf88\neip = 0x08048b99\neflags = 0x00000246\noeax = 0xffffffff\n</code></pre>\n <p>\n  Why I don't have the rip value ? Can you explain me how can I do that if is it possible ?\n </p>\n <p>\n  <strong>\n   Second question :\n  </strong>\n  Is there a command in radare2 which I don't know and which allows me to print directly the value of\n  <code>\n   obj._ZSt4cout__GLIBCXX_3.4\n  </code>\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "212",
    "tags": [
        "binary-analysis",
        "radare2",
        "binary",
        "breakpoint"
    ],
    "user": "Anonymous",
    "time": "Jan 8, 2019 at 21:36",
    "comments": [
        {
            "user": "sudhackar",
            "text": "<html><body><span class=\"comment-copy\">\n rip is the 64 bit instruction pointer only available on x64. Your binary seems to be x86, eip is the x86 instruction pointer. Try changing eip in a similar way. Read up on different registers available on both c86 and x64.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  rip = x64 \neip = x86 \ndr shows eip in your case\n </p>\n <p>\n  it is probably some demangled name  (not sure why radare2 inserts the GLIBC part )\n </p>\n <p>\n  but if you strip the GLIBC part you can use iD Command to demangle it to std::cout\n </p>\n <pre><code>[0x01012d6c]> iD cxx _ZSt4cout__GLIBCXX_3.4\n[0x01012d6c]> iD cxx _ZSt4cout__GLIBCXX_\n[0x01012d6c]> iD cxx _ZSt4cout__GLIBCXX\n[0x01012d6c]> iD cxx _ZSt4cout__GLIBC\n[0x01012d6c]> iD cxx _ZSt4cout__GL\n[0x01012d6c]> iD cxx _ZSt4cout__\n[0x01012d6c]> iD cxx _ZSt4cout_\n[0x01012d6c]> iD cxx _ZSt4cout\nstd::cout\n[0x01012d6c]> iD cxx _ZSt4cou\n[0x01012d6c]>\n</code></pre>\n <p>\n  btw i don't know why you get all that unintelligible thingies\n </p>\n <p>\n  did you analyse the executable prior to loading or after loading it ?\n </p>\n <p>\n  radare2 does a better job than what you posted  as a result of pdf\n </p>\n <p>\n  just so i wasn't deceived by some long forgotten memory i ran through hoops to fetch the 4th challenge :( and loaded it in radare2 and i am sure  it really does a better job than you posted in case after analysis you don't get intelligible output check\n </p>\n <p>\n  e asm.demangle and set it to true reanlyze and do pdf\n </p>\n <p>\n  here is a screenshot the first _Z blah blah in your screen shot is std::cerr auto demangled by radare2\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/1qUGy.jpg\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/1qUGy.jpg\"/>\n  </a>\n </p>\n <p>\n  my radare2 version atm is 2.8.xxx i see latest is 3.2.xxx if the latest version differs in output try contacting the radare2 team \nmaybe someone from the team or a more avid user like megabeets might chime here too\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "blabb",
            "time": "Jan 9, 2019 at 21:24",
            "is_accepted": true,
            "comments": []
        }
    ]
}