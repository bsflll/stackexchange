{
    "title": "How tools like PEiD find out the compiler and its version.",
    "link": "https://reverseengineering.stackexchange.com/questions/16060/how-tools-like-peid-find-out-the-compiler-and-its-version",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <strong>\n   How tools like PEiD and CFF explorer find out the compiler and its version.\n  </strong>\n </p>\n <p>\n  I am analyzing a executable file. Which shows: Borland Delphi 3.0\n  <a href=\"https://i.sstatic.net/ZGieG.jpg\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/ZGieG.jpg\"/>\n  </a>\n </p>\n <p>\n  But the section names .text .rsrc. Which is usually not get generated by Borland Delphi compiler.\n  <a href=\"https://i.sstatic.net/MJ8aV.jpg\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/MJ8aV.jpg\"/>\n  </a>\n </p>\n <p>\n  I guess the file version info is modified.\n </p>\n <p>\n  <strong>\n   But how these tools find out the compiler version ??\n  </strong>\n </p>\n</div>\n</body></html>",
    "votes": "8",
    "answers": 1,
    "views": "5k",
    "tags": [
        "windows",
        "malware",
        "pe",
        "executable"
    ],
    "user": "Dinesh D",
    "time": "Aug 11, 2017 at 5:33",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The signature database of many Compiler and Packer detectors, and sometimes even their source-code, is freely available and you can actually read the signatures in clear-text.\n </p>\n <p>\n  Genrally, the detector performs very naive checks to detect the compiler/linker/protector/etc which based on a preset mask of bytes. The mask is combined from a sequence of bytes and wildcards that usually represents a magic number, a piece of code or a string that gives information about the file.\n </p>\n <p>\n  To understand it better let's look at different detections to Borland 3.0 by different detectors.\n </p>\n <p>\n  <strong>\n   PEiD\n  </strong>\n  :\n </p>\n <pre><code>[Borland Delphi v3.0]\nsignature = 50 6A ?? E8 ?? ?? FF FF BA ?? ?? ?? ?? 52 89 05 ?? ?? ?? ?? 89 42 04 E8 ?? ?? ?? ?? 5A 58 E8 ?? ?? ?? ?? C3 55 8B EC 33 C0\nep_only = true\n</code></pre>\n <p>\n  In order to detect Borland Delphi v3.0, PEiD is searching for this sequence of bytes in the entry point of the binary. The '??' are wildcards used to ignore the bytes in these locations because they might not be the same in different binaries.\n </p>\n <blockquote>\n  <p>\n   You can find the databse of PEiD\n   <a href=\"https://raw.githubusercontent.com/ynadji/peid/master/userdb.txt\" rel=\"noreferrer\">\n    here\n   </a>\n   .\n  </p>\n </blockquote>\n <p>\n  <strong>\n   CFF Explorer\n  </strong>\n  :\n </p>\n <pre><code><ENTRY>\n    <NAME>Borland Delphi v3.0</NAME>\n    <COMMENTS />\n    <ENTRYPOINT>506A??E8????FFFFBA????????528905????????894204E8????????5A58E8????????C3558BEC33C0</ENTRYPOINT>\n    <ENTIREPE />\n</ENTRY>\n</code></pre>\n <p>\n  Although the format of the signature might look different then\n  <em>\n   PEiD\n  </em>\n  's, it is actually the same mask as in the previous example.\n </p>\n <blockquote>\n  <p>\n   You can usually find the signatures database of\n   <em>\n    CFF explorer\n   </em>\n   in the\n  following path\n   <em>\n    C:\\Users\\Public\\Documents\\Explorer\n  Suite\\Signatures\\IMAGE_FILE_MACHINE_I386.xml\n   </em>\n   or in\n   <em>\n    /Signatures/IMAGE_FILE_MACHINE_I386.xml\n   </em>\n   although it\n  may be different in your installation. You can also find it online\n   <a href=\"https://github.com/uxmal/reko/blob/master/src/Decompiler/Loading/Signatures/IMAGE_FILE_MACHINE_I386.xml\" rel=\"noreferrer\">\n    here\n   </a>\n   .   Read\n   <a href=\"http://www.codelooker.com/dfilec/2204CFFExplorer/SignaturesTechnicalDetails.pdf\" rel=\"noreferrer\">\n    this PDF\n   </a>\n   for more technical information about\n  the signatures and how the used in\n   <em>\n    CFF Explorer\n   </em>\n   .\n  </p>\n </blockquote>\n <p>\n  <strong>\n   Detect It Easy:\n  </strong>\n </p>\n <p>\n  <em>\n   Detect It Easy\n  </em>\n  is more complex, rich and accurate detector (in my opinion) which uses \"scripts\" to detect the type of the program. The detection algorithm of\n  <em>\n   DIE\n  </em>\n  is more complex then the others and doesn't use only byte-mask to detect the Compiler/Linker/Packer/etc.\n  \n\n  You can see how\n  <em>\n   DIE\n  </em>\n  detects\n  <em>\n   Borland Delphi\n  </em>\n  in the\n  <a href=\"https://github.com/horsicq/Detect-It-Easy/blob/be67f3c71455e561175639456021e57ddb2b35ae/db/PE/Delphi.4.sg\" rel=\"noreferrer\">\n   following signature\n  </a>\n  .\n </p>\n <p>\n  The signature of Borland Delphi is too long so I'll show here another example of a signature, the signature of\n  <em>\n   NTKrnl Protector\n  </em>\n  :\n </p>\n <pre><code>// DIE's signature file\n\ninit(\"protector\",\"NTkrnl Protector\");\n\nfunction detect(bShowType,bShowVersion,bShowOptions)\n{\n    if(PE.compareEP(\"68........e8\")&&(PE.nLastSection>=1))\n    {\n        if(PE.getNumberOfImports()==1)\n        {\n            if(PE.getNumberOfImportThunks(0)==2)\n            {\n                if((PE.getImportFunctionName(0,0)==\"LoadLibraryA\")&&(PE.getImportFunctionName(0,1)==\"GetProcAddress\"))\n                {\n                    if(PE.isSignatureInSectionPresent(1,\"'http://www.ntcore.com  '\"))\n                    {\n                        sVersion=\"0.1\";\n                        bDetected=1;\n                    }\n                    else if(PE.isSignatureInSectionPresent(1,\"'http://www.ntkrnl.com'\"))\n                    {\n                        sVersion=\"0.15\";\n                        bDetected=1;\n                    }\n                    /* if(bDetected)\n                    {\n                        var nFind=PE.findString(PE.section[1].FileOffset,PE.section[1].FileSize,\"Version \");\n                        if(nFind!=-1)\n                        {\n                            sVersion=PE.getString(nFind,20);\n                            var aVersion=sVersion.match(/Version ?(.*?) /);\n                            sVersion=aVersion[1];\n                        }\n                    } */\n                }\n\n            }\n        }\n    }\n    /*if(PE.compareEP(\"68........e8........c3\")&&(PE.compareEP(\"68########60e8$$$$$$$$5d4555c3\")))\n    {\n        bDetected=1;\n    } */\n\n    return result(bShowType,bShowVersion,bShowOptions);\n}\n</code></pre>\n <blockquote>\n  <p>\n   You can read more about\n   <em>\n    Detect it Easy\n   </em>\n   in its\n   <a href=\"https://github.com/horsicq/Detect-It-Easy\" rel=\"noreferrer\">\n    Github\n  repository\n   </a>\n   .\n  </p>\n </blockquote>\n <hr/>\n <p>\n  Remember that most of the times the bytes in the binary which represent the type of the file can be replaced without harming the functionality of the program. There are even many programs like\n  <em>\n   GcPH\n  </em>\n  ,\n  <em>\n   PseudoSigner\n  </em>\n  and\n  <em>\n   DotFix FakeSigner\n  </em>\n  that try to fool Packer Detectors like the mentioned above. Some of the detectors might actually detect some of these anti-detectors in what seems like cat and mouse game.\n </p>\n <p>\n  Here's an example of how PEiD detects PseudoSigner for Delphi 3.0:\n </p>\n <pre><code>[PseudoSigner 0.1 [Borland Delphi 3.0]\nsignature = 55 8B EC 83 C4 90 90 90 90 68 ?? ?? ?? ?? 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90\nep_only = true\n</code></pre>\n</div>\n</body></html>",
            "votes": "10",
            "user": "Megabeets",
            "time": "Aug 11, 2017 at 8:11",
            "is_accepted": false,
            "comments": [
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">nice answer there  ust an addition msvc compiler version can be detected by the RICH signature embedded in the header one may  look for daniel pistellis article about this</span>",
                    "time": null
                }
            ]
        }
    ]
}