{
    "title": "VADs with RWX permission in winlogon and csrss processes",
    "link": "https://reverseengineering.stackexchange.com/questions/3440/vads-with-rwx-permission-in-winlogon-and-csrss-processes",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  On a clean Windows XP SP2 installation running inside a VirtualBox VM, when doing a snapshot with\n  <code>\n   vboxmangage debugvm --dumpguestcore\n  </code>\n  and analyzing it in Volatility, I always find 9 VADs with\n  <code>\n   PAGE_EXECUTE_READWRITE\n  </code>\n  permissions in\n  <code>\n   winlogon.exe\n  </code>\n  process and 1 VAD with the same permission in\n  <code>\n   csrss.exe\n  </code>\n  process. Sometimes there is one in\n  <code>\n   explorer.exe\n  </code>\n  process as well.\n </p>\n <p>\n  This is the same for two different Machines one with VirtualBox tools installed and one without.\n </p>\n <p>\n  Where do these come from? What are the write permission useful for?\nAny help is mostly appreciated, thank you!\n </p>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 2,
    "views": "1k",
    "tags": [
        "windows",
        "digital-forensics"
    ],
    "user": "user3365",
    "time": "Jan 11, 2014 at 18:53",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<html><body><span class=\"comment-copy\">\n Relocations? I don't know for sure, so just guessing.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <strong>\n   All the statements below are xp-sp3 based\n  </strong>\n </p>\n <p>\n  windbg can also be used to parse for RWX pages in VadTree\n  \n\n  Copy paste following lines to\n  <code>\n   **.txt and run the script $$>a< path to **.txt\n  </code>\n </p>\n <p>\n  script contents needs grep in path for text parsing\n </p>\n <pre><code>aS  proc        @#Process ;\naS  procname    @@c++( (char *)(((nt!_EPROCESS *) @#Process ))->ImageFileName )  ;\naS  procvad     @@c++( (((nt!_EPROCESS *) @#Process ))->VadRoot )  ;\n.block { !for_each_process \".printf \\\"%20ma\\t%p\\t%p\n\n\\\",${procname}, ${proc} , ${procvad}; .echo \n;.shell  -ci  \\\"!vad ${procvad}\\\"  grep  \\\"EXECUTE_READWRITE\\\"\" } ;\nad *\n</code></pre>\n <p>\n  and then set the process context to approriate process and examine the memory from StartVpn to EndVpn\n </p>\n <p>\n  iirc Winlogon and csrss always had a few RWX pages\n  \n\n  the csrss RWX page always seemed to contain lots of initialization  _UNICODE_STRING\n  \n\n  most of the pages wont be available for viewing you may need to live debug in Phase1Init Stage\n </p>\n <pre><code>sxe ibp;.reboot  \n</code></pre>\n <p>\n  on reboot set\n  <code>\n   bp NtCreateProcessEx\n  </code>\n  until csrss is about to be created\n  \n\n  <code>\n   bc * ; gu ;!vad on csrss _EPROCESS\n  </code>\n  csrss process at this point wont have the RWX page\n  \n\n  only 4 vads will exist in csrss VadTree\n  \n\n  you may need to follow from here and catch the allocation / writes and executions\n </p>\n <pre><code>           csrss.exe    86acebe0    86d62660  \n86d39250 ( 4) 7f6f0 7f7ef 0 Mapped       EXECUTE_READWRITE  Pagefile-backed section\n</code></pre>\n <p>\n  this oneliner will fetch you most of the strings in that page\n </p>\n <pre><code>.foreach (place { s -[1]b 7f6f0000 l?7000 0x7f } ) { r $t0 = place ; dS @$t0-7}\n</code></pre>\n <p>\n  output of the above line\n </p>\n <pre><code>7f6f2170  \"C:\\WINDOWS\"\n7f6f2190  \"C:\\WINDOWS\\system32\"\n7f6f21c0  \"\\BaseNamedObjects\"\n7f6f2208  \".罯...罯\"\n7f6f22b0  \".罯...罯\"\n7f6f221c  \"Autorun.inf\"\n7f6f2300  \".罯02.罯Software\\Microsoft\\Clock\"\n7f6f226c  \"DoesNotExist\"\n7f6f2260  \".罯\"\n7f6f2368  \"ヘ罯...罯.罯\"\n7f6f22c4  \"Clock.ini\"\n7f6f23d8  \".罯68.罯Control Panel\\Color Scheme\"\n7f6f2418  \"s\"\n7f6f230c  \"Software\\Microsoft\\Clock\"\n</code></pre>\n <p>\n  the winlogon RWX pages will contain Executble code most of them will start with\n  <code>\n   push cx push ax\n  </code>\n  sequence and end with an indirect call to somehwre via\n  <code>\n   jmp eax\n  </code>\n  and some intermediate calls to unviewable / non existing locations \nmay need live analysis\n </p>\n <p>\n  never observed rwx pages in clean explorer / iexplore / services.exe processos\nthey exist only if some antivirus etc are installed\n </p>\n <p>\n  see below for an\n  <code>\n   Avasted RWX\n  </code>\n  page in explorer.exe patching\n  <code>\n   RtlSetCurrentDirectory_U\n  </code>\n  and loading\n  <code>\n   snxhk.dll using LdrLoadDll()\n  </code>\n  this same patch can also be observed in iexplore.exe\n </p>\n <pre><code>.shell dir /b scan*vad*\nscanvad4rwx.txt    \nlkd> $$>a< scanvad4rwx.txt\n              System    86fc6830    86fbfa90     \n            smss.exe    86b0e020    86dfd008      \n           csrss.exe    86acebe0    86f4e4d0  \n86d39250 ( 4) 7f6f0 7f7ef 0 Mapped EXECUTE_READWRITE  Pagefile-backed section    \n        winlogon.exe    86d7b918    86d58930  \n86ae8ee0 ( 8)       9550     9553         4 Private      EXECUTE_READWRITE \n86340690 ( 7)      29c90    29c93         4 Private      EXECUTE_READWRITE \n86f370d0 ( 6)      2a4f0    2a4f3         4 Private      EXECUTE_READWRITE \n86b13a38 ( 5)      46580    46583         4 Private      EXECUTE_READWRITE \n86da2a00 ( 6)      497c0    497c3         4 Private      EXECUTE_READWRITE \n        services.exe    86b0a020    86ec15c8  \n86da7c20 (12)        380      380         1 Private      EXECUTE_READWRITE \n               lsass.exe    86b2a6b8    86b21110  \n    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        explorer.exe    86241260    86b86768  \n86b13d28 (13)         90       90         1 Private      EXECUTE_READWRITE \n86545e50 (11)        2b0      2b0         1 Private      EXECUTE_READWRITE \n86aa6878 (12)        2c0      2ca        11 Private      EXECUTE_READWRITE \n86b056a0 (10)        2d0      2da        11 Private      EXECUTE_READWRITE \n86b3b9c8 (12)        2e0      2ea        11 Private      EXECUTE_READWRITE \n             AvastUI.exe    86315a00    860fc008  \n    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n        iexplore.exe    86aaf020    861b3f00  \n862ae9f8 (16)        150      150         1 Private      EXECUTE_READWRITE \n</code></pre>\n <p>\n  on rereading i noticed the below output is from a differnt session\nso splitting\n </p>\n <pre><code>and examine the memory  using  lkd> .process /p /r 862543e8 &   lkd> uf 150000\n00150000 50              push    eax\n00150001 60              pushad\n00150002 bd42001500      mov     ebp,150042h\n00150007 8b7d10          mov     edi,dword ptr [ebp+10h]\n0015000a 8b4518          mov     eax,dword ptr [ebp+18h]\n0015000d 8b5d1c          mov     ebx,dword ptr [ebp+1Ch]\n00150010 8907            mov     dword ptr [edi],eax\n00150012 895f04          mov     dword ptr [edi+4],ebx\n00150015 897c2420        mov     dword ptr [esp+20h],edi\n00150019 8d454c          lea     eax,[ebp+4Ch]\n0015001c 50              push    eax\n0015001d ff7548          push    dword ptr [ebp+48h]\n00150020 8d4550          lea     eax,[ebp+50h]\n00150023 50              push    eax\n00150024 8d4540          lea     eax,[ebp+40h]\n00150027 50              push    eax\n00150028 6aff            push    0FFFFFFFFh\n0015002a ff5508          call    dword ptr [ebp+8]\n0015002d 85c0            test    eax,eax\n0015002f 750f            jne     00150040    \n00150031 33c9            xor     ecx,ecx\n00150033 8d4538          lea     eax,[ebp+38h]\n00150036 50              push    eax\n00150037 8d4528          lea     eax,[ebp+28h]\n0015003a 50              push    eax\n0015003b 51              push    ecx\n0015003c 51              push    ecx\n0015003d ff5500          call    dword ptr [ebp]    \n00150040 61              popad\n00150041 c3              ret\n</code></pre>\n <p>\n  put the commands in one line\n </p>\n <pre><code>? @$t1+10 ; ? poi(@$t1+10) ; ln poi(@$t1+10); db (@$t1+18) l8; u (@$t1+18)  l3;\n? poi(@$t1+4c) ; ? poi(@$t1+48) ; ? poi(@$t1+50) ;? poi(@$t1+40) ;  lm m ntdll* ;\nln poi(@$t1+8) ; ? poi(@$t1+38); db  (@$t1+28) l8; du /c 40 poi(@$t1+2c) ;\n? poi(@$t1); ln poi(@$t1);.echo patches RtlSetCurwith pattern and sets return \naddress    [esp+20]to patched instruction calls ntvirtproct for a pagein ntdll \non successloads a dll using LdrLoadDll;   \n\nEvaluate expression: 1376338 = 00150052\nEvaluate expression: 2089936810 = 7c91e7aa\n(7c91e7aa)       Exact matches: ntdll!RtlSetCurrentDirectory_U\n0015005a  6a 6c 68 78 e9 91 7c e8                          jlhx..|.\n0015005a 6a6c            push    6Ch\n0015005c 6878e9917c      push    offset ntdll!`string'+0x34 (7c91e978)\n00150061 e81501ffff      call    0014017b\nEvaluate expression: 64 = 00000040\nEvaluate expression: 32 = 00000020\nEvaluate expression: 4096 = 00001000\nEvaluate expression: 2089934848 = 7c91e000\nstart    end        module name\n7c900000 7c9b2000   ntdll      (pdb symbols)          f:\\symbols\ntdll.pdb\n(7c90d6ee)   Exact matches: ntdll!NtProtectVirtualMemory\nEvaluate expression: 1691353088 = 64d00000\n0015006a  60 00 60 00 9a 00 15 00                          `.`.....\n0015009a  \"C:\\Program Files\\Alwil Software\\Avast5\\snxhk.dll\"\nEvaluate expression: 2089903043 = 7c9163c3\n(7c9163c3)      Exact matches:    ntdll!LdrLoadDll = <no type information>\npatches RtlSetCurwith pattern and sets return address    \n[esp+20] to patched instruction calls ntvirtproct for     \na page in ntdll on success loads a dll using LdrLoadDll\n</code></pre>\n <p>\n  <strong>\n   UPDATE\n  </strong>\n </p>\n <p>\n  the rwx page in csrss.exe is being created during CSRSRV initialization seems to be heap\n </p>\n <p>\n  i set a conditional break after csrss.exe is created on NtAllocateVirtualMemory to print the VadTree on every allocation\n  \n\n  and i see that the rwx page is inserted while CSRSRV init and a CreateSharedSection is observed in call stack\n </p>\n <pre><code>sxe ibp;.reboot\n</code></pre>\n <p>\n  on reboot\n  <code>\n   bp NtCreateprocessEx and hit g;kb\n  </code>\n  till csrss.exe is about to be created\n  \n\n  you can glean the process being created by looking at the unicode_string passed to RtlCreateUserProcess api in the callstack printed\n  \n\n  dS   should print ........................../csrss.exe\n  \n\n  enter\n  <code>\n   gu\n  </code>\n  go up to allow the process to be created\n  \n\n  <code>\n   !process 0 1 csrss.exe\n  </code>\n  save eprocess to scratch pad\n  \n\n  !vad VadRoot\n  \n\n  you should observe 4 vads in csrss vad tree\n </p>\n <p>\n  now set this conditional breakpoint  (\n  <code>\n   substitute the saved eprocess inplace of 0x81160020\n  </code>\n  note\n  <code>\n   use 0x notation\n  </code>\n  )\n  \n\n  bp\n </p>\n <pre><code>bp nt!NtAllocateVirtualMemory \"!vad @@c++(((nt!_EPROCESS *) 0x81160020)->VadRoot);kb;.echo \n;dd poi(@esp+8);\"\n</code></pre>\n <p>\n  if you persist with an access breakpoint you can catch when the rwx page is being added to the ProcessHeapList\n </p>\n <p>\n  see below\n </p>\n <p>\n  ntdll!RtlCreateHeap+0x5b9:\n001b:7c9253de e8a6000000      call\n  <code>\n   ntdll!RtlpAddHeapToProcessList\n  </code>\n  (7c925489)\n </p>\n <p>\n  kd>\n  <code>\n   !heap\n  </code>\n  HEAPEXT: Unable to get address of *ntdll!RtlpGlobalTagHeap.\nIndex   Address  Name      Debugging options enabled\n  \n\n  1:   00160000\n  \n\n  2:   00260000\n  \n\n  kd>\n </p>\n <pre><code>p  step over the call\n</code></pre>\n <p>\n  ntdll!RtlCreateHeap+0x5be:\n001b:7c9253e3 8b45e4          mov     eax,dword ptr [ebp-1Ch]\n </p>\n <pre><code>kd> !heap\n</code></pre>\n <p>\n  Index   Address  Name      Debugging options enabled\n  \n\n  1:   00160000\n  \n\n  2:   00260000\n  \n\n  3:\n  <code>\n   7f6f0000\n  </code>\n </p>\n <pre><code>kd> `!process 0 1 csrss.exe`\nPROCESS `81160020`  SessionId: 0  Cid: 01c4    Peb: 7ffde000  ParentCid: 014c\n    DirBase: 06e30000  ObjectTable: e14a7f38  HandleCount:  10.\n    Image: csrss.exe\n    VadRoot `812275c0 Vads 13` \n</code></pre>\n <p>\n  dump vadtree\n </p>\n <pre><code>kd> `!vad 812275c0`\nVAD     level      start      end    commit\n812201d8 ( 1)          0       ff         0 Private      READWRITE         \n812280e8 ( 2)        100      100         1 Private      READWRITE         \n81229dd0 ( 3)        110      110         1 Private      READWRITE         \n81222a88 ( 4)        120      15f         4 Private      READWRITE         \n811f30b8 ( 5)        160      25f         3 Private      READWRITE         \n81223b80 ( 6)        260      26f         6 Private      READWRITE         \n812275c0 ( 0)      4a680    4a684         2 Mapped  Exe  EXECUTE_WRITECOPY  \\WINDOWS\\system32\\csrss.exe\n811f4fd8 ( 2)      75b40    75b4a         2 Mapped  Exe  EXECUTE_WRITECOPY  \\WINDOWS\\system32\\csrsrv.dll\n811cced0 ( 1)      7c900    7c9b1         5 Mapped  Exe  EXECUTE_WRITECOPY  \\WINDOWS\\system32\ntdll.dll\n8121f440 ( 3)      `7f6f0    7f7ef         0 Mapped       EXECUTE_READWRITE`  Pagefile-backed section\n81167108 ( 2)      7ffb0    7ffd3         0 Mapped       READONLY           Pagefile-backed section\n811e1d30 ( 4)      7ffdd    7ffdd         1 Private      READWRITE         \n811e21b0 ( 3)      7ffde    7ffde         1 Private      READWRITE         \n\nTotal VADs:    13  average level:    3  maximum depth: 6\n</code></pre>\n <p>\n  dump call stack\n </p>\n <pre><code>kd> kb\nChildEBP RetAddr  Args to Child              \n0015fda4 75b437b8 00007008 7f6f0000 00100000 ntdll!RtlCreateHeap+0x5be\n0015fe28 75b42f9a 001626dd 00000000 00000000 CSRSRV!CsrSrvCreateSharedSection+0x23f\n0015ff74 75b430f3 0000000a 001624f0 7c90dc9e CSRSRV!CsrParseServerCommandLine+0x255\n0015ff88 4a68115d 0000000a 001624f0 00000005 CSRSRV!CsrServerInitialization+0x95\n0015ffa8 4a6818d7 0000000a 001624f0 0016251c csrss!main+0x4f\n0015fff4 00000000 7ffde000 000000c8 00000166 csrss!NtProcessStartup+0x1d2\n</code></pre>\n <p>\n  list of breakpoints\n </p>\n <pre><code>kd> bl\n 0 e 8058124c     0001 (0001) nt!NtCreateProcessEx\n 1 e 805691ea     0001 (0001) nt!NtAllocateVirtualMemory \"!vad @@c++(((nt!_EPROCESS *) 0x81160020)->VadRoot);kb;.echo \n;dd poi(@esp+8);\"\n 2 e 7f6f0000 w 1 0001 (0001)\n</code></pre>\n <p>\n  you can follow this methodology with winlogon further below in the chain\n </p>\n <p>\n  <strong>\n   update to answer comment\n  </strong>\n </p>\n <p>\n  the breakpoint @NtAllocateVirtualMemory did not catch the allocation of vad 12\n  \n\n  which was RWX allotment from vad11 my breakpoint got hit only when vad 13 was allocated\n  \n\n  and printing vadtree i found that the vads had increased by 2 and one of them was the   7f6f0000 rwx page so maybe another way is used to add the vad to vad tree insted of   NtAllocateVirtualMemory it is possible that rwx needs to be reset and isnt being reset needs investigation\n </p>\n <p>\n  i can only confirm that the page is indeed HEAP and seems to mapped in almost every process\nwith EXECUTE_READ permissions on all the process vads except in csrss where it is RWX\n </p>\n <pre><code>lkd> .logopen c:\\check7f6f0page.txt\nOpened log file 'c:\\check7f6f0page.txt'\nlkd> !for_each_process \".process /p /r @#Process ; !grep -c \\\"!vad @@c++( ( ( nt!_EPROCESS *) @#Process )->VadRoot)\\\" -e \\\"7f6f0\\\"\"\nlkd> .logclose\nClosing open log file c:\\check7f6f0page.txt\n</code></pre>\n <p>\n  results show this page is mapped in all process\n </p>\n <pre><code>lkd> .shell grep \"7f6f0    7f7ef         0 Mapped\" c:\\check7f6f0page.txt\n<.shell waiting 1 second(s) for process>\n86d39250 ( 4)      7f6f0    7f7ef         0 Mapped       EXECUTE_READWRITE  Pagefile-backed section\n86d39250 ( 4)      7f6f0    7f7ef         0 Mapped       EXECUTE_READWRITE  Pagefile-backed section\n86e87fd8 ( 4)      7f6f0    7f7ef         0 Mapped       EXECUTE_READ       Pagefile-backed section\n86e87fd8 ( 4)      7f6f0    7f7ef         0 Mapped       EXECUTE_READ       Pagefile-backed section\n86b96d10 ( 3)      7f6f0    7f7ef         0 Mapped       EXECUTE_READ       Pagefile-backed section\n86b96d10 ( 3)      7f6f0    7f7ef         0 Mapped       EXECUTE_READ       Pagefile-backed section\n86abfe80 ( 3)      7f6f0    7f7ef         0 Mapped       EXECUTE_READ       Pagefile-backed section\n86abfe80 ( 3)      7f6f0    7f7ef         0 Mapped       EXECUTE_READ       Pagefile-backed section\n86eaf3a8 ( 3)      7f6f0    7f7ef         0 Mapped       EXECUTE_READ       Pagefile-backed section\n86eaf3a8 ( 3)      7f6f0    7f7ef         0 Mapped       EXECUTE_READ       Pagefile-backed section\n86b3fda8 ( 4)      7f6f0    7f7ef         0 Mapped       EXECUTE_READ       Pagefile-backed section\n86e77b20 ( 2)      7f6f0    7f7ef         0 Mapped       EXECUTE_READ       Pagefile-backed section\n</code></pre>\n <p>\n  and confirms to structure _HEAP\n </p>\n <pre><code>lkd> dt -r nt!_HEAP 0x7f6f0000\n   +0x000 Entry            : _HEAP_ENTRY\n      +0x000 Size             : 0xc8\n      +0x002 PreviousSize     : 0\n      +0x000 SubSegmentCode   : 0x000000c8 Void\n      +0x004 SmallTagIndex    : 0x1e ''\n      +0x005 Flags            : 0x1 ''\n      +0x006 UnusedBytes      : 0 ''\n      +0x007 SegmentIndex     : 0 ''\n   +0x008 Signature        : 0xeeffeeff\n   +0x00c Flags            : 0x7008\n   +0x010 ForceFlags       : 8\n   +0x014 VirtualMemoryThreshold : 0xfe00\n   +0x018 SegmentReserve   : 0x100000\n</code></pre>\n <p>\n  dump of 7f6f0000\n </p>\n <pre><code>lkd> dd 7f6f0000 l1c/4\n7f6f0000  000000c8 0000011e eeffeeff 00007008\n7f6f0010  00000008 0000fe00 00100000\n</code></pre>\n <p>\n  and you can confirm this pattern is indeed heap if you look at ntdll!RtlCreateHeap\n </p>\n <pre><code>lkd> !grep -c \"uf ntdll!RtlCreateHeap\" -e \"ebp-24h\"\n7c925dcd c745dc88050000  mov     dword ptr [ebp-24h],588h\n7c925de7 c745dcc0050000  mov     dword ptr [ebp-24h],5C0h\n7c925e87 8145dc80000000  add     dword ptr [ebp-24h],80h\n7c925eb1 8b75dc          mov     esi,dword ptr [ebp-24h]\n7c93c079 0145dc          add     dword ptr [ebp-24h],eax\n</code></pre>\n <p>\n  dis assemble where the address is used\n </p>\n <pre><code>lkd> u 7c925eb1\nntdll!RtlCreateHeap+0x421:\n7c925eb1 8b75dc          mov     esi,dword ptr [ebp-24h]\n7c925eb4 83c607          add     esi,7\n7c925eb7 83e6f8          and     esi,0FFFFFFF8h\n7c925eba 8bc6            mov     eax,esi\n7c925ebc c1e803          shr     eax,3\n7c925ebf 8b4de4          mov     ecx,dword ptr [ebp-1Ch]\n7c925ec2 668901          mov     word ptr [ecx],ax\n</code></pre>\n <p>\n  evaluate the expression\n </p>\n <pre><code>lkd> ? ((588 + 80 >> 3) + 7)  & 0x0fffffff8 \nEvaluate expression: 200 = 000000c8\n</code></pre>\n <p>\n  <strong>\n   update\n  </strong>\n </p>\n <p>\n  the RWX page in csrss is\n  <code>\n   _CsrSrvSharedSectionHeap\n  </code>\n  ==\n  <code>\n   _CsrSrvSharedSectionBase\n  </code>\n  \n\n  that specifc value is queried from registry  and  mapped with NtMapViewOfSection\n  \n\n  or a Section Created using NtCreateSection\nall of this happens under\n  \n\n  <code>\n   csrss!main ->csrsrv.dll ->CsrsrvCreateSharedSection\n  </code>\n </p>\n <pre><code>reg query \"hklm\\system\\currentcontrolset\\control\\session manager\\subsystems\\csrss\"\n! REG.EXE VERSION 3.0    \nHKEY_LOCAL_MACHINE\\system\\currentcontrolset\\control\\session manager\\subsystems\\csrss\n        CsrSrvSharedSectionBase     REG_DWORD       0x7f6f0000\n</code></pre>\n</div>\n</body></html>",
            "votes": "5",
            "user": "blabb",
            "time": "Jan 18, 2014 at 19:16",
            "is_accepted": true,
            "comments": [
                {
                    "user": "user3365",
                    "text": "<span class=\"comment-copy\">Wow, I think I've got to read this a few more times to fully understand it. What comes to my mind now: During process creation, if a process allocates and later commits executable code to an address range (RWX permission), does the process itself have to change the permission to something like PAGE_EXECUTE_READ using VirtualProtect, which would mean that they forgot to make these calls for the RWX VAD's in winlogon and csrss process, or is there some kind of magic happening? Thank you!</span>",
                    "time": null
                },
                {
                    "user": "user3365",
                    "text": "<span class=\"comment-copy\">Thank you blabb, I was able to confirm that it is heap. I accepted your answer! Thank you for the very clear explanation. Anyway I will have to open a new thread on this to clearify where the rwx vads in winlogon.exe process originate. best regards!</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <code>\n   PAGE_EXECUTE_READWRITE\n  </code>\n  (RWX) memory is commonly used for allocating injected processes. The permissions allow for code execution. Scanning memory dumps for RWX is an approach for detecting injected processes. Here are some examples of memory permission with malware injected into them.\n </p>\n <p>\n  Ramnit Memory:\n  <code>\n   Svchost.exe\n  </code>\n  1\n </p>\n <pre><code>Private (Commit), 0x20010000, 52 kB, RWX, MZ\nPrivate (Commit), 0x2001d000, 4 kB, R,  \nPrivate (Commit), 0x2001e000, 12 kB, RW, DS\nPrivate (Commit), 0x20021000, 4 kB, R, \n</code></pre>\n <p>\n  Ramnit Memory:\n  <code>\n   Svchost.exe\n  </code>\n  2\n </p>\n <pre><code>Private (Commit), 0x20010000, 4 kB, RWX, MZ \nPrivate (Commit), 0x20011000, 28 kB, RX\nPrivate (Commit), 0x20018000, 4 kB, R\nPrivate (Commit), 0x20019000, 4 kB, RW\nPrivate (Commit), 0x2001a000, 4 kB, R\nFree, 0x2001b000, 84 kB, NA\n</code></pre>\n <p>\n  Ldpinch\n </p>\n <pre><code>Private (Commit), 0x2460000, 160 kB, RWX, MZ \n</code></pre>\n <p>\n  The output above was created using my own tool (not Volatility). It is not uncommon for explorer.exe or other processes to have a block of memory marked as RWX. It usually has a size of 4k (depending on the process). The presence of RWX memory doesn't mean something bad is present but it is a good starting point for investigation. A good read on using Volatility for detecting process injection can be found on one of the developer's (Michael Hale Ligh)\n  <a href=\"http://mnin.blogspot.com/2011/06/examining-stuxnets-footprint-in-memory.html\" rel=\"nofollow\">\n   site\n  </a>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "perror",
            "time": "Jan 12, 2014 at 9:59",
            "is_accepted": false,
            "comments": [
                {
                    "user": "user3365",
                    "text": "<span class=\"comment-copy\">Hey alexanderh, I'm aware of remote code injection. But the dumps are from clean windows installations. I need to distinguish between those RWX vads and others that are due to an injection, thats why I was asking the question in the first place. I'm working on something similar to malfind... Any clues? Thank you!</span>",
                    "time": null
                },
                {
                    "user": "alexanderh",
                    "text": "<span class=\"comment-copy\">@user3365 odds are you will need to get an answer from an individual who has reversed explorer.exe, winlogon.exe, etc or reverse it yourself. Different processes allocate memory for different reasons. There isn't a generic rule for determining when RWX memory is legitimately allocated. There are though generic rules or clues for determining when malicious memory is allocated. Malfind is a good example of detecting off of those rules. Good luck with your project.</span>",
                    "time": null
                }
            ]
        }
    ]
}