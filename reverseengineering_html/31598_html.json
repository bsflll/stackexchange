{
    "title": "Why this x64 shellcode doesn't work?(segmentation fault)",
    "link": "https://reverseengineering.stackexchange.com/questions/31598/why-this-x64-shellcode-doesnt-worksegmentation-fault",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I found a simple shellcode on the internet.\nThen, to test this shellcode, I make the simple ret overwrite code.\n </p>\n <p>\n  test.c\n </p>\n <pre><code>#include <stdio.h>\n#include <string.h>\n\nchar buf[100];\n\nint main(void)\n{\n        char x=0;\n        strcpy(buf, \"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\");\n\n        *(&x+9)=0x40;\n        *(&x+10)=0x40;\n        *(&x+11)=0x40;\n        *(&x+12)=0x00;\n        *(&x+13)=0x00;\n        *(&x+14)=0x00;\n        *(&x+15)=0x00;\n        *(&x+16)=0x00;\n\n        puts(\"end of program\");\n}\n</code></pre>\n <p>\n  I compiled this using gcc like this.\n </p>\n <pre><code>gcc -o test test.c -fno-stack-protector -mpreferred-stack-boundary=2 -no-pie -fno-pie -z execstack\n</code></pre>\n <p>\n  and the following is the result of what I debugged with gdb.\n </p>\n <pre><code>┌──(kali㉿kali)-[~]\n└─$ gdb -q test                                                                                \nReading symbols from test...\n(No debugging symbols found in test)\n(gdb) set disassembly-flavor intel\n(gdb) disas main\nDump of assembler code for function main:\n   0x0000000000401126 <+0>:     push   rbp\n   0x0000000000401127 <+1>:     mov    rbp,rsp\n   0x000000000040112a <+4>:     sub    rsp,0x10\n   0x000000000040112e <+8>:     mov    BYTE PTR [rbp-0x1],0x0\n   0x0000000000401132 <+12>:    movabs rax,0x6e69622fbb48f631\n   0x000000000040113c <+22>:    movabs rdx,0x5f54535668732f2f\n   0x0000000000401146 <+32>:    mov    QWORD PTR [rip+0x2ef3],rax        # 0x404040 <buf>\n   0x000000000040114d <+39>:    mov    QWORD PTR [rip+0x2ef4],rdx        # 0x404048 <buf+8>\n   0x0000000000401154 <+46>:    movabs rax,0x50fd231583b6a\n   0x000000000040115e <+56>:    mov    QWORD PTR [rip+0x2eeb],rax        # 0x404050 <buf+16>\n   0x0000000000401165 <+63>:    lea    rax,[rbp-0x1]\n   0x0000000000401169 <+67>:    add    rax,0x9\n   0x000000000040116d <+71>:    mov    BYTE PTR [rax],0x40\n   0x0000000000401170 <+74>:    lea    rax,[rbp-0x1]\n   0x0000000000401174 <+78>:    add    rax,0xa\n   0x0000000000401178 <+82>:    mov    BYTE PTR [rax],0x40\n   0x000000000040117b <+85>:    lea    rax,[rbp-0x1]\n   0x000000000040117f <+89>:    add    rax,0xb\n   0x0000000000401183 <+93>:    mov    BYTE PTR [rax],0x40\n   0x0000000000401186 <+96>:    lea    rax,[rbp-0x1]\n   0x000000000040118a <+100>:   add    rax,0xc\n   0x000000000040118e <+104>:   mov    BYTE PTR [rax],0x0\n   0x0000000000401191 <+107>:   lea    rax,[rbp-0x1]\n   0x0000000000401195 <+111>:   add    rax,0xd\n   0x0000000000401199 <+115>:   mov    BYTE PTR [rax],0x0\n   0x000000000040119c <+118>:   lea    rax,[rbp-0x1]\n   0x00000000004011a0 <+122>:   add    rax,0xe\n   0x00000000004011a4 <+126>:   mov    BYTE PTR [rax],0x0\n   0x00000000004011a7 <+129>:   lea    rax,[rbp-0x1]\n   0x00000000004011ab <+133>:   add    rax,0xf\n   0x00000000004011af <+137>:   mov    BYTE PTR [rax],0x0\n   0x00000000004011b2 <+140>:   lea    rax,[rbp-0x1]\n   0x00000000004011b6 <+144>:   add    rax,0x10\n   0x00000000004011ba <+148>:   mov    BYTE PTR [rax],0x0\n   0x00000000004011bd <+151>:   lea    rax,[rip+0xe40]        # 0x402004\n   0x00000000004011c4 <+158>:   mov    rdi,rax\n   0x00000000004011c7 <+161>:   call   0x401030 <puts@plt>\n   0x00000000004011cc <+166>:   mov    eax,0x0\n   0x00000000004011d1 <+171>:   leave\n   0x00000000004011d2 <+172>:   ret\nEnd of assembler dump.\n(gdb) b *main+172\nBreakpoint 1 at 0x4011d2\n(gdb) r\nStarting program: /home/kali/test \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nend of program\n\nBreakpoint 1, 0x00000000004011d2 in main ()\n(gdb) si\n0x0000000000404040 in buf ()\n(gdb) x/30i $rip\n=> 0x404040 <buf>:      xor    esi,esi\n   0x404042 <buf+2>:    movabs rbx,0x68732f2f6e69622f\n   0x40404c <buf+12>:   push   rsi\n   0x40404d <buf+13>:   push   rbx\n   0x40404e <buf+14>:   push   rsp\n   0x40404f <buf+15>:   pop    rdi\n   0x404050 <buf+16>:   push   0x3b\n   0x404052 <buf+18>:   pop    rax\n   0x404053 <buf+19>:   xor    edx,edx\n   0x404055 <buf+21>:   syscall\n   0x404057 <buf+23>:   add    BYTE PTR [rax],al\n   0x404059 <buf+25>:   add    BYTE PTR [rax],al\n   0x40405b <buf+27>:   add    BYTE PTR [rax],al\n   0x40405d <buf+29>:   add    BYTE PTR [rax],al\n   0x40405f <buf+31>:   add    BYTE PTR [rax],al\n   0x404061 <buf+33>:   add    BYTE PTR [rax],al\n   0x404063 <buf+35>:   add    BYTE PTR [rax],al\n   0x404065 <buf+37>:   add    BYTE PTR [rax],al\n   0x404067 <buf+39>:   add    BYTE PTR [rax],al\n   0x404069 <buf+41>:   add    BYTE PTR [rax],al\n   0x40406b <buf+43>:   add    BYTE PTR [rax],al\n   0x40406d <buf+45>:   add    BYTE PTR [rax],al\n   0x40406f <buf+47>:   add    BYTE PTR [rax],al\n   0x404071 <buf+49>:   add    BYTE PTR [rax],al\n   0x404073 <buf+51>:   add    BYTE PTR [rax],al\n   0x404075 <buf+53>:   add    BYTE PTR [rax],al\n   0x404077 <buf+55>:   add    BYTE PTR [rax],al\n   0x404079 <buf+57>:   add    BYTE PTR [rax],al\n   0x40407b <buf+59>:   add    BYTE PTR [rax],al\n   0x40407d <buf+61>:   add    BYTE PTR [rax],al\n(gdb) si\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000404040 in buf ()\n</code></pre>\n <p>\n  I think that 'xor esi,esi' don't generate segmentation fault, but It generated. Why the segmentation fault occured?\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "349",
    "tags": [
        "c",
        "gdb",
        "x86-64",
        "shellcode",
        "gcc"
    ],
    "user": "doldom",
    "time": "Feb 28, 2023 at 11:55",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Your\n  <code>\n   buf\n  </code>\n  variable is a global variable, which most likely is located inside\n  <code>\n   .data\n  </code>\n  section.\n </p>\n <p>\n  This section is not executable by default (it probably has RW permissions). You can check its permissions with\n  <code>\n   readelf\n  </code>\n  utility.\n </p>\n <p>\n  Since you are putting your shell code inside a buffer located in a non executable section of memory, upon executing first instructions, program segfaults.\n </p>\n <p>\n  Considering arguments you are passing to compile your code, I assume that you wanted your shell code to be located in the stack. Thus, to avoid segfault, your\n  <code>\n   buf\n  </code>\n  array should be a local variable (place your array inside\n  <code>\n   main\n  </code>\n  function).\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Qwark",
            "time": "Feb 28, 2023 at 15:40",
            "is_accepted": true,
            "comments": []
        }
    ]
}