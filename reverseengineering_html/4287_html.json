{
    "title": "How to deal with Static Memory Allocation while modifying an executable?",
    "link": "https://reverseengineering.stackexchange.com/questions/4287/how-to-deal-with-static-memory-allocation-while-modifying-an-executable",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm not new to StackExchange, but I'm quite new to reverse engineering, so please be patient with me! :P\n </p>\n <p>\n  At present I'm dealing with an executable that I would like to modify a little bit, for personal use; the source code of the application is not available so I can only modify it or die trying. I'm using both IDA Pro 6.1 and OllyDBG 2.0 as tools.\n </p>\n <p>\n  To be exact, I would just like to increase the amount of CFG_ENTRY that the application can read from\n  <code>\n   500\n  </code>\n  to\n  <code>\n   1000\n  </code>\n  in the method\n  <code>\n   ReadCfgFile\n  </code>\n  which, apparently, has a static memory region preallocated at compile-time:\n </p>\n <pre><code>.text:008F2860 ReadCfgFile     proc near ; DATA XREF: .rdata:0137A1ECo\n.text:008F2860 var_20          = dword ptr -20h\n.text:008F2860 var_1C          = dword ptr -1Ch\n.text:008F2860 var_18          = dword ptr -18h\n.text:008F2860 var_C           = dword ptr -0Ch\n.text:008F2860 var_4           = dword ptr -4\n.text:008F2860 arg_0           = dword ptr  4\n.text:008F2860 arg_4           = byte ptr  8\n.text:008F2860\n.text:008F2860                 push    0FFFFFFFFh\n.text:008F2862                 mov     eax, large fs:0\n.text:008F2868                 push    offset sub_1288B18\n.text:008F286D                 push    eax\n.text:008F286E                 mov     large fs:0, esp\n.text:008F2875                 sub     esp, 14h\n.text:008F2878                 push    ebx\n.text:008F2879                 push    ebp\n.text:008F287A                 push    esi\n.text:008F287B                 push    edi\n.text:008F287C                 mov     edi, [esp+30h+arg_0]\n.text:008F2880                 mov     eax, [edi+10h]\n.text:008F2883                 cmp     eax, [edi+8]\n.text:008F2886                 mov     esi, ecx\n.text:008F2888                 jnb     loc_8F2930\n.text:008F288E                 mov     edi, edi\n.text:008F2890\n.text:008F2890 loc_8F2890:\n.text:008F2890                 mov     eax, [esi+79954h]\n.text:008F2896                 cmp     eax, 3E8h\n.text:008F289B                 jge     loc_8F29DF\n.text:008F28A1                 mov     edx, eax\n.text:008F28A3                 shl     edx, 5\n.text:008F28A6                 lea     ecx, [eax+1]\n.text:008F28A9                 sub     edx, eax\n.text:008F28AB                 lea     eax, [eax+edx*8]\n.text:008F28AE                 mov     [esi+79954h], ecx\n.text:008F28B4                 push    edi\n.text:008F28B5                 lea     ecx, [esi+eax*4+4]\n.text:008F28B9                 call    ReadEDURecord\n.text:008F28BE                 test    al, al\n.text:008F28C0                 jz      loc_8F2947\n.text:008F28C6                 mov     eax, [esi+79954h]\n.text:008F28CC                 mov     ecx, eax\n.text:008F28CE                 shl     ecx, 5\n.text:008F28D1                 sub     ecx, eax\n.text:008F28D3                 lea     edx, [eax+ecx*8]\n.text:008F28D6                 mov     ebp, [esi+edx*4-3E0h]\n.text:008F28DD                 lea     eax, [esp+30h+arg_0]\n.text:008F28E1                 lea     ebx, [esi+79958h]\n.text:008F28E7                 push    eax\n.text:008F28E8                 mov     ecx, ebx\n.text:008F28EA                 mov     [esp+34h+arg_0], ebp\n.text:008F28EE                 call    sub_437DF0\n.text:008F28F3                 test    eax, eax\n.text:008F28F5                 jz      short loc_8F2902\n.text:008F28F7                 cmp     [esp+30h+arg_4], 0\n.text:008F28FC                 jz      loc_8F2994\n.text:008F2902\n.text:008F2902 loc_8F2902:\n.text:008F2902                 mov     ecx, [esi+79954h]\n.text:008F2908                 sub     ecx, 1\n.text:008F290B                 lea     edx, [esp+30h+arg_0]\n.text:008F290F                 push    edx\n.text:008F2910                 lea     eax, [esp+34h+var_20]\n.text:008F2914                 mov     [esp+34h+arg_0], ecx\n.text:008F2918                 push    eax\n.text:008F2919                 mov     ecx, ebx\n.text:008F291B                 mov     [esp+38h+var_20], ebp\n.text:008F291F                 call    sub_437890\n.text:008F2924                 mov     ecx, [edi+10h]\n.text:008F2927                 cmp     ecx, [edi+8]\n.text:008F292A                 jb      loc_8F2890\n.text:008F2930\n.text:008F2930 loc_8F2930:\n.text:008F2930                 pop     edi\n.text:008F2931                 pop     esi\n.text:008F2932                 pop     ebp\n.text:008F2933                 mov     al, 1\n.text:008F2935                 pop     ebx\n.text:008F2936                 mov     ecx, [esp+20h+var_C]\n.text:008F293A                 mov     large fs:0, ecx\n.text:008F2941                 add     esp, 20h\n.text:008F2944                 retn    8\n.text:008F2947\n.text:008F2947 loc_8F2947:\n.text:008F2947                 push    0\n.text:008F2949                 call    sub_D386E0\n.text:008F294E                 add     esp, 4\n.text:008F2951                 mov     ecx, edi\n.text:008F2953                 mov     esi, eax\n.text:008F2955                 call    sub_D4D270\n.text:008F295A                 push    eax ; ArgList\n.text:008F295B                 push    offset aErrMsg_1 ; Error Message\n.text:008F2960                 call    sub_D386E0\n.text:008F2965                 add     esp, 8\n.text:008F2968                 call    sub_D388C0\n.text:008F296D                 lea     edx, [esp+30h+var_20]\n.text:008F2971                 push    edx\n.text:008F2972                 lea     ecx, [esp+34h+var_18]\n.text:008F2976                 mov     [esp+34h+var_20], eax\n.text:008F297A                 mov     [esp+34h+var_1C], 640h\n.text:008F2982                 call    sub_403D60\n.text:008F2987                 mov     [esp+30h+var_4], 0\n.text:008F298F                 jmp     loc_8F2A27\n.text:008F2994\n.text:008F2994 loc_8F2994:\n.text:008F2994                 push    0\n.text:008F2996                 call    sub_D386E0\n.text:008F299B                 add     esp, 4\n.text:008F299E                 mov     ecx, edi\n.text:008F29A0                 mov     esi, eax\n.text:008F29A2                 call    sub_D4D270\n.text:008F29A7                 push    eax\n.text:008F29A8                 push    ebp             ; ArgList\n.text:008F29A9                 push    offset aErrMsg_2 ; Error Message\n.text:008F29AE                 call    sub_D386E0\n.text:008F29B3                 add     esp, 0Ch\n.text:008F29B6                 call    sub_D388C0\n.text:008F29BB                 mov     [esp+30h+var_20], eax\n.text:008F29BF                 lea     eax, [esp+30h+var_20]\n.text:008F29C3                 push    eax\n.text:008F29C4                 lea     ecx, [esp+34h+var_18]\n.text:008F29C8                 mov     [esp+34h+var_1C], 640h\n.text:008F29D0                 call    sub_403D60\n.text:008F29D5                 mov     [esp+30h+var_4], 1\n.text:008F29DD                 jmp     short loc_8F2A27\n.text:008F29DF\n.text:008F29DF loc_8F29DF:\n.text:008F29DF                 push    0\n.text:008F29E1                 call    sub_D386E0\n.text:008F29E6                 add     esp, 4\n.text:008F29E9                 mov     ecx, edi\n.text:008F29EB                 mov     esi, eax\n.text:008F29ED                 call    sub_D4D270\n.text:008F29F2                 push    eax             ; ArgList\n.text:008F29F3                 push    offset aErrMsg_0 ; Error Message\n.text:008F29F8                 call    sub_D386E0\n.text:008F29FD                 add     esp, 8\n.text:008F2A00                 call    sub_D388C0\n.text:008F2A05                 lea     ecx, [esp+30h+var_20]\n.text:008F2A09                 push    ecx\n.text:008F2A0A                 lea     ecx, [esp+34h+var_18]\n.text:008F2A0E                 mov     [esp+34h+var_20], eax\n.text:008F2A12                 mov     [esp+34h+var_1C], 640h\n.text:008F2A1A                 call    sub_403D60\n.text:008F2A1F                 mov     [esp+30h+var_4], 2\n.text:008F2A27\n.text:008F2A27 loc_8F2A27:\n.text:008F2A27                 mov     eax, [esp+30h+var_18]\n.text:008F2A2B                 test    eax, eax\n.text:008F2A2D                 jz      short loc_8F2A3A\n.text:008F2A2F                 push    esi\n.text:008F2A30                 push    eax\n.text:008F2A31                 call    ds:??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const *)\n.text:008F2A37                 add     esp, 8\n.text:008F2A3A\n.text:008F2A3A loc_8F2A3A:\n.text:008F2A3A                 lea     ecx, [esp+30h+var_18]\n.text:008F2A3E                 mov     [esp+30h+var_4], 0FFFFFFFFh\n.text:008F2A46                 call    sub_403DF0\n.text:008F2A4B                 mov     ecx, [esp+30h+var_C]\n.text:008F2A4F                 pop     edi\n.text:008F2A50                 pop     esi\n.text:008F2A51                 pop     ebp\n.text:008F2A52                 xor     al, al\n.text:008F2A54                 pop     ebx\n.text:008F2A55                 mov     large fs:0, ecx\n.text:008F2A5C                 add     esp, 20h\n.text:008F2A5F                 retn    8\n.text:008F2A5F ReadCfgFile     endp\n</code></pre>\n <p>\n  <strong>\n   [EDIT 1 - All what I should have known since the beginning!]\n  </strong>\n </p>\n <p>\n  After following the suggestions of the answer of @sealed..., I used a class inspector to detect the Virtual Function Table and I found the full class descriptor. Well... in fact there are two classes referring to my target method\n  <code>\n   ReadCfgFile\n  </code>\n  and no direct calls to it in the whole executable:\n </p>\n <pre><code>.rdata:0137A1D4 ; class DATABASE_TABLE<CFG_ENTRY,500,unsigned int> [SI] O: 0, A: 0\n.rdata:0137A1D4 dd offset ??_R4?$DATABASE_TABLE@UCFG_ENTRY@@$0BPE@I@@6B@ ; RTTI Complete Object Locator\n.rdata:0137A1D8 ; const DATABASE_TABLE<struct CFG_ENTRY,500,unsigned int> VF Table\n.rdata:0137A1D8 ??_7?$DATABASE_TABLE@UCFG_ENTRY@@$0BPE@I@@6B@ dd offset sub_8EF0F0 ; DATA XREF: sub_8EEFC0+1Do\n.rdata:0137A1DC dd offset nullsub_648\n.rdata:0137A1E0 dd offset sub_8EAB30\n.rdata:0137A1E4 dd offset sub_8EF060\n.rdata:0137A1E8 dd offset sub_8EE500\n.rdata:0137A1EC dd offset ReadCfgFile\n\n.rdata:0137A1F0 ; class CFG_DB: DATABASE_TABLE<CFG_ENTRY,500,unsigned int> [SI] O: 0, A: 0\n.rdata:0137A1F0 dd offset ??_R4CFG_DB@@6B@ ; RTTI Complete Object Locator\n.rdata:0137A1F4 ; const CFG_DB VFTable\n.rdata:0137A1F4 ??_7UNIT_DB@@6B@ dd offset sub_8EF2B0 ; DATA XREF: sub_8EF290+8o\n.rdata:0137A1F8 dd offset nullsub_648\n.rdata:0137A1FC dd offset sub_8EAB30\n.rdata:0137A200 dd offset sub_8EF060\n.rdata:0137A204 dd offset sub_8EE8B0\n.rdata:0137A208 dd offset ReadCfgFile\n.rdata:0137A20C dd offset sub_8EE5D0\n</code></pre>\n <p>\n  <strong>\n   [EDIT 2 - The adventure continues! Yay!]\n  </strong>\n </p>\n <p>\n  After reading the answer of @Guntram Blohm, I investigated some more in order to collect and analyze the data he suggested. The first thing I did is to analyze the executable with PEiD and here is the information I got from it:\n </p>\n <pre><code>Compiler: Microsoft Visual C++ 7.0 Method2 [Debug]\nEntropy: 6.24 (Not Packed)\nLinker Info: 7.10\n</code></pre>\n <p>\n  When I set a breakpoint on my\n  <code>\n   ReadCfgFile\n  </code>\n  method, here is what I get from OllyDBG stack:\n </p>\n <pre><code>CPU Stack\nAddress   Value      ASCII Comments\n0018B2C0  [008EE644  Dï¿½.  ; RETURN to myapp.008EE644\n</code></pre>\n <p>\n  And\n  <code>\n   008EE644\n  </code>\n  is a small part of the following method that, for what I can understand, looks for the configuration file and starts the routine for reading it, but without an explicit call to\n  <code>\n   ReadCfgFile\n  </code>\n  (offset highlighted):\n </p>\n <pre><code>.text:008EE5D0 sub_8EE5D0      proc near ; CODE XREF: sub_411B20+2CBp\n.text:008EE5D0 var_41          = byte ptr -41h\n.text:008EE5D0 var_40          = dword ptr -40h\n.text:008EE5D0 var_3C          = dword ptr -3Ch\n.text:008EE5D0 var_38          = byte ptr -38h\n.text:008EE5D0 var_34          = dword ptr -34h\n.text:008EE5D0 var_30          = dword ptr -30h\n.text:008EE5D0 var_2C          = byte ptr -2Ch\n.text:008EE5D0 var_C           = dword ptr -0Ch\n.text:008EE5D0 var_4           = dword ptr -4\n.text:008EE5D0\n.text:008EE5D0                 push    0FFFFFFFFh\n.text:008EE5D2                 push    offset SEH_8EE5D0\n.text:008EE5D7                 mov     eax, large fs:0\n.text:008EE5DD                 push    eax\n.text:008EE5DE                 mov     large fs:0, esp\n.text:008EE5E5                 sub     esp, 38h\n.text:008EE5E8                 push    ebx\n.text:008EE5E9                 push    ebp\n.text:008EE5EA                 mov     ebx, ecx\n.text:008EE5EC                 push    offset aCfgFile ; \"application.cfg\"\n.text:008EE5F1                 mov     [esp+50h+var_30], ebx\n.text:008EE5F5                 call    sub_41BD00\n.text:008EE5FA                 add     esp, 4\n.text:008EE5FD                 push    eax\n.text:008EE5FE                 lea     ecx, [esp+50h+var_38]\n.text:008EE602                 call    sub_F018E0\n.text:008EE607                 xor     ebp, ebp\n.text:008EE609                 push    ebp\n.text:008EE60A                 lea     eax, [esp+50h+var_38]\n.text:008EE60E                 push    eax\n.text:008EE60F                 lea     ecx, [esp+54h+var_2C]\n.text:008EE613                 mov     [esp+54h+var_4], ebp\n.text:008EE617                 call    sub_D50170\n.text:008EE61C                 lea     ecx, [esp+4Ch+var_38] ; void *\n.text:008EE620                 mov     byte ptr [esp+4Ch+var_4], 2\n.text:008EE625                 call    sub_EFFE30\n.text:008EE62A                 mov     edx, [ebx]\n.text:008EE62C                 mov     ecx, ebx\n.text:008EE62E                 mov     [ebx+7A938h], ebp\n.text:008EE634                 call    dword ptr [edx+4]\n.text:008EE637                 mov     eax, [ebx]\n.text:008EE639                 push    ebp\n.text:008EE63A                 lea     ecx, [esp+50h+var_2C]\n.text:008EE63E                 push    ecx\n.text:008EE63F                 mov     ecx, ebx\n.text:008EE641                 call    dword ptr [eax+14h]\n.text:008EE644 ; ---------------------------------------------------------------------------         \n.text:008EE644                 test    al, al ; HERE IS THE STACK REFERENCE\n.text:008EE644 ; ---------------------------------------------------------------------------   \n.text:008EE646                 jnz     short loc_8EE66C\n.text:008EE648                 lea     ecx, [esp+4Ch+var_2C]\n.text:008EE64C                 mov     [esp+4Ch+var_4], 0FFFFFFFFh\n.text:008EE654                 call    sub_D4BB30\n.text:008EE659                 pop     ebp\n.text:008EE65A                 xor     al, al\n.text:008EE65C                 pop     ebx\n.text:008EE65D                 mov     ecx, [esp+44h+var_C]\n.text:008EE661                 mov     large fs:0, ecx\n.text:008EE668                 add     esp, 44h\n.text:008EE66B                 retn\n.text:008EE66C\n.text:008EE66C loc_8EE66C:\n.text:008EE66C                 xor     edx, edx\n.text:008EE66E                 or      eax, 0FFFFFFFFh\n.text:008EE671                 mov     dword_1986644, edx\n.text:008EE677                 mov     dword_1986650, eax\n.text:008EE67C                 push    esi\n.text:008EE67D                 mov     dword_1986648, edx\n.text:008EE683                 mov     dword_1986654, eax\n.text:008EE688                 push    edi\n.text:008EE689                 mov     dword_198664C, edx\n.text:008EE68F                 mov     dword_1986658, eax\n.text:008EE694                 xor     edi, edi\n.text:008EE696                 cmp     [ebx+79954h], ebp\n.text:008EE69C                 jle     loc_8EE727\n.text:008EE6A2                 lea     esi, [ebx+40h]\n.text:008EE6A5                 jmp     short loc_8EE6B0\n.text:008EE6A7                 align 10h\n.text:008EE6B0\n.text:008EE6B0 loc_8EE6B0:\n.text:008EE6B0                 mov     eax, [esi]\n.text:008EE6B2                 mov     cx, [esi+92h]\n.text:008EE6B9                 lea     eax, ds:1986644h[eax*2]\n.text:008EE6C0                 mov     ax, [eax]\n.text:008EE6C3                 cmp     ax, cx\n.text:008EE6C6                 jnb     short loc_8EE6CA\n.text:008EE6C8                 mov     eax, ecx\n.text:008EE6CA\n.text:008EE6CA loc_8EE6CA:\n.text:008EE6CA                 mov     ecx, [esi]\n.text:008EE6CC                 mov     word ptr dword_1986644[ecx*2], ax\n.text:008EE6D4                 mov     eax, [esi]\n.text:008EE6D6                 mov     cx, [esi+92h]\n.text:008EE6DD                 lea     eax, ds:1986650h[eax*2]\n.text:008EE6E4                 mov     ax, [eax]\n.text:008EE6E7                 cmp     ax, cx\n.text:008EE6EA                 jb      short loc_8EE6EE\n.text:008EE6EC                 mov     eax, ecx\n.text:008EE6EE\n.text:008EE6EE loc_8EE6EE:\n.text:008EE6EE                 mov     edx, [esi]\n.text:008EE6F0                 lea     ecx, [esi-3Ch]\n.text:008EE6F3                 mov     word ptr dword_1986650[edx*2], ax\n.text:008EE6FB                 call    sub_8ED600\n.text:008EE700                 push    eax\n.text:008EE701                 mov     eax, [ebx+7A938h]\n.text:008EE707                 push    eax\n.text:008EE708                 call    sub_F1E550\n.text:008EE70D                 add     edi, 1\n.text:008EE710                 add     esp, 8\n.text:008EE713                 mov     [ebx+7A938h], eax\n.text:008EE719                 add     esi, 3E4h\n.text:008EE71F                 cmp     edi, [ebx+79954h]\n.text:008EE725                 jl      short loc_8EE6B0\n.text:008EE727\n.text:008EE727 loc_8EE727:\n.text:008EE727                 xor     esi, esi\n.text:008EE729                 cmp     dword_1667290, ebp\n.text:008EE72F                 mov     [esp+54h+var_3C], esi\n.text:008EE733                 jbe     loc_8EE840\n.text:008EE739                 lea     esp, [esp+0]\n.text:008EE740\n.text:008EE740 loc_8EE740:\n.text:008EE740                 cmp     [ebx+79954h], ebp\n.text:008EE746                 mov     [esp+54h+var_41], 0\n.text:008EE74B                 mov     [esp+54h+var_40], ebp\n.text:008EE74F                 mov     [esp+54h+var_34], ebp\n.text:008EE753                 jle     loc_8EE7D9\n.text:008EE759                 mov     ebp, 1\n.text:008EE75E                 mov     ecx, esi\n.text:008EE760                 shl     ebp, cl\n.text:008EE762                 lea     edi, [ebx+3B0h]\n.text:008EE768\n.text:008EE768 loc_8EE768:\n.text:008EE768                 cmp     [esp+54h+var_41], 0\n.text:008EE76D                 jnz     short loc_8EE77F\n.text:008EE76F                 test    [edi-2Ch], ebp\n.text:008EE772                 jz      short loc_8EE77F\n.text:008EE774                 test    byte ptr [edi+3], 20h\n.text:008EE778                 jz      short loc_8EE77F\n.text:008EE77A                 mov     [esp+54h+var_41], 1\n.text:008EE77F\n.text:008EE77F loc_8EE77F: \n.text:008EE77F                 xor     esi, esi\n.text:008EE781                 xor     eax, eax\n.text:008EE783\n.text:008EE783 loc_8EE783:\n.text:008EE783                 mov     ecx, [edi-24h]\n.text:008EE786                 test    [eax+ecx], ebp\n.text:008EE789                 jz      short loc_8EE7AF\n.text:008EE78B                 cmp     eax, 10h\n.text:008EE78E                 jnb     loc_8EE89B\n.text:008EE794                 mov     ecx, esi\n.text:008EE796                 shr     ecx, 5\n.text:008EE799                 lea     edx, [esp+ecx*4+54h+var_40]\n.text:008EE79D                 mov     ecx, esi\n.text:008EE79F                 and     ecx, 1Fh\n.text:008EE7A2                 mov     ebx, 1\n.text:008EE7A7                 shl     ebx, cl\n.text:008EE7A9                 or      [edx], ebx\n.text:008EE7AB                 mov     ebx, [esp+54h+var_30]\n.text:008EE7AF\n.text:008EE7AF loc_8EE7AF:\n.text:008EE7AF                 add     eax, 4\n.text:008EE7B2                 add     esi, 1\n.text:008EE7B5                 cmp     eax, 10h\n.text:008EE7B8                 jb      short loc_8EE783\n.text:008EE7BA                 mov     eax, [esp+54h+var_34]\n.text:008EE7BE                 add     eax, 1\n.text:008EE7C1                 add     edi, 3E4h\n.text:008EE7C7                 cmp     eax, [ebx+79954h]\n.text:008EE7CD                 mov     [esp+54h+var_34], eax\n.text:008EE7D1                 jl      short loc_8EE768\n.text:008EE7D3                 mov     esi, [esp+54h+var_3C]\n.text:008EE7D7                 xor     ebp, ebp\n.text:008EE7D9\n.text:008EE7D9 loc_8EE7D9:\n.text:008EE7D9                 push    esi\n.text:008EE7DA                 call    sub_8D1490\n.text:008EE7DF                 mov     edi, eax\n.text:008EE7E1                 add     esp, 4\n.text:008EE7E4                 cmp     byte ptr [edi+0BCh], 0\n.text:008EE7EB                 jz      short loc_8EE82D\n.text:008EE7ED                 xor     esi, esi\n.text:008EE7EF                 cmp     esi, 4\n.text:008EE7F2                 jnb     loc_8EE8A4\n.text:008EE7F8\n.text:008EE7F8 loc_8EE7F8:\n.text:008EE7F8                 mov     ecx, esi\n.text:008EE7FA                 and     ecx, 1Fh\n.text:008EE7FD                 mov     edx, 1\n.text:008EE802                 shl     edx, cl\n.text:008EE804                 mov     ecx, esi\n.text:008EE806                 shr     ecx, 5\n.text:008EE809                 add     ecx, ecx\n.text:008EE80B                 add     ecx, ecx\n.text:008EE80D                 test    [esp+ecx+54h+var_40], edx\n.text:008EE811                 setnz   al\n.text:008EE814                 test    al, al\n.text:008EE816                 jnz     short loc_8EE821\n.text:008EE818                 not     edx\n.text:008EE81A                 and     [ecx+edi+0C0h], edx\n.text:008EE821\n.text:008EE821 loc_8EE821:\n.text:008EE821                 add     esi, 1\n.text:008EE824                 cmp     esi, 4\n.text:008EE827                 jb      short loc_8EE7F8\n.text:008EE829                 mov     esi, [esp+54h+var_3C]\n.text:008EE82D\n.text:008EE82D loc_8EE82D:\n.text:008EE82D                 add     esi, 1\n.text:008EE830                 cmp     esi, dword_1667290\n.text:008EE836                 mov     [esp+54h+var_3C], esi\n.text:008EE83A                 jb      loc_8EE740\n.text:008EE840\n.text:008EE840 loc_8EE840:\n.text:008EE840                 xor     esi, esi\n.text:008EE842                 cmp     [ebx+79954h], ebp\n.text:008EE848                 jle     short loc_8EE875\n.text:008EE84A                 lea     edi, [ebx+108h]\n.text:008EE850\n.text:008EE850 loc_8EE850:\n.text:008EE850                 mov     eax, [edi]\n.text:008EE852                 mov     ecx, dword_16E9DC8\n.text:008EE858                 push    eax ; Str2\n.text:008EE859                 add     ecx, 84h\n.text:008EE85F                 call    sub_10E86C0\n.text:008EE864                 add     esi, 1\n.text:008EE867                 add     edi, 3E4h\n.text:008EE86D                 cmp     esi, [ebx+79954h]\n.text:008EE873                 jl      short loc_8EE850\n.text:008EE875\n.text:008EE875 loc_8EE875:\n.text:008EE875                 lea     ecx, [esp+54h+var_2C]\n.text:008EE879                 mov     [esp+54h+var_4], 0FFFFFFFFh\n.text:008EE881                 call    sub_D4BB30\n.text:008EE886                 mov     ecx, [esp+54h+var_C]\n.text:008EE88A                 pop     edi\n.text:008EE88B                 pop     esi\n.text:008EE88C                 pop     ebp\n.text:008EE88D                 mov     al, 1\n.text:008EE88F                 pop     ebx\n.text:008EE890                 mov     large fs:0, ecx\n.text:008EE897                 add     esp, 44h\n.text:008EE89A                 retn\n.text:008EE89B\n.text:008EE89B loc_8EE89B:\n.text:008EE89B                 lea     ecx, [esp+54h+var_40]\n.text:008EE89F                 jmp     sub_8D0FE0\n.text:008EE8A4\n.text:008EE8A4 loc_8EE8A4:\n.text:008EE8A4                 lea     ecx, [esp+54h+var_40]\n.text:008EE8A8                 jmp     sub_8D0FE0\n.text:008EE8A8 sub_8EE5D0      endp\n</code></pre>\n <p>\n  The, I digged a little bit more finding out the\n  <code>\n   CFG_DB\n  </code>\n  contructor, which looks like this (pseudo-code from IDA Pro):\n </p>\n <pre><code>void __thiscall sub_8EEFC0(void *this)\n{\n  void *v1 = this; // esi@1\n\n  *(_DWORD *)this = &DATABASE_TABLE<CFG_ENTRY_500_unsigned_int>::_vftable_;\n\n  sub_8EE500((int)this);\n  sub_8EC030((char *)v1 + 502036);\n\n  if ( *((_DWORD *)v1 + 124503) )\n    operator delete__(*((void **)v1 + 124503));\n\n  *((_DWORD *)v1 + 124503) = 0;\n\n  unknown_libname_2673((char *)v1 + 4, 0x3E4u, 500, sub_8EEA00);\n}\n</code></pre>\n <p>\n  So it looks like the \"array\" of\n  <code>\n   CFG_ENTRY\n  </code>\n  is being instantiated calling a method belonging to another library linked to the executable.\nFinally, I put a breakpoint at the beginning of my\n  <code>\n   ReadCfgFile\n  </code>\n  method in order to see if pointers passed to it can be of any help:\n </p>\n <pre><code>.text:008F287A                 push esi ==> esi = 00400000\n[...]                          [...]\n.text:008F2886                 mov esi, ecx ==> ecx = myapp.0190BD08\n</code></pre>\n <p>\n  And following the address\n  <code>\n   0190BD08\n  </code>\n  I just stumbled upon this:\n </p>\n <pre><code>.data:0190BD08 unk_190BD08     db    ? ; ; DATA XREF: sub_40FFF0:loc_410049o\n.data:0190BD08                           ; sub_40FFF0:loc_410053o ...\n\n.text:00410049 loc_410049: ; DATA XREF: .rdata:01484034o\n.text:00410049 ; .rdata:0148489Co ...\n.text:00410049                 mov     ecx, offset unk_190BD08\n\n.text:00410053\n.text:00410053 loc_410053: ; DATA XREF: .rdata:01484078o\n.text:00410053 ; .rdata:01484C3Co ...\n.text:00410053                 mov     ecx, offset unk_190BD08\n</code></pre>\n <p>\n  It looks like a dead end to me...\n </p>\n</div>\n</body></html>",
    "votes": "8",
    "answers": 2,
    "views": "3k",
    "tags": [
        "assembly",
        "decompilation",
        "debugging",
        "memory",
        "struct"
    ],
    "user": "Zarathos",
    "time": "May 8, 2014 at 16:37",
    "comments": [
        {
            "user": "Jason Geffner",
            "text": "<html><body><span class=\"comment-copy\">\n I don't see any references in your disassembly to a static buffer. Where's the reference in the disassembly to the equivalent\n <code>\n  s_CfgEntries\n </code>\n ?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Zarathos",
            "text": "<html><body><span class=\"comment-copy\">\n Well, as I said, I'm not really expert about disassembly, and the code I wrote is just a pseudo-code to see how the ASM could look like in human readable code. I can't see any static buffer either but the metod ReadCfgFile is being called only here: \".rdata:0137A1EC dd offset ReadCfgFile\", \".rdata:0137A208 dd offset ReadCfgFile\".\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  It seems to me that the problem is a bit worse than you describe, and there's no easy way to get around it.\n </p>\n <p>\n  First, @sealed seems to be right with the function being a class method, and your compiler passing the class pointer in\n  <code>\n   ecx\n  </code>\n  , because that's the only way for\n </p>\n <pre><code>.text:008F28B5                 lea     ecx, [esi+eax*4+4]\n.text:008F28B9                 call    ReadCfgEntry\n</code></pre>\n <p>\n  to make sense - other parameters are pushed on the stack, and the values of eax, edx and ebx seem not to be very meaningful, so the compiler doesn't use some kind of parameters-in-registers fastcall abi.\n </p>\n <p>\n  Now, let me reorder the statements from the loop start to the call a bit (without changing the meaning, just to make a bit clearer what happens). The compiler spread the \"increment the count by one\" instructions between the others, probably to take advantage of pipelining within the processor:\n </p>\n <pre><code>-- get the current \"number of config entries\" count, and abort the loop if it exceeds 500\n\n.text:008F2890                 mov     eax, [esi+79954h]\n.text:008F2896                 cmp     eax, 1F4h\n.text:008F289B                 jge     loc_8F29DF\n\n-- increment the count by one\n\n.text:008F28A6                 lea     ecx, [eax+1]\n.text:008F28AE                 mov     [esi+79954h], ecx\n\n-- eax = (( count << 5 - count ) * 8 ) + count = count*249\n.text:008F28A1                 mov     edx, eax\n.text:008F28A3                 shl     edx, 5\n.text:008F28A9                 sub     edx, eax\n.text:008F28AB                 lea     eax, [eax+edx*8]\n\n-- push edi, which is a parameter to this function, on the stack;\n-- pass this = esi+4*eax+4  == esi+996*count+4 in ecx. Remember esi was set to\n-- `this`=`ecx` at the start of the current method and hasn't been changed.\n\n.text:008F28B4                 push    edi\n.text:008F28B5                 lea     ecx, [esi+eax*4+4]\n.text:008F28B9                 call    ReadCfgEntry\n</code></pre>\n <p>\n  This seems like ReadCfgEntry is a class method as well, which gets its\n  <code>\n   this\n  </code>\n  pointer in cx. From the way the array index is calculated, i'd assume the original C++ class looked like this:\n </p>\n <pre><code>class Configuration {\n    int whatever;\n    ConfigurationEntry entries[500];\n    ....\n}\n</code></pre>\n <p>\n  with ConfigurationEntry being a 996 byte class.\nNow, the bad news is: These two class members need 4+(500*996) bytes. This is equal to 498004, or 0x79954. So your entry count is directly behind the entries at 0x79954, with another variable at 0x79958:\n </p>\n <pre><code>class Configuration {\n    int whatever;\n    ConfigurationEntry entries[500];\n    int entryCount;\n    int somethingelse;\n    ... ??? ...\n}\n</code></pre>\n <p>\n  Now, if the entries had been a pointer and allocated with\n  <code>\n   new\n  </code>\n  , it would have been easier to just modify the size parameter in that new from 500 to 1000. But in your case, you'd have to modify the new method of the Configuration class, and you'd have to modify ALL references to variables \"behind\" the configuration entries as well. You already mentioned that for the count variable at offset 0x79954, and the next variable at offset 0x79958, but there might be more of them that don't get referenced in your reader function, so you'll have a hard time finding them all.\n </p>\n <hr/>\n <p>\n  I was just about to post this, when i saw your edit to the question.\n </p>\n <p>\n  As you realized in your edit, you need to change all accesses to structure components behind the array of entries that you want to increase. You need to do this in your class methods (which you can find easily as you have the vtables), but also in the rest of your program (as you don't know which of the original class variables where public and might be accessed from outside the class itself).\n  <em>\n   Unfortunately, you can't really automate that, because, for every occurence of, say 0x79954, you'd have to check if it's an index into your class, or something else.\n  </em>\n </p>\n <p>\n  Since i don't know which compiler was used to write your program, i can't tell much about how it stores the function vtable. With a bit of luck, the first entry (the one i called\n  <code>\n   whatever\n  </code>\n  earlier) is the vtable pointer. You can check this if you run the program with a debugger, and check if the\n  <code>\n   whatever\n  </code>\n  variable points to the vtable when it reaches the ReadConfigFile method. If it does, this is good, because we don't have to care about overwriting the vtable when extending the structure.\n </p>\n <p>\n  Then, there must be some allocator function for your classes. Since you seem to have a class called DATABASE_TABLE, and a derived one called CFG_DB, the second one is probably larger. Try finding the initializing method of this second, larger class. It should call\n  <code>\n   new\n  </code>\n  or a similar memory-allocator, with a size that fits the structure size (so it's probably somewhere between 79960h and 79a00h), and it should move the vtable pointer into the newly allocated memory, so you might be able to find it checking for cross-references of the vtable. Or, use a debugger and set a breakpoint on ReadConfigFile and check the stack for what called it, chances should be good you find a function that allocates the class instance first, then calls its ReadConfigFile member function.\n </p>\n <p>\n  After you find where the class is instantiated, i'd probably try not to increase the array size from 500 to 1000, but, instead, just allocate a larger array behind the structure. For example, if your current function allocates 79a00h bytes, add the 996000d bytes to it that 1000 entries need, resulting in 16cca0h bytes. Then, change the\n </p>\n <pre><code>lea ecx, [esi+eax*4+4]\n</code></pre>\n <p>\n  in front of ReadCfgEntry to\n </p>\n <pre><code>lea ecx, [esi+eax*4+16cca0h]\n</code></pre>\n <p>\n  That way, you've created another array\n  <em>\n   behind\n  </em>\n  the current structure instead of extending the current one.\n  <em>\n   Which means none of your structure offsets, except the config items themselves, have changed\n  </em>\n  .\n </p>\n <p>\n  Speaking in C++, we just changed the class to\n </p>\n <pre><code>class Configuration {\n    int whatever;\n    ConfigurationEntry entries[500];\n    int entryCount;\n    int somethingelse;\n    ... ??? ...\n    ConfigurationEntry newEntries[1000];\n}\n</code></pre>\n <p>\n  and in the next step we have to re-write all accessed to\n  <code>\n   entries\n  </code>\n  to use\n  <code>\n   newentries\n  </code>\n  .\n </p>\n <p>\n  Check your member functions for accesses to the original array, and replace them as well. The most simple way to do this is probably\n </p>\n <ul>\n  <li>\n   start the program with a debugger\n  </li>\n  <li>\n   set a breakpoint on the function you identified previously that allocates the structure\n  </li>\n  <li>\n   after the structure is allocated, set a hardware breakpoint on (structure address + 4)\n  </li>\n  <li>\n   continue the program, and whenever you hit the hardware breakpoints, you found a match\n  </li>\n </ul>\n <p>\n  Since the hardware breakpoint is on entries[0], chances are good that every access to an entry hits the 0-th of it at some point.\n </p>\n <p>\n  Also, since ReadCfgEntry is probably a class method, chances are good that there is a loop somewhere that just allocates one class instance for each entry - something like\n </p>\n <pre><code>for (i=0; i<500; i++) {\n    entries[i]=new ConfigurationEntry()\n}\n</code></pre>\n <p>\n  Your hardware breakpoint should catch this loop quite quickly. Patch the executable to change the 500 to 1000, and the entries[i] calculation to your new array. After that, your new array will get initialized, but the old one will hold nothing but NULL pointers. Which means, you might get invalid memory acceses through those NULL pointers in the future, which help identifying accessed to your original array (that you can patch) as well.\n </p>\n <hr/>\n <h2>\n  Edit - Edit after reading OP's 2nd answer\n </h2>\n <p>\n  Dead end? Not at all, you gathered and posted very valuable information.\n </p>\n <p>\n  First, your pseudo code of the CFG_DB constructor\n </p>\n <pre><code>void __thiscall sub_8EEFC0(void *this)\n{\n  void *v1 = this; // esi@1\n  *(_DWORD *)this = &DATABASE_TABLE<CFG_ENTRY_500_unsigned_int>::_vftable_;\n</code></pre>\n <p>\n  confirms that the 4 bytes at the beginning of the class structure are actually a pointer to the virtual function table of the class.\n </p>\n <p>\n  Second, your snippet\n </p>\n <pre><code>.text:008EE639                 push    ebp\n.text:008EE63A                 lea     ecx, [esp+50h+var_2C]\n.text:008EE63E                 push    ecx\n.text:008EE63F                 mov     ecx, ebx\n.text:008EE637                 mov     eax, [ebx]\n.text:008EE641                 call    dword ptr [eax+14h]\n.text:008EE644 ;     ---------------------------------------------------------------------------         \n.text:008EE644                 test    al, al ; HERE IS THE STACK REFERENCE\n</code></pre>\n <p>\n  fits very well. (Again, i reordered the assembly instructions in a way that doesn't change what they do, but makes it clearer to understand them). Remember your vtable that had a function offset, a nullsub, 3 more function offsets, and\n  <code>\n   ReadCfgFile\n  </code>\n  as its entries? Since each of these has 4 bytes, the offset of the ReadCfgFile function pointer in the vtable is 20, or 14h. In that code snippet, ebx is a class pointer;\n  <code>\n   mov eax, [ebx]\n  </code>\n  gets the vtable pointer from the class pointer, and\n  <code>\n   call dword ptr [eax+14h]\n  </code>\n  calls the function at that offset, namely\n  <code>\n   ReadCfgFile\n  </code>\n  . Before that, it initializes the\n  <code>\n   this\n  </code>\n  register (ecx) to ebx, and pushes 2 parameters on the stack. This seems to be a very standard call to a class method.\n </p>\n <p>\n  Next, your constructor ends in\n </p>\n <pre><code>unknown_libname_2673((char *)v1 + 4, 0x3E4u, 500, sub_8EEA00);\n</code></pre>\n <p>\n  with the first parameter (v1+4) being the address of the ConfigurationEntries array within the Configuration class (i'm keeping my old invented variable/class names), the second parameter (0x3e4 == 996) the size of each array entry; the third (500) the number of entries, and a callback function. I'm almost sure this is the constructor function for the individual ConfigurationEntries. Which means this is the function i said you need to find, and which should be changed to\n </p>\n <pre><code>unknown_libname_2673((char *)v1 + XXXXX, 0x3E4u, 1000, sub_8EEA00);\n</code></pre>\n <p>\n  with XXXXX being the offset of the newEntries array once we allocate space for it.\n </p>\n <p>\n  Next, reconsidering a part of the code snippet before the indirect call to ReadConfigFile,\n </p>\n <pre><code>.text:008EE62A                 mov     edx, [ebx]\n.text:008EE62C                 mov     ecx, ebx\n.text:008EE62E                 mov     [ebx+7A938h], ebp\n.text:008EE634                 call    dword ptr [edx+4]\n</code></pre>\n <p>\n  we see that there is a move to\n  <code>\n   ebx+7A938h\n  </code>\n  , with ebx being the class pointer, so there seems to be another class member at this offset. This is quite a lot of memory\n  <em>\n   after\n  </em>\n  the offset of the element count (79954h) - so the structure has a lot more components. Good thing you're not trying to shift them all. The constructor function, which accesses\n  <code>\n   this+502036\n  </code>\n  , or\n  <code>\n   this+0x7a914\n  </code>\n  , would have been another hint at that. (It also accesses\n  <code>\n   this+124503\n  </code>\n  , but with\n  <code>\n   this\n  </code>\n  being a dword pointer, this means 498012 bytes, which is still less than 502036).\n </p>\n <p>\n  Next, you found out the address 0190BD08, which is a very good thing. Along with the XREFs, and the data definition,\n </p>\n <pre><code>.data:0190BD08 unk_190BD08     db    ? \n</code></pre>\n <p>\n  this means:\n </p>\n <p>\n  The class structure at that address is NOT allocated dynamically, and it is NOT initialized to anything, instead, it is an uninitialized global variable. In C++, it would have probably been a\n </p>\n <pre><code>static Configuration myConfig;\n</code></pre>\n <p>\n  with all the xrefs you're seeing being a reference to myConfig. As the assembly instructions at those places are\n </p>\n <pre><code>mov     ecx, offset unk_190BD08\n</code></pre>\n <p>\n  i'm almost sure the calls to a class member function are one or 2 instructions after each of these. Congractulations, you've just found a way to catch many of the instances where the configuration gets accessed. To verify this, unk_190BD08 being a global variable for the configuration, you could run the program with a breakpoint on the constructor function (sub_8EEFC0), i bet it's called only once, and 190BD08 is the parameter to it.\n </p>\n <p>\n  The bad thing about the configuration class instance being a static variable, not a new()-instantiated one, is that we can't just increase the size in the new() call. Instead, we'll have to move it to a part of the address space where it doesn't disturb anything else - at the end of the current uninitialized data segment. Find the very last entry in your data segment, then choose a nice address behind that, and rewrite all the xrefs to unk_190BD08 to that new address. Then, run the program using ollydbg, place a hardware breakpoint on 190BD08 just in case, and check that the functions you know to be class member functions, and the initialized, all get the new address instead of 190BD08 as their\n  <code>\n   ecx\n  </code>\n  (this) parameter. When you've finished, you're ready to implement the 2nd part, change the accesses to\n  <code>\n   this+4\n  </code>\n  to\n  <code>\n   this+XXXX\n  </code>\n  with\n  <code>\n   XXXX\n  </code>\n  being the class size.\n </p>\n <p>\n  The fact that we're missing a new() call for the Configuration variable means we can't use its parameter to get the class size. But we already know the class size is at least 7A938h, so the static variable occupies the address space from 0x190BD08 to at least 0x1986640. With a bit of luck, your .data segment has that unk_190BD08 label, with the next label being at an address a bit after 0x1986640, so the next label is some other variable, and the difference between both labels the size of the Configuration instance.\n </p>\n <p>\n  There's one thing left to do - when you move the configuration variable behind everything else, you'll also have to increase the size of that data segment in the PE file. Unfortunately, i'm not that skilled in the windows PE file format, so i'd have to do a lot of research how to do this correctly myself, so maybe you're lucky and someone else, who has more experience in this than i have, can help you with this.\n </p>\n <hr/>\n <h2>\n  Edit - Edit to answer to comment\n </h2>\n <ul>\n  <li>\n   how can I calculate how big is the CFG_DB class in order to append something at the end of it?\n  </li>\n </ul>\n <p>\n  The original C++ program will have had something like\n </p>\n <pre><code>int somevariable;\nint someothervariable;\nCFG_DB globalConfig;\nint athirdvariable;\n</code></pre>\n <p>\n  (int as an example, the data type could be anything)\nand the compiler should place all of these varuables into the uninitialized part of the .data segment. Any access to one of the variables will make IDA create a label at that memory address, with an XREF to where it's accessed. So, if your .data dump looks like this\n </p>\n <pre><code>.data:0190BD08 unk_190BD08     db    ?        <-- along with some xrefs \n.data:0190BD09                 db    ?        <-- this repeats a lot of times\n.data:01986670 unk_1986670     db    ?        <-- along with some xrefs \n</code></pre>\n <p>\n  and you know that 0190BD08 is your\n  <code>\n   globalConfig\n  </code>\n  , then 01986670 is\n  <code>\n   athirdvariable\n  </code>\n  , and the size of globalConfig is 0x01986670 - 0x0190BD08 = 0x7a968 = 502120 bytes.\n </p>\n <p>\n  This is not 100% foolproof, because if anything accesses globalConfig.somemember, with somemember having a structure offset of, say, 500000 (=0x7a120), then IDA will generate a label and an XREF at 0x190BD08+0x7a120=0x1985E28 ass well. But with a bit of luck, the \"rest\" of the program will just use the globalConfig variable as an argument to a member function, where references are indirect, so they won't be used by IDA to create labels.\n </p>\n <ul>\n  <li>\n   what will happen if other classes/methods/etc are interacting with this modified class?\n  </li>\n </ul>\n <p>\n  If they access anything but the 500 individual config entries, nothing at all, because these haven't changed their offset. The thing that might be dangerous is when they access the entries, because those accesses should be rewritten to newEntries. You have to find out where they are (if you're lucky, that's just in the member functions) and patch the code at that point. The hardware breakpoint on the (old) entries[0] address (which is 0x190BD0C in your case, structure start + 4) should help with this, because anything that's likely to access any entry, is likely to access entry[0] as well. So, if you hit the hardware breakpoint, on, say,\n  <code>\n   mov eax, [ebx+4]\n  </code>\n  , then you know\n  <code>\n   ebx+4\n  </code>\n  is accessing the old address, and should be rewritten to\n  <code>\n   mov eax, [ebx+XXXXX]\n  </code>\n  to use the new array.\n </p>\n <p>\n  Unfortunately, you can't create a hardware breakpoint that covers the whole structure to catch any access. That's where the null pointer exceptions kick in. If, after the change, your program throws a NPE where it normally doesn't, it's probably because 'something' accessed the old array, which contains nothing but NULLs now, instead of the new one. Catching the NPE in the debugger, and checking the disassembly/call stack that lead to it, should give you an idea where the NULL pointer was read from the old array, so you know which instruction to change to point to the new one.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Guntram Blohm",
            "time": "May 9, 2014 at 9:41",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Zarathos",
                    "text": "<span class=\"comment-copy\">Thanks for your very, very valuable answer. I edited my answer with mode information that could be probably helpful for someone who's more skilled than me...</span>",
                    "time": null
                },
                {
                    "user": "Guntram Blohm",
                    "text": "<span class=\"comment-copy\">Updated my answer to reply to your 2nd Edit as well.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">@guntram i havent digested the answer but in your proposal if it is ok to add space at the end of executable instead of at the end of some section before another section it is dead easy there are even utilities that does this automatically for you and can add asmuch space as you want at the end iirc santmants ZeroAdd is one such utility (been very long since i used it but should be available in woodmanns tool repo</span>",
                    "time": null
                },
                {
                    "user": "Zarathos",
                    "text": "<span class=\"comment-copy\">Wow @GuntramBlohm, your answer is just amazing. I would have never discovered all that without your help! So, in fact, to resume a little bit I have to: 1) move all the XRefs to unk_190BD08 to the bottom of my data space to avoid overwriting 2) change 500 to 1000 and \"v1 + 4\" to the new CFG_ENTRY[] address in unknown_libname_2673's call in the constructor But there are still two things I don't understand: how can I calculate how big is the CFG_DB class in order to append something at the end of it? And... what will happen if other classes/methods/etc are interacting with this modified class?</span>",
                    "time": null
                },
                {
                    "user": "Guntram Blohm",
                    "text": "<span class=\"comment-copy\">It seems that something somewhere is accessing globalConfig.entries directly. This will make IDA put a label there, along with an xref.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  As I Don't know the prototype of\n  <em>\n   ReadCfgEntry\n  </em>\n  and structure of the code my answer is not exact.\n </p>\n <p>\n  <strong>\n   First: If the buffer is dynamically allocated\n  </strong>\n </p>\n <p>\n  As your function use ECX as initialized register:\n </p>\n <pre><code>.text:008F2886                 mov     esi, ecx\n</code></pre>\n <p>\n  It is a class function so the owner class has a constructor that initiated the target buffer. you must trace the buffer and increase the allocation size.\n </p>\n <p>\n  It is not an exact way to find constructor; but one of the efficient way is to find\n  <em>\n   Virtual Function Table\n  </em>\n </p>\n <ul>\n  <li>\n   <p>\n    by trace ECX at function start. most of times the destination buffer contains a\n    <em>\n     VFTable\n    </em>\n    in first element.\n   </p>\n  </li>\n  <li>\n   <p>\n    by XRef it in IDA (as you did)\n   </p>\n   <blockquote>\n    <p>\n     ReadCfgFile is being called only here: \".rdata:0137A1EC dd offset\n  ReadCfgFile\"...\n    </p>\n   </blockquote>\n  </li>\n </ul>\n <p>\n  After finding\n  <em>\n   VFTable\n  </em>\n  , most of time the constructor is topmost member.\n </p>\n <p>\n  <strong>\n   Second: If the buffer is statically allocated\n  </strong>\n </p>\n <p>\n  As I mentioned before the function is a member of class so if you change the pointer of interest; it would do the work.\n </p>\n <p>\n  <code>\n   if (!ReadCfgEntry((void*)(pointer + (996 * entriesCount) + 4), v5))\n  </code>\n </p>\n <p>\n  you should insert a stub to allocate proper memory and assign it to class.\n </p>\n <p>\n  FINALLY: If a program is closed source it means the developer doesn't like others to modify it for personal use... be sure the license is not violated!\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "sealed...",
            "time": "May 8, 2014 at 4:53",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Zarathos",
                    "text": "<span class=\"comment-copy\">I'm editing this application for personal use only, it won't be harmless and I won't publicly release these modifications... it's just a very old application that is no more under development but that could be really, really useful for me. Meanwhile, I edited my question adding my recent findings, so probably everything will be clearer for you now.</span>",
                    "time": null
                }
            ]
        }
    ]
}