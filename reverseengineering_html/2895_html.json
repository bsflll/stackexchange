{
    "title": "Delphi Pascal Try..Except..Finally block",
    "link": "https://reverseengineering.stackexchange.com/questions/2895/delphi-pascal-try-except-finally-block",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm having trouble reverse-engineering a specific Delphi Pascal .exe (old vsn., pre-1995 so probably v.3). From the system calls I understand this is\n  <em>\n   probably\n  </em>\n  a\n  <code>\n   try..except..finally\n  </code>\n  block, but I am at a loss finding the 'normal' route through the code, and what the\n  <code>\n   except\n  </code>\n  and (possibly)\n  <code>\n   finally\n  </code>\n  blocks are.\n </p>\n <p>\n  The assembly looks like this:\n </p>\n <pre><code>782CFC  33 C0                   xor    eax, eax\n782CFE  55                      push   ebp\n782CFF  68 (782E37)             push   _FINALLY_A_0_782E37\n782D04  64 FF 30                push   dword ptr fs:[eax]\n782D07  64 89 20                mov    dword ptr fs:[eax], esp\n\n            _try_0_782D0A:\n782D0A  8B D3                   mov    edx, ebx\n782D0C  8B C6                   mov    eax, esi\n782D0E  E8 D1 F3 FF FF          call   ...unrelated...\n782D13  8D 56 1C                lea    edx, [esi+1Ch]\n.. lots of regular code here ..\n.. ending with ..\n782E17  8B 18                   mov    ebx, dword ptr [eax]\n782E19  FF 53 20                call   dword ptr [ebx+20h]\n\n        finally_1_782E1C:\n782E1C  33 C0                   xor    eax, eax\n782E1E  5A                      pop    edx\n782E1F  59                      pop    ecx\n782E20  59                      pop    ecx\n782E21  64 89 10                mov    dword ptr fs:[eax], edx\n782E24  68 (782E3E)             push   _end_1_782E3E\n\n                @block_L:\n782E29  8D 45 F4                lea    eax, [ebp + local_0C]\n782E2C  BA 02 00 00 00          mov    edx, 2\n782E31  E8 12 E3 F7 FF          call   System.@LStrArrayClr\n782E36  C3                      retn\n\n            _FINALLY_A_0_782E37:\n782E37  E9 B4 E2 F7 FF          jmp    System.@HandleFinally\n\n            _FINALLY_B_0_782E3C:\n782E3C  EB EB                   jmp    @block_L\n                ; -------\n\n            _end_1_782E3E:\n782E3E  5F                      pop    edi\n782E3F  5E                      pop    esi\n782E40  5B                      pop    ebx\n782E41  8B E5                   mov    esp, ebp\n782E43  5D                      pop    ebp\n782E44  C3                      retn\n</code></pre>\n <p>\n  -- this is output from my own disassembler, but I don't think there are errors in it. The labels have been auto-named, but I still cannot follow the 'logic' (if any) from one block to the next. In particular, the bottom half, right before the function epilogue, confuses me.\n </p>\n <p>\n  Are these fragments enough to reconstruct the original\n  <code>\n   try\n  </code>\n  ..\n  <code>\n   finally\n  </code>\n  blocks?\n </p>\n <hr/>\n <p>\n  After reading Igor's answer: yes they are. Consider these flowcharts: left, original before special handling of try/finally blocks, right, afterwards.\n </p>\n <p>\n  <img alt=\"flowcharts\" src=\"https://i.sstatic.net/1B6lK.png\"/>\n </p>\n <p>\n  In the original flowchart, I considered every jump from one basic block to another as a\n  <em>\n   link\n  </em>\n  , and the code flow stops at every\n  <code>\n   retn\n  </code>\n  .\n  <code>\n   if\n  </code>\n  (E-(F)-K) and\n  <code>\n   if-else\n  </code>\n  (G-H/I-J) structures can clearly be discerned. However, pushing return addresses and the other 'tricks' of exception handling, defeat this, as can be seen by the dangling blocks N and O -- they 'enter' from nowhere --, and a separate block 'M' which comes and goes from nowhere.\n </p>\n <p>\n  At the right, I separated the\n  <em>\n   initialization\n  </em>\n  of the exception block from the main code (adding a new block B), and concatenated the\n  <em>\n   finalize\n  </em>\n  structure into one single new block (M), which ultimately jumps to an AFTER_TRY (which happened to be the last\n  <em>\n   Exit\n  </em>\n  block). Now it's clear that\n </p>\n <ol>\n  <li>\n   right after the prologue, a\n   <code>\n    try\n   </code>\n   is initiated;\n  </li>\n  <li>\n   all code ends up at the\n   <code>\n    finally\n   </code>\n   block M, which\n  </li>\n  <li>\n   then always exists the code at a single fixed point.\n  </li>\n </ol>\n</div>\n</body></html>",
    "votes": "12",
    "answers": 1,
    "views": "3k",
    "tags": [
        "disassembly",
        "decompilation"
    ],
    "user": "Jongware",
    "time": "Oct 7, 2013 at 21:44",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Delphi implements\n  <code>\n   try\n  </code>\n  /\n  <code>\n   except\n  </code>\n  /\n  <code>\n   finally\n  </code>\n  by using Win32 Structured Exception Handlers (SEH). The basics of SEH are explained in the\n  <a href=\"http://www.microsoft.com/msj/0197/Exception/Exception.aspx\" rel=\"noreferrer\">\n   classic article by Matt Pietrek\n  </a>\n  , so I'll skip to the details relevant to Delphi only.\n </p>\n <h1>\n  1.\n  <code>\n   try\n  </code>\n  entry\n </h1>\n <p>\n  Entry to a\n  <code>\n   try\n  </code>\n  block, or a block which protects automatic variables that need to be destructed on exit (such as strings) looks like the following:\n </p>\n <pre><code>xor     eax, eax\npush    ebp\npush    offset SEH_HANDLER\npush    dword ptr fs:[eax]\nmov     fs:[eax], esp\n</code></pre>\n <p>\n  This is a typical way of setting up a SEH frame. After it's run, top of the stack will look like this:\n </p>\n <pre><code>       +-----------+\nESP+00 |    next   | <- fs:[0] points here\n       +-----------+\nESP+04 |  handler  |\n       +-----------+\nESP+08 | saved_ebp |\n       +-----------+\n</code></pre>\n <p>\n  The pointer to this structure will be passed to the SEH handler.\n </p>\n <h1>\n  2.\n  <code>\n   try\n  </code>\n  exit\n </h1>\n <p>\n  At the end of the\n  <code>\n   try\n  </code>\n  block, the SEH frame is torn down:\n </p>\n <pre><code>    xor     eax, eax\n    pop     edx               ; pop 'next' into edx\n    pop     ecx               ; pop handler\n    pop     ecx               ; pop saved_ebp\n    mov     fs:[eax], edx     ; move 'next' into fs:[0]\n</code></pre>\n <p>\n  If there is a\n  <code>\n   finally\n  </code>\n  handler or automatic destructors, then it continues like this:\n </p>\n <pre><code>    push    offset AFTER_TRY  ; make it so the 'ret' will jump to AFTER_TRY\nFINALLY_HANDLER:\n    <destruct automatic variables created in the try block>\n    <finally handler body>\n    ret                       ; jumps to AFTER_TRY\n</code></pre>\n <p>\n  Otherwise there is a simple jump:\n </p>\n <pre><code>    jmp AFTER_TRY\n</code></pre>\n <h1>\n  3.\n  <code>\n   finally\n  </code>\n  handler\n </h1>\n <p>\n  In case the program use\n  <code>\n   finally\n  </code>\n  statement, or in case of the\n  <code>\n   try..finally\n  </code>\n  added by the compiler to guard automatic variables, the SEH handler looks like this:\n </p>\n <pre><code>SEH_HANDLER:\n    jmp     _HandleFinally\n    jmp     FINALLY_HANDLER\n</code></pre>\n <h1>\n  4.\n  <code>\n   except\n  </code>\n  handler\n </h1>\n <p>\n  If the program uses an\n  <code>\n   except\n  </code>\n  handler to catch all exceptions, the code looks a little different:\n </p>\n <pre><code>SEH_HANDLER:\n    jmp     _HandleAnyException\n    <handler code>\n    call    _DoneExcept\n</code></pre>\n <h1>\n  5.\n  <code>\n   except on\n  </code>\n  handlers\n </h1>\n <p>\n  If the program uses\n  <code>\n   except on...\n  </code>\n  to match the exception(s) being caught, the compiler generates a table of one or more possible exception classes with corresponding handlers:\n </p>\n <pre><code>SEH_HANDLER:\n    jmp     _HandleOnException\n    dd <numExceptions>\n    dd offset ExceptionClass1\n    dd offset OnException1_handler\n    dd offset ExceptionClass2\n    dd offset OnException2_handler\n    <...>\n\nOnException1_handler:\n    <handler code>\n    call    _DoneExcept\n\nOnException2_handler:\n    <handler code>\n    call    _DoneExcept\n</code></pre>\n <p>\n  There may be some variations, but I think I covered most of it.\n </p>\n <p>\n  The source code of\n  <code>\n   _HandleFinally\n  </code>\n  ,\n  <code>\n   _HandleAnyException\n  </code>\n  ,\n  <code>\n   _HandleOnException\n  </code>\n  ,\n  <code>\n   _DoneExcept\n  </code>\n  and a few other exceptions-related functions can be found in\n  <code>\n   system.pas\n  </code>\n  in the VCL sources.\n </p>\n</div>\n</body></html>",
            "votes": "11",
            "user": "Igor Skochinsky",
            "time": "Oct 7, 2013 at 15:26",
            "is_accepted": true,
            "comments": []
        }
    ]
}