{
    "title": "Question about Keeloq - A car remote control standard",
    "link": "https://reverseengineering.stackexchange.com/questions/11988/question-about-keeloq-a-car-remote-control-standard",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have a question about Keeloq security. I have an original car remote controller (BFT Mitto 2) and I know this chip uses HCS301 with Keeloq implementation.\n </p>\n <p>\n  I would like to clone this remote for my girlfriend because it's very expensive to buy a new one. I know universal remotes can copy this remote like this stuff (\n  <a href=\"http://www.amazon.fr/T%C3%A9l%C3%A9commande-Copieuse-T%C3%89L%C3%89COMMANDES-t%C3%A9l%C3%A9commandes-descriptif/dp/B00GTV5SUQ\" rel=\"nofollow noreferrer\">\n   http://www.amazon.fr/T%C3%A9l%C3%A9commande-Copieuse-T%C3%89L%C3%89COMMANDES-t%C3%A9l%C3%A9commandes-descriptif/dp/B00GTV5SUQ\n  </a>\n  ) but I'm curious and I think it's a good electronic project for fun. So, I studied the datasheet of this component. I have already spoofed two consecutive commands and I saved the seed code (retrieved by pushing all the buttons).\n </p>\n <p>\n  Data 1:\nCrypt part:\n  <code>\n   0xFD32DEBA\n  </code>\n  Serial number:\n  <code>\n   0x719A00\n  </code>\n </p>\n <p>\n  Data 2:\nCrypt part:\n  <code>\n   0xB1755164\n  </code>\n  Serial number:\n  <code>\n   0x719A00\n  </code>\n </p>\n <p>\n  SEED CODE:\n  <code>\n   0xFAA7B14\n  </code>\n </p>\n <p>\n  How can I learn a new remote with this information? I don't know how universal remote works but according to the datasheet I need to know the manufacturer Id to create a device Key. Can you advise me how I can proceed please.\n </p>\n <p>\n  Thank you!\n </p>\n</div>\n</body></html>",
    "votes": "5",
    "answers": 1,
    "views": "3k",
    "tags": [
        "hardware",
        "encryption",
        "decryption",
        "embedded"
    ],
    "user": null,
    "time": "Jan 13, 2017 at 19:37",
    "comments": [
        {
            "user": "Federico Ferrari",
            "text": "<html><body><span class=\"comment-copy\">\n So at the end, there is someone who successfully copy a keeloq rolling code remote?\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  To create a full duplicate, able to generate valid transmission packets you'll need the following information:\n </p>\n <ol>\n  <li>\n   Serial Number\n  </li>\n  <li>\n   Button press mapping\n  </li>\n  <li>\n   32 bit of KeeLoq encrypted data\n  </li>\n </ol>\n <p>\n  See attached Figure 1-2, from the\n  <a href=\"http://ww1.microchip.com/downloads/en/devicedoc/21143b.pdf\" rel=\"noreferrer\">\n   datasheet\n  </a>\n  , near \"Transmitted information\" at the bottom right:\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/dVEQQ.png\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/dVEQQ.png\"/>\n  </a>\n </p>\n <p>\n  Using those three pieces of information you can theoretically create your own device.\n </p>\n <h2>\n  Serial Numer\n </h2>\n <p>\n  The serial number is a unique identifier of the remote control, and is trivially retrievable by capturing a single transmission packet because it is sent as-is. OP already retrieved it.\n </p>\n <p>\n  The serial is later required because it is part of the encrypted data as well, so the ability to retrieve it without first decrypting a transmission might help us down the line when we'll create the encrypted part.\n </p>\n <h1>\n  Key mappings\n </h1>\n <p>\n  In order to send a specific key, you'll need to create your own mapping of values to key meaning. This is not as easy as getting a single value of any transmitted message but does not prove any difficulty, just hit every key and capture it's\n  <em>\n   Button Press Information\n  </em>\n  field. OP seems to have managed that as well.\n </p>\n <h1>\n  32 bit of KeeLoq encrypted data\n </h1>\n <p>\n  This is where shit gets serious, we'll need to know what to encrypt in addition to the key:\n </p>\n <ol>\n  <li>\n   Button status.\n  </li>\n  <li>\n   DISC bits.\n  </li>\n  <li>\n   OVR bits.\n  </li>\n  <li>\n   Sync Counter (16 bit word incremented once for every button press in the controller's life span).\n  </li>\n  <li>\n   Encryption Key (called \"Crypt Key\" to sound leet in the datasheet :D )\n  </li>\n </ol>\n <p>\n  See attached Figure 4-2, from the datasheet, right part:\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/rlXR9.png\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/rlXR9.png\"/>\n  </a>\n </p>\n <h2>\n  Button status bits\n </h2>\n <p>\n  These four bits are the same ones sent unencrypted, so we've already discussed their rather easy retrieval.\n </p>\n <h2>\n  DISC bits\n </h2>\n <blockquote>\n  <p>\n   The discrimination value aids the post-decryption\n  check on the decoder end. It may be any value, but in\n  a typical system it will be programmed as the 10 Least\n  Significant bits of the serial number. Values other than\n  this must be separately stored by the receiver when a\n  transmitter is learned. The discrimination bits are part\n  of the information that form the encrypted portion of the\n  transmission (Figure 4-2). After the receiver has\n  decrypted a transmission, the discrimination bits are\n  checked against the receiver’s stored value to verify\n  that the decryption process was valid. If the discrimination\n  value was programmed as the 10 LSb’s of the\n  serial number then it may merely be compared to the\n  respective bits of the received serial number; saving\n   <a href=\"https://en.wikipedia.org/wiki/EEPROM\" rel=\"noreferrer\">\n    EEPROM\n   </a>\n   space.\n  </p>\n </blockquote>\n <p>\n  These bits are used to identify the device, and according to the datasheet are usually the\n  <em>\n   Least Significant Bits\n  </em>\n  of the previously discussed\n  <em>\n   Serial Number\n  </em>\n  .\n </p>\n <h2>\n  OVR bits\n </h2>\n <blockquote>\n  <p>\n   The overflow bits are used to extend the number of\n  possible synchronization values. The synchronization\n  counter is 16 bits in length, yielding 65,536 values\n  before the cycle repeats. Under typical use of\n  10 operations a day, this will provide nearly 18 years of\n  use before a repeated value will be used. Should the\n  system designer conclude that is not adequate, then\n  the overflow bits can be utilized to extend the number\n  of unique values. This can be done by programming\n  OVR0 and OVR1 to 1s at the time of production. The\n  encoder will automatically clear OVR0 the first time that\n  the synchronization value wraps from 0xFFFF to\n  0x0000 and clear OVR1 the second time the counter\n  wraps. Once cleared, OVR0 and OVR1 cannot be set\n  again, thereby creating a permanent record of the\n  counter overflow. This prevents fast cycling of 64K\n  counter. If the decoder system is programmed to track\n  the overflow bits, then the effective number of unique\n  synchronization values can be extended to 196,608.\n  </p>\n </blockquote>\n <p>\n  Under normal circumstances, these bits will be zero. They're used to increase the overall Sync Counter size by two bits but are unused by default, according to the datasheet.\n </p>\n <h2>\n  Sync Counter\n </h2>\n <p>\n  Out of the datasheet:\n </p>\n <blockquote>\n  <p>\n   This is the 16-bit synchronization value that is used to create the hopping code for transmission. This value will increment after every transmission.\n  </p>\n </blockquote>\n <p>\n  This is a value incremented every time a button is pressed, so once we get it we'll be able to roughly know what is the next expected value (which will depend on the number of button presses since).\n </p>\n <p>\n  Additionally:\n </p>\n <blockquote>\n  <p>\n   Figure 7-3 shows a 3-partition, rotating synchronization\n  window. The size of each window is optional but the\n  technique is fundamental. Each time a transmission is\n  authenticated, the intended function is executed and\n  the transmission’s synchronization counter value is\n  stored in EEPROM. From the currently stored counter\n  value there is an initial \"Single Operation\" forward window\n  of 16 codes. If the difference between a received\n  synchronization counter and the last stored counter is\n  within 16, the intended function will be executed on the\n  single button press and the new synchronization\n  counter will be stored. Storing the new synchronization\n  counter value effectively rotates the entire synchronization\n  window.\n  </p>\n  <p>\n   A \"Double Operation\" (resynchronization) window further\n  exists from the Single Operation window up to 32K\n  codes forward of the currently stored counter value. It\n  is referred to as \"Double Operation\" because a transmission\n  with synchronization counter value in this window\n  will require an additional, sequential counter\n  transmission prior to executing the intended function.\n  Upon receiving the sequential transmission the\n  decoder executes the intended function and stores the\n  synchronization counter value. This resynchronization\n  occurs transparently to the user as it is human nature\n  to press the button a second time if the first was unsuccessful.\n  </p>\n </blockquote>\n <p>\n  Which means we don't have to hit the exact value, and actually can guess a number the the range of up to 32k values further away, nearly half the size of the value-space.\n </p>\n <p>\n  There are three possible ways to figure it out.\n </p>\n <h3>\n  Reading the EEPROM\n </h3>\n <p>\n  By reading the\n  <a href=\"https://en.wikipedia.org/wiki/EEPROM\" rel=\"noreferrer\">\n   EEPROM\n  </a>\n  , which stores the Sync Counter. Since it is not possible to read EEPROM using the HCS301 without first writing it, you cannot normally read it without tinkering with the hardware. If you've managed to do that you can easily duplicate a remote. Good for you!\n </p>\n <h3>\n  Decrypting a single transmission\n </h3>\n <p>\n  By decrypting a single transmission you can get the currently used Sync Counter, and have a rough estimate going forward. Since the counter is incremented relatively rarely (datasheet estimates 10 times a day), you can easily guess enough values to succeed.\n </p>\n <h3>\n  Good old bruteforcing\n </h3>\n <p>\n  By\n  <a href=\"https://en.wikipedia.org/wiki/Brute-force_attack\" rel=\"noreferrer\">\n   bruteforcing\n  </a>\n  the entire value, you're also able to get the correct value. Since the key-space is relatively small 64k values, you could go at it. According to\n  <a href=\"https://securewww.esat.kuleuven.be/cosic/publications/article-1045.pdf\" rel=\"noreferrer\">\n   this\n  </a>\n  cryptanalysis and related-works review:\n </p>\n <blockquote>\n  <p>\n   Depending on the transponder, it takes 65 or 98 minutes to gather\n   <code>\n    2^16\n   </code>\n   plaintext/ciphertext pairs.\n  </p>\n </blockquote>\n <p>\n  <em>\n   Note they quote is taken a bit out of context here. While the original intent was getting samples of known plaintext/ciphertext for the challenge-response part of the chip, they also provide a rough estimate at the protocol's speed.\n  </em>\n </p>\n <p>\n  And that essentially means a receiver can handle these many messages in under two minutes.\n </p>\n <p>\n  Thankfully, using the 16 values window mentioned above, we can shave off four bits if done properly.\n </p>\n <h2>\n  Encryption Key\n </h2>\n <p>\n  The\n  <a href=\"https://securewww.esat.kuleuven.be/cosic/publications/article-1045.pdf\" rel=\"noreferrer\">\n   A Practical Attack on KeeLoq\n  </a>\n  article describes different vulnerabilities of the KeeLoq encryption espclifically as used for vehicle remote controls and immobilizers. This is a good read if you're interested retrieving the key using cryptanalysis, and it demonstrates several potentially feasible methods. It also reviews related works for your convenience.\n </p>\n <p>\n  I'll iterate possible approaches:\n </p>\n <h3>\n  Reading the EEPROM (again)\n </h3>\n <p>\n  if you've done that, you could just as easily get the key itself together with the\n  <em>\n   Sync Counter\n  </em>\n  .\n </p>\n <h3>\n  Cryptanalysis\n </h3>\n <p>\n  Cryptographically retrieving the key, as described in detail at the above article and it's references.\n </p>\n <h3>\n  Using the \"Learning\" feature\n </h3>\n <p>\n  According the datasheet, the chip has a feature called \"Learning\" to communicate / share the key which might use the SYNC value OP has mentioned.\n </p>\n <p>\n  There are three types of \"Learning\":\n </p>\n <ol>\n  <li>\n   <p>\n    Simple Learning - this basically means all Encoder (remote controls) and Decoders (cars) by the same manufacturer share the same key, and are associated using the Serial Number. This is useful because it makes bruteforcing slightly more beneficial because a successful retrieval will provide keys for all of that manufacturer's cars. It also makes it easy to parallelize using multiple vehicles.\n   </p>\n  </li>\n  <li>\n   <p>\n    Normal Learning\n   </p>\n   <blockquote>\n    <p>\n     The receiver uses information transmitted\n  during normal operation to derive the crypt\n  key and decrypt the received code word’s\n  encrypted portion\n    </p>\n   </blockquote>\n  </li>\n  <li>\n   <p>\n    Secure Learning\n   </p>\n   <blockquote>\n    <p>\n     The transmitter is activated through a special\n  button combination to transmit a stored 60-bit\n  seed value used to generate the transmitter’s\n  crypt key. The receiver uses this seed value\n  to derive the same crypt key and decrypt the\n  received code word’s encrypted portion.\n    </p>\n   </blockquote>\n  </li>\n </ol>\n <p>\n  It is possible to use the \"Secure Learning\" feature, with the\n  <em>\n   manufacturer key\n  </em>\n  to calculate the key. For that, you'll need to reverse engineer the Key generation algorithm (stored in the receiver/car) and fetch the manufacturer key from there.\n </p>\n <p>\n  Normal Learning and Secure Learning are only mentioned, but aren't described in the datasheet in depth which makes it harder to bypass those without manual analysis.\n </p>\n <p>\n  Although the implementation/design details of \"Secure Learning\" are not described in the datasheet, a patent filing titled \"\n  <a href=\"https://www.google.ch/patents/US5686904\" rel=\"noreferrer\">\n   Secure self learning system\n  </a>\n  \" (USA Patent US 5686904 A) is mentioned on page 29.\n </p>\n <p>\n  The patent includes the following relevant yet vague paragraph:\n </p>\n <blockquote>\n  <p>\n   The key generation algorithm that is used in key generation unit 42 during the secure learning operation is usually a non-linear algorithm. This algorithm accepts as input the manufacturer’s master key 40 (not known) and key generation information. The key generation information can consist of the encoder serial number 24 or the seed 20 or both.\n  This information is transferred from the encoder in a learning operation to the decoder.\n  The decoder 12 uses the key generation algorithm to\n  generate a key 44 that is used to decode a normal code\n  hopping transmission. The security of this mechanism pertains to the fact that the relationship between the transmitted\n  seed and the decoding key is not lmown, rendering any kind\n  of interception of the transmission useless. The non-linear\n  key generation function also makes it impossible to establish\n  any relationship between the key and the key generation\n  information, making it impossible for a possible imposter to\n  copy an illegitimate encoder. The key 22, serial number 24\n  and randomly generated seed 20 of an encoder 10 are loaded\n  during the manufacturing process. The manufacturer generates the key using the seed, serial number, manufacturers\n  master key and key generation algorithm. The key genera\n  tion algorithm is not made known publicly. Because the seed\n  is a random number, the possibility of manufacturing two\n  encoders with the same keys are very slim. Considering the\n  fact that the serial number is also used in this process, it is\n  highly improbable.\n  </p>\n </blockquote>\n</div>\n</body></html>",
            "votes": "9",
            "user": "NirIzr",
            "time": "Oct 11, 2016 at 21:01",
            "is_accepted": false,
            "comments": []
        }
    ]
}