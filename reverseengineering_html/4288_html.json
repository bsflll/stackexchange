{
    "title": "How to deal with this “lea” instructions generated by objdump?",
    "link": "https://reverseengineering.stackexchange.com/questions/4288/how-to-deal-with-this-lea-instructions-generated-by-objdump",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  So basically I am using\n  <code>\n   objdump\n  </code>\n  to disassemble a binary from `GNU Coreutils\", on 32 bit Linux x86.\n </p>\n <p>\n  In the disassembled code, I found one \"broken\" instruction like this:\n </p>\n <pre><code> 804bb49:   8d 04 ed 00 00 00 00    lea    0x0(,%ebp,8),%eax\n</code></pre>\n <p>\n  I asked a related question about a very similar instruction\n  <a href=\"https://reverseengineering.stackexchange.com/questions/4285/how-to-deal-with-this-error-instructions-generated-by-objdump\">\n   here\n  </a>\n  , in that question, I think it should be a jump table related instruction, but how about this one ? I am quite confused..\n </p>\n <p>\n  Could anyone give me some help?\n </p>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 2,
    "views": "2k",
    "tags": [
        "disassembly",
        "assembly",
        "objdump"
    ],
    "user": "lllllllllllll",
    "time": "Apr 28, 2017 at 12:54",
    "comments": [
        {
            "user": "yaspr",
            "text": "<html><body><span class=\"comment-copy\">\n You should update your question & be more precise. I cannot seem to understand what you mean by \"broken\" from the code you provided.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I don't know what makes you think this instruction is \"broken\" - the fact that there is a comma right after a bracket, without a parameter in between? In this case, the disassembler just doesn't show the parameter because it's \"zero\" (more precisely, it specifies \"no register\" where \"any processor register\" would be allowed).\n </p>\n <p>\n  What happens here is: when addressing memory locations, the processor has a mode where it adresses\n </p>\n <ul>\n  <li>\n   a base offset\n  </li>\n  <li>\n   plus the content of one processor register\n  </li>\n  <li>\n   plus the content of another processor register, multiplied by an integer that can be 1,2,4 or 8\n  </li>\n </ul>\n <p>\n  This calculation is quite fast, as it's done in special hardware in the address bus subsystem.\n </p>\n <p>\n  The\n  <code>\n   lea\n  </code>\n  (load effective address) instruction is a special kind of RAM access -- it calculates the address of the operand, but then, it moves the\n  <em>\n   address\n  </em>\n  , not the data at that address, into the destination register.\n </p>\n <p>\n  So your 'broken' instruction moves a base offset of 0, plus \"no\" first register, plus 8 times the content of ebp, into eax. The same could have been done by moving ebp to eax and multiplying by 8, or moving and shifting left by 3 bits, but the\n  <code>\n   lea\n  </code>\n  instruction is probably a bit faster (because, as i said, it's done in specialized address bus hardware), so the compiler used that one to save a few cycles. Nothing is broken here.\n </p>\n <p>\n  You might want to take a look at a i386 assembler reference when disassembling, the indirect adressing is quite well explained in the\n  <a href=\"https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/060-i386_Addressing_Modes_and_Assembler_Instructions/i386_intructions.html\" rel=\"noreferrer\">\n   OS X Assembler reference\n  </a>\n  , scroll down to \"Indirect Memory Operands\".\n </p>\n</div>\n</body></html>",
            "votes": "5",
            "user": "Guntram Blohm",
            "time": "May 8, 2014 at 8:38",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  what does broken mean\n </p>\n <p>\n  the instruction in either this post or in your earlier post do not seem to be broken\n </p>\n <p>\n  if you are confused with AT&T syntax then you can ask objdump to disassemble in intel syntax\n </p>\n <p>\n  a better explanation of broken can get a better answer\n </p>\n <pre><code>root@box:/home/dsl/gcctests/test# cat testjt.c \nvoid naked (void)\n{\n        asm( \".globl _naked\n\");\n        asm( \"_naked:\n\");\n        asm( \"jmp *0x80509e4(,%eax,4)\");\n        asm( \"lea 0x0(,%ebp,8),%eax\");\n        asm( \"ret\");\n}\nint main (void)\n{\n        naked();\n        return 0;\n}\n\n\nroot@box:/home/dsl/gcctests/test# objdump -t ./testjt | grep _naked\n08048357 g       .text  00000000              _naked\n\n\nroot@box:/home/dsl/gcctests/test# objdump -d --disassembler-option=intel  ./testjt | grep -A 2 _naked\n\n\n08048357 <_naked>:\n 8048357:       ff 24 85 e4 09 05 08    jmp    DWORD PTR [eax*4+134547940]\n 804835e:       8d 04 ed 00 00 00 00    lea    eax,[ebp*8]\n\n\nroot@box:/home/dsl/gcctests/test#  \n</code></pre>\n</div>\n</body></html>",
            "votes": "5",
            "user": "blabb",
            "time": "May 8, 2014 at 9:04",
            "is_accepted": false,
            "comments": []
        }
    ]
}