{
    "title": "Can AI be used to write better decompilers/disassemblers? [closed]",
    "link": "https://reverseengineering.stackexchange.com/questions/18866/can-ai-be-used-to-write-better-decompilers-disassemblers",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <div>\n  <aside class=\"s-notice s-notice__info post-notice js-post-notice mb16\" role=\"status\">\n   <div class=\"d-flex fd-column fw-nowrap\">\n    <div class=\"d-flex fw-nowrap\">\n     <div class=\"flex--item wmn0 fl1 lh-lg\">\n      <div class=\"flex--item fl1 lh-lg\">\n       <div>\n        <b>\n         Closed\n        </b>\n        . This question is\n        <a href=\"/help/closed-questions\">\n         opinion-based\n        </a>\n        . It is not currently accepting answers.\n       </div>\n      </div>\n     </div>\n    </div>\n   </div>\n   <hr class=\"my12 outline-none baw0 bb bc-blue-400\"/>\n   <div class=\"fw-nowrap fc-black-500\">\n    <div class=\"d-flex fd-column lh-md\">\n     <div class=\"mb0 d-flex\">\n      <div class=\"flex--item mr8\">\n       <svg aria-hidden=\"true\" class=\"svg-icon iconLightbulb\" height=\"18\" viewbox=\"0 0 18 18\" width=\"18\">\n        <path d=\"M15 6.38A6.5 6.5 0 0 0 7.78.04h-.02A6.5 6.5 0 0 0 2.05 5.6a6.3 6.3 0 0 0 2.39 5.75c.49.39.76.93.76 1.5v.24c0 1.07.89 1.9 1.92 1.9h2.75c1.04 0 1.92-.83 1.92-1.9v-.2c0-.6.26-1.15.7-1.48A6.3 6.3 0 0 0 15 6.37M4.03 5.85A4.5 4.5 0 0 1 8 2.02a4.5 4.5 0 0 1 5 4.36 4.3 4.3 0 0 1-1.72 3.44c-.98.74-1.5 1.9-1.5 3.08v.1H7.2v-.14c0-1.23-.6-2.34-1.53-3.07a4.3 4.3 0 0 1-1.64-3.94M10 18a1 1 0 0 0 0-2H7a1 1 0 1 0 0 2z\">\n        </path>\n       </svg>\n      </div>\n      <p>\n       <b>\n        Want to improve this question?\n       </b>\n       Update the question so it can be answered with facts and citations by\n       <a href=\"/posts/18866/edit\">\n        editing this post\n       </a>\n       .\n      </p>\n     </div>\n     <div class=\"mb0 mt6 d-flex\">\n      <p class=\"ml24 pl2\">\n       Closed\n       <span class=\"relativetime\" title=\"2018-07-26 11:06:40Z\">\n        6 years ago\n       </span>\n       .\n      </p>\n     </div>\n     <div class=\"ml24 pl2\">\n     </div>\n    </div>\n   </div>\n   <div class=\"mt24 d-flex gsx gs8\">\n    <a class=\"s-btn s-btn__outlined flex--item js-post-notice-edit-post\" href=\"/posts/18866/edit\">\n     Improve this question\n    </a>\n   </div>\n  </aside>\n </div>\n <p>\n  In the past for years I used some disassembler and tried some decompiler, nowadays there's so much talking and stuff about deep learning and AI, I wonder if some can be used with those tasks (given some human training) and if there's some tool using it already.\n </p>\n</div>\n</body></html>",
    "votes": "7",
    "answers": 4,
    "views": "7k",
    "tags": [
        "disassemblers",
        "decompiler"
    ],
    "user": "Alex",
    "time": "6 years ago",
    "comments": [
        {
            "user": "Elian Kamal",
            "text": "<html><body><span class=\"comment-copy\">\n I like this question and actually thought about it lately. While it is somewhat relevant to RE, I think\n <a href=\"https://ai.stackexchange.com/\">\n  ai.stackexchange.com\n </a>\n may be more relevant since this issue is more about AI target definition and training than the actual process it does to disassembly/de-compile a program.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "<html><body><span class=\"comment-copy\">\n The mechanical process of disassembling – purely decoding instructions – stays the same; there is nothing there that an AI could do better. AI could help in determining\n <i>\n  what\n </i>\n to disassemble – i.e., the old problem of\n <a href=\"https://reverseengineering.stackexchange.com/q/15329/2959\">\n  differentiating between code and data\n </a>\n , and then only for paths that are not clearly either a part, or not a part of executable code. Both linear-sweep and recursive disassembly can mark huge swaths of 'actual code' and '(likely) not code at all', but the gray areas in between are where the problems lie. ..(ctd)\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "<html><body><span class=\"comment-copy\">\n .. I am not convinced an AI would be able to tell us more than a pure mechanical process. I.e., the best\n <i>\n  possible\n </i>\n disassembler should be able to \"run\" an entire program and inspect all possible code pathways, which is a pure mechanical exercise. The only reason one does not do that (yet) is because it's fundamentally an NP problem. Also, if all code was written 100% correct, you'd never experience a crash.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Alex",
            "text": "<html><body><span class=\"comment-copy\">\n @usr2564301 I think observing disassembled code there's a lot of pattern work, there are nice tools nowadays to graph where a function branch, but I think an AI would be helpful guessing/suggesting what a function does, what kind of data you're inspecting\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  First, you cannot answer to this question without having to define what you mean by\n  <em>\n   AI\n  </em>\n  ... Because this is probably the worst name for a domain in computer science. Where people think about \"programs mimicking human reasoning\", the reality is more about \"automated heuristics to recognize patterns in tons of samples\"...\n </p>\n <p>\n  So, I will take the more accurate definition of AI, it is to say that I assume that an AI program can recognize patterns that might escape to the understanding of human being and that they can self-train to achieve this.\n </p>\n <p>\n  Now, speaking about disassembly, the core problems are definitely not about recognizing patterns but rebuilding all the execution paths that one can find in a binary. So, an AI algorithm is simply not interesting to choose if an execution path is more valuable than another because they are all interesting (as the disassembler need to exhaustively find\n  <strong>\n   all the paths\n  </strong>\n  ).\n </p>\n <p>\n  Finally, speaking about decompilation, this is the field where you may want to use AI to recognize some patterns such as:\n </p>\n <ul>\n  <li>\n   What compiler or what language has been used;\n  </li>\n  <li>\n   Guess if this code is similar to another sample that is in your data-base of malware;\n  </li>\n  <li>\n   Give a first guess of the architecture of the software (complex data-structures (arrays, records), functions, objects, modules, packages, ...) even after an obfuscation pass;\n  </li>\n  <li>\n   Recognize the most common functions and what they may be used for;\n  </li>\n  <li>\n   ... probably many other guesses that can be automatized ...\n  </li>\n </ul>\n <p>\n  But, the point here is that we are just all stuck at the disassembly problem (which is a quite strong problem!!!) and to go further we first need to have a reasonably reliable method/algorithm/tool in order to reach the next level (decompilation).\n </p>\n <p>\n  Though, a few people have worked in this direction, you may look at (this list is far from being complete, I search only 10mn on Google):\n </p>\n <ul>\n  <li>\n   <a href=\"http://pages.cs.wisc.edu/~jerryzhu/pub/nips07-abs.pdf\" rel=\"noreferrer\">\n    Machine Learning-Assisted Binary Code Analysis\n   </a>\n   , by Nathan Rosenblum, Xiaojin Zhu, Barton Miller and Karen Hunt, NIPS 2007.\n  </li>\n  <li>\n   <a href=\"https://www.blackhat.com/docs/us-15/materials/us-15-Davis-Deep-Learning-On-Disassembly.pdf\" rel=\"noreferrer\">\n    Deep Learning on Disassembly Data\n   </a>\n   (\n   <a href=\"https://www.youtube.com/watch?v=LQh8dktQReI\" rel=\"noreferrer\">\n    Full talk\n   </a>\n   ), by Andrew Davis and Matt Wolff, BlackHat 2015.\n  </li>\n  <li>\n   <a href=\"http://www.cs.unm.edu/~eschulte/data/katz-saner-2018-preprint.pdf\" rel=\"noreferrer\">\n    Using Recurrent Neural Networks for Decompilation\n   </a>\n   , by Deborah S. Katz, Jason Ruchti and Eric Schulte, SANER 2018\n  </li>\n  <li>\n   <a href=\"http://storm-country.com/blog/evo-deco\" rel=\"noreferrer\">\n    Evolving a Decompiler\n   </a>\n   , by Matt Noonan, 2018;\n  </li>\n </ul>\n</div>\n</body></html>",
            "votes": "8",
            "user": "perror",
            "time": "Jul 23, 2018 at 8:48",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <em>\n   Although I initially voted to close this question as primarily opinion-based, given both answers side with the same general answer (\"\n   <strong>\n    No!\n   </strong>\n   \") I'll answer as well. I just love being the devil's advocate.\n  </em>\n </p>\n <h2>\n  A general stance\n </h2>\n <p>\n  This question is very difficult to answer. As someone who came from the security field and had worked on quite a few machine learning related projects in the past, I know it's really hard to make an honest projection on whether it's possible to solve problems in our domain using machine learning. Often times ML/AI research is a lot about trial and error.\n </p>\n <h2>\n  AI disassembler\n </h2>\n <p>\n  Although the operation of disassembling a sequence of bytes is quite straight-forward, there are quite a few problems that are solved nowadays with somewhat clever heuristics. Those problems include:\n </p>\n <ol>\n  <li>\n   Identifying function boundaries.\n  </li>\n  <li>\n   Classifying code VS data.\n  </li>\n  <li>\n   Inferring structures and higher-level constructs from assembly.\n  </li>\n </ol>\n <p>\n  and more.\n </p>\n <p>\n  As time went on, some of those problems have been improved\n  <em>\n   mostly\n  </em>\n  by creating and improving manually written heuristics and logical guidelines for disassemblers. Mostly based on human experience and incorrect results seen in the past.\n </p>\n <p>\n  However, it is still quite common to see errors in fully automated disassemblers and as evidence to that we can see the focus given by disassemblers to the reverse engineer to manually correct and adjust the automated analyses. One might argue it's possible that ML/AI approaches could create similar or better heuristics and more complex / accurate rules.\n </p>\n <h2>\n  AI decompiler\n </h2>\n <p>\n  Decompilation is generally seen as more difficult to accomplish even given perfect disassembly. It relies heavily on inferring higher-level constructs such as structures, objects, classes and inheritance. It requires more accurate data-type recognition and more demanding understanding and reasoning of abstract objects. Even humans find those harder to manually recognize, not to mention using automated rules and heuristics. Therefore, decompilation may prove a more fertile ground for such improvements.\n </p>\n <h2>\n  A word about the buzzword\n </h2>\n <p>\n  Nowadays, when startups rise and fall based on using the\n  <em>\n   right\n  </em>\n  buzzword in their marketing it is easy to get drawn into using such buzzwords instead of accurate descriptions and forcing the solution on the problem instead of finding the best solution for the problem at hand.\n </p>\n</div>\n</body></html>",
            "votes": "4",
            "user": "NirIzr",
            "time": "Jul 23, 2018 at 20:56",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <strong>\n   No!\n  </strong>\n </p>\n <p>\n  Reason is that AI is dumb, much more than you think it is. All it can do is matching patterns to predetermine output. And here are two main problem to use it to decompile code or to recreate \"readable\" source code:\n </p>\n <ul>\n  <li>\n   <p>\n    This matching isn't perfect. For example if you have\n    <code>\n     mov, eax 0x10\n    </code>\n    it could be interpreted as\n    <code>\n     i=8;\n    </code>\n    as AI didn't have this particulate training set, but it has\n    <code>\n     mov, eax 0x8\n    </code>\n    .\n   </p>\n  </li>\n  <li>\n   <p>\n    Other big problem is what to feed AI. In translation tools are used sentences, in image recognition are used features from whole images. What to use in code? Few op codes? How many? where to start?\n   </p>\n  </li>\n </ul>\n <p>\n  In conclusion AI (at this stage and near future) is mostly useless for this purpose.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "perror",
            "time": "Jul 23, 2018 at 7:38",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I want to say yes, but I have to say\n  <strong>\n   NO\n  </strong>\n  . The thing is that computers grab our programs that we write and optimize them in a way that often will make little or no sense to humans. You'll see things being multiplied and arrays being worked with that you can understand what is happening , but it is very unhuman to work with data in this kind of way.\n  <strong>\n   Computers and humans think very differently.\n  </strong>\n </p>\n <p>\n  I think could be possible for an AI to do the following:\n </p>\n <ul>\n  <li>\n   Grab the assembly and convert and either make it clearer for\nhumans to understand.\n  </li>\n  <li>\n   Make a near useable form of assembly. (Maybe.... Because we would be keeping the computer's understanding of the relative data intact. )\n  </li>\n </ul>\n <p>\n  Take this simple example:\n </p>\n <pre><code>MOV v7, DWORD PTR [v7 + 0x8]\n</code></pre>\n <p>\n  would convert to\n </p>\n <pre><code>v7 = *(_DWORD *)(v7 + 8);\n</code></pre>\n <p>\n  then to\n </p>\n <pre><code>v7 = *(v7 + 8)\n</code></pre>\n <p>\n  And this might be really something completely different in source.\n </p>\n <p>\n  where as you might see something like\n </p>\n <pre><code>mov eax, dword ptr ds: [ESI*deadbeef+0b0] \n</code></pre>\n <p>\n  and the computer will think\n </p>\n <pre><code>int a = somefoovar[v5].someint\n</code></pre>\n <p>\n  or\n </p>\n <pre><code>int a = 1234;\n</code></pre>\n <p>\n  Both are kind of correct... If that array doesn't have changing data in it.\n </p>\n <p>\n  but a computer might look at this as a single variable, when it could be something temporary. Also I have noticed that in my own decompilation work, that you'll wind up with a lot more static variables that are when you originally start.\n </p>\n <p>\n  I think some other problems might be that the program might not ever hit certain parts of a function and might not understand all event paths.\n </p>\n <p>\n  Personally, I would like to see AI what AI can come up with . Maybe it would be nice to have a pseudo translator of code. But I know that I will have to clean up after it and correct it's understandings.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "LUser",
            "time": "Jul 25, 2018 at 7:52",
            "is_accepted": false,
            "comments": []
        }
    ]
}