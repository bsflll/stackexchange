{
    "title": "UC_ERR_WRITE_UNMAPPED when emulation starts on binary",
    "link": "https://reverseengineering.stackexchange.com/questions/30640/uc-err-write-unmapped-when-emulation-starts-on-binary",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Whenever I try to emulate my obfuscated driver it fails at\n  <code>\n   uc_emu_start\n  </code>\n  with UC_ERR_WRITE_UNMAPPED. I get all success return codes on:\n  <code>\n   uc_mem_map\n  </code>\n  and\n  <code>\n   uc_mem_write\n  </code>\n  but when I call\n  <code>\n   uc_emu_start\n  </code>\n  ; I get the UC_ERR_WRITE_UNMAPPED error. So, I added a hook on the error code to see what address it was writing to and I found that it was:\n  <code>\n   0xfffffffffffffff8\n  </code>\n  . I don't understand why it is writing to this address because I put\n  <code>\n   0x1000\n  </code>\n  as my base address (\n  <code>\n   std::uint64_t BASE_ADDRESS = 0x1000;\n  </code>\n  ) which is then used at\n  <code>\n   uc_emu_start\n  </code>\n  . Any help would be appreciated.\n  <a href=\"https://i.sstatic.net/T0gH9.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/T0gH9.png\"/>\n  </a>\n </p>\n <pre><code>// EMU.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n#include <unicorn.h>\n#include \"capstone/capstone.h\"\n#include <iostream>\n#include <list>\n#include <queue>\n#include <iomanip>\n#include \"PE.h\"\n#include \"BasicBlock.h\"\n#include \"Optimizations.h\"\n#include \"CCapstoneHelper.h\"\nstatic bool hook_mem_invalid(uc_engine* uc, uc_mem_type type, uint64_t address,\n    int size, int64_t value, void* user_data)\n{\n    switch (type) {\n    default:\n        // return false to indicate we want to stop emulation\n        return false;\n    case UC_MEM_WRITE_UNMAPPED:\n        printf(\">>> Missing memory is being WRITE at 0x%\" PRIx64\n            \", data size = %u, data value = 0x%\" PRIx64 \"\n\",\n            address, size, value);\n        // map this memory in with 2MB in size\n        uc_mem_map(uc, 0xaaaa0000, 2 * 1024 * 1024, UC_PROT_ALL);\n        // return true to indicate we want to continue\n        return true;\n    }\n}\nint main()\n{\n    try {\n        // UNICORN\n        uc_engine* uc;\n       uc_err err;\n\n        // CAPSTONE\n        csh handle{};\n        cs_insn* insn;\n        //size_t count; \n        std::queue<uint64_t> Q;\n        std::map<uint64_t, bool> seen;\n        std::uint64_t BASE_ADDRESS = 0x1000;\n\n        \n#define MEGABYTES_TO_MAP 15\n        \n        std::cout << \"[+] Starting emulation...\" << std::endl;\n        if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle) != CS_ERR_OK) {\n            throw std::runtime_error(\"cs_open failed\");\n        }\n\n        if (uc_open(UC_ARCH_X86, UC_MODE_64, &uc) != UC_ERR_OK) {\n            throw std::runtime_error(\"uc_open failed\");\n        }\n       \n        if (uc_mem_map(uc, BASE_ADDRESS, 2 * 1024 * 1024, UC_PROT_ALL) != UC_ERR_OK) {\n            throw std::runtime_error(\"uc_mem_map failed\");\n        }\n\n\n\n\n        cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);\n\n       \n        // get pointer to file from Init()\n        insn = cs_malloc(handle);\n        std::cout << \"[+] Finding driver entry point...\" << std::endl;\n       PE::CPe pe = PE::CPe::CPe(\"C:\\\\Program Files (x86)\\\\Driver\\\\Driver.sys\");\n\n   \n       std::cout << \"[+] Found: \" << std::hex << pe.get_entry_point_address_relative_to_mapped_file() << std::endl;\n\n       std::cout << \"[+] Starting emulation...\" << std::endl;\n       BasicBlock::CBasicBlock block_buffer{};\n       BasicBlock::_basic_block basic_block{};\n       basic_block.start_address = pe.get_entry_point_address_relative_to_mapped_file();\n    //   BASE_ADDRESS += pe.get_entry_point_file_offset();\n        const std::uint8_t* addr = (std::uint8_t*) basic_block.start_address;\n      \n       // we are at entry point. Start emulation until we reach end of basic block?\n       // At entrypoint, set start of basic block to entry point address.\n       // Emulate until we reach a JUMP instruction\n        std::cout << \"[+] Removing anti-disassembly...\" << std::endl;\n        Optimizations::COptimizations optimizations;\n        std::uint8_t anti_d_pattern[] = {0xEB, 0xFF, 0x64, 0x24, 0x08};\n        std::uint64_t num_of_bytes_fixed = optimizations.remove_antidisassembly(anti_d_pattern, sizeof(anti_d_pattern), pe);\n       \n        uint64_t target = 0;\n       size_t code_size = 0x1000;\n       \n       CapstoneHelper::CCapstoneHelper capstone_helper_obj;\n\n\n       uc_hook hook;\n       err = uc_hook_add(uc, &hook, UC_HOOK_MEM_WRITE_UNMAPPED, hook_mem_invalid, NULL, 1, 0);\n      \n       while (true) {\n \n           std::uint64_t prev_base_address = BASE_ADDRESS;\n          while (cs_disasm_iter(handle, &addr, &code_size, &BASE_ADDRESS, insn)) {\n               if (capstone_helper_obj.is_cs_cflow_ins(insn)) {\n                   basic_block.end_address = (std::uint64_t)addr;\n                   break;\n               }\n               \n\n           }\n\n           \n           std::uint32_t error;\n           // write code and then some into memory\n           //uc_mem_map(uc, prev_base_address, MEGABYTES_TO_MAP * 1024 * 1024, UC_PROT_ALL);\n          // if (uc_mem_map(uc, BASE_ADDRESS, MEGABYTES_TO_MAP * 1024 * 1024, UC_PROT_ALL) != UC_ERR_OK) {\n          \n               err = uc_mem_write(uc, prev_base_address, reinterpret_cast<void*>(basic_block.start_address), (basic_block.end_address - basic_block.start_address));\n               if (err != UC_ERR_OK) {\n                  throw std::runtime_error(\"uc_mem_write failed\");\n              }\n            \n              \n            // resolve file offset from base_address;\n              \n\n               err = uc_emu_start(uc, prev_base_address, prev_base_address + (basic_block.end_address - basic_block.start_address) , 0, 0);\n               if (err != UC_ERR_OK) {\n                   throw std::runtime_error(\"uc_emu_start failed\");\n               }\n\n\n\n               /* TODO:\n               1. Write anti-disassembly remover because capstone won't properly disassemble.\n               Anti disassembly byte string: EB FF 64 24 08 (Removing EB byte results in \" jmp    QWORD PTR [rsp+0x8]\"\n               Use file pointer to do operations before we disassemble with capstone.\n               2. Add check for control flow instructions (look at PBA)\n               */\n\n          \n       }\n\n        \n       \n\n\n\n\n\n\n\n\n\n\n        \n        uc_close(uc);\n        cs_close(&handle);\n        \n    }\n    catch (std::exception& e) {\n        std::cout << \"Error: \" << e.what();\n        getchar();\n        std::abort();\n    }\n    \n        return 0;\n}\n</code></pre>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 0,
    "views": "359",
    "tags": [
        "emulation",
        "capstone"
    ],
    "user": "Ayyware",
    "time": "Jul 15, 2022 at 23:10",
    "comments": [
        {
            "user": "Mega Tonnage",
            "text": "<html><body><span class=\"comment-copy\">\n Deleted my answer, too early in the morning and I confused hex and binary\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}