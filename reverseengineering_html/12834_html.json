{
    "title": "Randomly picking up a x86 register for an instruction",
    "link": "https://reverseengineering.stackexchange.com/questions/12834/randomly-picking-up-a-x86-register-for-an-instruction",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I came around a piece of malware which i am analyzing and have found that it uses some kind of math to randomly selecting a register for a specific instruction\n </p>\n <p>\n  Which i don't understand how this operation is calculated depend on what?\n </p>\n <p>\n  Here is an example of what i mean\n </p>\n <p>\n  let's say that i wanted to randomly pick up a register for the instruction\n </p>\n <pre><code>ADD DWORD PTR DS:[0],EAX\n</code></pre>\n <p>\n  We know the opcode for this instruction is 01\n  <strong>\n   05\n  </strong>\n  00 00 00 00\n </p>\n <p>\n  The bold number represents the register for this instruction\n </p>\n <p>\n  05 == EAX\n0D == ECX\n </p>\n <p>\n  To better explain this here is the instruction with all the registers\n </p>\n <pre><code>0041580B    0105 00000000   ADD DWORD PTR DS:[0],EAX\n00415811    010D 00000000   ADD DWORD PTR DS:[0],ECX\n00415817    0115 00000000   ADD DWORD PTR DS:[0],EDX\n0041581D    011D 00000000   ADD DWORD PTR DS:[0],EBX\n00415823    0125 00000000   ADD DWORD PTR DS:[0],ESP\n00415829    012D 00000000   ADD DWORD PTR DS:[0],EBP\n0041582F    0135 00000000   ADD DWORD PTR DS:[0],ESI\n00415835    013D 00000000   ADD DWORD PTR DS:[0],EDI\n</code></pre>\n <p>\n  The malware uses a register index starting from 0 (EAX) till 7 (EDI)\n </p>\n <p>\n  The number is get SHLed first with the number 3 then it is ORed with 5 to get the right register opcode. So my question is how the author came to the conclusion of that?\n </p>\n <p>\n  I would say that SHL REG,3 equals REG*8 that is the number of max registers? but why do we need to OR it with 05? is it because the starting opcode of this instruction is 05?\n </p>\n <p>\n  Does anybody have a better explanation for this? or any hint words for a better comprehend?\n </p>\n</div>\n</body></html>",
    "votes": "11",
    "answers": 1,
    "views": "890",
    "tags": [
        "assembly",
        "x86",
        "malware",
        "register"
    ],
    "user": "RCECoder",
    "time": "Dec 30, 2016 at 20:01",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  To better understand this, you need to study instruction encoding formats i.e. x86 for this question.\n </p>\n <p>\n  An x86 instruction looks like this\n </p>\n <pre><code>+----------------------+--------+--------+-----+--------------+-----------+\n| Instruction prefixes | Opcode | ModR/M | SIB | Displacement | Immediate |\n+----------------------+--------+--------+-----+--------------+-----------+\n|          0-4         |   1-3  |   0-1  | 0-1 |      0-4     |    0-4    |\n+----------------------+--------+--------+-----+--------------+-----------+\n</code></pre>\n <p>\n  The numbers on the second row indicates the length in bytes of the corresponding part.\n </p>\n <p>\n  For the instruction,\n </p>\n <pre><code>010D 00000000   ADD DWORD PTR DS:[0],ECX\n</code></pre>\n <p>\n  there is no instruction prefix.\nThe opcode for\n  <code>\n   ADD\n  </code>\n  is\n  <code>\n   01\n  </code>\n  (\n  <a href=\"http://x86.renejeschke.de/html/file_module_x86_id_5.html\" rel=\"nofollow noreferrer\">\n   Check here\n  </a>\n  )\n </p>\n <p>\n  The second byte of the instruction i.e\n  <code>\n   ModR/M\n  </code>\n  is\n  <code>\n   0D\n  </code>\n  .\nThe\n  <code>\n   ModR/M\n  </code>\n  byte provides addressing information about the instruction. It specifies whether an operand is in a register or in memory; if it is in memory, then fields within the byte specify the addressing mode to be used.\n </p>\n <p>\n  The\n  <code>\n   ModR/M\n  </code>\n  byte can be broken down into\n </p>\n <pre><code>+-----+------------+-----+\n| Mod | Reg/Opcode | R/M |\n+-----+------------+-----+\n|  2  |      3     |  3  |\n+-----+------------+-----+\n</code></pre>\n <p>\n  Here the numbers on the second row indicates the length in bits of the corresponding parts.\n </p>\n <p>\n  The\n  <code>\n   Mod\n  </code>\n  field (2 bits) combines with the\n  <code>\n   R/M\n  </code>\n  field (3 bits) to form 32 possible values 8 registers and 24 addressing modes.\n </p>\n <p>\n  The\n  <code>\n   Reg/Opcode\n  </code>\n  field (3 bits) specifies either a register number or three more bits of opcode information; the\n  <code>\n   r/m\n  </code>\n  field (3 bits) can specify a register as the location of an operand, or it can form part of the addressing-mode encoding in combination with the\n  <code>\n   Mod\n  </code>\n  field.\n </p>\n <p>\n  Now, convert the\n  <code>\n   ModR/M\n  </code>\n  i.e\n  <code>\n   0D\n  </code>\n  to binary. You would get.\n </p>\n <pre><code>+-----+------------+-----+\n| Mod | Reg/Opcode | R/M |\n+-----+------------+-----+\n|  00 |     001    | 101 |\n+-----+------------+-----+\n</code></pre>\n <p>\n  The\n  <code>\n   Mod\n  </code>\n  and\n  <code>\n   R/M\n  </code>\n  fields are\n  <code>\n   00\n  </code>\n  and\n  <code>\n   101\n  </code>\n  respectively. This indicates displacement only addressing mode. See the table below.\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/mGqsS.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/mGqsS.png\"/>\n  </a>\n </p>\n <p>\n  <strong>\n   For all the instructions this mode of addressing is used, hence the reason for\n   <code>\n    OR\n   </code>\n   ing with 5 (in binary 101) to set that particular bit pattern.\n  </strong>\n </p>\n <p>\n  Coming to the\n  <code>\n   Reg/Opcode\n  </code>\n  field, this indicates a register.\n  \n\n  <code>\n   001\n  </code>\n  is the register index for\n  <code>\n   ECX\n  </code>\n  .\n </p>\n <p>\n  For the first instruction i.e\n  \n\n  <code>\n   0105 00000000   ADD DWORD PTR DS:[0],EAX\n  </code>\n  \n\n  this field is\n  <code>\n   000\n  </code>\n  standing for\n  <code>\n   EAX\n  </code>\n  . You can check by converting\n  <code>\n   05\n  </code>\n  to binary.\n </p>\n <p>\n  See more in the table below taken from\n  <a href=\"http://www.c-jump.com/CIS77/CPU/x86/X77_0060_mod_reg_r_m_byte.htm\" rel=\"nofollow noreferrer\">\n   here\n  </a>\n  .\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/Ljow1.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/Ljow1.png\"/>\n  </a>\n </p>\n <p>\n  <strong>\n   So basically the register value was\n   <code>\n    SHL\n   </code>\n   ed with 3 to move it to the correct position. The Reg/Opcode field is 3 bits from the right.\n  </strong>\n </p>\n <p>\n  Finally the last 4 bytes are\n  <code>\n   00000000\n  </code>\n  . This represents the displacement which is zero in this example.\n </p>\n</div>\n</body></html>",
            "votes": "18",
            "user": "0xec",
            "time": "Jun 12, 2016 at 18:49",
            "is_accepted": true,
            "comments": []
        }
    ]
}