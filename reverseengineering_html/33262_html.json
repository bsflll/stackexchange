{
    "title": "wzr register usage in main method on ARM",
    "link": "https://reverseengineering.stackexchange.com/questions/33262/wzr-register-usage-in-main-method-on-arm",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have this C code :\n </p>\n <pre class=\"lang-none prettyprint-override\"><code>\nint foo(){\n    int a = 1;\n    int b = 1;\n    return a + b;\n}\n\n\nint main() {\n    return 2;\n}\n</code></pre>\n <p>\n  After disassembling it shows:\n </p>\n <pre><code>foo():\n        sub     sp, sp, #16\n        mov     w8, #1\n        str     w8, [sp, #12]\n        str     w8, [sp, #8]\n        ldr     w8, [sp, #12]\n        ldr     w9, [sp, #8]\n        add     w0, w8, w9\n        add     sp, sp, #16\n        ret\n\nmain:\n        sub     sp, sp, #16\n        str     wzr, [sp, #12]\n        mov     w0, #2\n        add     sp, sp, #16\n        ret\n</code></pre>\n <p>\n  Why does\n  <code>\n   main\n  </code>\n  method use\n  <code>\n   wzr\n  </code>\n  register on this line\n  <code>\n   str     wzr, [sp, #12]\n  </code>\n  while\n  <code>\n   foo\n  </code>\n  method doesn't?\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "68",
    "tags": [
        "disassembly",
        "arm",
        "arm64"
    ],
    "user": "pacman",
    "time": "Oct 15, 2024 at 21:55",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'll take guess that you are using\n  <code>\n   clang\n  </code>\n  and running it without optimisations.\nNormally when looking at generated code without optimisations, there is lots of seeming superfluous code output and that's the simple answer\n </p>\n <p>\n  Here though, there is more going on.  This is clear to see if we change the source code a bit.\n </p>\n <pre><code>int main2() {\n    return 42;\n}\n\nint main() {\n    return 42;\n}\n</code></pre>\n <p>\n  Despite two, on the face of it, identical functions, we see different code output.\n </p>\n <pre><code>main2:\n    mov     w0, #42\n    ret\n\nmain:\n    sub     sp, sp, #16\n    str     wzr, [sp, #12]\n    mov     w0, #42\n    add     sp, sp, #16\n    ret\n</code></pre>\n <p>\n  This difference is also visible in clang's LLVM IR output, which is the precursor to the generated assembly code.\n </p>\n <pre><code>define dso_local i32 @main2() {\nentry:\n  ret i32 42\n}\n\ndefine dso_local i32 @main() {\nentry:\n  %retval = alloca i32, align 4\n  store i32 0, ptr %retval, align 4\n  ret i32 42\n}\n</code></pre>\n <p>\n  This difference is highly likely because\n  <code>\n   main\n  </code>\n  is a special function in\n  <code>\n   C\n  </code>\n  .\n </p>\n <p>\n  <a href=\"https://stackoverflow.com/a/207992/366486\">\n   This answer\n  </a>\n  on stackoverflow explains what makes\n  <code>\n   main\n  </code>\n  special.  Of particular interest is the fact that\n  <code>\n   main\n  </code>\n  doesn't need to have an explicit return statement and, in the absence of one, it is specified in the standard to return zero.\n </p>\n <p>\n  It is highly likely that what is seen in the LLVM IR and assembly language output above is part of\n  <code>\n   clang\n  </code>\n  's preparation to handle this case by setting up a local variable with value zero.\n </p>\n <p>\n  If you compiled with optimisations, the difference will disappear.\n </p>\n <hr/>\n <p>\n  Where this gets a little more unexpected is we look at 2 more variations -\n </p>\n <ul>\n  <li>\n   main explicitly returns 0\n  </li>\n  <li>\n   main implicitly returns 0\n  </li>\n </ul>\n <p>\n  Consistent with the above, in the first case,\n  <code>\n   clang\n  </code>\n  sets up the\n  <code>\n   %retval\n  </code>\n  variable but doesn't use it.\n </p>\n <p>\n  However, in the second case, and somewhat counter-intuitively, when the code is relying on the implicit behaviour\n  <code>\n   clang\n  </code>\n  skips setting up\n  <code>\n   %retval\n  </code>\n  completely and simply returns a zero directly.\n </p>\n <p>\n  First case -\n </p>\n <pre><code>// main explicitly returning 0\n\n// C\n\nint main() {\n    return 0;\n}\n\n// LLVM IR\n\ndefine dso_local i32 @main() {\nentry:\n  %retval = alloca i32, align 4\n  store i32 0, ptr %retval, align 4\n  ret i32 0\n}\n\n// AArch64\n\nmain:\n    sub     sp, sp, #16\n    mov     w0, wzr\n    str     wzr, [sp, #12]\n    add     sp, sp, #16\n    ret\n</code></pre>\n <p>\n  Second case -\n </p>\n <pre><code>// main implicitly returning 0\n\n// C\n\nint main() {\n}\n\n// LLVM IR\n\ndefine dso_local i32 @main() {\nentry:\n  ret i32 0\n}\n\n// AArch64\nmain:\n    mov     w0, wzr\n    ret\n</code></pre>\n <hr/>\n <p>\n  There are a couple of very similar questions on stackoverflow\n  <a href=\"https://stackoverflow.com/questions/69233253/why-does-main-have-retval-in-ll-file-llvm\">\n   here\n  </a>\n  and\n  <a href=\"https://stackoverflow.com/questions/59610063/why-does-llvm-allocate-a-redundant-variable/61566244\">\n   here\n  </a>\n </p>\n</div>\n</body></html>",
            "votes": "5",
            "user": "Ian Cook",
            "time": "Oct 20, 2024 at 21:55",
            "is_accepted": true,
            "comments": []
        }
    ]
}