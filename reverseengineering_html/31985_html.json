{
    "title": "How do I extract sprites and backgrounds from .BIN files? (dos game - 1988)",
    "link": "https://reverseengineering.stackexchange.com/questions/31985/how-do-i-extract-sprites-and-backgrounds-from-bin-files-dos-game-1988",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Does anyone know what tools should I use to extract the backgrounds and sprites of this very rare old game: Armorik the Viking?\n </p>\n <p>\n  The files are in .BIN format. No idea how to open them. I tried Game Extractor and QuickBMS tools but they could not read the files.\n </p>\n <p>\n  What type of BIN are these? The game is from 1988 and was released by InfoGrames.\n </p>\n <p>\n  This is the game:\n </p>\n <p>\n  <a href=\"https://archive.org/download/msdos_Armorik_the_Viking_-_The_Eight_Conquests_1988/Armorik_the_Viking_-_The_Eight_Conquests_1988.zip\" rel=\"nofollow noreferrer\">\n   https://archive.org/download/msdos_Armorik_the_Viking_-_The_Eight_Conquests_1988/Armorik_the_Viking_-_The_Eight_Conquests_1988.zip\n  </a>\n </p>\n <p>\n  Many thanks in advance!\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/F20b5.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/F20b5.png\"/>\n  </a>\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 2,
    "views": "492",
    "tags": [
        "ida",
        "disassembly",
        "ghidra"
    ],
    "user": "Fab",
    "time": "Jun 19, 2023 at 22:50",
    "comments": [
        {
            "user": "Ali Rizvi-Santiago",
            "text": "<html><body><span class=\"comment-copy\">\n Unless you want to do some work to 100% confirm (as it's just a .COM file), screenshots of the game look like it's CGA. As per\n <a href=\"https://moddingwiki.shikadi.net/wiki/Raw_CGA_Data\" rel=\"nofollow noreferrer\">\n  moddingwiki.shikadi.net/wiki/Raw_CGA_Data\n </a>\n , it's a pretty simple format with every pair of bits representing a color. To confirm it's CGA with reverse-engineering, though, you'd scan for \"INT 10h\" in the disassembly to identify all possible screen mode changes, and I'm pretty certain that they're using \"INT 21h\" to read the contents of those filenames.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  BACKS.BIN - backgrounds. You'll have to write a program to decode those images using your preferred programming language. Some info:\n </p>\n <ul>\n  <li>\n   <p>\n    All images are 320x200, 2 bits per pixel.\n   </p>\n  </li>\n  <li>\n   <p>\n    all images contain header - 8 bytes (4 values - 2 bytes per value, all header contain values 0,0-319,199)\n   </p>\n  </li>\n  <li>\n   <p>\n    Images are interlaced - first part of image contains only even rows, second - odd rows.\n   </p>\n  </li>\n  <li>\n   <p>\n    All images are packed with RLE compression, pseudocode:\n   </p>\n   <pre><code> while(!needExit) {\n\n     controlByte = getNextByte(data[position]);\n     position++;\n\n     if (controlByte == 0) {\n         needExit = true;\n     } else if (controlByte == 0x80) {\n         // change CGA plane\n         buffer = oddRows;\n     } else if ((controlByte & 0x80) == 0) {\n         for (int i=0; i<controlByte; i++) {\n             word = getNextTwoBytes(data, position + i*2);\n             buffer.write(word);\n         }\n         position += controlByte * 2;\n     } else {\n         controlByte = controlByte & 0x7F;\n         word = getNextTwoBytes(data, position);\n         for (int i=0; i<controlByte; i++) {\n             buffer.write(word);\n         }\n         position += 2;\n     }\n }\n</code></pre>\n  </li>\n </ul>\n <p>\n  MOTIFS.BIN - sprites. This file is not packed, so you can see/extract sprites with programs like \"Texture/Tiles finder\" (if they support CGA/2 bits per pixel modes).\n </p>\n <ul>\n  <li>\n   <p>\n    256 sprites of size 32x32 pixels\n   </p>\n  </li>\n  <li>\n   <p>\n    3 sprites of size 48x48 pixels\n   </p>\n  </li>\n  <li>\n   <p>\n    3 sprites of size 64x64 pixels\n   </p>\n  </li>\n  <li>\n   <p>\n    2 bits per pixel, CGA pal.\n   </p>\n  </li>\n  <li>\n   <p>\n    After each sprite lies its transparency mask, also 2 bits per pixel. If 2 bits in mask both set then corresponding pixel in sprite is transparent.\n   </p>\n  </li>\n </ul>\n <p>\n  <img alt=\"Example\" src=\"https://imgur.com/a/UEf75nF\"/>\n  -\n  <a href=\"https://imgur.com/a/UEf75nF\" rel=\"nofollow noreferrer\">\n   https://imgur.com/a/UEf75nF\n  </a>\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Max",
            "time": "Jun 28, 2023 at 22:02",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I tried to read the file BACKS.BIN but I can only view one image from the output_images.bin file generated by the following C++ code. It looks like the output file does not contain all the content from the input file BACKS.BIN; I'm not sure how to fix it. Any ideas on how to improve the below code? Many thanks!\nMy viewer is GBS as well.\n </p>\n <p>\n  here it is:\n  <a href=\"https://ibb.co/MhvhZZq\" rel=\"nofollow noreferrer\">\n   https://ibb.co/MhvhZZq\n  </a>\n </p>\n <pre><code>#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n\nconst int IMAGE_WIDTH = 320;\nconst int IMAGE_HEIGHT = 200;\nconst int HEADER_SIZE = 8;\n\nstruct ImageHeader {\n    int width;\n    int height;\n};\n\nbool getNextTwoBytes(const std::vector<char>& data, int position, short& word) {\n    if (position + 1 >= data.size())\n        return false;\n\n    word = (static_cast<uint8_t>(data[position + 1]) << 8) | static_cast<uint8_t>(data[position]);\n    return true;\n}\n\nbool extractAndDecompressImages(const std::string& inputFilePath, const std::string& outputFilePath) {\n    std::ifstream inputFile(inputFilePath, std::ios::binary);\n    if (!inputFile) {\n        std::cerr << \"Error: Could not open input file.\n\";\n        return false;\n    }\n\n    inputFile.seekg(0, std::ios::end);\n    std::streampos fileSize = inputFile.tellg();\n    inputFile.seekg(0, std::ios::beg);\n\n    int imageCount = static_cast<int>(fileSize / (HEADER_SIZE + IMAGE_WIDTH * IMAGE_HEIGHT));\n    if (imageCount == 0) {\n        std::cerr << \"Error: Invalid input file format.\n\";\n        return false;\n    }\n\n    std::ofstream outputFile(outputFilePath, std::ios::binary);\n    if (!outputFile) {\n        std::cerr << \"Error: Could not create output file \" << outputFilePath << \"\n\";\n        return false;\n    }\n\n    for (int i = 0; i < imageCount; ++i) {\n        ImageHeader header;\n        inputFile.read(reinterpret_cast<char*>(&header), sizeof(ImageHeader));\n\n        std::vector<char> compressedData(IMAGE_WIDTH * IMAGE_HEIGHT);\n        inputFile.read(compressedData.data(), compressedData.size());\n\n        std::vector<char> decompressedData;\n        decompressedData.reserve(IMAGE_WIDTH * IMAGE_HEIGHT * 2); // Reserve enough space to avoid reallocations\n\n        int position = 0;\n\n        while (position < compressedData.size()) {\n            unsigned char controlByte = static_cast<unsigned char>(compressedData[position++]);\n            if (controlByte == 0) {\n                break;\n            } else if (controlByte == 0x80) {\n                // change CGA plane (not relevant for decompression)\n                // Assuming CGA plane change is already handled outside of decompression.\n            } else if ((controlByte & 0x80) == 0) {\n                for (int i = 0; i < controlByte; i++) {\n                    short word;\n                    if (!getNextTwoBytes(compressedData, position + i * 2, word)) {\n                        std::cerr << \"Error: Invalid input file format.\n\";\n                        return false;\n                    }\n                    decompressedData.insert(decompressedData.end(), {static_cast<char>(word & 0xFF), static_cast<char>(word >> 8)});\n                }\n                position += controlByte * 2;\n            } else {\n                controlByte = controlByte & 0x7F;\n                short word;\n                if (!getNextTwoBytes(compressedData, position, word)) {\n                    std::cerr << \"Error: Invalid input file format.\n\";\n                    return false;\n                }\n                for (int i = 0; i < controlByte; i++) {\n                    decompressedData.insert(decompressedData.end(), {static_cast<char>(word & 0xFF), static_cast<char>(word >> 8)});\n                }\n                position += 2;\n            }\n        }\n\n        // Write the decompressed data to the output file using modern C++ iterators\n        std::copy(decompressedData.begin(), decompressedData.end(), std::ostreambuf_iterator<char>(outputFile));\n    }\n\n    return true;\n}\n\nint main() {\n    const std::string inputFilePath = \"BACKS.bin\";\n    const std::string outputFilePath = \"output_images.bin\";\n\n    if (extractAndDecompressImages(inputFilePath, outputFilePath)) {\n        std::cout << \"Extraction and decompression successful!\n\";\n    } else {\n        std::cout << \"Extraction and decompression failed.n\";\n    }\n\n    return 0;\n}\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "The Thinker",
            "time": "Jul 26, 2023 at 3:30",
            "is_accepted": false,
            "comments": []
        }
    ]
}