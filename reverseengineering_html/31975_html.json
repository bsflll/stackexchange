{
    "title": "APK / Decrypting [closed]",
    "link": "https://reverseengineering.stackexchange.com/questions/31975/apk-decrypting",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <div>\n  <aside class=\"s-notice s-notice__info post-notice js-post-notice mb16\" role=\"status\">\n   <div class=\"d-flex fd-column fw-nowrap\">\n    <div class=\"d-flex fw-nowrap\">\n     <div class=\"flex--item wmn0 fl1 lh-lg\">\n      <div class=\"flex--item fl1 lh-lg\">\n       <div>\n        <b>\n         Closed\n        </b>\n        . This question needs\n        <a href=\"/help/closed-questions\">\n         details or clarity\n        </a>\n        . It is not currently accepting answers.\n       </div>\n      </div>\n     </div>\n    </div>\n   </div>\n   <hr class=\"my12 outline-none baw0 bb bc-blue-400\"/>\n   <div class=\"fw-nowrap fc-black-500\">\n    <div class=\"d-flex fd-column lh-md\">\n     <div class=\"mb0 d-flex\">\n      <div class=\"flex--item mr8\">\n       <svg aria-hidden=\"true\" class=\"svg-icon iconLightbulb\" height=\"18\" viewbox=\"0 0 18 18\" width=\"18\">\n        <path d=\"M15 6.38A6.5 6.5 0 0 0 7.78.04h-.02A6.5 6.5 0 0 0 2.05 5.6a6.3 6.3 0 0 0 2.39 5.75c.49.39.76.93.76 1.5v.24c0 1.07.89 1.9 1.92 1.9h2.75c1.04 0 1.92-.83 1.92-1.9v-.2c0-.6.26-1.15.7-1.48A6.3 6.3 0 0 0 15 6.37M4.03 5.85A4.5 4.5 0 0 1 8 2.02a4.5 4.5 0 0 1 5 4.36 4.3 4.3 0 0 1-1.72 3.44c-.98.74-1.5 1.9-1.5 3.08v.1H7.2v-.14c0-1.23-.6-2.34-1.53-3.07a4.3 4.3 0 0 1-1.64-3.94M10 18a1 1 0 0 0 0-2H7a1 1 0 1 0 0 2z\">\n        </path>\n       </svg>\n      </div>\n      <p>\n       <b>\n        Want to improve this question?\n       </b>\n       Add details and clarify the problem by\n       <a href=\"/posts/31975/edit\">\n        editing this post\n       </a>\n       .\n      </p>\n     </div>\n     <div class=\"mb0 mt6 d-flex\">\n      <p class=\"ml24 pl2\">\n       Closed\n       <span class=\"relativetime\" title=\"2023-07-14 14:56:27Z\">\n        1 year ago\n       </span>\n       .\n      </p>\n     </div>\n     <div class=\"ml24 pl2\">\n     </div>\n    </div>\n   </div>\n   <div class=\"mt24 d-flex gsx gs8\">\n    <a class=\"s-btn s-btn__outlined flex--item js-post-notice-edit-post\" href=\"/posts/31975/edit\">\n     Improve this question\n    </a>\n   </div>\n  </aside>\n </div>\n <p>\n  I'm new to Reverse Engineering, so I apologize if something is wrong.\nThere is a free program that requires a license key, which can no longer be bought and obtained. I'm trying to write a KeyGen or just change key parameters like other people have done. It seems they just changed the date in the key and it began to work. I also have a real license key, but if you open it in a text document or Notepad++ - Non-Cyrillic Standard is displayed there.\n </p>\n <p>\n  I looked at the source code of the program, I realized that initially the key is created in .dat, encrypted via AES / CBC / PKCS5Padding, I have BasePassword, SecretKeySpec, parameters for which a license key, and IV can be created. I wrote Keygen,  but generated with the wrong number of bytes. The original key is 192 bytes, mine is about 160. Help me with Java sample of decrypting/keygen based on this crypto.class source code :\n </p>\n <pre><code>import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Crypto {\n  private static final String C2BKEY = \"DEFAULTC2BKEY\";\n  \n  private static final String CRYPTO = \"CRYPTO\";\n  \n  private static final String DATE = \"ExpirationDate\";\n  \n  private static final String EMAIL = \"Email\";\n  \n  public static final String FILENAME_AUTHORIZATION = \"/authorization.dat\";\n  \n  private static final String FILENAME_TIME = \"/validation.dat\";\n  \n  private static final String FULLNAME = \"Fullname\";\n  \n  private static final String HOST_NAME = \"pool.ntp.org\";\n  \n  private static final String LEVEL = \"Level\";\n  \n  private static int authorizationStatus;\n  \n  private static byte[] backuptEncryptedByte;\n  \n  private static String basePassword = \"BasePassword\";\n  \n  private static String strDecryptedKey;\n  \n  private static String str1Level;\n  \n  private static String strEmail;\n  \n  private static String strExpDate;\n  \n  private static String strFullName = \"\";\n  \n  private static String str2Level;\n  \n  private static String str3Level;\n  \n  private static String strLevel;\n  \n  private static String str4Level;\n  \n  private static String str5Level;\n  \n  private static String str6Level;\n  \n  private static String str7Level;\n  \n  static {\n    strEmail = \"\";\n    strLevel = \"\";\n    strExpDate = \"\";\n    str2Level = \"0\";\n    str3Level = \"0\";\n    str4Level = \"0\";\n    str5Level = \"0\";\n    str6Level = \"0\";\n    str7Level = \"0\";\n    str8Level = \"0\";\n    backuptEncryptedByte = null;\n    authorizationStatus = 0;\n  }\n  \n  public static String decrypt(byte[] paramArrayOfbyte, String paramString) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n    Util.print(\"CRYPTO\", \"decrypt\");\n    SecretKeySpec secretKeySpec = new SecretKeySpec(generatePassword(paramString).getBytes(\"UTF-8\"), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(2, secretKeySpec, new IvParameterSpec(new byte[16]));\n    return (new String(cipher.doFinal(paramArrayOfbyte))).trim();\n  }\n  \n  public static String decryptDeviceKey(byte[] paramArrayOfbyte) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n    Util.print(\"CRYPTO\", \"decrypt\");\n    SecretKeySpec secretKeySpec = new SecretKeySpec(\"secretkeyspec\".getBytes(\"UTF-8\"), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(2, secretKeySpec, new IvParameterSpec(new byte[16]));\n    return (new String(cipher.doFinal(paramArrayOfbyte))).trim();\n  }\n  \n  public static void deleteAuthenticationKey(String paramString) {\n    File file = new File(paramString + \"/authorization.dat\");\n    if (file.exists())\n      file.delete(); \n    authorizationStatus = 0;\n    strFullName = \"\";\n    strEmail = \"\";\n    strLevel = \"\";\n    strExpDate = \"\";\n  }\n  \n  public static byte[] encrypt(String paramString) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n    Util.print(\"CRYPTO\", \"decrypt\");\n    SecretKeySpec secretKeySpec = new SecretKeySpec(\"SecretKeySpec\".getBytes(\"UTF-8\"), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(1, secretKeySpec, new IvParameterSpec(new byte[16]));\n    return cipher.doFinal(paramString.getBytes(\"UTF-8\"));\n  }\n  \n  private static String generatePassword(String paramString) {\n    String str = \"\";\n    for (byte b = 0; b < 4; b++)\n      str = str + (String)basePassword.subSequence(b, b + 1) + paramString.subSequence(b, b + 1); \n    return str + (String)paramString.subSequence(4, paramString.length());\n  }\n  \n  public static int getAuthStatus() {\n    Util.print(\"CRYPTO\", \"getStatus\");\n    return authorizationStatus;\n  }\n  \n  public static String getDate() {\n    Util.print(\"CRYPTO\", \"getDate\");\n    return strExpDate;\n  }\n  \n  public static String get2() {\n    Util.print(\"CRYPTO\", \"get2Level\");\n    return str2Level;\n  }\n  \n  public static String get3Level() {\n    Util.print(\"CRYPTO\", \"get3Level\");\n    return str3Level;\n  }\n  \n  public static String get4Level() {\n    Util.print(\"CRYPTO\", \"get4Level\");\n    return str4Level;\n  }\n  \n  public static String getLevel() {\n    Util.print(\"CRYPTO\", \"getLevel\");\n    return strLevel;\n  }\n  \n  public static String get4Level() {\n    Util.print(\"CRYPTO\", \"get4Level\");\n    return str4Level;\n  }\n  \n  public static String get5Level() {\n    Util.print(\"CRYPTO\", \"get5Level\");\n    return str5Level;\n  }\n  \n  public static String get6Level() {\n    Util.print(\"CRYPTO\", \"get6Level\");\n    return str6Level;\n  }\n  \n  public static String get7Level() {\n    Util.print(\"CRYPTO\", \"get7level\");\n    return str7Level;\n  }\n  private static byte[] loadTime(String paramString) {\n    byte[] arrayOfByte;\n    Util.print(\"CRYPTO\", \"load time\");\n    File file = new File(paramString + \"/validation.dat\");\n    String str = null;\n    if (!file.exists())\n      return null; \n    paramString = str;\n    try {\n      FileInputStream fileInputStream = new FileInputStream();\n      paramString = str;\n      this(file);\n      paramString = str;\n      byte[] arrayOfByte1 = new byte[(int)file.length()];\n      arrayOfByte = arrayOfByte1;\n      fileInputStream.read(arrayOfByte1);\n      arrayOfByte = arrayOfByte1;\n      fileInputStream.close();\n      arrayOfByte = arrayOfByte1;\n    } catch (IOException iOException) {\n      iOException.printStackTrace();\n    } \n    return arrayOfByte;\n  }\n  \n  public static byte[] m_loadExternalAuthenticationKey(String paramString1, String paramString2) {\n    byte[] arrayOfByte;\n    Util.print(\"CRYPTO\", \"load external key\");\n    String str = null;\n    File file = new File(paramString2);\n    if (!file.exists())\n      return null; \n    paramString1 = str;\n    try {\n      FileInputStream fileInputStream = new FileInputStream();\n      paramString1 = str;\n      this(file);\n      paramString1 = str;\n      byte[] arrayOfByte1 = new byte[(int)file.length()];\n      arrayOfByte = arrayOfByte1;\n      fileInputStream.read(arrayOfByte1);\n      arrayOfByte = arrayOfByte1;\n      fileInputStream.close();\n      arrayOfByte = arrayOfByte1;\n    } catch (IOException iOException) {\n      iOException.printStackTrace();\n    } \n    return arrayOfByte;\n  }\n  \n  public static byte[] m_loadInternalAuthenticationKey(String paramString1, String paramString2) {\n    byte[] arrayOfByte;\n    Util.print(\"CRYPTO\", \"load internal key\");\n    File file = new File(paramString1 + \"/authorization.dat\");\n    paramString2 = null;\n    if (!file.exists())\n      return null; \n    paramString1 = paramString2;\n    try {\n      FileInputStream fileInputStream = new FileInputStream();\n      paramString1 = paramString2;\n      this(file);\n      paramString1 = paramString2;\n      byte[] arrayOfByte1 = new byte[(int)file.length()];\n      arrayOfByte = arrayOfByte1;\n      fileInputStream.read(arrayOfByte1);\n      arrayOfByte = arrayOfByte1;\n      fileInputStream.close();\n      arrayOfByte = arrayOfByte1;\n    } catch (IOException iOException) {\n      iOException.printStackTrace();\n    } \n    return arrayOfByte;\n  }\n  \n  public static void m_saveAuthenticationKey(String paramString1, String paramString2) {\n    Util.print(\"CRYPTO\", \"m_saveAuthenticationKey\");\n    backuptEncryptedByte = null;\n    backuptEncryptedByte = m_loadInternalAuthenticationKey(paramString1, \"\");\n    byte[] arrayOfByte = m_loadExternalAuthenticationKey(paramString1, paramString2);\n    if (arrayOfByte != null)\n      saveKey(paramString1, arrayOfByte); \n  }\n  \n  private static void parseDecryptedString(String paramString) {\n    Util.print(\"CRYPTO\", \"parse string\");\n    authorizationStatus = 0;\n    if (strDecryptedKey != null && !strDecryptedKey.equals(\"\")) {\n      Date date1;\n      String[] arrayOfString2 = strDecryptedKey.split(\";\");\n      for (int i = 0; i < arrayOfString2.length; i = j + 1) {\n        int j;\n        if (arrayOfString2[i].contains(\":\")) {\n          String[] arrayOfString = arrayOfString2[i].split(\":\");\n          j = i;\n          if (arrayOfString.length == 2)\n            if (arrayOfString[0].compareTo(\"Fullname\") == 0) {\n              strFullName = arrayOfString[1].trim();\n              Util.print(\"CRYPTO\", strFullName);\n              j = i;\n            } else if (arrayOfString[0].compareTo(\"Email\") == 0) {\n              strEmail = arrayOfString[1].trim();\n              Util.print(\"CRYPTO\", strEmail);\n              j = i;\n            } else if (arrayOfString[0].compareTo(\"Level\") == 0) {\n              strLevel = arrayOfString[1].trim();\n              Util.print(\"CRYPTO\", strLevel);\n              j = i;\n            } else {\n              j = i;\n              if (arrayOfString[0].compareTo(\"ExpirationDate\") == 0) {\n                strExpDate = arrayOfString[1].trim();\n                Util.print(\"CRYPTO\", strExpDate);\n                j = i;\n              } \n            }  \n        } else {\n          j = i;\n          if (i < arrayOfString2.length - 1)\n            if (arrayOfString2[i].compareTo(\"Level 2\") == 0) {\n              str2Level = arrayOfString2[i + 1];\n              Util.print(\"CRYPTO\", str2Level);\n              j = i + 1;\n            } else if (arrayOfString2[i].compareTo(\"Level 3\") == 0) {\n              str3Level = arrayOfString2[i + 1];\n              j = i + 1;\n              Util.print(\"CRYPTO\", str4Level);\n            } else if (arrayOfString2[i].compareTo(\"Level 4\") == 0) {\n              str4Level = arrayOfString2[i + 1];\n              j = i + 1;\n              Util.print(\"CRYPTO\", str5Level);\n            } else if (arrayOfString2[i].compareTo(\"Level 5\") == 0) {\n              str5Level = arrayOfString2[i + 1];\n              j = i + 1;\n              Util.print(\"CRYPTO\", str6Level);\n            } else if (arrayOfString2[i].compareTo(\"Level 6\") == 0) {\n              str6Level = arrayOfString2[i + 1];\n              j = i + 1;\n              Util.print(\"CRYPTO\", str6Level);\n            } else if (arrayOfString2[i].compareTo(\"Level 7\") == 0) {\n              str7Level = arrayOfString2[i + 1];\n              j = i + 1;\n              Util.print(\"CRYPTO\", str7Level);\n            } else {\n              j = i;\n              if (arrayOfString2[i].compareTo(\"Level 8\") == 0) {\n                str8Level = arrayOfString2[i + 1];\n                j = i + 1;\n                Util.print(\"CRYPTO\", str8Level);\n              } \n            }  \n        } \n      } \n      arrayOfString2 = null;\n      Date date2 = null;\n      SimpleDateFormat simpleDateFormat = new SimpleDateFormat(Global.DATE_FORMATTER);\n      try {\n        date1 = simpleDateFormat.parse(paramString);\n        date2 = date1;\n      } catch (ParseException parseException) {\n        parseException.printStackTrace();\n      } \n      String[] arrayOfString1 = arrayOfString2;\n      try {\n        Date date = simpleDateFormat.parse(strExpDate);\n        date1 = date;\n        System.out.println(date);\n        date1 = date;\n        if (date2.after(date1)) {\n          Util.print(\"CRYPTO\", \"Authorization Expired\");\n          authorizationStatus = 0;\n          return;\n        } \n      } catch (ParseException parseException) {\n        parseException.printStackTrace();\n        if (date2.after(date1)) {\n          Util.print(\"CRYPTO\", \"Authorization Expired\");\n          authorizationStatus = 0;\n          return;\n        } \n      } \n    } \n  }\n  \n  public static void restoreKey(String paramString) {\n    Util.print(\"CRYPTO\", \"restoreKey\");\n    deleteAuthenticationKey(paramString);\n    if (backuptEncryptedByte != null)\n      saveKey(paramString, backuptEncryptedByte); \n  }\n  \n  private static void saveKey(String paramString, byte[] paramArrayOfbyte) {\n    Util.print(\"CRYPTO\", \"m_save Key\");\n    File file = new File(paramString + \"/authorization.dat\");\n    try {\n      FileOutputStream fileOutputStream = new FileOutputStream();\n      this(file);\n      fileOutputStream.write(paramArrayOfbyte);\n      fileOutputStream.close();\n    } catch (FileNotFoundException fileNotFoundException) {\n      fileNotFoundException.printStackTrace();\n    } catch (IOException iOException) {\n      iOException.printStackTrace();\n    } \n  }\n  \n  private static void saveTime(String paramString1, String paramString2) {\n    Util.print(\"CRYPTO\", \"save time\");\n    File file = new File(paramString1 + \"/validation.dat\");\n    try {\n      FileOutputStream fileOutputStream = new FileOutputStream();\n      this(file);\n      fileOutputStream.write(paramString2.getBytes(\"UTF-8\"));\n      fileOutputStream.close();\n    } catch (FileNotFoundException fileNotFoundException) {\n      fileNotFoundException.printStackTrace();\n    } catch (IOException iOException) {\n      iOException.printStackTrace();\n    } \n  }\n}\n</code></pre>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 0,
    "views": "209",
    "tags": [
        "android",
        "decryption",
        "java",
        "apk"
    ],
    "user": "wh1tedance",
    "time": "1 year ago",
    "comments": [],
    "answers_data": []
}