{
    "title": "Different disassembly for the same function?",
    "link": "https://reverseengineering.stackexchange.com/questions/11789/different-disassembly-for-the-same-function",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have this code:\n </p>\n <pre><code>#include <stdio.h>\nint main()\n{\nprintf(\"a=%d; b=%d; c=%d\", 1, 2, 3);\nreturn 0;\n};</code></pre>\n <p>\n  I compile it with\n  <code>\n   gcc -g 3arg.cpp\n  </code>\n  . Disassemble with\n  <code>\n   objdump -d -M intel a.out\n  </code>\n  . In the output there is exactly one function named\n  <code>\n   _init\n  </code>\n  and it is disassembled like this:\n </p>\n <pre><code>00000000004003e0 <_init>:\n  4003e0:       48 83 ec 08             sub    rsp,0x8\n  4003e4:       48 8b 05 0d 0c 20 00    mov    rax,QWORD PTR [rip+0x200c0d]        # 600ff8 <_DYNAMIC+0x1d0>\n  4003eb:       48 85 c0                test   rax,rax\n  4003ee:       74 05                   je     4003f5 <_init+0x15>\n  4003f0:       e8 3b 00 00 00          call   400430 <__gmon_start__@plt>\n  4003f5:       48 83 c4 08             add    rsp,0x8\n  4003f9:       c3                      ret</code></pre>\n <p>\n  This is\n  <code>\n   gdb\n  </code>\n  output:\n </p>\n <pre><code>$ gdb -q a.out\nReading symbols from a.out...done.\n(gdb) disassemble _init\nDump of assembler code for function _init:\n   0x00000000004003e0 <+0>:  sub    $0x8,%rsp\n   0x00000000004003e4 <+4>:  mov    0x200c0d(%rip),%rax        # 0x600ff8\n   0x00000000004003eb <+11>: test   %rax,%rax\n   0x00000000004003ee <+14>: je     0x4003f5 <_init+21>\n   0x00000000004003f0 <+16>: callq  0x400430 <__gmon_start__@plt>\n   0x00000000004003f5 <+21>: add    $0x8,%rsp\n   0x00000000004003f9 <+25>: retq   \nEnd of assembler dump.\n(gdb) break _init\nBreakpoint 1 at 0x4003e0\n(gdb) run\nStarting program: [redacted]/a.out \n\nBreakpoint 1, _init (argc=1, argv=0x7fffffffdf68, envp=0x7fffffffdf78) at ../csu/init-first.c:52\n52  ../csu/init-first.c: No such file or directory.\n(gdb) disassemble _init\nDump of assembler code for function _init:\n=> 0x00007ffff7a36c20 <+0>:  push   %r13\n   0x00007ffff7a36c22 <+2>:  push   %r12\n   0x00007ffff7a36c24 <+4>:  mov    %edi,%r12d\n   0x00007ffff7a36c27 <+7>:  push   %rbp\n   0x00007ffff7a36c28 <+8>:  mov    %rsi,%rbp\n   0x00007ffff7a36c2b <+11>: push   %rbx\n[etc.]</code></pre>\n <p>\n  Why is the last disassembly different? It's not even the same data disassembled in a different way (As seen when comparing the\n  <code>\n   objdump\n  </code>\n  output with output of\n  <code>\n   gdb\n  </code>\n  command\n  <code>\n   x/10b $rip\n  </code>\n  when the breakpoint has been hit). If it's a different\n  <code>\n   _init\n  </code>\n  function:\n </p>\n <ul>\n  <li>\n   how can I put a breakpoint at the one that's seen in the\n   <code>\n    objdump\n   </code>\n   output and the first disassembly in\n   <code>\n    gdb\n   </code>\n   ?\n  </li>\n  <li>\n   why did\n   <code>\n    gdb\n   </code>\n   say Breakpoint 1 was at\n   <code>\n    0x4003e0\n   </code>\n   and then stopped at a different function?\n  </li>\n </ul>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 1,
    "views": "1k",
    "tags": [
        "disassembly",
        "gdb",
        "objdump"
    ],
    "user": "user14742",
    "time": "Jan 23, 2017 at 10:34",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  To arrive to your\n  <code>\n   _init\n  </code>\n  function just continue execution. This will stop once again in the intended place.\n </p>\n <pre><code>    gdb -q test.out\n    Reading symbols from test.out...done.\n    (gdb) b _init\n    Breakpoint 1 at 0x4003e0\n    (gdb) run\n    Starting program: /home/[censored]/stk/test.out \n\n    Breakpoint 1, _init (argc=1, argv=0x7fffffffe008, envp=0x7fffffffe018) at ../csu/init-first.c:52\n    52  ../csu/init-first.c: No such file or directory.\n    (gdb) bt\n    #0  _init (argc=1, argv=0x7fffffffe008, envp=0x7fffffffe018) at ../csu/init-first.c:52\n    #1  0x00007ffff7dea0fd in call_init (l=0x7ffff7ff74c0, argc=argc@entry=1, argv=argv@entry=0x7fffffffe008, env=env@entry=0x7fffffffe018) at dl-init.c:64\n    #2  0x00007ffff7dea223 in call_init (env=<optimized out>, argv=<optimized out>, argc=<optimized out>, l=<optimized out>) at dl-init.c:36\n    #3  _dl_init (main_map=0x7ffff7ffe1c8, argc=1, argv=0x7fffffffe008, env=0x7fffffffe018) at dl-init.c:126\n    #4  0x00007ffff7ddb30a in _dl_start_user () from /lib64/ld-linux-x86-64.so.2\n    #5  0x0000000000000001 in ?? ()\n    #6  0x00007fffffffe364 in ?? ()\n    #7  0x0000000000000000 in ?? ()\n    (gdb) c\n    Continuing.\n\n    Breakpoint 1, 0x00000000004003e0 in _init ()\n    (gdb) bt\n    #0  0x00000000004003e0 in _init ()\n    #1  0x0000000000400593 in __libc_csu_init ()\n    #2  0x00007ffff7a36e55 in __libc_start_main (main=0x40052d <main>, argc=1, argv=0x7fffffffe008, init=0x400560 <__libc_csu_init>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffdff8)\n        at libc-start.c:246\n    #3  0x0000000000400469 in _start ()\n    (gdb) info shared\n    From                To                  Syms Read   Shared Object Library\n    0x00007ffff7ddaae0  0x00007ffff7df54e0  Yes         /lib64/ld-linux-x86-64.so.2\n    0x00007ffff7a344a0  0x00007ffff7b79583  Yes         /lib/x86_64-linux-gnu/libc.so.6\n    (gdb) x/10i $pc\n=> 0x4003e0 <_init>:    sub    $0x8,%rsp\n   0x4003e4 <_init+4>:  mov    0x200c0d(%rip),%rax        # 0x600ff8\n   0x4003eb <_init+11>: test   %rax,%rax\n   0x4003ee <_init+14>: je     0x4003f5 <_init+21>\n   0x4003f0 <_init+16>: callq  0x400430 <__gmon_start__@plt>\n   0x4003f5 <_init+21>: add    $0x8,%rsp\n   0x4003f9 <_init+25>: retq \n(gdb) info breakpoints\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   <MULTIPLE>         \n    breakpoint already hit 2 times\n1.1                         y     0x00000000004003e0 <_init>\n1.2                         y     0x00007ffff7a36c20 in _init at ../csu/init-first.c:52\n</code></pre>\n <p>\n  According to information about shared libraries, it stopped first time in address area of\n  <code>\n   libc.so\n  </code>\n  , which looks like also has\n  <code>\n   _init\n  </code>\n  function, which caused\n  <code>\n   gdb\n  </code>\n  to set this breakpoint there too (see breakpoint definition at the end of the listing).\n </p>\n <p>\n  If you want to set a breakpoint in your specific address, you can use\n </p>\n <pre><code> b *address\n</code></pre>\n <p>\n  notation. If you want to set a breakpoint on a specific function from specific source file you can use something like\n </p>\n <pre><code>(gdb) break test.c:call1\n</code></pre>\n <p>\n  The same thing is discussed a bit deeper\n  <a href=\"https://stackoverflow.com/questions/31379422/why-is-init-from-glibcs-csu-init-first-c-called-before-start-even-if-start-i\">\n   here\n  </a>\n  .\n </p>\n <p>\n  Good luck.\n </p>\n</div>\n</body></html>",
            "votes": "10",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": []
        }
    ]
}