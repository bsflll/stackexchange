{
    "title": "What exactly is binary disassembly and what it produces?",
    "link": "https://reverseengineering.stackexchange.com/questions/18276/what-exactly-is-binary-disassembly-and-what-it-produces",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The first time I heard about binary disassembly I thought that it is something what can be called as perfect decompilation tool to assembly code and I still don't understand why it is not. I thought that assembly opcodes can be translated directly to binary sequences and directly back from binary sequences to opcodes but leater I heard about some things like possibility of mixing code and data and possibly some other things that make my thought about that I could dissasemble any binary and back assemble it to recreate the same binary impossible. Please don't downvote me immediately. I know practically nothing about reverse engineering and I'm thinking about starting my adventure with it. Can You please axplain me on some examples why things are like they are ?\n </p>\n</div>\n</body></html>",
    "votes": "7",
    "answers": 3,
    "views": "11k",
    "tags": [
        "disassembly",
        "decompilation"
    ],
    "user": "Daro",
    "time": "May 15, 2018 at 18:51",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  First of all welcome to the world of reverse engineering, if there was really such a tool as a perfect disassembler this whole stack exchange forum wouldn't even exist.\n </p>\n <p>\n  Before tackling your question right away I'd like to start talking about what reversing really means and what it is all about as I see it as a more appropriate approach to your question.\n </p>\n <p>\n  The first question you ask given a binary file is \"What?\" I mean in both senses, a binary dump of what seems to be an infinetely large sequence of zeroes and ones and is in fact a your favorite video game or driver.\n </p>\n <p>\n  <strong>\n   How do you interpret the data?\n  </strong>\n  Honestly, this sequence could be anything a text file, program, driver, image, music, video, some trojan etc.. and suppose you know it's one of the above, you still don't know how to interpret it, if it's some sort of media, what format is it (png, mp3, avi...)? \nIf it is a program for which platform is it (windows / Linux) or even worse what CPU architecture is it even for (x86, ARM, PowerPC, MSP430...), and what version of that CPU is it for?. Wait but what if it is encrypted? What encryption is it? I believe you get the point by now.\n </p>\n <p>\n  The last paragraph is meant to give a sense to the ridiculously large amount of possibilities that this said series of code could represent.\nNow your question is specifically about code disassembly. Disassembly is exactly the process of converting the different binary sequences into their original opcode, however when you get a program and supposing you know the platform / CPU / version etc..\n </p>\n <p>\n  And, supposing the opcodes couldn't be mixed up. For example, Let 0101 (instruction a), 0011 (b) be opcodes, suppose there is also longer different opcodes 01010011 (c) and 00110101 (d). Given the sequence 0101001100110101\nHow do you know how to interpret the code (abba, cd, cab..)? (Spoiler: usually ISAs are designed in a way that such collisions wouldn't be made possible)\n </p>\n <p>\n  Great, we now supposedly have a perfect disassembler and now we want to get a step further, and get the original code. Here comes the problem\n </p>\n <p>\n  Take for example the following code:\n </p>\n <pre><code>.loop:\n    xadd eax, edx\n    loop .loop\n</code></pre>\n <p>\n  Basically what we see here is a command of addition and exchange (add edx to eax and then switch their content) now the trivial way to make out the original code would be something like:\n </p>\n <pre><code>for (int i = n; i > 0; i--)\n{\n    a += b;\n    switch(a, b);\n}\n</code></pre>\n <p>\n  However the smart reverse engineer\n  <em>\n   could\n  </em>\n  translate it as such:\n </p>\n <pre><code>genrate_nth_fibonnacci(n);\n</code></pre>\n <p>\n  when eax and edx start at 0 and 1\n </p>\n <p>\n  Similarly, a series of random commands in a malware may be translated into \"makeAntivirusNotNotice\" function or in an otherwise legit program be a very efficient algorithm for a special case.\n </p>\n <p>\n  Thus, programming also has\n  <strong>\n   intention\n  </strong>\n  when writing the code so when you are trying to reverse a program the same code or as mentioned earlier seemingly chaotic series of bytes could have different meanings depending on context, a lot of high level code alternatives and as of the time of writing there still isn't a tool which can also predict the original programmer's intention. The best decompilers and reversing tools such as Radare and IDA try to analyze better and imitate such functionality but right now it is the reverse engineer's task.\n </p>\n</div>\n</body></html>",
            "votes": "5",
            "user": "Elian Kamal",
            "time": "May 15, 2018 at 21:39",
            "is_accepted": true,
            "comments": [
                {
                    "user": "savram",
                    "text": "<span class=\"comment-copy\">Another great decompiler, free and easy to use, is <a href=\"https://retdec.com/\" rel=\"nofollow noreferrer\">retdec.com</a></span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Consider reading chapters 1, 2 and 3 of\n  <em>\n   Computer Systems: A Programmer's Perspective\n  </em>\n  . It explains everything. Strive to gain an understanding of the fundamental concepts of computer architecture and programming languages before diving into reverse engineering.\n </p>\n <hr/>\n <blockquote>\n  <p>\n   The first time I heard about binary disassembly I thought that it is something what can be called as perfect decompilation tool to assembly code and I still don't understand why it is not.\n  </p>\n </blockquote>\n <p>\n  It is important to understand what\n  <em>\n   compilation\n  </em>\n  is and what\n  <em>\n   assembly\n  </em>\n  is before attempting to understand\n  <em>\n   decompilation\n  </em>\n  and\n  <em>\n   disassembly\n  </em>\n  .\n </p>\n <ul>\n  <li>\n   <p>\n    <em>\n     compilation\n    </em>\n    is language-to-language transformation in which the original meaning is preserved. Typically, a computer architecture-\n    <strong>\n     in\n    </strong>\n    dependent language such as C is transformed into a architecture-specific language, such as x86 assembly language, which targets Intel i386 family CPUs.\n   </p>\n   <p>\n    Here is an example of such a high-level language to low-level language transformation using GCC:\n   </p>\n   <p>\n    Source C \"hello_world.c\" file (ASCII text):\n   </p>\n   <blockquote>\n    <pre><code>#include <stdio.h>\n\nint main(void) {\n  printf(\"Hello, world.\n\");\n  return 0;\n}\n</code></pre>\n   </blockquote>\n   <p>\n    Compiler output (x86 assembly ASCII text generated using the\n    <code>\n     -S\n    </code>\n    flag):\n   </p>\n   <blockquote>\n    <pre><code>$ gcc -m32 -S hello_world.c \n$ cat hello_world.s\n  .file   \"hello_world.c\"\n  .section    .rodata\n.LC0:\n  .string \"Hello, world.\"\n  .text\n  .globl  main\n  .type   main, @function\nmain:\n.LFB0:\n  .cfi_startproc\n  pushl   %ebp\n  .cfi_def_cfa_offset 8\n  .cfi_offset 5, -8\n  movl    %esp, %ebp\n  .cfi_def_cfa_register 5\n  andl    $-16, %esp\n  subl    $16, %esp\n  movl    $.LC0, (%esp)\n  call    puts\n  movl    $0, %eax\n  leave\n  .cfi_restore 5\n  .cfi_def_cfa 4, 4\n  ret\n  .cfi_endproc\n.LFE0:\n  .size   main, .-main\n  .ident  \"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4\"\n  .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n   </blockquote>\n   <p>\n    As you can see, this is all ASCII text. There is no machine code here. An additional step is required in order for the CPU to execute this code.\n   </p>\n  </li>\n  <li>\n   <p>\n    the above x86\n    <em>\n     assembly language\n    </em>\n    encoded in ASCII is transformed to a sequence of binary values that conform to the instruction set specification of the target CPU via an\n    <em>\n     assembler\n    </em>\n    . The assembler takes\n    <em>\n     assembly language\n    </em>\n    as input and from it will generate machine language that the CPU can execute. Machine language is not encoded in ASCII and is not human readable.\n   </p>\n  </li>\n  <li>\n   <p>\n    The role of a\n    <em>\n     disassembler\n    </em>\n    is to display machine-language\n    <em>\n     operation codes\n    </em>\n    as human-readable\n    <em>\n     mnemonics\n    </em>\n    . The output below is\n    <em>\n     disassembly\n    </em>\n    of x86 machine language:\n   </p>\n   <blockquote>\n    <pre><code> 0804841d <main>:\n 804841d: 55                      push   %ebp\n 804841e: 89 e5                   mov    %esp,%ebp\n 8048420: 83 e4 f0                and    $0xfffffff0,%esp\n 8048423: 83 ec 10                sub    $0x10,%esp\n 8048426: c7 04 24 d0 84 04 08    movl   $0x80484d0,(%esp)\n 804842d: e8 be fe ff ff          call   80482f0 <puts@plt>\n 8048432: b8 00 00 00 00          mov    $0x0,%eax\n 8048437: c9                      leave  \n 8048438: c3                      ret    \n 8048439: 66 90                   xchg   %ax,%ax\n 804843b: 66 90                   xchg   %ax,%ax\n 804843d: 66 90                   xchg   %ax,%ax\n 804843f: 90                      nop\n</code></pre>\n   </blockquote>\n   <p>\n    On the left are hexadecimal values of machine-language operation codes, and on the right are mnemonics corresponding to the machine-language operation codes.\n   </p>\n  </li>\n  <li>\n   <p>\n    <em>\n     decompilation\n    </em>\n    can be understood in the following way:\n   </p>\n   <blockquote>\n    <p>\n     A decompiler, or reverse compiler, is a program that attempts to perform the inverse process of the compiler:\n  given an executable program compiled in any high-level language, the aim is to produce a high-level language\n  program that performs the same function as the executable program. Thus, the input is machine dependent, and\n  the output is language dependent.\n    </p>\n   </blockquote>\n   <p>\n    In essence, decompilation is translation of machine language consisting of binary opcodes and operands to a architecture-independent language such as C. Disassembly and decompilation are quite different concepts and shouldn't be confused.\n   </p>\n  </li>\n </ul>\n <hr/>\n <blockquote>\n  <p>\n   I thought that assembly opcodes can be translated directly to binary sequences and directly back from binary sequences to opcodes but leater I heard about some things like possibility of mixing code and data and possibly some other things that make my thought about that I could dissasemble any binary and back assemble it to recreate the same binary impossible.\n  </p>\n </blockquote>\n <p>\n  When you say \"assembly opcodes\" what you mean is assembly language mnemonics corresponding to machine-language operation codes. While there is a strong relationship between assembly language and machine language, the relationship is not necessarily 1-to-1. Take a look at\n  <a href=\"https://reverseengineering.stackexchange.com/questions/3800/why-there-are-not-any-disassemblers-that-can-generate-re-assemblable-asm-code\">\n   Why there are not any disassemblers that can generate re-assemblable asm code?\n  </a>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "julian",
            "time": "May 15, 2018 at 20:47",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Daro",
                    "text": "<span class=\"comment-copy\">the question 'Why there are not any disassemblers that can generate re-assemblable asm code?.' is what I wanted to know. Thanks for pointing this out</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  disassembly produces a human readable mnemonic form hexbytes\n </p>\n <p>\n  the processor understands 0's and 1's\n </p>\n <p>\n  the binary contains an encoded version of 0's and 1's  in the form of hex bytes\n </p>\n <p>\n  if one needs to instruct the processor to mov 1 to register eax\n </p>\n <p>\n  it needs to be encoded as\n  <strong>\n   0b1011100000000001000000000000000000000000\n  </strong>\n </p>\n <p>\n  which when converted to hex (base 16 instead of base 2 as above )\nwill become  >\n  <strong>\n   0xb801000000\n  </strong>\n </p>\n <p>\n  disassembler takes this > 0xb801000000 interprets and dispalys this hex bytes\n  \n\n  as\n  <strong>\n   mov eax ,1\n  </strong>\n </p>\n <p>\n  the high level languages does not know about registers \nyou will write code like\n </p>\n <p>\n  int a =1;\n </p>\n <p>\n  this can be translated as\n  <strong>\n   mov eax,1 or mov ebx,1 or mov [addr] , 1\n  </strong>\n </p>\n <p>\n  so converting back one of several forms back to original is not possible always\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "blabb",
            "time": "May 15, 2018 at 20:30",
            "is_accepted": false,
            "comments": []
        }
    ]
}