{
    "title": "Reversing a 2.4Ghz Quadcopter remote control",
    "link": "https://reverseengineering.stackexchange.com/questions/9331/reversing-a-2-4ghz-quadcopter-remote-control",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  TL;DR - I can't figure out why I'm failing to replicate the Quadcopter's remote control with, say, Arduino and NRF24L01 after eavesdropping the SPI commands on the remote control.\n </p>\n <p>\n  So I got this cheap quadcopter, actually 3 different models (\n  <a href=\"http://www.ebay.com/itm/UDI-U839-Nano-RC-Quadcopter-UFO-4CH-2-4G-6-Axis-Gyro-Remote-Control-Helicopter-/281682763236?pt=LH_DefaultDomain_0&hash=item419599dde4\" rel=\"nofollow noreferrer\">\n   this\n  </a>\n  ,\n  <a href=\"http://www.ebay.com/itm/NEW-Mini-RC-Quadcopter-Toy-JJ810-2-4G-4CH-6-axis-Gyro-LED-lights-for-Night-Fly-/251955473147?pt=LH_DefaultDomain_0&hash=item3aa9b76afb\" rel=\"nofollow noreferrer\">\n   this\n  </a>\n  and\n  <a href=\"http://www.ebay.com/itm/Super-Stable-Flight-RC-Mini-Quadcopter-Toy-M9912-X6-2-4G-4CH-6-axis-Gyro-New-/381050684931?pt=LH_DefaultDomain_15&hash=item58b8640603\" rel=\"nofollow noreferrer\">\n   this\n  </a>\n  , and the principle is the same with all three)\nAll models use the\n  <a href=\"http://www.inhaos.com/uploadfile/otherpic/BK2423%20Datasheet%20v2.0.pdf\" rel=\"nofollow noreferrer\">\n   BK2423 radio\n  </a>\n  , which should be air-compatible with the\n  <a href=\"http://www.nordicsemi.com/eng/content/download/2730/34105/file/nRF24L01_Product_Specification_v2_0.pdf\" rel=\"nofollow noreferrer\">\n   NRF24l01\n  </a>\n  - which is what I have.\n </p>\n <p>\n  So since I have found (surprisingly) very little information on this matter online, I put some probes between the remote control's MPU and it's BK2423 and used Saleae Logic Analyzer to read the communication running on the SPI bus between the two. What I have find out is it has 3 main stages: Config, Search/Bind and Command, where in between there are some tweaks that the MCU performs, as I described below.\n </p>\n <p>\n  On the Config phase, some registers are being set, like the pipe number for Rx and the address, RF channel and more. Here is part of the config capture:\n  <img alt=\"config phase\" src=\"https://i.sstatic.net/Gpnyu.png\"/>\n </p>\n <p>\n  So the initial Tx (and Rx) address is 5 bytes:\n  <strong>\n   0xCCCCCCCCCC\n  </strong>\n  .\nAnd the initial RF Channel is\n  <strong>\n   0x2D\n  </strong>\n  . \nThe default address length for the two chips is 5 bytes and since the remote control does not change it, the length should stay 5 bytes.\n </p>\n <p>\n  Then comes the search phase. In that phase, the remote sends basically the same data over and over, and only changes the RF channel. Here is the last search packet:\n </p>\n <p>\n  <img alt=\"Search stage\" src=\"https://i.sstatic.net/8d45W.png\"/>\n </p>\n <p>\n  So after many transmissions with different RF channels, something weird happens. The remote hits the correct RF channel for the quadcopter, but I can't figure out how he understands that, since the Status register (on the MISO channel) stays the same on the last search packets. Here is where the remote control MCU tells the BK2423 to change the RF Channel, with no evidence to anything else around:\n </p>\n <p>\n  <img alt=\"After search phase\" src=\"https://i.sstatic.net/P3Lmc.png\"/>\n </p>\n <p>\n  Then the MCU tells the BK2423 to change the address and RF channel to the right ones. It must be the right ones since the quadcopter reacts properly:\n </p>\n <p>\n  <img alt=\"Changing address and RF channel again\" src=\"https://i.sstatic.net/oqbGM.png\"/>\n </p>\n <p>\n  From this point and on, the remote control sends command packets and the quadcopter happily fly around. I couldn't manage to properly pass the search phase.\n </p>\n <p>\n  I used some code from\n  <a href=\"https://dl.dropboxusercontent.com/u/2248531/blog/HCD/HCD.zip\" rel=\"nofollow noreferrer\">\n   this project\n  </a>\n  (taken from\n  <a href=\"http://dzlsevilgeniuslair.blogspot.dk/2013/11/more-toy-quadcopter-hacking.html\" rel=\"nofollow noreferrer\">\n   this page\n  </a>\n  ) and changed HCD.cpp to match what I sniffed. Here are only the two methods I changed (rest of the code within that file stays the same):\n </p>\n <pre><code>void HCD::bind(unsigned char *ID)\n{\n  for(unsigned char i=0;i<4;i++)\n    noteID[i]=ID[i];\n\n  state=HS_CONNECT;\n  radio.offline();\n    radio.txbuf[0] = 0x3F;\n    radio.txbuf[1] = 0x4C;\n    radio.txbuf[2] = 0x84;\n    radio.txbuf[3] = 0x6F;\n    radio.txbuf[4] = 0x9C;\n    radio.txbuf[5] = 0x20;\n    radio.sendBuffer(6); \n    radio.txbuf[0] = 0x3E;\n    radio.txbuf[1] = 0xC9;\n    radio.txbuf[2] = 0x9A;\n    radio.txbuf[3] = 0xB0;\n    radio.txbuf[4] = 0x61;\n    radio.txbuf[5] = 0xBB;\n    radio.txbuf[6] = 0xAB;\n    radio.txbuf[7] = 0x9C;\n    radio.sendBuffer(8); \n    radio.txbuf[0] = 0x39;\n    radio.txbuf[1] = 0x0B;\n    radio.txbuf[2] = 0xDF;\n    radio.txbuf[3] = 0xC4;\n    radio.txbuf[4] = 0xA7;\n    radio.txbuf[5] = 0x03;\n    radio.sendBuffer(6); \n\n    radio.txbuf[0] = 0x30;\n    radio.txbuf[1] = 0xCC;\n    radio.txbuf[2] = 0xCC;\n    radio.txbuf[3] = 0xCC;\n    radio.txbuf[4] = 0xCC;\n    radio.txbuf[5] = 0xCC;\n    radio.sendBuffer(6);\n\n    radio.txbuf[0] = 0x2A;\n    radio.txbuf[1] = 0xCC;\n    radio.txbuf[2] = 0xCC;\n    radio.txbuf[3] = 0xCC;\n    radio.txbuf[4] = 0xCC;\n    radio.txbuf[5] = 0xCC;\n    radio.sendBuffer(6);\n\n    radio.txbuf[0] = 0xE1;\n    radio.txbuf[1] = 0x00;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0xE2;\n    radio.txbuf[1] = 0x00;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x27;\n    radio.txbuf[1] = 0x70;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x21;\n    radio.txbuf[1] = 0x00;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x22;\n    radio.txbuf[1] = 0x01;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x23;\n    radio.txbuf[1] = 0x03;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x25;\n    radio.txbuf[1] = 0x2D;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x24;\n    radio.txbuf[1] = 0x00;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x31;\n    radio.txbuf[1] = 0x09;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x26;\n    radio.txbuf[1] = 0x07;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x50;\n    radio.txbuf[1] = 0x73;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x3C;\n    radio.txbuf[1] = 0x00;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x3D;\n    radio.txbuf[1] = 0x00;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x31;\n    radio.txbuf[1] = 0x09;\n    radio.sendBuffer(2);\n\n    radio.txbuf[0] = 0x1D;\n    radio.txbuf[1] = 0x00;\n    radio.sendBuffer(2);\n\n\n}\n\n\nvoid HCD::update(unsigned char *payload)\n{\nSerial.print(\"Sending, state: \");\nSerial.print(state);\nSerial.print(\"  Channel: \");\nSerial.println(channel);\n  unsigned char c=0;\n\n  switch(state)\n  {\n  case HS_CONNECT:\n\n    radio.offline();\n    radio.txbuf[0] = 0x27;\n    radio.txbuf[1] = 0x70;\n    radio.sendBuffer(2); \n    radio.txbuf[0] = 0xE1;\n    radio.txbuf[1] = 0x00;\n    radio.sendBuffer(2); \n    radio.txbuf[0]=0x25;\n    radio.txbuf[1]= channel; //0x2A;\n    radio.sendBuffer(2);      //-Chan\n\n    //radio.block(baseAddress);\n    //radio.block(flushTX);\n\n    radio.txbuf[0]=0xA0;\n    radio.txbuf[1]=0x20;\n    radio.txbuf[2]=0x14;\n    radio.txbuf[3]=0x03;\n    radio.txbuf[4]=0x25;\n    radio.txbuf[5]=0x1F; //noteID[0];\n    radio.txbuf[6]=0xC3; //noteID[1];\n    radio.txbuf[7]=0x00; //noteID[2];\n    radio.txbuf[8]=0xE2; //noteID[3];\n    radio.txbuf[8]=0xAA; //noteID[3];\n    radio.sendBuffer(9);      //-tx data\n    //radio.block(PTX);\n    radio.online();\n\n    while(!c)\n      c=radio.getStatus();\n    radio.clrStatus();\n     Serial.print(\"Status: \" );\n     Serial.println(c);\n    if(c&0x10)  //MRT\n    {\n      state=HS_UNINITIALIZED;\n      Serial.println(\"Uninitializing :( Connecting\");\n    }\n\n    if(c&0x20)  //ACK\n    {\n      Serial.println(\"ACK Connecting\");\n      state=HS_CONNECTED;\n    }\n    break;\n\n  case HS_CONNECTED:\n\n    radio.offline();\n\n    radio.txbuf[0]=0x25;\n    radio.txbuf[1]=channel;\n    radio.sendBuffer(2);      //-Chan\n\n\n    radio.txbuf[0]=0x2a;\n    radio.txbuf[1]=noteID[0];\n    radio.txbuf[2]=noteID[1];\n    radio.txbuf[3]=noteID[2];\n    radio.txbuf[4]=noteID[3];\n    radio.txbuf[5]=0xCC;\n    radio.sendBuffer(6);      //-tx data\n\n    radio.txbuf[0]=0x30;\n    radio.txbuf[1]=noteID[0];\n    radio.txbuf[2]=noteID[1];\n    radio.txbuf[3]=noteID[2];\n    radio.txbuf[4]=noteID[3];\n    radio.txbuf[5]=0xAA;\n    radio.sendBuffer(6);      //-tx data\n\n    radio.online();\n\n    radio.block(flushTX);\n\n    radio.txbuf[0]=0xA0;\n    radio.txbuf[1]=payload[0];\n    radio.txbuf[2]=payload[1];\n    radio.txbuf[3]=payload[2];\n    radio.txbuf[4]=payload[3];\n    radio.txbuf[5]=payload[4];\n    radio.txbuf[6]=payload[5];\n    radio.txbuf[7]=payload[6];\n    radio.txbuf[8]=payload[7];\n    radio.sendBuffer(9);      //-tx data\n\n    radio.txbuf[0]=0x20;\n    radio.txbuf[1]=0x7A;  //-TX\n    radio.sendBuffer(2);\n\n    while(!c)\n      c=radio.getStatus();\n    radio.clrStatus();\n\n\n    if(c&0x10)  //MRT\n    {\n      Serial.println(\"MRT - connected\");\n    }\n\n    if(c&0x20)  //ACK\n    {\n      Serial.println(\"ACK - connected\");\n    }\n\n    break;\n\n  }\n}\n</code></pre>\n <p>\n  And I'm using a fairly simple Arduino sketch to invoke these methods (which is a modified version of the INO file form the project mentioned above):\n </p>\n <pre><code>#include <HCD.h>\nHCD drone0;\n\nunsigned char ID0[]={\n  0x1F, 0xC3, 0x00, 0xCC};\nunsigned char payload0[]={  0x0, 0x20, 0x14, 0x03, 0x25, 0x1F, 0xC3, 0x00 };\nunsigned char payload1[]={\n  0x00,0x70,0x70,0x1E,0x1E,0x00,0x10,0x7E};\n\nvoid setup()\n{\n  Serial.begin(19200);\n  Serial.println(\"ON\");\n  Serial.println(\"Connecting a\");\n  drone0.bind(ID0);\n  drone0.setChannel(0x25);\n}\n\nunsigned long timer=0;\n\nunsigned char chs[] = { 0x2A, 0x20, 0x34, 0x16, 0x3E, 0x0C, 0x48};\nvoid loop()\n{\n  for (int i=0; i<128; i++)\n  {\n     drone0.setChannel(i);\n     drone0.update(payload0);\n     delay(10);\n  }\n  delay(2000);  \n  drone0.setChannel(0x2); \n  drone0.update(payload1);\n  delay(2000);\n}\n</code></pre>\n <p>\n  Yet the Quadcopter seems to gently ignore this code and many variations of it.\n </p>\n <p>\n  If anyone got to this line in my question, I would appreciate any help he/she can provide.\n </p>\n</div>\n</body></html>",
    "votes": "8",
    "answers": 1,
    "views": "2k",
    "tags": [
        "spi",
        "arduino",
        "remote"
    ],
    "user": "Omer",
    "time": "Jul 12, 2015 at 12:56",
    "comments": [
        {
            "user": "Guntram Blohm",
            "text": "<html><body><span class=\"comment-copy\">\n I'm afraid i don't have the knowledge to help you, but i wish more questions on RE.SE were as well researched and written. Upvoted.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  There are some items I do not understand in your code:\n </p>\n <ol>\n  <li>\n   <p>\n    In the initial \"bind\" routine, there are commands 0x3F, 0x3E, 0x39, corresponding to registers 1F, 1E, 19, if I understood this right. These are not documented in the NRF24l01 data sheet (btw your link to it does not work).\n   </p>\n  </li>\n  <li>\n   <p>\n    You send the payload with the correct command 0xA0. However, you send a total of 9 bytes, including the command. Does this not mean that the payload you are sending contains only eight bytes? And in one of your payload send commands you put the txbuf[8] twice. maybe you meant as second time txbuf[9] instead?\n   </p>\n  </li>\n  <li>\n   <p>\n    As the last command you send 0x20. If I got it right, this is the \"Write configuration\". Should this not come at an earlier stage?\n   </p>\n  </li>\n </ol>\n <p>\n  Otherwise, I do not know anything about quadcopters (only that Amazon wants to use them...)\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "josh",
            "time": "Jul 12, 2015 at 12:48",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Omer",
                    "text": "<span class=\"comment-copy\">Thanks for the remarks! 1. True - I just replicated what the logic analyzer caught. 2. True again. And the second [8] is a bug. 3. This is the same as the original code, basically it can come at this stage as well, there are no restriction on where in the flow this register can be configured so I guess it should be OK.</span>",
                    "time": null
                },
                {
                    "user": "josh",
                    "text": "<span class=\"comment-copy\">But shouldn't you send a total of 10 bytes, as the payload size has been setup to be 9? You also catch 10 bytes in your logic analyzer, when including the command.</span>",
                    "time": null
                },
                {
                    "user": "Omer",
                    "text": "<span class=\"comment-copy\">Right. default payload is 8 bytes and they didn't change it. But after everything else failed, I decided to replicate exactly what was captured. I know it doesn't make sense, the same as the non-existing registers 1F and 1E, but that's what I sniffed, several times. Any experience with such discrepancies?</span>",
                    "time": null
                },
                {
                    "user": "josh",
                    "text": "<span class=\"comment-copy\">Sorry, but I do not understand.  In your \"bind\" routine, you set the payload length to 9 bytes (command 0x31), but then you send only 8 bytes payload. Why? But maybe I got you completely wrong, and we are talking about different items. I have only limited experience with microcontrollers.</span>",
                    "time": null
                },
                {
                    "user": "Omer",
                    "text": "<span class=\"comment-copy\">I think you got it right again. I missed that. At some stage I just copied the bytes, and indeed 0x31 followed by 0x9 means the payload is set to 9 bytes. Fixing the bug of the double \"txbuf[8]\" should reflect that as well (meaning 10 bytes total including the command). I should perform this fix and update the question (who knows, perhaps this was the issue?!...)</span>",
                    "time": null
                }
            ]
        }
    ]
}