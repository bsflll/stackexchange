{
    "title": "What is the purpose of these instructions before the main preamble?",
    "link": "https://reverseengineering.stackexchange.com/questions/19830/gcc-adds-code-involving-ecx-in-main",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I wrote a small C program below:\n </p>\n <pre><code>#include <stdlib.h>\nint sub(int x, int y){\n  return 2*x+y;\n}\n\nint main(int argc, char ** argv){\n  int a;\n  a = atoi(argv[1]);\n  return sub(argc,a);\n}\n</code></pre>\n <p>\n  Compiled with gcc 5.4.0 and target 32 bit x86. I got the following in disassembly:\n </p>\n <pre><code>0804841b <main>:\n 804841b: 8d 4c 24 04           lea    0x4(%esp),%ecx\n 804841f: 83 e4 f0              and    $0xfffffff0,%esp\n 8048422: ff 71 fc              pushl  -0x4(%ecx)\n 8048425: 55                    push   %ebp\n 8048426: 89 e5                 mov    %esp,%ebp\n 8048428: 53                    push   %ebx\n 8048429: 51                    push   %ecx\n 804842a: 83 ec 10              sub    $0x10,%esp\n 804842d: 89 cb                 mov    %ecx,%ebx\n....\n</code></pre>\n <p>\n  What are the first three instructions before\n  <code>\n   push %ebp\n  </code>\n  doing? I haven't seen those in older gcc compiled binaries.\n </p>\n</div>\n</body></html>",
    "votes": "10",
    "answers": 2,
    "views": "6k",
    "tags": [
        "disassembly",
        "x86",
        "gcc"
    ],
    "user": "Evan Carroll",
    "time": "Apr 17, 2017 at 1:08",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <h2>\n  What the Instructions Are Doing\n </h2>\n <blockquote>\n  <p>\n   What are the first three instructions before\n   <code>\n    push %ebp\n   </code>\n   doing?\n  </p>\n </blockquote>\n <p>\n  Namely,\n </p>\n <pre><code> 804841b: 8d 4c 24 04           lea    0x4(%esp),%ecx      <-  1\n 804841f: 83 e4 f0              and    $0xfffffff0,%esp    <-  2\n 8048422: ff 71 fc              pushl  -0x4(%ecx)          <-  3\n</code></pre>\n <p>\n  This is easy to see if\n  <code>\n   gdb\n  </code>\n  (or some other debugger) is used to step through the code.\n </p>\n <ol>\n  <li>\n   <blockquote>\n    <p>\n     <code>\n      804841b: 8d 4c 24 04           lea    0x4(%esp),%ecx\n     </code>\n    </p>\n   </blockquote>\n  </li>\n </ol>\n <p>\n  At this point in the process, the memory address in register\n  <code>\n   $esp\n  </code>\n  is\n  <code>\n   0xffffd13c\n  </code>\n  , so\n  <code>\n   4(%esp)\n  </code>\n  =\n  <code>\n   $esp+4\n  </code>\n  =\n  <code>\n   0xffffd140\n  </code>\n  :\n </p>\n <pre><code>>>> x/x $esp+4\n0xffffd140: 0x01\n</code></pre>\n <p>\n  This means that the\n  <code>\n   lea\n  </code>\n  instruction loads the effective address of\n  <code>\n   0x4(%esp)\n  </code>\n  ,\n  <code>\n   0xffffd140\n  </code>\n  , into\n  <code>\n   $ecx\n  </code>\n  .\n </p>\n <hr/>\n <ol start=\"2\">\n  <li>\n   <blockquote>\n    <p>\n     <code>\n      804841f: 83 e4 f0              and    $0xfffffff0,%esp\n     </code>\n    </p>\n   </blockquote>\n  </li>\n </ol>\n <p>\n  Next, the value in\n  <code>\n   $esp\n  </code>\n  ,\n  <code>\n   0xffffd13c\n  </code>\n  , is ANDed with\n  <code>\n   0xfffffff0\n  </code>\n  :\n </p>\n <pre><code>0xffffd13c:            11111111111111111101000100111100\n0xfffffff0:       AND  11111111111111111111111111110000\n                  -------------------------------------\n                       11111111111111111101000100110000\n</code></pre>\n <p>\n  This results in the value\n  <code>\n   0xffffd130\n  </code>\n  , which is stored in\n  <code>\n   $esp\n  </code>\n  . This is equivalent to\n </p>\n <p>\n  <code>\n   0xffffd13c\n  </code>\n  -\n  <code>\n   0x0c\n  </code>\n  =\n  <code>\n   0xffffd130\n  </code>\n  .\n </p>\n <p>\n  This has the effect of creating 12 bytes of space on the process runtime stack. On a side note, the value -16 would be represented as\n  <code>\n   0xfffffff0\n  </code>\n  , so we could think of\n </p>\n <p>\n  <code>\n   and $0xfffffff0,%esp\n  </code>\n </p>\n <p>\n  as\n </p>\n <p>\n  <code>\n   and $-16,%esp\n  </code>\n </p>\n <p>\n  This is done to\n  <a href=\"https://reverseengineering.stackexchange.com/questions/14880/basic-reversing-question-about-local-variable/14883#14883\">\n   keep the stack aligned to a 16-byte boundary\n  </a>\n  , since the next instruction (see 3) decrements the stack pointer by 4 and then saves a value to the stack.\n </p>\n <hr/>\n <ol start=\"3\">\n  <li>\n   <blockquote>\n    <p>\n     <code>\n      8048422: ff 71 fc              pushl  -0x4(%ecx)\n     </code>\n    </p>\n   </blockquote>\n  </li>\n </ol>\n <p>\n  As a result of\n  <code>\n   lea 0x4(%esp),%ecx\n  </code>\n  from earlier, the value in\n  <code>\n   $ecx\n  </code>\n  is equivalent to what had been\n  <code>\n   $esp+4\n  </code>\n  (that is,\n  <code>\n   0xffffd140\n  </code>\n  ). As a result,\n </p>\n <p>\n  <code>\n   -0x4(%ecx)\n  </code>\n  =\n  <code>\n   0xffffd140\n  </code>\n  - 4 =\n  <code>\n   0xffffd13c\n  </code>\n  .\n </p>\n <p>\n  This was the value of\n  <code>\n   $esp\n  </code>\n  at the beginning of\n  <code>\n   main()\n  </code>\n  . This value is now saved on the process runtime stack via a\n  <code>\n   pushl\n  </code>\n  instruction.\n </p>\n <p>\n  <hr/>\n  <strong>\n   summary:\n  </strong>\n </p>\n <pre><code> lea    0x4(%esp),%ecx         // load 0xffffd140 into $ecx\n and    $0xfffffff0,%esp       // subtract 0x0c (decimal 12) from $esp\n pushl  -0x4(%ecx)             // decrement $esp by 4, save 0xffffd13c on stack\n</code></pre>\n <hr/>\n <h2>\n  The Purpose of these Instructions\n </h2>\n <blockquote>\n  <p>\n   What is the purpose of these instructions before the main preamble?\n  </p>\n </blockquote>\n <p>\n  A clue about the purpose of these instructions is the fact that they are executed prior to the conventional function prologue:\n </p>\n <pre><code>8048425: 55                    push   %ebp\n8048426: 89 e5                 mov    %esp,%ebp\n</code></pre>\n <p>\n  According to the\n  <a href=\"http://refspecs.linux-foundation.org/elf/abi386-4.pdf\" rel=\"noreferrer\">\n   System V Application Binary Interface Intel386 Architecture Processor Supplment, Fourth Edition\n  </a>\n  , after the execution of the function prologue\n  <code>\n   $ebp+4\n  </code>\n  is the location on the runtime stack of the return address.\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/VRdaH.png\" rel=\"noreferrer\">\n   <img alt=\"SYS V ABI i386 supplement C stack frame\" src=\"https://i.sstatic.net/VRdaH.png\"/>\n  </a>\n </p>\n <p>\n  The address saved on the stack at\n  <code>\n   $ebp+4\n  </code>\n  by the instruction\n </p>\n <p>\n  <code>\n   8048422: ff 71 fc              pushl  -0x4(%ecx)\n  </code>\n </p>\n <p>\n  is\n  <code>\n   0xffffd13c\n  </code>\n  . This is a pointer to\n  <code>\n   0xf7e12637\n  </code>\n  , the address of offset 247 in\n  <code>\n   __libc_start_main()\n  </code>\n  :\n </p>\n <pre><code>>>> x/x $ecx-4\n0xffffd13c: 0xf7e12637\n>>> x/x 0xf7e12637\n0xf7e12637 <__libc_start_main+247>: 0x8310c483\n</code></pre>\n <p>\n  This indicates that the return address of\n  <code>\n   main()\n  </code>\n  is in function\n  <code>\n   __libc_start_main()\n  </code>\n  .\n </p>\n <p>\n  As for\n  <code>\n   $ecx\n  </code>\n  , this register simply holds the value of\n  <code>\n   argc\n  </code>\n  :\n </p>\n <pre><code>>>> x/x $ecx\n0xffffd140: 0x00000001\n</code></pre>\n <p>\n  Note that since variable\n  <code>\n   a\n  </code>\n  is never used, the compiler optimizes out the call to\n  <code>\n   atoi\n  </code>\n  .\n </p>\n <p>\n  So to answer the question directly, the instructions in\n  <code>\n   main()\n  </code>\n  prior to the prologue pass an argument to\n  <code>\n   main()\n  </code>\n  (the value of\n  <code>\n   argc\n  </code>\n  ) and save the return address of\n  <code>\n   main()\n  </code>\n  on the runtime stack.\n </p>\n <h2>\n  The C Runtime Environment and Linux Process Anatomy\n </h2>\n <p>\n  Naturally, the next question is \"What is\n  <code>\n   __libc_start_main\n  </code>\n  ?\" According to\n  <a href=\"http://refspecs.linuxbase.org/LSB_3.0.0/LSB-PDA/LSB-PDA/baselib---libc-start-main-.html\" rel=\"noreferrer\">\n   Linux Standard Base PDA Specification 3.0RC1\n  </a>\n  :\n </p>\n <blockquote>\n  <p>\n   The\n   <code>\n    __libc_start_main()\n   </code>\n   function shall initialize the process, call the main function with appropriate arguments, and handle the return from\n   <code>\n    main()\n   </code>\n   .\n  </p>\n </blockquote>\n <p>\n  So where does\n  <code>\n   __libc_start_main()\n  </code>\n  come from? The short answer is that it is a function in the shared object\n  <code>\n   /lib/i386-linux-gnu/libc-2.23.so\n  </code>\n  which is dynamically linked into the executable ELF binary:\n </p>\n <pre><code> $ ldd [binary_name]\n    linux-gate.so.1 =>  (0xf7764000)\n    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7586000)\n    /lib/ld-linux.so.2 (0x56640000)\n</code></pre>\n <p>\n  In addition to\n  <code>\n   __libc_start_main()\n  </code>\n  , the function\n  <code>\n   __gmon_start__\n  </code>\n  , also part of process initialization, is dynamically linked to the executable ELF binary as well:\n </p>\n <pre><code>$ readelf --dyn-syms [binary_name]\n\nSymbol table '.dynsym' contains 5 entries:\n   Num:    Value  Size Type    Bind   Vis      Ndx Name\n     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (2)\n     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__\n     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (3)\n     4: 0804851c     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used\n</code></pre>\n <p>\n  Here is the complete picture, from\n  <a href=\"http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html\" rel=\"noreferrer\">\n   <strong>\n    Linux x86 Program Start Up or - How the heck do we get to main()?\n   </strong>\n  </a>\n  by Patrick Horgan:\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/xKl8k.png\" rel=\"noreferrer\">\n   <img alt=\"C process initialization call graph\" src=\"https://i.sstatic.net/xKl8k.png\"/>\n  </a>\n </p>\n <p>\n  On a final note, if the return address of\n  <code>\n   main()\n  </code>\n  of\n  <code>\n   0xf7e12637\n  </code>\n  is examined more closely, we see that this address lies outside of the\n  <code>\n   text\n  </code>\n  segment as well as the runtime stack. This address, located in\n  <code>\n   __libc_start_main()\n  </code>\n  , is actually located in the memory-mapped segment in virtual memory, as shown by this diagram from Gustavo Duarte's article\n  <a href=\"http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/\" rel=\"noreferrer\">\n   <strong>\n    Anatomy of a Program in Memory\n   </strong>\n  </a>\n  :\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/LPwfZ.png\" rel=\"noreferrer\">\n   <img alt=\"Linux Process Layout in VM\" src=\"https://i.sstatic.net/LPwfZ.png\"/>\n  </a>\n </p>\n</div>\n</body></html>",
            "votes": "19",
            "user": "sudhackar",
            "time": "Aug 4, 2018 at 8:39",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <h1>\n  What does this do?\n </h1>\n <p>\n  These three statements serve to\n  <em>\n   move\n  </em>\n  the stackframe of\n  <code>\n   main\n  </code>\n  , beginning with its return address, to the next 16-byte-aligned address.\n </p>\n <pre><code>lea    0x4(%esp),%ecx    # save address of arguments\nand    $0xfffffff0,%esp  # align stack\npushl  -0x4(%ecx)        # move return address\n...                      # continue normal preamble\n</code></pre>\n <p>\n  At the same time, the arguments to\n  <code>\n   main\n  </code>\n  (\n  <code>\n   argc\n  </code>\n  and\n  <code>\n   argv\n  </code>\n  ) are not moved, so a pointer to them is saved in\n  <code>\n   %ecx\n  </code>\n  .\n </p>\n <p>\n  Recall the layout of the stack upon entering\n  <code>\n   main\n  </code>\n  :\n </p>\n <pre><code>%esp+8:  argv (a pointer to an array of pointers)\n%esp+4:  argc (a 32-bit integer)\n%esp+0:  return address (from call)\n</code></pre>\n <p>\n  The arguments sit right above the return address, so\n  <code>\n   %esp+4\n  </code>\n  is saved to\n  <code>\n   %ecx\n  </code>\n  before the stack pointer is adjusted.\nNext,\n  <code>\n   %ecx\n  </code>\n  also serves as our pointer to locate the original return address,\n  <code>\n   -4(%ecx)\n  </code>\n  , which we push to our new stack frame.\n </p>\n <p>\n  After the rest of the preamble, the stack will look like this:\n </p>\n <pre><code>%ecx+4:  argv pointer\n%ecx+0:  argc\n%ecx-4:  original return address\n         ...\n%esp+4:  copy of return address\n%esp+0:  saved base pointer\n</code></pre>\n <p>\n  In your code, you can also see that\n  <code>\n   %ecx\n  </code>\n  is pushed onto the stack (i.e. saved as a local variable) after the preamble; it will be restored from there at the end of the function which will look like this:\n </p>\n <pre><code>...\nmov    -0x8(%ebp),%ecx   # load pointer to argc\nleave                    # unwind stack frame, pop %ebp\nlea    -0x4(%ecx),%esp   # restore original stack pointer\nret                      # jump out, using the original return address!\n</code></pre>\n <h1>\n  Why is all this done at all?\n </h1>\n <p>\n  Modern processors like data aligned to 16-byte boundaries for various reasons; some operations may take significant performance hits otherwise, others might not work at all.\n </p>\n <p>\n  Adjusting the\n  <code>\n   main\n  </code>\n  stack frame once allows the rest of the code to run without further adjustment as long as care is taken to always allocate stack in multiples of 16 bytes before a call. That is why you will often see something like this:\n </p>\n <pre><code>sub    $0xc,%esp    # pad stack by 12 bytes\npush   %eax         # push 4-byte argument\ncall   puts\n</code></pre>\n <p>\n  <strong>\n   NB:\n  </strong>\n  The x86-64 ABI makes the 16-byte stack alignment mandatory. Incidentally this means that you\n  <em>\n   will not\n  </em>\n  find a frame adjustment on\n  <code>\n   main\n  </code>\n  in 64-bit code - the stack is already aligned.\n </p>\n</div>\n</body></html>",
            "votes": "7",
            "user": "pesco",
            "time": "Aug 3, 2018 at 15:36",
            "is_accepted": false,
            "comments": [
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">Welcome! Based on what you have written so far, I look forward to reading your future posts.</span>",
                    "time": null
                },
                {
                    "user": "pesco",
                    "text": "<span class=\"comment-copy\">Thanks! I came here to look this up and afterwards felt that, while your answer is quite elaborate, it was missing a few details. Since as a new user I couldn't comment, I took a shot at my own. Hope you don't mind! :)</span>",
                    "time": null
                },
                {
                    "user": "Evan Carroll",
                    "text": "<span class=\"comment-copy\">I like this better than @SYS_V's answer (no offense to SYS_V). I don't believe SYS_V's answer address \"what is the purpose\". It does a great job of explaining what the instructions do. The answer seems to be very very simple. Above and beyond the obvious alignment-optimization \"At the same time, the arguments to main (argc and argv) are not moved, so a pointer to them is saved in %ecx.\" Beautiful. Thanks a ton.</span>",
                    "time": null
                }
            ]
        }
    ]
}