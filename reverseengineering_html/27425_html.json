{
    "title": "Most idiot-proof method of entry to Reverse Engineer Visual/Control feed for security camera",
    "link": "https://reverseengineering.stackexchange.com/questions/27425/most-idiot-proof-method-of-entry-to-reverse-engineer-visual-control-feed-for-sec",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am looking to reverse engineer a construction security camera. I am a self-learner, and have a very general grasp on electrical engineering and coding - so I'm not entirely 'out of my element' - but I understand this is a big challenge that requires a lot of work. I am looking to eventually create an interface that will let see what the camera sees, as well as utilize its PTZ functions.\n  <strong>\n   What would be the most idiot proof method of entry to figure out the interface?\n  </strong>\n </p>\n <p>\n  The camera (or camera package I guess) in question is an\n  <a href=\"https://www.axis.com/en-us/products/axis-q6128-e\" rel=\"nofollow noreferrer\">\n   Axis PTZ camera\n  </a>\n  , which is connected to an Axis DC\n  <a href=\"https://www.axis.com/en-us/products/midspans/axis-t81b22-dc-30-w-midspan-1-port\" rel=\"nofollow noreferrer\">\n   PoE midspan\n  </a>\n  . The midspan directly plugs into a Raspberry Pi 3 Model B that bootloads directly from a micro-SD card (to me that was rather surprising). The pi then has three USB cables, two of which run to a proprietary board (which will be described and pictured below), and the third which plugs into a Sierra Wireless AirLink RV50 for transmission via wireless carrier network.\n </p>\n <p>\n  The proprietary board has two JTAG ports, a ten-pin port that connects to an\n  <a href=\"https://www.adestotech.com/wp-content/uploads/doc8784.pdf\" rel=\"nofollow noreferrer\">\n   Adesto SPI flash\n  </a>\n  , and a 20 pin JTAG that connects to a\n  <a href=\"http://www.latticesemi.com/iCE40#_21E33C7EC0BD48AA80FE384ED73CC895\" rel=\"nofollow noreferrer\">\n   Lattice Semi ICE40 HX8X FPGA chip\n  </a>\n  . The only other chips of notable manufacture is a\n  <a href=\"https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers\" rel=\"nofollow noreferrer\">\n   SILabs CP2102\n  </a>\n  , and a\n  <a href=\"https://www.ti.com/product/ADC088S022?utm_source=supplyframe&utm_medium=SEP&utm_campaign=not_alldatasheet&DCM=yes#product-details##description\" rel=\"nofollow noreferrer\">\n   TI CMOS sensor ADC\n  </a>\n  . The board also houses the power transformer and directs power to all the components.\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/biVDX.jpg\" rel=\"nofollow noreferrer\">\n   <img alt=\"A picture of the proprietary board (aside from the transformer side)\" src=\"https://i.sstatic.net/biVDX.jpg\"/>\n  </a>\n </p>\n <p>\n  There are a few points of access I could try to get access to the control system, but i am curious about all y'alls opinion.\n </p>\n <p>\n  TL;DR\n  <strong>\n   What would be more forgiving of novice blunders?\n  </strong>\n  Would it be better if I were to try to change any programming on the card? Is it better to try to decode the data as it is sent to the WIFI access point? Just curious what the best method of entry/analysis should be. Everything I have seen on the internet involves some sort of IP sniffing, but when the camera has its own unique network system via cellular carrier, and I don't know what it is transmitting... Better to not.\n </p>\n <p>\n  Hoping for the best, and excited to hear any tips you all might have.\n </p>\n <p>\n  Cheers!\nPhotovoltaeic\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "245",
    "tags": [
        "hardware"
    ],
    "user": "Photo Voltaeic",
    "time": "Apr 9, 2021 at 6:39",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I think I'd start with the Raspberry Pi.  The reason is that among the pieces you've listed, it's probably the one that has the most available documentation.\n </p>\n <h3>\n  ‚ÄúThe first rule of intelligent tinkering is to save all the pieces.‚Äù -- Aldo Leopold\n </h3>\n <p>\n  Because the Raspberry Pi boots from a MicroSD card, the first thing I'd do would be to\n  <strong>\n   make a copy of that card\n  </strong>\n  and preserve the original.  Because it's probably running Raspberry Pi OS (a Linux derivative), it would be easiest to dissect the contents of that card under Linux.  Here's a bash script to mount the two partitions of the standard format Pi image:\n </p>\n <pre><code>#!/bin/bash\n# Automatically mount a Raspberry Pi image \n\nif [[ ! $(whoami) =~ \"root\" ]]; then\n    echo \"\"\n    echo \"**********************************\"\n    echo \"*** This should be run as root ***\"\n    echo \"**********************************\"\n    echo \"\"\n    exit\nfi\n\nif [[ -z $1 ]]; then\n    echo \"Usage: ./mountimg.sh my-favorite-pi.img\"\n    exit\nfi\n\nif [[ ! -e $1 ]]; then\n    echo \"Error : Not an image file, or file doesn't exist\"\n    exit\nfi\n\nfatoffset=`parted -m $1 unit B print |sed -e 'y/B/ /'|grep fat|awk -F: '{print $2}'`\nfatlimit=`parted -m $1 unit B print |sed -e 'y/B/ /'|grep fat|awk -F: '{print $4}'`\nextoffset=`parted -m $1 unit B print |sed -e 'y/B/ /'|grep ext4|awk -F: '{print $2}'`\nextlimit=`parted -m $1 unit B print |sed -e 'y/B/ /'|grep ext4|awk -F: '{print $4}'`\necho \"fatoffset = ${fatoffset}.\"\necho \"fatlimit = ${fatlimit}.\"\necho \"exttoffset = ${extoffset}.\"\necho \"exttlimit = ${extlimit}.\"\n\nmkdir img1 img2\necho mount -t vfat -o loop,offset=${fatoffset},sizelimit=${fatlimit} \"$1\" img1\necho mount -t ext4 -o loop,offset=${extoffset},sizelimit=${extlimit} \"$1\" img2\n</code></pre>\n <p>\n  Once the copy is mounted, I'd start by looking at its boot sequence.\n </p>\n <h2>\n  What software does it load?\n </h2>\n <p>\n  Study the boot sequence of the Pi from the copy of the SD card.  Generally, the interesting bits are likely to have configuration items in\n  <code>\n   /etc\n  </code>\n  and\n  <code>\n   /boot\n  </code>\n  .  The startup sequence is\n  <a href=\"https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#boot-sequence\" rel=\"nofollow noreferrer\">\n   well documented\n  </a>\n  so you might find it useful to start there.  I have even sometimes seen source code left on a device, so you could get very lucky that way.\n </p>\n <h2>\n  What users exist on the system?\n </h2>\n <p>\n  Custom software for Raspberry Pi-based systems is often installed as either\n  <code>\n   root\n  </code>\n  or as another user.  If it's under another user, it could be the default\n  <code>\n   pi\n  </code>\n  user or it could be some newly created user.  By examining\n  <code>\n   /etc/passwd\n  </code>\n  you can see which users and systems are provisioned on the machine and get some clues as to what is running.  For example, if it has\n  <code>\n   mysql\n  </code>\n  and\n  <code>\n   mosquitto\n  </code>\n  as users, you can conclude that is has both a database and an MQTT broker which suggest further avenues for exploration.\n </p>\n <h2>\n  Try running the software\n </h2>\n <p>\n  A Raspberry Pi is a pretty inexpensive device.  I'd suggest getting one, if you don't already have one, and booting it up with your cloned SD card but no peripherals attached.  Make a note of what processes are running and look for their binary files on the SD card.\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Glorfindel",
            "time": "Jul 10, 2022 at 18:39",
            "is_accepted": true,
            "comments": [
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">Have you heard of <code>kpartx</code> üòâ?</span>",
                    "time": null
                }
            ]
        }
    ]
}