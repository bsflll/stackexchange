{
    "title": "Adobe Reader JIT Pages",
    "link": "https://reverseengineering.stackexchange.com/questions/17004/adobe-reader-jit-pages",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I use Adobe Reader XI for a little research project.\n </p>\n <p>\n  I know that Adobe use SpiderMonkey as its JS engine.\n </p>\n <p>\n  When opening a .pdf file that contains JS, the JS code is compiled in runtime in parts (JIT), to bytecode and the bytecode is mapped on the heap in pages with RW access.\nI try to understand how the bytecode then executes. Where the executable opcodes are located/mapped in runtime?\n </p>\n <p>\n  Using windbg\n  <code>\n   !address\n  </code>\n  command, I don't see any page with RX access on the heap.\n </p>\n <p>\n  What I try to do is to figure out how the JS engine works, down to the page level. Means, how the engine interprets the bytecode to executable opcodes and where do he map that executable instructions themselves, alongside how he determines where to map each time the next executable code.\n </p>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 0,
    "views": "168",
    "tags": [
        "debugging",
        "memory",
        "windbg",
        "javascript",
        "pdf"
    ],
    "user": "kvmN00bsky",
    "time": "Dec 19, 2017 at 22:33",
    "comments": [],
    "answers_data": []
}