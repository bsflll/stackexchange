{
    "title": "Decoding CalibrationL6.dll",
    "link": "https://reverseengineering.stackexchange.com/questions/31554/decoding-calibrationl6-dll",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am having problems with a dll, it is called CalibrationL6.dll, I have been able to see the code inside, and the function that interests me is this:\n </p>\n <pre><code>public static int CalculateCoefficients(\n          int[] coefficients,\n          out int negCoeffs,\n          int numPoints,\n          int selCoeffs,\n          int CalType,\n          double[] bridgeRaw,\n          double[] bridgeDesired,\n          double[] tempRaw,\n          double[] tempDesired)\n        {\n            CalData data = new CalData();\n            Vector<CalPoint> calPoints = (Vector<CalPoint>)data.calPoints;\n            LMCallbacks callbacks = new LMCallbacks();\n            lm_control_type control = new lm_control_type();\n            int index1 = 0;\n            negCoeffs = 0;\n            if (0 < numPoints)\n            {\n                do\n                {\n                    bridgeRaw[index1] = (double)Program.TwosComplementToDecimal((int)bridgeRaw[index1]);\n                    tempRaw[index1] = (double)Program.TwosComplementToDecimal((int)tempRaw[index1]);\n                    ++index1;\n                }\n                while (index1 < numPoints);\n            }\n            int index2 = 0;\n            if (0 < numPoints)\n            {\n                do\n                {\n                    if (tempRaw != null && tempDesired != null)\n                    {\n                        CalPoint calPoint;\n                        calPoint.rawB = bridgeRaw[index2];\n                        calPoint.bridge = bridgeDesired[index2];\n                        calPoint.temp = tempDesired[index2];\n                        calPoint.rawT = tempRaw[index2];\n                        calPoints.Add(calPoint);\n                    }\n                    else\n                    {\n                        CalPoint calPoint;\n                        calPoint.rawB = bridgeRaw[index2];\n                        calPoint.bridge = bridgeDesired[index2];\n                        calPoint.temp = 2000.0;\n                        calPoint.rawT = 2000.0;\n                        calPoints.Add(calPoint);\n                    }\n                    ++index2;\n                }\n                while (index2 < numPoints);\n            }\n            data.CalType = CalType;\n            data.CO_CAL = selCoeffs;\n            Map<double, double> map = new Map<double, double>();\n            List<CalPoint>.Enumerator enumerator1 = calPoints.GetEnumerator();\n            if (enumerator1.MoveNext())\n            {\n                do\n                {\n                    CalPoint current = enumerator1.Current;\n                    double key = Math.Truncate(current.temp * 10.0) / 10.0;\n                    Dictionary<double, double>.Enumerator enumerator2 = map.GetEnumerator();\n                    if (enumerator2.MoveNext())\n                    {\n                        while (Math.Abs(Map<double, double>.Key((ValueType)enumerator2.Current) - key) >= 0.1)\n                        {\n                            if (!enumerator2.MoveNext())\n                                goto label_11;\n                        }\n                        goto label_12;\n                    }\n                label_11:\n                    map[key] = current.rawT;\n                label_12:;\n                }\n                while (enumerator1.MoveNext());\n            }\n            if (map.Size < 3)\n                data.CO_CAL &= -561;\n            if (map.Size < 2)\n                data.CO_CAL &= -269;\n            double[] par = new double[10];\n            par[0] = 0.0;\n            data.cos[0] = 0.0;\n            data.cos[1] = 65536.0;\n            data.cos[2] = 0.0;\n            data.cos[3] = 0.0;\n            data.cos[4] = 0.0;\n            data.cos[5] = 0.0;\n            data.cos[6] = 0.0;\n            data.cos[7] = 0.0;\n            data.cos[8] = 32768.0;\n            data.cos[9] = 0.0;\n            data.zero_point = 8388608.0;\n            int[] numArray = new int[4] { 2, 4, 6, 7 };\n            int num = 0;\n            do\n            {\n                data.CalType = CalType;\n                int index3 = 0;\n                do\n                {\n                    int n_par = 0;\n                    int index4 = 0;\n                    if (0 < numArray[index3])\n                    {\n                        do\n                        {\n                            if ((data.CO_CAL >> index4 & 1) != 0)\n                            {\n                                par[n_par] = data.cos[index4];\n                                ++n_par;\n                            }\n                            else\n                                data.cos[index4] = (double)coefficients[index4];\n                            ++index4;\n                        }\n                        while (index4 < numArray[index3]);\n                    }\n                    data.calcTo = numArray[index3];\n                    control.Initialize();\n                    //< Module >.lm_minimize(((Vector<CalPoint>)calPoints).Size, n_par, par, (ILMCallbacks)callbacks, (lm_data_type)data, control);\n                    int index5 = 0;\n                    int index6 = 0;\n                    if (0 < numArray[index3])\n                    {\n                        do\n                        {\n                            if ((data.CO_CAL >> index6 & 1) != 0)\n                            {\n                                data.cos[index6] = par[index5];\n                                ++index5;\n                            }\n                            ++index6;\n                        }\n                        while (index6 < numArray[index3]);\n                    }\n                    ++index3;\n                }\n                while (index3 < 4);\n                data.CalType = 2;\n                int n_par1 = 0;\n                int index7 = 7;\n                do\n                {\n                    if ((data.CO_CAL >> index7 & 1) != 0)\n                    {\n                        par[n_par1] = data.cos[index7];\n                        ++n_par1;\n                    }\n                    else\n                        data.cos[index7] = (double)coefficients[index7];\n                    ++index7;\n                }\n                while (index7 <= 9);\n                control.Initialize();\n                //< Module >.lm_minimize(((Vector<CalPoint>)calPoints).Size, n_par1, par, (ILMCallbacks)callbacks, (lm_data_type)data, control);\n                int index8 = 0;\n                int index9 = 7;\n                do\n                {\n                    if ((data.CO_CAL >> index9 & 1) != 0)\n                    {\n                        data.cos[index9] = par[index8];\n                        ++index8;\n                    }\n                    ++index9;\n                }\n                while (index9 <= 9);\n                int index10 = 0;\n                do\n                {\n                    coefficients[index10] = (int)data.cos[index10];\n                    ++index10;\n                }\n                while (index10 < 10);\n                int coefficient = coefficients[6];\n                if (coefficient < 0)\n                {\n                    if (coefficient < -8388607)\n                    {\n                        coefficients[6] = -8388607;\n                        data.CO_CAL &= -65;\n                        data.cos[6] = 0.0;\n                    }\n                    else\n                        break;\n                }\n                else if (coefficient > 536870911)\n                {\n                    coefficients[6] = 33554431;\n                    data.CO_CAL &= -65;\n                }\n                else\n                    break;\n                ++num;\n            }\n            while (num < 2);\n            if (coefficients[0] < 0)\n                negCoeffs |= 64;\n            if (coefficients[7] < 0)\n                negCoeffs |= 128;\n            if (coefficients[9] < 0)\n                negCoeffs |= 8;\n            if (coefficients[4] < 0)\n                negCoeffs |= 2;\n            if (coefficients[5] < 0)\n                negCoeffs |= 4;\n            if (coefficients[3] < 0)\n                negCoeffs |= 16;\n            if (coefficients[2] < 0)\n                negCoeffs |= 32;\n            return 0;\n\n        }\n</code></pre>\n <p>\n  But I have problems with a function and a class that is:\n </p>\n <pre><code>< Module >.lm_minimize(((Vector<CalPoint>)calPoints).Size, n_par1, par, (ILMCallbacks)callbacks, (lm_data_type)data, control);\n\n</code></pre>\n <p>\n  I can't find the class  and I don't know what it refers to... it would be very useful if you can help me find a solution...\n </p>\n <p>\n  Thanks\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 0,
    "views": "89",
    "tags": [
        "dll",
        "c#"
    ],
    "user": "raulelerma",
    "time": "Feb 15, 2023 at 18:23",
    "comments": [
        {
            "user": "Rup",
            "text": "<html><body><span class=\"comment-copy\">\n Which decompiler are you using? I'd guess worst case you can do an export-all-sources and grep them for lm_minimize. I'd think most tools would let you double-click on lm_minimize and it'll take you to the definition though.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "raulelerma",
            "text": "<html><body><span class=\"comment-copy\">\n Yes i can check lm_minimize function but it has unreadable code (hexadecimal, binary, etc.) i used two decompilers.. JetBrains dotPeek and Telerik JustDecompile\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Gu Rocky",
            "text": "<html><body><span class=\"comment-copy\">\n Could you provide the dll? I would like to try it.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}