{
    "title": "Why does vmt hooking not work with instance member in the following case?",
    "link": "https://reverseengineering.stackexchange.com/questions/20481/why-does-vmt-hooking-not-work-with-instance-member-in-the-following-case",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <strong>\n   Why does the function not get hooked when called with instance member obj.myFunc() ?\n  </strong>\n </p>\n <pre><code>class Myclass\n{\n\npublic:\n    virtual void myFunc() = 0;\n\n};\nclass Derived : public Myclass\n{\npublic:\n    void myFunc()\n    {\n        std::cout << \"Actual method is called\" << std::endl;\n    }\n};\n\n    void __fastcall hk_myFunc(void* thisPtr, int edx)\n    {\n        std::cout << \"Hooked method is called\" << std::endl;\n    }\n\ntypedef void(__thiscall *fPtr)();\n\nint main()\n{\n    Derived* ptr = new Derived();\n    ptr->myFunc();// Output : Actual method is called.\n    void** vTPtr = *(reinterpret_cast<void ***>(ptr));\n    DWORD oldProtection;\n    VirtualProtect(vTPtr, 4, PAGE_EXECUTE_READWRITE, &oldProtection);\n    *vTPtr = reinterpret_cast<fPtr>(&hk_myFunc);\n    VirtualProtect(vTPtr, 4, oldProtection, 0);\n    ptr->myFunc(); //Output: Hooked method is called\n    Derived obj = *ptr;\n    obj.myFunc(); // Output : Actual method is called. Why ??\n    return 0;\n}\n</code></pre>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "144",
    "tags": [
        "function-hooking",
        "hooking"
    ],
    "user": "kk ll",
    "time": "Jan 27, 2019 at 15:19",
    "comments": [
        {
            "user": "Milhous",
            "text": "<html><body><span class=\"comment-copy\">\n Have you tried disassembling the output and looking at the differences?\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The problem is the way you reference this object with a new pointer.\n </p>\n <pre><code>Derived obj = *ptr;\n</code></pre>\n <p>\n  This actually creates a new object utilizing the data of the old object. Yay! C++!\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/Ev6Nc.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"IDA Decompilation\" src=\"https://i.sstatic.net/Ev6Nc.png\"/>\n  </a>\n </p>\n <p>\n  In line 27 you can see that a new object is generated by calling a constructor. If you have a look at the disassembly, you'll see the vtable is not used for the function call. Hence you end up with the non-modified function.\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/n9QHa.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"disassembly\" src=\"https://i.sstatic.net/n9QHa.png\"/>\n  </a>\n </p>\n <p>\n  Btw, when you change the line referenced above to\n </p>\n <pre><code>(*ptr).myFunc();\n</code></pre>\n <p>\n  The output works as expected\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Nordwald",
            "time": "Jan 30, 2019 at 5:40",
            "is_accepted": true,
            "comments": []
        }
    ]
}