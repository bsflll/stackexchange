{
    "title": "Heap Chunk Structure Does Not Contain Previous Section Info",
    "link": "https://reverseengineering.stackexchange.com/questions/19293/heap-chunk-structure-does-not-contain-previous-section-info",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm reading\n  <a href=\"https://www.wiley.com/en-us/The+Shellcoder%27s+Handbook%3A+Discovering+and+Exploiting+Security+Holes%2C+2nd+Edition-p-9780470080238\" rel=\"nofollow noreferrer\">\n   Shellcoder's Handbook\n  </a>\n  to learn more about exploitation and overflows. I reached the chapter on Heap Overflows. The book mentions that a heap is split into chunks where each chunk contains two important pieces of info:\n </p>\n <ul>\n  <li>\n   The size of the previous chunk, if allocated\n  </li>\n  <li>\n   Size of current chunck\n  </li>\n  <li>\n   Data\n  </li>\n </ul>\n <p>\n  The following image is taken from a\n  <a href=\"http://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf\" rel=\"nofollow noreferrer\">\n   Blackhat presentation\n  </a>\n  <a href=\"https://i.sstatic.net/M5AM5.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/M5AM5.png\"/>\n  </a>\n </p>\n <p>\n  I made a small demo to test this. Below is the code:\n </p>\n <pre><code>    1 #include <stdio.h>\n    2 #include <string.h>\n    3 #include <stdlib.h>\n    4\n    5 int\n    6 main (int argc, char *argv[]){\n    7     char *buf, *buf2;\n    8\n    9     buf = (char *) malloc(1024);\n   10     buf2 = (char *) malloc(1024);\n   11\n   12     printf(\"buf=%p\n\", buf);\n   13     printf(\"buf2=%p\n\", buf2);\n   14     strcpy(buf, argv[1]);\n   15     strcpy(buf2, argv[2]);\n   16     printf(\"buf=%s\n\", buf);\n   17     printf(\"buf2=%s\n\", buf2);\n   18     free(buf2);\n   19     return 0;\n   20 }\n</code></pre>\n <p>\n  I've placed a breakpoint on line 18 and checked the memory. Here's the dump after running the following command:\n </p>\n <p>\n  <code>\n   ./basicheap $(python -c 'print(\"A\"*1000 + \" \" +\"XXXXABCDEFGH\")')\n  </code>\n </p>\n <p>\n  This is the memory dump of\n  <code>\n   buf1\n  </code>\n  :\n </p>\n <pre><code>[0x08048543]> pxw 0x50 @ [fcnvar.local_1ch]-8\n0x0804b158  0x00000000 0x00000411 0x41414141 0x41414141  ........AAAAAAAA\n0x0804b168  0x41414141 0x41414141 0x41414141 0x41414141  AAAAAAAAAAAAAAAA\n0x0804b178  0x41414141 0x41414141 0x41414141 0x41414141  AAAAAAAAAAAAAAAA\n0x0804b188  0x41414141 0x41414141 0x41414141 0x41414141  AAAAAAAAAAAAAAAA\n0x0804b198  0x41414141 0x41414141 0x41414141 0x41414141  AAAAAAAAAAAAAAAA\n</code></pre>\n <p>\n  This is the memory dump of\n  <code>\n   buf2\n  </code>\n  :\n </p>\n <pre><code>[0x08048543]> pxw 0x50 @ [fcnvar.local_20h]-8\n0x0804b568  0x00000000 0x00000411 0x58585858 0x44434241  ........XXXXABCD\n0x0804b578  0x48474645 0x00000000 0x00000000 0x00000000  EFGH............\n0x0804b588  0x00000000 0x00000000 0x00000000 0x00000000  ................\n0x0804b598  0x00000000 0x00000000 0x00000000 0x00000000  ................\n0x0804b5a8  0x00000000 0x00000000 0x00000000 0x00000000  ................\n</code></pre>\n <p>\n  The output shows\n  <code>\n   0x411\n  </code>\n  as the size of the both chunk, which is 1024 + 17 bits for whatever. This is the the first (and only) piece of information in the header for both chunks.\n </p>\n <p>\n  However, I don't see any info relating to any previous chunks. In\n  <em>\n   Shellcoder's\n  </em>\n  , the author is trying to demonstrate how one can overflow\n  <code>\n   buf1\n  </code>\n  to overwrite the header info of\n  <code>\n   buf2\n  </code>\n  .\n </p>\n <p>\n  Did the writers of glibc forgo the size of previous chunk in the header info, or is it something I'm missing?\n </p>\n <p>\n  P.S: The build command I used was\n  <code>\n   gcc -no-pie -g basicheap.c -o basicheap\n  </code>\n </p>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 1,
    "views": "1k",
    "tags": [
        "binary-analysis",
        "radare2",
        "exploit",
        "shellcode",
        "heap"
    ],
    "user": "Solidak",
    "time": "Sep 8, 2018 at 16:18",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The diagram you linked to seems to be wrong.\n  <strong>\n   The size of the previous chunk is stored in the current chunk iff, the previous chunk is free\n  </strong>\n  .\n </p>\n <p>\n  This image is more appropriate of what an allocated heap chunk looks like.\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/so4y7.png\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/so4y7.png\"/>\n  </a>\n </p>\n <p>\n  <sub>\n   Source:\n   <a href=\"https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/\" rel=\"noreferrer\">\n    https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/\n   </a>\n  </sub>\n </p>\n <p>\n  Lets take the following code to demonstrate this.\n </p>\n <pre><code>#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main (int argc, char *argv[])\n{\n    char *buf1, *buf2, *buf3;\n    buf1 = (char *) malloc(1024);\n    buf2 = (char *) malloc(1024);\n    buf3 = (char *) malloc(1024);\n\n    printf(\"buf1=%p\n\", buf1);\n    printf(\"buf2=%p\n\", buf2);\n    printf(\"buf3=%p\n\", buf3);\n\n    memset(buf1, 'A', 1024);\n    memset(buf2, 'B', 1024);\n    memset(buf3, 'C', 1024);\n\n    free(buf2);\n    return 0;\n}\n</code></pre>\n <p>\n  Note: Instead of two chunks, I'm taking three chunks or otherwise freeing the first may coalesce it into the top chunk. We will free the middle chunk and examine the chunk contents before and after the\n  <code>\n   free\n  </code>\n  call is executed.\n </p>\n <p>\n  The binary was compiled with\n  <code>\n   gcc -m32 -g ./heap.c\n  </code>\n  . Debug the binary in gdb as you would normally and set a breakpoint on line 20 at the\n  <code>\n   free(buf2)\n  </code>\n  call.\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/CJyx9.png\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/CJyx9.png\"/>\n  </a>\n </p>\n <p>\n  When the breakpoint hit, let's examine the three chunks.\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/gJQm2.png\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/gJQm2.png\"/>\n  </a>\n </p>\n <p>\n  <code>\n   malloc\n  </code>\n  returns the pointer to\n  <code>\n   chunk + 8\n  </code>\n  , so we subtracted 8 from each of the addresses. Additionally, I've also highlighted the chunk sizes (2nd member of a heap chunk) in the above image.\n </p>\n <p>\n  However the chunk sizes are not actually\n  <code>\n   0x409\n  </code>\n  . Glibc heap chunks are always aligned to 8 bytes which means the last three bits are always zero. Hence, these three bits are used for storing other information (\n  <code>\n   A\n  </code>\n  ,\n  <code>\n   M\n  </code>\n  and\n  <code>\n   P\n  </code>\n  bits).\n </p>\n <p>\n  <code>\n   0x409\n  </code>\n  when converted to binary comes out to be\n  <code>\n   100 0000 1001\n  </code>\n  .\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/JuOf7.png\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/JuOf7.png\"/>\n  </a>\n </p>\n <p>\n  To get the true chunk size we have to discard the last three bits (\n  <code>\n   A\n  </code>\n  <code>\n   M\n  </code>\n  <code>\n   P\n  </code>\n  ) i.e. we should consider only\n  <code>\n   100 0000 1000\n  </code>\n  . When this is converted to decimal we get 1032.\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/84kOZ.png\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/84kOZ.png\"/>\n  </a>\n </p>\n <p>\n  The true chunk size is indeed 1032. 1024 bytes for our data and the other 8 for the first two members.\n </p>\n <p>\n  Coming back to gdb, lets step over the\n  <code>\n   free\n  </code>\n  call and examine the chunks once again.\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/vV7ws.png\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/vV7ws.png\"/>\n  </a>\n </p>\n <p>\n  Chunk 2 has been freed. Let's have a look at chunk 3 (\n  <code>\n   buf3\n  </code>\n  ).\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/NHdyo.png\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/NHdyo.png\"/>\n  </a>\n </p>\n <p>\n  The first member of chunk 3 now contains\n  <code>\n   0x408\n  </code>\n  which is\n  <code>\n   1032\n  </code>\n  in decimal - this is the size of chunk 2.\n  <strong>\n   Thus the previous size is stored in chunk 3 only after chunk 2 has been freed, not when it is in-use\n  </strong>\n  .\n </p>\n <p>\n  The\n  <code>\n   P\n  </code>\n  bit I was referring before stands for\n  <code>\n   PREV_INUSE\n  </code>\n  . This bit is set when the previous chunk is in use. Since the previous chunk is now free this bit is set to 0. As a result the second member now also contains\n  <code>\n   0x408\n  </code>\n  (instead of\n  <code>\n   0x409\n  </code>\n  ) which equals\n  <code>\n   100 0000 1000\n  </code>\n  .\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/EdYy9.png\" rel=\"noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/EdYy9.png\"/>\n  </a>\n </p>\n <p>\n  As shown in the image above, the\n  <code>\n   P\n  </code>\n  bit is unset. Hope, this clears your understanding.\n </p>\n</div>\n</body></html>",
            "votes": "9",
            "user": "0xec",
            "time": "Sep 8, 2018 at 21:14",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Solidak",
                    "text": "<span class=\"comment-copy\">This was superb! Thank you so much for the effort!</span>",
                    "time": null
                }
            ]
        }
    ]
}