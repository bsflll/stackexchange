{
    "title": "Mysterious bytecode (executable?) file from a chinese decibel meter whose manufacturer has been hacked &/or gone bankrupt",
    "link": "https://reverseengineering.stackexchange.com/questions/9309/mysterious-bytecode-executable-file-from-a-chinese-decibel-meter-whose-manufa",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I bought a decibel meter off amazon recently (\n  <a href=\"http://rads.stackoverflow.com/amzn/click/B00CPKSE38\" rel=\"nofollow noreferrer\">\n   http://www.amazon.com/Sound-Measure-Tester-Pressure-Decibel/dp/B00CPKSE38/ref=sr_1_1?ie=UTF8&qid=1436376590&sr=8-1&keywords=wensn\n  </a>\n  ) which outputs db measurements to a microsd card. I opened the sd card's content on my computer and encountered four separate *.wsn files, two of which I created and the other two apparently made by the manufacturer in testing perhaps. Anyway, did a google search for the .wsn file extension and can't find anything but something called a \"whoopsie skin file\" which doesn't appear to be what I'm looking for. Can anyone help me find a way to parse this file? I imagine it simply contains a table of information with two columns (db level and time)\n </p>\n <p>\n  Here's the link to a sample of the file. It is time series data for just a couple of seconds from the decibel meter.\n  <a href=\"https://drive.google.com/file/d/0B0yWXI3LgLr4ME1DeUs4SDFMX1E/view?usp=sharing\" rel=\"nofollow noreferrer\">\n   https://drive.google.com/file/d/0B0yWXI3LgLr4ME1DeUs4SDFMX1E/view?usp=sharing\n  </a>\n </p>\n <p>\n  Update:\nThe db measurement device's manufacturer is \"wensn\", which clearly accounts for the file name extension. I've found two leads so far:\n </p>\n <ul>\n  <li>\n   <a href=\"http://www.wensn.com/html_products/digital-Sound-level-meter-WS1361-17.html\" rel=\"nofollow noreferrer\">\n    manufacture website for device (not very helpful, in fact it has been HACKED)\n   </a>\n  </li>\n  <li>\n   <a href=\"http://opensource.ebswift.com/RaspiMonitor/wensn/\" rel=\"nofollow noreferrer\">\n    reverse engineering wensn usb stream data (pretty advanced stuff)\n   </a>\n  </li>\n  <li>\n   <a href=\"https://github.com/jeroensteenhuis/wensn\" rel=\"nofollow noreferrer\">\n    wensn usb stream github parsing project in python\n   </a>\n  </li>\n </ul>\n <p>\n  but both are for parsing usb streams of *.tmp files from the device, rather than the static wsn files. I'm guessing I could utilize this code to parse the wsn files, but I don't know how to do that yet. Honestly I'm in way over my head at this point.\n </p>\n <p>\n  I first posted this question meta.stackexchange, you can find that discussion\n  <a href=\"https://meta.stackexchange.com/questions/260286/i-have-a-mysterious-bytecode-executable-file-whose-extension-is-nowhere-on-th?noredirect=1#comment848624_260286\">\n   here\n  </a>\n  . The expected output data is columnar, time and decibel level, as seems to be indicated\n  <a href=\"http://opensource.ebswift.com/RaspiMonitor/wensn/\" rel=\"nofollow noreferrer\">\n   here\n  </a>\n  .\n </p>\n <p>\n  Update 2:\nI think there may be a way to decode this file using the '\n  <a href=\"http://www.sigrok.org\" rel=\"nofollow noreferrer\">\n   sigrok\n  </a>\n  ' utility, which is used to read all sorts of serial outputs from scientific sensors.\n </p>\n</div>\n</body></html>",
    "votes": "5",
    "answers": 5,
    "views": "1k",
    "tags": [
        "executable",
        "byte-code"
    ],
    "user": "boulder_ruby",
    "time": "Mar 20, 2017 at 10:32",
    "comments": [
        {
            "user": "Carcigenicate",
            "text": "<html><body><span class=\"comment-copy\">\n Out of curiosity, how do you know that it's been hacked?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "boulder_ruby",
            "text": "<html><body><span class=\"comment-copy\">\n I am not currently pursuing the amateur noise study project because the damned device cut off and the data was only for a few seconds, then all of a sudden the noise study was moot for other business reasons. I still have the equipment and may try to do a study again. I will mark the correct answer as the one that leads to me cracking the puzzle. Until then, this question appears to be helping a lot of people and that is good\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  This is a hex dump of your sample file:\n </p>\n <pre><code>00000000  1F DA 51 A0 19 5A 52 A0  19 DA 52 A0 28 5A 53 A0  ..Q..ZR...R.(ZS.\n00000010  28 DA 53 A0 24 5A 54 A0  1A DA 54 A0 2A 5A 55 A0  (.S.$ZT...T.*ZU.\n00000020  26 DA 55 A0 26 5A 56 A0  08 DA 56 A0 47 5A 57 A0  &.U.&ZV...V.GZW.\n00000030  35 DA 57 A0 32 5A 58 A0  3B DA 58 A0              5.W.2ZX.;.X.\n</code></pre>\n <p>\n  As you can see, the file clearly has a pattern where 4 bytes seem to repeat:\n- Byte one goes up and down, and might have to do with the sound level\n- Byte two alternates between DA and 5A - note DA is just a 5A with the highest bit set\n- Byte three seems to be slowly ascending, maybe a time indicator\n- Byte four is A0 and might be the high order byte of the time.\n </p>\n <p>\n  However, without any information about the sound level that has been recorded, or some expected values from the raw bytes, every guess is quite hard to verify. It would be really helpful if you could use the software that comes with the device, open the file with it, and tell us whatever the software makes of that data.\n </p>\n <p>\n  Btw, the german vendor Voelkner (they are reputable and i bought from them on several occasions) has a\n  <a href=\"http://files.voelkner.de/300000-324999/303791-an-01-ml-Omnitronic_SLM_700_de_en.pdf\">\n   german/english PDF manual of the product\n  </a>\n  , which refers to www.omnitronic.com for the newest version. That web site forwards to a shop that sold the product, doesn't have it in stock anymore, but still has a\n  <a href=\"http://eshop.steinigke.de/en//SLM-700-SPL-meter/category-/product-ARTI_10360610.html\">\n   download page for manual and software\n  </a>\n  . The product looks slightly different, but has the same overall layout and key positions, so there is reason to assume it's the same electronics in a slightly different plastic case, and the software might work for you and even be better than whatever came with your device - the amazon reviews says the software is in chinese and lacks a driver; the zip on \"my\" download page includes a \"Vista Driver\" folder and an installer that seems to support english.\n </p>\n</div>\n</body></html>",
            "votes": "7",
            "user": "Guntram Blohm",
            "time": "Jul 8, 2015 at 21:47",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  This is the file in hex format (done with vi and\n  <code>\n   :%!xxd\n  </code>\n  ; I added the column numbers  myself):\n </p>\n <pre><code>          0 1  2 3  4 5  6 7  8 9  a b  c d  e f\n0000000: 1fda 51a0 195a 52a0 19da 52a0 285a 53a0  ..Q..ZR...R.(ZS.\n0000010: 28da 53a0 245a 54a0 1ada 54a0 2a5a 55a0  (.S.$ZT...T.*ZU.\n0000020: 26da 55a0 265a 56a0 08da 56a0 475a 57a0  &.U.&ZV...V.GZW.\n0000030: 35da 57a0 325a 58a0 3bda 58a0 0a         5.W.2ZX.;.X..\n</code></pre>\n <p>\n  As you can see the bytes with odd indexes are all\n  <code>\n   da\n  </code>\n  ,\n  <code>\n   a0\n  </code>\n  ,\n  <code>\n   5a\n  </code>\n  ,\n  <code>\n   a0\n  </code>\n  , with a period of 8 bytes (half a line). This doesn't look like the\n  <a href=\"http://opensource.ebswift.com/RaspiMonitor/wensn/\" rel=\"nofollow noreferrer\">\n   data on the usb stream\n  </a>\n  , so that link or the Python project are probably not going to help you much:\n </p>\n <p>\n  <img alt=\"enter image description here\" src=\"https://i.sstatic.net/del2B.png\"/>\n </p>\n <p>\n  Furthermore, there seems to be a counter in columns\n  <code>\n   2\n  </code>\n  and\n  <code>\n   a\n  </code>\n  :\n  <code>\n   51\n  </code>\n  ,\n  <code>\n   52\n  </code>\n  ,\n  <code>\n   53\n  </code>\n  , ... The bytes in columns\n  <code>\n   6\n  </code>\n  and\n  <code>\n   a\n  </code>\n  are the same. The bytes in column\n  <code>\n   e\n  </code>\n  and\n  <code>\n   2\n  </code>\n  are also the same, but with 2 difference, showing us that this part is not very well aligned. A nicer alignment to further reverse engineer would be to shift column\n  <code>\n   e\n  </code>\n  to the leftmost position or so.\n </p>\n <p>\n  You could get a larger sample to see if\n  <code>\n   da\n  </code>\n  ,\n  <code>\n   a0\n  </code>\n  and\n  <code>\n   5a\n  </code>\n  are constants or that they are part of the counter, or possibly something else. For example, it could also be that they are actually part of the measurement, but seem to be constant here because the sound level on the moment of measurement was constant.\n </p>\n <p>\n  In any case, it seems at this point that only columns\n  <code>\n   0\n  </code>\n  ,\n  <code>\n   4\n  </code>\n  ,\n  <code>\n   8\n  </code>\n  and\n  <code>\n   c\n  </code>\n  carry data. Once you have confirmed that hypothesis (by looking at more data), you could start generating sounds and see how the data you see relates to the sounds you generate.\n </p>\n <p>\n  Considering that the manufacturer uses its own name as an extension, it is unlikely this file has some common-used table format, so I can't give you more tips than this.\n </p>\n <p>\n  A note about the hex editor. As said, I used vi with xxd (i.e. open the file in vi and then\n  <code>\n   :%!xxd\n  </code>\n  ). However, there are plenty of hex editors, also for Windows. I don't know of any that allows you to shift the start column, which would be useful to check alignment.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": null,
            "time": "Jul 8, 2015 at 21:51",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Your file seems to go like:\n </p>\n <pre><code>51A0\n52A0\n52A0\n53A0\n53A0\n</code></pre>\n <p>\n  _\n </p>\n <pre><code>52A0 = 20:02:36\n53A0 = 20:02:38 in dos time\n</code></pre>\n <p>\n  If its dos time it would make sense why every pattern(51A0, 52A0) is shown 2 times since dos time doesnt accept odd numbers as seconds.\n </p>\n <p>\n  <strong>\n   Theory 1:\n  </strong>\n </p>\n <p>\n  I dont think anything natural such as sound would go DA,5A,DA,5A,DA,5A,DA,5A,DA,5A.\n </p>\n <p>\n  So I assume that DA shows the lower part and 5A is the higher part. (DA=+0 and 5A=+1)\n </p>\n <pre><code>5A 52 A0 = 20:02:36\nDA 52 A0 = 20:02:37\n5A 53 A0 = 20:02:38\nDA 53 A0 = 20:02:39\n</code></pre>\n <p>\n  I'm dont know alot about measuring sound but I can make assumptions based on the first byte too. But this maybe wrong since you didnt give  any information about the sound you captured.\n </p>\n <p>\n  1st byte is Max: 0x47(71) Min: 0x8(8) on your file.\n </p>\n <p>\n  On the amazon page it says (30 ~ 130 Db)\n </p>\n <p>\n  8 wouldnt fit those ranges so I assume the first byte is an offset.\n </p>\n <p>\n  130-30=100 -> 0 > x > 100.\n </p>\n <p>\n  Every 4 byte has this information:\n </p>\n <pre><code>struct Frame{\n  char SoundOffset;\n  char TimeOffset;\n  char DosTime[2];\n}\n</code></pre>\n <p>\n  I wrote a sample code for your data.\n </p>\n <pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include <Windows.h>\n#include <string>\n#include <iostream>  \n#include <fstream>\n#include <iostream>\n\nusing namespace std;\n\n\nstruct DosTime{\n    int hour, minute, second;\n    DosTime(char a1, char a2){\n        char y[2] = { a1, a2 };\n        INT16 * b = (INT16*)y;\n        second = 2 * (*b & 31);\n        minute = (*b & 2016) >> 5;\n        hour = (*b & 63488) >> 11;\n    }\n    DosTime(){\n        hour = 0;\n        minute = 0;\n        second = 0;\n    }\n};\nstruct Frame{\n    char SoundOffset;\n    char TimeOffset;\n    char DosTime[2];\n};\nstruct ConvertedFrame{\n    int soundDB;\n    DosTime time;\n    void print(){\n        cout << \"Sound Level: \" << soundDB << \" dB @ \";\n        cout.fill('0'); cout.width(2); cout << time.hour;\n        cout << \":\";\n        cout.fill('0'); cout.width(2); cout << time.minute;\n        cout << \":\";\n        cout.fill('0'); cout.width(2); cout << time.second;\n        cout << endl;\n    }\n};\nint main(int argc, char* argv[])\n{\n\n    int bytecount = 0;\n\n    ifstream inFile;\n    inFile.open(\"FG8U0235.wsn\", ios::in | ios::binary | ios::ate);\n    inFile.seekg(0, ios::end);\n    bytecount = inFile.tellg();\n    inFile.seekg(0, ios::beg);\n\n    char * buffer = new char[bytecount];\n    inFile.read(buffer, bytecount);\n\n    ConvertedFrame * frames = new ConvertedFrame[bytecount / 4];\n    for (int i = 0; i < bytecount; i += 4){\n        ConvertedFrame _con;\n        Frame f;\n        memcpy(&f, &buffer[i], 4);\n        DosTime _t = DosTime(f.DosTime[0], f.DosTime[1]);\n        if (f.TimeOffset == '\\xDA')\n            _t.second++;\n        _con.time = _t;\n        _con.soundDB = ((int)f.SoundOffset) + 30;\n        frames[i / 4] = _con;\n        _con.print();\n    }\n    system(\"pause\");\n    return 0;\n\n}\n</code></pre>\n <p>\n  Which outputs:\n </p>\n <pre><code>Sound Level: 61 dB @ 20:02:35\nSound Level: 55 dB @ 20:02:36\nSound Level: 55 dB @ 20:02:37\nSound Level: 70 dB @ 20:02:36\nSound Level: 70 dB @ 20:02:39\nSound Level: 66 dB @ 20:02:40\nSound Level: 56 dB @ 20:02:41\nSound Level: 72 dB @ 20:02:42\nSound Level: 68 dB @ 20:02:43\nSound Level: 68 dB @ 20:02:44\nSound Level: 38 dB @ 20:02:45\nSound Level: 101 dB @ 20:02:46\nSound Level: 83 dB @ 20:02:47\nSound Level: 80 dB @ 20:02:48\nSound Level: 89 dB @ 20:02:49\n</code></pre>\n <p>\n  <strong>\n   Theory 2:\n  </strong>\n </p>\n <p>\n  On the site you gave us (\n  <a href=\"http://opensource.ebswift.com/RaspiMonitor/wensn/\" rel=\"nofollow\">\n   http://opensource.ebswift.com/RaspiMonitor/wensn/\n  </a>\n  ), there was this function (\n  <strong>\n   dB = (byte1 + ((byte2 & 3) * 256)) * 0.1 + 30\n  </strong>\n  ) that made me think that maybe the 2nd byte is actually not the timeoffset but the 2nd byte for the dB.\n </p>\n <p>\n  This makes dB Float instead of Integer which would make much more sense. Also the output I got from the 2nd theory felt much better so I assume this is the correct answer.\n </p>\n <pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include <Windows.h>\n#include <string>\n#include <fstream>\n#include <iostream>\n\nusing namespace std;\n\nstruct DosTime{\n    int hour, minute, second;\n    INT16 data;\n    DosTime(char a1, char a2){\n        char y[2] = { a1, a2 };\n        INT16 * b = (INT16*)y;\n        second = 2 * (*b & 31);\n        minute = (*b & 2016) >> 5;\n        hour = (*b & 63488) >> 11;\n        data = *b;\n    }\n    DosTime(){\n        hour = 0;\n        minute = 0;\n        second = 0;\n    }\n};\nstruct Frame{\n    char SoundOffset;\n    char precisionOffset;\n    char DosTime[2];\n};\nstruct ConvertedFrame{\n    float soundDB;\n    DosTime time;\n    void print(){\n        cout << \"Sound Level: \";\n        cout << soundDB;\n        if ((((int)soundDB) - soundDB) == 0) cout << \".0\";\n        cout << \" dB @ \";\n        cout.fill('0'); cout.width(2); cout << time.hour;\n        cout << \":\";\n        cout.fill('0'); cout.width(2); cout << time.minute;\n        cout << \":\";\n        cout.fill('0'); cout.width(2); cout << time.second;\n        cout << endl;\n    }\n};\nint main(int argc, char* argv[])\n{\n    int bytecount = 0;\n\n    ifstream inFile;\n    inFile.open(\"FG8U0235.wsn\", ios::in | ios::binary | ios::ate);\n    inFile.seekg(0, ios::end);\n    bytecount = inFile.tellg();\n    inFile.seekg(0, ios::beg);\n\n    char * buffer = new char[bytecount];\n    inFile.read(buffer, bytecount);\n\n\n    ConvertedFrame * frames = new ConvertedFrame[bytecount / 4];\n\n\n    INT16 lastTime = 0;\n    for (int i = 0; i < bytecount; i += 4){\n        ConvertedFrame _con;\n        Frame f;\n        memcpy(&f, &buffer[i], 4);\n        DosTime _t = DosTime(f.DosTime[0], f.DosTime[1]);\n        if (lastTime == _t.data) _t.second++;\n        lastTime = _t.data;\n        _con.time = _t;\n        _con.soundDB = (f.SoundOffset + ((f.precisionOffset & 3) * 256)) * 0.1 + 30;\n        frames[i / 4] = _con;\n        _con.print();\n    }\n    system(\"pause\");\n    return 0;\n\n}\n</code></pre>\n <p>\n  Output:\n </p>\n <pre><code>Sound Level: 84.3 dB @ 20:02:34\nSound Level: 83.7 dB @ 20:02:36\nSound Level: 83.7 dB @ 20:02:37\nSound Level: 85.2 dB @ 20:02:38\nSound Level: 85.2 dB @ 20:02:39\nSound Level: 84.8 dB @ 20:02:40\nSound Level: 83.8 dB @ 20:02:41\nSound Level: 85.4 dB @ 20:02:42\nSound Level: 85.0 dB @ 20:02:43\nSound Level: 85.0 dB @ 20:02:44\nSound Level: 82.0 dB @ 20:02:45\nSound Level: 88.3 dB @ 20:02:46\nSound Level: 86.5 dB @ 20:02:47\nSound Level: 86.2 dB @ 20:02:48\nSound Level: 87.1 dB @ 20:02:49\n</code></pre>\n <p>\n  <strong>\n   Notes:\n  </strong>\n  To find which one is the correct one you need to write dB into a paper or something and then compare with the output you get from both codes.\n </p>\n <p>\n  Also you need to do the cleanup of ConvertedFrame * frames and char * buffer if you use this code and want to prevent memory leaks. I wrote this code pretty fast @ 4 am just to test the theory.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "user2596732",
            "time": "Jul 16, 2015 at 8:04",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have buy a decibel meter Koolertron SL1361 from Amazon and it's produce files  *.wsn, but software don't work so I use this notes to understand.\nThe last theory 2 it's right, every sample data is 4 bytes long.\n </p>\n <p>\n  Assuming that the 32 bit(four byte) is named bit31-0, here my decode:\n </p>\n <p>\n  Bit 31-24 & 17-16  Value in Db (10 bits), must be divide by 10 and after add 30 to obtain the correct value \nBit 22 filter mode 0=Fast 1=Slow\nBit 21 filter mode 0=A 1=C\nBit 12-8 & 23 = seconds \nBit 7-3  = hours\nbit 2-0 & 15-13 = minutes\n </p>\n <p>\n  They are coding in positive binary.\n </p>\n <p>\n  Everything works.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Giorgio Didone",
            "time": "Jan 25, 2017 at 17:54",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Obvious and easy solution if you just can't get any documentation:\nDo you have any software that reads these files? Something that probably displays them in some useful, probably graphic format?\n </p>\n <p>\n  If so, reverse engineer the loading section of this program.\nString search in the program for \"wsn\" references to help zero in on where they are probably loaded..\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "Sirmabus",
            "time": "Jul 9, 2015 at 15:39",
            "is_accepted": false,
            "comments": []
        }
    ]
}