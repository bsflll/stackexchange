{
    "title": "How to know if PE Header import function is being imported by Ordinal rather than by name",
    "link": "https://reverseengineering.stackexchange.com/questions/13385/how-to-know-if-pe-header-import-function-is-being-imported-by-ordinal-rather-tha",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I want to know how to find out if an imported function in a PE header is being imported by ordinal rather than by name because I came across an executable that does that. Here is the DLL that imports all functions by ordinal except for one (from\n  <code>\n   WS2_32.dll\n  </code>\n  ):\n </p>\n <p>\n  Screenshot from program called\n  <code>\n   ExeinfoPE\n  </code>\n  <a href=\"https://i.sstatic.net/W3zGE.png\" rel=\"nofollow noreferrer\">\n   <img alt=\"enter image description here\" src=\"https://i.sstatic.net/W3zGE.png\"/>\n  </a>\n </p>\n <p>\n  This is what I'm doing to get to the imports:\n </p>\n <ol>\n  <li>\n   Read the PE header.\n  </li>\n  <li>\n   Loop over data directories and find\n   <code>\n    IMAGE_DIRECTORY_ENTRY_IMPORT\n   </code>\n   .\n  </li>\n  <li>\n   <p>\n    Once\n    <code>\n     IMAGE_DIRECTORY_ENTRY_IMPORT\n    </code>\n    is found, loop over\n    <code>\n     IMAGE_IMPORT_DESCRIPTORS\n    </code>\n    .\n   </p>\n  </li>\n  <li>\n   <p>\n    On each\n    <code>\n     IMAGE_IMPORT_DESCRIPTORS\n    </code>\n    , extract all the functions.\n   </p>\n  </li>\n </ol>\n <p>\n  Here is how I extract the functions (only works for functions imported by name):\n </p>\n <pre><code>void extractFunctions(IMAGE_IMPORT_DESCRIPTOR dll, uintptr_t sectionStartAddrRaw) {\n    uintptr_t selectedFunctionImport = dll.Characteristics + sectionStartAddrRaw;\n    uintptr_t selectedFunctionImportIAT = dll.FirstThunk + sectionStartAddrRaw;\n\n    while (true) {\n        IMAGE_THUNK_DATA thunkPtrToImportByName = *(IMAGE_THUNK_DATA*)selectedFunctionImport;\n        selectedFunctionImport += sizeof(IMAGE_THUNK_DATA); //Next loop we'll loop over to the next IMAGE_THUNK_DATA.\n        if (thunkPtrToImportByName.u1.Function == NULL) { //Check if we need to exit the looping since there are no more functions to import.\n            break;\n        }\n\n        IMAGE_IMPORT_BY_NAME* functionImport = (IMAGE_IMPORT_BY_NAME*)(thunkPtrToImportByName.u1.Function + sectionStartAddrRaw);\n\n        Function function;\n        function.name = std::string(functionImport->Name); //Access violation here if the function needs to be imported by ordinal, instead of by name.\n        function.locationInIAT = selectedFunctionImportIAT;\n        function.locationInOriginalIAT = selectedFunctionImportIAT - sectionStartAddrRaw + header.OptionalHeader.ImageBase;\n\n        selectedFunctionImportIAT += sizeof(IMAGE_THUNK_DATA);\n        dlls.back().functions.push_back(function); //We assume that IMAGE_IMPORT_DESCRIPTOR dll is the last one in the dlls vector.]\n    }\n}\n</code></pre>\n <p>\n  I noticed that every function Hint/Ordinal inside\n  <code>\n   ExeinfoPE\n  </code>\n  that is imported by name is\n  <code>\n   0\n  </code>\n  . However, in my code\n  <code>\n   functionImport->Hint\n  </code>\n  is always set to something, regardless if the function is supposed to be imported by name or ordinal.\n </p>\n <p>\n  The\n  <code>\n   IMAGE_IMPORT_DESCRIPTOR\n  </code>\n  cannot have information on whether the functions inside that\n  <code>\n   IMAGE_IMPORT_DESCRIPTOR\n  </code>\n  are imported by ordinal or name, since one of the functions is imported by name and all of the others are imported by ordinal. So, I'm all out of ideas here.\n </p>\n <p>\n  Here are the data structures I'm using for your reference so no need to Google:\n </p>\n <pre><code>typedef struct _IMAGE_THUNK_DATA {\n    union {\n        uint32_t* Function;             // address of imported function\n        uint32_t  Ordinal;              // ordinal value of function\n        PIMAGE_IMPORT_BY_NAME AddressOfData;        // RVA of imported name\n        DWORD ForwarderStringl              // RVA to forwarder string\n    } u1;\n} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;\n\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR {\n    union {\n        DWORD   Characteristics; /* 0 for terminating null import descriptor  */\n        DWORD   OriginalFirstThunk; /* RVA to original unbound IAT */\n    } DUMMYUNIONNAME;\n\n    DWORD   TimeDateStamp;  /* 0 if not bound,\n    * -1 if bound, and real date\\time stamp\n    *    in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\n    * (new BIND)\n    * otherwise date/time stamp of DLL bound to\n    * (Old BIND)\n    */\n    DWORD   ForwarderChain; /* -1 if no forwarders */\n    DWORD   Name;\n    /* RVA to IAT (if bound this IAT has actual addresses) */\n    DWORD   FirstThunk;\n} IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;\n\ntypedef struct _IMAGE_IMPORT_BY_NAME {\n    WORD    Hint;\n    BYTE    Name[1];\n} IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;\n</code></pre>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 1,
    "views": "5k",
    "tags": [
        "windows",
        "pe"
    ],
    "user": "Majiick",
    "time": "Aug 28, 2016 at 6:20",
    "comments": [
        {
            "user": "Majiick",
            "text": "<html><body><span class=\"comment-copy\">\n I found something relevant on page 51 of Windows' pe header documentation under the topic \"Import Lookup Table\",\n <a href=\"https://gyazo.com/0fde0a89b514b3e40a163e9934391e4f\" rel=\"nofollow noreferrer\">\n  gyazo.com/0fde0a89b514b3e40a163e9934391e4f\n </a>\n Looks like the first bit of the IMAGE_THUNK_DATA->Ordinal is a flag, and if it is set then the function should be imported by ordinal. It's late right now, I will write the answer tomorrow or someone else write it.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Extracted from\n  <a href=\"http://www.pelib.com/resources/luevel.txt\" rel=\"nofollow\">\n   http://www.pelib.com/\n  </a>\n  :\n </p>\n <blockquote>\n  <p>\n   First, the bit\n   <code>\n    IMAGE_ORDINAL_FLAG\n   </code>\n   (that is: the\n   <code>\n    MSB\n   </code>\n   ) of the\n   <code>\n    IMAGE_THUNK_DATA\n   </code>\n   in the arrays can be set, in which case there is no\n  symbol-name-information in the list and the symbol is imported purely by\n  ordinal. You get the ordinal by inspecting the lower word of the\n   <code>\n    IMAGE_THUNK_DATA\n   </code>\n   .\n  </p>\n  <p>\n   <code>\n    IMAGE_THUNK_DATA\n   </code>\n   -array; walk down this array (it is be\n   <code>\n    0\n   </code>\n   -terminated), and each member will be the RVA of a\n   <code>\n    IMAGE_IMPORT_BY_NAME\n   </code>\n   (unless the hi-bit is set in which case you\n  don't have a name but are left with a mere ordinal).\n  </p>\n </blockquote>\n <p>\n  A more detailed explanation extracted from a\n  <a href=\"http://fossies.org/linux/volatility/volatility/plugins/overlays/windows/pe_vtypes.py\" rel=\"nofollow\">\n   volatility plugin\n  </a>\n  (lines 363-367):\n </p>\n <pre><code>350  while 1:\n351      thunk = obj.Object('_IMAGE_THUNK_DATA',\n352                 offset = self.obj_parent.DllBase + self.OriginalFirstThunk +\n353                 i * self.obj_vm.profile.get_obj_size('_IMAGE_THUNK_DATA'),\n354                 vm = self.obj_native_vm)\n\n355      # We've reached the end when the element is zero \n357      if thunk == None or thunk.AddressOfData == 0:\n358          break\n359      o = obj.NoneObject(\"Ordinal not accessible?\")\n361      n = obj.NoneObject(\"Imported by ordinal?\")\n362      f = obj.NoneObject(\"FirstThunk not accessible\")\n\n363      # If the highest bit (32 for x86 and 64 for x64) is set, the function is \n365      # imported by ordinal and the lowest 16-bits contain the ordinal value. \n366      # Otherwise, the lowest bits (0-31 for x86 and 0-63 for x64) contain an \n367      # RVA to an _IMAGE_IMPORT_BY_NAME struct. \n368      if thunk.OrdinalBit == 1:\n369          o = thunk.Ordinal & 0xFFFF\n370      else:\n371          iibn = obj.Object(\"_IMAGE_IMPORT_BY_NAME\",\n372                            offset = self.obj_parent.DllBase +\n373                            thunk.AddressOfData,\n374                            vm = self.obj_native_vm)\n375          o = iibn.Hint\n376          n = iibn.Name\n377      # See if the import is bound (i.e. resolved)\n379      first_thunk = obj.Object('_IMAGE_THUNK_DATA',\n380                      offset = self.obj_parent.DllBase + self.FirstThunk +\n381                      i * self.obj_vm.profile.get_obj_size('_IMAGE_THUNK_DATA'),\n382                      vm = self.obj_native_vm)\n383      if first_thunk:\n384          f = first_thunk.Function.v()\n385      yield o, f, str(n or '')\n387      i += 1\n</code></pre>\n</div>\n</body></html>",
            "votes": "4",
            "user": "knx",
            "time": "Aug 28, 2016 at 7:33",
            "is_accepted": true,
            "comments": []
        }
    ]
}