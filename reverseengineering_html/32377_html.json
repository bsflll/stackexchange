{
    "title": "MS-DOS 32 bit mode Timer interrupt",
    "link": "https://reverseengineering.stackexchange.com/questions/32377/ms-dos-32-bit-mode-timer-interrupt",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  My application works in 32 bit MS-DOS mode with dos4gw.exe extender. variables unknown_bool_0004AA8A = 1, unknown_bool_0004AAA0 = 1.\n </p>\n <pre><code>cseg01:0004AAB3                 mov     eax, offset Proc_Addr1\ncseg01:0004AAB8                 push    eax\ncseg01:0004AAB9                 push    0FFFFh\ncseg01:0004AABE                 call    Timer_Interrupt_Controller\n\n</code></pre>\n <pre><code>cseg01:000521C6 Timer_Interrupt_Controller proc near    ; CODE XREF: Interrupt_Controller_Proc+4Dp\ncseg01:000521C6\ncseg01:000521C6 arg_0_FFFF      = dword ptr  8\ncseg01:000521C6 arg_4_Proc_Addr = dword ptr  0Ch\ncseg01:000521C6\ncseg01:000521C6                 push    ebp\ncseg01:000521C7                 mov     ebp, esp\ncseg01:000521C9                 push    esi\ncseg01:000521CA                 push    edi\ncseg01:000521CB                 push    ebx\ncseg01:000521CC                 push    ecx\ncseg01:000521CD                 push    fs\ncseg01:000521CF                 push    gs\ncseg01:000521D1                 push    es\ncseg01:000521D2                 mov     edi, [ebp+arg_4_Proc_Addr]\ncseg01:000521D5                 mov     Proc_Addr, edi\ncseg01:000521DB                 mov     DS_word_000521DB, ds\ncseg01:000521E2                 mov     DS_word_000521E2, ds\ncseg01:000521E9                 cmp     unknown_bool_0004AAA0, 0\ncseg01:000521F0                 jz      on_exit\ncseg01:000521F6                 mov     dx, 21h ; '!'\ncseg01:000521FA                 in      al, dx          ; Interrupt controller, 8259A.\ncseg01:000521FB                 or      al, 1\ncseg01:000521FD                 out     dx, al          ; Interrupt controller, 8259A.\ncseg01:000521FE                 cmp     unknown_bool_0004AA8A, 0\ncseg01:00052205                 jz      short condition_2\ncseg01:00052207                 nop\ncseg01:00052208                 nop\ncseg01:00052209                 nop\ncseg01:0005220A                 nop\ncseg01:0005220B                 mov     ax, 204h\ncseg01:0005220F                 mov     bl, 8\ncseg01:00052211                 int     31h             ; DPMI Services   ax=func xxxxh\ncseg01:00052211                                         ; GET PROTECTED MODE INTERRUPT VECTOR\ncseg01:00052211                                         ; BL = interrupt number\ncseg01:00052211                                         ; Return: CF set on error\ncseg01:00052211                                         ; CF clear if successful, CX:DX / CX:EDX = selector:offset of handler\ncseg01:00052213                 mov     Timer_offset_proc_addr, edx\ncseg01:00052219                 mov     word ptr Timer_segment_proc_addr, cx\ncseg01:00052220                 mov     ax, 205h\ncseg01:00052224                 mov     bl, 8\ncseg01:00052226                 mov     edx, offset Proc_Addr2\ncseg01:0005222B                 mov     cx, cs\ncseg01:0005222E                 int     31h             ; DPMI Services   ax=func xxxxh\ncseg01:0005222E                                         ; SET PROTECTED MODE INTERRUPT VECTOR\ncseg01:0005222E                                         ; BL = interrupt number, CX:DX / CX:EDX = selector:offset of handler\ncseg01:0005222E                                         ; Return: CF set on error\ncseg01:0005222E                                         ; CF clear if successful\ncseg01:00052230                 jmp     short Timer\ncseg01:00052230 ; ---------------------------------------------------------------------------\ncseg01:00052232                 db 3 dup(90h)\ncseg01:00052235 ; ---------------------------------------------------------------------------\ncseg01:00052235\ncseg01:00052235 condition_2:                            ; CODE XREF: Timer_Interrupt_Controller+3Fj\ncseg01:00052235                 mov     ax, 3508h\ncseg01:00052239                 int     21h             ; DOS - 2+ - GET INTERRUPT VECTOR\ncseg01:00052239                                         ; AL = interrupt number\ncseg01:00052239                                         ; Return: ES:BX = value of interrupt vector\ncseg01:0005223B                 mov     Timer_offset_proc_addr, ebx\ncseg01:00052241                 mov     word ptr Timer_segment_proc_addr, es\ncseg01:00052248                 push    ds\ncseg01:00052249                 xor     ax, ax\ncseg01:0005224C                 mov     es, ax\ncseg01:0005224E                 assume es:nothing\ncseg01:0005224E                 mov     ax, 2508h\ncseg01:00052252                 mov     edx, offset Proc_Addr2\ncseg01:00052257                 push    cs\ncseg01:00052258                 pop     ds\ncseg01:00052259                 assume ds:nothing\ncseg01:00052259                 int     21h             ; DOS - SET INTERRUPT VECTOR\ncseg01:00052259                                         ; AL = interrupt number\ncseg01:00052259                                         ; DS:DX = new vector to be used for specified interrupt\ncseg01:0005225B                 pop     ds\ncseg01:0005225C                 assume ds:dseg05\ncseg01:0005225C\ncseg01:0005225C Timer:                                  ; CODE XREF: Timer_Interrupt_Controller+6Aj\ncseg01:0005225C                 mov     dx, 43h ; 'C'\ncseg01:00052260                 mov     al, 36h ; '6'\ncseg01:00052262                 out     dx, al          ; Timer 8253-5 (AT: 8254.2).\ncseg01:00052263                 mov     dx, 40h ; '@'\ncseg01:00052267                 mov     eax, [ebp+arg_0_FFFF]\ncseg01:0005226A                 out     dx, al          ; Timer 8253-5 (AT: 8254.2).\ncseg01:0005226B                 mov     al, ah\ncseg01:0005226D                 out     dx, al          ; Timer 8253-5 (AT: 8254.2).\ncseg01:0005226E                 mov     dx, 21h ; '!'\ncseg01:00052272                 in      al, dx          ; Interrupt controller, 8259A.\ncseg01:00052273                 and     al, 0FEh\ncseg01:00052275                 out     dx, al          ; Interrupt controller, 8259A.\ncseg01:00052276\ncseg01:00052276 on_exit:                                ; CODE XREF: Timer_Interrupt_Controller+2Aj\ncseg01:00052276                 pop     es\ncseg01:00052277                 assume es:nothing\ncseg01:00052277                 pop     gs\ncseg01:00052279                 pop     fs\ncseg01:0005227B                 pop     ecx\ncseg01:0005227C                 pop     ebx\ncseg01:0005227D                 pop     edi\ncseg01:0005227E                 pop     esi\ncseg01:0005227F                 pop     ebp\ncseg01:00052280                 retn\ncseg01:00052280 Timer_Interrupt_Controller endp\n\n</code></pre>\n <pre><code>cseg01:00052119 Proc_Addr2      proc near               ; DATA XREF: Timer_Interrupt_Controller+60o\ncseg01:00052119                                         ; Timer_Interrupt_Controller+8Co\ncseg01:00052119                 push    ds\ncseg01:0005211A                 call    __GETDS\ncseg01:0005211A Proc_Addr2      endp\ncseg01:0005211A\ncseg01:0005211F ; ---------------------------------------------------------------------------\ncseg01:0005211F                 cmp     word_C7E3E, 1\ncseg01:00052127                 jz      short loc_5217E\ncseg01:00052129                 nop\ncseg01:0005212A                 nop\ncseg01:0005212B                 nop\ncseg01:0005212C                 nop\ncseg01:0005212D                 push    ax\ncseg01:0005212F                 mov     ax, 20h ; ' '\ncseg01:00052133                 out     20h, al         ; Interrupt controller, 8259A.\ncseg01:00052135                 pop     ax\ncseg01:00052137                 mov     word_C7E3E, 1\ncseg01:00052140                 mov     dword ptr byte_C6E2E, esp\ncseg01:00052146                 mov     word ptr byte_C6E2E+4, ss\ncseg01:0005214D                 lss     esp, fword ptr off_C6E26\ncseg01:00052154                 pusha\ncseg01:00052155                 push    es\ncseg01:00052156                 push    fs\ncseg01:00052158                 push    gs\ncseg01:0005215A                 push    ds\ncseg01:0005215B                 pop     es\ncseg01:0005215C                 assume es:dseg05\ncseg01:0005215C                 mov     dword_C7E36, esp\ncseg01:00052162                 call    Proc_Addr\ncseg01:00052168                 pop     gs\ncseg01:0005216A                 pop     fs\ncseg01:0005216C                 pop     es\ncseg01:0005216D                 assume es:nothing\ncseg01:0005216D                 popa\ncseg01:0005216E                 lss     esp, fword ptr byte_C6E2E\ncseg01:00052175                 mov     word_C7E3E, 0\ncseg01:0005217E\ncseg01:0005217E loc_5217E:                              ; CODE XREF: cseg01:00052127j\ncseg01:0005217E                 pop     ds\ncseg01:0005217F                 iret\ncseg01:00052180\n\n</code></pre>\n <pre><code>cseg01:0004A840 __GETDS:                                ; CODE XREF: sub_481FE+Bp\ncseg01:0004A840                                         ; Proc_Addr2+1p ...\ncseg01:0004A840                 db      66h\ncseg01:0004A840                 mov     ds, cs:word_4A849\ncseg01:0004A848                 retn\ncseg01:0004A848 start           endp\n\n</code></pre>\n <pre><code>cseg01:0004B0CF Proc_Addr1      proc near               ; DATA XREF: Interrupt_Controller_Proc+42o\ncseg01:0004B0CF\ncseg01:0004B0CF var_4           = dword ptr -4\ncseg01:0004B0CF\ncseg01:0004B0CF                 push    ebx\ncseg01:0004B0D0                 push    ecx\ncseg01:0004B0D1                 push    edx\ncseg01:0004B0D2                 push    esi\ncseg01:0004B0D3                 push    edi\ncseg01:0004B0D4                 push    ebp\ncseg01:0004B0D5                 mov     ebp, esp\ncseg01:0004B0D7                 sub     esp, 4\ncseg01:0004B0DD                 mov     [ebp+var_4], 0\ncseg01:0004B0E4\ncseg01:0004B0E4 loc_4B0E4:                              ; CODE XREF: Proc_Addr1+23j\ncseg01:0004B0E4                 cmp     [ebp+var_4], 10h\ncseg01:0004B0E8                 jb      short loc_4B0F4\ncseg01:0004B0EA                 jmp     locret_4B168\ncseg01:0004B0EF ; ---------------------------------------------------------------------------\ncseg01:0004B0EF\ncseg01:0004B0EF loc_4B0EF:                              ; CODE XREF: Proc_Addr1:loc_4B166j\ncseg01:0004B0EF                 inc     [ebp+var_4]\ncseg01:0004B0F2                 jmp     short loc_4B0E4\ncseg01:0004B0F4 ; ---------------------------------------------------------------------------\ncseg01:0004B0F4\ncseg01:0004B0F4 loc_4B0F4:                              ; CODE XREF: Proc_Addr1+19j\ncseg01:0004B0F4                 mov     eax, [ebp+var_4]\ncseg01:0004B0F7                 shl     eax, 2\ncseg01:0004B0FA                 cmp     dword_C7FE4[eax], 0\ncseg01:0004B101                 jz      short loc_4B166\ncseg01:0004B103                 mov     eax, [ebp+var_4]\ncseg01:0004B106                 shl     eax, 2\ncseg01:0004B109                 mov     edx, [ebp+var_4]\ncseg01:0004B10C                 shl     edx, 2\ncseg01:0004B10F                 mov     edx, dword_C8064[edx]\ncseg01:0004B115                 add     dword_C80A4[eax], edx\ncseg01:0004B11B                 mov     eax, [ebp+var_4]\ncseg01:0004B11E                 shl     eax, 2\ncseg01:0004B121                 test    byte ptr (dword_C80A4+2)[eax], 1\ncseg01:0004B128                 jz      short loc_4B166\ncseg01:0004B12A                 mov     eax, [ebp+var_4]\ncseg01:0004B12D                 shl     eax, 2\ncseg01:0004B130                 mov     word ptr (dword_C80A4+2)[eax], 0\ncseg01:0004B139                 mov     eax, [ebp+var_4]\ncseg01:0004B13C                 shl     eax, 2\ncseg01:0004B13F                 cmp     byte_C80E4[eax], 0FFh\ncseg01:0004B146                 jz      short loc_4B15A\ncseg01:0004B148                 mov     eax, [ebp+var_4]\ncseg01:0004B14B                 shl     eax, 2\ncseg01:0004B14E                 movzx   eax, byte_C80E4[eax]\ncseg01:0004B155                 mov     dword_C8124, eax\ncseg01:0004B15A\ncseg01:0004B15A loc_4B15A:                              ; CODE XREF: Proc_Addr1+77j\ncseg01:0004B15A                 mov     eax, [ebp+var_4]\ncseg01:0004B15D                 shl     eax, 2\ncseg01:0004B160                 call    dword_C7FE4[eax]\ncseg01:0004B166\ncseg01:0004B166 loc_4B166:                              ; CODE XREF: Proc_Addr1+32j\ncseg01:0004B166                                         ; Proc_Addr1+59j\ncseg01:0004B166                 jmp     short loc_4B0EF\ncseg01:0004B168 ; ---------------------------------------------------------------------------\ncseg01:0004B168\ncseg01:0004B168 locret_4B168:                           ; CODE XREF: Proc_Addr1+1Bj\ncseg01:0004B168                 leave\ncseg01:0004B169                 pop     edi\ncseg01:0004B16A                 pop     esi\ncseg01:0004B16B                 pop     edx\ncseg01:0004B16C                 pop     ecx\ncseg01:0004B16D                 pop     ebx\ncseg01:0004B16E                 retn\ncseg01:0004B16E Proc_Addr1      endp\n\n</code></pre>\n <p>\n  How I understood, function Timer_Interrupt_Controller setup new interrupt function for timer. But I dont understand why this need? For me, need convert function Proc_Addr2 into C++ code with __asm statement. But I dont know how it to do. Who can assist me? Also I dont know what happens between label Timer: and label on_exit: - who can explain?\nThanks in advance.\n </p>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 0,
    "views": "58",
    "tags": [
        "disassembly",
        "c++"
    ],
    "user": "black4joss",
    "time": "Oct 8, 2023 at 0:57",
    "comments": [
        {
            "user": "ESkri",
            "text": "<html><body><span class=\"comment-copy\">\n <code>\n  what happens between label Timer: and label on_exit:\n </code>\n - setting timer parameters via I/O ports\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "black4joss",
            "text": "<html><body><span class=\"comment-copy\">\n Possible a bit detailed? What timer's parameters changes and for what? Quite normal timer - 18.2 ticks per second. What usage of this?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "ESkri",
            "text": "<html><body><span class=\"comment-copy\">\n You can make the timer faster (for example, 1 kHz) to suit the needs of your application.  18.2 ticks is the minimum possible frequency (and this is exactly what your code does,\n <code>\n  push 0FFFFh\n </code>\n before call is setting the minimum frequency).  One of a timer usage examples - generating sound of specified frequency by adjusting the settings of the corresponding timer.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "black4joss",
            "text": "<html><body><span class=\"comment-copy\">\n This is information from 90s years MS DOS development. You took this from Internet or have own knowledge? Please share link, if possible, I want study this.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "ESkri",
            "text": "<html><body><span class=\"comment-copy\">\n That's from my own memory, I wrote a lot of assembler programs for MSDOS.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}