{
    "title": "How could a CRC-15 CAN be transformed into 8 bytes in an embedded system?",
    "link": "https://reverseengineering.stackexchange.com/questions/33414/how-could-a-crc-15-can-be-transformed-into-8-bytes-in-an-embedded-system",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am analyzing calibration binary files of an embedded system (BMS) that likely uses a CRC-15 CAN checksum.\n </p>\n <p>\n  From my firmware and bootloader file analysis, I have found a PECLookup table, which suggests that a CRC-15 CAN calculation is being performed somewhere. However, I do not see a direct 2-byte CRC-15 stored in the calibration binary file.\n </p>\n <p>\n  Instead, the binary file ends with 8 extra bytes, which seem to be linked to a CRC checksum. I suspect these 8 bytes may be derived from the CRC-15 CAN in some way, but I haven't been able to determine the exact transformation.\n </p>\n <p>\n  What I have observed so far:\n </p>\n <p>\n  The PECLookup table for CRC-15 CAN is present in the firmware and bootloader, so it is likely used in some form.\nI do not find a direct 2-byte CRC-15 in the file, but the last 8 bytes change systematically when I modify just 1 bit in the calibration file.\nThe 8 bytes doesn't seem to be a simple XOR with a fixed key.\nI tested various CRC-64 transformations on top of the CRC15, but none match the final 8 bytes.\nThe system processor is a TMS570 (ARM Cortex-R4, Big Endian).\nWhat I am looking for:\n </p>\n <p>\n  Is there a known method in embedded systems where a CRC-15 CAN is expanded or transformed into a longer checksum (e.g., 8 bytes)?\nCould this be a linear transformation, a different CRC format, or another encoding method?\nHas anyone encountered a similar method in automotive/embedded checksum handling?\nAny insights into how such a transformation could work in an automotive or industrial embedded system would be greatly appreciated!\n </p>\n <p>\n  Additional observation In the BMS diagnostic software, a Config CRC (4 bytes) is displayed, which seems to be derived from the last 8 bytes of the calibration file. Specifically:\n </p>\n <pre><code>Config_CRC[1] = byte[1] XOR byte[5]\nConfig_CRC[2] = byte[2] XOR byte[6]\nConfig_CRC[3] = byte[3] XOR byte[7]\nConfig_CRC[4] = byte[4] XOR byte[8]\n</code></pre>\n <hr/>\n <h2>\n  <strong>\n   Added\n  </strong>\n </h2>\n <p>\n  I managed to locate the CRC15-CAN function and identified that this function is called twice within the bootloader file.\n </p>\n <p>\n  However, I'm struggling to fully understand whatâ€™s happening. My C knowledge is quite basic, and since these functions call other functions, it makes the analysis more difficult.\n </p>\n <p>\n  Here are the two functions that call the CRC15-CAN function:\n </p>\n <pre><code>int CRC_used1(undefined4 *param_1,uint param_2,uint param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 uVar4;\n  uint local_2c;\n  uint local_28;\n  undefined2 local_24;\n  uint auStack_22 [4];\n  \n  fun_called11(auStack_22,0,10);\n  local_2c = 0;\n  local_28 = 0;\n  iVar1 = fun_called12(param_3,(int)param_1,param_2,&local_2c,&local_28);\n  if (iVar1 == 0) {\n    uVar4 = fun_called13((int)auStack_22,local_2c & 0xffff,local_28 & 0xffff);\n    iVar2 = (int)uVar4;\n    iVar1 = iVar2;\n    if (iVar2 == 0) {\n      iVar1 = Calcul_CRC15((int)auStack_22,param_2 & 0xffff);\n      local_24 = (undefined2)iVar1;\n      iVar3 = fun_called14((int)&local_24,(int)auStack_22 + param_2,2);\n      iVar1 = DAT_000067d0;\n      if (iVar3 == 0) {\n        fun_called15(param_1,auStack_22,param_2);\n        iVar1 = iVar2;\n      }\n    }\n  }\n  return iVar1;\n}\n\n\nint CRC_used2(undefined4 *param_1,uint param_2,uint param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  uint local_2c [2];\n  undefined2 local_24;\n  uint auStack_22 [4];\n  \n  local_2c[0] = 0;\n  local_2c[1] = 0;\n  iVar1 = fun_called12(param_3,(int)param_1,param_2,local_2c,local_2c + 1);\n  if (iVar1 == 0) {\n    iVar1 = Calcul_CRC15((int)param_1,param_2 & 0xffff);\n    local_24 = (undefined2)iVar1;\n    fun_called11(auStack_22,0,10);\n    fun_called15(auStack_22,param_1,param_2);\n    fun_called15((undefined4 *)((int)auStack_22 + param_2),(undefined4 *)&local_24,2);\n    uVar2 = fun_called21((int)auStack_22,local_2c[0] & 0xffff,param_2 + 2 & 0xffff);\n    iVar1 = (int)uVar2;\n  }\n  return iVar1;\n}\n</code></pre>\n <p>\n  Does anyone have any insights on how I could progress further in understanding this?\n </p>\n <p>\n  Since these functions are deeply nested and call many others, could this suggest that a more complex algorithm like Reed-Solomon or BCH code is being used internally? That might explain why so many layers of functions are involved.\n </p>\n <p>\n  For those interested, here's some information about the last 8 bytes of 2 different files with only one change bit :\nEvery calibration file has a size of 64 Ko and :\n </p>\n <pre><code>file 1 :\n8 last bytes : 01 A4 2D 58 B8 C9 D4 28 \nConfig_CRC : B9 6D F9 70\n\nfile 2 :\n8 last bytes : CA A5 2A 2A 50 D1 23 FE\nConfig_CRC : 9A 74 09 D4\n</code></pre>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 0,
    "views": "35",
    "tags": [
        "assembly",
        "debugging",
        "ghidra",
        "crc",
        "checksum"
    ],
    "user": "Charles",
    "time": "Mar 24 at 8:25",
    "comments": [],
    "answers_data": []
}