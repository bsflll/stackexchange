{
    "title": "Decompress from file with crush32",
    "link": "https://reverseengineering.stackexchange.com/questions/21359/decompress-from-file-with-crush32",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have some files *.bli, *.ilg, *.pix, etc. These files are from technical documentation LinkOne, and compressed with old C/Win32 compression library crush32.dll.\n </p>\n <p>\n  information can be found here\n  <a href=\"https://reverseengineering.stackexchange.com/questions/20771/reverse-engineering-file-format-imagelink\">\n   Reverse engineering file format - ImageLink\n  </a>\n </p>\n <p>\n  I found c# code to decompress it, but it is not working. What did I do wrong? I tried to read s001.bli, it`s ok, than from result gets \"true\" and that's all. decompressedPixelData is empty, with size 0.\n </p>\n <p>\n  I run the code through Visual Studio 2012 on emulated Windows 7 X86 in VirtualBox. The crush32.dll library seems to work only with x86, although on win10 x64 the result is exactly the same.\n </p>\n <p>\n  <strong>\n   Files and dll\n  </strong>\n  :\n  <a href=\"https://drive.google.com/file/d/1GipwXL9ikog1YVu46uqxLfuuY1Rk-5Pc/view\" rel=\"nofollow noreferrer\">\n   https://drive.google.com/file/d/1GipwXL9ikog1YVu46uqxLfuuY1Rk-5Pc/view\n  </a>\n </p>\n <p>\n  Code:\n </p>\n <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.IO;\n\nnamespace Crush32Wrap\n{\n    public unsafe static class Crush32\n    {\n        #region Private PINVOKE signatures\n        /// <summary>\n        /// Name of legacy crush32.dll file (put it in same folder!)\n        /// </summary>\n        public const string DLLName = \"crush32.dll\";\n        public const string FName = \"s001.bli\";\n\n        /// <summary>\n        /// The cxERROR for SUCCESS\n        /// </summary>\n        private const short CX_SUCCESS = 0;\n\n        /// <summary>\n        /// Initializes the library\n        /// </summary>\n        /// <returns>cxERROR statevalue</returns>\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxInit();\n\n        /// <summary>\n        /// Cleanup\n        /// </summary>\n        /// <returns>cxERROR statevalue</returns>\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxCleanup();\n\n        /// <summary>\n        /// Initializes a buffer to buffer operation.\n        /// </summary>\n        /// <returns>cxERROR statevalue</returns>\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBuf2BufInit();\n\n        /// <summary>\n        /// Closes a buffer to buffer operation\n        /// </summary>\n        /// <returns>cxERROR statevalue</returns>\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBuf2BufClose();\n\n        /// <summary>\n        /// Decrypts data in a buffer.\n        /// </summary>\n        /// <param name=\"Buffer\">A pointer to the data to be decrypted.</param>\n        /// <param name=\"Length\">How many bytes should be decrypted.</param>\n        /// <param name=\"Challenge\">The Challenge used to test your password first.</param>\n        /// <param name=\"ExpectedResponse\">The ExpectedResponse matching your Challenge and your password.</param>\n        /// <returns>cxERROR statevalue</returns>\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBufDecrypt(byte* Buffer, int Length, uint Challenge, uint ExpectedResponse);\n\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBufDecrypt(IntPtr Buffer, int Length, uint Challenge, uint ExpectedResponse);\n\n\n        /// <summary>\n        /// Encrypts data in a buffer.\n        /// </summary>\n        /// <param name=\"Buffer\">A pointer to the data to be encrypted.</param>\n        /// <param name=\"Length\">How many bytes should be encrypted.</param>\n        /// <param name=\"Challenge\">The Challenge used to create the returnvalue.</param>\n        /// <returns>The \"ExpectedResponse\" matching your given Challenge and your Password, use this in decryption later.</returns>\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern uint cxBufEncrypt(IntPtr Buffer, int Length, uint Challenge);\n\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern uint cxBufEncrypt(byte* Buffer, int Length, uint Challenge);\n\n\n        /// <summary>\n        /// Sets a password for the encryption and decryption methods.\n        /// </summary>\n        /// <param name=\"PtrPasswordString\">A pointer to the nullterminated passwordstring in memory.</param>\n        /// <returns>cxERROR statevalue</returns>\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxSetPassword(IntPtr PtrPasswordString);\n\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxSetPassword(byte* Password);\n\n        /// <summary>\n        /// Compresses the data from the InputBuffer to the OutputBuffer.\n        /// </summary>\n        /// <param name=\"InputBuffer\">A pointer to read inputdata from.</param>\n        /// <param name=\"OutputBuffer\">A pointer to write outputdata to.</param>\n        /// <param name=\"InputLength\">How many bytes should be read from input buffer.</param>\n        /// <returns>The length of the compressed data.</returns>\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern int cxBuf2BufCompress(IntPtr InputBuffer, IntPtr OutputBuffer, int InputLength);\n\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern int cxBuf2BufCompress(byte* InputBuffer, byte* OutputBuffer, int InputLength);\n\n        /// <summary>\n        /// Decompresses the data from the InputBuffer to the OutputBuffer.\n        /// </summary>\n        /// <param name=\"InputBuffer\">A pointer to read inputdata from.</param>\n        /// <param name=\"OutputBuffer\">A pointer to write outputdata to.</param>\n        /// <param name=\"DecompressedLength\">The length of the data in decompressed state.</param>\n        /// <param name=\"CompressedLength\">The length of the data in compressed state.</param>\n        /// <returns>cxERROR statevalue</returns>\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBuf2BufExpand(IntPtr InputBuffer, IntPtr OutputBuffer, int DecompressedLength, int CompressedLength);\n\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBuf2BufExpand(byte* InputBuffer, byte* OutputBuffer, int DecompressedLength, int CompressedLength);\n\n        /// <summary>\n        /// Creates a CRC32 for the data in the Buffer.\n        /// Note: The used algorithm is equal to\n        /// http://damieng.com/blog/2006/08/08/calculating_crc32_in_c_and_net\n        /// </summary>\n        /// <param name=\"Buffer\">A pointer to read the data to CRC.</param>\n        /// <param name=\"Length\">How many bytes should be read from pointer.</param>\n        /// <returns>The created CRC32</returns>\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        public static extern uint cxBufCRC32(IntPtr Buffer, int Length);\n\n        #endregion\n        #region Public Wrappers\n\n        /// <summary>\n        /// Fast decompresses data from managed sourcebuffer to managed targetbuffer using pointers\n        /// </summary>\n        /// <param name=\"SourceBuffer\">SourceBuffer containing compressed data</param>\n        /// <param name=\"SourceIndex\">Cursor in SourceBuffer to start reading</param>\n        /// <param name=\"TargetBuffer\">TargetBuffer for decompressed data</param>\n        /// <param name=\"TargetIndex\">Cursor in TargetBuffer to start writing</param>\n        /// <param name=\"UncompressedLength\">Uncompressed data length</param>\n        /// <param name=\"CompressedLength\">Compressed data length</param>\n        /// <returns>True if the operation was successful.</returns>\n        public static bool Decompress(byte[] SourceBuffer, int SourceIndex, byte[] TargetBuffer, int TargetIndex, int UncompressedLength, int CompressedLength)\n        {\n            bool isSuccessful = false;\n\n            // init crush32\n            if (Crush32.CX_SUCCESS == Crush32.cxInit())\n            {\n                if (Crush32.CX_SUCCESS == Crush32.cxBuf2BufInit())\n                {\n                    // pin the managed source & targetbuffers in memory so crush32 can access them\n                    // and we can directly use them without marshaling.\n                    fixed (byte* ptrSourceBuffer = SourceBuffer, ptrTargetBuffer = TargetBuffer)\n                    {\n                        // add the offsets to the pointers (they still point to the beginning of the buffer)\n                        byte* ptrSourceIndex = ptrSourceBuffer + SourceIndex;\n                        byte* ptrTargetIndex = ptrTargetBuffer + TargetIndex;\n\n                        if (Crush32.CX_SUCCESS == Crush32.cxBuf2BufExpand(ptrSourceIndex, ptrTargetIndex, UncompressedLength, CompressedLength))\n                            isSuccessful = true;\n\n                    }\n\n\n\n                    Crush32.cxBuf2BufClose();\n                }\n\n                Crush32.cxCleanup();\n            }\n\n            return isSuccessful;\n        }\n\n        /// <summary>\n        /// Fast compresses data from managed sourcebuffer to managed targetbuffer using pointers\n        /// </summary>\n        /// <param name=\"SourceBuffer\">SourceBuffer containing data to be compressed</param>\n        /// <param name=\"SourceIndex\">Cursor in SourceBuffer to start reading</param>\n        /// <param name=\"TargetBuffer\">TargetBuffer for compressed data</param>\n        /// <param name=\"TargetIndex\">Cursor in TargetBuffer to start writing</param>\n        /// <param name=\"UncompressedLength\">Uncompressed data length in SourceBuffer</param>\n        /// <returns>Compressed length</returns>\n        public static int Compress(byte[] SourceBuffer, int SourceIndex, byte[] TargetBuffer, int TargetIndex, int UncompressedLength)\n        {\n            int compressedLength = 0;\n\n            // init crush32\n            if (Crush32.CX_SUCCESS == Crush32.cxInit())\n            {\n                if (Crush32.CX_SUCCESS == Crush32.cxBuf2BufInit())\n                {\n                    // pin the managed source & targetbuffers in memory so crush32 can access them\n                    // and we can directly use them without marshaling.\n                    fixed (byte* ptrSourceBuffer = SourceBuffer, ptrTargetBuffer = TargetBuffer)\n                    {\n                        // add the offsets to the pointers (they still point to the beginning of the buffer)\n                        byte* ptrSourceIndex = ptrSourceBuffer + SourceIndex;\n                        byte* ptrTargetIndex = ptrTargetBuffer + TargetIndex;\n\n                        // compress\n                        compressedLength = Crush32.cxBuf2BufCompress(ptrSourceIndex, ptrTargetIndex, UncompressedLength);\n                    }\n\n                    Crush32.cxBuf2BufClose();\n                }\n\n                Crush32.cxCleanup();\n            }\n\n            return compressedLength;\n        }\n\n        /// <summary>\n        /// Fast decrypt data in managed buffer using pointer\n        /// </summary>\n        /// <param name=\"SourceBuffer\">SourceBuffer containing encrypted data</param>\n        /// <param name=\"SourceIndex\">Cursor in SourceBuffer to start reading</param>\n        /// <param name=\"Length\">Encrypted data length</param>\n        /// <param name=\"Challenge\">Challenge to use</param>\n        /// <param name=\"ExpectedResponse\">ExpectedRespone to use</param>\n        /// <param name=\"Password\">Password to use</param>\n        /// <returns>True if the operation was successful.</returns>\n        public static bool Decrypt(byte[] SourceBuffer, int SourceIndex, int Length, uint Challenge, uint ExpectedResponse, byte[] Password)\n        {\n            bool isSuccessful = false;\n\n            // pin the managed sourcebuffer in memory so crush32 can access\n            // and we can directly use without marshaling.\n            fixed (byte* ptrSourceBuffer = SourceBuffer)\n            {\n                // add the offsets to the pointers (they still point to the beginning of the buffer)\n                byte* ptrSourceIndex = ptrSourceBuffer + SourceIndex;\n                isSuccessful = Decrypt(ptrSourceIndex, Length, Challenge, ExpectedResponse, Password);\n            }\n\n            return isSuccessful;\n        }\n\n        /// <summary>\n        /// \n        /// </summary>\n        /// <param name=\"SourceBuffer\"></param>\n        /// <param name=\"Length\"></param>\n        /// <param name=\"Challenge\"></param>\n        /// <param name=\"ExpectedREsponse\"></param>\n        /// <param name=\"Password\"></param>\n        /// <returns></returns>\n        public static unsafe bool Decrypt(byte* SourceBuffer, int Length, uint Challenge, uint ExpectedResponse, byte[] Password)\n        {\n            bool isSuccessful = false;\n\n            // init crush32\n            if (Crush32.CX_SUCCESS == Crush32.cxInit())\n            {\n                if (Crush32.CX_SUCCESS == Crush32.cxBuf2BufInit())\n                {\n                    // pin the managed sourcebuffer in memory so crush32 can access\n                    // and we can directly use without marshaling.\n                    fixed (byte* ptrPassword = Password)\n                    {\n                        // set password && decrypt\n                        if (Crush32.CX_SUCCESS == Crush32.cxSetPassword(ptrPassword))\n                            if (Crush32.CX_SUCCESS == Crush32.cxBufDecrypt(SourceBuffer, Length, Challenge, ExpectedResponse))\n                                isSuccessful = true;\n                    }\n\n                    Crush32.cxBuf2BufClose();\n                }\n\n                Crush32.cxCleanup();\n            }\n\n            return isSuccessful;\n        }\n\n        /// <summary>\n        /// Fast encrypt data in managed buffer using pointer\n        /// </summary>\n        /// <param name=\"SourceBuffer\">SourceBuffer containing data to be encrypted</param>\n        /// <param name=\"SourceIndex\">Cursor in SourceBuffer to start reading</param>\n        /// <param name=\"Length\">Length of data to be encrypted</param>\n        /// <param name=\"Challenge\">Challenge to use</param>\n        /// <param name=\"Password\">Password to use</param>\n        /// <returns>ExpectedResponse for Challenge/Password combination.</returns>\n        public static uint Encrypt(byte[] SourceBuffer, int SourceIndex, int Length, uint Challenge, byte[] Password)\n        {\n            uint expectedResponse = 0;\n\n            // pin the managed sourcebuffer in memory so crush32 can access\n            // and we can directly use without marshaling.\n            fixed (byte* ptrSourceBuffer = SourceBuffer, ptrPassword = Password)\n            {\n                // add the offsets to the pointers (they still point to the beginning of the buffer)\n                byte* ptrSourceIndex = ptrSourceBuffer + SourceIndex;\n                expectedResponse = Encrypt(ptrSourceIndex, Length, Challenge, Password);\n            }\n\n            return expectedResponse;\n        }\n\n        /// <summary>\n        /// Fast encrypt data on unmanaged pointer\n        /// </summary>\n        /// <param name=\"SourceBuffer\"></param>\n        /// <param name=\"Length\"></param>\n        /// <param name=\"Challenge\"></param>\n        /// <param name=\"Password\"></param>\n        /// <returns></returns>\n        public static unsafe uint Encrypt(byte* SourceBuffer, int Length, uint Challenge, byte[] Password)\n        {\n            uint expectedResponse = 0;\n\n            // init crush32\n            if (Crush32.CX_SUCCESS == Crush32.cxInit())\n            {\n                if (Crush32.CX_SUCCESS == Crush32.cxBuf2BufInit())\n                {\n                    // pin the managed sourcebuffer in memory so crush32 can access\n                    // and we can directly use without marshaling.\n                    fixed (byte* ptrPassword = Password)\n                    {\n                        // set password && encrypt\n                        if (Crush32.CX_SUCCESS == Crush32.cxSetPassword(ptrPassword))\n                            expectedResponse = Crush32.cxBufEncrypt(SourceBuffer, Length, Challenge);\n                    }\n\n                    Crush32.cxBuf2BufClose();\n                }\n\n                Crush32.cxCleanup();\n            }\n\n            return expectedResponse;\n        }\n        #endregion\n        #region Public main\n        [STAThread]\n        static void Main(string[] args)\n        {\n            byte[] Data = File.ReadAllBytes(\"s001.bli\");\n                int CompressedLength = Data.Length;\n                int UncompressedLength = 0;\n                byte[] decompressedPixelData = new byte[UncompressedLength];\n                bool result = Crush32.Decompress(Data, 15, decompressedPixelData, 0, (int)UncompressedLength, CompressedLength);\n                string s = \"{\" +\n                        string.Join(\", \",\n                            decompressedPixelData.Select(x => string.Format(\"0x{0}\", x.ToString(\"X\")))\n                        ) + \"}\";\n                Console.WriteLine(s);\n                Console.ReadKey(true);\n\n        }\n        #endregion\n    }\n}\n</code></pre>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 0,
    "views": "351",
    "tags": [
        "decompress",
        "c#"
    ],
    "user": "Антон Родин",
    "time": "Jun 4, 2019 at 6:38",
    "comments": [
        {
            "user": "Антон Родин",
            "text": "<html><body><span class=\"comment-copy\">\n I don`t know. I know that these files can be read by LinkOne program, but I need to open them separately. There is also another program that seems to work with this library. That version of the code I also could not run:\n <a href=\"https://github.com/cyberjunk/meridian59-dotnet/blob/master/Meridian59/Common/Crush32.cs\" rel=\"nofollow noreferrer\">\n  github.com/cyberjunk/meridian59-dotnet/blob/master/Meridian59/…\n </a>\n .\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}