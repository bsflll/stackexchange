{
    "title": "What is the difference between these two function prologue instruction sequences?",
    "link": "https://reverseengineering.stackexchange.com/questions/10949/what-is-the-difference-between-these-two-function-prologue-instruction-sequences",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  the test is on\n  <code>\n   32-bit x86\n  </code>\n  . I compiled the code with\n  <code>\n   gcc 4.2\n  </code>\n  , optimization level\n  <code>\n   o2\n  </code>\n  . I compiled the C code into binary, and then use\n  <code>\n   objdump\n  </code>\n  to disassemble it.\n </p>\n <p>\n  Here are two sequences of instructions used for the function prologue:\n </p>\n <pre><code>0804a6f0 <quotearg_n>:\n804a6f0:       8b 44 24 04             mov    0x4(%esp),%eax\n804a6f4:       b9 ff ff ff ff          mov    $0xffffffff,%ecx\n804a6f9:       8b 54 24 08             mov    0x8(%esp),%edx\n804a6fd:       c7 44 24 04 40 e1 04    movl   $0x804e140,0x4(%esp)\n804a704:       08 \n804a705:       e9 c6 fa ff ff          jmp    804a1d0 <quotearg_n_options>\n804a70a:       8d b6 00 00 00 00       lea    0x0(%esi),%esi\n\n\n0804a730 <quotearg>:\n804a730:       83 ec 1c                sub    $0x1c,%esp\n804a733:       8b 44 24 20             mov    0x20(%esp),%eax\n804a737:       c7 04 24 00 00 00 00    movl   $0x0,(%esp)\n804a73e:       89 44 24 04             mov    %eax,0x4(%esp)\n804a742:       e8 a9 ff ff ff          call   804a6f0 <quotearg_n>\n804a747:       83 c4 1c                add    $0x1c,%esp\n804a74a:       c3                      ret\n804a74b:       90                      nop\n804a74c:       8d 74 26 00             lea    0x0(%esi,%eiz,1),%esi\n</code></pre>\n <p>\n  Note that in function\n  <code>\n   quotearg\n  </code>\n  , register\n  <code>\n   esp\n  </code>\n  is decreased with\n  <code>\n   0x1c\n  </code>\n  before it is used to access the stack and get some arguments. Accutually according to my experience, I think the\n  <code>\n   sub\n  </code>\n  then\n  <code>\n   access\n  </code>\n  pattern is quite common for instructions compiled with\n  <code>\n   O2\n  </code>\n  .\n </p>\n <p>\n  However, note that in function\n  <code>\n   quotearg_n\n  </code>\n  , register\n  <code>\n   esp\n  </code>\n  is directly added with\n  <code>\n   0x4\n  </code>\n  to access the stack. (I think the meaning of instruction at address\n  <code>\n   0x804a6f0\n  </code>\n  is to put the return address of call site to register\n  <code>\n   eax\n  </code>\n  , am I right..?) According to my observation, the pattern used by the first function is rare, around 5% for\n  <code>\n   gcc\n  </code>\n  compiled middle size C program with\n  <code>\n   O2\n  </code>\n  .\n </p>\n <p>\n  So here is my question:\n </p>\n <p>\n  Why does compiler generate function prologue instructions in a way similar to\n  <code>\n   quoterag_n\n  </code>\n  ? What is the exact meaning of the first three instructions start from address\n  <code>\n   0x804a6f0\n  </code>\n  ?\n </p>\n <p>\n  Why doesn't compiler always generate function prologue instructions following the\n  <code>\n   sub\n  </code>\n  then\n  <code>\n   access\n  </code>\n  pattern? (such as\n  <code>\n   quoterag\n  </code>\n  )\n </p>\n <p>\n  Am I clear? thanks a lot\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "692",
    "tags": [
        "assembly",
        "x86",
        "c",
        "gcc"
    ],
    "user": "lllllllllllll",
    "time": "Sep 25, 2015 at 1:55",
    "comments": [
        {
            "user": "phuclv",
            "text": "<html><body><span class=\"comment-copy\">\n Is there a reason for you to use an 8-year-old compiler?\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  It seems like the functions are defined like this:\n </p>\n <pre><code>int quotearg_n(int a, int b) {\n    return quotearg_n_options(a, b, -1, \"some_string\");\n}\n\nint quotearg(int a) {\n    return quotearg_n(0, a);\n}\n</code></pre>\n <p>\n  (the\n  <code>\n   int\n  </code>\n  s might as well be pointers, can't tell this from your snippets, and the \"some string\" might be a pointer to a pre-initialized structure)\n </p>\n <p>\n  These functions have the normal\n  <code>\n   ABI\n  </code>\n  , which means they pass all arguments on the stack, while\n  <code>\n   quotearg_n_options\n  </code>\n  receives the first three of its arguments in registers, and only the last one on the stack. This might be due to a modifier in the function's prototype, and it might also be due to the function being declared\n  <code>\n   static\n  </code>\n  , so the compiler knows it can't be called from outside the current source file so it's safe to change it's\n  <code>\n   ABI\n  </code>\n  .\n </p>\n <p>\n  Now, from\n  <code>\n   quotearg\n  </code>\n  to\n  <code>\n   quotearg_n\n  </code>\n  , the number of parameters on the stack increases, so the compiler\n  <strong>\n   needs to make room for them\n  </strong>\n  , initializes them, calls the subroutine, and returns.\n </p>\n <p>\n  From\n  <code>\n   quotearg_n\n  </code>\n  to\n  <code>\n   quotearg_n_options\n  </code>\n  , the number of parameters increases again (from 2 to 4), but since three parameters are passed in registers\n  <code>\n   eax\n  </code>\n  ,\n  <code>\n   edx\n  </code>\n  and\n  <code>\n   ecx\n  </code>\n  , only the string has to be on the stack. Which means the number of parameter on the stack\n  <em>\n   decreases\n  </em>\n  , so\n  <strong>\n   the call needs\n   <em>\n    less\n   </em>\n   stack space\n  </strong>\n  , which allows the compiler to recycle the current stack. So what the compiler does is something called\n  <em>\n   tail call elimination\n  </em>\n  : instead of calling the function, then returning, it sets up the stack in the way the callee expects it, then jumps to it instead of using a call. That function (\n  <code>\n   quotearg_n_options\n  </code>\n  ) will execute, and when it returns, it will directly return to the function that called\n  <code>\n   quotearg_n\n  </code>\n  , the original one.\n </p>\n <p>\n  So to answer your question: The compiler uses the\n  <a href=\"https://stackoverflow.com/questions/310974/what-is-tail-call-optimization\">\n   tail call elimination\n  </a>\n  optimization, which it can do only if the number of parameters\n  <em>\n   on the stack\n  </em>\n  of the called function is lower than the number of parameters\n  <em>\n   on the stack\n  </em>\n  of the caller.\n </p>\n</div>\n</body></html>",
            "votes": "4",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": true,
            "comments": []
        }
    ]
}