{
    "title": "What factors affect the base address of a shared object?",
    "link": "https://reverseengineering.stackexchange.com/questions/32014/what-factors-affect-the-base-address-of-a-shared-object",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm looking at a CVE for an old thrift shop router that amounts to a stack based buffer overflow with no\n  <code>\n   NULL\n  </code>\n  characters allowed. I can control the instruction pointer register as well as a few less useful registers. My goal is to perform a stack pivot to something I control. The router runs on MIPS big endian architecture so I can't leave the last 8 bits of a payload empty to get a leading\n  <code>\n   NULL\n  </code>\n  in an address. e.g. 0x00XXXXXX. I'm left to look for gadgets in shared objects (or the stack if cache flushed). I find that shared objects are generally loaded at higher addresses that make use of all 32 bits of the address. I cannot use gadgets from the vulnerable process because it was not compiled with\n  <code>\n   -fpie\n  </code>\n  and it loads at the same address with a leading\n  <code>\n   NULL\n  </code>\n  every time.\n </p>\n <p>\n  If I consistently want to be able to use gadgets in a shared object, it will need to be loaded with the same base address most of the time. Assuming no ASLR (not enabled on my router), what determines where a shared object will be loaded?\n </p>\n <p>\n  If I run\n  <code>\n   ldd\n  </code>\n  on the target binary, I get this:\n </p>\n <pre><code>$ mips-linux-ldd squashfs-root/sbin/my_binary\n    /lib/ld-uClibc.so.0 => /lib/ld-uClibc.so.0 (0x00000000)\n</code></pre>\n <p>\n  Not super useful. I know that\n  <code>\n   ld-uClibc.so.0\n  </code>\n  doesn't get loaded at\n  <code>\n   0x00000000\n  </code>\n  and that there are several other libraries that get loaded for this process (not\n  <code>\n   dlopen\n  </code>\n  'ed) which are not listed. Perhaps the non-useful output is a toolchain thing or due to the fact that I'm not running on the target architecture.\n </p>\n <p>\n  Under the hood, I'd think we're looking at\n  <code>\n   mmap\n  </code>\n  logic.\n </p>\n <p>\n  I found this in an article from Oracle:\n </p>\n <blockquote>\n  <p>\n   An executable or shared object file's base address is calculated during execution from three values: the memory load address, the maximum page size, and the lowest virtual address of a program's loadable segment\n  </p>\n </blockquote>\n <p>\n  To me it seems like these things would never change when working with a specific firmware version where the binaries can always be expected to be the same.\n </p>\n <p>\n  My questions are:\n </p>\n <ul>\n  <li>\n   Will shared objects get loaded in the same place every time on a Linux system with ASLR disabled?\n   <ul>\n    <li>\n     Is the mapping deterministic?\n    </li>\n   </ul>\n  </li>\n  <li>\n   What factors, if any will make the shared object map to a different address?\n   <ul>\n    <li>\n     Perhaps 2 libraries conflict in a preferred address\n    </li>\n   </ul>\n  </li>\n  <li>\n   Iff library loading is deterministic, can I assume the shared object will always be at the same address after checking once? The word\n   <em>\n    deterministic\n   </em>\n   answers my own question, but I want to be clear.\n  </li>\n </ul>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 0,
    "views": "67",
    "tags": [
        "linux",
        "exploit",
        "mips",
        "libraries"
    ],
    "user": "Matthew Tingum",
    "time": "Jul 1, 2023 at 1:57",
    "comments": [],
    "answers_data": []
}