{
    "title": "How to recover information stored in .ctors section?",
    "link": "https://reverseengineering.stackexchange.com/questions/6285/how-to-recover-information-stored-in-ctors-section",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Test is on x86, 32-bit Linux. I am using\n  <code>\n   g++\n  </code>\n  4.6.3 and\n  <code>\n   objdump\n  </code>\n  2.22\n </p>\n <p>\n  Here is a simple C++ code I am working on:\n </p>\n <pre><code>#include <iostream>\n\nusing namespace std;\n\nmain()\n{\n    cout << \"Hello World!\" << endl;\n    return 0;\n}\n</code></pre>\n <p>\n  When I compile it into assembly code using :\n </p>\n <pre><code>gcc -S hello.cc\n</code></pre>\n <p>\n  I can find out a\n  <code>\n   ctors\n  </code>\n  section in the\n  <strong>\n   hello.s\n  </strong>\n  below:\n </p>\n <pre><code>.section    .ctors,\"aw\",@progbits\n.align 4\n.long   _GLOBAL__sub_I_main\n.weakref    _ZL20__gthrw_pthread_oncePiPFvvE,pthread_once\n.weakref    _ZL27__gthrw_pthread_getspecificj,pthread_getspecific\n.weakref    _ZL27__gthrw_pthread_setspecificjPKv,pthread_setspecific\n.weakref    _ZL22__gthrw_pthread_createPmPK14pthread_attr_tPFPvS3_ES3_,pthread_create\n.weakref    _ZL20__gthrw_pthread_joinmPPv,pthread_join\n.weakref    _ZL21__gthrw_pthread_equalmm,pthread_equal\n.weakref    _ZL20__gthrw_pthread_selfv,pthread_self\n.weakref    _ZL22__gthrw_pthread_detachm,pthread_detach\n.weakref    _ZL22__gthrw_pthread_cancelm,pthread_cancel\n.weakref    _ZL19__gthrw_sched_yieldv,sched_yield\n.weakref    _ZL26__gthrw_pthread_mutex_lockP15pthread_mutex_t,pthread_mutex_lock\n.weakref    _ZL29__gthrw_pthread_mutex_trylockP15pthread_mutex_t,pthread_mutex_trylock\n.weakref    _ZL31__gthrw_pthread_mutex_timedlockP15pthread_mutex_tPK8timespec,pthread_mutex_timedlock\n.weakref    _ZL28__gthrw_pthread_mutex_unlockP15pthread_mutex_t,pthread_mutex_unlock\n.weakref    _ZL26__gthrw_pthread_mutex_initP15pthread_mutex_tPK19pthread_mutexattr_t,pthread_mutex_init\n.weakref    _ZL29__gthrw_pthread_mutex_destroyP15pthread_mutex_t,pthread_mutex_destroy\n.weakref    _ZL30__gthrw_pthread_cond_broadcastP14pthread_cond_t,pthread_cond_broadcast\n.weakref    _ZL27__gthrw_pthread_cond_signalP14pthread_cond_t,pthread_cond_signal\n.weakref    _ZL25__gthrw_pthread_cond_waitP14pthread_cond_tP15pthread_mutex_t,pthread_cond_wait\n.weakref    _ZL30__gthrw_pthread_cond_timedwaitP14pthread_cond_tP15pthread_mutex_tPK8timespec,pthread_cond_timedwait\n.weakref    _ZL28__gthrw_pthread_cond_destroyP14pthread_cond_t,pthread_cond_destroy\n.weakref    _ZL26__gthrw_pthread_key_createPjPFvPvE,pthread_key_create\n.weakref    _ZL26__gthrw_pthread_key_deletej,pthread_key_delete\n.weakref    _ZL30__gthrw_pthread_mutexattr_initP19pthread_mutexattr_t,pthread_mutexattr_init\n.weakref    _ZL33__gthrw_pthread_mutexattr_settypeP19pthread_mutexattr_ti,pthread_mutexattr_settype\n.weakref    _ZL33__gthrw_pthread_mutexattr_destroyP19pthread_mutexattr_t,pthread_mutexattr_destroy\n</code></pre>\n <p>\n  However, when I assembly the asm code, producing an exe file and use the\n  <code>\n   objdump\n  </code>\n  produce the\n  <code>\n   ctors\n  </code>\n  section's contain like this:\n </p>\n <pre><code>objdump -Dr -j .ctors hellocpp\n</code></pre>\n <p>\n  All I can get is like this:\n </p>\n <pre><code>hellocpp:     file format elf32-i386\n\n\nDisassembly of section .ctors:\n\n08049efc <__CTOR_LIST__>:\n 8049efc:   ff                      (bad)  \n 8049efd:   ff                      (bad)  \n 8049efe:   ff                      (bad)  \n 8049eff:   ff 00                   incl   (%eax)\n\n08049f00 <__CTOR_END__>:\n 8049f00:   00 00                   add    %al,(%eax)\n ...\n</code></pre>\n <p>\n  Currently I am trying to recover the content of some ELF binaries compiled from\n  <code>\n   c++\n  </code>\n  program..\n </p>\n <p>\n  So I am wondering if there is a way to get the content of\n  <code>\n   ctors\n  </code>\n  which equals to what\n  <code>\n   g++\n  </code>\n  produced?\n </p>\n <h3>\n  Update:\n </h3>\n <p>\n  Thanks a lot for @Igor's help. But I am still trapped in looking for\n  <code>\n   class's\n  </code>\n  <code>\n   constructor\n  </code>\n  and\n  <code>\n   destructor\n  </code>\n  info from ELF binary.\n </p>\n <p>\n  When evolving\n  <code>\n   class\n  </code>\n  definition, g++ would produce these info in the\n  <code>\n   .ctors\n  </code>\n  section:\n </p>\n <pre><code>    .globl  _ZN8ComputerC1Ev\n    .set    _ZN8ComputerC1Ev,_ZN8ComputerC2Ev\n    .globl  _ZN8ComputerD1Ev\n    .set    _ZN8ComputerD1Ev,_ZN8ComputerD2Ev\n</code></pre>\n <p>\n  Generally\n  <code>\n   _ZN8ComputerC2Ev\n  </code>\n  is the name of a class's constructor while\n  <code>\n   _ZN8ComputerD2Ev\n  </code>\n  is its  destructor.\n </p>\n <p>\n  However, I just can not find corresponding info in the\n  <code>\n   objdump\n  </code>\n  dumped\n  <code>\n   .ctors\n  </code>\n  or\n  <code>\n   .init_array\n  </code>\n  sections.. I also tried\n  <code>\n   .eh_frame\n  </code>\n  and\n  <code>\n   gcc_except_table\n  </code>\n  , but the information dumped is massive.. I can not figure out the meaning of those information..\n </p>\n <p>\n  Could anyone give me guide?\n </p>\n</div>\n</body></html>",
    "votes": "7",
    "answers": 2,
    "views": "4k",
    "tags": [
        "disassembly",
        "x86",
        "c++",
        "elf"
    ],
    "user": "lllllllllllll",
    "time": "Jun 17, 2020 at 9:54",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The\n  <code>\n   .ctors\n  </code>\n  section is a list of pointers terminated with -1 (0xFFFFFFFF), so it does not make sense to disassemble it. If you rearrange the bytes as data, you get:\n </p>\n <pre><code>__CTOR_LIST__: .long 0xffffffff\n__CTOR_END__:  .long 0x00000000\n</code></pre>\n <p>\n  So, for whatever reason, the resulting exe does not actually use the\n  <code>\n   .ctors\n  </code>\n  section. I suspect the linker instead placed the pointers into the new-style\n  <code>\n   .init_array\n  </code>\n  section. Note that it is, again, a list of pointers, and not code.\n </p>\n <p>\n  <strong>\n   Edit\n  </strong>\n  :\n </p>\n <p>\n  The\n  <code>\n   .ctors\n  </code>\n  or\n  <code>\n   .init_array\n  </code>\n  sections only contain so-called\n  <em>\n   constructor functions\n  </em>\n  - functions that need to be executed at startup, before the\n  <code>\n   main()\n  </code>\n  itself. These are usually compiler-generated functions that perform construction of global objects (such as\n  <code>\n   cin\n  </code>\n  ,\n  <code>\n   cout\n  </code>\n  etc.), or other startup-related tasks. You can, in fact, add your own functions to that list using\n  <a href=\"https://stackoverflow.com/questions/2053029/how-exactly-does-attribute-constructor-work\">\n   <code>\n    __attribute__((constructor))\n   </code>\n  </a>\n  .\n </p>\n <p>\n  What does\n  <strong>\n   not\n  </strong>\n  go there are general C++ class constructors - there is no need to execute those on startup. They will be called when and if you construct an object of a specific class - e.g. by declaring a variable or calling\n  <code>\n   operator new\n  </code>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "9",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": true,
            "comments": [
                {
                    "user": "lllllllllllll",
                    "text": "<span class=\"comment-copy\">Groovy! I dump the content of <code>.init_array</code> section and it contains the address of <code>_GLOBAL__sub_I_main</code> function!</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  As Igor stated, the\n  <code>\n   .ctors\n  </code>\n  section is a list of function pointers, ending with a sentinel value of\n  <code>\n   0xffffffff\n  </code>\n  . To see its contents, just do\n </p>\n <pre><code>$ objdump -s -j.ctors bar.so\n</code></pre>\n <p>\n  But your assembly file only contains weak symbols. Those are foreign functions in other libraries, and are invoked when their libraries are loaded at runtime.\n </p>\n <p>\n  For example, put this in a file\n  <code>\n   bar.cpp\n  </code>\n  :\n </p>\n <pre><code>class Foo {\npublic:\n  int i;\n\n  Foo(int n) : i(n) {\n  }\n};\n\nFoo global_foo(123);\n</code></pre>\n <p>\n  Compile with\n </p>\n <pre><code>$ g++ -shared -fPIC bar.cpp -obar.so\n</code></pre>\n <p>\n  The contents of the\n  <code>\n   .init_array\n  </code>\n  section is\n </p>\n <pre><code>$ objdump -s -j.init_array bar.so\n\nbar.so:     file format elf64-x86-64\n\nContents of section .init_array:\n 200820 ad060000 00000000                    ........        \n</code></pre>\n <p>\n  There's a function pointer there,\n  <code>\n   0xad060000 00000000\n  </code>\n  . But you have to change its endianness, e.g. with Python:\n </p>\n <pre><code>>>> import struct\n>>> import binascii\n>>> binascii.hexlify(struct.pack(\"<Q\", 0xad06000000000000))\n'00000000000006ad'\n</code></pre>\n <p>\n  Now list all symbols and grep for that address:\n </p>\n <pre><code>$ objdump -C --syms bar.so | grep 00000000000006ad\n00000000000006ad l     F .text  0000000000000015\n  [... on above line ...] global constructors keyed to bar.cpp\n</code></pre>\n <p>\n  The disassembly for it,\n </p>\n <pre><code>$ objdump -C -d bar.so\n</code></pre>\n <p>\n  shows\n </p>\n <pre><code>00000000000006ad <global constructors keyed to bar.cpp>:\n 6ad:   55                      push   %rbp\n 6ae:   48 89 e5                mov    %rsp,%rbp\n 6b1:   be ff ff 00 00          mov    $0xffff,%esi\n 6b6:   bf 01 00 00 00          mov    $0x1,%edi\n 6bb:   e8 ba ff ff ff          callq  67a <__static_initialization_and_destruction_0(int, int)>\n 6c0:   c9                      leaveq \n 6c1:   c3                      retq   \n</code></pre>\n <p>\n  which jumps to\n  <code>\n   __static_initialization_and_destruction_0(int, int)\n  </code>\n  :\n </p>\n <pre><code>000000000000067a <__static_initialization_and_destruction_0(int, int)>:\n 67a:   55                      push   %rbp\n 67b:   48 89 e5                mov    %rsp,%rbp\n 67e:   48 83 ec 10             sub    $0x10,%rsp\n 682:   89 7d fc                mov    %edi,-0x4(%rbp)\n 685:   89 75 f8                mov    %esi,-0x8(%rbp)\n 688:   83 7d fc 01             cmpl   $0x1,-0x4(%rbp)\n 68c:   75 1d                   jne    6ab <__static_initialization_and_destruction_0(int, int)+0x31>\n 68e:   81 7d f8 ff ff 00 00    cmpl   $0xffff,-0x8(%rbp)\n 695:   75 14                   jne    6ab <__static_initialization_and_destruction_0(int, int)+0x31>\n 697:   be 7b 00 00 00          mov    $0x7b,%esi\n 69c:   48 8b 05 9d 03 20 00    mov    0x20039d(%rip),%rax        # 200a40 <_DYNAMIC+0x1e8>\n 6a3:   48 89 c7                mov    %rax,%rdi\n 6a6:   e8 f5 fe ff ff          callq  5a0 <Foo::Foo(int)@plt>\n 6ab:   c9                      leaveq \n 6ac:   c3                      retq   \n</code></pre>\n <p>\n  which puts 123 (\n  <code>\n   0x7b\n  </code>\n  ) on the stack and calls\n  <code>\n   Foo::Foo(int)\n  </code>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "5",
            "user": "csl",
            "time": "Jun 3, 2016 at 9:02",
            "is_accepted": false,
            "comments": []
        }
    ]
}