{
    "title": "Problem with converting hex values to decimal",
    "link": "https://reverseengineering.stackexchange.com/questions/15111/problem-with-converting-hex-values-to-decimal",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm reverse-engineering custom binary file format. I'm using 010 Editor to check this file. I found data structure to represent UTF-8 strings, which has header section of one or two bytes in length then the actual UTF-8 string data. The header section seems to store total number of bytes needed for the string data.\n </p>\n <pre><code>╔════════════╦═══════════════╦═══════════════════╗\n║ first byte ║ optional byte ║ UTF-8 string data ║\n╚════════════╩═══════════════╩═══════════════════╝\n</code></pre>\n <p>\n  The second byte in header is optional and it's only there when UTF-8 string needs more than 128 bytes to be stored. When string length is less or equal 128 bytes, decoding it's length is easy. However, when string length > 128, I'm failing to calculate string length from header section. So I did experiments and generated many binary files with different string length and below is the result. String length is the total number of bytes needed to store the string. First and second columns are first and second optional byte in header section.\n </p>\n <pre><code>╔════╦════╦═══════════════╗\n║ 01 ║ 02 ║ String length ║\n╠════╬════╬═══════════════╣\n║ 7D ║N/A ║           126 ║\n║ 7E ║N/A ║           127 ║\n║ 7F ║N/A ║           128 ║\n║ 80 ║ 01 ║           129 ║\n║ 81 ║ 01 ║           130 ║\n║ C7 ║ 01 ║           200 ║\n║ C8 ║ 01 ║           201 ║\n║ F9 ║ 01 ║           250 ║\n║ FE ║ 01 ║           255 ║\n║ FF ║ 01 ║           256 ║\n║ 80 ║ 02 ║           257 ║\n║ 81 ║ 02 ║           258 ║\n║ 82 ║ 02 ║           259 ║\n║ F3 ║ 03 ║           500 ║\n║ F4 ║ 03 ║           501 ║\n║ F5 ║ 03 ║           502 ║\n║ F6 ║ 03 ║           503 ║\n║ 80 ║ 04 ║           513 ║\n╚════╩════╩═══════════════╝\n</code></pre>\n <p>\n  I read somewhere that Pascal\\Delphi is using string format where it has header to save string length instead of null terminated strings like in C, which look similar to my case.\n </p>\n <p>\n  My question is how can I calculate string length when it's greater than 128 bytes in length using values in header section?\n </p>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 2,
    "views": "353",
    "tags": [
        "binary-analysis",
        "hex",
        "strings",
        "struct",
        "binary-format"
    ],
    "user": "Anthony J.",
    "time": "Apr 6, 2017 at 15:05",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  This is not the pascal/delphi string format, as those are either constant 1 byte or 4 bytes long length fields.\n </p>\n <p>\n  It does have some resemblance to the ASN1 format, except ASN1 comes with an additional field denoting the type of the object.\n </p>\n <p>\n  Anyways, This looks like the\n  <em>\n   Most significant bit\n  </em>\n  of the first byte is not part of the length and has the special meaning of extending the length by an additional byte.\n </p>\n <p>\n  If you take that table:\n </p>\n <pre><code>In [24]: t\nOut[24]:\n[['7D', 'N/A', '126'],\n ['7E', 'N/A', '127'],\n ['7F', 'N/A', '128'],\n ['80', '01', '129'],\n ['81', '01', '130'],\n ['C7', '01', '200'],\n ['C8', '01', '201'],\n ['F9', '01', '250'],\n ['FE', '01', '255'],\n ['FF', '01', '256'],\n ['80', '02', '257'],\n ['81', '02', '258'],\n ['82', '02', '259'],\n ['F3', '03', '500'],\n ['F4', '03', '501'],\n ['F5', '03', '502'],\n ['F6', '03', '503'],\n ['80', '04', '513']]\n</code></pre>\n <p>\n  And split the MSB off the first byte:\n </p>\n <pre><code>In [36]: t2=[[int(l[0], 16)&0b10000000>0, hex(int(l[0], 16)&0b01111111)[2:]]+l[1:] for l in t]\n\nIn [37]: t2\nOut[37]:\n[[False, '7d', 'N/A', '126'],\n [False, '7e', 'N/A', '127'],\n [False, '7f', 'N/A', '128'],\n [True, '0', '01', '129'],\n [True, '1', '01', '130'],\n [True, '47', '01', '200'],\n [True, '48', '01', '201'],\n [True, '79', '01', '250'],\n [True, '7e', '01', '255'],\n [True, '7f', '01', '256'],\n [True, '0', '02', '257'],\n [True, '1', '02', '258'],\n [True, '2', '02', '259'],\n [True, '73', '03', '500'],\n [True, '74', '03', '501'],\n [True, '75', '03', '502'],\n [True, '76', '03', '503'],\n [True, '0', '04', '513']]\n</code></pre>\n <p>\n  First, lets note that\n  <code>\n   0x7D\n  </code>\n  is 125 in decimal, not 126. This is true for all values where MSB is clear, so all of these values are always increased by one.\n </p>\n <p>\n  Then if the MSB is set, values in the second byte are multiplied by 128 and then added to the first byte's result.\n </p>\n <p>\n  Here's an example that calculates the result using the previous two bytes (and appends it as the last value:\n </p>\n <pre><code>In [53]: t3 = [l+[int(l[1], 16) + 1 + (int(l[2], 16)*128 if l[0] else 0)] for l in t2]\n\nIn [54]: t3\nOut[54]:\n[[False, '7d', 'N/A', '126', 126],\n [False, '7e', 'N/A', '127', 127],\n [False, '7f', 'N/A', '128', 128],\n [True, '0', '01', '129', 129],\n [True, '1', '01', '130', 130],\n [True, '47', '01', '200', 200],\n [True, '48', '01', '201', 201],\n [True, '79', '01', '250', 250],\n [True, '7e', '01', '255', 255],\n [True, '7f', '01', '256', 256],\n [True, '0', '02', '257', 257],\n [True, '1', '02', '258', 258],\n [True, '2', '02', '259', 259],\n [True, '73', '03', '500', 500],\n [True, '74', '03', '501', 501],\n [True, '75', '03', '502', 502],\n [True, '76', '03', '503', 503],\n [True, '0', '04', '513', 513]]\n</code></pre>\n <p>\n  The code doing the calculation above is not too pretty, so here's a short python function that does the same:\n </p>\n <pre><code>def calc(first_byte, second_byte):\n    value = 1\n    value += first_byte & 0x7F\n    msb = bool(first_byte >> 7)\n    if msb:\n        value += second_byte * 128\n</code></pre>\n <p>\n  Another way to look at it, which might be more intuitive, is that the second byte is a continuation of the 7 bits (excluding the MSB) for the first byte.\nHere's a function doing the same calculation based on that approach:\n </p>\n <pre><code>def calc(first_byte, second_byte):\n    value = 1\n    value += first_byte & 0x7F\n    msb = bool(first_byte >> 7)\n    if msb:\n        value += second_byte << 7\n</code></pre>\n <p>\n  We're lacking any values having the MSB set on the second byte, but this approach might be sequential, allowing larger ranges using additional bytes by setting the MSBs of all previous bytes.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "NirIzr",
            "time": "Apr 6, 2017 at 11:35",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  This looks like the\n  <code>\n   LEB128\n  </code>\n  encoding.\n </p>\n <p>\n </p>\n <p>\n  Essentially, this is a variable length encoding where the lowest 7 bits of each byte store part of the value and highest bit of each byte is set if it's not the last byte. The successive 7-bit values are stored in little-endian order.\n </p>\n <p>\n </p>\n <p>\n  For more details, and especially for how signed numbers are handled, see either the\n  <a href=\"http://dwarfstd.org/\" rel=\"nofollow noreferrer\" title=\"DWARF Debugging Standard\">\n   DWARF Debugging Standard\n  </a>\n  or the\n  <a href=\"https://source.android.com/devices/tech/dalvik/dex-format.html\" rel=\"nofollow noreferrer\" title=\"DEX format\">\n   Android DEX file format\n  </a>\n  documentation.\n </p>\n <p>\n </p>\n <p>\n  This is similar to the Variable-Length Quantity format used in MIDI files and ASN.1 encoding which uses big-endian ordering.\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Ian Cook",
            "time": "Apr 6, 2017 at 15:56",
            "is_accepted": false,
            "comments": []
        }
    ]
}