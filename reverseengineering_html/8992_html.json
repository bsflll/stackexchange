{
    "title": "Floating point registers on ARM",
    "link": "https://reverseengineering.stackexchange.com/questions/8992/floating-point-registers-on-arm",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  When I disassemble ARM code that deals with floating point values, how can I print out the registers? (I'm using Gdb).\n </p>\n <pre><code>   0x000083d8 <+12>:    ldr r3, [pc, #56]   ; 0x8418 <main+76>\n   0x000083dc <+16>:    str r3, [r11, #-8]\n   0x000083e0 <+20>:    vldr    s14, [r11, #-8]\n   0x000083e4 <+24>:    vldr    s15, [pc, #40]  ; 0x8414 <main+72>\n</code></pre>\n <p>\n  How could I print out the\n  <code>\n   s14\n  </code>\n  register in this case?\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 2,
    "views": "1k",
    "tags": [
        "arm"
    ],
    "user": null,
    "time": "May 26, 2015 at 14:30",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  To print the value of\n  <code>\n   s14\n  </code>\n  from gdb:\n </p>\n <p>\n  <code>\n   info registers s14\n  </code>\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "Jason Geffner",
            "time": "May 26, 2015 at 14:33",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <strong>\n   <code>\n    p $reg\n   </code>\n  </strong>\n </p>\n <p>\n  In QEMU v3.0.0 built from source\n  <a href=\"https://stackoverflow.com/questions/20590155/how-to-single-step-arm-assembly-in-gdb-on-qemu/51310791#51310791\">\n   user mode\n  </a>\n  + GDB 8.2 Ubuntu 16.04, if you do:\n  <code>\n   info registers\n  </code>\n  and\n  <code>\n   info vector\n  </code>\n  it does not show the floating point values but rather rounds them down to integers, I think there is a bug.\n </p>\n <p>\n  The following does work however. First I load:\n </p>\n <pre><code>1.5, 2.5, 3.5, 4.5\n</code></pre>\n <p>\n  into v0 / q0.\n </p>\n <p>\n  <strong>\n   ARMv8\n  </strong>\n </p>\n <pre><code>(gdb) p $v0\n$2 = {\n  d = {\n    f = {[0] = 8.0000018998980522, [1] = 1024.0002455711365}, \n    u = {[0] = 4620693218751676416, [1] = 4652218416153755648}, \n    s = {[0] = 4620693218751676416, [1] = 4652218416153755648}\n  }, \n  s = {\n    f = {[0] = 1.5, [1] = 2.5, [2] = 3.5, [3] = 4.5}, \n    u = {[0] = 1069547520, [1] = 1075838976, [2] = 1080033280, [3] = 1083179008}, \n    s = {[0] = 1069547520, [1] = 1075838976, [2] = 1080033280, [3] = 1083179008}\n  }, \n  h = {\n    u = {[0] = 0, [1] = 16320, [2] = 0, [3] = 16416, [4] = 0, [5] = 16480, [6] = 0, [7] = 16528}, \n    s = {[0] = 0, [1] = 16320, [2] = 0, [3] = 16416, [4] = 0, [5] = 16480, [6] = 0, [7] = 16528}\n  }, \n  b = {\n    u = {[0] = 0, [1] = 0, [2] = 192, [3] = 63, [4] = 0, [5] = 0, [6] = 32, [7] = 64, [8] = 0, [9] = 0, [10] = 96, [11] = 64, [12] = 0, [13] = 0, [14] = 144, [15] = 64}, \n    s = {[0] = 0, [1] = 0, [2] = -64, [3] = 63, [4] = 0, [5] = 0, [6] = 32, [7] = 64, [8] = 0, [9] = 0, [10] = 96, [11] = 64, [12] = 0, [13] = 0, [14] = -112, [15] = 64}\n  }, \n  q = {\n    u = {[0] = 85818282497786728556221825347259203584}, \n    s = {[0] = 85818282497786728556221825347259203584}\n  }\n}\n</code></pre>\n <p>\n  and:\n </p>\n <pre><code>(gdb) p $v0.s\n$3 = {\n  f = {[0] = 1.5, [1] = 2.5, [2] = 3.5, [3] = 4.5}, \n  u = {[0] = 1069547520, [1] = 1075838976, [2] = 1080033280, [3] = 1083179008}, \n  s = {[0] = 1069547520, [1] = 1075838976, [2] = 1080033280, [3] = 1083179008}\n}\n</code></pre>\n <p>\n  and:\n </p>\n <pre><code>(gdb) p $v0.s.f\n$3 = {[0] = 1.5, [1] = 2.5, [2] = 3.5, [3] = 4.5}\n</code></pre>\n <p>\n  <a href=\"https://github.com/cirosantilli/arm-assembly-cheat/blob/d5dafc3528f8f735e5ed0f36e7aa8014a145a240/v8/simd.S#L68\" rel=\"nofollow noreferrer\">\n   Test setup\n  </a>\n  .\n </p>\n <p>\n  <strong>\n   ARMv7\n  </strong>\n </p>\n <pre><code>(gdb) p $q0\n$3 = {\n  u8 = {[0] = 0, [1] = 0, [2] = 192, [3] = 63, [4] = 0, [5] = 0, [6] = 32, [7] = 64, [8] = 0, [9] = 0, [10] = 96, [11] = 64, [12] = 0, [13] = 0, [14] = 144, [15] = 64}, \n  u16 = {[0] = 0, [1] = 16320, [2] = 0, [3] = 16416, [4] = 0, [5] = 16480, [6] = 0, [7] = 16528}, \n  u32 = {[0] = 1069547520, [1] = 1075838976, [2] = 1080033280, [3] = 1083179008}, \n  u64 = {[0] = 4620693218751676416, [1] = 4652218416153755648}, \n  f32 = {[0] = 1.5, [1] = 2.5, [2] = 3.5, [3] = 4.5}, \n  f64 = {[0] = 8.0000018998980522, [1] = 1024.0002455711365}\n}\n</code></pre>\n <p>\n  and:\n </p>\n <pre><code>(gdb) p $q0.f32\n$5 = {[0] = 1.5, [1] = 2.5, [2] = 3.5, [3] = 4.5}\n</code></pre>\n <p>\n  <a href=\"https://github.com/cirosantilli/arm-assembly-cheat/blob/d5dafc3528f8f735e5ed0f36e7aa8014a145a240/v7/simd.S#L89\" rel=\"nofollow noreferrer\">\n   Test setup\n  </a>\n  .\n </p>\n <p>\n  <strong>\n   Bug\n  </strong>\n </p>\n <p>\n  The bug I mentioned earlier, leads in ARMv8 to:\n </p>\n <pre><code>(gdb) i r v0\nv0             {\n  d = {\n    f = {[0x0] = 0x8, [0x1] = 0x400}, \n    u = {[0x0] = 0x402000003fc00000, [0x1] = 0x4090000040600000}, \n    s = {[0x0] = 0x402000003fc00000, [0x1] = 0x4090000040600000}\n  }, \n  s = {\n    f = {[0x0] = 0x1, [0x1] = 0x2, [0x2] = 0x3, [0x3] = 0x4}, \n    u = {[0x0] = 0x3fc00000, [0x1] = 0x40200000, [0x2] = 0x40600000, [0x3] = 0x40900000}, \n    s = {[0x0] = 0x3fc00000, [0x1] = 0x40200000, [0x2] = 0x40600000, [0x3] = 0x40900000}\n  }, \n  h = {\n    u = {[0x0] = 0x0, [0x1] = 0x3fc0, [0x2] = 0x0, [0x3] = 0x4020, [0x4] = 0x0, [0x5] = 0x4060, [0x6] = 0x0, [0x7] = 0x4090}, \n    s = {[0x0] = 0x0, [0x1] = 0x3fc0, [0x2] = 0x0, [0x3] = 0x4020, [0x4] = 0x0, [0x5] = 0x4060, [0x6] = 0x0, [0x7] = 0x4090}\n  }, \n  b = {\n    u = {[0x0] = 0x0, [0x1] = 0x0, [0x2] = 0xc0, [0x3] = 0x3f, [0x4] = 0x0, [0x5] = 0x0, [0x6] = 0x20, [0x7] = 0x40, [0x8] = 0x0, [0x9] = 0x0, [0xa] = 0x60, [0xb] = 0x40, [0xc] = 0x0, [0xd] = 0x0, [0xe] = 0x90, [0xf] = 0x40}, \n    s = {[0x0] = 0x0, [0x1] = 0x0, [0x2] = 0xc0, [0x3] = 0x3f, [0x4] = 0x0, [0x5] = 0x0, [0x6] = 0x20, [0x7] = 0x40, [0x8] = 0x0, [0x9] = 0x0, [0xa] = 0x60, [0xb] = 0x40, [0xc] = 0x0, [0xd] = 0x0, [0xe] = 0x90, [0xf] = 0x40}\n  }, \n  q = {\n    u = {[0x0] = 0x4090000040600000402000003fc00000}, \n    s = {[0x0] = 0x4090000040600000402000003fc00000}\n  }\n}\n</code></pre>\n <p>\n  So note how the\n  <code>\n   v0.s.f\n  </code>\n  line has rounded down integers instead of floats:\n </p>\n <pre><code>  s = {\n    f = {[0x0] = 0x1, [0x1] = 0x2, [0x2] = 0x3, [0x3] = 0x4},\n</code></pre>\n <p>\n  <strong>\n   SVE\n  </strong>\n </p>\n <p>\n  Not yet implemented on QEMU, see:\n  <a href=\"https://stackoverflow.com/questions/52888916/how-to-assemble-arm-sve-instructions-with-gnu-gas-or-llvm-and-run-it-on-qemu/52888917#52888917\">\n   https://stackoverflow.com/questions/52888916/how-to-assemble-arm-sve-instructions-with-gnu-gas-or-llvm-and-run-it-on-qemu/52888917#52888917\n  </a>\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "Ciro Santilli",
            "time": "Feb 15, 2019 at 14:18",
            "is_accepted": false,
            "comments": []
        }
    ]
}