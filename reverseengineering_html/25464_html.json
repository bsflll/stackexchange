{
    "title": "Intercepting game function with C and Assembler, game unstable with minimum changes",
    "link": "https://reverseengineering.stackexchange.com/questions/25464/intercepting-game-function-with-c-and-assembler-game-unstable-with-minimum-chan",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am reverse engeneering a really old game (Mu 97d) for the sake of adding new things to the game.\nWhat I am doing is intercepting the game with a DLL, and in the DLL do the calculations so I can add the new things.\n </p>\n <p>\n  I have this code that intercepts an 'if' statement, and I redirect it to my own function - based on the input - my function returns true or false.\n </p>\n <p>\n  <strong>\n   C code:\n  </strong>\n </p>\n <pre><code>/* Called on player load - 12 bytes */\n*(BYTE*)(0x004798CD  + 0) = 0x50;  /* PUSH EAX */\n*(BYTE*)(0x004798CD  + 1) = 0xE8;  /* CALL */\n*(DWORD*)(0x004798CD + 2) = (DWORD)&Unk11 - (0x004798CD + 6); /* FUNCTION TO CALL */\n*(BYTE*)(0x004798CD  + 6) = 0x85;  /* TEST */\n*(BYTE*)(0x004798CD  + 7) = 0xC0;  /* EAX, EAX */\n*(BYTE*)(0x004798CD  + 8) = 0x58;  /* POP EAX */\n*(BYTE*)(0x004798CD  + 9) = 0x74;  /* JE */\n*(BYTE*)(0x004798CD  + 10) = 0x15;  /* 15 */\n*(BYTE*)(0x004798CD  + 11) = 0x90;  /* NOP */\n</code></pre>\n <p>\n  <strong>\n   ASM part that I am intercepting\n  </strong>\n </p>\n <pre><code>[...]\n004798A1  |.  81E7 FF000000 AND EDI,000000FF\n004798A7  |.  8D0440        LEA EAX,[EAX*2+EAX]\n    004798AA  |.  C1E0 02       SHL EAX,2\n004798AD  |.  99            CDQ\n004798AE  |.  F7FF          IDIV EDI\n004798B0  |.  8BD8          MOV EBX,EAX\n004798B2  |.  B8 67666666   MOV EAX,66666667\n004798B7  |.  F7EF          IMUL EDI\n004798B9  |.  D1FA          SAR EDX,1\n004798BB  |.  8BC2          MOV EAX,EDX\n004798BD      03D3          ADD EDX,EBX\n004798BF      C1E8 1F       SHR EAX,1F\n004798C2      8D5410 04     LEA EDX,[EDX+EAX+4]\n004798C6      66:0156 12    ADD WORD PTR DS:[ESI+12],DX\n004798CA      66:8B06       MOV AX,WORD PTR DS:[ESI]\n004798CD      66:3D 8301    CMP AX,183 ]---------------------- FROM HERE\n004798D1      7C 1A         JL SHORT 004798ED\n004798D3      66:3D 8601    CMP AX,186\n004798D7      7F 14         JG SHORT 004798ED ]--------------- TO HERE\n004798D9      83F9 09       CMP ECX,9\n004798DC      B8 09000000   MOV EAX,9\n004798E1      7F 02         JG SHORT 004798E5\n004798E3      8BC1          MOV EAX,ECX\n004798E5      03C0          ADD EAX,EAX\n004798E7      66:0146 12    ADD WORD PTR DS:[ESI+12],AX\n004798EB      EB 13         JMP SHORT 00479900\n004798ED      83F9 09       CMP ECX,9\n004798F0  |.  B8 09000000   MOV EAX,9\n004798F5  |.  7F 02         JG SHORT 004798F9\n004798F7  |.  8BC1          MOV EAX,ECX\n004798F9  |>  8D1440        LEA EDX,[EAX*2+EAX]\n004798FC  |.  66:0156 12    ADD WORD PTR DS:[ESI+12],DX\n00479900  |>  8D51 F7       LEA EDX,[ECX-9]\n00479903  |.  33C0          XOR EAX,EAX\n00479905  |.  85D2          TEST EDX,EDX\n00479907  |.  7E 1D         JLE SHORT 00479926\n00479909  |.  BB 04000000   MOV EBX,4\n0047990E  |.  BF 05000000   MOV EDI,5\n00479913  |>  85C0          /TEST EAX,EAX\n00479915  |.  75 06         |JNE SHORT 0047991D\n00479917  |.  66:015E 12    |ADD WORD PTR DS:[ESI+12],BX\n0047991B  |.  EB 04         |JMP SHORT 00479921\n0047991D  |>  66:017E 12    |ADD WORD PTR DS:[ESI+12],DI\n00479921  |>  40            |INC EAX\n[...]\n</code></pre>\n <p>\n  This is the code from my DLL, the function right now behaves as the game would do.\n </p>\n <pre><code>BOOL Unk11(short int a1)\n{\n    if((a1 >= 387 && a1 <= 390))\n        return TRUE;\n    return FALSE;\n}\n</code></pre>\n <p>\n  But, if I add a second condition to the IF:\n </p>\n <pre><code>BOOL Unk11(short int a1)\n{\n    if((a1 >= 387 && a1 <= 390) || (a1 >= 404 && a1 <= 415))\n        return TRUE;\n    return FALSE;\n}\n</code></pre>\n <p>\n  The game becomes unstable, even with a simple debug function that writes to a log file, the game becomes unstable, example:\n </p>\n <pre><code>BOOL Unk11(short int a1)\n{\n    Debug(\"Hello\");\n    if((a1 >= 387 && a1 <= 390))\n        return TRUE;\n    return FALSE;\n}\n</code></pre>\n <p>\n  With Ollydbg I executed the game, and checked the ASM part of my function, and this is what I've got:\n </p>\n <pre><code>CPU Disasm\nAddress   Hex dump          Command                                  Comments\n7C721B30    55              PUSH EBP\n7C721B31    8BEC            MOV EBP,ESP\n7C721B33    8B45 08         MOV EAX,DWORD PTR SS:[EBP+8]\n7C721B36    05 7DFEFFFF     ADD EAX,-183\n7C721B3B    66:B9 0300      MOV CX,3\n7C721B3F    66:3BC8         CMP CX,AX\n7C721B42    1BC0            SBB EAX,EAX\n7C721B44    40              INC EAX\n7C721B45    5D              POP EBP\n7C721B46    C3              RETN\n</code></pre>\n <p>\n  Why the ADD EAX is -183? Shouldn't it be 183? Where is the '<= 390' in this code?\nI tried with different calling conventions, but I get the same behaviour - game unstable.\n </p>\n <p>\n  Why is the game unstable even with a minimum game? The game is old, 2003 or so - could it be a compatibility issue with my DLL? I am using Visual Studio 2010.\n </p>\n <p>\n  I hope this is enough info, if not, say so!\nThanks!\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 3,
    "views": "159",
    "tags": [
        "c",
        "assembly"
    ],
    "user": "Feche1320",
    "time": "Jul 10, 2020 at 5:54",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  It's not add\n  <code>\n   -183\n  </code>\n  .\n  <code>\n   0xFFFFFE7d\n  </code>\n  is equal to\n  <code>\n   -387\n  </code>\n  . The original conditions is this\n </p>\n <pre><code>387 <= x <= 390\n</code></pre>\n <p>\n  if we add\n  <code>\n   -387\n  </code>\n  to all the sides we get\n </p>\n <pre><code>0 <= x + (-387) <= 3\n</code></pre>\n <p>\n  and this is exactly what's checked in the code.\n </p>\n <p>\n  As why the code is unstable? Well it would require a bit more detailed analysis (debugging?) but what I can see is this. Just after the code you are replacing,\n  <code>\n   ECX\n  </code>\n  is used (see\n  <code>\n   004798D9 83F9 09 CMP ECX,9\n  </code>\n  ) and yet your function destroy the value of\n  <code>\n   ECX\n  </code>\n  (see\n  <code>\n   7C721B3B 66:B9 0300 MOV CX,3\n  </code>\n  ). Try saving this value and see if it become more stable.\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Paweł Łukasik",
            "time": "Jul 10, 2020 at 7:09",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Feche1320",
                    "text": "<span class=\"comment-copy\">Thanks for the explanation, now I understand how the check is done. About the ECX register, isn't the compiler the one that has to PUSH and POP the registers that will use?  Because you are right, ECX seems to be 'overwritten' by the function itself, I will try to push ECX before my function and check if fixes the crashes.</span>",
                    "time": null
                },
                {
                    "user": "Paweł Łukasik",
                    "text": "<span class=\"comment-copy\">If compiler would do it then we would see the code for it - no code, nothing is done - you need to make sure it is saved.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  To add to\n  <a href=\"https://reverseengineering.stackexchange.com/a/25465/4731\">\n   Paweł Łukasik's answer\n  </a>\n  , the issue with ECX surrounds what is known as a 'calling convention'.\n </p>\n <p>\n  Calling conventions set out the obligations on both the caller of a function and on the called function itself.\n </p>\n <p>\n  Microsoft's 32-bit calling convention is described\n  <a href=\"https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions\" rel=\"nofollow noreferrer\">\n   here\n  </a>\n  .\n </p>\n <p>\n  It says that an obligation on the called function is -\n </p>\n <blockquote>\n  <p>\n   The compiler generates prolog and epilog code to save and restore the\nESI, EDI, EBX, and EBP registers, if they are used in the function.\n  </p>\n </blockquote>\n <p>\n  Conversely, this implies that the\n  <em>\n   caller\n  </em>\n  of a function must expect the values in other registers to NOT survive the call. (This is most obviously the case in respect of EAX - often used for the return value.)\n </p>\n <p>\n  The compiler of your Unk11 function is doing the right thing in that, since it is modifying EBP, it is preserving it's value.  It's under no obligation though to preserve ECX.\n </p>\n <p>\n  For the other side of the contact, there is no compiler here calling the function though. Instead it's your hand-crafted binary code doing the calling, so the obligation is on you to preserve ECX at that end.\n </p>\n <hr/>\n <p>\n  <strong>\n   Fixing It\n  </strong>\n </p>\n <p>\n  Obviously one solution is using inline assembler as you have done in your answer.  Here you are modifying ESI and so are correctly preserving it.\n </p>\n <p>\n  However, as you have discovered, if you call another function it is up to you, in your hand-crafted assembly, to abide by the calling convention.  It is almost certain that Debug is modifying ECX or EDX (as it is allowed to do) giving the adverse effect you are seeing.\n </p>\n <p>\n  So, if you also preserve ECX and EDX in your assembly function I suspect that you will find a call to Debug will work (or at least, if it fails, it's for some other reason.)\n </p>\n <p>\n  Something else to consider is that if you were to need any more complex logic in your DLL function, using assembly can be a pain.  Instead you might want to consider writing the function using normal C, as you were originally doing, but writing a very simple assembly wrapper that preserves the values of these additional registers around a call to your easier-to-code C function.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Ian Cook",
            "time": "Jul 19, 2020 at 10:32",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Okay, so after a few hours this is what I did - instead of a C style function, I made it with ASM; this is the result:\n </p>\n <pre><code>Naked (Unk11)\n{\n    _asm\n    {\n        PUSH ESI\n        MOV ESI, DWORD PTR SS:[ESP+8]\n\n        CMP ESI, 0x183 //387\n        JL False\n        CMP ESI, 0x186 //390\n        JLE True\nFalse:\n        MOV EAX, FALSE\n        JMP Exit\nTrue:   \n        MOV EAX, TRUE\nExit:\n        POP ESI\n        RETN\n    }\n}\n</code></pre>\n <p>\n  Now this is working correctly, the only thing that I still can't figure it out, is why if I add the 'Debug();' function, the game starts to behave strange.\nFor example, my armor goes from 95 to 45 by just adding that function.\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "Feche1320",
            "time": "Jul 10, 2020 at 22:27",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Paweł Łukasik",
                    "text": "<span class=\"comment-copy\">call to <code>Debug()</code> might also destroy some registers that the later code depends on.</span>",
                    "time": null
                }
            ]
        }
    ]
}