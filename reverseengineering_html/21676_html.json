{
    "title": "Find Target to Call Dword Ptr in 16-bit Windows with IDA Pro",
    "link": "https://reverseengineering.stackexchange.com/questions/21676/find-target-to-call-dword-ptr-in-16-bit-windows-with-ida-pro",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Looking for suggestions on steps that could be used to identify what code would get executed at call dword ptr es:[bx+0Ch] from static analysis.\n </p>\n <pre><code>cseg04:3044 loc_105D4:                              ; CODE XREF: cseg04:2F10↑j\n    cseg04:3044                 push    0\n    cseg04:3046                 push    34h ; '4'\n    cseg04:3048                 les     bx, ppMalloc\n    cseg04:304C                 push    es\n    cseg04:304D                 push    bx\n    cseg04:304E                 les     bx, es:[bx]\n    cseg04:3051                 call    dword ptr es:[bx+0Ch]\n    cseg04:3055                 add     sp, 8\n    cseg04:3058                 mov     si, ax\n    cseg04:305A                 mov     [bp-6], dx\n    cseg04:305D                 or      dx, ax\n    cseg04:305F                 jnz     short loc_105F8\n</code></pre>\n <p>\n  ppMalloc section:\n </p>\n <pre><code>eg70:3612 ppMalloc        dd 0                    ; DATA XREF: cseg04:3048↑r\ndseg70:3612                                         ; sub_145C0+24↑r ...\ndseg70:3616 ; ATOM word_10CA26\ndseg70:3616 word_10CA26     dw 0                    ; DATA XREF: sub_4637E:loc_463B1↑r\ndseg70:3616                                         ; sub_4637E+3A↑r ...\ndseg70:3618 word_10CA28     dw 0                    ; DATA XREF: sub_CE2A+1↑o\ndseg70:3618                                         ; cseg03:2F9C↑o ...\ndseg70:361A                 db    0\ndseg70:361B                 db    0\ndseg70:361C                 db    0\ndseg70:361D                 db    0\ndseg70:361E                 db    0\ndseg70:361F                 db    0\ndseg70:3620                 db    0\ndseg70:3621                 db    0\ndseg70:3622                 db    0\ndseg70:3623                 db    0\ndseg70:3624                 db    0\ndseg70:3625                 db    0\ndseg70:3626 unk_10CA36      db    0                 ; DATA XREF: sub_CE2A+A↑o\ndseg70:3626                                         ; cseg03:2F93↑o ...\ndseg70:3627                 db    0\ndseg70:3628                 db    0\ndseg70:3629                 db    0\ndseg70:362A                 db    0\ndseg70:362B                 db    0\ndseg70:362C                 db    0\ndseg70:362D                 db    0\ndseg70:362E                 db    0\ndseg70:362F                 db    0\ndseg70:3630                 db    0\ndseg70:3631                 db    0\ndseg70:3632                 dw 0\n</code></pre>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 2,
    "views": "414",
    "tags": [
        "ida",
        "windows"
    ],
    "user": "chentiangemalc",
    "time": "Jul 15, 2019 at 1:29",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  My guess is that\n  <code>\n   ppMalloc\n  </code>\n  is a pointer to an instance of the\n  <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/objidl/nn-objidl-imalloc\" rel=\"nofollow noreferrer\">\n   <code>\n    IMalloc\n   </code>\n  </a>\n  COM interface (e.g. it was initialized by a call to\n  <code>\n   CoGetMalloc\n  </code>\n  ), which means the the first pointer in it (loaded by the\n  <code>\n   les\n  </code>\n  instruction) is the VTable which has the following methods.\n </p>\n <p>\n  First three are inherited from IUnknown, the parent of all COM objects:\n </p>\n <hr/>\n <p>\n  +00 QueryInterface\n </p>\n <p>\n  +04 AddRef\n </p>\n <p>\n  +08 Release\n </p>\n <hr/>\n <p>\n  Followed by the methods of IMalloc proper:\n </p>\n <hr/>\n <p>\n  +0C\n  <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/objidl/nf-objidl-imalloc-alloc\" rel=\"nofollow noreferrer\">\n   Alloc\n  </a>\n </p>\n <p>\n  +10 DidAlloc\n </p>\n <p>\n  +14 Free\n </p>\n <p>\n  +18 GetSize\n </p>\n <p>\n  +1C HeapMinimize\n </p>\n <p>\n  +20 Realloc\n </p>\n <hr/>\n <p>\n  So the code is probably calling\n  <code>\n   IMalloc::Malloc\n  </code>\n  to allocate 0x34 bytes, pointer to which is returned in the\n  <code>\n   ax:dx\n  </code>\n  register pair.\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Igor Skochinsky",
            "time": "Jul 17, 2019 at 16:43",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  We cannot deduce it from the fragment of code you have provided (unless we are @Igor Skochinsky of course). However, we can notice a few things:\n </p>\n <ul>\n  <li>\n   <code>\n    ppMalloc\n   </code>\n   contains the address of dynamically allocated array of function pointers\n  </li>\n  <li>\n   the function called by\n   <code>\n    call [bx+0Ch]\n   </code>\n   takes three arguments passed by stack:\n   <code>\n    0\n   </code>\n   ,\n   <code>\n    34h\n   </code>\n   (offset?) and a pointer to the address of that dynamically allocated array (that is the address of\n   <code>\n    ppMalloc\n   </code>\n   pointer)\n  </li>\n  <li>\n   at line\n   <code>\n    3051\n   </code>\n   <code>\n    es:bx\n   </code>\n   points to the first element of that array and\n   <code>\n    es:[bx+0Ch]\n   </code>\n   is fourth element in it\n  </li>\n  <li>\n   depending on the value returned (in\n   <code>\n    dx:ax\n   </code>\n   ) the jump at the last line will or won't be performed (\n   <code>\n    or dx, ax\n   </code>\n   checks whether\n   <code>\n    dx:ax\n   </code>\n   is\n   <code>\n    0\n   </code>\n   or not)\n  </li>\n </ul>\n <p>\n  If you have any doubts the comments to the disassembly given below should clarify them.\n </p>\n <pre><code>cseg04:3044                 push    0 ; push first argument\ncseg04:3046                 push    34h ; '4' ; push the second one\ncseg04:3048                 les     bx, ppMalloc ; es:bx = ppMalloc\ncseg04:304C                 push    es\ncseg04:304D                 push    bx ; push es:bx (ppMalloc)\ncseg04:304E                 les     bx, es:[bx] ; es:bx = *ppMalloc (that is the value stored at dseg70:3612, i.e. pointer to array of function pointers, i.e. pointer to the first element of that array)\ncseg04:3051                 call    dword ptr es:[bx+0Ch] ; call arrayOfFunctionPointers[3] - fourth entry as each entry is probably of dword size\ncseg04:3055                 add     sp, 8 ; restore previous sp value\ncseg04:3058                 mov     si, ax ; si = (returned result) % 2^16\ncseg04:305A                 mov     [bp-6], dx ; [bp-6] = (returned result) / 2^16\ncseg04:305D                 or      dx, ax ; will be 0 <=> (dx = 0 and ax = 0)\ncseg04:305F                 jnz     short loc_105F8\n</code></pre>\n</div>\n</body></html>",
            "votes": "2",
            "user": "bart1e",
            "time": "Jul 17, 2019 at 17:44",
            "is_accepted": false,
            "comments": []
        }
    ]
}