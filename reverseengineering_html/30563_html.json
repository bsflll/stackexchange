{
    "title": "How to utilize `FillOutStructureCmd`?",
    "link": "https://reverseengineering.stackexchange.com/questions/30563/how-to-utilize-filloutstructurecmd",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Basically I'm extending the\n  <code>\n   CreateStructure.java\n  </code>\n  plugin so it iterates all functions and tries to automatically create structures on all variables.\n </p>\n <p>\n  It looks something like this:\n </p>\n <pre><code>public class CreateStructure extends GhidraScript {\n\n    @Override\n    public void run() throws Exception {\n        FunctionIterator funcs = currentProgram.getFunctionManager().getFunctions(true);\n        DecompInterface decomp = setUpDecompiler(currentProgram);\n        for (Function fn : funcs) {\n            Variable[] allvars = fn.getAllVariables();\n            for(Variable var : allvars) {\n                /*DecompileResults res = decomp.decompileFunction(fn, 10000, monitor);\n                ClangNode nodres = null;\n                ClangTokenGroup ccode = res.getCCodeMarkup();\n                println(\"Decompiled \" + fn.getName());\n                ClangToken tokeres = new ClangToken((ClangNode) var.getVariableStorage().getFirstVarnode());\n                */\n                //DecompilerLocation loc = new DecompilerLocation(currentProgram, var.getFirstStorageVarnode().getAddress(), fn.getEntryPoint(), res, tokeres,0,0);\n                setCurrentLocation(var.getMinAddress());\n                FillOutStructureCmd fillCmd =\n                        new FillOutStructureCmd(currentProgram, currentLocation, state.getTool());\n                fillCmd.applyTo(currentProgram, this.monitor);\n            }\n        }\n    }\n    \n    private DecompInterface setUpDecompiler(Program program) {\n        DecompInterface decompInterface = new DecompInterface();\n\n        // call it to get results\n        if (!decompInterface.openProgram(currentProgram)) {\n            println(\"Decompile Error: \" + decompInterface.getLastMessage());\n            return null;\n        }\n\n        DecompileOptions options;\n        options = new DecompileOptions();\n        OptionsService service = state.getTool().getService(OptionsService.class);\n        if (service != null) {\n            ToolOptions opt = service.getOptions(\"Decompiler\");\n            options.grabFromToolAndProgram(null, opt, program);\n        }\n        decompInterface.setOptions(options);\n\n        decompInterface.toggleCCode(true);\n        decompInterface.toggleSyntaxTree(true);\n        decompInterface.setSimplificationStyle(\"decompile\");\n\n        return decompInterface;\n    }\n}\n</code></pre>\n <p>\n  But it only iterates through the functions variables without creating structures - unlike when I position my cursor on a parameter and execute there.\n </p>\n <p>\n  What am I missing?\n </p>\n <p>\n  (You can also see my attempt to retrieve the DecompilerLocation which also doesn't work)\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "89",
    "tags": [
        "decompilation",
        "ghidra",
        "java",
        "plugin"
    ],
    "user": "rec",
    "time": "Jun 27, 2022 at 16:35",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I figure it out something like this does it:\n </p>\n <pre><code>public class CreateStructure extends GhidraScript {\n\n    @Override\n    public void run() throws Exception {\n        /*println(\"\" + currentLocation.toString());\n        FillOutStructureCmd fillCmd =\n                new FillOutStructureCmd(currentProgram, currentLocation, state.getTool());\n        fillCmd.applyTo(currentProgram, this.monitor);*/\n        FunctionIterator funcs = currentProgram.getFunctionManager().getFunctions(true);\n        DecompInterface decomp = setUpDecompiler(currentProgram);\n        for (Function fn : funcs) {\n            Variable[] allvars = fn.getAllVariables();\n            for(Variable var : allvars) {\n                /*DecompileResults res = decomp.decompileFunction(fn, 10000, monitor);\n                ClangNode nodres = null;\n                ClangTokenGroup ccode = res.getCCodeMarkup();\n                println(\"Decompiled \" + fn.getName());\n                ClangToken tokeres = new ClangToken((ClangNode) var.getVariableStorage().getFirstVarnode());\n                */\n                DataType dattyp = var.getDataType();\n                String datatypstring = dattyp.getDisplayName();\n                println(datatypstring = datatypstring.replaceAll(\"\\\\[|\\\\]|\\\\*|\\\\s\", \"\"));\n                DecompileResults res = decomp.decompileFunction(fn, 10000, monitor);\n                \n                ClangTokenGroup tokengrp = res.getCCodeMarkup();\n                \n                if(tokengrp == null) continue;\n                \n                ClangToken tokeres = null;\n                \n                println(\"searching for \" + datatypstring);\n                \n                mainloop:\n                for(ClangNode  token : tokengrp) {\n                    if(token instanceof ClangFuncProto) {\n                        for(ClangNode  outter : ((ClangFuncProto)token)) {\n                            if(outter instanceof ClangVariableDecl)\n                            for(ClangNode inner2 : ((ClangVariableDecl)outter)) {\n                                if(inner2 instanceof ClangToken) {\n                                    if(((ClangToken)inner2).getText().equals(datatypstring)) {\n                                        tokeres = (ClangToken)inner2;\n                                        println(inner2.getClass().toString());\n                                        break mainloop;\n                                    }\n                                    else {\n                                        println(\"\" + ((ClangToken)inner2).getText());\n                                    }\n                                }\n                                else {\n                                    println(inner2.getClass().toString());\n                                }\n                            }\n                    }\n                }\n                }\n                if(tokeres == null) continue;\n                println(\"found\");\n                \n                //ClangToken tokeres = new ClangToken(null, datatypstring);\n                DecompilerLocation loc = new DecompilerLocation(currentProgram, fn.getEntryPoint(), fn.getEntryPoint(), res, tokeres,1,1);\n                println(\"\" + loc);\n                FillOutStructureCmd fillCmd =\n                        new FillOutStructureCmd(currentProgram, loc, state.getTool());\n                fillCmd.applyTo(currentProgram, this.monitor);\n            }\n        }\n    }\n    \n    private DecompInterface setUpDecompiler(Program program) {\n        DecompInterface decompInterface = new DecompInterface();\n\n        // call it to get results\n        if (!decompInterface.openProgram(currentProgram)) {\n            println(\"Decompile Error: \" + decompInterface.getLastMessage());\n            return null;\n        }\n\n        DecompileOptions options;\n        options = new DecompileOptions();\n        OptionsService service = state.getTool().getService(OptionsService.class);\n        if (service != null) {\n            ToolOptions opt = service.getOptions(\"Decompiler\");\n            options.grabFromToolAndProgram(null, opt, program);\n        }\n        decompInterface.setOptions(options);\n\n        decompInterface.toggleCCode(true);\n        decompInterface.toggleSyntaxTree(true);\n        decompInterface.setSimplificationStyle(\"decompile\");\n\n        return decompInterface;\n    }\n}\n</code></pre>\n <p>\n  Now I only need to seed out the non structure types because currently it's creating structure for everything.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "rec",
            "time": "Jun 27, 2022 at 18:20",
            "is_accepted": false,
            "comments": []
        }
    ]
}