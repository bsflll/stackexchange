{
    "title": "How does services.exe trigger the start of a service?",
    "link": "https://reverseengineering.stackexchange.com/questions/2235/how-does-services-exe-trigger-the-start-of-a-service",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm trying to work out the internals of how a Windows process starts and maintains communication with\n  <code>\n   services.exe\n  </code>\n  . This is on Windows 8 x64, but if you have tips for Windows 7 that is fine too.\n </p>\n <p>\n  So far I figure out\n  <code>\n   services.exe\n  </code>\n  does something approximately like this:\n </p>\n <pre><code>PROCESS_INFORMATION     pi;\n    TCHAR                   szExe[] = _T(\"C:\\\\Program Files\\\\TestProgram\\\\myWindowsService.exe\");\n    PROCESS_INFORMATION process_information = {0};\n    HKEY hOpen;\n    DWORD dwNumber = 0;\n    DWORD dwType = REG_DWORD;  \n    DWORD dwSize = sizeof(DWORD);\n    STARTUPINFOEX startup_info;\n    SIZE_T attribute_list_size = 0;\n\n    ZeroMemory(&startup_info, sizeof(STARTUPINFOEX));\n\n    // can see EXTENDED_STARTUPINFO_PRESENT is used, but couldn't figure out if any/what attributes are added\n    BOOL status = InitializeProcThreadAttributeList(nullptr, 0, 0, &attribute_list_size);\n    PPROC_THREAD_ATTRIBUTE_LIST attribute_list = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, attribute_list_size);\n\n    startup_info.StartupInfo.cb = sizeof(STARTUPINFOEX);\n    startup_info.lpAttributeList = attribute_list;\n    startup_info.StartupInfo.dwFlags = STARTF_FORCEOFFFEEDBACK;\n    startup_info.StartupInfo.wShowWindow= SW_HIDE;\n\n        if(CreateProcess(\n            NULL,\n            szExe,\n            NULL,\n            NULL, \n            FALSE,\n            CREATE_SUSPENDED | \n            CREATE_UNICODE_ENVIRONMENT | \n            DETACHED_PROCESS | \n            EXTENDED_STARTUPINFO_PRESENT,\n            NULL,\n            NULL, \n            &startup_info.StartupInfo, \n            &pi))\n    {\n        HANDLE hEvent;\n        hEvent=CreateEvent(NULL,FALSE,FALSE,NULL); // I traced this call during service sstartup; no idea what purpose it serves?\n\n        ResumeThread(pi.hThread);\n</code></pre>\n <p>\n  Now my question is, how does the actual \"Start\" get communicated to the service? I know the service itself does something like this:\n </p>\n <ol>\n  <li>\n   main entry point (Ã  la console program)\n  </li>\n  <li>\n   Call\n   <code>\n    advapi!StartServiceCtrlDispatcher\n   </code>\n  </li>\n  <li>\n   Goes to\n   <code>\n    sechost!StartServiceCtrlDispatcher\n   </code>\n  </li>\n  <li>\n   This jumps into\n   <code>\n    sechost!QueryServiceDynamicInformation\n   </code>\n  </li>\n </ol>\n <p>\n  I'm trying to figure out what method in\n  <code>\n   services.exe\n  </code>\n  is used to hook into this start process. Ideally I want to be able to write a PoC code that can \"launch\" a simple Windows service and get it to start, without it being registered as a Windows Service, i.e. wrapped inside a \"stand alone service control manager\". I'm looking for some tips of what best to look for next.\n </p>\n <p>\n  There is also a reference to\n  <code>\n   services.exe\n  </code>\n  in\n  <code>\n   \\\\pipe\ntsvcs\n  </code>\n  . The\n  <a href=\"http://en.wikipedia.org/wiki/Service_Control_Manager\">\n   Wikipedia article about SCM\n  </a>\n  refers to\n  <code>\n   \\Pipe\\Net\\NtControlPipeX\n  </code>\n  being created, but as far as I can tell, that is in Windows 2000 (maybe XP) but I can't see this happening on Windows 8.\n </p>\n</div>\n</body></html>",
    "votes": "8",
    "answers": 1,
    "views": "6k",
    "tags": [
        "windows"
    ],
    "user": "chentiangemalc",
    "time": "Jun 11, 2013 at 22:17",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  This is my basic understanding of how Windows service works. I have used it with Windows XP and Windows 7. These are general concepts anyways.\n </p>\n <p>\n  Any service requires three things to be present:\n </p>\n <ol>\n  <li>\n   A Main Entry Point\n  </li>\n  <li>\n   A Service Entry Point\n  </li>\n  <li>\n   A Service Control Handler\n  </li>\n </ol>\n <p>\n  You are absolutely right. In the Main Entry Point service must call\n  <strong>\n   <code>\n    StartServiceCtrlDispatcher(const SERVICE_TABLE_ENTRY *lpServiceTable)\n   </code>\n  </strong>\n  providing Service Control Manager with filled in\n  <strong>\n   <code>\n    SERVICE_TABLE_ENTRY\n   </code>\n  </strong>\n  , which is (per\n  <a href=\"http://msdn.microsoft.com/en-us/\" rel=\"nofollow noreferrer\">\n   MSDN\n  </a>\n  ):\n </p>\n <pre><code>typedef struct _SERVICE_TABLE_ENTRY {\n    LPTSTR                  lpServiceName;\n    LPSERVICE_MAIN_FUNCTION lpServiceProc;\n} SERVICE_TABLE_ENTRY, *LPSERVICE_TABLE_ENTRY;\n</code></pre>\n <p>\n  As you can see, there are two things which are required to be supplied in SERVICE_TABLE_ENTRY structure. Those are pointer to name of the service, and pointer to service main function. Right after service registration, Service Control Manager calls  Service Main function, which is also called ServiceMain or Service Entry Point. Service Control Manager expects that following tasks are performed by Service Entry Point:\n </p>\n <ol>\n  <li>\n   Register the service control handler.\n  </li>\n  <li>\n   Set Service Status\n  </li>\n  <li>\n   Perform necessary initialization (creating events, mutex, etc)\n  </li>\n </ol>\n <p>\n  Service Control Handler is a callback function with the following definition:\n  <strong>\n   <code>\n    VOID WINAPI ServiceCtrlHandler (DWORD CtrlCode)\n   </code>\n  </strong>\n  (\n  <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms685149%28v=vs.85%29.aspx\" rel=\"nofollow noreferrer\">\n   MSDN\n  </a>\n  ). It is expected to handle service STOP, PAUSE, CONTINUE, and SHUTDOWN. It is imperative that each service has a handler to handle requests from the SCM. Service control handler is registered with\n  <strong>\n   <code>\n    RegisterServiceCtrlHandlerEx()\n   </code>\n  </strong>\n  (\n  <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms685058%28v=vs.85%29.aspx\" rel=\"nofollow noreferrer\">\n   MSDN\n  </a>\n  ), which returns\n  <strong>\n   <code>\n    SERVICE_STATUS_HANDLE\n   </code>\n  </strong>\n  . Service uses the handle to communicate to the SCM. The control handler must also return within 30 seconds. If it does not happen the SCM will return an error stating that the service is unresponsive. This is due to the fact that the handler is called out of the SCM and will freeze the SCM until it returns from the handler. Only then, service may use\n  <strong>\n   <code>\n    SetServiceStatus()\n   </code>\n  </strong>\n  (\n  <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms686241%28v=vs.85%29.aspx\" rel=\"nofollow noreferrer\">\n   MSDN\n  </a>\n  ) function along with service status handle to communicate back to the SCM.\n </p>\n <p>\n  You don't communicate \"Start\" to a service. Whenever a service loads, it loads in the \"started\" state. It is service's responsibility to report its state to the SCM. You can PAUSE it or CONTINUE (plus about dozen more control codes). You communicate it to the SCM by using\n  <strong>\n   <code>\n    ControlService()\n   </code>\n  </strong>\n  (\n  <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms682108%28v=vs.85%29.aspx\" rel=\"nofollow noreferrer\">\n   MSDN\n  </a>\n  ) function. The SCM in turn relays the control code (e.g. SERVICE_CONTROL_PAUSE, SERVICE_CONTROL_CONTINUE or any other one) through to the service using registered service control handler function. Afterwards, it is the services responsibility to act upon received control code.\n </p>\n <p>\n  I don't think services.exe executes or runs threads behind actual services. It is the SCM itself. I take it coordinates services in general. Each service \"lives\" in svchost.exe instance. Taking mentioned above into account, I could assume that Service Entry Point or Service Main is executed in the context of instance of the svchost.exe. In its turn, svchost.exe executes Service Main in context of main thread, blocking main thread until Service Main exists signaling that the service exited.\n </p>\n <p>\n  If you are thinking to create your own service control manager, there is no need to reverse engineer how services.exe does it. You can do it your own way and anyway that you like it :)\n </p>\n <p>\n  I hope it helps.\n </p>\n <p>\n  <strong>\n   ADDED:\n  </strong>\n </p>\n <p>\n  As\n  <a href=\"https://reverseengineering.stackexchange.com/users/161/mick\">\n   Mick\n  </a>\n  commented below,\n  <strong>\n   <code>\n    services.exe\n   </code>\n  </strong>\n  is the Service Control Manager itself.\n </p>\n <p>\n  If you are creating your own service wrapper to run existing serivce executables outside of the SCM, you will have to adhere to above mentioned service quidelines and requirements. The fist requirement is for the service to get itself registered with the SCM and provide Service Main Entry Point, which is done by calling\n  <strong>\n   <code>\n    StartServiceCtrlDispatcher()\n   </code>\n  </strong>\n  . It will get you the entry point to Service Main. Afterwards, you should expect the Service Main to call\n  <strong>\n   <code>\n    RegisterServiceCtrlHandler()\n   </code>\n  </strong>\n  and\n  <strong>\n   <code>\n    SetServiceStatus()\n   </code>\n  </strong>\n  . Since\n  <strong>\n   <code>\n    RegisterServiceCtrlHandler()\n   </code>\n  </strong>\n  runs in context of Service Main and blocks Service Main thread, it should be handled properly as well. In addition, you should think of a way to control/monitor the service worker thread(s) by \"watching\" for\n  <strong>\n   <code>\n    CreatThread()\n   </code>\n  </strong>\n  (\n  <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms682453%28v=vs.85%29.aspx\" rel=\"nofollow noreferrer\">\n   MSDN\n  </a>\n  ) within Service Main.\n </p>\n</div>\n</body></html>",
            "votes": "9",
            "user": "Community",
            "time": "Apr 13, 2017 at 12:49",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Mick",
                    "text": "<span class=\"comment-copy\">Good answer. I'd only add for clarity (you do imply it) that the Service Control Manager's executable <i>is</i> \"services.exe\", a console application that is launched by Winlogon early in the startup process.</span>",
                    "time": null
                },
                {
                    "user": "chentiangemalc",
                    "text": "<span class=\"comment-copy\">Thank you PSS, a very good response. Following along with what you said I found when a service EXE is launched outside SCM the call to StartServiceCtrlDispatcher fails err code 1063 The service process could not connect to the service controller. I suspect then if I want to write my own \"wrapper\" i.e. run service without SCM, I need to hook advapi32!StartServiceCtrlDispatcher and replace with my own function to execute service main. Would this be correct understanding?</span>",
                    "time": null
                },
                {
                    "user": "PSS",
                    "text": "<span class=\"comment-copy\">@MalcolmMcCaffery. Exactly. Please see above. I have amended my answer.</span>",
                    "time": null
                }
            ]
        }
    ]
}