{
    "title": "What process should I follow to sniff USB serial packets and then replicate them?",
    "link": "https://reverseengineering.stackexchange.com/questions/16389/what-process-should-i-follow-to-sniff-usb-serial-packets-and-then-replicate-them",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <strong>\n   Summary\n  </strong>\n </p>\n <p>\n  I'm currently using wireshark to sniff USB serial packets from a program that sends data to FPGA boards. So far I'm able to acquire the packets and data, but I'm not sure how to test each command I find. I want to develop my own program that can do the same thing on a different platform than the one the original program operates on.\n </p>\n <p>\n  <strong>\n   Questions\n  </strong>\n </p>\n <p>\n  Would I get another program to connect to the USB serial connection and then test sending each command? What program would be good for testing?\n </p>\n <p>\n  How would I go about figuring out the serial connection specifications? Baudrate, data bits, stop bits, parity, flow control, and forward?\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "802",
    "tags": [
        "serial-communication"
    ],
    "user": "SaundersB",
    "time": "Sep 22, 2017 at 20:41",
    "comments": [
        {
            "user": "Chris Stratton",
            "text": "<html><body><span class=\"comment-copy\">\n Building something that could re-play what you have seen could be a good start.  But first you'll need to decide if you want to speak raw USB operations to it, or go through an operating system Serial port driver.   You should be able to determine the line settings either by looking at the USB control transfers used to configure them and recognizing the chip via cross referencing likely data sheets, or by using a scope or logic analyzer on the serial signals between the USB chip and the FPGA.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Well for starters you are going to want an in Kernel USB monitor like Linux has, a pass through USB analyzer (more expensive, but more flexible) or something like a logic analyzer.\n </p>\n <p>\n  Here is a video that goes into great detail of doing the latter far more than anyone will here\n  <a href=\"https://www.youtube.com/watch?v=4FOkJLp_PUw\" rel=\"nofollow noreferrer\">\n   https://www.youtube.com/watch?v=4FOkJLp_PUw\n  </a>\n  Note from the video\n  <a href=\"https://opentechlab.org.uk/videos:011:notes\" rel=\"nofollow noreferrer\">\n   https://opentechlab.org.uk/videos:011:notes\n  </a>\n </p>\n <p>\n  To summarize you'll need a logic analyzer, potentially a way of getting the device to tell you it is about to send a packet in some manner (otherwise you will have better luck with a USB analyzer or in kernel USB monitor). Sigrok is software used there... but there are others.\n </p>\n <p>\n  Here is a little python code the guy in the video uses which will probably be of use to you. Which is just a basic example of using pyusb he was using it to talk to whatever micro controller board he was debugging you could use it to talk to your FPGA perhaps as you figure out what it's protocol is doing.\n </p>\n <pre><code>#! /usr/bin/env python3\n\nimport usb.core\nimport time\n\ndev = usb.core.find(idVendor=0x0925, idProduct=0xD100)\nif dev is None:\n  raise ValueError('Device not found')\n\nres = dev.ctrl_transfer(\n  bmRequestType=0x40,                       # OUT, VENDOR, DEVICE request\n  bRequest=1,                               # Request #1\n  wValue=0xCAFE,\n  wIndex=0xD00D,\n  data_or_wLength=[0x01, 0x23, 0x45, 0x67])\n</code></pre>\n <p>\n  The method you choose largely depends on what you need to know, if the device is functioning properly and you don't need to make changes to it, perhaps a software monitor is good enough. If it is indeed USB serial is it a dedicated chip? If so find it's datasheet... and investigate the circuit that may tell you some things. Common USB to serial chips are the the following which either use a standard USB CDC ACM protocol (check if chip in question is this then you can just grap the spec for it here ) or custom driver.\n </p>\n <p>\n  Note that the USB end of the protocol itself is probably baud rate independent but you may need to tell the USB serial convert what rate to run at... it depends alot on how it was designed. Probing the Uart output pints of the controller would allow you to figure out the correct baud rate if you can't figure it out from the circuit itself.\n </p>\n <p>\n  Another way to go about this would be to figure out at least one command that will give you a response... then exhaustively try different baud rates and configurations until you get the expected response.\n </p>\n <ol>\n  <li>\n   <p>\n    Silicon Labs CP2102 and variants.\n    <a href=\"https://www.silabs.com/documents/public/data-sheets/CP2102-9.pdf\" rel=\"nofollow noreferrer\">\n     https://www.silabs.com/documents/public/data-sheets/CP2102-9.pdf\n    </a>\n   </p>\n  </li>\n  <li>\n   <p>\n    MicroChip MCP2200\n    <a href=\"http://www.microchip.com/wwwproducts/en/en546923\" rel=\"nofollow noreferrer\">\n     http://www.microchip.com/wwwproducts/en/en546923\n    </a>\n   </p>\n  </li>\n  <li>\n   FT232R\n   <a href=\"http://www.ftdichip.com/Products/ICs/FT232R.htm\" rel=\"nofollow noreferrer\">\n    http://www.ftdichip.com/Products/ICs/FT232R.htm\n   </a>\n  </li>\n </ol>\n</div>\n</body></html>",
            "votes": "1",
            "user": "cb88",
            "time": "Sep 27, 2017 at 20:50",
            "is_accepted": true,
            "comments": []
        }
    ]
}