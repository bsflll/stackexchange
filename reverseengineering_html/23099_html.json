{
    "title": "Behringer CRC8 algorithm",
    "link": "https://reverseengineering.stackexchange.com/questions/23099/behringer-crc8-algorithm",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The Behringer DEQ2496 audio device can have commands sent to it via MIDI, however they require a valid CRC code in order for the device to accept them.\n </p>\n <p>\n  I have thus far been unable to work out how the CRC code is calculated.  The manual suggests it is CRC8 however I have not been able to configure a CRC8 algorithm to produce matching values.\n </p>\n <p>\n  Here is some sample data, including valid CRC codes:\n </p>\n <ul>\n  <li>\n   <a href=\"http://files.shikadi.net/malv/files/stackexchange/block-40.bin\" rel=\"nofollow noreferrer\">\n    Block 0x0040\n   </a>\n  </li>\n  <li>\n   <a href=\"http://files.shikadi.net/malv/files/stackexchange/block-41.bin\" rel=\"nofollow noreferrer\">\n    Block 0x0041\n   </a>\n  </li>\n  <li>\n   <a href=\"http://files.shikadi.net/malv/files/stackexchange/block-41.bin\" rel=\"nofollow noreferrer\">\n    Block 0x0042\n   </a>\n  </li>\n  <li>\n   <a href=\"http://files.shikadi.net/malv/files/stackexchange/block-42.bin\" rel=\"nofollow noreferrer\">\n    Block 0x0043\n   </a>\n  </li>\n  <li>\n   <a href=\"http://files.shikadi.net/malv/files/stackexchange/block-43.bin\" rel=\"nofollow noreferrer\">\n    Block 0x0043\n   </a>\n  </li>\n  <li>\n   <a href=\"http://files.shikadi.net/malv/files/stackexchange/block-ff00.bin\" rel=\"nofollow noreferrer\">\n    Block 0xFF00\n   </a>\n  </li>\n </ul>\n <p>\n  The DEQ2496 SysEx manual says of the layout of each of the above files:\n </p>\n <blockquote>\n  <p>\n   <strong>\n    blockdata\n   </strong>\n   : 7/8 coded: blockno_h, blockno_l, crc, data[256].\n  </p>\n  <p>\n   <strong>\n    crc\n   </strong>\n   : crc8 checksum of blockno_h, blockno_l, data[256]\n  </p>\n  <p>\n   <strong>\n    blockno\n   </strong>\n   : transferred 256 byte data block number (bits 21..15, 14..8 of flash offset); blocks 0-0x1f: boot loader; blocks 0x20..0x5ef: application; blocks 0x5f0-0x5ff: startup screen; blocks 0x600-0x67f: presets; blocks 0x680-0x69f: temporary buffers; blocks 0x6a0-0x7ff: hw configuration; block no 0xff00 shows text message data[0..52] on screen\n  </p>\n  <p>\n   <strong>\n    data\n   </strong>\n   : data block\n  </p>\n </blockquote>\n <p>\n  I have taken care of the 7/8 coding, so now I have a block of 3+256 bytes, consisting of:\n </p>\n <ul>\n  <li>\n   Offset 0: 16-bit big endian integer, block number\n  </li>\n  <li>\n   Offset 2: 8-bit integer, CRC (this is the value I am trying to calculate)\n  </li>\n  <li>\n   Offset 3+: Actual data\n  </li>\n </ul>\n <p>\n  I've tried a couple of CRC algorithms (with and without a lookup table), written code to run through all possible 8-bit polynomials, initial and final XOR values, and yet I can't find any parameters that work for more than one block.\n </p>\n <p>\n  Although the manual suggests the CRC byte itself is not included in the CRC calculation, I also tried leaving it in place and setting it to various values like\n  <code>\n   0x00\n  </code>\n  and\n  <code>\n   0xFF\n  </code>\n  however this didn't yield any results either.\n </p>\n <p>\n  Is there anyone with more CRC knowledge than me who is able to figure out what they mean here by \"crc8 checksum\"?\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "217",
    "tags": [
        "crc"
    ],
    "user": "Malvineous",
    "time": "Jun 17, 2020 at 9:54",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Well thanks to @IgorSkochinsky who suggested in another question of mine to try a disassembler, I found a\n  <a href=\"https://hub.docker.com/r/pf0camino/cross-bfin-elf\" rel=\"nofollow noreferrer\">\n   Docker image that contained a Blackfin toolchain\n  </a>\n  which allowed me to use\n  <code>\n   objdump\n  </code>\n  to disassemble the code:\n </p>\n <pre><code>bfin-elf-objdump -D -b binary -mbfin bootloader.bin > bootloader.disasm\n</code></pre>\n <p>\n  After hastily consulting a manual on Blackfin assembler and poking around a bit, I was able to get a vague idea of what was going on, and I was able to find the CRC function, which turned out not to be a CRC function at all, but a DIY checksum.\n </p>\n <p>\n  Using the disassembly as a reference, I was able to replicate the algorithm in my Javascript code:\n </p>\n <pre><code>function behringer_crc8(data) {\n    let crc = 0;\n    for (let b of data) {\n        for (let j = 0; j < 8; j++) {\n            if (!((b ^ crc) & 1)) crc ^= 0x19;\n            b >>= 1;\n            // Rotate (shift right, move lost LSB to new MSB)\n            crc = ((crc & 1) << 7) | (crc >> 1);\n        }\n    }\n    return crc ^ 0xbf;\n}\n</code></pre>\n <p>\n  Comparing this code against the distributed firmware update shows that it is able to reproduce the CRC bytes correctly!\n </p>\n <p>\n  It also turned out that despite the manual saying the two-byte block number prefix was included in the checksum, it turned out it wasn't, and only the 256-byte content is checksummed.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Malvineous",
            "time": "Jan 26, 2020 at 9:57",
            "is_accepted": true,
            "comments": []
        }
    ]
}