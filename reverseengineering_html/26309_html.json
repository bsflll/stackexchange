{
    "title": "how to hook __usercall function with microsoft detours",
    "link": "https://reverseengineering.stackexchange.com/questions/26309/how-to-hook-usercall-function-with-microsoft-detours",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I need to hook a  __usercall function in particular I need to read only the first parameter:\n </p>\n <pre><code>char __usercall sub_4F3E6D@<al>(char *Src@<ecx>, int a2@<edx>, int a3, int a4, char a5, char a6, char a7, char a8, int a9)\n{\n  int v9; // edi\n  char v10; // bl\n  char *v11; // esi\n  unsigned __int8 v12; // al\n  signed int v13; // edx\n  int v14; // eax\n  signed int v15; // eax\n  signed int v16; // edi\n  char *v17; // eax\n  char *v18; // esi\n  float v20; // xmm1_4\n  size_t v21; // ST04_4\n  float v22; // [esp+18h] [ebp-A8h]\n  int v23; // [esp+1Ch] [ebp-A4h]\n  char v24; // [esp+24h] [ebp-9Ch]\n  int v25; // [esp+2Ch] [ebp-94h]\n  char Dst; // [esp+40h] [ebp-80h]\n  int v27; // [esp+98h] [ebp-28h]\n  int v28; // [esp+9Ch] [ebp-24h]\n  float v29; // [esp+ACh] [ebp-14h]\n  float v30; // [esp+B0h] [ebp-10h]\n\n  v9 = a2;\n  v10 = 0;\n  v11 = Src;\n  v23 = a2;\n  if ( a9 )\n    *(_DWORD *)a9 = 0;\n  if ( !dword_897628 || !Src || !*Src )\n    return 0;\n  if ( a6 )\n  {\n    v12 = *((_BYTE *)dword_8CF880 + 2232);\n  }\n  else if ( a7 )\n  {\n    v12 = *((_BYTE *)dword_8CF880 + 2234);\n  }\n  else\n  {\n    v12 = a8 ? *((_BYTE *)dword_8CF880 + 2233) : *((_BYTE *)dword_8CF880 + 2252);\n  }\n  v22 = (float)v12 * 0.0099999998;\n  if ( v22 < 0.0099999998 && a2 != 1481317962 )\n    return 0;\n  if ( sub_4F4463(a2, 0) )\n    return 0;\n  memset(&Dst, 0, 0x78u);\n  sub_410BA2(&Dst, 3);\n  if ( a6 )\n  {\n    v28 = 9;\n  }\n  else if ( a7 )\n  {\n    v27 |= 4u;\n  }\n  else if ( !a8 )\n  {\n    v27 |= 0x40000u;\n  }\n  v13 = 1;\n  if ( a5 || a6 )\n  {\n    v14 = v27 | 1;\n    v27 |= 1u;\n    if ( a6 )\n      v27 = v14 | 8;\n  }\n  if ( *(float *)&a3 > 0.0099999998 )\n    sub_4F0812(&Dst, 1);\n  sub_4F0855(&Dst, v13);\n  v27 |= 0x40u;\n  *(_DWORD *)a4 = 0;\n  v30 = fminf(fmaxf(v22, 0.0), 1.0);\n  v29 = v30;\n  sub_410B78(&v24);\n  v15 = v25;\n  if ( a5 )\n    v15 = 1;\n  v25 = v15;\n  v16 = v9 == 1481317962 ? 2147483646 : sub_4F353D(&v24, 0);\n  if ( !(unsigned __int8)sub_4F349C(v16) )\n    return 0;\n  v17 = sub_4F1BBB(v11, v23, 0, (int)&Dst);\n  v18 = v17;\n  if ( !v17 )\n    return 0;\n  if ( dword_897628 )\n    v10 = sub_4F11D7(v17, &v24);\n  if ( !v10 )\n  {\n    sub_4F3A95(v18);\n    return 0;\n  }\n  if ( v18[34] )\n    v20 = 9999.0;\n  else\n    v20 = (float)*(signed int *)(*((_DWORD *)v18 + 3) + 172) / (float)*(unsigned int *)(*((_DWORD *)v18 + 3) + 156);\n  *(float *)a4 = v20;\n  v21 = dword_897634;\n  *((_DWORD *)v18 + 5) = v16;\n  qsort(dword_897650, v21, 4u, sub_4F37D5);\n  if ( a9 )\n    *(_DWORD *)a9 = *(_DWORD *)v18;\n  return 1;\n}\n</code></pre>\n <p>\n  here the assemply:\n </p>\n <pre><code>.text:004F3E6D ; =============== S U B R O U T I N E =======================================\n.text:004F3E6D\n.text:004F3E6D ; Attributes: bp-based frame\n.text:004F3E6D\n.text:004F3E6D ; int __usercall sub_4F3E6D@<eax>(char *Src@<ecx>, int, int, char, char, char, char, int)\n.text:004F3E6D sub_4F3E6D      proc near               ; CODE XREF: StartAudio2D(char const * const,float,float,float,bool,bool)+3B↑p\n.text:004F3E6D                                         ; sub_4EDCE9+14E↑p ...\n.text:004F3E6D\n.text:004F3E6D var_B0          = dword ptr -0B0h\n.text:004F3E6D var_AC          = dword ptr -0ACh\n.text:004F3E6D var_A8          = dword ptr -0A8h\n.text:004F3E6D var_A4          = dword ptr -0A4h\n.text:004F3E6D var_A0          = dword ptr -0A0h\n.text:004F3E6D var_9C          = byte ptr -9Ch\n.text:004F3E6D var_94          = dword ptr -94h\n.text:004F3E6D Dst             = byte ptr -80h\n.text:004F3E6D var_28          = dword ptr -28h\n.text:004F3E6D var_24          = dword ptr -24h\n.text:004F3E6D var_14          = dword ptr -14h\n.text:004F3E6D var_10          = dword ptr -10h\n.text:004F3E6D var_4           = dword ptr -4\n.text:004F3E6D arg_0           = dword ptr  8\n.text:004F3E6D arg_4           = dword ptr  0Ch\n.text:004F3E6D arg_8           = byte ptr  10h\n.text:004F3E6D arg_C           = byte ptr  14h\n.text:004F3E6D arg_10          = byte ptr  18h\n.text:004F3E6D arg_14          = byte ptr  1Ch\n.text:004F3E6D arg_18          = dword ptr  20h\n.text:004F3E6D\n.text:004F3E6D                 push    ebp\n.text:004F3E6E                 mov     ebp, esp\n.text:004F3E70                 and     esp, 0FFFFFFF8h\n.text:004F3E73                 sub     esp, 0B4h\n.text:004F3E79                 mov     eax, ___security_cookie\n.text:004F3E7E                 xor     eax, esp\n.text:004F3E80                 mov     [esp+0B4h+var_4], eax\n.text:004F3E87                 mov     eax, [ebp+arg_4]\n.text:004F3E8A                 push    ebx\n.text:004F3E8B                 push    esi\n.text:004F3E8C                 push    edi\n.text:004F3E8D                 mov     [esp+0C0h+var_B0], eax\n.text:004F3E91                 mov     edi, edx\n.text:004F3E93                 mov     eax, [ebp+arg_18]\n.text:004F3E96                 xor     ebx, ebx\n.text:004F3E98                 movss   [esp+0C0h+var_AC], xmm3\n.text:004F3E9E                 mov     esi, ecx\n.text:004F3EA0                 mov     [esp+0C0h+var_A4], edi\n.text:004F3EA4                 mov     [esp+0C0h+var_A0], eax\n.text:004F3EA8                 test    eax, eax\n.text:004F3EAA                 jz      short loc_4F3EAE\n.text:004F3EAC                 mov     [eax], ebx\n.text:004F3EAE\n.text:004F3EAE loc_4F3EAE:                             ; CODE XREF: sub_4F3E6D+3D↑j\n.text:004F3EAE                 cmp     dword_897628, ebx\n.text:004F3EB4                 jz      loc_4F4093\n.text:004F3EBA                 test    esi, esi\n.text:004F3EBC                 jz      loc_4F4093\n.text:004F3EC2                 cmp     [esi], bl\n.text:004F3EC4                 jz      loc_4F4093\n.text:004F3ECA                 mov     eax, dword_8CF880\n.text:004F3ECF                 cmp     [ebp+arg_C], bl\n.text:004F3ED2                 jz      short loc_4F3EDC\n.text:004F3ED4                 mov     al, [eax+8B8h]\n.text:004F3EDA                 jmp     short loc_4F3EFC\n.text:004F3EDC ; ---------------------------------------------------------------------------\n.text:004F3EDC\n.text:004F3EDC loc_4F3EDC:                             ; CODE XREF: sub_4F3E6D+65↑j\n.text:004F3EDC                 cmp     [ebp+arg_10], bl\n.text:004F3EDF                 jz      short loc_4F3EE9\n.text:004F3EE1                 mov     al, [eax+8BAh]\n.text:004F3EE7                 jmp     short loc_4F3EFC\n.text:004F3EE9 ; ---------------------------------------------------------------------------\n.text:004F3EE9\n.text:004F3EE9 loc_4F3EE9:                             ; CODE XREF: sub_4F3E6D+72↑j\n.text:004F3EE9                 cmp     [ebp+arg_14], bl\n.text:004F3EEC                 jz      short loc_4F3EF6\n.text:004F3EEE                 mov     al, [eax+8B9h]\n.text:004F3EF4                 jmp     short loc_4F3EFC\n.text:004F3EF6 ; ---------------------------------------------------------------------------\n.text:004F3EF6\n.text:004F3EF6 loc_4F3EF6:                             ; CODE XREF: sub_4F3E6D+7F↑j\n.text:004F3EF6                 mov     al, [eax+8CCh]\n.text:004F3EFC\n.text:004F3EFC loc_4F3EFC:                             ; CODE XREF: sub_4F3E6D+6D↑j\n.text:004F3EFC                                         ; sub_4F3E6D+7A↑j ...\n.text:004F3EFC                 movss   xmm1, ds:dword_82A2D8\n.text:004F3F04                 movzx   eax, al\n.text:004F3F07                 movd    xmm0, eax\n.text:004F3F0B                 cvtdq2ps xmm0, xmm0\n.text:004F3F0E                 mulss   xmm0, xmm1\n.text:004F3F12                 comiss  xmm1, xmm0\n.text:004F3F15                 movss   [esp+0C0h+var_A8], xmm0\n.text:004F3F1B                 jbe     short loc_4F3F29\n.text:004F3F1D                 cmp     edi, 584B1E4Ah\n.text:004F3F23                 jnz     loc_4F4093\n.text:004F3F29\n.text:004F3F29 loc_4F3F29:                             ; CODE XREF: sub_4F3E6D+AE↑j\n.text:004F3F29                 xor     edx, edx\n.text:004F3F2B                 mov     ecx, edi\n.text:004F3F2D                 call    sub_4F4463\n.text:004F3F32                 test    eax, eax\n.text:004F3F34                 jnz     loc_4F4093\n.text:004F3F3A                 push    78h             ; Size\n.text:004F3F3C                 lea     eax, [esp+0C4h+Dst]\n.text:004F3F40                 push    ebx             ; Val\n.text:004F3F41                 push    eax             ; Dst\n.text:004F3F42                 call    memset\n.text:004F3F47                 add     esp, 0Ch\n.text:004F3F4A                 lea     ecx, [esp+0C0h+Dst] ; Dst\n.text:004F3F4E                 push    3               ; int\n.text:004F3F50                 call    sub_410BA2\n.text:004F3F55                 mov     cl, [ebp+arg_C]\n.text:004F3F58                 test    cl, cl\n.text:004F3F5A                 jz      short loc_4F3F69\n.text:004F3F5C                 mov     [esp+0C0h+var_24], 9\n.text:004F3F67                 jmp     short loc_4F3F88\n.text:004F3F69 ; ---------------------------------------------------------------------------\n.text:004F3F69\n.text:004F3F69 loc_4F3F69:                             ; CODE XREF: sub_4F3E6D+ED↑j\n.text:004F3F69                 cmp     [ebp+arg_10], bl\n.text:004F3F6C                 jz      short loc_4F3F78\n.text:004F3F6E                 or      [esp+0C0h+var_28], 4\n.text:004F3F76                 jmp     short loc_4F3F88\n.text:004F3F78 ; ---------------------------------------------------------------------------\n.text:004F3F78\n.text:004F3F78 loc_4F3F78:                             ; CODE XREF: sub_4F3E6D+FF↑j\n.text:004F3F78                 cmp     [ebp+arg_14], bl\n.text:004F3F7B                 jnz     short loc_4F3F88\n.text:004F3F7D                 or      [esp+0C0h+var_28], 40000h\n.text:004F3F88\n.text:004F3F88 loc_4F3F88:                             ; CODE XREF: sub_4F3E6D+FA↑j\n.text:004F3F88                                         ; sub_4F3E6D+109↑j ...\n.text:004F3F88                 xor     edx, edx\n.text:004F3F8A                 inc     edx\n.text:004F3F8B                 cmp     [ebp+arg_8], bl\n.text:004F3F8E                 jnz     short loc_4F3F94\n.text:004F3F90                 test    cl, cl\n.text:004F3F92                 jz      short loc_4F3FB2\n.text:004F3F94\n.text:004F3F94 loc_4F3F94:                             ; CODE XREF: sub_4F3E6D+121↑j\n.text:004F3F94                 mov     eax, [esp+0C0h+var_28]\n.text:004F3F9B                 or      eax, edx\n.text:004F3F9D                 mov     [esp+0C0h+var_28], eax\n.text:004F3FA4                 test    cl, cl\n.text:004F3FA6                 jz      short loc_4F3FB2\n.text:004F3FA8                 or      eax, 8\n.text:004F3FAB                 mov     [esp+0C0h+var_28], eax\n.text:004F3FB2\n.text:004F3FB2 loc_4F3FB2:                             ; CODE XREF: sub_4F3E6D+125↑j\n.text:004F3FB2                                         ; sub_4F3E6D+139↑j\n.text:004F3FB2                 movss   xmm1, [ebp+arg_0]\n.text:004F3FB7                 comiss  xmm1, ds:dword_82A2D8\n.text:004F3FBE                 jbe     short loc_4F3FC9\n.text:004F3FC0                 lea     ecx, [esp+0C0h+Dst]\n.text:004F3FC4                 call    sub_4F0812\n.text:004F3FC9\n.text:004F3FC9 loc_4F3FC9:                             ; CODE XREF: sub_4F3E6D+151↑j\n.text:004F3FC9                 movss   xmm1, [esp+0C0h+var_AC]\n.text:004F3FCF                 lea     ecx, [esp+0C0h+Dst]\n.text:004F3FD3                 call    sub_4F0855\n.text:004F3FD8                 movss   xmm0, [esp+0C0h+var_A8]\n.text:004F3FDE                 lea     ecx, [esp+0C0h+var_9C]\n.text:004F3FE2                 maxss   xmm0, ds:dword_82A218\n.text:004F3FEA                 mov     eax, [esp+0C0h+var_B0]\n.text:004F3FEE                 or      [esp+0C0h+var_28], 40h\n.text:004F3FF6                 minss   xmm0, ds:dword_82A46C\n.text:004F3FFE                 and     [eax], ebx\n.text:004F4000                 movss   [esp+0C0h+var_10], xmm0\n.text:004F4009                 movss   [esp+0C0h+var_14], xmm0\n.text:004F4012                 call    sub_410B78\n.text:004F4017                 cmp     [ebp+arg_8], bl\n.text:004F401A                 mov     eax, [esp+0C0h+var_94]\n.text:004F401E                 push    1\n.text:004F4020                 pop     ecx\n.text:004F4021                 cmovnz  eax, ecx\n.text:004F4024                 mov     [esp+0C0h+var_94], eax\n.text:004F4028                 cmp     edi, 584B1E4Ah\n.text:004F402E                 jnz     short loc_4F4037\n.text:004F4030                 mov     edi, 7FFFFFFEh\n.text:004F4035                 jmp     short loc_4F404F\n.text:004F4037 ; ---------------------------------------------------------------------------\n.text:004F4037\n.text:004F4037 loc_4F4037:                             ; CODE XREF: sub_4F3E6D+1C1↑j\n.text:004F4037                 lea     eax, [esp+0C0h+var_9C]\n.text:004F403B                 mov     ecx, offset unk_59D561C\n.text:004F4040                 push    ebx\n.text:004F4041                 push    eax\n.text:004F4042                 lea     edx, [esp+0C8h+Dst]\n.text:004F4046                 call    sub_4F353D\n.text:004F404B                 pop     ecx\n.text:004F404C                 pop     ecx\n.text:004F404D                 mov     edi, eax\n.text:004F404F\n.text:004F404F loc_4F404F:                             ; CODE XREF: sub_4F3E6D+1C8↑j\n.text:004F404F                 mov     ecx, edi\n.text:004F4051                 call    sub_4F349C\n.text:004F4056                 test    al, al\n.text:004F4058                 jz      short loc_4F4093\n.text:004F405A                 mov     edx, [esp+0C0h+var_A4]\n.text:004F405E                 lea     eax, [esp+0C0h+Dst]\n.text:004F4062                 push    eax             ; int\n.text:004F4063                 push    ebx             ; int\n.text:004F4064                 mov     ecx, esi        ; Src\n.text:004F4066                 call    sub_4F1BBB\n.text:004F406B                 mov     esi, eax\n.text:004F406D                 pop     ecx\n.text:004F406E                 pop     ecx\n.text:004F406F                 test    esi, esi\n.text:004F4071                 jz      short loc_4F4093\n.text:004F4073                 cmp     dword_897628, ebx\n.text:004F4079                 jz      short loc_4F4088\n.text:004F407B                 lea     edx, [esp+0C0h+var_9C]\n.text:004F407F                 mov     ecx, esi\n.text:004F4081                 call    sub_4F11D7\n.text:004F4086                 mov     bl, al\n.text:004F4088\n.text:004F4088 loc_4F4088:                             ; CODE XREF: sub_4F3E6D+20C↑j\n.text:004F4088                 test    bl, bl\n.text:004F408A                 jnz     short loc_4F40AA\n.text:004F408C                 mov     ecx, esi\n.text:004F408E                 call    sub_4F3A95\n.text:004F4093\n.text:004F4093 loc_4F4093:                             ; CODE XREF: sub_4F3E6D+47↑j\n.text:004F4093                                         ; sub_4F3E6D+4F↑j ...\n.text:004F4093                 xor     al, al\n.text:004F4095\n.text:004F4095 loc_4F4095:                             ; CODE XREF: sub_4F3E6D+2B2↓j\n.text:004F4095                 mov     ecx, [esp+0C0h+var_4]\n.text:004F409C                 pop     edi\n.text:004F409D                 pop     esi\n.text:004F409E                 pop     ebx\n.text:004F409F                 xor     ecx, esp\n.text:004F40A1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)\n.text:004F40A6                 mov     esp, ebp\n.text:004F40A8                 pop     ebp\n.text:004F40A9                 retn\n.text:004F40AA ; ---------------------------------------------------------------------------\n.text:004F40AA\n.text:004F40AA loc_4F40AA:                             ; CODE XREF: sub_4F3E6D+21D↑j\n.text:004F40AA                 cmp     byte ptr [esi+22h], 0\n.text:004F40AE                 jnz     short loc_4F40E2\n.text:004F40B0                 mov     eax, [esi+0Ch]\n.text:004F40B3                 movd    xmm1, dword ptr [eax+0ACh]\n.text:004F40BB                 mov     eax, [eax+9Ch]\n.text:004F40C1                 cvtdq2ps xmm1, xmm1\n.text:004F40C4                 movd    xmm0, eax\n.text:004F40C8                 cvtdq2pd xmm0, xmm0\n.text:004F40CC                 shr     eax, 1Fh\n.text:004F40CF                 addsd   xmm0, ds:qword_82C2D0[eax*8]\n.text:004F40D8                 cvtpd2ps xmm0, xmm0\n.text:004F40DC                 divss   xmm1, xmm0\n.text:004F40E0                 jmp     short loc_4F40EA\n.text:004F40E2 ; ---------------------------------------------------------------------------\n.text:004F40E2\n.text:004F40E2 loc_4F40E2:                             ; CODE XREF: sub_4F3E6D+241↑j\n.text:004F40E2                 movss   xmm1, ds:dword_82A910\n.text:004F40EA\n.text:004F40EA loc_4F40EA:                             ; CODE XREF: sub_4F3E6D+273↑j\n.text:004F40EA                 mov     eax, [esp+0C0h+var_B0]\n.text:004F40EE                 push    offset sub_4F37D5 ; PtFuncCompare\n.text:004F40F3                 push    4               ; SizeOfElements\n.text:004F40F5                 movss   dword ptr [eax], xmm1\n.text:004F40F9                 push    dword_897634    ; NumOfElements\n.text:004F40FF                 mov     [esi+14h], edi\n.text:004F4102                 push    offset dword_897650 ; Base\n.text:004F4107                 call    ds:qsort\n.text:004F410D                 mov     edx, [esp+0D0h+var_A0]\n.text:004F4111                 add     esp, 10h\n.text:004F4114                 test    edx, edx\n.text:004F4116                 jz      short loc_4F411C\n.text:004F4118                 mov     ecx, [esi]\n.text:004F411A                 mov     [edx], ecx\n.text:004F411C\n.text:004F411C loc_4F411C:                             ; CODE XREF: sub_4F3E6D+2A9↑j\n.text:004F411C                 xor     eax, eax\n.text:004F411E                 inc     eax\n.text:004F411F                 jmp     loc_4F4095\n.text:004F411F sub_4F3E6D      endp\n</code></pre>\n <p>\n  here there is one xref of this function:\n </p>\n <pre><code>int v6; // eax\n  int v8; // [esp+1Ch] [ebp-8h]\n  int v9; // [esp+20h] [ebp-4h]\n\n  v9 = 0;\n  v6 = sub_73A34B(a1, 0);\n  sub_4F3E6D((char *)a1, v6, SLODWORD(a4), (int)&v9, a5, a6, 0, 0, (int)&v8);\n</code></pre>\n <p>\n  I don't have experience in assembly I have tried with this code:\n </p>\n <pre><code>// char __usercall sub_4F3E6D@<al>(char *Src@<ecx>, int a2@<edx>, int a3, int a4, char a5, char a6, char a7, char a8, int a9)\n    \n    typedef char(__fastcall *HookFile) (char* src, int a2, int a3, int a4, char a5, char a6, char a7, char a8, int a9);\n    \n    __declspec(naked) char HookSoundFileSub(char* src, int a2, int a3, int a4, char a5, char a6, char a7, char a8, int a9)\n    {\n        HookFile originalFunction = (HookFile)AddressOfHookSoundFunction; // 0x4F4463\n    \n        __asm {\n            mov ecx, src\n            mov edx, a2\n            call AddressOfHookSoundFunction\n        }\n    \n    \n        // Apply  my code\n        // std::string FileName;\n        // FileName = SC::To_String(src);\n        // .....\n        \n        return originalFunction(src, a2,a3,a4,a5,a6,a7,a8,a9);\n    }\n\n\n\n   // DetourAttach(&(LPVOID&)AddressOfHookSoundFunction, &HookSoundFileSub);\n</code></pre>\n <p>\n  but not compile becouse naked function seem not allow to add code apart the assembly.\n </p>\n <p>\n  Can you help me please ?\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "902",
    "tags": [
        "ida",
        "c++",
        "function-hooking"
    ],
    "user": "user3449922",
    "time": "Nov 15, 2020 at 15:04",
    "comments": [
        {
            "user": "user3449922",
            "text": "<html><body><span class=\"comment-copy\">\n thank you, the compiler don't accept __cdecl or __stdcall in naked function. I have removed it and crash. Becouse this is a DLL the debug is not easy however I can see that crash inside \"CallOriginalFunction\" (I don't known the exact point). Any suggests ?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "user3449922",
            "text": "<html><body><span class=\"comment-copy\">\n apart the crash I confirm that the char pointer \"src\" inside this function return the file name as I expected. I hope is possible find a solution.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  As your question indicates, you need to move all of the non-assembly code out of the\n  <code>\n   naked\n  </code>\n  function. Although I've never actually used Detours before -- I wrote my own hooking library -- what I would do would be to write a little stub that allowed me to call the\n  <code>\n   __usercall\n  </code>\n  function with an ordinary calling convention.\n </p>\n <p>\n  Be careful with the calling conventions. It will be easy to mess up the stack corrections, causing a crash. Debugging stuff like this is part of the job when you get into binary hooking. If you experience crashes, set a breakpoint at the beginning and end of all assembly sequences, and write down the value of\n  <code>\n   esp\n  </code>\n  at each of those points.\n </p>\n <p>\n  Something like this:\n </p>\n <pre><code>// Here's your hook, the ASM part. It just redirects execution to the _C function below\n// Note I removed the first two arguments, the ones in registers\n__declspec(naked) __cdecl char HookSoundFileSub_ASM(int a3, int a4, char a5, char a6, char a7, char a8, int a9)\n{\n    __asm {\n        push a9\n        push a8\n        push a7\n        push a6\n        push a5\n        push a4\n        push a3\n        push edx // a2 in edx\n        push ecx // src in ecx\n        call HookSoundFileStub_C\n        ret // Don't need to correct the stack here\n    }\n}\n\n// Here's your hook, the C part. Do whatever you want in here\nchar __stdcall HookSoundFileStub_C(char* src, int a2, int a3, int a4, char a5, char a6, char a7, char a8, int a9)\n{\n    // Your original hook code\n    // Apply  my code\n    // std::string FileName;\n    // FileName = SC::To_String(src);\n    \n    // Call the original function\n    return CallOriginalFunction(src, a2, a3, a4, a5, a6, a7, a8, a9);\n}\n\n// We moved this outside of the naked function\nDWORD AddressOfHookSoundFunction = 0x4F4463;\n\n// This just allows us to call the original function from C code\n__declspec(naked) __stdcall char CallOriginalFunction(char* src, int a2, int a3, int a4, char a5, char a6, char a7, char a8, int a9)\n{\n    __asm {\n        mov ecx, src\n        mov edx, a2\n        push a9\n        push a8\n        push a7\n        push a6\n        push a5\n        push a4\n        push a3\n        mov eax, AddressOfHookSoundFunction\n        call eax\n        add esp, 1ch // Target doesn't clear the stack, so do that\n        retn 24h // Also clear the arguments passed to this function\n    }\n}\n\n// DetourAttach(&(LPVOID&)AddressOfHookSoundFunction, &HookSoundFileSub_ASM);\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Rolf Rolles",
            "time": "Nov 16, 2020 at 23:03",
            "is_accepted": false,
            "comments": []
        }
    ]
}