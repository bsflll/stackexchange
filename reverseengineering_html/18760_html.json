{
    "title": "How does array indexing works at the assembly level?",
    "link": "https://reverseengineering.stackexchange.com/questions/18760/how-does-array-indexing-works-at-the-assembly-level",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Can anyone give me an example to understand how array indexing is working in assembly.\n </p>\n <p>\n  For example, in C:\n </p>\n <pre><code>char s[1000]; \n\nfor (int = 0; i < 5; i++)\n{\n  s[i]  = i;\n}\n</code></pre>\n <p>\n  And, in x86 assembly:\n </p>\n <pre><code>add eax,edx\nmovzx eax, byte ptr [eax]\n</code></pre>\n</div>\n</body></html>",
    "votes": "-3",
    "answers": 1,
    "views": "2k",
    "tags": [
        "disassembly",
        "assembly"
    ],
    "user": "ReverserT",
    "time": "Jul 11, 2018 at 16:53",
    "comments": [
        {
            "user": "perror",
            "text": "<html><body><span class=\"comment-copy\">\n For God sake! Learn about the wiki syntax and try to better proof read your question before hitting the \"Send\" button...\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "<html><body><span class=\"comment-copy\">\n First you want to know the\n <a href=\"https://reverseengineering.stackexchange.com/q/18710/2959\">\n  C version of an array in assembly\n </a>\n and now the same in the opposite direction. Tempting to close-vote this as a mirror-duplicate of your earlier question. You accepted an answer ... but did you not understand it? Then you need to work on your assembly knowledge.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  First of all, here is a small example written in C:\n </p>\n <pre><code>#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_ROW 5\n#define MAX_COLUMN 10\n\nint main (void)\n{\n  int array[MAX_ROW][MAX_COLUMN];\n\n  for (int row = 0; row < MAX_ROW; ++row)\n    for (int column = 0; column < MAX_COLUMN; ++column)\n      array[row][column] = ((row - 1) * (column + 1)) & ~row ;\n\n  for (int i = 0; i < MAX_ROW; ++i)\n    fprintf (stdout, \"array[%1$d][%1$d] = %2$d\n\", i, array[i][i]);\n\n  return EXIT_SUCCESS;\n}\n</code></pre>\n <p>\n  I compiled it with:\n </p>\n <pre><code>$> gcc -Wall -Wextra -std=c11 -Os -o sample sample.c\n</code></pre>\n <p>\n  The resulting (amd64) assembly is as follow:\n </p>\n <pre><code>0000000000001050 <main>:\n    1050:       41 54                   push   %r12\n    1052:       55                      push   %rbp\n    1053:       83 c8 ff                or     $0xffffffff,%eax\n    1056:       53                      push   %rbx\n    1057:       41 b8 fe ff ff ff       mov    $0xfffffffe,%r8d\n    105d:       48 81 ec d0 00 00 00    sub    $0xd0,%rsp\n    1064:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\n    1069:       49 89 cc                mov    %rcx,%r12\n    106c:       44 89 c7                mov    %r8d,%edi\n    106f:       31 d2                   xor    %edx,%edx\n    1071:       29 c7                   sub    %eax,%edi\n    1073:       89 fe                   mov    %edi,%esi\n    1075:       41 89 f1                mov    %esi,%r9d\n    1078:       01 fe                   add    %edi,%esi\n    107a:       41 21 c1                and    %eax,%r9d\n    107d:       44 89 0c 91             mov    %r9d,(%rcx,%rdx,4)\n    1081:       48 ff c2                inc    %rdx\n    1084:       48 83 fa 0a             cmp    $0xa,%rdx\n    1088:       75 eb                   jne    1075 <main+0x25>\n    108a:       ff c8                   dec    %eax\n    108c:       48 83 c1 28             add    $0x28,%rcx\n    1090:       83 f8 fa                cmp    $0xfffffffa,%eax\n    1093:       75 d7                   jne    106c <main+0x1c>\n    1095:       48 8d 2d 68 0f 00 00    lea    0xf68(%rip),%rbp\n    109c:       31 db                   xor    %ebx,%ebx\n    109e:       48 6b c3 2c             imul   $0x2c,%rbx,%rax\n    10a2:       48 8b 3d 87 2f 00 00    mov    0x2f87(%rip),%rdi\n    10a9:       89 da                   mov    %ebx,%edx\n    10ab:       48 89 ee                mov    %rbp,%rsi\n    10ae:       48 ff c3                inc    %rbx\n    10b1:       41 8b 0c 04             mov    (%r12,%rax,1),%ecx\n    10b5:       31 c0                   xor    %eax,%eax\n    10b7:       e8 74 ff ff ff          callq  1030 <fprintf@plt>\n    10bc:       48 83 fb 05             cmp    $0x5,%rbx\n    10c0:       75 dc                   jne    109e <main+0x4e>\n    10c2:       48 81 c4 d0 00 00 00    add    $0xd0,%rsp\n    10c9:       31 c0                   xor    %eax,%eax\n    10cb:       5b                      pop    %rbx\n    10cc:       5d                      pop    %rbp\n    10cd:       41 5c                   pop    %r12\n    10cf:       c3                      retq   \n</code></pre>\n <p>\n  If we take the time to look precisely at the whole assembly code, we can see that the interesting part is the following:\n </p>\n <pre><code>1064:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\n1069:       49 89 cc                mov    %rcx,%r12\n106c:       44 89 c7                mov    %r8d,%edi <-----------------\\\n106f:       31 d2                   xor    %edx,%edx                   |\n1071:       29 c7                   sub    %eax,%edi                   |\n1073:       89 fe                   mov    %edi,%esi                   |\n1075:       41 89 f1                mov    %esi,%r9d <-----------\\     |\n1078:       01 fe                   add    %edi,%esi             |     |\n107a:       41 21 c1                and    %eax,%r9d             |     |\n107d:       44 89 0c 91             mov    %r9d,(%rcx,%rdx,4)    |     |\n1081:       48 ff c2                inc    %rdx                  |     |\n1084:       48 83 fa 0a             cmp    $0xa,%rdx             |     |\n1088:       75 eb                   jne    1075 <main+0x25>------/     |\n108a:       ff c8                   dec    %eax                        |\n108c:       48 83 c1 28             add    $0x28,%rcx                  |\n1090:       83 f8 fa                cmp    $0xfffffffa,%eax            |\n1093:       75 d7                   jne    106c <main+0x1c> -----------/\n</code></pre>\n <p>\n  It depict the double loop that initialize the example matrix where\n  <code>\n   rdx\n  </code>\n  is the\n  <code>\n   column\n  </code>\n  variable (it is compared to\n  <code>\n   0xa\n  </code>\n  which is 10 in decimal) and\n  <code>\n   eax\n  </code>\n  is the\n  <code>\n   row\n  </code>\n  variable (it is compared to\n  <code>\n   0xfffffffa\n  </code>\n  which is -6). For some reasons that we will see later, one index is increased and the other one is decreased, but both start from zero.\n </p>\n <p>\n  Now, the access to the array is located here:\n </p>\n <pre><code>107d:       44 89 0c 91             mov    %r9d,(%rcx,%rdx,4)\n</code></pre>\n <p>\n  Which would be translated into\n  <code>\n   mov [rcx + 4*rdx], r9d\n  </code>\n  in Intel format. Basically:\n </p>\n <ul>\n  <li>\n   <code>\n    rcx\n   </code>\n   is the base address of the current row.\n  </li>\n  <li>\n   <code>\n    rdx\n   </code>\n   is the column index within the same row vector.\n  </li>\n </ul>\n <p>\n  Note that when we move to the next row,\n  <code>\n   rcx\n  </code>\n  is updated like that:\n </p>\n <pre><code>108c:       48 83 c1 28             add    $0x28,%rcx\n</code></pre>\n <p>\n  Basically, it moves from the current row to the next one knowing that the row contains 10 items and each item is an\n  <code>\n   int\n  </code>\n  (4 bytes). So, 40 bytes in total which is 0x28 in hexadecimal.\n </p>\n <p>\n  And, the very first initialization of\n  <code>\n   rcx\n  </code>\n  is given by:\n </p>\n <pre><code>1064:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\n</code></pre>\n <p>\n  It clearly load the address of the\n  <code>\n   array\n  </code>\n  which is somewhere on the stack.\n </p>\n <p>\n  Getting all together now!\n </p>\n <p>\n  So, we have the\n  <code>\n   array\n  </code>\n  on the stack at\n  <code>\n   rsp+0x8\n  </code>\n  which is a contiguous memory area of size:\n </p>\n <pre><code>5 * 10 * 4 bytes (`rows * columns * sizeof(int)`) = 200 bytes = 0xc8 bytes\n</code></pre>\n <p>\n  And, it is mapped as a sequence of rows of 40 bytes each. Each row gather 10 columns with cells of 4 bytes which can be depicted as follow:\n </p>\n <pre><code>---------------------------------------------------------------------------------\n ... | array[0][0] | array[0][1] | array[0][2] | array[0][3] | array[0][4] | ...\n---------------------------------------------------------------------------------\n</code></pre>\n <p>\n  Of course, you can find more complex mapping when dealing with multi-dimensional arrays in C, this one is quite simple. Just for completude remember that in total generality the mapping of a multi-dimensional array in C looks usually like that:\n </p>\n <p>\n  <a href=\"https://i.sstatic.net/u3nfL.png\" rel=\"noreferrer\">\n   <img alt=\"Matrix memory mapping in C\" src=\"https://i.sstatic.net/u3nfL.png\"/>\n  </a>\n </p>\n <p>\n  And, the structure of the assembly code will follow these constraints (slightly more complex but not so much once you understood the previous simple example).\n </p>\n</div>\n</body></html>",
            "votes": "7",
            "user": "perror",
            "time": "Jul 11, 2018 at 18:48",
            "is_accepted": false,
            "comments": []
        }
    ]
}