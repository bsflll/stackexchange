{
    "title": "Find out which struct RaGetUnitStorageDeviceProperty use by reverse engineering",
    "link": "https://reverseengineering.stackexchange.com/questions/30897/find-out-which-struct-ragetunitstoragedeviceproperty-use-by-reverse-engineering",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am trying to find out which struct\n  <code>\n   storport!RaGetUnitStorageDeviceProperty\n  </code>\n  uses by myself. I know I can use google and find out the correct answer is\n  <code>\n   _RAID_UNIT_EXTENSION\n  </code>\n  . However i want to do it myself on my own manually and learn the logic behind it.\n </p>\n <p>\n  Things so far I tried include setting a breakpoint on the function and then using the\n  <code>\n   dt\n  </code>\n  command which shows the function name as result. I also used IDA to see if I can get any trace of struct but I could not find any trace of\n  <code>\n   _RAID_UNIT_EXTENSION\n  </code>\n  with IDA even though I used storport.pdb as well. How can I find it myself manually? I can clearly see\n  <code>\n   _RAID_UNIT_EXTENSION\n  </code>\n  using\n  <code>\n   dt storport!*\n  </code>\n  in the output but there is not any trace of such a name in IDA.\nI would really appreciate it if someone could help me.\n </p>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 1,
    "views": "129",
    "tags": [
        "windows",
        "debugging",
        "windbg",
        "kernel-mode",
        "driver"
    ],
    "user": "user19819208",
    "time": "Sep 19, 2022 at 18:55",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  unless you have a private pdb for storport you wouldn't be able to locate the names\nand even if you have the private pdb it is mostly a guessing game\n </p>\n <p>\n  i will show a demo using windbg adapt it to the tools of your choice\n </p>\n <p>\n  1)locating function of interest\n </p>\n <pre><code>0: kd> x /v /t /f storport!RaGetUnitStorageDeviceProperty\nprv func   fffff801`36f12664  268 <CLR type> storport!RaGetUnitStorageDeviceProperty (void)\n</code></pre>\n <p>\n  since the argument list is void either this functions takes no arguments or the details are missing and is not easily locatable without putting in effort\n </p>\n <p>\n  since this is an x64 the first four arguments are passed via rcx,rdx,r8,r9 in windows\nlets check if any of them are used inside the function.\n </p>\n <p>\n  if they are going to be accessed they would be saved or used very early in the function dissassemble first 15 lines of the functions\n </p>\n <pre><code>0: kd> u storport!RaGetUnitStorageDeviceProperty l15\nstorport!RaGetUnitStorageDeviceProperty:\nfffff801`36f12664 4055            push    rbp\nfffff801`36f12666 53              push    rbx\nfffff801`36f12667 56              push    rsi\nfffff801`36f12668 57              push    rdi\nfffff801`36f12669 4154            push    r12\nfffff801`36f1266b 4156            push    r14\nfffff801`36f1266d 4157            push    r15\nfffff801`36f1266f 488dac2440ffffff lea     rbp,[rsp-0C0h]\nfffff801`36f12677 4881ecc0010000  sub     rsp,1C0h\nfffff801`36f1267e 488b056b6cffff  mov     rax,qword ptr [storport!_security_cookie (fffff801`36f092f0)]\nfffff801`36f12685 4833c4          xor     rax,rsp\nfffff801`36f12688 488985b0000000  mov     qword ptr [rbp+0B0h],rax\nfffff801`36f1268f 488b7968        mov     rdi,qword ptr [rcx+68h]\nfffff801`36f12693 4d8bf0          mov     r14,r8 <<<<<<<<<<<<<<<<<\nfffff801`36f12696 4c8bfa          mov     r15,rdx <<<<<<<<<<<<<<<<<\nfffff801`36f12699 488bd9          mov     rbx,rcx <<<<<<<<<<<<<<<<<<<<<<<\nfffff801`36f1269c 41bc8c010000    mov     r12d,18Ch\nfffff801`36f126a2 488d4c2420      lea     rcx,[rsp+20h]\nfffff801`36f126a7 458bc4          mov     r8d,r12d\nfffff801`36f126aa 33d2            xor     edx,edx\nfffff801`36f126ac e88fd2faff      call    storport!memset (fffff801`36ebf940)\n</code></pre>\n <p>\n  as you can notice three arguments are saved the first argument rcx is saved to rbx\nthe second argument rdx is saved to r15  the third argument r8 is saved to r14\n </p>\n <p>\n  disassemble the full function and grep for r9 just in case\n </p>\n <pre><code>0: kd> .shell -ci \"uf storport!RaGetUnitStorageDeviceProperty\" findstr \"r9\"\n.shell: Process exited\n</code></pre>\n <p>\n  no sign of r9 so this function possibly takes 3 arguments\n </p>\n <p>\n  lets concentrate on rbx which holds the first argument\n </p>\n <pre><code>0: kd> .shell -ci \"uf storport!RaGetUnitStorageDeviceProperty\" findstr \"rbx\"\nfffff801`36f12666 53              push    rbx\nfffff801`36f12699 488bd9          mov     rbx,rcx\nfffff801`36f126f3 8b83d00c0000    mov     eax,dword ptr [rbx+0CD0h] <<<<<<<\nfffff801`36f126fd 488b8398000000  mov     rax,qword ptr [rbx+98h]\nfffff801`36f1270d 488b9390000000  mov     rdx,qword ptr [rbx+90h]\nfffff801`36f1274c 6644396372      cmp     word ptr [rbx+72h],r12w\nfffff801`36f12773 0fb74370        movzx   eax,word ptr [rbx+70h]\nfffff801`36f12777 488b5378        mov     rdx,qword ptr [rbx+78h]\nfffff801`36f127c4 5b              pop     rbx\nfffff801`36f12819 6644396372      cmp     word ptr [rbx+72h],r12w\nfffff801`36f1282e 488b4318        mov     rax,qword ptr [rbx+18h]\nfffff801`36f12879 6644396372      cmp     word ptr [rbx+72h],r12w\nfffff801`36f12880 0fb77b70        movzx   edi,word ptr [rbx+70h]\nfffff801`36f12898 488b5378        mov     rdx,qword ptr [rbx+78h]\n.shell: Process exited\n</code></pre>\n <p>\n  this clearly shows rbx is used and is possibly a structure and is possibly a very large structure as a member at offset 0xcd0  is accessed  so the possible sizeof structure is greater than   0xcd0\n </p>\n <p>\n  from this stage on you either need to identify each member manually and name them or use google or tools like ida / ghidra to aid you or debug the function and infer the members of the structure\n </p>\n <p>\n  since you already googled and is having a possible candidate lets trial and eliminate or confirm its correctness\n </p>\n <p>\n  confirm if size is greater than the accessed offset\n </p>\n <pre><code>0: kd> ?? sizeof(storport!_RAID_UNIT_EXTENSION)\nunsigned int64 0xd40\n</code></pre>\n <p>\n  yes it is greater\n </p>\n <p>\n  check if offset 0xcd0 is correct offset for a member inside this structure\n </p>\n <pre><code>0: kd> .shell -ci \"dt -v storport!_RAID_UNIT_EXTENSION \" findstr \"cd0\"\n   +0xcd0 BusType          : Enum _STORAGE_BUS_TYPE,  22 total enums\n.shell: Process exited\n</code></pre>\n <p>\n  sure it matches\nlets check the enum\n </p>\n <pre><code>0: kd> dt -v storport!_STORAGE_BUS_TYPE\nEnum _STORAGE_BUS_TYPE,  22 total enums\n   BusTypeUnknown = 0n0\n   BusTypeScsi = 0n1\n   BusTypeAtapi = 0n2\n   BusTypeAta = 0n3\n   BusType1394 = 0n4\n   BusTypeSsa = 0n5\n   BusTypeFibre = 0n6\n   BusTypeUsb = 0n7\n   BusTypeRAID = 0n8\n   BusTypeiScsi = 0n9\n   BusTypeSas = 0n10\n   BusTypeSata = 0n11\n   BusTypeSd = 0n12\n   BusTypeMmc = 0n13\n   BusTypeVirtual = 0n14\n   BusTypeFileBackedVirtual = 0n15\n   BusTypeSpaces = 0n16\n   BusTypeNvme = 0n17\n   BusTypeSCM = 0n18\n   BusTypeUfs = 0n19\n   BusTypeMax = 0n20\n   BusTypeMaxReserved = 0n127\n</code></pre>\n <p>\n  ok test eax,eax means it is possibly checking BusTypeUnknown\n </p>\n <p>\n  lets check other offsets\n </p>\n <p>\n  +0x018 Adapter          : Ptr64 to struct _RAID_ADAPTER_EXTENSION, 178 elements, 0x1740 bytes\n </p>\n <p>\n  all other member access 0x70,72,0x90,0x98 etc  fall inside\n </p>\n <pre><code>   +0x068 Identity         : struct _STOR_SCSI_IDENTITY, 7 elements, 0x38 bytes\n   +0x0a0 VendorId         : [9] UChar\n</code></pre>\n <p>\n  lets check that structure\n </p>\n <pre><code>0: kd> dt -v storport!_STOR_SCSI_IDENTITY\nstruct _STOR_SCSI_IDENTITY, 7 elements, 0x38 bytes\n   +0x000 InquiryData      : Ptr64 to struct _INQUIRYDATA, 44 elements, 0x68 bytes\n   +0x008 SerialNumber     : struct _STRING, 3 elements, 0x10 bytes\n   +0x018 Supports1667     : UChar\n   +0x019 ZonedDevice      : UChar\n   +0x020 DeviceId         : Ptr64 to struct _VPD_IDENTIFICATION_PAGE, 6 elements, 0x4 bytes\n   +0x028 AtaDeviceId      : Ptr64 to struct _STOR_ATA_DEVICE_ID, 2 elements, 0x32 bytes\n   +0x030 RichDeviceDescription : Ptr64 to struct _STOR_RICH_DEVICE_DESCRIPTION, 5 elements, 0x6c bytes\n</code></pre>\n <p>\n  <a href=\"https://www.unknowncheats.me/forum/2858059-post136.html\" rel=\"nofollow noreferrer\">\n   so your google foo has landed a possibly correct reference to the implementation\n  </a>\n </p>\n <p>\n  opened the storport.sys in ghidra / configured symbol path / searched for the function and de-compiled it  selected the PARAMETER 1 and assigned _RAID_UNIT_EXTENSION to it and voila you get a neat output\n </p>\n <pre><code>void RaGetUnitStorageDeviceProperty(_RAID_UNIT_EXTENSION *param_1,void *param_2,uint *param_3)\n\n{\nxxxxxxxxxxxxxxxxxxxxxx\n  local_1bc = param_1->BusType;\n  p_Var5 = (param_1->Identity).RichDeviceDescription;\n  if (p_Var5 == (_STOR_RICH_DEVICE_DESCRIPTION *)0x0) {\n    p_Var6 = (param_1->Identity).AtaDeviceId;\n    if ((p_Var6 == (_STOR_ATA_DEVICE_ID *)0x0) ||\n       ((((param_1->Adapter->Miniport).HwInitializationData)->FeatureSupport & 0x40) == 0)) {\n      local_1b0 = *(undefined8 *)p_Var4->VendorId;\n      uVar3 = *(undefined4 *)p_Var4->ProductRevisionLevel;\n      uStack424 = uStack424 & 0xff | *(int *)p_Var4->ProductId << 8;\n      uStack420._1_3_ = (undefined3)*(undefined4 *)(p_Var4->ProductId + 4);\n      uStack420 = CONCAT31(uStack420._1_3_,(char)((uint)*(int *)p_Var4->ProductId >> 0x18));\n      uStack416._1_3_ = (undefined3)*(undefined4 *)(p_Var4->ProductId + 8);\n      uStack416 = CONCAT31(uStack416._1_3_,\n                           (char)((uint)*(undefined4 *)(p_Var4->ProductId + 4) >> 0x18));\n      uStack412._1_3_ = (undefined3)*(undefined4 *)(p_Var4->ProductId + 0xc);\n      uStack412 = CONCAT31(uStack412._1_3_,\n                           (char)((uint)*(undefined4 *)(p_Var4->ProductId + 8) >> 0x18));\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n</code></pre>\n <p>\n  opening the file in idafree8  inserted the standard structure _RAxxxxx\nassigned the parameter to pointer to standard structure  and decompiled\n </p>\n <p>\n  idas output\n </p>\n <pre><code>  HIDWORD(v26[3]) = a1->BusType;\n  RichDeviceDescription = a1->Identity.RichDeviceDescription;\n  if ( RichDeviceDescription )\n  {\n    if ( RichDeviceDescription->VendorId[0] )\n    {\n      v15 = *(_OWORD *)RichDeviceDescription->VendorId;\n      HIDWORD(v26[1]) = 40;\n      *(_OWORD *)&v26[5] = v15;\n    }\n    v16 = *(_OWORD *)RichDeviceDescription->ModelNumber;\n    v26[2] = 0x7A00000039i64;\n    v17 = *(_OWORD *)&RichDeviceDescription->ModelNumber[16];\n    *(_OWORD *)((char *)&v26[7] + 1) = v16;\n    v18 = *(_OWORD *)&RichDeviceDescription->ModelNumber[32];\n    *(_OWORD *)((char *)&v26[9] + 1) = v17;\n    v19 = *(_OWORD *)&RichDeviceDescription->ModelNumber[48];\n    *(_OWORD *)((char *)&v26[11] + 1) = v18;\n    v20 = *(_OWORD *)RichDeviceDescription->FirmwareRevision;\n    *(_OWORD *)((char *)&v26[13] + 1) = v19;\n    *(_OWORD *)((char *)&v26[15] + 2) = v20;\n    if ( a1->Identity.SerialNumber.MaximumLength )\n      JUMPOUT(0x1C00761D0i64);\n    goto LABEL_12;\n  }\n  AtaDeviceId = a1->Identity.AtaDeviceId;\n  if ( AtaDeviceId && (a1->Adapter->Miniport.HwInitializationData->FeatureSupport & 0x40) != 0 )\n  {\n    v21 = *(_OWORD *)AtaDeviceId->ModelNumber;\n    v22 = *(_QWORD *)AtaDeviceId->FirmwareRevision;\n    v23 = *(_OWORD *)&AtaDeviceId->ModelNumber[16];\n    v26[2] = 0x5100000028i64;\n    *(_OWORD *)&v26[5] = v21;\n    *(_QWORD *)((char *)&v26[10] + 1) = v22;\n    v26[9] = *(_QWORD *)&AtaDeviceId->ModelNumber[32];\n    *(_OWORD *)&v26[7] = v23;\n    if ( a1->Identity.SerialNumber.MaximumLength )\n    {\n      Length = a1->Identity.SerialNumber.Length;\n      LODWORD(v26[3]) = 90;\n      memmove((char *)&v26[11] + 2, a1->Identity.SerialNumber.Buffer);\n      v25 = 21;\n      if ( (unsigned __int64)(Length + 1) < 0x15 )\n        v25 = Length + 1;\n      RaidRemoveTrailingBlanks((char *)&v26[11] + 2, v25);\n      goto LABEL_8;\n    }\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "blabb",
            "time": "Sep 22, 2022 at 15:41",
            "is_accepted": true,
            "comments": [
                {
                    "user": "user19819208",
                    "text": "<span class=\"comment-copy\">Thank you so much for this wonderful answer. I just have one more question. How should I insert struct in IDA? I am new to reverse engineering. I can't find any structure in IDA with that name.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">shift+f9 -&gt; add standard structure -&gt; load til or pdb as the case maybe if the standard structure dialog is empty or partial</span>",
                    "time": null
                }
            ]
        }
    ]
}