{
    "title": "Data placement in memory",
    "link": "https://reverseengineering.stackexchange.com/questions/31111/data-placement-in-memory",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am playing with buffer overflow attacks in C. I have the following code:\n </p>\n <pre><code>int foo(void*, void*);        // Calculates the distance (in bytes) between two addresses in memory\n\nint main(int argc, char** argv) {\n   int a = 15;\n   int b = 16;\n   int c = 90;\n\n   char buffer[4];\n   \n   /* Memory layout */\n   printf(\"[LAYOUT]\n\");\n   printf(\"foo(&a, &b) is %d\n\", foo(&a, &b));\n   printf(\"foo(&a, &c) is %d\n\", foo(&a, &c));\n   printf(\"foo(&c, &string) is %d\n\", foo(&c, &string));\n   printf(\"foo(&a, &string) is %d\n\n\", foo(&a, &string));\n\n   /* Memory content before copying into the buffer */\n   printf(\"[BEFORE]\n\");\n   printf(\"a is at %p and is %d (0x%08x)\n\", &a, a, a);\n   printf(\"b is at %p and is %d (0x%08x)\n\", &b, b, b);\n   printf(\"c is at %p and is %d (0x%08x)\n\", &c, c, c);\n   printf(\"string is at %p and is %s\n\n\", &string, string);\n\n   strcpy(buffer, \"aaaaaaaaa\");\n\n   /* Memory content after copying into the buffer */\n   printf(\"[AFTER]\n\");\n   printf(\"a is at %p and is %d (0x%08x)\n\", &a, a, a);\n   printf(\"b is at %p and is %d (0x%08x)\n\", &b, b, b);\n   printf(\"c is at %p and is %d (0x%08x)\n\", &c, c, c);\n   printf(\"string is at %p and is %s\n\", &string, string);\n\n   return EXIT_SUCCESS;\n}\n\nint foo(void* addr_1, void* addr_2) {\n   return (addr_1 - addr_2);\n}\n</code></pre>\n <p>\n  After the compilation with\n  <code>\n   gcc main.c -o main -O0 -g -fno-stack-protector -D_FORTIFY_SOURCE=0\n  </code>\n  flags\n  <strong>\n   with optimization turned off\n  </strong>\n  , the output is following (\n  <em>\n   on my machine\n  </em>\n  ):\n </p>\n <pre><code>[LAYOUT]\nfoo(&a, &b) is 4\nfoo(&a, &c) is 8\nfoo(&c, &string) is 4\nfoo(&a, &string) is 12\n\n[BEFORE]\na is at 0x7ffee13d5b68 and is 16 (0x00000010)\nb is at 0x7ffee13d5b64 and is 15 (0x0000000f)\nc is at 0x7ffee13d5b60 and is 90 (0x0000005a)\nstring is at 0x7ffee13d5b5c and is \n\n[AFTER]\na is at 0x7ffee13d5b68 and is 16 (0x00000010)\nb is at 0x7ffee13d5b64 and is 97 (0x00000061)\nc is at 0x7ffee13d5b60 and is 1633771873 (0x61616161)\nstring is at 0x7ffee13d5b5c and is aaaaaaaaa\n</code></pre>\n <p>\n  Obviously, the buffer is located at the leftmost position, before integer variables. I can think of it as:\n </p>\n <div class=\"s-table-container\">\n  <table class=\"s-table\">\n   <thead>\n    <tr>\n     <th style=\"text-align: center;\">\n      0x5c\n     </th>\n     <th style=\"text-align: center;\">\n      0x5d\n     </th>\n     <th style=\"text-align: center;\">\n      0x5e\n     </th>\n     <th style=\"text-align: center;\">\n      0x5f\n     </th>\n     <th style=\"text-align: center;\">\n      0x60\n     </th>\n     <th style=\"text-align: center;\">\n      0x61\n     </th>\n     <th style=\"text-align: center;\">\n      0x62\n     </th>\n     <th style=\"text-align: center;\">\n      0x63\n     </th>\n     <th style=\"text-align: center;\">\n      0x64\n     </th>\n    </tr>\n   </thead>\n   <tbody>\n    <tr>\n     <td style=\"text-align: center;\">\n      0x61\n     </td>\n     <td style=\"text-align: center;\">\n      0x61\n     </td>\n     <td style=\"text-align: center;\">\n      0x61\n     </td>\n     <td style=\"text-align: center;\">\n      0x61\n     </td>\n     <td style=\"text-align: center;\">\n      0x61\n     </td>\n     <td style=\"text-align: center;\">\n      0x61\n     </td>\n     <td style=\"text-align: center;\">\n      0x61\n     </td>\n     <td style=\"text-align: center;\">\n      0x61\n     </td>\n     <td style=\"text-align: center;\">\n      0x61\n     </td>\n    </tr>\n   </tbody>\n  </table>\n </div>\n <p>\n  It completely overwrites\n  <code>\n   c\n  </code>\n  's data (all four bytes) and the one byte of\n  <code>\n   b\n  </code>\n  's data (\n  <em>\n   little-endian machine\n  </em>\n  ).\n </p>\n <p>\n  After compiling the same program with the optimization turned on,\n  <code>\n   -O1\n  </code>\n  for example, it produces the output:\n </p>\n <pre><code>[LAYOUT]\nfoo(&a, &b) is -4\nfoo(&a, &c) is -8\nfoo(&c, &string) is 12\nfoo(&a, &string) is 4\n\n[BEFORE]\na is at 0x7ffee056db3c and is 16 (0x00000010)\nb is at 0x7ffee056db40 and is 15 (0x0000000f)\nc is at 0x7ffee056db44 and is 90 (0x0000005a)\nstring is at 0x7ffee056db38 and is \n\n[AFTER]\na is at 0x7ffee056db3c and is 1633771873 (0x61616161)\nb is at 0x7ffee056db40 and is 97 (0x00000061)\nc is at 0x7ffee056db44 and is 90 (0x0000005a)\nstring is at 0x7ffee056db38 and is aaaaaaaaa\n</code></pre>\n <p>\n  It seems to me that integer variables are placed in memory in reversed order.\n </p>\n <p>\n  The questions are:\n </p>\n <ol>\n  <li>\n   <strong>\n    How does a variable declaration and/or initialization in C affect its placement in memory?\n   </strong>\n  </li>\n  <li>\n   <strong>\n    Does the optimization affect on variable placement in memory? If so, then how?\n   </strong>\n  </li>\n </ol>\n <p>\n  The working environment is\n  <code>\n   macOS Mojave 10.14.6\n  </code>\n  ,\n  <code>\n   Apple LLVM version 10.0.1 (clang-1001.0.46.4)\n  </code>\n </p>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 0,
    "views": "47",
    "tags": [
        "disassembly",
        "assembly",
        "c",
        "memory",
        "buffer-overflow"
    ],
    "user": "Stone Paul",
    "time": "Nov 9, 2022 at 1:42",
    "comments": [
        {
            "user": "Mega Tonnage",
            "text": "<html><body><span class=\"comment-copy\">\n You might find that this is compiler dependent.. this is not part of the C standard.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}