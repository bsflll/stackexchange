{
    "title": "What is the best way to change the call-graph of a PE file without changing its real behavior and without packing it?",
    "link": "https://reverseengineering.stackexchange.com/questions/23433/what-is-the-best-way-to-change-the-call-graph-of-a-pe-file-without-changing-its",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  What i want to do is take a PE file, extract its call-graph, and then inject a junk function in it, so for example by injecting a junk function inside of it, and changing a call instruction's opcode to point to this junk function, and then returning to the original destination after the junk code is done without changing the behavior of program\n </p>\n <p>\n  so is there any open source program that does this so i can see how they did it?\n </p>\n <p>\n  my idea is to create a new section in PE at the end of it, and change section headers by modifying an existing section which is not used or appending a new section header, and then change some call instruction to point to this\n </p>\n <p>\n  the problem i think i will face is long calls, basically if the offset between junk code and call instruction is too far, then i have to change the call instruction to a far call instruction which makes things really complicated if not impossible\n </p>\n <p>\n  so any suggestion? do you guys happen to know any open-source program that does this? or maybe i can approach this better? all i want is to change the call-graph of a PE file\n </p>\n</div>\n</body></html>",
    "votes": "0",
    "answers": 3,
    "views": "305",
    "tags": [
        "windows",
        "x86",
        "malware",
        "pe"
    ],
    "user": "OneAndOnly",
    "time": "Mar 14, 2020 at 5:58",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  There are several ways you can achieve this. I assume you don't have source code of the executable, otherwise you would just tell the compiler to for example generate few\n  <code>\n   nop\n  </code>\n  s for you after the\n  <code>\n   call\n  </code>\n  opcode, so you would simply patch the call without any data shifting.\n </p>\n <p>\n  As you said, you could replace the call with long call (but as far as I know all calls on x86-32 takes 4+1 bytes of space, no matter if they are relative or absolute) and shift all the instructions below because there is sometimes free space between functions generated by compiler (eg filed with 0xCC), but then you would need to fix all jumps/calls to addresses that are affected by your shift. Doing this you have to remember that there may be dynamicaly generated jump-tables/calls that you would also need to replace.\n </p>\n <p>\n  The better approach would be to hook that function and apply short prolog and epilog to your payload. I will try to explain how it can be done. Let's say you have following assembly instructions:\n </p>\n <pre><code>0069DDCC            | 8B00                        | mov eax,dword ptr ds:[eax]\n0069DDCE            | 8B50 24                     | mov edx,dword ptr ds:[eax+24]\n0069DDD1            | A1 00506F00                 | mov eax,dword ptr ds:[6F5000]\n0069DDD6            | 8B00                        | mov eax,dword ptr ds:[eax]\n</code></pre>\n <p>\n  And you want to redirect the code flow at\n  <code>\n   0x69DDCE\n  </code>\n  to your function that is located at\n  <code>\n   0xDEADBEEF\n  </code>\n  . As you can see the instruction at\n  <code>\n   0x69DDCE\n  </code>\n  is 3 bytes long, but the long jmp is actually 5 bytes long. After patching the 5 bytes our code looks like:\n </p>\n <pre><code>0069DDCC            | 8B00                        | mov eax,dword ptr ds:[eax]\n0069DDCE            | E9 1CE143DE                 | jmp DEADBEEF\n0069DDD3            | 5C                          | pop esp\n0069DDD4            | 6F                          | outsd\n0069DDD5            | 008B 00E81770               | add byte ptr ds:[ebx+7017E800],cl\n</code></pre>\n <p>\n  This is because we have partially overwritten the\n  <code>\n   mov eax,dword ptr ds:[6F5000]\n  </code>\n  so our code will change the behavior after returning from your function at\n  <code>\n   0xDEADBEEF\n  </code>\n  . The thing we need to do here is to\n  <code>\n   NOP\n  </code>\n  the instruction totally, so in fact we need to patch 8 bytes (\n  <code>\n   mov edx,dword ptr ds:[eax+24]\n  </code>\n  +\n  <code>\n   mov eax,dword ptr ds:[6F5000]\n  </code>\n  ), so it will look like this:\n </p>\n <pre><code>0069DDCC            | 8B00                        | mov eax,dword ptr ds:[eax]\n0069DDCE            | E9 1CE143DE                 | jmp DEADBEEF\n0069DDD3            | 90                          | nop\n0069DDD4            | 90                          | nop\n0069DDD5            | 90                          | nop\n0069DDD6            | 8B00                        | mov eax,dword ptr ds:[eax]\n</code></pre>\n <p>\n  Now we need to prepare our payload at\n  <code>\n   0xDEADBEEF\n  </code>\n  . Keep in mind that you have removed two instructions from the original code, so you need to execute them at some point, also note the address where we should restore the original code flow, which is\n  <code>\n   0x69DDD6\n  </code>\n  . If you plan to modify the registers in your payload you need to save them, the best would be probably to call the pushad/pushfd, so the final payload at\n  <code>\n   0xDEADBEEF\n  </code>\n  can look like this\n </p>\n <pre><code>pushad\npushfd\n; your code\npopfd\npopad\nmov edx,dword ptr ds:[eax+24]\nmov eax,dword ptr ds:[6F5000]\njmp 0x69DDD6\n</code></pre>\n <p>\n  The\n  <code>\n   mov\n  </code>\n  s in the payload are the ones you have deleted from original code, and the\n  <code>\n   jmp 0x69DDD6\n  </code>\n  is the place where you should restore the original flow. Keep in mind that if you write something to the program memory in your code you may change the way program executes if it will use your changed data at some point. Otherwise the program should continue normally after jumping back from your function.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "morsisko",
            "time": "May 15, 2020 at 17:32",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  It looks like you are looking for some hooking frameworks.\n </p>\n <p>\n  You can check\n  <a href=\"https://www.microsoft.com/en-us/research/project/detours/\" rel=\"nofollow noreferrer\">\n   detours\n  </a>\n  and\n  <a href=\"https://frida.re/\" rel=\"nofollow noreferrer\">\n   Frida\n  </a>\n  for this purpose.\n </p>\n <p>\n  Check in particular this\n  <a href=\"https://github.com/microsoft/detours/wiki/Using-Detours\" rel=\"nofollow noreferrer\">\n   example\n  </a>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "macro_controller",
            "time": "Mar 15, 2020 at 9:31",
            "is_accepted": false,
            "comments": [
                {
                    "user": "OneAndOnly",
                    "text": "<span class=\"comment-copy\">but will these two help in case of hooking an actual function and not an windows API? for example can i give it a function address and tell it hook this for me? also which of them is better?</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  What you want is call inline patching, you can read about it\n  <a href=\"https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-1.html\" rel=\"nofollow noreferrer\">\n   here\n  </a>\n  . I don't know any generic tool for that, but it is relatively easy to create one for yourself if you understand the logic behind it.\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "Cih2001",
            "time": "Apr 14, 2020 at 10:35",
            "is_accepted": false,
            "comments": []
        }
    ]
}