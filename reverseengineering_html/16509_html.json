{
    "title": "Identify password generation algorithm",
    "link": "https://reverseengineering.stackexchange.com/questions/16509/identify-password-generation-algorithm",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm a newbie who just started own way through reverse engineering so I apologize if my question is not appropriate.\nCurrently I'm going through different Crackme puzzles and now I'm stuck. I've spend a couple of days trying to solve it but I can't.\n </p>\n <p>\n  We enter a login and a password. Then we apply\n  <em>\n   algorithm #1\n  </em>\n  on login. And\n  <em>\n   algorithm #2\n  </em>\n  on password. In both cases we get a number as a result. And if the two numbers are equal, then the password is correct. I'm trying to find a way to generate a correct password for any given login.\n </p>\n <p>\n  I've figured out both algorithms with IDA and wrote a program in C++ to test my solutions.\n </p>\n <h3>\n  Algorithm For Login\n </h3>\n <p>\n  Login should be at least 4 chars.\n </p>\n <pre><code>login = \"Vasya_Pupkin\"\n</code></pre>\n <p>\n  1) From login we get two first chars (\"Va\") and two last (\"in\") and write its ASCII-code into hex number:\n </p>\n <pre><code>V = 0x56, a = 0x61, i = 0x69, n = 0x6e\nhexVain = 0x5661696e\n</code></pre>\n <p>\n  2) We go through the login string and add up all ASCII-codes:\n </p>\n <pre><code>for (int j = 0; j < login.length(); j++)        \n    asciiSum += login[j];\n</code></pre>\n <p>\n  For\n  <code>\n   Vasya_Pupkin\n  </code>\n  we get\n  <code>\n   asciiSum = 0x4da\n  </code>\n </p>\n <p>\n  3) We xor those values with some number 0xfec0135a:\n </p>\n <pre><code>hexVain ^ asciiSum ^ 0xfec0135a\nmagicValueLogin = 0xa8a17eee\n</code></pre>\n <h3>\n  Algorithm For Password\n </h3>\n <p>\n  Password should be at least 12 chars and should contain only'a'-'f', 'A'-'F', '0'-'9'.\nWe enter password as string. Then we divide the length by 2.\n </p>\n <pre><code>password_str = \"011c0d0f090e00\";\nn = password_str.length() / 2;  // n = 7\n</code></pre>\n <p>\n  Then we convert string representation to hex and aplly this algorithm:\nWe go through every byte from left to right and calculate new magic value.\n </p>\n <pre><code>password = 0x011c0d0f090e00;\nmagicValuePass = 0xadde;\nfor (int i = 0; i < n; i++)\n{\n    // we count bytes from left to right\n    passByte = getByte(password, i);    \n\n    // multiplication by 32 is left shift for 5 bytes\n    magicValuePass = passByte ^ (32 * magicValuePass + 1) ^ 0xdeadbeef;\n}\n</code></pre>\n <p>\n  The output of this function is following:\n </p>\n <pre><code>Byte:  01\nMagic: deb8052f\n\nByte:  1c\nMagic: 9ad1b12\n\nByte:  0d\nMagic: eb0edca3\n\nByte:  0f\nMagic: bf762a81\n\nByte:  09\nMagic: 3068eec7\n\nByte:  0e\nMagic: d3b06600\n\nByte:  00\nMagic: a8a17eee\n</code></pre>\n <p>\n  In the end we get\n  <code>\n   magicValuePass = 0xa8a17eee\n  </code>\n  which is the same value we get for login so the password is correct.\n </p>\n <h3>\n  What I've Tried\n </h3>\n <p>\n  I thought about reversing\n  <code>\n   magicValuePass\n  </code>\n  generation but but came to conclusion that's a bad idea.\n </p>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 2,
    "views": "2k",
    "tags": [
        "encryption",
        "decryption",
        "xor"
    ],
    "user": "Neilana",
    "time": "Oct 8, 2017 at 11:11",
    "comments": [
        {
            "user": "Paweł Łukasik",
            "text": "<html><body><span class=\"comment-copy\">\n I guess instead of identifying the algorithm you want to RE to be able to write a keygen of some sort, right?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Neilana",
            "text": "<html><body><span class=\"comment-copy\">\n @PawełŁukasik Exactly! We have to figure out the correct password for a given login.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  As you have just started into RE, try looking into SAT solvers.\n  <a href=\"https://github.com/Z3Prover/z3\" rel=\"nofollow noreferrer\">\n   Z3\n  </a>\n  is a great tool that will help you in such simple tasks with APIs in all major languages. Here is a solution I tried in python.\n </p>\n <pre><code>password = BitVec(\"password\",64)\nmagicValuePass = BitVec(\"magicValuePass\",64)\n\ns = Solver()\nidx = 7\nmagicValuePass =  (((password&(0xff<<(8*idx)))>>(8*idx))^ (32 * 0xadde + 1) ^ 0xdeadbeef) & 0xffffffff\nfor i in xrange(6,0,-1):\n    magicValuePass =  (((password&(0xff<<(8*i)))>>(8*i))^ (32 * magicValuePass + 1) ^ 0xdeadbeef) & 0xffffffff\n\ns.add(magicValuePass == magicValueLogin)\n\nif s.check() == sat:\n    print hex(s.model()[password].as_long())\n</code></pre>\n <p>\n  First declare\n  <code>\n   password\n  </code>\n  to be a 64 bit variable. Then iterate byte by byte  calculating the intermediate values and finally set the\n  <code>\n   magicValuePass\n  </code>\n  equal to\n  <code>\n   magicValueLogin\n  </code>\n  . If a solution exists to such conditions Z3 will run for some time and give the solution which is printed.\n  <a href=\"https://gist.github.com/sudhackar/ccd20ec5b412f8aae4fba651be8e8429\" rel=\"nofollow noreferrer\">\n   Full script here\n  </a>\n  which on running gives such output\n </p>\n <pre><code>$ python test-so.py Vasya_Pupkin\n0x11c0d0f090e0000\n$ python test-so.py ABCD        \n0x1171f0902111a00\n$ python test-so.py DEfg\n0x1150f070b1a0500\n</code></pre>\n</div>\n</body></html>",
            "votes": "2",
            "user": "sudhackar",
            "time": "Oct 9, 2017 at 8:20",
            "is_accepted": true,
            "comments": [
                {
                    "user": "yaspr",
                    "text": "<span class=\"comment-copy\">I agree, SAT Solvers are the mathematical way out. But, your examples aren't correct : login:ABCD has a magic number of 0xbf825114 and Password: 1171f0902111a00 has a magic number of 0x79660be7. No match!</span>",
                    "time": null
                },
                {
                    "user": "sudhackar",
                    "text": "<span class=\"comment-copy\">I think my assumptions might be flawed such as taking 64 bit passwords and operating only on the lower 56 bits, but once given the binary I can verify what I want and assume. I was just trying to give him some ways to try instead of giving a complete solution.</span>",
                    "time": null
                },
                {
                    "user": "Neilana",
                    "text": "<span class=\"comment-copy\">@sudhackar Wow, that worked! I've tried both of those examples in the crackme puzzle and it worked. Unfortunately I didn't have much time today to take a look on either SAT or Z3. So just for now I don't understand how it worked. I'll check it later and write back! Thank you for your answer.</span>",
                    "time": null
                },
                {
                    "user": "Neilana",
                    "text": "<span class=\"comment-copy\">@sudhackar Okay, I've just looked closer and now I can fully understand  what's going on in your script. I've also tested it on some other values and it works perfectly. Thanks, didn't know about existing of SAT solvers, will definitely keep that in mind. Now I have even harder crackme to solve (didn't look at it yet), I think I could apply my new knowledge there as well!</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  How about generating many logins from a password?\n </p>\n <p>\n  To start, algorithm 1 looks like the weakest link. Algorithm 2 is a one directional hash function and there's no way you can extract the characters by only knowing the magic number and the password bias. It involves some advanced math work and time. I explain the process of breaking Algorithm 2 in the second section.\n </p>\n <p>\n  Suppose :\n </p>\n <p>\n  <strong>\n   log_bias  = 0xfec0135a\n  </strong>\n </p>\n <p>\n  <strong>\n   pass_bias = 0xdeadbeef\n  </strong>\n </p>\n <p>\n  Let's look at algorithm 1:\n </p>\n <p>\n  1)\n  <strong>\n   log_chunk = 0xlogin(0)login(1)login(n - 2)login(n - 1);\n  </strong>\n </p>\n <p>\n  2)\n  <strong>\n   log_checksum = Sum(login, 0, n);\n  </strong>\n </p>\n <p>\n  3)\n  <strong>\n   log_magicnumber = log_chunk ^ log_checksum ^ log_bias;\n  </strong>\n </p>\n <p>\n  This algorithm shows two potential weaknesses. One, if you take the magic number and xor it with the\n  <strong>\n   log_bias\n  </strong>\n  constant you obtain :\n  <strong>\n   log_chunk ^ log_checksum\n  </strong>\n  .\nTwo,\n  <strong>\n   log_chunk\n  </strong>\n  is a concatenation in hex of the first two characters and the last two characters and it provides a frame for the login; therefore, we can generate our own characters and give that variable a value.\n </p>\n <p>\n  After getting rid of the bias and choosing a value for the chunk, we can obtain a value for\n  <strong>\n   log_checksum\n  </strong>\n  .\n </p>\n <p>\n  <strong>\n   log_checksum =  (log_magicnumber ^ log_bias) ^ log_chunk;\n  </strong>\n </p>\n <p>\n  What's left to do is to find a sequence of numbers representing characters which sum is the checksum.\n </p>\n <p>\n  How?\n </p>\n <p>\n  Well, if you look at the\n  <a href=\"http://www.asciichars.com/\" rel=\"nofollow noreferrer\">\n   ASCII\n  </a>\n  table you'll see that printable characters go from 33 to 126. If we generate a random value\n  <strong>\n   b\n  </strong>\n  between 33 and 126 and subtract it from the checksum we obtain a character value\n  <strong>\n   b\n  </strong>\n  and  reduce the checksum value by\n  <strong>\n   b\n  </strong>\n  :\n  <strong>\n   log_checksum -= b\n  </strong>\n  . Repeat this operation until checksum value goes below 126 and only store characters which\n  <strong>\n   diff = (log_checksum - b)\n  </strong>\n  is greater or equal than 33. This way, all characters will be printable.\n </p>\n <p>\n  After filling the middle of the login string it can be represented as follows :\n </p>\n <p>\n  <strong>\n   login\n  </strong>\n  =\n  <strong>\n   A B\n  </strong>\n  <strong>\n   b\n  </strong>\n  0\n  <strong>\n   b\n  </strong>\n  1\n  <strong>\n   b\n  </strong>\n  2 ...\n  <strong>\n   b\n  </strong>\n  j\n  <strong>\n   C D\n  </strong>\n </p>\n <p>\n  with A, B, C, D the characters we chose, and\n  <strong>\n   b\n  </strong>\n  i the characters generated from the checksum.\n </p>\n <p>\n  This reverse engineering approach is a cheap smart hack that targets the weakest hash function of the process and it will definitely work and save you time. From one password you'll obtain multiple logins : this is called a hash collision.\n </p>\n <p>\n  Here's an example output of this code:\n </p>\n <pre><code>Login: Vasya_Pupkin\nPassword: 011c0d0f090e00\nLogin    check : 0xa8a17eee\nPassword check : 0xa8a17eee\nCheck success :)\nValid login for pass_magicnumber 0xa8a17eee: Va[JiIUpHBI]in, length = 14\nValid login for pass_magicnumber 0xa8a17eee: VaU[^OnyD^fin, length = 13\nValid login for pass_magicnumber 0xa8a17eee: Va|IkH`y`i2in, length = 13\nValid login for pass_magicnumber 0xa8a17eee: VaTziSl^oK>in, length = 13\nValid login for pass_magicnumber 0xa8a17eee: VawNzAOGWktin, length = 13\nValid login for pass_magicnumber 0xa8a17eee: Vaeh]bmzbwin, length = 12\nValid login for pass_magicnumber 0xa8a17eee: VaugjXcNEvBin, length = 13\nValid login for pass_magicnumber 0xa8a17eee: VaJoMwQ{p[8in, length = 13\nValid login for pass_magicnumber 0xa8a17eee: VatBZwR`R|Ein, length = 13\nValid login for pass_magicnumber 0xa8a17eee: VaIy[lkZQbKin, length = 13\n</code></pre>\n <p>\n  All the listed valid logins will work for the password \"011c0d0f090e00\".\nIf you alter the password a bit, say : \"011c0d0f090efe\", here's what you get :\n </p>\n <pre><code>Login: VaNpNa^Twin \nPassword: 011c0d0f090efe\nLogin    check : 0xa8a17e10\nPassword check : 0xa8a17e10\nCheck success :)\nValid login for pass_magicnumber 0xa8a17e10: VaeOTUkOG8in, length = 12\nValid login for pass_magicnumber 0xa8a17e10: VaUDFEzBx>in, length = 12\nValid login for pass_magicnumber 0xa8a17e10: Va|gktoein, length = 10\nValid login for pass_magicnumber 0xa8a17e10: VaaPRTogiin, length = 11\nValid login for pass_magicnumber 0xa8a17e10: VaFEzBpktin, length = 11\nValid login for pass_magicnumber 0xa8a17e10: VafCCzmQrin, length = 11\nValid login for pass_magicnumber 0xa8a17e10: VaFDWMHSNC<in, length = 13\nValid login for pass_magicnumber 0xa8a17e10: VaSvoIgR\\in, length = 11\nValid login for pass_magicnumber 0xa8a17e10: Va[{eLdl?in, length = 11\nValid login for pass_magicnumber 0xa8a17e10: VaPaoDPXFDin, length = 12\n</code></pre>\n <hr/>\n <p>\n  Now, let's talk about generating passwords from a login magic number.\nYou'll have to attack this function :\n </p>\n <p>\n  <strong>\n   log_magicnumber = b ^ ((log_magicnumber << 5) + 1) ^ pass_bias\n  </strong>\n </p>\n <p>\n  If you look closely, you'll see that current\n  <strong>\n   log_magicnumber\n  </strong>\n  is computed using the previous\n  <strong>\n   log_magicnumber\n  </strong>\n  value transformed and mixed up with an unknown byte value and a known bias.\nIteratively, it looks like this:\n </p>\n <p>\n  <strong>\n   log_magicnumber(i) = b ^ ((log_magicnumber(i - 1) << 5) + 1) ^ pass_bias\n  </strong>\n </p>\n <p>\n  If we xor the\n  <strong>\n   pass_magicnumber\n  </strong>\n  and the\n  <strong>\n   pass_bias\n  </strong>\n  we're left with :\n </p>\n <p>\n  <strong>\n   b ^ ((log_magicnumber << 5) + 1)\n  </strong>\n </p>\n <p>\n  After generating all possible values of\n  <strong>\n   b\n  </strong>\n  (\n  <em>\n   0-9\n  </em>\n  and\n  <em>\n   a-f\n  </em>\n  , 16 possibilities total) and deriving the corresponding value of\n  <strong>\n   log_magicnumber\n  </strong>\n  for each possible value of\n  <strong>\n   b\n  </strong>\n  , we apply the same step on these magic number values to obtain another value & we go on 8 times (the password string being a 64 bit value = 8 bytes with a minimum length of 6 bytes). We discard the two left-most bytes if set to zero and pack all the bytes into a password string; we then verify with the password magic number algorithm if the password's magic number matches the login's.\n </p>\n <p>\n  This approach amounts to creating an 8 stage tree where each node has 16 children. This means that we'll have to generate 16 to the power of 8 characters : 16^8 = (2^4)^8 = 2^32 = 4.294.967.296 characters (4GB) and combine them in strings of 6 to 8 characters with each string being checked for validation. It was fun to code :)\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "yaspr",
            "time": "Oct 9, 2017 at 10:54",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Neilana",
                    "text": "<span class=\"comment-copy\">Very interesting idea about generating logins from a password! That definitely works. I've spend many hours with that puzzle trying to came up with any algorithm that would generate any valid pair login\\pass. But the thing you propose didn't came into mind. I like it :)  Yes, I thought about implementing something like what you describing in the 2nd section but realized that's a pretty bad idea :D    I mark question as solved and choose the sudhackar's answer as solution because it provides way to generate pass from login (not vise versa).</span>",
                    "time": null
                }
            ]
        }
    ]
}