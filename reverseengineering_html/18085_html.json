{
    "title": "Radare2 Find command line arguments and location in stack",
    "link": "https://reverseengineering.stackexchange.com/questions/18085/radare2-find-command-line-arguments-and-location-in-stack",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  This might have a simple solution but I can't find it anywhere.\n </p>\n <pre><code>$> ./be1 11 AAAAA\n</code></pre>\n <p>\n  With\n  <code>\n   gdb\n  </code>\n  , finding\n  <code>\n   argv[]\n  </code>\n  and\n  <code>\n   argc\n  </code>\n  is simple:\n </p>\n <pre><code>(gdb) print argv[0]@argc\n$7 = {0xbffff872 \"be1\", 0xbffff89a \"11\", 0xbffff89d \"AAAAA\"}\n</code></pre>\n <p>\n  But, how can we do this with radare2 ?\n </p>\n</div>\n</body></html>",
    "votes": "7",
    "answers": 2,
    "views": "2k",
    "tags": [
        "binary-analysis",
        "radare2"
    ],
    "user": "Corey",
    "time": "Apr 25, 2018 at 15:51",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  radare2 currently doesn't\n  <a href=\"https://radare.gitbooks.io/radare2book/content/basic_commands/flags.html\" rel=\"noreferrer\">\n   flags\n  </a>\n  <code>\n   argv\n  </code>\n  and\n  <code>\n   argc\n  </code>\n  . Yet, it shouldn't be something complicated to implement.\n </p>\n <p>\n  Although these arguments are not flagged by radare2, they can be easily be visible to us by inspecting the registers. Let's do it step by step.\n </p>\n <p>\n  Assume we have the following program:\n </p>\n <pre><code>$ cat example.c\n\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n\n   printf( \"argv[1]: %s\n\", argv[1]);\n\n   return 0;\n}\n</code></pre>\n <p>\n  All the program is doing is to print the first argument given to it. Simple as that.\n </p>\n <p>\n  Let's compile it in\n  <code>\n   gcc\n  </code>\n  and open it in debug-mode with\n  <code>\n   radare2\n  </code>\n  using the\n  <code>\n   -d\n  </code>\n  flag, and pass an argument to it:\n </p>\n <pre><code>$ gcc example.c -o example.elf\n$ r2 -d example.elf ABCDEFGH\nProcess with PID 104 started...\n= attach 104 104\nbin.baddr 0x00400000\nUsing 0x400000\nasm.bits 64\n -- Nothing to see here. Move along.\n[0x7f3c8f000c30]> \n</code></pre>\n <p>\n  Let's quickly analyze the program using\n  <code>\n   aa\n  </code>\n  :\n </p>\n <pre><code>[0x7f3c8f000c30]> aa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n</code></pre>\n <p>\n  Now, let's execute the program until we reach\n  <code>\n   main()\n  </code>\n  . We can do this by setting a breakpoint at\n  <code>\n   main\n  </code>\n  using\n  <code>\n   db main\n  </code>\n  and continue the execution until the program reaches the breakpoint using\n  <code>\n   dc\n  </code>\n  .\n  <strong>\n   Or\n  </strong>\n  , we can simply use\n  <code>\n   dcu [addr]\n  </code>\n  -- a very nice command that will continue the execution until a specific address.\n </p>\n <pre><code>[0x7f3c8f000c30]> dcu main\nContinue until 0x00400526 using 1 bpsize\nhit breakpoint at: 400526\n</code></pre>\n <p>\n  radare2 stopped the execution of the program at\n  <code>\n   main\n  </code>\n  . Great! Let's move on and print the function:\n </p>\n <pre><code>[0x00400526]> pdf\n            ;-- main:\n            ;-- rax:\n            ;-- rip:\n╭ (fcn) sym.main 51\n│   sym.main ();\n│           ; var int local_10h @ rbp-0x10\n│           ; var int local_4h @ rbp-0x4\n│           ; DATA XREF from 0x0040044d (entry0)\n│           0x00400526      55             push rbp\n│           0x00400527      4889e5         mov rbp, rsp\n│           0x0040052a      4883ec10       sub rsp, 0x10\n│           0x0040052e      897dfc         mov dword [local_4h], edi\n│           0x00400531      488975f0       mov qword [local_10h], rsi\n│           0x00400535      488b45f0       mov rax, qword [local_10h]\n│           0x00400539      4883c008       add rax, 8\n│           0x0040053d      488b00         mov rax, qword [rax]\n│           0x00400540      4889c6         mov rsi, rax\n│           0x00400543      bfe4054000     mov edi, str.argv_1_:__s    ; 0x4005e4 ; \"argv[1]: %s\n\"\n│           0x00400548      b800000000     mov eax, 0\n│           0x0040054d      e8aefeffff     call sym.imp.printf         ; int printf(const char *format)\n│           0x00400552      b800000000     mov eax, 0\n│           0x00400557      c9             leave\n╰           0x00400558      c3             ret\n</code></pre>\n <p>\n  As you may know, in a GCC compiled program, at\n  <code>\n   main\n  </code>\n  's entry,\n  <code>\n   edi\n  </code>\n  will hold\n  <code>\n   argc\n  </code>\n  and\n  <code>\n   rsi\n  </code>\n  (a pointer on the stack) will hold\n  <code>\n   argv\n  </code>\n  .\n </p>\n <p>\n  We can print their addresses like this:\n </p>\n <pre><code>[0x00400526]> dr rsi\n0x7ffff02302b8\n[0x00400526]> dr edi\n0x00000002\n</code></pre>\n <p>\n  So the value of\n  <code>\n   argc\n  </code>\n  (\n  <code>\n   edi\n  </code>\n  ) is\n  <code>\n   0x2\n  </code>\n  which is expected since the arguments are the file name and \"ABCDEFGH\". The address of the pointer\n  <code>\n   argv\n  </code>\n  (\n  <code>\n   rsi\n  </code>\n  ) is\n  <code>\n   0x7ffff02302b8\n  </code>\n  . In order to print the content of\n  <code>\n   * argv\n  </code>\n  (\n  <code>\n   rsi\n  </code>\n  ) we can simply use the following command:\n </p>\n <pre><code>[0x00400526]> psb @ [rsi]\n0x7ffff02304b7 ./example.elf\n0x7ffff02304c4 ABCDEFGH\n0x7ffff02304cd SHELL=/bin/bash\n0x7ffff02304dd TERM=xterm-256color\n0x7ffff02304f1 OLDPWD=<truncated>\n0x7ffff023050e USER=beet\n0x7ffff0230518 NAME=<truncated>\n</code></pre>\n <p>\n  <code>\n   psb\n  </code>\n  is used to\n  <strong>\n   p\n  </strong>\n  rint\n  <strong>\n   s\n  </strong>\n  trings in the current\n  <strong>\n   b\n  </strong>\n  lock. Since at this point we know that\n  <code>\n   argc\n  </code>\n  equals 2, we can ignore anything that is beneath the second line of the output.\n </p>\n <p>\n  radare2 also offers you a register telescoping using\n  <code>\n   drr\n  </code>\n  . This way you can easily see where\n  <code>\n   rsi\n  </code>\n  is pointing to:\n </p>\n <pre><code>[0x00400526]> drr~rsi\n   rsi 0x00007ffff1a56ab8  rsi stack R W 0x7ffff1a56cb7 -->  stack R W 0x6c706d6178652f2e (./example.elf) -->  ascii\n</code></pre>\n <p>\n  As you can see,\n  <code>\n   rsi\n  </code>\n  value is\n  <code>\n   0x7ffff1a56ab8\n  </code>\n  which is pointing to an address on the stack (\n  <code>\n   0x7ffff1a56cb7\n  </code>\n  ) that contains an ascii string \"./example.elf\".\n  \n\n  <em>\n   <code>\n    ~\n   </code>\n   is radare's internal grep\n  </em>\n  .\n </p>\n <p>\n  Please consider open an\n  <a href=\"https://github.com/radare/radare2/issues/new\" rel=\"noreferrer\">\n   issue\n  </a>\n  to ask for this feature, or even better, implement it and send a pull-request.\n </p>\n</div>\n</body></html>",
            "votes": "7",
            "user": "Megabeets",
            "time": "Apr 25, 2018 at 7:32",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Corey",
                    "text": "<span class=\"comment-copy\">Wow, thanks this is everything I wanted and much much more. Thanks again!</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  the info command holds all the args passed to radare2  and you can use the internal grep too to find it\n </p>\n <pre><code>:\\>radare2 -Q -c \"i~ref\" -d cmdlnargs.exe firstarg secarg thirdarg\nSpawned new process with pid 6032, tid = 3196\nr_sys_pid_to_path: Cannot get module filename.= attach 6032 3196\nbin.baddr 0x01330000\nUsing 0x1330000\nSpawned new process with pid 872, tid = 2512\nr_sys_pid_to_path: Cannot get module filename.asm.bits 32\nreferer  dbg://cmdlnargs.exe firstarg secarg thirdarg\n</code></pre>\n <p>\n  the same command performed inside radare instead of shell\n </p>\n <pre><code>:\\>radare2 -d cmdlnargs.exe firstarg secarg thirdarg\nSpawned new process with pid 5356, tid = 2704\nr_sys_pid_to_path: Cannot get module filename.= attach 5356 2704\nbin.baddr 0x01330000\nUsing 0x1330000\nSpawned new process with pid 5296, tid = 6036\nr_sys_pid_to_path: Cannot get module filename.asm.bits 32\n -- Are you still there?\n[0x779d70d8]> i~ref\nreferer  dbg://cmdlnargs.exe firstarg secarg thirdarg\n[0x779d70d8]> q\nDo you want to quit? (Y/n) y\nDo you want to kill the process? (Y/n) y\n\n:\\>\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "blabb",
            "time": "Apr 25, 2018 at 21:33",
            "is_accepted": false,
            "comments": []
        }
    ]
}