{
    "title": "Why dependency walker indentifies an app as Borland Delphi 4 while IDR says Delphi 2011",
    "link": "https://reverseengineering.stackexchange.com/questions/10835/why-dependency-walker-indentifies-an-app-as-borland-delphi-4-while-idr-says-delp",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I opened an app in Dependency Walker and noticed that the app was made in Borland Delphi 4 to improve my reversing techniques I fired up DeDe, it's sticks and respond after hours with error \"out of memory\"\n </p>\n <p>\n  Then I used Interactive Delphi Reconstructor to see if Delphi is really hard to Reverse but I notced that it was in Delphi XE1\n </p>\n <p>\n  How can an app be made in two different versions (Delphi 4 and Delphi 2011)?\nOr  the Dependency walker lied?\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 0,
    "views": "216",
    "tags": [
        "decompilation",
        "delphi"
    ],
    "user": "Alex",
    "time": "Sep 11, 2015 at 16:25",
    "comments": [
        {
            "user": "0xec",
            "text": "<html><body><span class=\"comment-copy\">\n Generally, the output from IDR can be better relied upon, as it is dedicated to reversing Delphi apps.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "peter ferrie",
            "text": "<html><body><span class=\"comment-copy\">\n Dependency Walker might not be aware of Delphi 2011 because it might be checking, for example, only DLL component names, whereas IDR might know about compiler signatures, and differentiate that way.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": []
}