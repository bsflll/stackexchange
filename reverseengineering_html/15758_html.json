{
    "title": "Could not find ld-linux-x86-64.so.2 in strace output",
    "link": "https://reverseengineering.stackexchange.com/questions/15758/could-not-find-ld-linux-x86-64-so-2-in-strace-output",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I did a ldd on /bin/cat and I see that dynamic loader library /lib64/ld-linux-x86-64.so.2 is a part of it.\n </p>\n <pre><code>ldd /bin/cat\n    linux-vdso.so.1 (0x00007ffe743f4000)\n    libc.so.6 => /lib64/libc.so.6 (0x00007fde4f0a1000)\n    /lib64/ld-linux-x86-64.so.2 (0x000056057639c000)\n</code></pre>\n <p>\n  However my problem started when I performed an strace over this binary (\n  <strong>\n   strace -o cat.trace /usr/bin/ls /etc/motd\n  </strong>\n  ) and could not find it being loaded. I was assuming that it should be the first one to be loaded by kernel.\n </p>\n <pre><code>execve(\"/usr/bin/ls\", [\"/usr/bin/ls\", \"/etc/motd\"], 0x7ffe9e6a8d38 /* 56 vars */) = 0\nbrk(NULL)                               = 0x5650331a2000\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f39527b9000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=95294, ...}) = 0\nmmap(NULL, 95294, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f39527a1000\nclose(3)                                = 0\nopen(\"/lib64/libselinux.so.1\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0000c\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=153176, ...}) = 0\nmmap(NULL, 2253688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f3952370000\nmprotect(0x7f3952393000, 2097152, PROT_NONE) = 0\nmmap(0x7f3952593000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x23000) = 0x7f3952593000\nmmap(0x7f3952595000, 4984, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f3952595000\nclose(3)                                = 0\nopen(\"/lib64/libcap.so.2\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0P\\25\\0\\0\\0\\0\\0\\0\"..., 832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=18608, ...}) = 0\nmmap(NULL, 2113840, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f395216b000\nmprotect(0x7f395216f000, 2093056, PROT_NONE) = 0\nmmap(0x7f395236e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x3000) = 0x7f395236e000\nclose(3)                                = 0\nopen(\"/lib64/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0P\\10\\2\\0\\0\\0\\0\\0\"..., 832) = 832\n</code></pre>\n <p>\n  As can be seen from ldd output, a supplementary question here is - how could ldd predict the load address of a dynamically linked/loaded library before loading of library? In theory as I studied, the memory is a shared resource and then multiple libraries should be able to be loaded at same memory locations (not simultaneously though).\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "1k",
    "tags": [
        "binary-analysis",
        "dynamic-analysis",
        "dynamic-linking"
    ],
    "user": "ultimate cause",
    "time": "Jul 4, 2017 at 19:10",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  A very similar question to this can be found on stackoverflow:\n  <a href=\"https://stackoverflow.com/questions/26876247/how-does-execve-call-dynamic-linker-loader-ld-linux-so-2\">\n   How does execve call dynamic linker/loader (ld-linux.so.2)\n  </a>\n </p>\n <p>\n  The reason there is no\n  <code>\n   strace\n  </code>\n  output associated with the dynamic linker is that control is passed to the dynamic linker during process creation by the kernel. In other words, the dynamic linker is not invoked from userspace via a system call. No system call means no\n  <code>\n   strace\n  </code>\n  output.\n </p>\n <p>\n  From the generic SYSV ABI, Chapter 5: \"Program Loading and Dynamic Linking\"::\n </p>\n <blockquote>\n  <p>\n   An executable file that participates in dynamic linking shall have one\n   <code>\n    PT_INTERP\n   </code>\n   program header element. During the function\n   <code>\n    exec\n   </code>\n   , the system retrieves a path name from the\n   <code>\n    PT_INTERP\n   </code>\n   segment and creates the initial process image from the interpreter file’s segments. That is, instead of using the original executable file’s segment images, the system composes a memory image for the interpreter. It then is the interpreter’s responsibility to receive control from the system and provide an environment for the application program.\n  </p>\n  <p>\n   As ‘‘Process Initialization’’ in Chapter 3 of the processor supplement mentions, the interpreter receives control in one of two ways. First, it may receive a file descriptor to read the executable file, positioned at the beginning. It can use this file descriptor to read and/or map the executable file’s segments into memory. Second, depending on the executable file format, the system may load the executable file into memory instead of giving the interpreter an open file descriptor.\n  With the possible exception of the file descriptor, the interpreter’s initial process state matches what the executable file would have received. The interpreter itself may not require a second interpreter. An interpreter may be either a shared object or an executable file.\n  </p>\n </blockquote>\n <p>\n  The term \"system\" used above refers to the kernel.\n </p>\n <pre><code>$ readelf -l /bin/cat\n\nElf file type is EXEC (Executable file)\nEntry point 0x402602\nThere are 9 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040\n                 0x00000000000001f8 0x00000000000001f8  R E    8\n  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238\n                 0x000000000000001c 0x000000000000001c  R      1\n      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\n</code></pre>\n <p>\n  It is significant that\n  <code>\n   INTERP\n  </code>\n  is a program header, as program headers are used by the kernel when mapping the binary into memory to create a running process. It can be inferred that the presence of the pathname of the dynamic linker in a program header has implications for process creation by the kernel.\n </p>\n <blockquote>\n  <p>\n   When building an executable file that uses dynamic linking, the link editor adds a program header element of type\n   <code>\n    PT _ INTERP\n   </code>\n   to an executable file, telling the system to invoke the dynamic linker as the program interpreter.\n  </p>\n  <p>\n   <code>\n    exec\n   </code>\n   and the dynamic linker cooperate to create the process image for the program, which entails the following actions:\n  </p>\n  <ul>\n   <li>\n    Adding the executable file’s memory segments to the process image;\n   </li>\n   <li>\n    Adding shared object memory segments to the process image;\n   </li>\n   <li>\n    Performing relocations for the executable file and its shared objects;\n   </li>\n   <li>\n    Closing the file descriptor that was used to read the executable file, if one was given to the dynamic linker;\n   </li>\n   <li>\n    Transferring control to the program, making it look as if the program had received control directly from the function\n    <code>\n     exec\n    </code>\n   </li>\n  </ul>\n </blockquote>\n <hr/>\n <p>\n  <em>\n   Response to comment\n  </em>\n  :\n </p>\n <blockquote>\n  <p>\n   I tried the same stuff on NetBSD machine and there I see the mapping of ld.so as the first step. So this should essentially means that this is implementation dependent whether we will see the dynamic linker in strace or not. Right?\n  </p>\n </blockquote>\n <p>\n  Wrong, at least according to the\n  <a href=\"http://www.netbsd.org/docs/internals/en/chap-processes.html#process_startup\" rel=\"nofollow noreferrer\">\n   NetBSD process startup documentation\n  </a>\n  :\n </p>\n <blockquote>\n  <p>\n   Note that when starting a dynamic ELF executable, the ELF loader (also known as the interpreter:\n   <code>\n    /usr/libexec/ld.elf_so\n   </code>\n   ) is loaded with the executable by the kernel. The ELF loader is started by the kernel and is responsible for starting the executable itself afterwards.\n  </p>\n </blockquote>\n <p>\n  For a better answer, you will have to ask a separate question about this specifically, and with the\n  <code>\n   strace\n  </code>\n  output included.\n </p>\n <blockquote>\n  <p>\n   how does\n   <code>\n    ldd\n   </code>\n   mentions the base address of a library even without loading it?\n  </p>\n </blockquote>\n <p>\n  <code>\n   ldd\n  </code>\n  calls the dynamic linker, which loads a dynamically-linked program's dynamic dependencies. From the\n  <code>\n   ldd\n  </code>\n  man page:\n </p>\n <blockquote>\n  <p>\n   In the usual case,\n   <code>\n    ldd\n   </code>\n   invokes the standard dynamic linker (see\n   <code>\n    ld.so(8)\n   </code>\n   ) with the\n   <code>\n    LD_TRACE_LOADED_OBJECTS\n   </code>\n   environment variable set to 1. This causes the dynamic linker to inspect the program's dynamic dependencies, and find (according to the rules described in\n   <code>\n    ld.so(8)\n   </code>\n   ) and load the objects that satisfy those dependencies. For each dependency,\n   <code>\n    ldd\n   </code>\n   displays the location of the matching object and the (hexadecimal) address at which it is loaded.  (The\n   <code>\n    linux-vdso\n   </code>\n   and\n   <code>\n    ld-linux\n   </code>\n   shared dependencies are special; see\n   <code>\n    vdso(7)\n   </code>\n   and\n   <code>\n    ld.so(8)\n   </code>\n   .)\n  </p>\n </blockquote>\n <p>\n  In some cases\n  <code>\n   ldd\n  </code>\n  will even execute the binary:\n </p>\n <blockquote>\n  <p>\n   Be aware that in some circumstances (e.g., where the program specifies an ELF interpreter other than ld-linux.so), some versions of\n   <code>\n    ldd\n   </code>\n   may attempt to obtain the dependency information by attempting to directly execute the program (which may lead to the execution of whatever code is defined in the program's ELF interpreter, and perhaps to execution of the program itself).  Thus, you should never employ ldd on an untrusted executable, since this may result in the execution of arbitrary code.\n  </p>\n </blockquote>\n <p>\n  <code>\n   ldd\n  </code>\n  does indeed result in a program's dynamic dependencies being loaded into virtual memory.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "julian",
            "time": "Jul 5, 2017 at 14:04",
            "is_accepted": false,
            "comments": [
                {
                    "user": "ultimate cause",
                    "text": "<span class=\"comment-copy\">This makes sense. Thanks. A followup question is - I tried the same stuff on NetBSD machine and there I see the mapping of ld.so as the first step. So this should essentially means that this is implementation dependent whether we will see the dynamic linker in strace or not. Right? A second part of my question is - how does ldd mentions the base address of a library even without loading it? Please read last part of my question.</span>",
                    "time": null
                },
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">@RIPUNJAYTRIPATHI A response to your comment has been added</span>",
                    "time": null
                },
                {
                    "user": "ultimate cause",
                    "text": "<span class=\"comment-copy\">thanks  for your effort. I was under assumption  that ldd does not executes or loads the binaries. However regarding NetBSD, I did an strace on version 7.1 and I  see that ld.so was  mmap'ed  as  first  step. Let me know if I could send you my strace proof  as personal message.</span>",
                    "time": null
                }
            ]
        }
    ]
}