{
    "title": "Automating pattern-based de-obfuscation of x64 code using IDA plugins",
    "link": "https://reverseengineering.stackexchange.com/questions/13068/automating-pattern-based-de-obfuscation-of-x64-code-using-ida-plugins",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Trying to deobfuscate x64 code. You can skim/skip most of this, since it mainly exists to prove I have tried and exhausted all avenues.\n </p>\n <h1>\n  Burning Purpose\n </h1>\n <p>\n  To massively automate the deobfuscation within a [memory dump] of a 64-bit Windows game.\n </p>\n <h1>\n  Methods currently in use\n </h1>\n <h2>\n  PCRE driven byte replacement\n </h2>\n <h3>\n  Works fine with simple obsfucation like Variant 1 & 2\n </h3>\n <p>\n  Original (Variant 1):\n </p>\n <pre><code>48 8D 64 24 F8        - lea rsp,[rsp-08]         ; Stack -= 8\n48 89 2C 24           - mov [rsp],rbp            ; Push RBP\n48 8D 2D 156A5A00     - lea rbp,[7FF749022784]   ; Put JMP target in RSP\n48 87 2C 24           - xchg [rsp],rbp           ; Pop RBP (RBP restored)\n48 8D 64 24 08        - lea rsp,[rsp+08]         ; Stack += 8 (Balanced)\nFF 64 24 F8           - jmp qword ptr [rsp-08]   ; JMP (target)\n</code></pre>\n <p>\n  Original (Variant 2):\n </p>\n <pre><code>48 89 6c 24 f8         - mov [rsp-0x8], rbp\n48 8d 64 24 f8         - lea rsp, [rsp-0x8]\n(rest as per Variant 1)\n</code></pre>\n <p>\n  Deobsfucated:\n </p>\n <pre><code>90 90 90 .. ..        - (Variant 1: NOP * 9, Variant 2: NOP * 10)\n90 90                   NOP * 2   ; Pad instruction to preserve\n                                  ; RIP of next instruction\nE9 ?? ?? ?? ??        - JMP NEAR \n90 90 90 .. ..        - NOP * 13\n</code></pre>\n <p>\n  De-obfuscation script:\n </p>\n <pre><code>#!/usr/bin/env sh\n#            |------------- 11 bytes--------| |-- 5 bytes--| |---------------- - 13 bytes---------|     \n# Signature: 48 8D 64 24 F8 48 89 2C 24 48 8D 2D ?? ?? ?? ?? 48 87 2C 24 48 8D 64 24 08 FF 64 24 F8 (29 bytes)\n# Translate: 90 90 90 90 90 90 90 90 90 90 90 E9 ?? ?? ?? ?? 90 90 90 90 90 90 90 90 90 90 90 90 90\n#    \n#            |------------- 12 bytes ----------| |-- 5 bytes--| |---------------- - 13 bytes---------|\n# Signature: 48 89 6c 24 f8 48 8d 64 24 f8 48 8d 2d ?? ?? ?? ?? 48 87 2c 24 48 8d 64 24 08 ff 64 24 f8 (30 bytes)\n# Translate: 90 90 90 90 90 90 90 90 90 90 90 90 e9 ?? ?? ?? ?? 90 90 90 90 90 90 90 90 90 90 90 90 90\n\nxxd -ps Game_Dumped.exe | \n    sed -e 's/\\(..\\)/\\1 /g' | \n    tr '\n' ' '             |\n    perl -p -e \"s/48 8d 64 24 f8 48 \\\n89 2c 24 48 8d 2d (.. .. .. ..) \\\n48 87 2c 24 48 8d 64 24 08 ff 64 24 f8/90 90 90 90 90 \\\n90 90 90 90 90 90 e9 \\1 90 90 90 90 90 90 90 90 90 90 \\\n90 90 90/g ; s/48 89 6c 24 f8 48 8d 64 24 f8 48 8d 2d\\\n (.. .. .. ..) 48 87 2c 24 48 8d 64 24 08 ff 64 24 \\\nf8/90 90 90 90 90 90 90 90 90 90 90 90 e9 \\1 90 90 90 \\\n90 90 90 90 90 90 90 90 90 90/g\" |\n    xxd -r -ps > Game_Dumped_NOP2.exe\n</code></pre>\n <h3>\n  The 3rd variety\n </h3>\n <pre><code>143fe7a26 48 89 6c 24 f8         mov     [rsp-8], rbp\n143fe7a2b 48 8d 64 24 f8         lea     rsp, [rsp-8]\n143fe7a30 e9 60 71 8d ff         jmp     loc_1438beb95\n\n1438beb95 48 8d 2d 10 b0 3a fd   lea     rbp, sub_jump_target\n1438beb9c 48 87 2c 24            xchg    rbp, [rsp]\n1438beba0 48 8d 64 24 08         lea     rsp, [rsp+8]\n1438beba5 ff 64 24 f8            jmp     qword ptr [rsp-8]\n</code></pre>\n <p>\n  This is the same as the Variant 2, except it has been broken into two sections. Planned solution will involve distorm3's flow control flags, and rewriting\n  <code>\n   jmp\n  </code>\n  to\n  <code>\n   0x143fe7a26\n  </code>\n  .\n </p>\n <h3>\n  Variations on stack manipulation\n </h3>\n <pre><code>48 89 E0             mov     rax, rsp\n48 05 F8 FF FF FF    add     rax, 0FFFFFFFFFFFFFFF8h ; Add\n48 89 C4             mov     rsp, rax\n48 89 1C 24          mov     [rsp], rbx\n</code></pre>\n <p>\n  What a horrifically long way to effect to decrement\n  <code>\n   RSP\n  </code>\n  by 8.  But by now, I am fairly used to it, and it wouldn't bother me, but I have just enabled the \"Stack Pointer\" in IDA [6.8]'s General Options, and realising that IDA isn't including\n  <code>\n   lea rsp, [rsp+-8]\n  </code>\n  in it's calculations of the stack pointer, which is stopping it properly analysing the code.\n </p>\n <pre><code>RSP Bytes               Disassembly\n--- ------------------- -------------------------------\n000 48 89 E0            mov     rax, rsp\n000 48 05 F8 FF FF FF   add     rax, 0FFFFFFFFFFFFFFF8h\n000 48 89 C4            mov     rsp, rax ; It tracked this\n-20 48 89 1C 24         mov     [rsp], rbx\n-20 48 83 EC 20         sub     rsp, 20h ; and this\n000 48 8B 41 10         mov     rax, [rcx+10h]\n000 48 89 4C 24 F8      mov     [rsp-8], rcx\n000 48 8D 64 24 F8      lea     rsp, [rsp-8] ; but not this\n000 48 8B 1C 24         mov     rbx, [rsp]\n</code></pre>\n <p>\n  I am also starting to suspect that there are going to be many permutations of all these techniques, and I need to start addressing the problem in IDA.\n </p>\n <p>\n  The problem is, the\n  <strong>\n   only\n  </strong>\n  sample source I can find uses IDAPython\n  <em>\n   idaapi\n  </em>\n  low-level functions, so the code is ridiculously long, and as I am replacing a 5 byte instruction with a 4 byte one, I cannot find a way to alter the operand I have inadvertently created.  (Fortunately, in this case, it's just CLC).\n </p>\n <p>\n  <strong>\n   Update: I have fixed this issue, and the solution has drastically reduced the size of my script.  The pertinent fix is below:\n  </strong>\n </p>\n <pre><code>def replace_pattern(ea):\n    search = [0x48, 0x8d, 0x64, 0x24, 0xf8]\n    replace = [0x48, 0x83, 0xec, 0x08, 0x90]\n    current = []\n    for i in xrange(5):\n        current.append(idaapi.get_byte(ea+i))\n    if 0 == cmp(search, current):\n        for i in xrange(5):\n            # fixed: replace put_byte with patch_byte\n            idaapi.patch_byte(ea+i, replace[i])\n        return 1\n    return 0\n</code></pre>\n <p>\n  [original code] Incidentally, the example code was written by our own\n  <a href=\"https://reverseengineering.stackexchange.com/users/182/rolf-rolles\">\n   Rolf Rolles\n  </a>\n </p>\n <pre><code>import idaapi\nimport idc\n\n# Planned task: replace\n#     48 8d 64 24 f8          lea    rsp,[rsp-0x8]\n# with\n#     48 83 ec 08             sub    rsp,0x8\n#     90                      nop\n#\n# Actual result:\n# Replaced:  48 8d 64 24 f8   lea    rsp,[rsp-0x8]\n# with:   :  48 83 ec 08      sub    rsp,0x8\n#            f8               clc\n#\n# Verdict, close enough, but way too much code involved.\n\ndef match_pattern(ea):\n    search = [0x48, 0x8d, 0x64, 0x24, 0xf8]\n    replace = [0x48, 0x83, 0xec, 0x08, 0x90]\n    current = []\n    for i in xrange(5):\n        current.append(idaapi.get_byte(ea+i))\n    if 0 == cmp(search, current):\n        return 1\n    return 0\n\n    # Note: I thought I might be able to simply rewrite\n    #       at a byte level, but it threw an exception.\n    #\n    #    for i in xrange(4):\n    #        idaapi.put_byte(ea+i, replace[i])\n\nclass deobfu_hook(idaapi.IDP_Hooks):\n    def __init__(self):\n        idaapi.IDP_Hooks.__init__(self)\n        self.n = idaapi.netnode(\"$ X86 Deobfuscator Modifications\",0,1)\n\n    def custom_ana(self):\n        # Check first two bytes \"by hand\" for speed\n        b = idaapi.get_byte(idaapi.cmd.ea)\n        if b == 0x48: # First byte\n            b = idaapi.get_byte(idaapi.cmd.ea+1)\n            if b == 0x8d: # Second byte\n                # Discard speed, do a full match\n                if match_pattern(idaapi.cmd.ea, 0, 0):\n                    # If matched, supply all required values for \n                    # SUB RSP,8 - Surely there is an easier way!\n                    idaapi.cmd.itype = 0xd1\n                    idaapi.cmd.size = 4\n                    idaapi.cmd.auxpref = 0x1810\n                    idaapi.cmd.segpref = 0\n                    idaapi.cmd.insnpref = 0x48\n                    idaapi.cmd.flags = 2\n\n                    idaapi.cmd.Op1.type = 1\n                    idaapi.cmd.Op1.offb = 0\n                    idaapi.cmd.Op1.offo = 0\n                    idaapi.cmd.Op1.flags = 8\n                    idaapi.cmd.Op1.dtyp = 7\n                    idaapi.cmd.Op1.reg = 4\n                    idaapi.cmd.Op1.phrase = 4\n                    idaapi.cmd.Op1.value = 0\n                    idaapi.cmd.Op1.addr = 0\n                    idaapi.cmd.Op1.specval = 0\n                    idaapi.cmd.Op1.specflag1 = 0\n                    idaapi.cmd.Op1.specflag2 = 0\n                    idaapi.cmd.Op1.specflag3 = 0\n                    idaapi.cmd.Op1.specflag4 = 0\n\n                    idaapi.cmd.Op2.type = 5\n                    idaapi.cmd.Op2.offb = 3\n                    idaapi.cmd.Op2.offo = 0\n                    idaapi.cmd.Op2.flags = 8\n                    idaapi.cmd.Op2.dtyp = 7\n                    idaapi.cmd.Op2.reg = 0\n                    idaapi.cmd.Op2.phrase = 0\n                    idaapi.cmd.Op2.value = 8\n                    idaapi.cmd.Op2.addr = 0\n                    idaapi.cmd.Op2.specval = 0\n                    idaapi.cmd.Op2.specflag1 = 0\n                    idaapi.cmd.Op2.specflag2 = 0\n                    idaapi.cmd.Op2.specflag3 = 0\n                    idaapi.cmd.Op2.specflag4 = 0\n\n                    return True\n        return False\n\nclass deobfu_t(idaapi.plugin_t):\n    flags = idaapi.PLUGIN_PROC | idaapi.PLUGIN_HIDE\n    comment = \"Deobfuscator\"\n    wanted_hotkey = \"\"\n    help = \"Runs transparently\"\n    wanted_name = \"deobx86\"\n    hook = None\n\n    def init(self):\n        self.hook = None\n\n        self.hook = deobfu_hook()\n        self.hook.hook()\n        print(\"deobfu init\")\n        return idaapi.PLUGIN_KEEP\n\n    def run(self, arg):\n        pass\n\n    def term(self):\n        print(\"deobfu term\")\n        if self.hook:\n            self.hook.unhook()\n\ndef PLUGIN_ENTRY():\n    print(\"PLUGIN_ENTRY:deobfu\")\n    return deobfu_t()\n</code></pre>\n <h3>\n  Where do you want to go today?\n </h3>\n <p>\n  I want a better solution, and I am not afraid to code it.  I am how-ever in need of some starting advice, plus I need to make sure I am not re-coding the wheel here.\n </p>\n <p>\n  I have since written some other IDAPython code using the higher level\n  <strong>\n   idautils\n  </strong>\n  to create call trees, and collate xrefs and such. But I don't know how to rewrite the actual disassembled code at that level.  There is one example in the IDAPython repo:\n  <a href=\"https://github.com/pfalcon/idapython/blob/master/examples/ex_idphook_asm.py\" rel=\"nofollow noreferrer\">\n   https://github.com/pfalcon/idapython/blob/master/examples/ex_idphook_asm.py\n  </a>\n  but that's\n </p>\n <ol>\n  <li>\n   Full of silly bugs (I fixed them)\n  </li>\n  <li>\n   Hooks the Assembly command, not the disassembly process\n  </li>\n </ol>\n <p>\n  I have reviewed the answer to a similar question at\n  <a href=\"https://reverseengineering.stackexchange.com/questions/1899/creating-ida-pro-debugger-plugins-api-documentation-and-examples\">\n   Creating IDA Pro debugger plugins - API documentation and examples?\n  </a>\n  .  I have looked at various examples of quite nice IDAPython code that can:\n </p>\n <ul>\n  <li>\n   <a href=\"http://researchcenter.paloaltonetworks.com/2015/12/using-idapython-to-make-your-life-easier-part-2/\" rel=\"nofollow noreferrer\">\n    Add comments while disassembling\n   </a>\n  </li>\n  <li>\n   <a href=\"http://researchcenter.paloaltonetworks.com/2016/01/using-idapython-to-make-your-life-easier-part-4/\" rel=\"nofollow noreferrer\">\n    Change the line color while disassembling\n   </a>\n  </li>\n </ul>\n <p>\n  But, I have seen nothing about actually changing instructions.\n </p>\n <p>\n  I have not purchased\n  <a href=\"http://rads.stackoverflow.com/amzn/click/1593272898\" rel=\"nofollow noreferrer\">\n   The IDA Pro Book\n  </a>\n  because I do not live in the U.S. and I do not want to wait\n  <strong>\n   <em>\n    n\n   </em>\n  </strong>\n  weeks for on-demand printing and delivery. I am not adverse to writing an\n  <code>\n   .idc\n  </code>\n  , as I'm quite familiar with C (more-so that with Python), although I suspect despite the shallower learning curve (and assumedly ready examples) it would be harder (long term) than using higher level IDAPython code.  (I'm learning Python as I go, but .. well, didn't we all?)\n </p>\n <p>\n  Because the code I am working with is exclusively 64-bit, there is little (basically no) pre-existing deobfu samples or code out there.\n </p>\n <p>\n  And so here I find myself, asking for your patient guidance.  (Very patient if you actually read all of that).\n </p>\n <p>\n  <em>\n   PS: I took the time to document everything I had done, because I know how little respect we all have for people who don't even attempt something before hollering for help.\n  </em>\n </p>\n <p>\n  <em>\n   PPS:\n   <strong>\n    OMG\n   </strong>\n   2nd most avid member of RE is Igor Skochinsky, I can only bow in humility\n  </em>\n  .\n </p>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 2,
    "views": "2k",
    "tags": [
        "ida",
        "windows",
        "idapython",
        "deobfuscation",
        "x86-64"
    ],
    "user": "Orwellophile",
    "time": "Apr 13, 2017 at 12:49",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<html><body><span class=\"comment-copy\">\n You can by the ebook directly\n <a href=\"https://www.nostarch.com/idapro2.htm\" rel=\"nofollow noreferrer\">\n  from No Starch\n </a>\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Igor Skochinsky",
            "text": "<html><body><span class=\"comment-copy\">\n I don't have time to write complete answer but check\n <a href=\"http://www.msreverseengineering.com/blog/2015/6/29/transparent-deobfuscation-with-ida-processor-module-extensions\" rel=\"nofollow noreferrer\">\n  this post\n </a>\n by Rolf\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Orwellophile",
            "text": "<html><body><span class=\"comment-copy\">\n @IgorSkochinsky\n <b>\n  disregard previous comment\n </b>\n - fixed my issue with Rolf's code (question updated), I needed to use\n <code>\n  patch_byte\n </code>\n instead of\n <code>\n  put_byte\n </code>\n .\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Orwellophile",
            "text": "<html><body><span class=\"comment-copy\">\n @IgorSkochinsky I have come to understand that Rolf's code does something quite different to what I thought it did, namely that it alters the instruction displayed/interpreted by IDA without actually changing the underlying bytes.  This is a very useful (and advanced) tool, but I am left again with the question of how to handle the extra instruction left over when the replacement instruction is shorter.  Is there a way to handle this in the current instance of the callback, or is it necessary to set a global/static variable and catch it on the next call?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "mrexodia",
            "text": "<html><body><span class=\"comment-copy\">\n I wrote some C++ for exactly this purpose... Some more details on the \"InterObfu\" section:\n <a href=\"http://x64dbg.com/blog/2016/10/30/weekly-digest-10.html\" rel=\"nofollow noreferrer\">\n  x64dbg.com/blog/2016/10/30/weekly-digest-10.html\n </a>\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  There are two scenarios to be distinguished, which you (implicitly) mention as well:\n </p>\n <p>\n  I. Obfuscated pattern with no jmps in between interrupting the control flow,\n </p>\n <p>\n  II. Obfuscated pattern with interrupting jmps.\n </p>\n <p>\n  Definitely there are several possibilities to remove the obfuscation. I will try to describe one of them which I (partly) applied.\n </p>\n <p>\n  <strong>\n   Scenario I\n  </strong>\n  is straightforward (and with that one I made some successful tries and wrote a program for it):\n </p>\n <ol>\n  <li>\n   <p>\n    Identify the pattern \"by hand\", write down the bytecode sequence, and write down the - simpler - bytecode replacement.\n   </p>\n  </li>\n  <li>\n   <p>\n    Read the binary into the own programmed \"remove obfuscation\" application.\n   </p>\n  </li>\n  <li>\n   <p>\n    Let the program search for all occurences of the obfuscation bytecode.\n   </p>\n  </li>\n  <li>\n   <p>\n    Let the program replace all found occurrences with the (hopefully simpler) replacement. You might gain a lot of space for possible patches.\n   </p>\n  </li>\n  <li>\n   <p>\n    Very important: Test the modified (i.e. simplified) program\n   </p>\n  </li>\n </ol>\n <p>\n  <strong>\n   Scenario II\n  </strong>\n  is the more difficult part, as the breaks can show up anywhere and no unique bytecode sequence is possible any more for an obfuscation pattern. I would probably proceed in the following way, however not having tried it yet:\n </p>\n <ol>\n  <li>\n   <p>\n    Independent from obfuscation, find a solution to remove the \"breaks\" in the code, i.e. try to remove the usually many, many useless jmp statements. In case you can solve this, it has the big additional advantage that the code is not broken any more in Ida by the jmps. Maybe there exist already some automated solutions, although presently not known to me.\n   </p>\n  </li>\n  <li>\n   <p>\n    Apply Scenario I\n   </p>\n  </li>\n </ol>\n <p>\n  As to my experience, the Scenario I is the lesser frequent case, although having been encountered as well. The following - real - obfuscated x64 code sequence demonstrates the importance of removing the \"code breaks\". In this sequence there are no less than six breaks where the program each time jmps between addresses separated far distant from each other.\n </p>\n <pre><code>    loc_startObfuscatedSequence:                        \n                    lea     rsp, [rsp-8]\n                    mov     [rsp], rbp\n                    mov     rbp, offset loc_target1\n                    xchg    rbp, [rsp]    \n                    mov     [rsp-8], rcx\n                    jmp     loc_break1  \n\n    loc_break1:     lea     rsp, [rsp-8]\n                    jmp     loc_break2\n\n    loc_break2:     mov     [rsp-8], rdx\n                    jmp     loc_break3\n\n    loc_break3:     lea     rsp, [rsp-8]\n                    jmp     loc_ break4\n\n    loc_ break4:    mov     rcx, [rsp+10h]\n                    mov     rdx, offset loc_target2\n                    cmovz   rcx, rdx\n                    jmp     loc_break5\n\n    loc_break5:     mov     [rsp+10h], rcx\n                    lea     rsp, [rsp+8]\n                    mov     rdx, [rsp-8]\n                    jmp     loc_break6\n\n    loc_break6:    lea     rsp, [rsp+8]\n                    mov     rcx, [rsp-8]\n                    retn\n</code></pre>\n <p>\n  If I interpreted this correctly, the obfuscated sequence is a replacement for the simple\n </p>\n <pre><code>jz  loc_target2\njmp loc_target1\n</code></pre>\n <p>\n  More complex patterns like the one of the example might contain simpler ones. As a consequence, you would start with the simple patterns and then move from simpler to more complicated ones, increasing the readablility of the code (and making Ida more happy) with each de-obfuscation step.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "josh",
            "time": "Jul 18, 2016 at 9:47",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Orwellophile",
                    "text": "<span class=\"comment-copy\">These are very much my own thoughts too.  My distorm3 based disassembler will stream out instructions while skipping <code>jmp</code> and i've already implemented signature based patching for those six lines at the top of your example.  BTW your example is so similar to my own, that I wonder if they weren't both generated by the same engine. Some of it's other tricks are <code>mov rax, rsp</code> <code>add rax, 0fffffffffffffff8h</code> <code>mov rsp, rax</code> or the belief beggaring <code>lea rsp, [rsp-8]</code> <code>sub rsp, 20h</code>.</span>",
                    "time": null
                },
                {
                    "user": "Orwellophile",
                    "text": "<span class=\"comment-copy\">(To get back on topic) the reason I posted this question was to determine if it would be better to continue with my own solution, or explore the IDA SDK some more.</span>",
                    "time": null
                },
                {
                    "user": "josh",
                    "text": "<span class=\"comment-copy\">With respect to use an own program or not, I think the best choice is the one you feel to come to a solution in the smallest amount of time. An own solution has IMO the advantage that you can tailor it perhaps better to your needs. I assume the basic algorithmic effort might be similar. However, I have no experience with the Ida SDK, only with some idc. With respect to the obfuscation engine, the similarity is striking indeed.</span>",
                    "time": null
                },
                {
                    "user": "Orwellophile",
                    "text": "<span class=\"comment-copy\">I'm not opposed to developing in .idc, the distorm3 based solution is in C++ (but no STL, so really C).  distorms3's <b>decompose</b> function produces a struct per instruction not wholly dissimilar to idaapi.cmd.  The advantage to developing it in IDA would be that the whole community benefited, and I'd learn a new skill.  BTW, I believe the protect is generated by (and we don't want google to bring up this page)  <code>char url[] = { 0x61, 0x72, 0x78, 0x61, 0x6e, 0x2e, 0x63, 0x6f, 0x6d };</code>   But I do want to get IDA to replace LEA based BSP manipulations with something IDA's stack counter can use.</span>",
                    "time": null
                },
                {
                    "user": "josh",
                    "text": "<span class=\"comment-copy\">To be honest, I would never do this in idc. idc as a language is too weak. I did it in C#, due to the comfortable GUI possiblities and file handling. If more basic stuff is needed, my technique is C# GUI frontend and C++ DLL backend with a plain C pinvoke interface. But maybe others have another opinion. BTW, the mentioned book of Chris Eagle is highly recommended. An excellent book. And your suggestion of the obfusc provider makes absolutely sense...</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <pre><code>import struct\n\ndef readWord(array, offset):\n    return struct.unpack_from(\"<i\", bytearray(array), offset)[0]\n\ndef writeWord(array, offset, word):\n    array[offset:offset+4] = bytearray(struct.pack(\"<i\", word))\n\nclass Obfu(object):\n    # Copyright 2016 Orwellophile LLC. MIT License.\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.eip = start\n        self.patterns = []\n\n    def append(self, searchText, replaceText, search, replace, replaceFunction = None):\n        self.patterns.append([search, replace, replaceFunction])\n\n    def replace_pattern(self, search, replace, replaceFunction, ea):\n        searchSize = len(search)\n        replaceSize = len(replace)\n        # buf = idc.GetManyBytes(ea, ItemSize(ea))\n        failed = 0\n        for i in range(searchSize):\n            if search[i] != -1 and idaapi.get_byte(ea+i) != search[i]:\n                failed = 1\n                break\n        if not failed:\n            if replaceFunction != None:\n                original = []\n                for i in range(max(searchSize,replaceSize)):\n                    original.append(idaapi.get_byte(ea+i))\n                replace = replaceFunction(search, replace, original, ea)\n                replaceSize = len(replace)\n            for i in range(replaceSize):\n                if replace[i] != -1:\n                    idaapi.patch_byte(ea+i, replace[i])\n            print \"patched %i bytes at 0x%x\" % (replaceSize, ea)\n            MakeCode(ea) # else it turns it into data\n        return not failed\n\n    def _patch(self, ea):\n        for pattern in self.patterns:\n            if self.replace_pattern(pattern[0], pattern[1], pattern[2], ea):\n                return 1\n        return 0\n\n    def get_next_instruction(self):\n        while self.eip <= self.end:\n            yield [hex(self.eip), self._patch(self.eip)]\n            self.eip += ItemSize(self.eip)\n\n# Usage\n\nobfu = Obfu(SegStart(ScreenEA()), SegEnd(ScreenEA()))\n\n# Patch factory\ndef generate_patch1(jmpTargetOffset, oldRip, newRip):\n    def patch(search, replace, original, ea):\n        result = [0xcc]*len(original) # preallocate result with 0xcccccc...\n\n        jmpTarget = readWord(original, jmpTargetOffset)\n        adjustTarget = oldRip - newRip\n        jmpTarget = jmpTarget + adjustTarget\n        result[0] = 0xE9 # JMP rel32off\n        writeWord(result, 1, jmpTarget)\n        return result\n    return patch\n\n# Uses Patch Factory generated callback\nobfu.append(\"\"\"\n        0:  48 8d 64 24 f8          lea    rsp,[rsp-0x8]\n        5:  48 89 2c 24             mov    QWORD PTR [rsp],rbp\n        9:  48 8d 2d 00 00 00 00    lea    rbp,[rip+0x0]        # 0x10\n        10: 48 87 2c 24             xchg   QWORD PTR [rsp],rbp\n        14: 48 8d 64 24 08          lea    rsp,[rsp+0x8]\n        19: ff 64 24 f8             jmp    QWORD PTR [rsp-0x8]\n        \"\"\", \"test of replacement function (patch callback)\",\n        [0x48, 0x8D, 0x64, 0x24, 0xF8, 0x48, 0x89, 0x2C, 0x24, 0x48, 0x8D, 0x2D, -1, -1, -1, -1, 0x48, 0x87, 0x2C, 0x24, 0x48, 0x8D, 0x64, 0x24, 0x08, 0xFF, 0x64, 0x24, 0xF8], \n        # unused:\n        [0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xE9, -1, -1, -1, -1, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90],\n        generate_patch1(0x0c, 0x10, 0x05)\n        )\n\n# Byte patch\nobfu.append(\"\"\"\n        0:  48 89 6c 24 f8          mov    QWORD PTR [rsp-0x8],rbp\n        5:  48 8d 64 24 f8          lea    rsp,[rsp-0x8]\n        a:  48 8d 2d 00 00 00 00    lea    rbp,[rip+0x0]        # 0x11\n        11: 48 87 2c 24             xchg   QWORD PTR [rsp],rbp\n        15: 48 8d 64 24 08          lea    rsp,[rsp+0x8]\n        1a: ff 64 24 f8             jmp    QWORD PTR [rsp-0x8]\n        \"\"\", \n        \"jmp ${ readWord(0x0d) + (oldRip = 0x11) - (newRip = 0x05) }\",\n        [0x48, 0x89, 0x6c, 0x24, 0xf8, 0x48, 0x8d, 0x64, 0x24, 0xf8, 0x48, 0x8d, 0x2d, -1, -1, -1, -1, 0x48, 0x87, 0x2c, 0x24, 0x48, 0x8d, 0x64, 0x24, 0x08, 0xff, 0x64, 0x24, 0xf8],\n        [0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xe9, -1, -1, -1, -1, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90]\n        )\n\n# This patch disables one of the longer patches, keep at end of list\nobfu.append(  \"lea    rsp,[rsp-0x8]\",   # First two arguments aren't used\n        \"\", # \"sub    rsp,0x8; nop\",    # They're just there to remind you\n        [0x48, 0x8d, 0x64, 0x24, 0xf8], \n        [0x48, 0x83, 0xec, 0x08, 0x90])\n\n# Test single replacement with: \n# obfu._patch(address)\n#\n# or uncomment next lines to patch everything:\n#\n# x = obfu.get_next_instruction()\n# count = 0\n# while x.next(): count = count + 1\n</code></pre>\n</div>\n</body></html>",
            "votes": "0",
            "user": "Orwellophile",
            "time": "Jul 19, 2016 at 2:46",
            "is_accepted": false,
            "comments": [
                {
                    "user": "NirIzr",
                    "text": "<span class=\"comment-copy\">Some text describing what's going on and why you came up with this might be nice</span>",
                    "time": null
                }
            ]
        }
    ]
}