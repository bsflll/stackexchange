{
    "title": "radare2 shows main function arguments argv as pointer to char on the stack, not as pointer to pointer to char",
    "link": "https://reverseengineering.stackexchange.com/questions/21260/radare2-shows-main-function-arguments-argv-as-pointer-to-char-on-the-stack-not",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Well, I've been digging around\n  <em>\n   process command line arguments\n  </em>\n  as well as\n  <em>\n   environment variables\n  </em>\n  a bit these last days, especially looking up the way\n  <code>\n   main\n  </code>\n  function arguments were pushed onto the stack.\n </p>\n <p>\n  So far I've got it that a certain\n  <code>\n   _libc_start_main()\n  </code>\n  function is responsible of setting up everything the\n  <code>\n   main()\n  </code>\n  function needs in terms of parameters before actually calling it.\n  \n\n  Without getting into much\n  <a href=\"https://reverseengineering.stackexchange.com/a/15175/24851\">\n   details\n  </a>\n  , I've noticed that when debugging a simple\n  <code>\n   main\n  </code>\n  program, the\n  <code>\n   main\n  </code>\n  stack frame is different whether we look it up in\n  <code>\n   radare2\n  </code>\n  or\n  <code>\n   gdb\n  </code>\n  .\n  \n\n  For instance, let's take this minimalist C program :\n </p>\n <pre><code>int main (int argc, char *argv[], char *envp[])\n{\n}\n</code></pre>\n <p>\n  And simply debug it without any additional parameters :\n </p>\n <h2>\n  With GDB\n </h2>\n <p>\n  After setting a breakpoint on the first assembly instruction of\n  <code>\n   main\n  </code>\n  (I couldn't dump the stack frame without running the program),\nwhat I got in\n  <code>\n   gdb\n  </code>\n  is something very sensible, as one can see :\n </p>\n <pre><code>(gdb) x/3xw $esp\n0xffffcfbc:     0xf7db7b41          0x00000001      0xffffd054      \n#                  ^                    ^               ^     \n#              PC (somewhere          argc            argv             \n#          in __libc_start_main())\n</code></pre>\n <p>\n  Now by actually inspecting the pointed out memory regions for\n  <code>\n   argv\n  </code>\n  :\n </p>\n <pre><code>(gdb) x/2xw 0xffffd054   # argv\n0xffffd054:     0xffffd1ef      0x00000000\n#                  ^                ^ \n#                argv[0]          argv[argc]\n#           (another pointer)              \n\n(gdb) x/s 0xffffd1ef  # argv[0]\n0xffffd1ef:     \"<path>/argvonstack32\"\n#                      ^ \n#                  Exepected program name\n</code></pre>\n <p>\n  So what was basically pushed onto the\n  <code>\n   main\n  </code>\n  stack frame, for both\n  <code>\n   argv\n  </code>\n  and\n  <code>\n   envp\n  </code>\n  (even if I didn't show the dump for\n  <code>\n   envp\n  </code>\n  for simplicity's sake) is exactly what we were entitled to expect from a debugger, that is a\n  <em>\n   pointer to pointer to\n   <code>\n    char\n   </code>\n  </em>\n  (as stated in the\n  <code>\n   main\n  </code>\n  function signature).\n </p>\n <h2>\n  With Radare2\n </h2>\n <p>\n  Without setting any breakpoint, and directly inspecting the stack frame without running the program,\n  <code>\n   radare2\n  </code>\n  shows a different stack frame :\n </p>\n <pre><code>- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF  comment\n0xffa63d10  0100 0000 1953 a6ff 0000 0000 2953 a6ff  .....S......)S..  ; esp\n                ^         ^         ^       \n              argc     argv[0]    argv[1]\n</code></pre>\n <p>\n  When inspecting\n  <code>\n   argv[0]\n  </code>\n  :\n </p>\n <pre><code>- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF  comment\n0xffa65319  2e2f 6172 6776 6f6e 7374 6163 6b33 3200  ./argvonstack32.\n0xffa65329  5348 454c 4c3d 2f62 696e 2f62 6173 6800  SHELL=/bin/bash.\n</code></pre>\n <p>\n  That shows that\n  <code>\n   radare2\n  </code>\n  skipped the first pointer indirection of\n  <code>\n   argv\n  </code>\n  and pushed the list\n  <code>\n   argv[0]...argv[argc]\n  </code>\n  directly onto the\n  <code>\n   main\n  </code>\n  stack frame.\n </p>\n <p>\n  What explains such a difference ?\n </p>\n <p>\n  <em>\n   <strong>\n    PS:\n   </strong>\n  </em>\n  As you can see, the only difference there is between my usage of\n  <code>\n   radare2\n  </code>\n  and\n  <code>\n   gdb\n  </code>\n  was that I runned the program in\n  <code>\n   gdb\n  </code>\n  while  didn't need to actually run it on\n  <code>\n   radare2\n  </code>\n  to dump the\n  <code>\n   main\n  </code>\n  stack frame memory.\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 1,
    "views": "416",
    "tags": [
        "debugging",
        "radare2",
        "gdb",
        "stack",
        "entry-point"
    ],
    "user": "programmersn",
    "time": "Jun 17, 2020 at 9:54",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  You are sort of comparing oranges and apples.\n </p>\n <p>\n  In the first example, you are looking at the arguments passed to the\n  <code>\n   main\n  </code>\n  function by the C library, and they match the C standard requirements (array of\n  <code>\n   char\n  </code>\n  pointers).\n </p>\n <p>\n  In the second example, you are looking at the low level\n  <em>\n   entry point\n  </em>\n  to the binary and the parameters\n  <em>\n   from the kernel\n  </em>\n  , before they have been processed by the C library. The kernel does no fancy processing: it just puts all strings in one block delimited by zero bytes (and terminated with two zeroes) and leaves the splitting to the program itself. Usually this is done by\n  <code>\n   __libc_start_main\n  </code>\n  or similar function before calling\n  <code>\n   main()\n  </code>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Igor Skochinsky",
            "time": "May 2, 2019 at 19:28",
            "is_accepted": true,
            "comments": []
        }
    ]
}