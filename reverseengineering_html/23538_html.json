{
    "title": "Why is there no call to strcpy in assembly?",
    "link": "https://reverseengineering.stackexchange.com/questions/23538/why-is-there-no-call-to-strcpy-in-assembly",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I try to better understand assembly and currently playing around with some compiled c snippets.\nI have the following snippet:\n </p>\n <pre><code>#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char b[] = \" a nice nice long string\";\n\n    char c[100];\n    strcpy(c, b);\n    printf(\"Hello World %s\n\", c);\n    strcpy(c, \" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n}\n</code></pre>\n <p>\n  After compiling it with\n  <code>\n   gcc hello_world.c -o hello_world\n  </code>\n  and opening it in gdb the assembly code of the main function looks like this:\n </p>\n <pre><code>   0x00000000000006fa <+0>:     push   rbp\n   0x00000000000006fb <+1>:     mov    rbp,rsp\n   0x00000000000006fe <+4>:     sub    rsp,0x90\n   0x0000000000000705 <+11>:    mov    rax,QWORD PTR fs:0x28\n   0x000000000000070e <+20>:    mov    QWORD PTR [rbp-0x8],rax\n   0x0000000000000712 <+24>:    xor    eax,eax\n   0x0000000000000714 <+26>:    movabs rax,0x206563696e206120\n   0x000000000000071e <+36>:    movabs rdx,0x6e6f6c206563696e\n   0x0000000000000728 <+46>:    mov    QWORD PTR [rbp-0x90],rax\n   0x000000000000072f <+53>:    mov    QWORD PTR [rbp-0x88],rdx\n   0x0000000000000736 <+60>:    movabs rax,0x676e697274732067\n   0x0000000000000740 <+70>:    mov    QWORD PTR [rbp-0x80],rax\n   0x0000000000000744 <+74>:    mov    BYTE PTR [rbp-0x78],0x0\n   0x0000000000000748 <+78>:    lea    rdx,[rbp-0x90]\n   0x000000000000074f <+85>:    lea    rax,[rbp-0x70]\n   0x0000000000000753 <+89>:    mov    rsi,rdx\n   0x0000000000000756 <+92>:    mov    rdi,rax\n   0x0000000000000759 <+95>:    call   0x5b0 <strcpy@plt>\n   0x000000000000075e <+100>:   lea    rax,[rbp-0x70]\n   0x0000000000000762 <+104>:   mov    rsi,rax\n   0x0000000000000765 <+107>:   lea    rdi,[rip+0xe8]        # 0x854\n   0x000000000000076c <+114>:   mov    eax,0x0\n   0x0000000000000771 <+119>:   call   0x5d0 <printf@plt>\n   0x0000000000000776 <+124>:   lea    rax,[rbp-0x70]\n   0x000000000000077a <+128>:   movabs rsi,0x4141414141414120\n   0x0000000000000784 <+138>:   movabs rdi,0x4141414141414141\n   0x000000000000078e <+148>:   mov    QWORD PTR [rax],rsi\n   0x0000000000000791 <+151>:   mov    QWORD PTR [rax+0x8],rdi\n   0x0000000000000795 <+155>:   movabs rdx,0x4141414141414141\n   0x000000000000079f <+165>:   movabs rcx,0x4141414141414141\n   0x00000000000007a9 <+175>:   mov    QWORD PTR [rax+0x10],rdx\n   0x00000000000007ad <+179>:   mov    QWORD PTR [rax+0x18],rcx\n   0x00000000000007b1 <+183>:   mov    BYTE PTR [rax+0x20],0x0\n   0x00000000000007b5 <+187>:   mov    eax,0x0\n   0x00000000000007ba <+192>:   mov    rcx,QWORD PTR [rbp-0x8]\n   0x00000000000007be <+196>:   xor    rcx,QWORD PTR fs:0x28\n   0x00000000000007c7 <+205>:   je     0x7ce <main+212>\n   0x00000000000007c9 <+207>:   call   0x5c0 <__stack_chk_fail@plt>\n   0x00000000000007ce <+212>:   leave\n   0x00000000000007cf <+213>:   ret\n</code></pre>\n <p>\n  I think i understand which part is doing what. \nBut some things are not clear to me.\n </p>\n <ol>\n  <li>\n   strcpy is only called once and only when the second argument is a variable. Why is ther no call for the second strcopy?\n  </li>\n  <li>\n   printf is called with a string and a second arg. The string is loaded from rip+0xe8. Why is the string provided to the second strcopy not loaded in the same fashion? It is \"hardcoded\" with in the moveabs instructions.\n  </li>\n </ol>\n <p>\n  Is this due to some compiler optimization? Can someone elaborate?\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "761",
    "tags": [
        "assembly",
        "c",
        "gdb"
    ],
    "user": "joachim",
    "time": "Mar 26, 2020 at 15:26",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <pre><code>import binascii\nprint(binascii.hexlify(b\" a nice nice long string\"))\nprint(binascii.hexlify(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"))\n</code></pre>\n <p>\n  you can find both the string in your listing\n </p>\n <pre><code>b'2061206e696365206e696365206c6f6e6720737472696e67'\nb'41414141414141414141414141414141414141414141414141414141414141'\n</code></pre>\n <p>\n  first string\n </p>\n <pre><code>0x0000000000000714 <+26>:    movabs rax,0x206563696e206120\n0x000000000000071e <+36>:    movabs rdx,0x6e6f6c206563696e\n0x0000000000000736 <+60>:    movabs rax,0x676e697274732067\n</code></pre>\n <p>\n  second string\n </p>\n <pre><code> 0x000000000000077a <+128>:   movabs rsi,0x4141414141414120\n 0x0000000000000784 <+138>:   movabs rdi,0x4141414141414141\n 0x000000000000078e <+148>:   mov    QWORD PTR [rax],rsi\n 0x0000000000000791 <+151>:   mov    QWORD PTR [rax+0x8],rdi\n 0x0000000000000795 <+155>:   movabs rdx,0x4141414141414141\n 0x000000000000079f <+165>:   movabs rcx,0x4141414141414141\n</code></pre>\n <p>\n  first time you give it an address which is unknown at compile time so compiler is forced to use the function (dynamic arguments)\n </p>\n <p>\n  second time you give a CONSTANT String which can be split and put into the c\n  \n\n  (static argument)\n </p>\n <p>\n  or if you provide a very very big string it can take the address and do a repmovsq\n </p>\n <pre><code>strcpy(d, \" lshdgfdghsdfghsdfghsdfhgsdfhgsdfhgshsfur4tye36346asdgxzcvgaewt34t sg afeaerwbhtyhswrtwqee5t6e67redhfdxbw45bh hhjljuhlfjsdhlksjdghsdlkjfhgsldkjfghlskjdghlkjsdhggkjsdhgksdjhgskdjhglsdkjhgfskjdhfgsdkjhfgkjsdfhgskdjhfgsdk;ljhg;djkgsjhg;dsljkhf;ljg;dljg;jh\");\n}\n</code></pre>\n <p>\n  using repmovsq\n </p>\n <pre><code>mov     eax, OFFSET FLAT:.LC1\nmov     ecx, 31\nmov     rdi, rdx\nmov     rsi, rax\nrep movsq\n\n.LC1:\n        .string \" lshd\n</code></pre>\n <p>\n  just to confirm remove the b[] = line and put strcpy(c,const string ); you will see the compiler has eliminated the .plt entry also and will convert the \nstrcpy to __builtin_memcpy()\n </p>\n <pre><code> __builtin_memcpy (&c, \" a nice nice long string\", 25);\n  printf (\"Hello World %s\n\", &c);\n  __builtin_memcpy (&c, \" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", 33);\n</code></pre>\n <p>\n  compile with -fno-builtin and you will get both strcpy\n </p>\n <pre><code>.LC0:\n        .string \"Hello World %s\n\"\n.LC1:\n        .string \" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\nmain:\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 144\n        movabs  rax, 2334381286331801888\n        movabs  rdx, 7957697952982722926\n        mov     QWORD PTR [rbp-32], rax\n        mov     QWORD PTR [rbp-24], rdx\n        movabs  rax, 7453010373645639783\n        mov     QWORD PTR [rbp-16], rax\n        mov     BYTE PTR [rbp-8], 0\n        lea     rdx, [rbp-32]\n        lea     rax, [rbp-144]\n        mov     rsi, rdx\n        mov     rdi, rax\n        call    strcpy\n        lea     rax, [rbp-144]\n        mov     rsi, rax\n        mov     edi, OFFSET FLAT:.LC0\n        mov     eax, 0\n        call    printf\n        lea     rax, [rbp-144]\n        mov     esi, OFFSET FLAT:.LC1\n        mov     rdi, rax\n        call    strcpy\n        mov     eax, 0\n        leave\n        ret\n</code></pre>\n <p>\n  you can read about various other __builtins\n  <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#Other-Builtins\" rel=\"nofollow noreferrer\">\n   here\n  </a>\n </p>\n</div>\n</body></html>",
            "votes": "4",
            "user": "blabb",
            "time": "Mar 26, 2020 at 18:41",
            "is_accepted": false,
            "comments": []
        }
    ]
}