{
    "title": "Why did I have gotten only null bytes argv variable from angr?",
    "link": "https://reverseengineering.stackexchange.com/questions/31543/why-did-i-have-gotten-only-null-bytes-argv-variable-from-angr",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have made simple program to test the angr.\n </p>\n <p>\n  My python code is here.\n </p>\n <pre><code>import angr \nimport claripy\n\np=angr.Project('./test2')\nbuf=claripy.BVS('buf', 8*10)\n\ninitial_state=p.factory.entry_state(args=[\"./test2\", buf])\n\ns=p.factory.simulation_manager()\n\ns.explore(find=0x80491ab, avoid=0x80491ba)\n\nprint(s.found)\n\nif s.found:\n    sol_state=s.found[0]\n    sol=sol_state.solver.eval(buf, cast_to=bytes)\n    print(sol)\nelse:\n    print(\"not found\")\n</code></pre>\n <p>\n  I expected this program print \"hello\"\nbut It printed as follows.\n </p>\n <pre><code>WARNING  | 2023-02-13 23:57:05,077 | angr.storage.memory_mixins.default_filler_mixin | The program is accessing memory with an unspecified value. This could indicate unwanted behavior.\nWARNING  | 2023-02-13 23:57:05,077 | angr.storage.memory_mixins.default_filler_mixin | angr will cope with this by generating an unconstrained symbolic variable and continuing. You can resolve this by:\nWARNING  | 2023-02-13 23:57:05,077 | angr.storage.memory_mixins.default_filler_mixin | 1) setting a value to the initial state\nWARNING  | 2023-02-13 23:57:05,077 | angr.storage.memory_mixins.default_filler_mixin | 2) adding the state option ZERO_FILL_UNCONSTRAINED_{MEMORY,REGISTERS}, to make unknown regions hold null\nWARNING  | 2023-02-13 23:57:05,078 | angr.storage.memory_mixins.default_filler_mixin | 3) adding the state option SYMBOL_FILL_UNCONSTRAINED_{MEMORY,REGISTERS}, to suppress these messages.\nWARNING  | 2023-02-13 23:57:05,078 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x0 with 129 unconstrained bytes referenced from 0x819f230 (strcpy+0x0 in libc.so.6 (0x9f230))\nWARNING  | 2023-02-13 23:57:05,402 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7ffeff6e with 10 unconstrained bytes referenced from 0x819f230 (strcpy+0x0 in libc.so.6 (0x9f230))\n[<SimState @ 0x80491ab>]\nb'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n</code></pre>\n <p>\n  Here is my source code test2.c and assembly code\n </p>\n <p>\n  test2.c\n </p>\n <pre><code>#include <stdio.h>\n#include <string.h>\n\nint main(int agrc, char* argv[])\n{\n    char buf[10];\n\n    strcpy(buf, argv[1]);\n\n    if(!strcmp(buf, \"hello\"))\n    {\n        puts(\"Correct!\");\n    }\n    else\n    {\n        puts(\"Incorrect\");\n    }\n}\n</code></pre>\n <p>\n  test2 assembly code\n </p>\n <pre><code>Dump of assembler code for function main:\n   0x08049176 <+0>:     push   ebp\n   0x08049177 <+1>:     mov    ebp,esp\n   0x08049179 <+3>:     sub    esp,0xc\n   0x0804917c <+6>:     mov    eax,DWORD PTR [ebp+0xc]\n   0x0804917f <+9>:     add    eax,0x4\n   0x08049182 <+12>:    mov    eax,DWORD PTR [eax]\n   0x08049184 <+14>:    push   eax\n   0x08049185 <+15>:    lea    eax,[ebp-0xa]\n   0x08049188 <+18>:    push   eax\n   0x08049189 <+19>:    call   0x8049050 <strcpy@plt>\n   0x0804918e <+24>:    add    esp,0x8\n   0x08049191 <+27>:    push   0x804a008\n   0x08049196 <+32>:    lea    eax,[ebp-0xa]\n   0x08049199 <+35>:    push   eax\n   0x0804919a <+36>:    call   0x8049030 <strcmp@plt>\n   0x0804919f <+41>:    add    esp,0x8\n   0x080491a2 <+44>:    test   eax,eax\n   0x080491a4 <+46>:    jne    0x80491b5 <main+63>\n   0x080491a6 <+48>:    push   0x804a00e\n   0x080491ab <+53>:    call   0x8049060 <puts@plt>\n   0x080491b0 <+58>:    add    esp,0x4\n   0x080491b3 <+61>:    jmp    0x80491c2 <main+76>\n   0x080491b5 <+63>:    push   0x804a017\n   0x080491ba <+68>:    call   0x8049060 <puts@plt>\n   0x080491bf <+73>:    add    esp,0x4\n   0x080491c2 <+76>:    mov    eax,0x0\n   0x080491c7 <+81>:    leave\n   0x080491c8 <+82>:    ret\nEnd of assembler dump.\n</code></pre>\n <p>\n  Why is this happening?\nThank you in advance.\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "83",
    "tags": [
        "assembly",
        "python",
        "angr"
    ],
    "user": "doldom",
    "time": "Feb 14, 2023 at 5:15",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  You do not use the\n  <code>\n   initial_state\n  </code>\n  you create with constraints for\n  <code>\n   buf\n  </code>\n  arg.\nFrom the doc\n </p>\n <blockquote>\n  <p>\n   If nothing is passed in, the SimulationManager is seeded with a state initialized for the program entry point, i.e. entry_state().\nIf a SimState is passed in, the SimulationManager is seeded with that state.\n  </p>\n </blockquote>\n <pre><code>s = p.factory.simulation_manager(initial_state)\n</code></pre>\n <p>\n  would just do it\n </p>\n <pre><code>[<SimState @ 0x4007a3>]\nb'hello\\x00\\x08\\x80\\x00\\x00'\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "sudhackar",
            "time": "Feb 14, 2023 at 14:14",
            "is_accepted": true,
            "comments": []
        }
    ]
}