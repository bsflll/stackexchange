{
    "title": "How does this Is64BitOS pointer-arithmetic-based function work?",
    "link": "https://reverseengineering.stackexchange.com/questions/31379/how-does-this-is64bitos-pointer-arithmetic-based-function-work",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Reversed this function. It works. But stepping through I can't figure out how. Why does this work?\n </p>\n <pre><code>bool   _Is64BitOS(void) {\n    unsigned int version = *(unsigned int*)0x7FFE026C;\n    unsigned int address = version == 10 ? 0x7FFE0308 : 0x7FFE0300;\n    ILog(\"Running %u-bit system\n\", *(void**)address ? 32 : 64);\n\n    return (*(void**)address ? false : true);\n};\n</code></pre>\n <p>\n  Why do we find\n  <code>\n   0x0A\n  </code>\n  at\n  <code>\n   0x7FFE026C\n  </code>\n  on a 64 bit Windows install?\n </p>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 1,
    "views": "119",
    "tags": [
        "windows",
        "c++"
    ],
    "user": "Pulpo",
    "time": "Jan 10, 2023 at 7:49",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<html><body><span class=\"comment-copy\">\n Just to mention the obvious, there isn't much pointer arithmethic involved. It's just using hardcoded addresses -- in one case conditionally one address or another.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  \"Simple\", I want to respond, but it's somewhat involved.\n </p>\n <p>\n  That region -- (\n  <a href=\"https://msrc-blog.microsoft.com/2022/04/05/randomizing-the-kuser_shared_data-structure-on-windows/\" rel=\"nofollow noreferrer\">\n   since newer Windows 10 versions read-only\n  </a>\n  ) mapped into userspace of every program -- is known as\n  <a href=\"https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi_x/kuser_shared_data/index.htm\" rel=\"nofollow noreferrer\">\n   KUSER_SHARED_DATA\n  </a>\n  . You can find details about the offsets and there meaning\n  <a href=\"http://terminus.rewolf.pl/terminus/structures/ntdll/_KUSER_SHARED_DATA_combined.html\" rel=\"nofollow noreferrer\">\n   over here\n  </a>\n  (\n  <em>\n   beware, it's a bit dated!\n  </em>\n  ).\n </p>\n <p>\n  The first assignment to\n  <code>\n   version\n  </code>\n  merely reads\n  <code>\n   KUSER_SHARED_DATA::NtMajorVersion\n  </code>\n  . So to answer:\n </p>\n <blockquote>\n  <p>\n   Why do we find\n   <code>\n    0x0A\n   </code>\n   at\n   <code>\n    0x7FFE026C\n   </code>\n   on a 64 bit Windows install?\n  </p>\n </blockquote>\n <p>\n  ... it's the major version of the Windows, 10 in decimal representation.\n </p>\n <p>\n  Since we need an up-to-date view of what\n  <code>\n   KUSER_SHARED_DATA\n  </code>\n  looks we'll have a look at the official symbols from Windows 10 by starting WinDbg/WinDbgX on Windows 10, launching some 64-bit program from it (e.g. notepad.exe) and then running\n  <code>\n   dt nt!_KUSER_SHARED_DATA\n  </code>\n  to see the type definition.\n </p>\n <pre><code>0:000> dt nt!_KUSER_SHARED_DATA\nntdll!_KUSER_SHARED_DATA\n   +0x000 TickCountLowDeprecated : Uint4B\n   +0x004 TickCountMultiplier : Uint4B\n   +0x008 InterruptTime    : _KSYSTEM_TIME\n   +0x014 SystemTime       : _KSYSTEM_TIME\n   +0x020 TimeZoneBias     : _KSYSTEM_TIME\n   +0x02c ImageNumberLow   : Uint2B\n   +0x02e ImageNumberHigh  : Uint2B\n   +0x030 NtSystemRoot     : [260] Wchar\n   +0x238 MaxStackTraceDepth : Uint4B\n   +0x23c CryptoExponent   : Uint4B\n   +0x240 TimeZoneId       : Uint4B\n   +0x244 LargePageMinimum : Uint4B\n   +0x248 AitSamplingValue : Uint4B\n   +0x24c AppCompatFlag    : Uint4B\n   +0x250 RNGSeedVersion   : Uint8B\n   +0x258 GlobalValidationRunlevel : Uint4B\n   +0x25c TimeZoneBiasStamp : Int4B\n   +0x260 NtBuildNumber    : Uint4B\n   +0x264 NtProductType    : _NT_PRODUCT_TYPE\n   +0x268 ProductTypeIsValid : UChar\n   +0x269 Reserved0        : [1] UChar\n   +0x26a NativeProcessorArchitecture : Uint2B\n   +0x26c NtMajorVersion   : Uint4B\n   +0x270 NtMinorVersion   : Uint4B\n   +0x274 ProcessorFeatures : [64] UChar\n   +0x2b4 Reserved1        : Uint4B\n   +0x2b8 Reserved3        : Uint4B\n   +0x2bc TimeSlip         : Uint4B\n   +0x2c0 AlternativeArchitecture : _ALTERNATIVE_ARCHITECTURE_TYPE\n   +0x2c4 BootId           : Uint4B\n   +0x2c8 SystemExpirationDate : _LARGE_INTEGER\n   +0x2d0 SuiteMask        : Uint4B\n   +0x2d4 KdDebuggerEnabled : UChar\n   +0x2d5 MitigationPolicies : UChar\n   +0x2d5 NXSupportPolicy  : Pos 0, 2 Bits\n   +0x2d5 SEHValidationPolicy : Pos 2, 2 Bits\n   +0x2d5 CurDirDevicesSkippedForDlls : Pos 4, 2 Bits\n   +0x2d5 Reserved         : Pos 6, 2 Bits\n   +0x2d6 CyclesPerYield   : Uint2B\n   +0x2d8 ActiveConsoleId  : Uint4B\n   +0x2dc DismountCount    : Uint4B\n   +0x2e0 ComPlusPackage   : Uint4B\n   +0x2e4 LastSystemRITEventTickCount : Uint4B\n   +0x2e8 NumberOfPhysicalPages : Uint4B\n   +0x2ec SafeBootMode     : UChar\n   +0x2ed VirtualizationFlags : UChar\n   +0x2ee Reserved12       : [2] UChar\n   +0x2f0 SharedDataFlags  : Uint4B\n   +0x2f0 DbgErrorPortPresent : Pos 0, 1 Bit\n   +0x2f0 DbgElevationEnabled : Pos 1, 1 Bit\n   +0x2f0 DbgVirtEnabled   : Pos 2, 1 Bit\n   +0x2f0 DbgInstallerDetectEnabled : Pos 3, 1 Bit\n   +0x2f0 DbgLkgEnabled    : Pos 4, 1 Bit\n   +0x2f0 DbgDynProcessorEnabled : Pos 5, 1 Bit\n   +0x2f0 DbgConsoleBrokerEnabled : Pos 6, 1 Bit\n   +0x2f0 DbgSecureBootEnabled : Pos 7, 1 Bit\n   +0x2f0 DbgMultiSessionSku : Pos 8, 1 Bit\n   +0x2f0 DbgMultiUsersInSessionSku : Pos 9, 1 Bit\n   +0x2f0 DbgStateSeparationEnabled : Pos 10, 1 Bit\n   +0x2f0 SpareBits        : Pos 11, 21 Bits\n   +0x2f4 DataFlagsPad     : [1] Uint4B\n   +0x2f8 TestRetInstruction : Uint8B\n   +0x300 QpcFrequency     : Int8B\n   +0x308 SystemCall       : Uint4B\n   +0x30c Reserved2        : Uint4B\n   +0x310 SystemCallPad    : [2] Uint8B\n   +0x320 TickCount        : _KSYSTEM_TIME\n   +0x320 TickCountQuad    : Uint8B\n   +0x320 ReservedTickCountOverlay : [3] Uint4B\n   +0x32c TickCountPad     : [1] Uint4B\n   +0x330 Cookie           : Uint4B\n   +0x334 CookiePad        : [1] Uint4B\n   +0x338 ConsoleSessionForegroundProcessId : Int8B\n   +0x340 TimeUpdateLock   : Uint8B\n   +0x348 BaselineSystemTimeQpc : Uint8B\n   +0x350 BaselineInterruptTimeQpc : Uint8B\n   +0x358 QpcSystemTimeIncrement : Uint8B\n   +0x360 QpcInterruptTimeIncrement : Uint8B\n   +0x368 QpcSystemTimeIncrementShift : UChar\n   +0x369 QpcInterruptTimeIncrementShift : UChar\n   +0x36a UnparkedProcessorCount : Uint2B\n   +0x36c EnclaveFeatureMask : [4] Uint4B\n   +0x37c TelemetryCoverageRound : Uint4B\n   +0x380 UserModeGlobalLogger : [16] Uint2B\n   +0x3a0 ImageFileExecutionOptions : Uint4B\n   +0x3a4 LangGenerationCount : Uint4B\n   +0x3a8 Reserved4        : Uint8B\n   +0x3b0 InterruptTimeBias : Uint8B\n   +0x3b8 QpcBias          : Uint8B\n   +0x3c0 ActiveProcessorCount : Uint4B\n   +0x3c4 ActiveGroupCount : UChar\n   +0x3c5 Reserved9        : UChar\n   +0x3c6 QpcData          : Uint2B\n   +0x3c6 QpcBypassEnabled : UChar\n   +0x3c7 QpcShift         : UChar\n   +0x3c8 TimeZoneBiasEffectiveStart : _LARGE_INTEGER\n   +0x3d0 TimeZoneBiasEffectiveEnd : _LARGE_INTEGER\n   +0x3d8 XState           : _XSTATE_CONFIGURATION\n   +0x710 FeatureConfigurationChangeStamp : _KSYSTEM_TIME\n   +0x71c Spare            : Uint4B\n</code></pre>\n <p>\n  (if we used\n  <code>\n   dt -r2 nt!_KUSER_SHARED_DATA 0x000000007ffe0000\n  </code>\n  -- assuming we're\n  <em>\n   not\n  </em>\n  on 64-bit ARM where the\n  <code>\n   KUSER_SHARED_DATA\n  </code>\n  is no longer at a fixed address -- we can see the \"decoded\" contents of this structure)\n </p>\n <p>\n  By comparing this output with the one from Terminus (link above) we can see that we seem to be looking for\n  <code>\n   KUSER_SHARED_DATA::SystemCall\n  </code>\n  (in newer versions\n  <code>\n   SystemCallPad\n  </code>\n  as per Terminus, but the symbols call it\n  <code>\n   SystemCall\n  </code>\n  nevertheless). When we follow the logic from the function it appears as if it tries to dereference the given address, picked based on Windows 10 or not, as a pointer. The goal seems to be to figure out (from any given process) if that value is 0 or not. And that seems to be an indicator for whether or not we're on 32-bit.\n </p>\n <p>\n  <code>\n   KUSER_SHARED_DATA\n  </code>\n  has all sorts of useful applications, one is to quickly determine the\n  <em>\n   true\n  </em>\n  Windows version with resorting to NT native function calls or having to specify in a manifest that your application is compatible with the Windows version it's running on.\n </p>\n <p>\n  That said, it's always a certain risk to reach into OS structures like that and relying on a given layout. Microsoft seems to be aware that this is being used by third parties, enough so to have kept the address fixed but making the region read-only in newer Windows versions (article linked above).\n </p>\n <ul>\n  <li>\n   <a href=\"https://osm.hpi.de/wrk/2007/08/getting-os-information-the-kuser_shared_data-structure/\" rel=\"nofollow noreferrer\">\n    Older article\n   </a>\n   , including details on how to query system time\n  </li>\n </ul>\n</div>\n</body></html>",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "Feb 8, 2024 at 16:50",
            "is_accepted": true,
            "comments": []
        }
    ]
}