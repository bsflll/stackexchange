{
    "title": "IDAPython: Getting all arguments passed to function",
    "link": "https://reverseengineering.stackexchange.com/questions/33072/idapython-getting-all-arguments-passed-to-function",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I am working on getting two specific arguments from a function that is called around 1000 times in an executable. Is there any way of looping through all XREFs that reference the function and print out the arguments supplied to it?\n </p>\n <p>\n  This question was asked before on\n  <a href=\"https://reverseengineering.stackexchange.com/questions/6960/is-there-any-way-to-get-a-list-of-function-arguments-used-with-idc\">\n   Is there any way to get a list of function arguments used with IDC?\n  </a>\n  but I'm wondering if it is possible via IDAPython specifically\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 2,
    "views": "126",
    "tags": [
        "ida",
        "x86",
        "idapython"
    ],
    "user": "Surasia",
    "time": "Jul 11, 2024 at 8:51",
    "comments": [
        {
            "user": "Ali Rizvi-Santiago",
            "text": "<html><body><span class=\"comment-copy\">\n How do you plan to process it, (or rather) what information are you trying to extract? Do you just want to print out the address of each call along with the inputs that are fed to it (like via the decompiler), or do you want the address of each param and its storage (like via the disassembler)? As mentioned in the ref'd question, each parameter is likely calculated...which makes the decompiler better for just displaying things for comparison. However, if you're trying to process the storage location, addressing, (or something else) the disassembler might be better for that.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Surasia",
            "text": "<html><body><span class=\"comment-copy\">\n this is one of the cases that all functions simply pass a constant defined at a memory address to the function, so I'd like to get what is defined in that memory adrdess.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  You can also use the minsc plugin, over at\n  <a href=\"https://github.com/arizvisa/ida-minsc/tree/persistence-refactor\" rel=\"nofollow noreferrer\">\n   https://github.com/arizvisa/ida-minsc\n  </a>\n  which aims to simplify a lot of these common reversing tasks with regards to scraping things out of (or importing things into) the disassembler.\n </p>\n <p>\n  Disclaimer: I maintain the minsc plugin, over at\n  <a href=\"https://github.com/arizvisa/ida-minsc/tree/persistence-refactor\" rel=\"nofollow noreferrer\">\n   https://github.com/arizvisa/ida-minsc\n  </a>\n  .\n </p>\n <p>\n  The following snippet requests all \"up\" references to a function \"\n  <code>\n   threadSafeObjectAllocator_170b0\n  </code>\n  \" that are executable (+x). This implies that each returned reference will be a branch instruction. The list of references are then assigned to the variable \"\n  <code>\n   calls\n  </code>\n  \".\n </p>\n <pre><code>import database as db, function as func, instruction as ins\nea = 'threadSafeObjectAllocator_170b0'\ncalls = {ref for ref in func.up(ea) if 'x' in ref}\nprint([(n, \"{!s}\".format(t), s) for n, t, s in zip(func.args.names(func.by(ea)), func.args(func.by(ea)), func.args.storage(func.by(ea)))])\n</code></pre>\n <p>\n  Afterwards, the list of calls will be used to get the address of the instruction for the desired parameter, \"\n  <code>\n   desired_argument_index\n  </code>\n  \". As we are making an assumption that the parameter that we want to scrape is an integer, we can use\n  <code>\n   instruction.ops_immediate\n  </code>\n  to filter the instruction for any operands that constain immediate values. We then collect both the address of the call instruction and the operand containing the immediate being used as one of the call instruction's parameters.\n </p>\n <pre><code>immediates = []\nfor call in calls:\n    args = func.xref.args(call)         # idaapi.get_arg_addrs(int(call))\n    arg = args[desired_argument_index]\n    oprefs = ins.ops_immediate(arg)\n    immediates.extend(((call, opref) for opref in oprefs))\n\n# output our results\nfor call, ref in immediates:\n    print(db.disasm(call), ins.op(ref))\n</code></pre>\n <p>\n  To save what we just determined, we can iterate through our list of \"\n  <code>\n   immediates\n  </code>\n  \" and apply the operand value from each item as a tag for the address of each \"\n  <code>\n   call\n  </code>\n  \" in the list. This way if we want to get the results at a later point of time (perhaps to process it differently), we can use the tag to query it, process it differently, and format it according to our needs.\n </p>\n <pre><code>tagname = 'parameter.1'\n\nfor call, opref in immediates:\n    db.tag(call, tagname, ins.op(opref))\n    print('found op', ref, hex(ins.op(ref)), db.disasm(ref))\n\n# use db.selectcontents to query all functions containing our tag,\n# and then query each function for the immediate was just stached\n# so that we can decode the string referenced by each immediate.\nfor f, _ in db.selectcontents(tagname):\n    for ea, res in func.select(f, tagname):\n        print(db.disasm(ea), db.get.string(res[tagname]))\n    continue\n</code></pre>\n <p>\n  As per the selected answer, the decompiler supports the simplification of expressions and in some situations can be a better choice. Taking inspiration from the plugin bundled with the weggli project at\n  <a href=\"https://github.com/weggli-rs/weggli\" rel=\"nofollow noreferrer\">\n   https://github.com/weggli-rs/weggli\n  </a>\n  , you can combine it with the decompiler to filter for certain expressions. Although this is experimental (in regards to minsc), there is a GH discussion on this toy at\n  <a href=\"https://github.com/arizvisa/ida-minsc/discussions/194\" rel=\"nofollow noreferrer\">\n   https://github.com/arizvisa/ida-minsc/discussions/194\n  </a>\n  . (Feel free to ask related questions there too).\n </p>\n <pre><code>import hexrays\nrefs = {ref for ref in func.up(ea) if 'x' in ref}\nfor cf in map(hexrays.function, refs):\n    for expr in hexrays.match(cf, 'threadSafeObjectAllocator_170b0(_);'):\n        call_expr = hexrays.tree.parent(cf, expr, opname='call')\n        print(hex(expr.ea), hexrays.repr(call_expr))\n    continue\n</code></pre>\n <p>\n  Results look like the following. At this point you can just follow the original answer to get from the\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcexpr__t-members.shtml\" rel=\"nofollow noreferrer\">\n   <code>\n    cexpr_t\n   </code>\n  </a>\n  of type\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/hexrays_8hpp.shtml#a8fff5d4d0a6974af5b5aa3feeebab2a0a04db2a2dc7ccd674cd65961a1cbfa946\" rel=\"nofollow noreferrer\">\n   <code>\n    cot_call\n   </code>\n  </a>\n  (stored as \"\n  <code>\n   call_expr\n  </code>\n  \") to the\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcnumber__t-members.shtml\" rel=\"nofollow noreferrer\">\n   <code>\n    cnumber_t\n   </code>\n  </a>\n  for your parameter, and then convert it to an integer in a similar way.\n </p>\n <pre><code>277a13da threadSafeObjectAllocator_170b0(1, 0x1A4u, 'WVMC', 0x4000, sub_277EC9B9, (void **)&lp_object_4)\n277bf49a threadSafeObjectAllocator_170b0(1, 0xC0u, 1213481296, 1, (void (__cdecl *)(void *))JSVDA::object_78250::destroy_67f69, (void **)&ap_result_14)\n277bf49a threadSafeObjectAllocator_170b0(1, 0x10u, 1196641612, 0x4000, (void (__cdecl *)(void *))sub_277BEDE1, (void **)(ap_result_14[45] + 28))\n277ca8bb threadSafeObjectAllocator_170b0(1, 0xCu, 'IPSF', 0x4000, sub_277A77CC, (void **)v34 + 10)\n277a5dc5 threadSafeObjectAllocator_170b0(1, 0xCu, 1230000966, 0x4000, sub_277A77CC, (void **)v69 + 10)\n...\n277b6c64 threadSafeObjectAllocator_170b0(1, av_size_8 + 0xA8, 'IEV', 0x4000, (void (__cdecl *)(void *))threadSafeHeapFree_177eb, (void **)&ap_result_14)\n277b6c25 threadSafeObjectAllocator_170b0(1, av_size_8 + 32, 'GES', 0x4000, jsvda_943, (void **)&ap_result_14)\n277b6c00 threadSafeObjectAllocator_170b0(1, av_size_8 + 16, 'CCV', 0x4000, (void (__cdecl *)(void *))threadSafeHeapFree_177eb, (void **)&ap_result_14)\n277b6b9e threadSafeObjectAllocator_170b0(1, av_size_8 + 52, 'AFV', 0x4000, (void (__cdecl *)(void *))threadSafeHeapFree_177eb, (void **)&ap_result_14)\n277b6bc3 threadSafeObjectAllocator_170b0(1, av_size_8 + 16, 'BCV', 0x4000, sub_277B8E42, (void **)&ap_result_14)\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Ali Rizvi-Santiago",
            "time": "Jul 20, 2024 at 2:27",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  As per the accepted answer in the referenced question, you can decompile each function referencing your target function, and then scrape your results out of the ctree representation. This can be done with the visitor pattern implemented by the\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structctree__visitor__t-members.shtml\" rel=\"nofollow noreferrer\">\n   <code>\n    ida_hexrays.ctree_visitor_t\n   </code>\n  </a>\n  class while filtering for the\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structctree__visitor__t-members.shtml\" rel=\"nofollow noreferrer\">\n   <code>\n    cot_call\n   </code>\n  </a>\n  expression type. The following closure implements a filter that collects each expression into a list.\n </p>\n <pre><code>import ida_hexrays\n\n# via ctree\ndef collect_exprs_with_op(body, ops):\n    res = []\n    class visitor_pattern_sucks(ida_hexrays.ctree_visitor_t):\n        def visit_expr(self, cexpr):\n            if cexpr.op in ops:\n                res.append(cexpr)\n            return 0\n    visitor_pattern_sucks(0).apply_to(body, None)\n    return res\n</code></pre>\n <p>\n  After that, you then need to collect references to your target function so that you can decompile each function containing a reference, and extract the full expression from the decompiler output.\n </p>\n <pre><code># vars to use for stuff\nea = int(whatever_address)\ndesired_argument_index = int(1)\n\n# collect references to address (calls and branches)\nrefs = []\nfor X in idautils.XrefsTo(ea):\n    if X.type in {idaapi.fl_CF, idaapi.fl_CN, idaapi.fl_JF, idaapi.fl_JN}:\n        refs.append(X.frm)\n    continue\n</code></pre>\n <p>\n  Next you need to use those references to decompile each function being referenced, and then use the\n  <code>\n   collect_exprs_with_op\n  </code>\n  function (that we defined) to collect all the\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/hexrays_8hpp.shtml#a8fff5d4d0a6974af5b5aa3feeebab2a0a04db2a2dc7ccd674cd65961a1cbfa946\" rel=\"nofollow noreferrer\">\n   <code>\n    cot_call\n   </code>\n  </a>\n  expressions. Afterwards, each\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcexpr__t-members.shtml\" rel=\"nofollow noreferrer\">\n   <code>\n    cexpr_t\n   </code>\n  </a>\n  can be filtered for any that match the list of references that were just used.\n </p>\n <pre><code># decompile the function associated w/ each reference.\ncollection = []\nfor fn in map(idaapi.get_func, refs):\n\n    # if idaapi.get_func returned None, then the reference\n    # isn't in a function and it can be skipped.\n    if not fn:\n        continue\n\n    # decompile function and use visitor to enumerate\n    # the entire ctree body for any citem that is \"cot_call\".\n    cfunc = ida_hexrays.decompile_func(fn)\n    exprs = collect_exprs_with_op(cfunc.body, {ida_hexrays.cot_call})\n\n    # filter each expression for an address that\n    # matches one of our references.\n    filtered = [cexpr for cexpr in exprs if cexpr.ea in refs]\n\n    # stash each expression into our list\n    collection.extend(filtered)\n</code></pre>\n <p>\n  Now that each expression has been collected, we can iterate through each\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/hexrays_8hpp.shtml#a8fff5d4d0a6974af5b5aa3feeebab2a0a04db2a2dc7ccd674cd65961a1cbfa946\" rel=\"nofollow noreferrer\">\n   <code>\n    cot_call\n   </code>\n  </a>\n  expression and extract the desired argument from its \"operands\". For\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/hexrays_8hpp.shtml#a8fff5d4d0a6974af5b5aa3feeebab2a0a04db2a2dc7ccd674cd65961a1cbfa946\" rel=\"nofollow noreferrer\">\n   <code>\n    cot_call\n   </code>\n  </a>\n  , the function arguments can be reached via the \"\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcexpr__t.shtml#a471b6908444d93f716a158eaf4b0a758\" rel=\"nofollow noreferrer\">\n   <code>\n    a\n   </code>\n  </a>\n  \" attribute which is of type\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcarglist__t.shtml\" rel=\"nofollow noreferrer\">\n   <code>\n    carglist_t\n   </code>\n  </a>\n  and can be treated as an array.\n </p>\n <pre><code># iterate through filtered expressions, collect the\n# arguments, select our desired index, and then stash\n# both the call expression and the argument we want.\nresults = []\nfor call in collection:\n    args = call.operands['a']\n    arg = args[desired_argument_index]\n    results.append((call, arg))\n</code></pre>\n <p>\n  Now the results contain the ctree expression for each call, and the\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcarg__t-members.shtml\" rel=\"nofollow noreferrer\">\n   <code>\n    carg_t\n   </code>\n  </a>\n  for the selected argument. If the expression type is a number, you can access it via the \"\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcexpr__t.shtml#a82540609a6ebe46a10274b946867d4de\" rel=\"nofollow noreferrer\">\n   <code>\n    n\n   </code>\n  </a>\n  \" attribute. If it's an expression, use the \"\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcexpr__t.shtml#adc89ce506f3b60d29c54de728b1bda99\" rel=\"nofollow noreferrer\">\n   <code>\n    x\n   </code>\n  </a>\n  \" attribute. If it's already your desired reference, you can access its address via \"\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcexpr__t.shtml#a886b8b66ad1e16eb7cbdc96dd87c2613\" rel=\"nofollow noreferrer\">\n   <code>\n    obj_ea\n   </code>\n  </a>\n  \". Each expression type and the attribute to use for its operands can be found in the\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/hexrays_8hpp.shtml\" rel=\"nofollow noreferrer\">\n   <code>\n    hexrays.hpp\n   </code>\n  </a>\n  file under the\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/hexrays_8hpp.shtml#a8fff5d4d0a6974af5b5aa3feeebab2a0\" rel=\"nofollow noreferrer\">\n   <code>\n    enum ctype_t\n   </code>\n  </a>\n  enumeration.\n </p>\n <pre><code>for call, arg in results:\n    print(hex(call.ea), call.dstr())\n    print(hex(arg.ea), arg.op, arg.dstr())\n</code></pre>\n <p>\n  That will output results that look like this.\n </p>\n <pre><code>277a13e5 threadSafeObjectAllocator_170b0(1, 0x1A4u, 'WVMC', 0x4000, sub_277EC9B9, (void **)&lp_object_4)\n277a13d0 61 'WVMC'\n277a16c9 threadSafeObjectAllocator_170b0(1, 0xCu, 4475977, 0x4000, sub_277F1377, (void **)&ap_result_14)\n277a16c0 61 4475977\n277a1a28 threadSafeObjectAllocator_170b0(1, sizeof(threadContext_19c5), 'TTTV', 0x4000, (void (__cdecl *)(void *))sub_277F128A, (void **)&lp_threadContext_4)\n277a1a1f 61 'TTTV'\n277a25d0 threadSafeObjectAllocator_170b0(1, 0xCu, 'IPSF', 0x4000, sub_277A77CC, (void **)&lp_objectFSPI_4)\n277a25c7 61 'IPSF'\n277a2620 threadSafeObjectAllocator_170b0(1, 0xCu, 'IPSF', 0x4000, sub_277A77CC, (void **)&lp_objectFSPI_4)\n...\n2780d98e threadSafeObjectAllocator_170b0(1, 0x34u, 'VIVN', 0x4000, sub_2780E590, (void **)((char *)ap_result_c + v39))\n2780d985 61 'VIVN'\n2780dcbe threadSafeObjectAllocator_170b0(1, 0x18u, 1414092366, 0x4000, sub_2780F124, (void **)&ap_result_14)\n2780dcb3 61 1414092366\n</code></pre>\n <p>\n  In order to convert a\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcnumber__t-members.shtml\" rel=\"nofollow noreferrer\">\n   <code>\n    cnumber_t\n   </code>\n  </a>\n  (from the \"\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcexpr__t.shtml#a82540609a6ebe46a10274b946867d4de\" rel=\"nofollow noreferrer\">\n   <code>\n    n\n   </code>\n  </a>\n  \" attribute) to a python integer, you'll need to get an instance of the\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/classtinfo__t-members.html\" rel=\"nofollow noreferrer\">\n   <code>\n    tinfo_t\n   </code>\n  </a>\n  to fit the integer to with\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcnumber__t.shtml#a25156e1b7b544653da4e14ba550f9f6b\" rel=\"nofollow noreferrer\">\n   <code>\n    cnumber_t.value\n   </code>\n  </a>\n  . In most cases you can be lazy and just create a\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/classtinfo__t-members.html\" rel=\"nofollow noreferrer\">\n   <code>\n    tinfo_t\n   </code>\n  </a>\n  for an integer.. However, to copy the parameter type from your target function you can grab its type and use\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/classtinfo__t.html#afd04a2f7e94d4d80ca358f3d3c060cd9\" rel=\"nofollow noreferrer\">\n   <code>\n    tinfo_t.get_nth_arg\n   </code>\n  </a>\n  .\n </p>\n <pre><code>prototype = idc.guess_func(ea)\nti = prototype.get_nth_arg(desired_argument_index)      # lazy: idaapi.tinfo_t(idaapi.BT_INT)\n\n# Output each integer.\nfor call, arg in results:\n    print(hex(arg.n.value(ti)))\n</code></pre>\n <p>\n  However, it's also probably worth noting that you can also use\n  <a href=\"https://hex-rays.com/products/decompiler/manual/sdk/structcexpr__t.shtml#a98b1df217695065a396c6c79e16513e9\" rel=\"nofollow noreferrer\">\n   <code>\n    cexpr_t.dstr\n   </code>\n  </a>\n  to render to a string and then parse it like that if you don't care to go this far.\n </p>\n <h1>\n  Disassembler\n </h1>\n <p>\n  If you prefer to avoid the decompiler for some reason (incorrect frames, not all refs are in a function, speed, etc.), you can utilise the parameter identification and tracking system (PIT) in some cases to locate the instruction responsible for passing the parameter to your target function. This PIT feature is what produces those comments containing the parameter name/type in the disassembly before calling a target function and can allow you to avoid having to extract the location information using the target function's prototype. You can access this information in IDAPython via the\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/typeinf_8hpp.html#a7ef863a47c0208d367489126c4a8ae6a\" rel=\"nofollow noreferrer\">\n   <code>\n    idaapi.get_arg_addrs\n   </code>\n  </a>\n  function.\n </p>\n <pre><code>candidates = []\nfor ea in refs:\n    locations = idaapi.get_arg_addrs(ea)\n    location = locations[desired_argument_index]\n    candidates.append(location)\n</code></pre>\n <p>\n  <em>\n   It is probably important to note that if there is more than one path that assigns the parameters needed to call a particular function, the\n   <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/typeinf_8hpp.html#a7ef863a47c0208d367489126c4a8ae6a\" rel=\"nofollow noreferrer\">\n    <code>\n     get_arg_addrs\n    </code>\n   </a>\n   api will prioritize the addresses of the parameters that are contiguous to the basic-block containing your target instruction (as opposed to the parameters initialized by the basic-block that branches to your target instruction).\n  </em>\n </p>\n <p>\n  After getting the address of each instruction responsible for passing the parameter that you are interested in, it is necessary to decode the instruction in order to extract your desired value out of its operands. For non-zero constants, it is pretty common that your value is an immediate that can be easily decoded out of the operand. In other cases, though, your value may be calculated by instructions prior to calling your target function. It is for this reason that it is generally recommended to use the decompiler's output which simplifies the inputs that are used for a function's parameters.\n </p>\n <p>\n  The next snippet uses the addresses collected via\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/typeinf_8hpp.html#a7ef863a47c0208d367489126c4a8ae6a\" rel=\"nofollow noreferrer\">\n   <code>\n    get_arg_addrs\n   </code>\n  </a>\n  to decode the instruction identified by the disassembler as corresponding to the target function's parameters. After decoding the instruction, the operands are checked in order to identify the one that is being used to modify memory (or register) in order to pass a value as a parameter. From the operand, we can extract the constant that we want and then save it for later.\n </p>\n <pre><code># this is not using reg_accesses_t vector (7.5), opting instead for\n# the CF_USE flags to identify the instruction operand being used.\nfor location in candidates:\n    insn = idaapi.insn_t()\n    length = idaapi.decode_insn(insn, location)\n\n    indices = [idaapi.CF_USE1, idaapi.CF_USE2, idaapi.CF_USE3, idaapi.CF_USE4, idaapi.CF_USE5, idaapi.CF_USE6, idaapi.CF_USE7, idaapi.CF_USE8]\n    used_operands = [index for index, flag in enumerate(indices) if insn.get_canon_feature() & flag]\n\n    # generally, something hacky like rendering the whole mnemonic\n    # or the operand as a string to process would also suffice.\n    operands = [insn.ops[index] for index in used_operands]\n    for op in operands:\n        if op.type in {idaapi.o_imm}:\n            immediates.append(op.value)\n        continue\n    continue\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Ali Rizvi-Santiago",
            "time": "Jul 20, 2024 at 1:44",
            "is_accepted": false,
            "comments": []
        }
    ]
}