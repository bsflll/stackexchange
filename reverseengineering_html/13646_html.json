{
    "title": "Using IDA to automatically annote dynamically imported functions in a driver",
    "link": "https://reverseengineering.stackexchange.com/questions/13646/using-ida-to-automatically-annote-dynamically-imported-functions-in-a-driver",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I've got an x64 Windows driver where a lot of functions are dynamically imported using\n  <code>\n   MmGetSystemRoutineAddress\n  </code>\n  . The function takes a\n  <code>\n   UNICODE_STRING\n  </code>\n  as a parameter to tell it what function to find and you can often see this being initialised just before the call which is how I'm checking what it's importing.\n </p>\n <p>\n  Is there anyway to automatically mark what this function is importing rather than having to manually go to each call and check? I imagine using IDC or IDAPython would be the best solution.\n </p>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "598",
    "tags": [
        "ida",
        "windows",
        "idapython",
        "driver"
    ],
    "user": "Peanut",
    "time": "Oct 5, 2016 at 22:04",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I've written an IDAPython script that searches for a string in the bytes preceding\n  <code>\n   MmGetSystemRoutineAddress\n  </code>\n  and\n  <code>\n   FltGetRoutineAddress\n  </code>\n  calls and then marks that call with the function being imported. It worked on the x64 and x86 drivers I had to hand but I've left my commented out debug prints in just in case.\n </p>\n <p>\n  Here's an example of the disassembly after running the script:\n  <a href=\"https://i.sstatic.net/gG3Er.jpg\" rel=\"nofollow noreferrer\">\n   <img alt=\"output\" src=\"https://i.sstatic.net/gG3Er.jpg\"/>\n  </a>\n </p>\n <p>\n  And of the output:\n </p>\n <pre><code>Getting string xrefs\nTrying to find MmGetSystemRoutineAddress...\nFound MmGetSystemRoutineAddress @ 1C00092E0\nFound 7 xrefs to MmGetSystemRoutineAddress\n\nMmGetSystemRoutineAddress called @ 1C000B022 in func sub_1C000B000\n    1C000B00D  lea     rdx, aPsgetversion; \"PsGetVersion\"\n  Found an Xref to a string in preceding 50 bytes\n  Searching for use of returned func pointer...\n    1C000B022  call    cs:MmGetSystemRoutineAddress; PsGetVersion  - auto added\n    1C000B028  lea     rdx, aWmitracemessag; \"WmiTraceMessage\"\n    1C000B02F  mov     cs:PsGetVersion, rax\n  Found mov to global data\n  Found the pointer being stored! Marking it\n</code></pre>\n <p>\n  There's definitely improvements that could be made:\n </p>\n <ul>\n  <li>\n   Make sure that the dynamic importing function xref is an actual call\n  </li>\n  <li>\n   <strike>\n    The function pointer result is often put into a global pointer (i.e.\n    <code>\n     mov dword_444E0, eax\n    </code>\n    ), having this pointer automatically named would be very useful.\n   </strike>\n  </li>\n  <li>\n   <strike>\n    The other common use case is seeing it being called straight after (i.e.\n    <code>\n     call eax\n    </code>\n    ) so having this call marked would be nice.\n   </strike>\n  </li>\n </ul>\n <p>\n  I'll have a look at making these improvements and updating when I can.\n </p>\n <pre><code>#Using Sark would have made the line iteration a bit nicer but I wanted \n#something I could use anywhere without any external dependencies\n\nimport idc\nimport idautils\nimport idaapi\n\n'''\nReturns - String xrefs. Dict of  xref_location[tuple of (str address, str value)]\n'''\ndef get_string_xrefs():\n    #Get the strings so we can see what might have been passed in\n    print \"Getting string xrefs\"\n    sc = idautils.Strings(default_setup = False)\n    # we want C & Unicode strings, and *only* existing strings.\n    sc.setup(strtypes=(Strings.STR_C | Strings.STR_UNICODE), \n            ignore_instructions = True, \n            display_only_existing_strings = True)\n\n    #Make a list of all string locations\n    string_locs = []\n    for s in sc:\n        string_locs.append((s.ea, str(s)))\n        #print \"%x: len=%d type=%d -> '%s'\" % (s.ea, s.length, s.type, str(s))\n\n    #Make a dict of all places strings are Xrefs\n    string_xrefs = {}\n    for loc in string_locs:\n        #print \"%08X  %s\" % (loc[0], loc[1])\n        for xref in idautils.XrefsTo(loc[0]):\n            #print \"Xref @ %08X\" % xref.frm\n            string_xrefs[xref.frm] = loc\n\n    return string_xrefs\n\n'''\ndynam_loading_func_name - The function used to dynamically load the functions\nstring_xrefs            - String xrefs. Dict of  xref_location[tuple of (str address, str value)]\n'''\ndef markup_dynamically_loaded_funcs(dynam_loading_func_name, string_xrefs, num_search_bytes_string = 50, num_search_bytes_use = 30):\n    print \"Trying to find %s...\" % dynam_loading_func_name\n\n    getsys_addr = idc.LocByName(dynam_loading_func_name)\n    print \"Found %s @ %08X\" % (dynam_loading_func_name, getsys_addr)\n\n    num_xrefs = sum(1 for i in idautils.CodeRefsTo(getsys_addr, 0))\n    print \"Found %d xrefs to %s\" % (num_xrefs, dynam_loading_func_name)\n\n    #Iterate through each Xref to dynamic loading func and see if a string is used in the preceding instructions...\n    for dynam_xref in idautils.CodeRefsTo(getsys_addr, 0):\n        print \"\n%s called @ %08X in func %s\" % (dynam_loading_func_name, dynam_xref, idc.GetFunctionName(dynam_xref))\n\n        #Start at line above dynamic loading func call\n        new_ea = idaapi.get_item_head(dynam_xref - 1)\n\n        #Continue until we've gone back 50 bytes or found a string\n        while new_ea > dynam_xref - num_search_bytes_string:        \n            #print \"    %08X  %s\" % (new_ea, idc.GetDisasm(new_ea))\n\n            #Go to the line above\n            new_ea = idaapi.get_item_head(new_ea-1)\n\n            #Check if the address is an xref to a string\n            if new_ea in string_xrefs:\n                print \"    %08X  %s\" % (new_ea, idc.GetDisasm(new_ea))\n                print \"  Found an Xref to a string in preceding %d bytes\" % num_search_bytes_string\n\n                #Make the comment to add\n                imported_func_name = string_xrefs[new_ea][1]\n                comment = imported_func_name + \"  - auto added\"\n\n                #Add the comment to the dynamic loading func call\n                idc.MakeComm(dynam_xref, comment)\n\n                print \"  Searching for use of returned func pointer...\"\n\n                #Start at line past dynamic loading func, go forward one at a time (up to 30 bytes) till we find either:\n                #  -  a call to rax or eax\n                #  -  a mov of rax or eax into a global pointer\n                ptr_search_addr = dynam_xref\n                while ptr_search_addr < dynam_xref + num_search_bytes_use:\n                    print \"    %08X  %s\" % (ptr_search_addr, idc.GetDisasm(ptr_search_addr))\n                    ptr_search_addr += idaapi.get_item_size(ptr_search_addr)\n\n                    #Check for 'call rax' or 'call eax'\n                    if idc.GetMnem(ptr_search_addr) == \"call\" and idc.GetOpnd(ptr_search_addr,0) in [\"rax\", \"eax\"]:\n                        print \"    %08X  %s\" % (ptr_search_addr, idc.GetDisasm(ptr_search_addr))\n                        print \"  Found a call! Marking it\"\n\n                        ##Comment it and stop checking for this string\n                        idc.MakeComm(ptr_search_addr, comment)\n                        break\n\n                    data_sec_start = idaapi.get_segm_by_name(\".data\").startEA\n                    data_sec_end = idaapi.get_segm_by_name(\".data\").endEA\n\n                    #Need to check for mov into global data, avoid situations like:\n                    #call MmGetSystemRoutineAddress\n                    #mov ecx, eax\n                    #mov dword_12345, ecx\n                    #Check for first 'mov' instruction and what it's moving to is in global data\n                    if idc.GetMnem(ptr_search_addr) == \"mov\" and \\\n                    data_sec_start < GetOperandValue(ptr_search_addr, 0) < data_sec_end:\n                        print \"  Found mov to global data\"\n                        #print \"    %08X\" % GetOperandValue(ptr_search_addr, 0)\n\n                        print \"  Found the pointer being stored! Marking it\"\n\n                        ptr_addr = GetOperandValue(ptr_search_addr, 0)\n\n                        #TODO: Validate address is in right section\n\n                        #Change the name, can't reuse names so keep trying till it works\n                        count = 1\n                        new_name = imported_func_name\n                        while not idc.MakeNameEx(ptr_addr, new_name, SN_NOWARN):\n                            new_name = imported_func_name + \"_\" + str(count)\n                            print \"%s is in use, using %s instead\" % (imported_func_name, new_name)\n                            count += 1\n                        break\n                else:\n                    print \"**************************************************\"\n                    print \"*****                                        *****\"\n                    print \"***** Didn't find a call or pointer storage! *****\"\n                    print \"*****                                        *****\"\n                    print \"**************************************************\"\n\n\n                #End the search for the string\n                break\n\ndef main():\n    string_xrefs = get_string_xrefs()\n\n    markup_dynamically_loaded_funcs(\"MmGetSystemRoutineAddress\", string_xrefs)\n    print \"\n\n\n\n\n\n\n\n\n\n\n\n\n\"\n    markup_dynamically_loaded_funcs(\"FltGetRoutineAddress\", string_xrefs)\nmain()\n</code></pre>\n</div>\n</body></html>",
            "votes": "2",
            "user": "Peanut",
            "time": "Oct 9, 2016 at 19:38",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Peanut",
                    "text": "<span class=\"comment-copy\">This was my first IDAPython script and my Python isn't strong so feel free to make comments/suggestions for improvement.</span>",
                    "time": null
                }
            ]
        }
    ]
}