{
    "title": "Where the pointer to virtual function table is located?",
    "link": "https://reverseengineering.stackexchange.com/questions/4428/where-the-pointer-to-virtual-function-table-is-located",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I used to think that the pointer to the Virtual Function Table (VFT, also Virtual Method Table, VMT) is the very first 32-bit word of the object binary representation.\n </p>\n <p>\n  But now I see a VFT whose index is 13 (!!!!), that is, offset=0x34. (I write \"index\" because the code to invoke the Qt function\n  <code>\n   o.metaObject()\n  </code>\n  is\n  <code>\n   ((func***)o)[13][0](o)\n  </code>\n  ). OMG, what is going on? Why the VFT address is located... where?\n </p>\n <p>\n  EDIT (after complaints that the question is unclear):\n </p>\n <p>\n  Each object with virtual functions has a pointer to the Virtual Function Table. Usually, this is the very first 32-bit value in the object's binary representation (and may be accessed as\n  <code>\n   ((void**)objAddr)[0]\n  </code>\n  ). But in the example below the offset of VMT pointer is not 0! (Function names may be demangled by\n  <a href=\"http://linux.die.net/man/1/c++filt\" rel=\"nofollow\">\n   <code>\n    c++filt\n   </code>\n  </a>\n  ; for readability, the class names have been shortened to\n  <code>\n   Abc\n  </code>\n  and\n  <code>\n   Xyz\n  </code>\n  ):\n </p>\n <pre><code>.text:02EF171C _ZN3XyzC2EP7QObject ; constructor Xyz::Xyz(QObject*), r0 = objAddr, r1 = QObject addr\n.text:02EF171C                 PUSH.W          {R4-R8,LR}\n.text:02EF1720                 MOV             R4, R0\n.text:02EF1722                 LDR             R5, =(_GLOBAL_OFFSET_TABLE_ - 0x02EF1730)\n.text:02EF1724                 MOV             R7, R1\n.text:02EF1726                 BL.W            _ZN4AbcdC2EP7QObject ; superclass_constructor(objAddr)\n.text:02EF172A ; ---------------------------------------------------------------------------\n.text:02EF172A                 LDR             R3, =(_ZTVN3XyzE_ptr - 0x27E4BE0) ; vtable for Xyz\n.text:02EF172C                 ADD             R5, PC ; _GLOBAL_OFFSET_TABLE_\n.text:02EF172E                 MOV             R6, R4\n.text:02EF1730                 MOV             R1, R7\n.text:02EF1732                 LDR             R3, [R5,R3] ; _ZTVN3XyzE_ptr ; pointer to vtable for Xyz\n.text:02EF1734                 ADDS            R3, #8 ; *_ptr points to the (-2)nd element of VMT\n.text:02EF1736                 STR.W           R3, [R6],#0x34 ; OOPS! the offset is 0x34 !!!\n</code></pre>\n <p>\n  <em>\n   I want to be able to locate the pointer to VMT for any object,\n  </em>\n  but as the example above shows, the pointer to VMT is not necessarily\n  <code>\n   ((void**)objAddr)[0]\n  </code>\n  .\n </p>\n <p>\n  So the question is:\n </p>\n <p>\n  1)\n  <strong>\n   <em>\n    why the VMT pointer is in the middle of the object's binary representation?\n   </em>\n  </strong>\n  There must be something specific about this place.\n </p>\n <p>\n  2)\n  <strong>\n   <em>\n    how do I find out where the VMT pointer actually is?\n   </em>\n  </strong>\n  (Ideally, at run-time given the object address. I have the code to tell a valid address from an invalid one. I'm interested in GCC for Android/ARM, although techniques for different platforms may turn out to be applicable.)\n </p>\n <p>\n  PS the code to detect a valid address on Android is:\n </p>\n <pre><code>#include <unistd.h>\n#include <fcntl.h>\nint isValidPtr(const void*p, int len) {\n    if (!p) { return 0; }\n    int ret = 1;\n    int nullfd = open(\"/dev/random\", O_WRONLY); // does not work with /dev/null !!!\n    if (write(nullfd, p, len) < 0) {\n        ret = 0; /* Not OK */\n    }\n    close(nullfd);\n    return ret;\n}\n</code></pre>\n <p>\n  UPDATE\n </p>\n <p>\n  In the following example, the VMT offset is 0:\n </p>\n <pre><code>class Base {\npublic:\n  int x,y;\n};\nclass Derived: public Base {\npublic:\n  int z;\n  Derived();\n  virtual int func();\n  virtual int func2();\n};\n</code></pre>\n <p>\n  Coercion from\n  <code>\n   Base*\n  </code>\n  to\n  <code>\n   Derived*\n  </code>\n  compiles to:\n  <code>\n   SUBS R0, #4\n  </code>\n </p>\n <pre><code>int test3(Base*b) {\n    Derived*d = (Derived*)b;\n    int r = addDerived(*d);\n    return r;\n}\n\n ; test3(Base *)\n _Z5test3P4Base\n CBZ             R0, loc_1C7A\n SUBS            R0, #4\n B.W             _Z10addDerivedR7Derived ;\n</code></pre>\n <p>\n  UPDATE2\n </p>\n <p>\n  I tried\n </p>\n <pre><code>struct Cls2 {\n    unsigned x[13];\n    Derived d;\n    Cls2();\n};\n</code></pre>\n <p>\n  and here's the disassembly:\n </p>\n <pre><code>.text:00001CE2 _ZN4Cls2C2Ev ; Cls2::Cls2(void)\n.text:00001CE2                 PUSH            {R4,LR}\n.text:00001CE4                 MOV             R4, R0\n.text:00001CE6                 ADD.W           R0, R0, #0x34\n.text:00001CEA                 BL              _ZN7DerivedC2Ev ; Derived::Derived(void)\n.text:00001CEE                 MOV             R0, R4\n.text:00001CF0                 POP             {R4,PC}\n</code></pre>\n <p>\n  That is, the VFT pointer of\n  <code>\n   Cls2::d\n  </code>\n  will indeed be at offset 0x34, but there's no\n  <code>\n   STR.W R3,[R6],#0x34\n  </code>\n  , so it is not #2 suggested by Willem Hengeveld.\n </p>\n <p>\n  BUT if we comment out the constructor,\n </p>\n <pre><code>struct Cls2 {\n    unsigned x[13];\n    Derived d;\n//    Cls2();\n};\n</code></pre>\n <p>\n  in\n </p>\n <pre><code>int testCls2() {\n    Cls2 c;\n    return c.d.func2();\n}\n</code></pre>\n <p>\n  we get\n </p>\n <pre><code>.text:00001C9E _Z8testCls2v\n.text:00001C9E var_18          = -0x18\n.text:00001C9E                 PUSH            {LR}\n.text:00001CA0                 SUB             SP, SP, #0x4C\n.text:00001CA2                 ADD             R0, SP, #0x50+var_18\n.text:00001CA4                 BL              _ZN7DerivedC2Ev ; Derived::Derived(void)\n.text:00001CA8                 ADD             R0, SP, #0x50+var_18\n.text:00001CAA                 BL              _ZN7Derived5func2Ev ; Derived::func2(void)\n.text:00001CAE                 ADD             SP, SP, #0x4C\n.text:00001CB0                 POP             {PC}\n</code></pre>\n <p>\n  which is very similar to the original code\nBUT in my case the VMT\n  <code>\n   vtable for Xyz\n  </code>\n  is written from\n  <code>\n   Xyz::Xyz()\n  </code>\n  and not from the enclosing function.\n </p>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 2,
    "views": "5k",
    "tags": [
        "c++",
        "arm",
        "virtual-functions",
        "gcc"
    ],
    "user": "18446744073709551615",
    "time": "May 27, 2014 at 6:19",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<html><body><span class=\"comment-copy\">\n Show the code/asm/whatever. It's not clear what you mean by \"index\".\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Willem Hengeveld",
            "text": "<html><body><span class=\"comment-copy\">\n the call to Derived::Derived(void) could have been inlined with the right optimization flags.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "DCoder",
            "text": "<html><body><span class=\"comment-copy\">\n Based on the way you keep editing your question, you might want to read through\n <a href=\"http://smile.amazon.com/dp/0201834545/\" rel=\"nofollow noreferrer\">\n  <i>\n   Inside The C++ Object Model\n  </i>\n </a>\n . It contains a lot more information than can be given in a single answer.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I can think of 2 cases where a VMT is not in the first word of an object:\n </p>\n <ul>\n  <li>\n   using multiple inheritance\n  </li>\n  <li>\n   when the an object has a member variable which has virtual methods\n  </li>\n </ul>\n <h2>\n  multiple inheritance\n </h2>\n <pre><code>struct base1 {\n    uint32_t x[12];\n    virtual void m1() { }\n};\n\n\nstruct base2 {\n    virtual void m2() { }\n};\n\nstruct cls : base1, base2 {\n};\n</code></pre>\n <p>\n  now the VMT of base2 is at offset 0x34\n </p>\n <h2>\n  virtual member\n </h2>\n <pre><code>struct cls2 {\n    uint32_t x[13];\n    base2   b;\n};\n</code></pre>\n <p>\n  now also the VMT of base2 is at offset 0x34\n </p>\n</div>\n</body></html>",
            "votes": "5",
            "user": "Willem Hengeveld",
            "time": "May 26, 2014 at 10:47",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The code to detect and print virtual function table pointers is:\n </p>\n <pre><code>int isIdentifier(const char* s) { // true if points to [0-9a-zA-Z_]*\\x00\n    if(!isValidPtr(s,0x10)) { return 0; }\n    if(!s[0]) { return 0; }\n    int i;\n    for (i=0; s[i] && i<512; i++) {\n        if( i/0x10 && i%0x10 == 0 && !isValidPtr(s,0x10)) { return 0; }\n        unsigned char c = s[i];\n        if ('0'<=c && c<='9' || 'a'<=c && c <= 'z' || 'A'<=c && c <= 'Z' || '_' == c) {\n        } else {\n            return 0;\n        }\n    }\n    return !s[i];\n}\n\nchar* isVftPtr(void*addr) { // returns addr of mangled class name (prefix it with _Z to demangle with c++filt)\n    unsigned int* vmtaddr = isValidPtr(addr,4)\n                     && 0 == (3 & *(int*)addr)\n                     && isValidPtr(*(int**)addr,4)\n                     ? *(unsigned int**)addr\n                     : (void*)0;\n    if (vmtaddr\n      &&isValidPtr(vmtaddr-2,0x20)\n     ) {\n        char**ptypeinfo = ((char***)vmtaddr)[-1];\n        if (isValidPtr(ptypeinfo,4)\n          &&isValidPtr((char***)ptypeinfo[0]-1,8)\n          &&isValidPtr(((char***)ptypeinfo[0])[-1],8)\n          &&isValidPtr(((char***)ptypeinfo[0])[-1][1],0x20)\n          &&isIdentifier(ptypeinfo[1])\n        ) {\n            return !strncmp(((char***)ptypeinfo[0])[-1][1], \"N10__cxxabiv\",12) ? ptypeinfo[1] : 0;\n        }\n    }\n    return 0;\n}\n// Usage example: printVfts(\"pThis\", pThis, -8, 0x400)\nvoid printVfts(const char*tag, void* addr, int from, int upto) {\n    void** start = addr+from;\n    void** end = addr+upto;\n    DLOG(\"{ %s ====== printVfts %p (%p..%p)\", tag, addr,start,end);\n    void**p;\n    char*n = 0;\n    for(p=addr;p<end;p++) {\n        if (n = isVftPtr(p)) {\n            DLOG(\"vft at %p [off=0x%x] _Z%s\",p,(unsigned)p - (unsigned)addr, n);\n        }\n    }\n    DLOG(\"} %s ====== printVfts %p\", tag, addr);\n}\n</code></pre>\n <p>\n  The code worked on Android/ARM.\n </p>\n <p>\n  The function\n  <code>\n   isValidPtr()\n  </code>\n  is given in the question, the logging macro is given below:\n </p>\n <pre><code>#include <android/log.h>\n#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG  , \"~~~~~~\", __VA_ARGS__)\n#define DLOG(...) __android_log_print(ANDROID_LOG_DEBUG  , \"~~~~~~\", __VA_ARGS__)\n</code></pre>\n <p>\n  <strong>\n   And, finally:\n  </strong>\n  <code>\n   printVfts()\n  </code>\n  showed that there is another VFT pointer at offset 0.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "18446744073709551615",
            "time": "May 27, 2014 at 10:42",
            "is_accepted": false,
            "comments": []
        }
    ]
}