{
    "title": "Is it possible to capture the standard output of a process in Ollydbg?",
    "link": "https://reverseengineering.stackexchange.com/questions/6350/is-it-possible-to-capture-the-standard-output-of-a-process-in-ollydbg",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm debugging an out-of-process COM server (an EXE), started by a dummy application I wrote. I attach the debugger when the instance is created and let the dummy application make calls to the server.\n </p>\n <p>\n  In the debugged process, I can see that it does lots of logging by calling sprintf. I would like to capture this output. Is there a way to do this with OllyDbg 2.01?\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 3,
    "views": "1k",
    "tags": [
        "ollydbg"
    ],
    "user": "Tam√°s Szelei",
    "time": "Oct 1, 2014 at 10:47",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  <code>\n   sprintf\n  </code>\n  is a crt function superseded by\n  <code>\n   sprintf_s\n  </code>\n  both take a\n  <code>\n   destination\n  </code>\n  a\n  <code>\n   format string\n  </code>\n  and\n  <code>\n   varargs\n  </code>\n  no of arguments can range from\n  <code>\n   one to several\n  </code>\n  depending on the format string.\n </p>\n <p>\n  code for both these functions are normally embedded inside the binary (static) and needs to be located and a preparatory step needs to be done prior to logging the output that will get sprintf'fed to the Destination Buffer;\n </p>\n <p>\n  <strong>\n   Ollydbg 1.10\n  </strong>\n </p>\n <p>\n  output below shows both the start of both sprintf versions (note src is available for vc compiled exes cycle the comment column to make src visible)\n </p>\n <pre><code>sprintf \n00401147 >/$  8BFF          MOV     EDI, EDI         ; { sprintf.c:99. \n\n00401120 >/$  55            PUSH    EBP                              \n; __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s,\n _Deref_post_z_ char, _Dest, _In_z_ _Printf_format_string_ const char *, \n_Format) stdio.h:323. \n</code></pre>\n <p>\n  select the start of function \nright click analysis -> assume arguments -> select Sformat(ptr,format,.....) apply\n </p>\n <p>\n  output post assume argument operation  cycle back to comment from src\n </p>\n <pre><code>00401147 >/$  8BFF          MOV     EDI, EDI     ;  Decoded as <Sformat>\n\n00401120 >/$  55            PUSH    EBP          ;  Decoded as <Sformat>\n</code></pre>\n <p>\n  now all you need is a non breaking conditional breakpoint to log all the sprintf output\n </p>\n <pre><code>select the start of function and click shift+f4 \n</code></pre>\n <p>\n  set radio buttons as follows for both version\n </p>\n <pre><code>pause radio button                     never \nlog expression radio button            never \nlog function arguments radio button    always \n</code></pre>\n <p>\n  now simply f9 and you will have all the sprintf arguments logged to log window or a file you specify (right click in log window to set up file logging )\n </p>\n <pre><code>Breakpoints\nAddress                            Module              Active \n00401120 sprintlo.sprintf_s<128>   sprintlo            Log \"logging sprintf_s_arguments\"\n00401147 sprintlo.sprintf          sprintlo            Log \"logging sprint arguments\" \n</code></pre>\n <p>\n  here is a sample output\n </p>\n <pre><code>Log data\nCALL to Assumed Sformat from sprintlo.0040104F\n  ptr = 0013FEE0\n  format = \"%s    %03d %s %p\"\n  <%s> = \"sprint logging number\"\n  <%03d> = 0\n  <%s> = \"logme\"\n  <%p> = sprintlo.00401105\nCALL to Assumed Sformat from sprintlo.004010BF\n  ptr = 0013FEE0\n  format = \"%s    %03d %s %p\"\n  <%s> = \"sprint logging number\"\n  <%03d> = 0\n  <%s> = \"logme\"\n  <%p> = sprintlo.00401111\n  ==================================================================================\nCALL to Assumed Sformat from sprintlo.0040104F\n  ptr = 0013FEE0\n  format = \"%s    %03d %s %p\"\n  <%s> = \"sprint logging number\"\n  <%03d> = 4\n  <%s> = \"logme\"\n  <%p> = sprintlo.00401105\nCALL to Assumed Sformat from sprintlo.004010BF\n  ptr = 0013FEE0\n  format = \"%s    %03d %s %p\"\n  <%s> = \"sprint logging number\"\n  <%03d> = 4\n  <%s> = \"logme\"\n  <%p> = sprintlo.00401111\nProcess terminated, exit code 0\n</code></pre>\n <p>\n  code used for demonstration\n </p>\n <pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <intrin.h>\nvoid insecuresprintf(int in) {\n    char dummybuff[0x80];\n    memset(dummybuff,0,sizeof(dummybuff));\n    void* pvAddressOfReturnAddress = _AddressOfReturnAddress();    \n    sprintf(\n        dummybuff,\n        \"%s    %03d %s %p\\0\\0\",\"sprint logging number\" ,\n        in,\"logme\",*((void**) pvAddressOfReturnAddress)\n        );\n    return;\n}\nvoid securesprintf(int in) {\n    char dummybuff[0x80];\n    memset(dummybuff,0,sizeof(dummybuff));\n    void* pvAddressOfReturnAddress = _AddressOfReturnAddress();    \n    sprintf_s(\n        dummybuff,\n        \"%s    %03d %s %p\\0\\0\",\"sprint logging number\" ,\n        in,\"logme\",*((void**) pvAddressOfReturnAddress)\n        );\n    return ;\n}\nint main (void) { \n    for (int i =0; i<5; i++)    {\n        insecuresprintf(i);\n        securesprintf(i);\n    }\n    return 0;\n}\n</code></pre>\n <p>\n  <strong>\n   ollydbg 2.01\n  </strong>\n </p>\n <p>\n  instead of analysis assume arguments you have to shift + f4 directly and specify the function type there  use format 2A (arg1,format,.....) but there is a bug in the function because of which the resulting strings are truncated out\n </p>\n <pre><code>INT3 breakpoints\nAddress   Module    Status       Disassembly                              Comment\n00401120 >sprintlog Cond         PUSH    EBP                              INT sprintlog.sprintf_s<128>(_Dest,_Format)\n00401147 >sprintlog Cond         MOV     EDI, EDI                         INT sprintlog.sprintf(string,format)\n</code></pre>\n <p>\n  output from ollydbg 2.01 (notice %03d showing correct values but %p %s output are not visible )\n </p>\n <pre><code>Log data\n00401147  Call to sprintlog.sprintf from sprintlog.0040104F\n        0013FEE0  Arg1 = 13FEE0\n        004131AC  Format = \"%s    %03d %s %p\"\n        00413194  <%s> =\n        00000000  <%03d> =\n        0041318C  <%s> =\n        00401105  <%p> =\n00401120  Call to sprintlog.sprintf_s<128> from sprintlog.004010BF\n        0013FEE0  Arg1 = 13FEE0\n        004131E0  Format = \"%s    %03d %s %p\"\n        004131C8  <%s> =\n        00000000  <%03d> =\n        004131C0  <%s> =\n        00401111  <%p> =\n========================================================================================\n00401147  Call to sprintlog.sprintf from sprintlog.0040104F\n        0013FEE0  Arg1 = 13FEE0\n        004131AC  Format = \"%s    %03d %s %p\"\n        00413194  <%s> =\n        00000004  <%03d> =\n        0041318C  <%s> =\n        00401105  <%p> =\n00401120  Call to sprintlog.sprintf_s<128> from sprintlog.004010BF\n        0013FEE0  Arg1 = 13FEE0\n        004131E0  Format = \"%s    %03d %s %p\"\n        004131C8  <%s> =\n        00000004  <%03d> =\n        004131C0  <%s> =\n        00401111  <%p> =\n      Process terminated, exit code 0\n</code></pre>\n <p>\n  btw it is incredibly simple with windbg\n </p>\n <pre><code>0:000> x *!sprintf*\n7c925bc4 ntdll!sprintf = <no type information>\n00401147 sprintlog!sprintf (void)\n004011e7 sprintlog!sprintf_s (void)\n00401120 sprintlog!sprintf_s<128> (char (*)[128], char *)\n0:000> bp 00401120 \"r $t1 = poi(@esp+4) ; gu; .printf \\\"%ma\\\n\\\", @$t1 ; gc\"\n0:000> bp 00401147 \"r $t1 = poi(@esp+4) ; gu; .printf \\\"%ma\\\n\\\", @$t1 ; gc\"\n0:000> .bpcmds\nbp0 0x00401120  \"r $t1 = poi(@esp+4) ; gu; .printf \\\"%ma\\\n\\\", @$t1 ; gc\";\nbp1 0x00401147  \"r $t1 = poi(@esp+4) ; gu; .printf \\\"%ma\\\n\\\", @$t1 ; gc\";\n0:000> g\nModLoad: 5cb70000 5cb96000   C:\\WINDOWS\\system32\\ShimEng.dll\nsprint logging number    000 logme 00401105\nsprint logging number    000 logme 00401111\nsprint logging number    001 logme 00401105\nsprint logging number    001 logme 00401111\nsprint logging number    002 logme 00401105\nsprint logging number    002 logme 00401111\nsprint logging number    003 logme 00401105\nsprint logging number    003 logme 00401111\nsprint logging number    004 logme 00401105\nsprint logging number    004 logme 00401111\n</code></pre>\n</div>\n</body></html>",
            "votes": "3",
            "user": "blabb",
            "time": "Oct 1, 2014 at 20:10",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I can think of these options:\n </p>\n <p>\n  1) Edit the .exe flags to mark it as a console process. E.g.\n </p>\n <pre><code>EDITBIN /SUBSYSTEM:CONSOLE comserver.exe\n</code></pre>\n <p>\n  2) Use the debugger to call to\n  <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms681944\" rel=\"nofollow\">\n   <code>\n    AllocConsole()\n   </code>\n  </a>\n  at runtime.\n </p>\n <p>\n  3) Put a breakpoint on the logging function and log the string contents in the breakpoint's action (not sure if it's doable in OllyDbg).\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Igor Skochinsky",
            "time": "Oct 1, 2014 at 11:00",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  sprintf doesnt \"log\" to standard output. it prints to a variable.\n </p>\n <p>\n  anyways: you could use a OllyDbgScript which sets a BP on sprintf and then use\n  <code>\n   BPGOTO\n  </code>\n  command to do some actions like dump the formatted variable and run again.\n </p>\n</div>\n</body></html>",
            "votes": "0",
            "user": "pHiL",
            "time": "Oct 1, 2014 at 12:04",
            "is_accepted": false,
            "comments": []
        }
    ]
}