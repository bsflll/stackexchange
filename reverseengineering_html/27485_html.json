{
    "title": "Comparing the static address of the vtable of a class, to the pointer to it held by the object",
    "link": "https://reverseengineering.stackexchange.com/questions/27485/comparing-the-static-address-of-the-vtable-of-a-class-to-the-pointer-to-it-held",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I know this is compiler/ABI dependent, not necessarily standardized, etc. I've always assumed, from what I've read in several places (e.g.\n  <a href=\"https://reverseengineering.stackexchange.com/a/5957/33935\">\n   an answer here\n  </a>\n  or\n  <a href=\"https://en.wikipedia.org/w/index.php?title=Virtual_method_table&oldid=1007338497#Example\" rel=\"nofollow noreferrer\">\n   the example in wikipedia\n  </a>\n  ), that a typical thing a compiler does is having a pointer to the vtable of\n  <code>\n   Class\n  </code>\n  at the start of an object of type\n  <code>\n   Class\n  </code>\n  .\n </p>\n <p>\n  I'm now debugging and instrumenting a function that receives a\n  <code>\n   Class*\n  </code>\n  parameter.\n  <code>\n   Class\n  </code>\n  has virtual functions. I want to\n  <strong>\n   determine if it belongs to a class\n  </strong>\n  that I care about. I probably also want to do other things with it, so I'm trying to get a good understanding.\n </p>\n <p>\n  I look at the disassembly in Ghidra, and I find this about the vtable of that class (paste is coming from an example I wrote, but it's equivalent in a real binary that I want to RE):\n </p>\n <pre><code>                             **************************************************************\n                             * vtable for DerivedClass                                    *\n                             **************************************************************\n                             _ZTV12DerivedClass                              XREF[3]:     Entry Point(*), \n                             DerivedClass::vtable                                         operator():001039d1(*), \n                                                                                          _elfSectionHeaders::00000650(*)  \n        00107c70 00 00 00        ptrdiff_\n                 00 00 00 \n                 00 00\n           00107c70 [0]                                  0h\n        00107c78 88 7c 10        addr       DerivedClass::typeinfo                           = \n                 00 00 00 \n                 00 00\n                             PTR_ARRAY_00107c80                              XREF[2]:     operator():001039d8(*), \n                                                                                          operator():001039dc(*)  \n        00107c80 94 42 10        addr[1]\n                 00 00 00 \n                 00 00\n           00107c80 94 42 10 00 00  addr      DerivedClass::someVirt  [0]                               XREF[2]:     operator():001039d8(*), \n                    00 00 00                                                                                         operator():001039dc(*)  \n\n</code></pre>\n <p>\n  And here is where my surprise is:\n </p>\n <ol>\n  <li>\n   I get the address of\n   <code>\n    _ZTV12DerivedClass\n   </code>\n   (e.g. via Frida,\n   <code>\n    Module.findExportByName(null, \"_ZTV12DerivedClass\")\n   </code>\n   or in GDB,\n   <code>\n    info address _ZTV12DerivedClass\n   </code>\n   ).\n  </li>\n  <li>\n   I get the address of the vtable of the object (it's 64 bits, so 8 first bytes of the object), again, in the debugger or with Frida.\n  </li>\n  <li>\n   I compare the two, and I get that\n   <em>\n    they are 16 bytes away\n   </em>\n   , the size of 2 pointers: the pointer in the object instance is\n   <strong>\n    not to the start\n   </strong>\n   of the vtable, but at the start of the array of pointers to the virtual functions!\n  </li>\n </ol>\n <p>\n  This is not Earth-shattering in order to compare the pointers, of course. Just add 16. I've seen explanations of what those first two pointers should be. But I have some doubts:\n </p>\n <ol>\n  <li>\n   Is it reliable to assume that the difference of 16 is going to be consistent in all classes in the same binary?\n  </li>\n  <li>\n   Is this common in more compilers?\n  </li>\n  <li>\n   Do the two positions in the table (the very start of it and the start of the array of pointers to the virtual functions) have any naming convention? I find it surprising that there is a pointer to something and it's not the start of the vtable as found on the disassembly.\n  </li>\n  <li>\n   Could be some historical legacy? If C++ first had virtual functions but without virtual inheritance or RTTI, it might explain that those two extra pointers were added to the top to not change some other assumptions.\n  </li>\n </ol>\n</div>\n</body></html>",
    "votes": "2",
    "answers": 1,
    "views": "428",
    "tags": [
        "linux",
        "gcc",
        "pointer",
        "vtables"
    ],
    "user": "Alejandro Exojo",
    "time": "Apr 16, 2021 at 21:14",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  The\n  <a href=\"https://itanium-cxx-abi.github.io/cxx-abi/abi.html\" rel=\"nofollow noreferrer\">\n   Itanium C++ ABI\n  </a>\n  is sometimes not very clear about what exactly is “vtable”.\n </p>\n <p>\n  In practice, the symbol such as\n  <code>\n   _ZTV12DerivedClass\n  </code>\n  points to the\n  <em>\n   complete vtable structure\n  </em>\n  , which includes the two pointer-sized slots before it (RTTI pointer and offset to top).\n </p>\n <p>\n  So, to get the start of the virtual function pointers table (what is commonly understood as “the vtable”),  you have to add 16 (or 8 on 32-but platforms) to the symbol’s address.\n </p>\n</div>\n</body></html>",
            "votes": "3",
            "user": "Igor Skochinsky",
            "time": "Apr 16, 2021 at 23:28",
            "is_accepted": true,
            "comments": []
        }
    ]
}