{
    "title": "how to convert this ASM to C",
    "link": "https://reverseengineering.stackexchange.com/questions/2251/how-to-convert-this-asm-to-c",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I have this function that I know its responsible for making some nice math between a 2D vector to return the highest 3D Y value at the provided 2D coordinate. I also know it takes two parameters,\n  <code>\n   int iX\n  </code>\n  and\n  <code>\n   int iZ\n  </code>\n  . I have the ASM and the pseudo-C generated by Hex-Rays, but I can't make this code cmpile, I'm not so good with the Hex-Rays pseudo-code.\n </p>\n <p>\n  The ASM code:\n </p>\n <pre><code>00464770  /$ 56             PUSH ESI\n00464771  |. 8BF1           MOV ESI,ECX\n00464773  |. 833E 00        CMP DWORD PTR DS:[ESI],0\n00464776  |. 75 06          JNZ SHORT 0046477E\n00464778  |. 33C0           XOR EAX,EAX\n0046477A  |. 5E             POP ESI\n0046477B  |. C2 0800        RETN 8\n0046477E  |> 8B4424 0C      MOV EAX,DWORD PTR SS:[ESP+C]\n00464782  |. 8B4C24 08      MOV ECX,DWORD PTR SS:[ESP+8]\n00464786  |. 50             PUSH EAX\n00464787  |. 51             PUSH ECX\n00464788  |. C1F8 0E        SAR EAX,0E\n0046478B  |. C1F9 0E        SAR ECX,0E\n0046478E  |. 50             PUSH EAX\n0046478F  |. 51             PUSH ECX\n00464790  |. 8BCE           MOV ECX,ESI\n00464792  |. E8 59FEFFFF    CALL 004645F0\n00464797  |. FF86 14000400  INC DWORD PTR DS:[ESI+40014]\n0046479D  |. 5E             POP ESI\n0046479E  \\. C2 0800        RETN 8\n</code></pre>\n <p>\n  The pseudo-code:\n </p>\n <pre><code>signed int __thiscall sub_464770(void *this, int a2, int a3)\n{\n  void *v3; // esi@1\n  signed int result; // eax@2\n\n\n  v3 = this;\n  if ( *(_DWORD *)this )\n  {\n    result = sub_4645F0((int)this, a2 >> 14, a3 >> 14, a2, a3);\n    ++*((_DWORD *)v3 + 65541);\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\nsigned int __thiscall sub_4645F0(int this, unsigned __int8 a2, unsigned __int8 a3, int a4, int a5)\n{\n  int v5; // ebx@1\n  int v6; // edi@1\n  int v7; // esi@1\n  signed int v8; // ebp@2\n  int v9; // eax@3\n  int v10; // edx@3\n  int v11; // eax@3\n  int v12; // ecx@3\n  int v13; // eax@5\n  signed int result; // eax@9\n  signed int v15; // [sp+14h] [bp+4h]@1\n  int v16; // [sp+18h] [bp+8h]@2\n\n\n  v7 = this;\n  v5 = this + 4 * (a3 + (a2 << 8)) + 4;\n  v6 = *(_DWORD *)(this + 262164);\n  v15 = -51200;\n  if ( *(_DWORD *)v5 && (v8 = 1, v16 = **(_WORD **)v5 + 1, v16 > 1) )\n  {\n    do\n    {\n      v10 = *(_DWORD *)(v7 + 262172);\n      v11 = 28 * *(_WORD *)(*(_DWORD *)v5 + 2 * v8);\n      v12 = *(_DWORD *)(v11 + v10 + 4);\n      v9 = v10 + v11;\n      if ( v12 != v6 )\n      {\n        if ( *(_BYTE *)(320 * *(_WORD *)(v9 + 14) + *(_DWORD *)(v7 + 262192) + 168) & 1 )\n        {\n          *(_DWORD *)(v9 + 4) = v6;\n          v13 = sub_464320(v7, v9, a4, a5);\n          if ( v13 != -32767 )\n          {\n            if ( v13 > v15 )\n              v15 = v13;\n          }\n        }\n      }\n      ++v8;\n    }\n    while ( v8 < v16 );\n    result = v15;\n  }\n  else\n  {\n    result = -51200;\n  }\n  return result;\n}\nint __thiscall sub_464320(int this, int a2, int a3, int a4)\n{\n  int v4; // eax@1\n  int v5; // ecx@1\n  int v6; // ebx@1\n  int v7; // esi@1\n  int v8; // esi@1\n  int v9; // edi@1\n  int v10; // edx@1\n  signed int v11; // ecx@16\n  int v12; // eax@17\n  int v13; // edx@22\n  int v14; // edi@22\n  int v15; // eax@23\n  int v16; // ecx@24\n  int v17; // eax@31\n  int v18; // edx@33\n  int v19; // ebx@33\n  int v20; // ebp@33\n  signed int v21; // ecx@34\n  int v22; // ecx@36\n  int v23; // eax@37\n  int v24; // eax@40\n  int v25; // eax@45\n  int v26; // edx@45\n  int v27; // esi@45\n  int v28; // edi@46\n  int v29; // eax@49\n  int v30; // eax@49\n  signed int v31; // ecx@52\n  int result; // eax@53\n  int v33; // [sp+10h] [bp-24h]@1\n  int v34; // [sp+14h] [bp-20h]@1\n  signed int v35; // [sp+18h] [bp-1Ch]@25\n  signed int v36; // [sp+1Ch] [bp-18h]@28\n  signed int v37; // [sp+20h] [bp-14h]@24\n  int v38; // [sp+20h] [bp-14h]@37\n  signed int v39; // [sp+24h] [bp-10h]@24\n  int v40; // [sp+24h] [bp-10h]@40\n  int v41; // [sp+28h] [bp-Ch]@1\n  int v42; // [sp+2Ch] [bp-8h]@1\n  int v43; // [sp+30h] [bp-4h]@1\n  int v44; // [sp+38h] [bp+4h]@1\n  int v45; // [sp+38h] [bp+4h]@43\n  signed int v46; // [sp+40h] [bp+Ch]@24\n\n\n  v8 = *(_DWORD *)(this + 262168);\n  v4 = v8 + 28 * *(_WORD *)(a2 + 10);\n  v5 = v8 + 28 * *(_WORD *)(a2 + 8);\n  v9 = *(_DWORD *)(v5 + 16);\n  v43 = v8 + 28 * *(_WORD *)(a2 + 12);\n  v33 = v43;\n  v10 = *(_DWORD *)(v4 + 16);\n  v7 = v5;\n  v6 = v4;\n  v41 = v5;\n  v42 = v4;\n  v34 = v5;\n  v44 = v4;\n  if ( v10 < v9 )\n  {\n    v7 = v4;\n    v34 = v4;\n  }\n  if ( *(_DWORD *)(v43 + 16) < *(_DWORD *)(v7 + 16) )\n  {\n    v7 = v43;\n    v34 = v43;\n  }\n  if ( v7 == v4 )\n  {\n    v44 = v43;\n    v6 = v43;\n  }\n  if ( *(_DWORD *)(v5 + 16) > *(_DWORD *)(v6 + 16) )\n  {\n    if ( v7 != v5 )\n    {\n      v44 = v5;\n      v6 = v5;\n    }\n  }\n  if ( *(_DWORD *)(v4 + 16) > *(_DWORD *)(v6 + 16) )\n  {\n    if ( v7 != v4 )\n    {\n      v44 = v4;\n      v6 = v4;\n    }\n  }\n  if ( *(_DWORD *)(v43 + 16) > *(_DWORD *)(v6 + 16) )\n  {\n    if ( v7 != v43 )\n    {\n      v44 = v43;\n      v6 = v43;\n    }\n  }\n  v11 = 0;\n  while ( 1 )\n  {\n    v12 = *(&v41 + v11);\n    if ( v7 != v12 )\n    {\n      if ( v6 != v12 )\n        break;\n    }\n    ++v11;\n    if ( v11 >= 3 )\n      goto LABEL_22;\n  }\n  v33 = *(&v41 + v11);\nLABEL_22:\n  v13 = *(_DWORD *)(v7 + 16);\n  v14 = a4;\n  if ( a4 < v13 )\n    goto LABEL_58;\n  v15 = *(_DWORD *)(v6 + 16);\n  if ( a4 > v15 )\n    goto LABEL_58;\n  v16 = *(_DWORD *)(v33 + 16);\n  v37 = v15 - v13;\n  v39 = *(_DWORD *)(v33 + 16) - v13;\n  v46 = v15 - v16;\n  v35 = v15 == v13 ? 0 : ((*(_DWORD *)(v44 + 8) - *(_DWORD *)(v7 + 8)) << 8) / (v15 - v13);\n  v36 = *(_DWORD *)(v33 + 16) == v13 ? 0 : ((*(_DWORD *)(v33 + 8) - *(_DWORD *)(v7 + 8)) << 8)\n                                         / (*(_DWORD *)(v33 + 16) - v13);\n  v17 = v46 ? ((*(_DWORD *)(v44 + 8) - *(_DWORD *)(v33 + 8)) << 8) / v46 : 0;\n  v20 = v14 - *(_DWORD *)(v7 + 16);\n  v18 = *(_DWORD *)(v7 + 8);\n  v19 = v18 + (v35 * (v14 - *(_DWORD *)(v7 + 16)) >> 8);\n  if ( v14 >= v16 )\n  {\n    v21 = v17 * (v14 - *(_DWORD *)(v33 + 16));\n    v18 = *(_DWORD *)(v33 + 8);\n  }\n  else\n  {\n    v21 = v36 * v20;\n  }\n  v22 = v18 + (v21 >> 8);\n  if ( v37 )\n  {\n    v23 = ((*(_DWORD *)(v44 + 12) - *(_DWORD *)(v7 + 12)) << 8) / v37;\n    v7 = v34;\n    v38 = v23;\n  }\n  else\n  {\n    v38 = 0;\n  }\n  if ( v39 )\n  {\n    v24 = ((*(_DWORD *)(v33 + 12) - *(_DWORD *)(v7 + 12)) << 8) / v39;\n    v7 = v34;\n    v40 = v24;\n  }\n  else\n  {\n    v40 = 0;\n  }\n  if ( v46 )\n  {\n    v7 = v34;\n    v45 = ((*(_DWORD *)(v44 + 12) - *(_DWORD *)(v33 + 12)) << 8) / v46;\n  }\n  else\n  {\n    v45 = 0;\n  }\n  v25 = *(_DWORD *)(v7 + 12);\n  v26 = *(_DWORD *)(v33 + 16);\n  v27 = v25 + (v38 * v20 >> 8);\n  v28 = v14 >= v26 ? *(_DWORD *)(v33 + 12) + (v45 * (v14 - v26) >> 8) : v25 + (v40 * v20 >> 8);\n  if ( v19 > v22 )\n  {\n    v29 = v19;\n    v19 = v22;\n    v22 = v29;\n    v30 = v27;\n    v27 = v28;\n    v28 = v30;\n  }\n  if ( a3 < v19 || a3 > v22 )\n  {\nLABEL_58:\n    result = -32767;\n  }\n  else\n  {\n    v31 = v22 - v19;\n    if ( v31 )\n      result = v27 + (((v28 - v27) << 8) / v31 * (a3 - v19) >> 8);\n    else\n      result = v27 + (v27 * (a3 - v19) >> 8);\n  }\n  return result;\n}\n</code></pre>\n <p>\n  I don't know why the functions have\n  <code>\n   void *this\n  </code>\n  as the first parameter though.\n </p>\n</div>\n</body></html>",
    "votes": "3",
    "answers": 1,
    "views": "3k",
    "tags": [
        "disassembly",
        "decompilation",
        "ollydbg",
        "ida"
    ],
    "user": "Leandro Battochio",
    "time": "Jun 15, 2013 at 20:50",
    "comments": [
        {
            "user": "DCoder",
            "text": "<html><body><span class=\"comment-copy\">\n <code>\n  void *this\n </code>\n is the way C++ non-static member functions receive the\n <code>\n  this\n </code>\n pointer.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "DCoder",
            "text": "<html><body><span class=\"comment-copy\">\n Out of curiosity, how many mathematically correct ways\n <i>\n  are there\n </i>\n to compute the result? Or are you interested in the reversing process itself, rather than the specific formula?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Rolf Rolles",
            "text": "<html><body><span class=\"comment-copy\">\n This doesn't seem like a real question.  The title of the question asks what the code is. You pasted both the code and the Hex-Rays decompilation, thereby answering your own question.  Then you said \"I can't work around with it, I'm not so good with the Hex-Rays pseudo-code\" which does not contain a clear or precise question.  Voting to close unless it is edited to ask a well-defined question.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "Leandro Battochio",
            "text": "<html><body><span class=\"comment-copy\">\n My question is clear: whats the c equivalent of that asm code.\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "DCoder",
            "text": "<html><body><span class=\"comment-copy\">\n The ASM snippet you provided is only for the first function from your C code block. For me personally, it would be easier to reverse this if you provided the binary itself rather than the pseudo C.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  It is very difficult to give you an ideal C equivalent that will accurately reflect original code in almost all but trivial cases.  While I don't immediately see signs of this in your code, you must bear in mind that when a compiler is executed, especially with any optimization options, it can result in logically jumbled code to allow the processor to more efficiently utilize cache and execution pipelines.\n </p>\n <p>\n  That said, rather than trying to go for a line by line decompilation, I find that it's better to start out commenting the assembly directly.  From there, try to stand back and identify general function.  From there you should be able to generate code.\n </p>\n <p>\n  For example: (by the way, the start of this assembly fragment seems pretty arbitrary)\n </p>\n <pre><code>00464770  /$ 56             PUSH ESI                 ; save ESI\n00464771  |. 8BF1           MOV ESI,ECX              ; ECX seems to contain the location of something important.\n00464773  |. 833E 00        CMP DWORD PTR DS:[ESI],0 ; Check to see if it's zero.\n00464776  |. 75 06          JNZ SHORT 0046477E       ; If it is, do this.\n00464778  |. 33C0           XOR EAX,EAX              ; If it isn't, zero out EAX.  Remember that EAX is almost always used to return values, especially in compiled C code.\n0046477A  |. 5E             POP ESI                  ; Restore ESI..  Why isn't EBP or anything else being restored?  This makes me suspicious of whether this code was compiled from C code to start with.  There doesn't seem to be a function prolog/epilog.\n0046477B  |. C2 0800        RETN 8                   ; Return, unwinding 8 bytes off of the stack.\n</code></pre>\n <p>\n  From there, stand back and try to identify functional blocks.  I'd need to have more code to reverse this, though, since there is no hint as to what ECX might be pointing at, for example, or how and why this function was called.\n </p>\n</div>\n</body></html>",
            "votes": "1",
            "user": "David Hoelzer",
            "time": "Jul 13, 2013 at 2:23",
            "is_accepted": false,
            "comments": [
                {
                    "user": "David Hoelzer",
                    "text": "<span class=\"comment-copy\">Looking at this again today it could actually be some type of fastcall or register calling but I would still expect to see ESP and EBP being saved/restored.  If you happen to know what compiled this code (if it wasn't written in assembly to start with) I'd be very interested to know it.</span>",
                    "time": null
                },
                {
                    "user": "Leandro Battochio",
                    "text": "<span class=\"comment-copy\">actually, the source code for this game got leaked, and it was compiled using visual studio 2002</span>",
                    "time": null
                }
            ]
        }
    ]
}