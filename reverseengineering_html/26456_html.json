{
    "title": "Correct way to understand local_ in ghidra disassembly",
    "link": "https://reverseengineering.stackexchange.com/questions/26456/correct-way-to-understand-local-in-ghidra-disassembly",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Attached is the part of a disassembled main from a x86 binary file, generated by ghidra.\n </p>\n <pre><code>                             **************************************************************\n                             *                          FUNCTION                          *\n                             **************************************************************\n                             undefined main(undefined1 param_1)\n             undefined         AL:1           <RETURN>                                XREF[1]:     0804835e(W)  \n             undefined1        Stack[0x4]:1   param_1                                 XREF[1]:     08048309(*)  \n             undefined4        EAX:4          str_in                                  XREF[1]:     0804835e(W)  \n             undefined4        Stack[0x0]:4   local_res0                              XREF[1]:     08048310(R)  \n             undefined4        Stack[-0x10]:4 local_10                                XREF[6]:     08048358(R), \n                                                                                                   08048363(W), \n                                                                                                   0804836d(R), \n                                                                                                   08048388(R), \n                                                                                                   08048393(W), \n                                                                                                   0804839d(R)  \n             undefined4        Stack[-0x14]:4 local_14                                XREF[2]:     0804831a(W), \n                                                                                                   08048366(R)  \n             undefined4        Stack[-0x18]:4 local_18                                XREF[2]:     08048321(W), \n                                                                                                   08048396(R)  \n             undefined4        Stack[-0x2c]:4 local_2c                                XREF[3]:     08048369(W), \n                                                                                                   08048399(W), \n                                                                                                   080483ac(W)  \n             undefined4        Stack[-0x30]:4 local_30                                XREF[12]:    08048328(*), \n                                                                                                   08048334(*), \n                                                                                                   08048340(*), \n                                                                                                   0804834c(*), \n                                                                                                   0804835b(*), \n                                                                                                   08048370(*), \n                                                                                                   0804837c(*), \n                                                                                                   0804838b(*), \n                                                                                                   080483a0(*), \n                                                                                                   080483b4(*), \n                                                                                                   080483c2(*), \n                                                                                                   080483d0(*)  \n                             main                                            XREF[2]:     Entry Point(*), \n                                                                                          _start:08048167(*)  \n        08048309 8d 4c 24 04     LEA        ECX=>param_1,[ESP + 0x4]\n        0804830d 83 e4 f0        AND        ESP,0xfffffff0\n        08048310 ff 71 fc        PUSH       dword ptr [ECX + local_res0]\n        08048313 55              PUSH       EBP\n        08048314 89 e5           MOV        EBP,ESP\n        08048316 51              PUSH       ECX\n        08048317 83 ec 24        SUB        ESP,0x24\n        0804831a c7 45 f4        MOV        dword ptr [EBP + local_14],DAT_080a6b19          = 6Ah    j\n                 19 6b 0a 08\n        08048321 c7 45 f0        MOV        dword ptr [EBP + local_18],s_the_ripper_080a6b1e = \"the ripper\"\n                 1e 6b 0a 08\n</code></pre>\n <p>\n  Same code from gdb\n </p>\n <pre><code>   0x08048309 <+0>: lea    ecx,[esp+0x4]\n   0x0804830d <+4>: and    esp,0xfffffff0\n   0x08048310 <+7>: push   DWORD PTR [ecx-0x4]\n   0x08048313 <+10>:    push   ebp\n   0x08048314 <+11>:    mov    ebp,esp\n   0x08048316 <+13>:    push   ecx\n   0x08048317 <+14>:    sub    esp,0x24\n=> 0x0804831a <+17>:    mov    DWORD PTR [ebp-0xc],0x80a6b19\n</code></pre>\n <p>\n  Why is ghidra changeing\n  <code>\n   [ebp-0xc]\n  </code>\n  to\n  <code>\n   [EBP + local_14]\n  </code>\n  .\nSimilar question I found is\n  <a href=\"https://reverseengineering.stackexchange.com/questions/23540/ghidra-interpreting-stack-pointers-wrongly\">\n   Ghidra interpreting stack pointers wrongly\n  </a>\n  but reading the answer, I'm not getting the meaning of\n  <code>\n   [EBP + local_14]\n  </code>\n  Here, is ghidra just renaming\n  <code>\n   -0xc\n  </code>\n  to a easily readable name like\n  <code>\n   local_14\n  </code>\n  ? I'm not getting how to make sense of this exactly.\n </p>\n <p>\n  In the function header, it is shown that\n  <code>\n   Stack[-0x10]:4 local_10\n  </code>\n  . I assume it means that\n  <code>\n   local_10\n  </code>\n  is 4 byte variable at Stack[-0x10], where Stack is the stack pointer upon entry to function. But why is it added to ebp. What's the meaning of that representation used by ghidra?\n </p>\n</div>\n</body></html>",
    "votes": "4",
    "answers": 1,
    "views": "5k",
    "tags": [
        "disassembly",
        "binary-analysis",
        "x86",
        "gdb",
        "ghidra"
    ],
    "user": "Mah35h",
    "time": "Dec 6, 2020 at 16:52",
    "comments": [
        {
            "user": "rustyMagnet",
            "text": "<html><body><span class=\"comment-copy\">\n Before doing anything with Ghidra, I start to help Ghidra by telling it the return types of functions (\n <code>\n  int\n </code>\n ,\n <code>\n  void\n </code>\n ,\n <code>\n  char *\n </code>\n , etc ). Then I do the same for the function parameters.  Just this step alone starts to clear up the local variables.  Did you try that ?\n</span>\n</body></html>",
            "time": null
        },
        {
            "user": "hairlessbear",
            "text": "<html><body><span class=\"comment-copy\">\n One thing you can do that may make this more obvious is to turn off the setting that causes Ghidra to use the\n <code>\n  local_\n </code>\n variables directly in the assembly. You can do this via\n <code>\n  Edit -> Tool Options -> Listing Fields -> Operands Field -> Markup Stack Variable References\n </code>\n . This will change the display to show the normal operands, with an arrow indicating what stack variable is being referenced.\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Since local variables are usually placed on the stack in\n  <code>\n   x86\n  </code>\n  and\n  <code>\n   esp\n  </code>\n  register can change during function execution, it is more convenient to save the value of\n  <code>\n   esp\n  </code>\n  register on function entry and access data relatively to that value.\n  <code>\n   ebp\n  </code>\n  register is used for this purpose. So you will often see\n </p>\n <pre><code>push ebp\nmov ebp, esp\n</code></pre>\n <p>\n  lines at the begining of functions. In the example you have provided it is the case - all local variables are accessed this way, through\n  <code>\n   ebp\n  </code>\n  .\n </p>\n <p>\n  Now, there are two different naming conventions for local variables:\n </p>\n <ul>\n  <li>\n   first and more natural one: if\n   <code>\n    [ebp - xxx]\n   </code>\n   is accessed, it will be displayed as\n   <code>\n    [ebp + local_xxx]\n   </code>\n   . Here,\n   <code>\n    local_xxx = -xxx\n   </code>\n   , so for instance,\n   <code>\n    local_18 = -0x18\n   </code>\n   .\n  </li>\n  <li>\n   second and less intuitive one makes use of the\n   <code>\n    esp\n   </code>\n   value at the beginning of a function. In your example, two dwords are pushed on the stack before\n   <code>\n    mov ebp, esp\n   </code>\n   line. It means, that if some local variable was called\n   <code>\n    local_xxx\n   </code>\n   in the first convention, in the second one it will be named\n   <code>\n    local_xxx+0x8\n   </code>\n   , for instance\n   <code>\n    local_18\n   </code>\n   in the first one will be\n   <code>\n    local_20\n   </code>\n   in the second one, used by Ghidra.\n  </li>\n </ul>\n <p>\n  Why do we add\n  <code>\n   0x8\n  </code>\n  in the second one? Because two dwords (\n  <code>\n   8\n  </code>\n  bytes) were pushed onto the stack before\n  <code>\n   esp\n  </code>\n  value was saved into\n  <code>\n   ebp\n  </code>\n  and in\n  <code>\n   x86\n  </code>\n  architecture stack \"grows downwards\", which means if you push something onto it, this value will be saved there and\n  <code>\n   esp\n  </code>\n  will be\n  <em>\n   decreased\n  </em>\n  accordingly (in this case, twice, by\n  <code>\n   4\n  </code>\n  bytes). So, in your particular example, you have the instruction\n </p>\n <pre><code>mov    DWORD PTR [ebp-0xc],0x80a6b19\n</code></pre>\n <p>\n  which would be displayed as\n </p>\n <pre><code>mov    DWORD PTR [ebp+local_c],0x80a6b19\n</code></pre>\n <p>\n  in the first convention and\n </p>\n <pre><code>mov    DWORD PTR [ebp+local_14],0x80a6b19\n</code></pre>\n <p>\n  in the second one, implemented in Ghidra, since\n  <code>\n   0xc + 0x8 = 0x14\n  </code>\n  .\n </p>\n</div>\n</body></html>",
            "votes": "9",
            "user": "bart1e",
            "time": "Dec 8, 2020 at 17:26",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Mah35h",
                    "text": "<span class=\"comment-copy\">Just to confirm. In the second convention, when it shows <code>ebp+local_14</code> , ebp actually mean the value of esp at the beginning of of the function call and not the value of ebp when the instruction is ran?</span>",
                    "time": null
                },
                {
                    "user": "bart1e",
                    "text": "<span class=\"comment-copy\">No, it is current ebp value (which is entry_esp-8).</span>",
                    "time": null
                },
                {
                    "user": "Mah35h",
                    "text": "<span class=\"comment-copy\">then value of local_14 should be -0xC right. Else it'll point to wrong memory location when added with ebp</span>",
                    "time": null
                },
                {
                    "user": "bart1e",
                    "text": "<span class=\"comment-copy\">Exactly. And that's why I called this convention \"less intuitive\".</span>",
                    "time": null
                }
            ]
        }
    ]
}