{
    "title": "Understanding the most recent heap implementation under Linux",
    "link": "https://reverseengineering.stackexchange.com/questions/3127/understanding-the-most-recent-heap-implementation-under-linux",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  A few days ago, I was wondering how one could teach himself heap-based overflow exploitation.\n </p>\n <p>\n  So I searched through documentation, subsequently practicing what I read in order to have a better insight of how the heap works under Linux.\n </p>\n <p>\n  We are told that the malloc() / free() function works around\n  <a href=\"http://gee.cs.oswego.edu/dl/html/malloc.html\">\n   Doug Lea's memory allocator\n  </a>\n  but, in spite of the great explanation given by the link, I cannot figure things out as I debug my program.\n </p>\n <p>\n  Given this example:\n </p>\n <pre><code>#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint n = 5;\n\nint main(int argc, char** argv) {\n\n        char* p;\n        char* q;\n\n        p = malloc(1024);\n        q = malloc(1024);\n\n        printf(\"real size = %d\n\",*(((int*)p)-1) & 0xFFFFFFF8);\n\n        if(argc >= 2) {\n                strcpy(p, argv[1]);\n        }\n\n        free(q);\n        printf(\"n = 0x%08X\n\", n);\n        free(p);\n\n        return EXIT_SUCCESS;\n}\n</code></pre>\n <p>\n  I would like to dump this structure in memory:\n </p>\n <pre><code>struct chunk {\n        int prev_size;\n        int size;\n        struct chunk *fd;\n        struct chunk *bk;\n};\n</code></pre>\n <p>\n  Here is my workflow:\n </p>\n <pre><code>geo@lilith:~/c/vuln_malloc$ gcc -o vuln vuln.c -m32 -ggdb\ngeo@lilith:~/c/vuln_malloc$ gdb ./vuln\nGNU gdb (GDB) 7.4.1-debian\nCopyright (C) 2012 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>...\nReading symbols from /home/geo/c/vuln_malloc/vuln...done.\n(gdb) b 21\nBreakpoint 1 at 0x804850f: file vuln.c, line 21.\n(gdb) r `perl -e 'print \"A\" x 1024'`\nStarting program: /home/geo/c/vuln_malloc/vuln `perl -e 'print \"A\" x 1024'`\nreal size = 1032\n\nBreakpoint 1, main (argc=2, argv=0xffffd414) at vuln.c:21\n21              free(q);\n(gdb) x/10x q-4\n0x804a40c:      0x00000409      0x00000000      0x00000000      0x00000000\n0x804a41c:      0x00000000      0x00000000      0x00000000      0x00000000\n0x804a42c:      0x00000000      0x00000000\n(gdb)\n</code></pre>\n <p>\n  Here I can see the size-field's value, which is 0x409. I can easily guess that the real size of my chunk is 0x409 & 0xFFFFFF8 = 0x408 = 1032, as explained by the documentation (the three least significant actually define some flags). Then I run until the free() function is processed.\n </p>\n <pre><code>(gdb) b 22\nBreakpoint 2 at 0x804851b: file vuln.c, line 22.\n(gdb) c\nContinuing.\n\nBreakpoint 2, main (argc=2, argv=0xffffd414) at vuln.c:22\n22              printf(\"n = 0x%08X\n\", n);\n(gdb) x/10x q-4\n0x804a40c:      0x00020bf9      0x00000000      0x00000000      0x00000000\n0x804a41c:      0x00000000      0x00000000      0x00000000      0x00000000\n0x804a42c:      0x00000000      0x00000000\n</code></pre>\n <p>\n  Firstly I don't understand the new value - 0x20bf9 - at all, secondly I don't understand why there isn't any relevant values as regard the fd and bk pointers either.\n </p>\n <p>\n  All of that stuff does not make much sense for me, that's why I was wondering wether you could give me some clues about all of this or not. Does the Doug Lea's implementation still exist in recent glibc versions, or...?\n </p>\n</div>\n</body></html>",
    "votes": "12",
    "answers": 1,
    "views": "5k",
    "tags": [
        "linux",
        "exploit",
        "buffer-overflow",
        "software-security"
    ],
    "user": "Geoffrey R.",
    "time": "Dec 5, 2013 at 14:25",
    "comments": [
        {
            "user": "asheeshr",
            "text": "<html><body><span class=\"comment-copy\">\n Related meta discussion:\n <a href=\"http://meta.reverseengineering.stackexchange.com/questions/268/extend-the-topic-to-software-security\" title=\"extend the topic to software security\">\n  meta.reverseengineering.stackexchange.com/questions/268/…\n </a>\n</span>\n</body></html>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  First of all, I have bad news for you ! Doug Lea's malloc is almost no more used in any C library implementation (even if understanding\n  <code>\n   dlmalloc\n  </code>\n  can help a lot to understand new ones).\n </p>\n <p>\n  The new implementation that is most widely used is\n  <code>\n   ptmalloc2\n  </code>\n  and the best way to learn about it is... to read the code... So, if you are using a Debian(-like) distribution, just like me, you just need to get the source code of the libc like this:\n </p>\n <pre><code>$> apt-get source libc6\n</code></pre>\n <p>\n  Note that the\n  <a href=\"http://lwn.net/Articles/488778/\" rel=\"nofollow noreferrer\">\n   glibc is no more\n  </a>\n  and has been subsumed by the\n  <a href=\"http://www.eglibc.org/home\" rel=\"nofollow noreferrer\">\n   eglibc project\n  </a>\n  . The Debian distribution switched to eglibc some time ago (see\n  <a href=\"http://blog.aurel32.net/47\" rel=\"nofollow noreferrer\">\n   here\n  </a>\n  and\n  <a href=\"http://lwn.net/Articles/332000/\" rel=\"nofollow noreferrer\">\n   there\n  </a>\n  and even on the\n  <a href=\"http://packages.qa.debian.org/g/glibc.html\" rel=\"nofollow noreferrer\">\n   glibc source package page\n  </a>\n  ). So, the implementation of\n  <code>\n   malloc\n  </code>\n  has changed considerably (and some security safeties have been added since\n  <code>\n   dlmalloc\n  </code>\n  ).\n </p>\n <p>\n  But, let see what does look like the\n  <code>\n   malloc\n  </code>\n  implementation:\n </p>\n <pre><code>$> cd eglibc-2.17/malloc/\n$> less malloc.c\n\n...\n/*\n This is a version (aka ptmalloc2) of malloc/free/realloc written by\n Doug Lea and adapted to multiple threads/arenas by Wolfram Gloger.\n\n There have been substantial changesmade after the integration into\n glibc in all parts of the code.  Do not look for much commonality\n with the ptmalloc2 version.\n...\n</code></pre>\n <p>\n  As I said, the algorithm used here is\n  <code>\n   ptmalloc2\n  </code>\n  (POSIX Threads Malloc), but with significant modifications. So, you'd better read the code to know better about it.\n </p>\n <p>\n  But, to sum up a bit, the heap memory is managed through memory chunks which are prefixed by meta-data gathering these information (I am just quoting comments that are in the\n  <code>\n   malloc.c\n  </code>\n  source file, refer to the whole file for more):\n </p>\n <pre><code>/*\n   malloc_chunk details:\n\n    (The following includes lightly edited explanations by Colin Plumb.)\n\n    Chunks of memory are maintained using a `boundary tag' method as\n    described in e.g., Knuth or Standish.  (See the paper by Paul\n    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a\n    survey of such techniques.)  Sizes of free chunks are stored both\n    in the front of each chunk and at the end.  This makes\n    consolidating fragmented chunks into bigger chunks very fast. The\n    size fields also hold bits representing whether chunks are free or\n    in use.\n\n    An allocated chunk looks like this:\n\n\n    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of previous chunk, if allocated            | |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of chunk, in bytes                       |M|P|\n      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             User data starts here...                          .\n            .                                                               .\n            .             (malloc_usable_size() bytes)                      .\n            .                                                               |\nnextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of chunk                                     |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\n    Where \"chunk\" is the front of the chunk for the purpose of most of\n    the malloc code, but \"mem\" is the pointer that is returned to the\n    user.  \"Nextchunk\" is the beginning of the next contiguous chunk.\n\n    Chunks always begin on even word boundries, so the mem portion\n    (which is returned to the user) is also on an even word boundary, and\n    thus at least double-word aligned.\n\n    Free chunks are stored in circular doubly-linked lists, and look like this:\n\n    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of previous chunk                            |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    `head:' |             Size of chunk, in bytes                         |P|\n      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Forward pointer to next chunk in list             |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Back pointer to previous chunk in list            |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Unused space (may be 0 bytes long)                .\n            .                                                               .\n            .                                                               |\nnextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    `foot:' |             Size of chunk, in bytes                           |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n    The P (PREV_INUSE) bit, stored in the unused low-order bit of the\n    chunk size (which is always a multiple of two words), is an in-use\n    bit for the *previous* chunk.  If that bit is *clear*, then the\n    word before the current chunk size contains the previous chunk\n    size, and can be used to find the front of the previous chunk.\n    The very first chunk allocated always has this bit set,\n    preventing access to non-existent (or non-owned) memory. If\n    prev_inuse is set for any given chunk, then you CANNOT determine\n    the size of the previous chunk, and might even get a memory\n    addressing fault when trying to do so.\n\n    Note that the `foot' of the current chunk is actually represented\n    as the prev_size of the NEXT chunk. This makes it easier to\n    deal with alignments etc but can be very confusing when trying\n    to extend or adapt this code.\n\n    The two exceptions to all this are\n\n     1. The special chunk `top' doesn't bother using the\n        trailing size field since there is no next contiguous chunk\n        that would have to index off it. After initialization, `top'\n        is forced to always exist.  If it would become less than\n        MINSIZE bytes long, it is replenished.\n\n     2. Chunks allocated via mmap, which have the second-lowest-order\n        bit M (IS_MMAPPED) set in their size fields.  Because they are\n        allocated one-by-one, each must contain its own trailing size field.\n*/\n</code></pre>\n <p>\n  You can also refer to '\n  <a href=\"https://csg.utdallas.edu/wp-content/uploads/2012/08/Heap-Based-Exploitation.pdf\" rel=\"nofollow noreferrer\">\n   <em>\n    Heap-Based Exploitation\n   </em>\n  </a>\n  ' which is a talk from Scott Hand about heap management and overflow exploitation.\n </p>\n <p>\n  Still, you have a lot of work to do to understand everything, I would have like to have more time to explain. But, I hope it helped you a bit to find ways to go deeper (downloading the source is really the key here).\n </p>\n</div>\n</body></html>",
            "votes": "13",
            "user": "perror",
            "time": "Nov 6, 2016 at 17:14",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Steeve",
                    "text": "<span class=\"comment-copy\">the link to the Heap-Based Exploitation PDF is dead.</span>",
                    "time": null
                },
                {
                    "user": "Bill B",
                    "text": "<span class=\"comment-copy\"><a href=\"https://web.archive.org/web/20131206064115/http://www.utdallas.edu/~shand/papers/heap_based_exploitation.pdf\" rel=\"nofollow noreferrer\">web.archive.org/web/20131206064115/http://www.utdallas.edu/…</a></span>",
                    "time": null
                },
                {
                    "user": "golem",
                    "text": "<span class=\"comment-copy\">Update. As of Oct 2015 the eglibc project is dead. Most features were merged into glibc and Debian <a href=\"http://blog.aurel32.net/175\" rel=\"nofollow noreferrer\">switched back to glibc</a></span>",
                    "time": null
                }
            ]
        }
    ]
}