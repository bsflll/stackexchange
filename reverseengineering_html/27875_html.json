{
    "title": "Restoring original stack variable in IDA Pro?",
    "link": "https://reverseengineering.stackexchange.com/questions/27875/restoring-original-stack-variable-in-ida-pro",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I would like to convert an instruction like:\n  \n\n  <code>\n   lea     ecx, [esp+150h+var_13E+2]\n  </code>\n  \n\n  to:\n  \n\n  <code>\n   lea     ecx, [esp+14h]\n  </code>\n  \n\n  I know it's possible to do this with the key\n  <code>\n   K\n  </code>\n  . But I'm writing an IDAPython plugin that needs an automatic conversion of instructions like the one above.\n </p>\n <p>\n  Edit:\nAre there any idaapi functions to do this?\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 2,
    "views": "71",
    "tags": [
        "ida",
        "idapython",
        "ida-plugin"
    ],
    "user": "Žiga Šumenjak",
    "time": "Jun 22, 2021 at 12:17",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <pre><code>idaapi.op_seg(idc.get_screen_ea(), -1)\nidaapi.op_stkvar(idc.get_screen_ea(), -1)\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "Jun 22, 2021 at 15:06",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  Disclaimer:\n  <em>\n   I am the author of the ida-minsc plugin (which aims to make idapython not suck) at\n   <a href=\"https://github.com/arizvisa/ida-minsc/tree/persistence-refactor\" rel=\"nofollow noreferrer\">\n    https://github.com/arizvisa/ida-minsc\n   </a>\n  </em>\n </p>\n <p>\n  Using minsc, toggling the representation of an operand between hexadecimal or a frame variable can be done with\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op_hexadecimal\" rel=\"nofollow noreferrer\">\n   <code>\n    instruction.op_hexadecimal\n   </code>\n  </a>\n  or\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op_stackvar\" rel=\"nofollow noreferrer\">\n   <code>\n    instruction.op_stack\n   </code>\n  </a>\n  . These functions act on a single operand and take an address and an operand number.\n </p>\n <pre><code>Python>db.disasm()\n'401304: lea ecx, [esp+14h]'\n\nPython>ins.op_stack(h(), 1)\n<member '$ F4012D0.var_284' index=5 offset=-0x288 size=+0x4 typeinfo='LPDWORD'>\n\nPython>db.disasm()\n'401304: lea ecx, [esp+298h+var_284]'\n\nPython>ins.op_hex(1)\n0x14\n\nPython>db.disasm()\n'401304: lea ecx, [esp+14h]'    \n</code></pre>\n <p>\n  Selecting these instructions within a function can then be done with the\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.chunks.register\" rel=\"nofollow noreferrer\">\n   <code>\n    function.register\n   </code>\n  </a>\n  function. Despite the semantics of Intel's\n  <code>\n   lea\n  </code>\n  instruction having the effect of doing SIB arithmetic and storing the result to a register, this can be treated as a load instruction using the\n  <code>\n   %esp\n  </code>\n  register. This should be parallel to the\n  <code>\n   o_mem\n  </code>\n  and\n  <code>\n   o_displ\n  </code>\n  operand types documented in the SDK as\n  <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group__o__.html\" rel=\"nofollow noreferrer\">\n   Operand types\n  </a>\n  .\n </p>\n <pre><code>Python>for ref in func.register('esp', load=True):\nPython> print(db.disasm(ref))\nPython>\n401304: lea ecx, [esp+14h]\n</code></pre>\n <p>\n  However, it's pretty likely that we'd also want instructions that write to the\n  <code>\n   %esp\n  </code>\n  register as well. To enumerate both loads and stores depending on the\n  <code>\n   %esp\n  </code>\n  register (and eventually change the operand), we can chain them together using\n  <code>\n   itertools.chain\n  </code>\n  ...essentially ORing them.\n </p>\n <pre><code>Python>for ref in itertools.chain(func.register(ins.reg.esp, store=True), func.register(ins.reg.esp, load=True)):\nPython> print(db.disasm(ref))\nPython>\n\n40177f: mov dword ptr [esp+8], offset ConnectionHandler(x)\n401787: mov dword ptr [esp+4], 0\n40178f: mov dword ptr [esp], 0\n...\n4017a9: mov [esp], eax\n401304: lea ecx, [esp+14h]\n</code></pre>\n <p>\n  If you're not in a function (which makes no sense for frame variables), you can also use the\n  <a href=\"https://github.com/arizvisa/ida-minsc/blob/persistence-refactor/base/instruction.py#L274\" rel=\"nofollow noreferrer\">\n   <code>\n    instruction.ops_register\n   </code>\n  </a>\n  function to filter an instruction's operands. By combining this with the\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/database.html#database-address\" rel=\"nofollow noreferrer\">\n   <code>\n    database.address\n   </code>\n  </a>\n  function, you can do a similar selection on any number of instructions that interact with registers in a particular way.\n </p>\n <pre><code>Python>for ea in db.a(function.chunk()):\nPython> for ref in ins.ops_register(ea, ins.reg.esp, write=True, store=False):\nPython>  print([ins.op_repr(ref), db.disasm(ref)])\nPython>\n\n['esp', '4012d4: sub esp, 294h']\n['esp', '4012da: and esp, 0FFFFFFF0h']\n['esp', '401466: sub esp, 8']\n...\n['esp', '401714: sub esp, 4']\n['esp', '40173a: sub esp, 4']\n['esp', '40174e: sub esp, 4']\n['esp', '40179b: sub esp, 18h']\n['esp', '4017b1: sub esp, 4']\n</code></pre>\n <p>\n  These results can then be combined with the\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op_stackvar\" rel=\"nofollow noreferrer\">\n   <code>\n    instruction.op_stack\n   </code>\n  </a>\n  function. The following python changes everything to a stack variable, outputs the reference, the result, and a disassembly of the modified instruction (for the purpose of demonstrating all of the available input types and their usage).\n </p>\n <pre><code>Python>for ref in itertools.chain(func.register(ins.reg.esp, store=True), func.register(ins.reg.esp, load=True)):\nPython> lvar = ins.op_stack(ref)\nPython> print(ref, lvar)\nPython> print(db.disasm(ref))\nPython>\n\nopref_t(address=0x40176d, opnum=0, access=access_t(&w)) <member '$ F4012D0.arg_C' index=24 offset=0x10 size=+0x4 typeinfo='DWORD'>\n40176d: mov [esp-4+arg_C], 0\nopref_t(address=0x40177b, opnum=0, access=access_t(&w)) <member '$ F4012D0.envp' index=23 offset=0xc size=+0x4 typeinfo='const char**'>\n40177b: mov [esp-4+envp], eax\nopref_t(address=0x40177f, opnum=0, access=access_t(&w)) <member '$ F4012D0.argv' index=22 offset=0x8 size=+0x4 typeinfo='const char**'>\n40177f: mov [esp-4+argv], offset ConnectionHandler(x)\n...\nopref_t(address=0x401787, opnum=0, access=access_t(&w)) <member '$ F4012D0.argc' index=21 offset=0x4 size=+0x4 typeinfo='int'>\n401787: mov [esp-4+argc], 0\nopref_t(address=0x401304, opnum=1, access=access_t(&r)) <member '$ F4012D0.var_284' index=5 offset=-0x288 size=+0x4 typeinfo='LPDWORD'>\n401304: lea ecx, [esp+298h+var_284]\n</code></pre>\n <p>\n  Similarly, it can also be combined with the\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op_hexadecimal\" rel=\"nofollow noreferrer\">\n   <code>\n    instruction.op_hex\n   </code>\n  </a>\n  function, or really any of the\n  <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op\" rel=\"nofollow noreferrer\">\n   <code>\n    instruction.op_*\n   </code>\n  </a>\n  functions.\n </p>\n <pre><code>Python>for ref in itertools.chain(func.register(ins.reg.esp, store=True), func.register(ins.reg.esp, load=True)):\nPython> discarded = ins.op_hex(ref)\nPython> print(db.disasm(ref))\n\n40176d: mov dword ptr [esp+10h], 0\n40177b: mov [esp+0Ch], eax\n40177f: mov dword ptr [esp+8], offset ConnectionHandler(x)\n...\n401787: mov dword ptr [esp+4], 0\n40178f: mov dword ptr [esp], 0\n4017a9: mov [esp], eax\n401304: lea ecx, [esp+14h]\n</code></pre>\n</div>\n</body></html>",
            "votes": "1",
            "user": "Ali Rizvi-Santiago",
            "time": "Aug 12, 2024 at 18:27",
            "is_accepted": false,
            "comments": []
        }
    ]
}