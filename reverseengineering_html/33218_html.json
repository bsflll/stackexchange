{
    "title": "What structure does GetProcessHeap actually return?",
    "link": "https://reverseengineering.stackexchange.com/questions/33218/what-structure-does-getprocessheap-actually-return",
    "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  I'm currently reverse engineering a 1998 era Windows game that, I think, tries to page in process data prior to the (time critical) game loop.\n </p>\n <p>\n  Below, equivalent reverse engineered c code can be found.\n </p>\n <p>\n  My question is what actual struct(s)\n  <code>\n   GetProcessHeap\n  </code>\n  returns, and whether this is documented somewhere?\n </p>\n <pre class=\"lang-c prettyprint-override\"><code>#include <stddef.h>\n#include <stdio.h>\n#include <windows.h>\n\nSYSTEM_INFO gSystem_info;\nDWORD gPage_size;\n\ntypedef struct tHeap_block_information {\n    BYTE field_0x0[0x48];\n    struct tHeap_block_information* next;\n    BYTE field_0x4c[0x26];\n    WORD field_0x72;\n} tHeap_block_information;\n_Static_assert(offsetof(tHeap_block_information, next) == 0x48);\n_Static_assert(offsetof(tHeap_block_information, field_0x72) == 0x72);\n_Static_assert(sizeof(tHeap_block_information) == 0x74);\n\ntypedef union {\n    DWORD flags;\n    BYTE data[1];\n} tHeap_memory;\n\nvoid PDPageInMemory(tHeap_block_information* memory) {\n\n    if (!IsBadReadPtr(memory, sizeof(tHeap_block_information)) && memory->field_0x72 == 0x4948) {\n        for (; memory != NULL; memory = memory->next) {\n            tHeap_memory *block;\n\n            block = (tHeap_memory*)(memory + 1);\n            for (;;) {\n                DWORD size = block->flags & 0x5ffffffc;\n                DWORD current;\n                if (size == 0) {\n                    break;\n                }\n                if (!(block->flags & 0x1)) {\n                    if (gPage_size == 0) {\n                        GetSystemInfo(&gSystem_info);\n                        gPage_size = gSystem_info.dwPageSize;\n                    }\n                    for (current = 16 * gPage_size; current < size - 4; current += gPage_size) {\n                        block->data[current + 16 - 16 * gPage_size] = block->data[current + 16 - 16 * gPage_size];\n                        block->data[current + 16]                   = block->data[current + 16];\n                    }\n                }\n                block = (tHeap_memory*)((BYTE*)block + size);\n            }\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n  \n  /* Initialize and load assets*/\n  \n  /* Page in memory prior to game loop */\n  PDPageInMemory((tHeap_block_information*)GetProcessHeap());\n  \n  for (;;) {\n    int finished = 0;\n    /* Do work */\n    \n    /* DONE */\n    finished = 1;\n\n    if (finished) {\n        /* Quit loop */\n        break;\n    }\n  }\n  /* Clean up and exit */\n  return 0;\n}\n</code></pre>\n <p>\n  This code probably made sense in the 90ies, when RAM was scarce.\n </p>\n</div>\n</body></html>",
    "votes": "1",
    "answers": 2,
    "views": "89",
    "tags": [
        "winapi"
    ],
    "user": "maarten",
    "time": "Sep 12, 2024 at 18:49",
    "comments": [],
    "answers_data": [
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  By Documentation GetProcessHeap Returns a HANDLE and is Supposed to be a Opaque\n </p>\n <p>\n  with windbg You could Cast the Returned HANDLE as\n  <strong>\n   ntdll!_HEAP\n  </strong>\n  and view the structure\n </p>\n <p>\n  (not sure if this assertion holds right above win8  or below xp but a\n  <a href=\"https://www.blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf\" rel=\"nofollow noreferrer\">\n   simple google\n  </a>\n  and some code conveys most of this still holds true)\n </p>\n <p>\n  code as below\n </p>\n <pre><code>#include <stdio.h>\n#include <windows.h>\n\nvoid main (void)  {\n    HANDLE hHeap = GetProcessHeap();\n    printf(\"%p\n\",hHeap);\n    PDWORD foo = (PDWORD) hHeap;\n    int j = 0;\n    for (j=0 ; j<128; j++)\n    {\n        \n    printf(\"%p\\t\" , foo+j);\n    for (int i=0;i<4;i++) \n    {\n        printf(\"%08x \", *foo++);\n        \n    }\n    j=j+16;\n    printf(\"\n\");\n    }\n    \n}\n</code></pre>\n <p>\n  executing it inside windbg and comparing the output of DD,ntdll!_HEAP, and !heap -a @rax outputs\n </p>\n <pre><code>:\\>cdb -c \"g heapy!main;p;p;dd @rax;!heap -a @rax;dt ntdll!_HEAP @rax;g;q\" heapy.exe\n\nMicrosoft (R) Windows Debugger Version 10.0.19041.685 AMD64\nCommandLine: heapy.exe\n\n(1bc0.ebc): Break instruction exception - code 80000003 (first chance)\nntdll!LdrpDoDebuggerBreak+0x30:\n00007ffe`106e0750 cc              int     3\n0:000> cdb: Reading initial command 'g heapy!main;p;p;dd @rax;!heap -a @rax;dt ntdll!_HEAP @rax;g;q'\n\n00000269`1d970000  00000000 00000000 76b307d9 01001d46\n00000269`1d970010  ffeeffee 00000002 1d970120 00000269\n00000269`1d970020  1d970120 00000269 1d970000 00000269\n00000269`1d970030  1d970000 00000269 000000ff 00000000\n00000269`1d970040  1d970740 00000269 1da6f000 00000269\n00000269`1d970050  000000ee 00000001 00000000 00000000\n00000269`1d970060  1d980fe0 00000269 1d980fe0 00000269\n00000269`1d970070  40000062 40000060 20000000 00100000\nHEAPEXT: Unable to get address of ntdll!RtlpHeapInvalidBadAddress.\n\nIndex   Address  Name      Debugging options enabled\n  1:   2691d970000\n    Segment at 000002691d970000 to 000002691da6f000 (00011000 bytes committed)\n    Flags:                40000062\n    ForceFlags:           40000060\n    Granularity:          16 bytes\n    Segment Reserve:      00100000\n    Segment Commit:       00002000\n    DeCommit Block Thres: 00000100\n    DeCommit Total Thres: 00001000\n    Total Free Size:      000002a3\n    Max. Allocation Size: 00007ffffffdefff\n    Lock Variable at:     000002691d9702c0\n    Next TagIndex:        0000\n    Maximum TagIndex:     0000\n    Tag Entries:          00000000\n    PsuedoTag Entries:    00000000\n    Virtual Alloc List:   2691d970110\n    Uncommitted ranges:   2691d9700f0\n            2691d981000: 000ee000  (974848 bytes)\n    FreeList[ 00 ] at 000002691d970150: 000002691d97ce40 . 000002691d980fb0\n        000002691d980fa0: 00050 . 00020 [104] - free\n        000002691d976490: 00050 . 00020 [104] - free\n        000002691d97ce30: 004a0 . 029f0 [104] - free\n\n    Segment00 at 1d970000:\n        Flags:           00000000\n        Base:            2691d970000\n        First Entry:     1d970740\n        Last Entry:      2691da6f000\n        Total Pages:     000000ff\n        Total UnCommit:  000000ee\n        Largest UnCommit:00000000\n        UnCommitted Ranges: (1)\n        cut off \n        \n        \n   +0x000 Segment          : _HEAP_SEGMENT\n   +0x000 Entry            : _HEAP_ENTRY\n   +0x010 SegmentSignature : 0xffeeffee\n   +0x014 SegmentFlags     : 2\n   +0x018 SegmentListEntry : _LIST_ENTRY [ 0x00000269`1d970120 - 0x00000269`1d970120 ]\n   +0x028 Heap             : 0x00000269`1d970000 _HEAP\n   +0x030 BaseAddress      : 0x00000269`1d970000 Void\n   +0x038 NumberOfPages    : 0xff\n   +0x040 FirstEntry       : 0x00000269`1d970740 _HEAP_ENTRY\n   +0x048 LastValidEntry   : 0x00000269`1da6f000 _HEAP_ENTRY\n   +0x050 NumberOfUnCommittedPages : 0xee\n   +0x054 NumberOfUnCommittedRanges : 1\n   +0x058 SegmentAllocatorBackTraceIndex : 0\n   +0x05a Reserved         : 0\n   +0x060 UCRSegmentList   : _LIST_ENTRY [ 0x00000269`1d980fe0 - 0x00000269`1d980fe0 ]\n   +0x070 Flags            : 0x40000062\n   +0x074 ForceFlags       : 0x40000060\n   +0x078 CompatibilityFlags : 0x20000000\n   +0x07c EncodeFlagMask   : 0x100000\n   +0x080 Encoding         : _HEAP_ENTRY\n   +0x090 Interceptor      : 0\n   +0x094 VirtualMemoryThreshold : 0xff00\n   +0x098 Signature        : 0xeeffeeff\n   +0x0a0 SegmentReserve   : 0x100000\n   +0x0a8 SegmentCommit    : 0x2000\n   +0x0b0 DeCommitFreeBlockThreshold : 0x100\n   +0x0b8 DeCommitTotalFreeThreshold : 0x1000\n   +0x0c0 TotalFreeSize    : 0x2a3\n   +0x0c8 MaximumAllocationSize : 0x00007fff`fffdefff\n   +0x0d0 ProcessHeapsListIndex : 1\n   +0x0d2 HeaderValidateLength : 0x2c0\n   +0x0d8 HeaderValidateCopy : (null)\n   +0x0e0 NextAvailableTagIndex : 0\n   +0x0e2 MaximumTagIndex  : 0\n   +0x0e8 TagEntries       : (null)\n   +0x0f0 UCRList          : _LIST_ENTRY [ 0x00000269`1d980fd0 - 0x00000269`1d980fd0 ]\n   +0x100 AlignRound       : 0x2f\n   +0x108 AlignMask        : 0xffffffff`fffffff0\n   +0x110 VirtualAllocdBlocks : _LIST_ENTRY [ 0x00000269`1d970110 - 0x00000269`1d970110 ]\n   +0x120 SegmentList      : _LIST_ENTRY [ 0x00000269`1d970018 - 0x00000269`1d970018 ]\n   +0x130 AllocatorBackTraceIndex : 0\n   +0x134 NonDedicatedListLength : 0\n   +0x138 BlocksIndex      : 0x00000269`1d9702e8 Void\n   +0x140 UCRIndex         : (null)\n   +0x148 PseudoTagEntries : (null)\n   +0x150 FreeLists        : _LIST_ENTRY [ 0x00000269`1d980fb0 - 0x00000269`1d97ce40 ]\n   +0x160 LockVariable     : 0x00000269`1d9702c0 _HEAP_LOCK\n   +0x168 CommitRoutine    : 0x429174d2`cc6cc977     long  +429174d2cc6cc977\n   +0x170 StackTraceInitVar : _RTL_RUN_ONCE\n   +0x178 CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA\n   +0x198 FrontEndHeap     : (null)\n   +0x1a0 FrontHeapLockCount : 0\n   +0x1a2 FrontEndHeapType : 0 ''\n   +0x1a3 RequestedFrontEndHeapType : 0 ''\n   +0x1a8 FrontEndHeapUsageData : 0x00000269`1d970750  \"\"\n   +0x1b0 FrontEndHeapMaximumIndex : 0x80\n   +0x1b2 FrontEndHeapStatusBitmap : [129]  \"\"\n   +0x238 Counters         : _HEAP_COUNTERS\n   +0x2b0 TuningParameters : _HEAP_TUNING_PARAMETERS\n   \n   \n000002691D970000\n000002691D970000        00000000 00000000 76b307d9 01001d46\n000002691D970054        ffeeffee 00000002 1d970120 00000269\n000002691D9700A8        1d970120 00000269 1d970000 00000269\n000002691D9700FC        1d970000 00000269 000000ff 00000000\n000002691D970150        1d970740 00000269 1da6f000 00000269\n000002691D9701A4        000000ee 00000001 00000000 00000000\n000002691D9701F8        1d980fe0 00000269 1d980fe0 00000269\n000002691D97024C        40000062 40000060 20000000 00100000\n</code></pre>\n</div>\n</body></html>",
            "votes": "0",
            "user": "blabb",
            "time": "Sep 13, 2024 at 9:45",
            "is_accepted": true,
            "comments": [
                {
                    "user": "maarten",
                    "text": "<span class=\"comment-copy\">Thank! I'll attribute the different offsets I'm seeing in the executable to the newer heap implementations of later NT versions. It would still be nice to see the heap lay-out of old windows 95/98.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<html><body><div class=\"s-prose js-post-body\" itemprop=\"text\">\n <p>\n  GetProcessHeap returns a handle to the default process heap.\nThe handle is not a struct but a base address to the default heap address space itself.\nMeaning that if you will use HeapAlloc passing that heap handle as a parameter, the allocated memory will be allocated from the address space beginning from the handle value.\n </p>\n <p>\n  References:\n </p>\n <ul>\n  <li>\n   [\n   <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-getprocessheap#return-value\" rel=\"nofollow noreferrer\">\n    1\n   </a>\n   ]\n  </li>\n  <li>\n   [\n   <a href=\"https://stackoverflow.com/questions/76059934/masm-x86-in-assembly-what-is-the-difference-between-heap-handle-and-pointer-t\">\n    2\n   </a>\n   ]\n  </li>\n </ul>\n</div>\n</body></html>",
            "votes": "0",
            "user": "rotem.salinas",
            "time": "Sep 12, 2024 at 23:19",
            "is_accepted": false,
            "comments": [
                {
                    "user": "maarten",
                    "text": "<span class=\"comment-copy\">Indeed, the docs say it returns a handle. But the code is not calling <code>HeapAlloc</code>. So I'm wondering whether this code is plain bad, or is using undocumented behavior.</span>",
                    "time": null
                }
            ]
        }
    ]
}