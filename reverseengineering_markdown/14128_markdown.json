{
  "title": "x86 sbb with same register as first and second operand",
  "link": "https://reverseengineering.stackexchange.com/questions/14128/x86-sbb-with-same-register-as-first-and-second-operand",
  "content": "I am analyzing a sequence of x86 instructions, and become confused with the following code:\n\n```\n135328495: sbb edx, edx\n135328497: neg edx\n135328499: test edx, edx\n135328503: jz 0x810f31c\n\n```\nI understand that sbb equals to des = des - (src + CF), in other words, the first instruction somehow put -CF into edx. Then it negtive -CF into CF, and test whether CF equals to zero??\n\nBut note that jz checks flag ZF, not CF! So basically what is the above code sequence trying to do? This is a legal x86 instruction sequence, produced by g++ version 4.6.3.\n\n",
  "votes": "2",
  "answers": 1,
  "views": "6k",
  "tags": [
    "assembly",
    "x86"
  ],
  "user": "lllllllllllll",
  "time": "Dec 8, 2016 at 4:57",
  "comments": [
    {
      "user": "Igor Skochinsky",
      "text": "post more instructions before the sbb",
      "time": null
    },
    {
      "user": "Arash",
      "text": "the test edx, edx will affect ZF. and about code it's hard to guess by a snipped assembly, but obviously the compiler is trying to save CF inside edx and then checking the edx (which is CF).",
      "time": null
    },
    {
      "user": "Cody Gray",
      "text": "Cross-site duplicate: stackoverflow.com/questions/41031912/â€¦",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "The sbb edx, edx statement writes either 0 or -1 to edx, depending only on the value of the carry flag. The following neg edx simply reflects the value of the initial carry flag. Thus the jz in your sequence is nothing else than a jnc statement (jmp on non-carry).\nHowever, this sequence might be found with an additional, preceding neg eax. The neg statement clears the carry in the zero case, otherwise sets it. This sequence might be used as a test for true or false, depending whether edx has some arbitrary nonzero value (true) or zero value (false). The sequence with the additional neg would then look like this:\n\n```\nneg edx          ; clears the carry flag in the zero case, otherwise sets it\nsbb edx, edx     ; if (cf == 0) then edx == 0, else edx == -1\nneg edx          ; remains zero if initially edx has been zero, else 1\ntest edx, edx    ;\njz toSomewhere   ; jmp on edx having been zero initially\n\n```\nbtw, this is one of the questions I am planning for a reversing quiz.\n\nHave fun!\n\n",
      "votes": "4",
      "user": "josh",
      "time": "Dec 9, 2016 at 0:19",
      "is_accepted": true,
      "comments": [
        {
          "user": "Cody Gray",
          "text": "It is certainly a question that tests one's knowledge of the instruction set, but it's otherwise extremely questionable code. The entire thing could be replaced with a single JNC toSomewhere instruction... I cannot think of a good reason why a compiler would ever generate code like this.",
          "time": null
        },
        {
          "user": "josh",
          "text": "Of course you are right for the code without the neg in my first line. But with it, the compilers use such pattern frequently for the described true/false decisions. The MS compiler uses a slightly modified variant.",
          "time": null
        },
        {
          "user": "Cody Gray",
          "text": "Yes, MSVC uses the sbb+neg pattern (combined with a trailing or leading neg, inc, or dec as appropriate for the logic) extensively. But only when it is generating branchless code. If it's going to emit a conditional branch (in this case, jz) anyway, there's absolutely no point in paying the penalty for all of these additional instructions.",
          "time": null
        },
        {
          "user": "josh",
          "text": "Maybe the OP can unveil the secret by showing us some more of his code generated by g++...",
          "time": null
        },
        {
          "user": "lllllllllllll",
          "text": "@CodyGray Hey, thank you so much for your very informative replies. I learned a lot for both here and the stackoverflow. The C++ code is actually from the botan project. I will try to find the corresponding source code for this instruction sequence and provide to you later. At the mean while, you can find the overall assembly code (the Botan RSA decryption example) at here. There are quite a lot of such instruction sequence in the disassembled code.",
          "time": null
        }
      ]
    }
  ]
}