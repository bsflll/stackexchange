{
  "title": "How to reverse engineer a Linux executable to find the parameters? [closed]",
  "link": "https://reverseengineering.stackexchange.com/questions/14209/how-to-reverse-engineer-a-linux-executable-to-find-the-parameters",
  "content": "So I am on a Linux box with an executable.Vague - I know. This is what happens when I try and run it with an argument/parameter:\n\n```\nme@there:~$ ./theFile theOption -a\n./theFile : option requires an argument -- 'a'\nusage: theOption [parameters]\n\n```\nMy colleague said just use objdump to reverse theFile first part of the main function.\n\nMy question is whether it's possible to find what parameters can be passed to the program. I have the name of some functions like do_this and do_that, but insure how to pass these to the executable.\n\n",
  "votes": "9",
  "answers": 2,
  "views": "27k",
  "tags": [
    "linux",
    "objdump"
  ],
  "user": "pee2pee",
  "time": "8 years ago",
  "comments": [
    {
      "user": "yaspr",
      "text": "Check out this link, it might help : tldp.org/LDP/LG/issue84/hawk.html",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "It is possible to determine what command line arguments or options can be passed to a Linux executable. Of course, how this can be done will depend on the type and design of the program and on factors such as obfuscation, encryption, compression, etc.\n\nLinux executables designed to be easily usable by humans and whose behavior changes depending on what command line arguments they receive, such as ls, cat, grep etc., are typically ELF binaries and have documentation of their usage hardcoded in the .rodata section. This data can be examined using readelf -x .rodata ELF_BINARY_NAME.\n\nExample:\n\n```\n  $ readelf -x .rodata /bin/ls | less\n                               .\n                         <lots of data>\n                               .\n  0x00413e90 20202d61 2c202d2d 616c6c20 20202020   -a, --all     \n  0x00413ea0 20202020 20202020 20202020 20646f20              do \n  0x00413eb0 6e6f7420 69676e6f 72652065 6e747269 not ignore entri\n  0x00413ec0 65732073 74617274 696e6720 77697468 es starting with\n  0x00413ed0 202e0a20 202d412c 202d2d61 6c6d6f73  ..  -A, --almos\n  0x00413ee0 742d616c 6c202020 20202020 20202020 t-all           \n  0x00413ef0 646f206e 6f74206c 69737420 696d706c do not list impl\n  0x00413f00 69656420 2e20616e 64202e2e 0a202020 ied . and ...   \n                               .\n                        <even more data>\n\n```\nThis means that even if there is no man page for the program on your system, no README files, and no source code, you can still look at how it is documented internally manually.\n\nThis pertains specifically to the example provided in the question:\n\n```\nme@there:~$ ./theFile theOption -a\n./theFile : option requires an argument -- 'a'\nusage: theOption [parameters]\n\n```\nWhat is happening in this example is that some command line option is passed to the executable and the executable then prints some strings about proper usage to STDOUT. The implication of this in the context of deducing valid command line arguments is that there are hardcoded strings in the executable that document proper usage that can be located using static analysis.\n\nPart 1: Static Analysis\n\nWe can take advantage of program design considerations made when designing  Linux userspace applications that accept command line arguments to identify what arguments the program expects when analyzing the binary. For example, what mechanisms exist to parse n-many command line arguments passed to the program when executing it? How is a program designed such that it can successfully determine what arguments are valid and what arguments are invalid? What if 1,000 arguments are passed? The design of programs that process command line arguments must reflect the fact that such input can be arbitrary.\n\nA common design pattern employed in a Linux environment to address this is using a combination of the GNU C library function getopt() and a switch construct inside a loop. getopt() parses the command-line arguments and the parsed argument is then evaluated by the switch construct. This can be used as a heuristic when analyzing the binary.\n\nTo illustrate this, we can analyze a \"mystery\" ELF binary that processes command line arguments.\n\n```\n$ file mystery_program \nmystery_program: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=3286c11349d82c58257a14e4d174b9ec5f313714, stripped\n\n```\nThis program is dynamically linked, which means that even though it is stripped it still contains information about what libraries are linked and loaded at runtime and also what functions in these libraries the program uses. Since getopt() is a glibc (shared library or .so*) function, if our dynamically-linked binary uses it then an entry in the .dynsym section will include information about it. Entry 21 in the output of readelf --dyn-syms mystery_program confirms that getopt() is indeed used in the program:\n\n```\n $ readelf --dyn-syms mystery_program \n\nSymbol table '.dynsym' contains 79 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __uflow@GLIBC_2.2.5 (2)\n     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND getenv@GLIBC_2.2.5 (2)\n     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND free@GLIBC_2.2.5 (2)\n     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND abort@GLIBC_2.2.5 (2)\n     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __errno_location@GLIBC_2.2.5 (2)\n     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strncmp@GLIBC_2.2.5 (2)\n     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _exit@GLIBC_2.2.5 (2)\n     8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strcpy@GLIBC_2.2.5 (2)\n     9: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __fpending@GLIBC_2.2.5 (2)\n    10: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND iconv@GLIBC_2.2.5 (2)\n    11: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND iswcntrl@GLIBC_2.2.5 (2)\n    12: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND write@GLIBC_2.2.5 (2)\n    13: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND textdomain@GLIBC_2.2.5 (2)\n    14: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fclose@GLIBC_2.2.5 (2)\n    15: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND bindtextdomain@GLIBC_2.2.5 (2)\n    16: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND stpcpy@GLIBC_2.2.5 (2)\n    17: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND dcgettext@GLIBC_2.2.5 (2)\n    18: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __ctype_get_mb_cur_max@GLIBC_2.2.5 (2)\n    19: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strlen@GLIBC_2.2.5 (2)\n    20: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (3)\n==> 21: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND getopt_long@GLIBC_2.2.5 (2)\n    22: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND mbrtowc@GLIBC_2.2.5 (2)\n    23: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strchr@GLIBC_2.2.5 (2)\n    24: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strrchr@GLIBC_2.2.5 (2)\n<output snipped>\n\n```\nThe version of getopt() being used in this program is getopt_long(). To see in what context getopt_long() is called, we can use objdump:\n\n```\n$ objdump -dj .text mystery_program | grep getopt -B10 -A25\n  401aa6:   c6 84 24 80 00 00 00    movb   $0x0,0x80(%rsp)\n  401aad:   00 \n  401aae:   c6 84 24 84 00 00 00    movb   $0x0,0x84(%rsp)\n  401ab5:   00 \n  401ab6:   c6 44 24 57 00          movb   $0x0,0x57(%rsp)\n  401abb:   8b 7c 24 58             mov    0x58(%rsp),%edi\n  401abf:   45 31 c0                xor    %r8d,%r8d\n  401ac2:   b9 00 90 40 00          mov    $0x409000,%ecx\n  401ac7:   ba 23 8f 40 00          mov    $0x408f23,%edx\n  401acc:   48 89 de                mov    %rbx,%rsi\n  401acf:   e8 3c fc ff ff          callq  401710 <getopt_long@plt>          <===\n  401ad4:   83 f8 ff                cmp    $0xffffffff,%eax\n  401ad7:   0f 84 10 01 00 00       je     401bed <__sprintf_chk@plt+0x1bd>\n  401add:   83 f8 62                cmp    $0x62,%eax\n  401ae0:   0f 84 f3 00 00 00       je     401bd9 <__sprintf_chk@plt+0x1a9>\n  401ae6:   7e 2c                   jle    401b14 <__sprintf_chk@plt+0xe4>\n  401ae8:   83 f8 73                cmp    $0x73,%eax\n  401aeb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)\n  401af0:   0f 84 d6 00 00 00       je     401bcc <__sprintf_chk@plt+0x19c>\n  401af6:   7e 6a                   jle    401b62 <__sprintf_chk@plt+0x132>\n  401af8:   83 f8 75                cmp    $0x75,%eax\n  401afb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)\n  401b00:   74 b9                   je     401abb <__sprintf_chk@plt+0x8b>\n  401b02:   7c 72                   jl     401b76 <__sprintf_chk@plt+0x146>\n  401b04:   83 f8 76                cmp    $0x76,%eax\n  401b07:   0f 85 d6 00 00 00       jne    401be3 <__sprintf_chk@plt+0x1b3>\n  401b0d:   c6 44 24 53 01          movb   $0x1,0x53(%rsp)\n  401b12:   eb a7                   jmp    401abb <__sprintf_chk@plt+0x8b>\n  401b14:   83 f8 41                cmp    $0x41,%eax\n  401b17:   74 34                   je     401b4d <__sprintf_chk@plt+0x11d>\n  401b19:   7f 19                   jg     401b34 <__sprintf_chk@plt+0x104>\n  401b1b:   3d 7d ff ff ff          cmp    $0xffffff7d,%eax\n  401b20:   74 64                   je     401b86 <__sprintf_chk@plt+0x156>\n  401b22:   3d 7e ff ff ff          cmp    $0xffffff7e,%eax\n  401b27:   0f 85 b6 00 00 00       jne    401be3 <__sprintf_chk@plt+0x1b3>\n  401b2d:   31 ff                   xor    %edi,%ed\n\n```\nThe call to getopt_long() at address 401acf is followed by disassembly of a jump table, indicative of the presence of a switch sequence. The jump table is much longer but what is displayed here is enough to get the idea. If we look more closely at the jump table we see that hex values that look like ASCII codes are compared to %eax, which by convention holds the return value of getopt_long():\n\n```\n  .\n  .\n  401add:   83 f8 62                cmp    $0x62,%eax       # 0x62 is '>'\n  .\n  .\n  401ae8:   83 f8 73                cmp    $0x73,%eax       # 0x73 is 'I'\n  .\n  .  \n  401af8:   83 f8 75                cmp    $0x75,%eax       # 0x75 is 'K'\n  .\n  .\n  401b04:   83 f8 76                cmp    $0x76,%eax       # 0x76 is 'L'\n  .\n  .\n  401b14:   83 f8 41                cmp    $0x41,%eax       # 0x41 is ')'\n  .\n  .\n  401b34:   83 f8 45                cmp    $0x45,%eax       # 0x45 is '-'\n  .\n  .\n  401b39:   83 f8 54                cmp    $0x54,%eax       # 0x54 is '6'\n  .\n  .\n<more comparisons>\n\n```\nThis program is parsing command line arguments and its execution path branches based on whatever ASCII characters it has specific conditionals for. While this is not going to immediately yield what arguments are valid and what arguments are not valid, it is a start. Static analysis with Linux binutils (and my limited knowledge and skills) can only get us so far.\n\nPart 2: Dynamic Analysis\n\nThere are two factors that are quite helpful in dynamically analyzing this \"mystery\" binary in order to determine what the valid command line arguments are.\n\nThe first is that even though this binary is stripped, getopt_long() is in a shared library, and in order to be dynamically linked to the binary some symbol information about getopt_long() must be preserved. This is why when objdump was used to statically analyze some dissasembled code from this stripped binary getopt_long() was still referred to by name. This means that we have the exact address in the binary where getopt_long() is called, which allows us to set a break point at that address without having to rummage around in the binary for hours and hours. In other words, we do not need to know in what function getopt_long() is called, whether in main() or some other function; we can just let the program execute until the break point at that address is hit. As a quick reminder, getopt_long() was called at address 401acf:\n\n```\n $ objdump -dj .text mystery_program | grep getopt\n   401acf:  e8 3c fc ff ff          callq  401710 <getopt_long@plt>\n\n```\nThe second is that a string composed of all valid command line options is passed to getopt() when it is called, as we see in its function prototypes. From the synopsis in its man page:\n\n```\n#include <unistd.h>\n\nint getopt(int argc, char * const argv[],\n           const char *optstring);\n\nextern char *optarg;\nextern int optind, opterr, optopt;\n\n#include <getopt.h>\n\nint getopt_long(int argc, char * const argv[],\n                const char *optstring,\n                const struct option *longopts, int *longindex);\n\nint getopt_long_only(int argc, char * const argv[],\n                     const char *optstring,\n                     const struct option *longopts, int *longindex);\n\n```\nOf these three prototypes, the prototype for getopt_long() is the one of interest in this particular case. According to the prototype, getopt_long() is passed a pointer to the options string as well as a pointer to a struct holding long options. This means that both the single-character options as well as option strings can be discovered by investigating these pointers at the point in the program getopt_long() is called. gdb can be used to perform the analysis:\n\n```\n$ gdb -q mystery_program\nReading symbols from mystery_program...(no debugging symbols found)...done.\n(gdb) break *0x401acf\nBreakpoint 1 at 0x401acf\n(gdb) run\nStarting program: mystery_program \n\nBreakpoint 1, 0x0000000000401acf in ?? ()\n(gdb) x/i $rip\n=> 0x401acf:    callq  0x401710 <getopt_long@plt>\n(gdb)\n\n```\nAs is demonstrated here, it is not necessary to know where main() is or even what the program entry point is. \n\nThis is the point at which getopt_long() is called. Time to investigate the registers.\n\n```\n(gdb) info registers \nrax            0x0  0\nrbx            0x7fffffffe138   140737488347448\nrcx            0x409000 4231168\nrdx            0x408f23 4230947\nrsi            0x7fffffffe138   140737488347448\nrdi            0x1  1\nrbp            0x1000   0x1000\nrsp            0x7fffffffdee0   0x7fffffffdee0\nr8             0x0  0\nr9             0x2  2\nr10            0x7fffffffdca0   140737488346272\nr11            0x7ffff7a51410   140737348178960\nr12            0x402602 4204034\nr13            0x7fffffffe130   140737488347440\nr14            0x0  0\nr15            0x0  0\nrip            0x401acf 0x401acf\neflags         0x246    [ PF ZF IF ]\n\n```\n%rcx and %rdx look interesting.\n\n```\n(gdb) x/s $rdx\n0x408f23:   \"benstuvAET\"\n\n```\nThat's the option character string, composed of all character options that the program uses. The options are -b, -e, -n, -s, etc.\n\nWhat about the long options? \n\n```\n(gdb) x/s $rcx\n0x409000:   \"\\225\\217@\"        # oops, that is not a string\n(gdb) x/xg $rcx\n0x409000:   0x0000000000408f95\n(gdb) x/s 0x0000000000408f95\n0x408f95:   \"number-nonblank\"\n(gdb)\n\n```\nSo one long option is \"--number-nonblank\". \n\n```\n(gdb) x/s 0x0000000000408f95+64\n0x408fd5:   \"show-tabs\"\n(gdb) \n\n```\nAnother is \"--show-tabs\".\n\nAnd so on.\n\nIf you have reached this point and have not died of boredom, congrats. It turns out that this \"mystery\" program is actually cat, a well-known Linux utility. In this particular case it was possible to discover what command line options the program was expecting.\n\nIt is important to note that throughout the entire course of this example analysis the arguments/options passed to mystery_program/cat were never examined. When a user passes options x, y and z to some program and then analyzes it, it is not useful to then go to main() and then look at the strings in *argv[] since they are already known: argv[0] points to the program name, argv[1] points to the first argument after the program name, x, etc. \n\nInvestigating main() is done to recover what arguments were passed to the program when it was executed, not to determine what options a program will actually use. As was illustrated in the example, that information lies elsewhere in the program.\n\n",
      "votes": "18",
      "user": "julian",
      "time": "Jan 23, 2017 at 1:52",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "As I don't know much about your executable, I would first run strings with your program to see if anything comes up: this work if the binary has a description.\n(I'm stuck on a Windows now, but strings seem to work in the same exact way it does on Linux)\n\n```\n{ ~ }  » strings.exe /bin/ls.exe  \n...\nUsage: %s [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\nMandatory arguments to long options are mandatory for short options too.\n  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n                               '--block-size=M' prints sizes in units of\n                               1,048,576 bytes; see SIZE format below\n  -B, --ignore-backups       do not list implied entries ending with ~\n...\n\n```\nIn this case those strings are part of the binary and are used when parameters are not valid or missing.\nIf that fails, can't you just run it with some random values and run ltrace (or strace if you want to take a closer look) and guess what the possible parameters are ?\n\n",
      "votes": "1",
      "user": "shxdow",
      "time": "Dec 21, 2016 at 19:36",
      "is_accepted": false,
      "comments": []
    }
  ]
}