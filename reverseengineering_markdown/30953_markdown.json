{
  "title": "Reversing Assembly Code (ASM) to Extract Password (Pin)",
  "link": "https://reverseengineering.stackexchange.com/questions/30953/reversing-assembly-code-asm-to-extract-password-pin",
  "content": "I'm new to binary exploitation and CTF challenges. I need to solve a CTF challenge and find the flag. All the program does is display \"Flag length is: 32\". I've tried to analyze the file using IDA pro.\n\nI think that the flag value is in rcx register, but I don't know how to extract it. Could you please help me solve the challenge or give me resources to learn?\n\nHere is the main fucntion's code (C and assembler):\n\nC:\n\n```\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  size_t v3; // rax\n\n  char Str[40]; // [rsp+20h] [rbp-30h] BYREF\n\n  int j; // [rsp+48h] [rbp-8h]\n\n  int i; // [rsp+4Ch] [rbp-4h]\n\n\n  _main();\n\n  for ( i = 0; i <= 33; ++i )\n\n    Str[i] = 0;\n\n  for ( j = 0; j <= 31; ++j )\n\n    Str[j] = buff[j + 15] ^ 0x3A;\n\n  v3 = strlen(Str);\n\n  printf(\"Flag length is: %d  \n\", v3);\n\n  return 0;\n\n}\n\n```\nAssembler:\n\n```\nint __cdecl main(int argc, const char **argv, const char **envp)\n\n                 public main\n\n main            proc near               ; CODE XREF: __tmainCRTStartup+243↑p\n\n\n\n Str             = byte ptr -30h\n\n var_8           = dword ptr -8\n\n var_4           = dword ptr -4\n\n\n\n                 push    rbp\n\n                 mov     rbp, rsp\n\n                 sub     rsp, 50h\n\n ; 7:   _main();\n\n                 call    __main\n\n ; 8:   for ( i = 0; i <= 33; ++i )\n\n                 mov     [rbp+var_4], 0\n\n                 jmp     short loc_4015D4\n\n ; ---------------------------------------------------------------------------\n\n ; 9:     Str[i] = 0;\n\n\n\n loc_4015C6:                             ; CODE XREF: main+28↓j\n\n                 mov     eax, [rbp+var_4]\n\n                 cdqe\n\n                 mov     [rbp+rax+Str], 0\n\n                 add     [rbp+var_4], 1\n\n\n\n loc_4015D4:                             ; CODE XREF: main+14↑j\n                 cmp     [rbp+var_4], 21h ; '!'\n\n                 jle     short loc_4015C6\n\n\n ; 10:   for ( j = 0; j <= 31; ++j )\n\n                 mov     [rbp+var_8], 0\n\n                 jmp     short loc_401609\n\n ; ---------------------------------------------------------------------------\n\n ; 11:     Str[j] = buff[j + 15] ^ 0x3A;\n\n\n\n loc_4015E3:                             ; CODE XREF: main+5D↓j\n\n                 mov     eax, [rbp+var_8]\n\n                 add     eax, 0Fh\n\n                 movsxd  rdx, eax\n\n                 lea     rax, buff\n\n                 movzx   eax, byte ptr [rdx+rax]\n\n                 xor     eax, 3Ah\n\n                 mov     edx, eax\n\n                 mov     eax, [rbp+var_8]\n\n                 cdqe\n\n                 mov     [rbp+rax+Str], dl\n\n                 add     [rbp+var_8], 1\n\n\n\n loc_401609:                             ; CODE XREF: main+31↑j\n\n                 cmp     [rbp+var_8], 1Fh\n\n                 jle     short loc_4015E3\n\n ; 12:   v3 = strlen(Str);\n\n                 lea     rax, [rbp+Str]\n\n                 mov     rcx, rax        ; Str\n\n                 call    strlen\n\n ; 13:   printf(\"Flag length is: %d  \n\", v3);\n\n                 mov     rdx, rax\n\n                 lea     rcx, Format     ; \"Flag length is: %d  \n\"\n\n                 call    printf\n\n ; 14:   return 0;\n\n                 mov     eax, 0\n\n                 add     rsp, 50h\n\n                 pop     rbp\n\n                 retn\n\n main            endp\n\n```\n",
  "votes": "1",
  "answers": 0,
  "views": "143",
  "tags": [
    "disassembly",
    "assembly",
    "exploit",
    "exe",
    "pwntools"
  ],
  "user": "Анатолий Городничий",
  "time": "Nov 29, 2022 at 7:07",
  "comments": [],
  "answers_data": []
}