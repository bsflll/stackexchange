{
  "title": "How to remove OFF64 SEGDEF from IDA disassembly",
  "link": "https://reverseengineering.stackexchange.com/questions/27339/how-to-remove-off64-segdef-from-ida-disassembly",
  "content": "This has plagued me from IDA 6.5 to 7.5.\n\n```\n.text:0000000143EFE8CD CC                     db 0CCh ; ÃŒ OFF64 SEGDEF [_text,140CFC35B]\n\n```\nIt may not look like much, but when a conditional jump is placed over such a location, the result is debilitating.\n\n```\n.text:0000000143EFE8B6 0F 8F 9F DA DF FC      jg      loc_143019000-231CCA5h\n\n```\nEvery instance creates an xref to the third .text segment at 0x143019000 along with multiple levels of chunk ownership, and Hexrays produces errors such as:\n\n```\n143019029: control flows out of bounds to 14301902A\n143019007: control flows out of bounds to 143018FB1\n143019023: control flows out of bounds to 143018FCD\n\n```\nI cannot remove, reproduce or detect the presence of these OFF64 SEGDEF lines, though the conditional jumps have the flag bit FF_0OFF set.\n\nThese OFF64 SEGDEFs appear where-ever an abs mov was previously (they're being replaced in a de-obfuscation process), the one in this question previously being:\n\n```\n.text:0000000143EFE8CB 48 BA 5B C3 CF 40 01+  mov     rdx, offset loc_140CFC35B\n.text:0000000143EFE8CB 00 00 00\n\n```\nAssembling an identical statement to another another location does not cause one to appear.\n\nI have tried ida_bytes.del_items, ida_bytes.del_value (hides it, but it re-appears when repopulated),  ida_bytes.del_mapping and some other things I don't recall.  I've also tried forcing re-analysis with the bytes nopped over, though a need an IDAPython solution.\n\nI've also tried some segment related functions in an effort to create a similar effect, in the hope the anything I know how to make I can then remove, but I failed in this effort also; my experience in segment-based assembly is minimal and from the 90's.\n\n",
  "votes": "1",
  "answers": 2,
  "views": "348",
  "tags": [
    "ida"
  ],
  "user": "Orwellophile",
  "time": "Mar 28, 2021 at 15:31",
  "comments": [],
  "answers_data": [
    {
      "content": "The comment indicates that there is fixup (aka relocation) information attached to the address. IDA tries to take it into account when displaying data or disassembly items, resulting in awkward expressions. If you're sure that the relocation is bogus and is no longer used after deobfuscation, you can delete it using idaapi.del_fixup(<address>) IDAPython function.\n\n",
      "votes": "1",
      "user": "Igor Skochinsky",
      "time": "Mar 29, 2021 at 10:55",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "Though Igor kindly answered my immediate question, I was still left with the problem of how to conveniently dispose of these unused fixups.  Fortunately I already use my own MakeUnknown and PatchBytes function, so I was able to simply include removal of fixup information with those and forget about the entire problem.\n\nI am including this code as an example of how to detect if a fixup is present, as ida_fixups.exists_fixup doesn't necessarily return what you think it will, if a fixup is hiding under an unexpected byte within an instruction.\n\nI've also included a fixup visitor.\n\n```\ndef MyMakeUnknown(ea, nbytes, flags = 0):\n    r\"\"\"\n    @param ea:      any address within the first item to delete (C++: ea_t)\n    @param nbytes:  number of bytes in the range to be undefined (C++: asize_t)\n    @param flags:   combination of:     DELIT_EXPAND    DELIT_DELNAMES\n                                        DELIT_NOTRUNC   DELIT_NOUNAME\n                                        DELIT_NOCMT     DELIT_KEEPFUNC\n    @param may_destroy: optional callback invoked before deleting a head item.\n                        if callback returns false then deletion and operation\n                        fail. (C++: may_destroy_cb_t *)\n    @return: true on sucessful operation, otherwise false\n\n    Convert item (instruction/data) to unexplored bytes. The whole item\n    (including the head and tail bytes) will be destroyed. \n    \"\"\"\n    # check if caller has invoked with (start_ea, end_ea)\n    if nbytes > ea:\n        nbytes = nbytes - ea\n\n    result = idaapi.del_items(ea, flags, nbytes)\n    if not result:\n        return result\n    \n    # check for fixups that must be removed \n    # https://reverseengineering.stackexchange.com/questions/27339/\n\n    fx = idaapi.get_next_fixup_ea(ea - 1)\n    while fx < ea + nbytes:\n        idaapi.del_fixup(fx)\n        fx = idaapi.get_next_fixup_ea(fx)\n\n    return result\n\ndef MyMakeUnkn(ea, flags = 0):\n    return MyMakeUnknown(ea, 1, flags)\n\ndef example_fixup_visitor(ea):\n    line = idc.generate_disasm_line(ea, 0)\n    print(\"{:16x} {}\".format(ea, line))\n\ndef visit_fixups(iteratee):\n    ea = idaapi.get_first_fixup_ea()\n    while ea != idc.BADADDR:\n        iteratee(ea)\n        ea = idaapi.get_next_fixup_ea(ea)\n\n# This is a bit length, so it's left until the end.\ndef PatchBytes(ea, patch=None, comment=None):\n    \"\"\"\n    @param ea [optional]:           address to patch (or ommit for screen_ea)\n    @param patch list|string|bytes: [0x66, 0x90] or \"66 90\" or b\"\\x66\\x90\"\n    @param comment [optional]:      comment to place on first patched line\n\n    @returns int containing nbytes patched\n\n    Can be invoked as PatchBytes(ea, \"66 90\"), PatchBytes(\"66 90\", ea),\n    or just PatchBytes(\"66 90\").\n    \"\"\"\n\n\n\n    if isinstance(ea, (list, str)):\n        ea, patch = patch, ea\n    elif ea is None:\n        ea = idc.get_screen_ea()\n    old_code = idc.is_code(idc.get_full_flags(idc.get_item_head(ea)))\n    old_head = idc.get_item_head(ea)\n\n\n    if isinstance(patch, str):\n        def intify(s): return -1 if '?' in s else int(s, 16)\n        patch = [hex_byte_as_pattern_int(x) for x in patch.split(' ')]\n\n    length = len(patch)\n    # deal with fixups\n    fx = idaapi.get_next_fixup_ea(ea - 1)\n    while fx < ea + length:\n        idaapi.del_fixup(fx)\n        fx = idaapi.get_next_fixup_ea(fx)\n\n    if type(getattr(__builtins__, 'bytes', None)) == 'type' and isinstance(patch, bytes):\n        idaapi.patch_bytes(ea, patch)\n    else:\n        [idc.patch_byte(ea+i, patch[i]) for i in range(length) if patch[i] != -1]\n        #  for i in range(length):\n            #  if patch[i] != -1:\n                #  idc.patch_byte(ea+i, patch[i])\n\n    idc.auto_wait()\n\n    if comment:\n        comment_formatted = \"[PatchBytes:{:x}-{:x}] {}\".format(ea, ea + length, str(comment))\n        if 'Commenter' in globals():\n            Commenter(old_head, 'line').add(comment_formatted)\n        else:\n            idaapi.set_cmt(old_head, comment_formatted, 0)\n\n    if old_code:\n        head = old_head\n        while head < ea + length:\n            inslen = idc.get_item_size(head)                                  \\\n                    if idc.is_code(idc.get_full_flags(idc.get_item_head(ea))) \\\n                    else idc.create_insn(head)\n            if inslen < 1:\n                break\n            head += inslen\n\n    return length\n\n```\n",
      "votes": "1",
      "user": "Orwellophile",
      "time": "Mar 30, 2021 at 14:11",
      "is_accepted": false,
      "comments": []
    }
  ]
}