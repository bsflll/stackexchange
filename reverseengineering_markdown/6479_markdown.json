{
  "title": "Insert jmp detour into a compiled program",
  "link": "https://reverseengineering.stackexchange.com/questions/6479/insert-jmp-detour-into-a-compiled-program",
  "content": "I've seen references on Stack Exchange and elsewhere to inserting detours into compiled code. My understanding is that essentially a jmp instruction is inserted and then somehow the patched program is linked with additional code that contains the target of the jmp.\n\nAs a concrete but (hopefully) simple example, consider a program.\n\n```\n#include <stdio.h>\n\nvoid hello(void) {\n    printf(\"Hello \");\n    printf(\"world!  \n\");\n}\n\nint main(void) {\n    hello();\n}\n\n```\nSuppose I have only a binary compiled from this program. No measures have been taken to strip symbols or obfuscate the program in any way. I want to insert a detour to call code compiled from this function.\n\n```\n#include <stdio.h>\n\nvoid detour(void) {\n    printf(\"detoured \");\n}\n\n```\nThe output of the patched program should be:\n\nHow would I do that? How would I avoid breaking address offsets in the compiled code?\n\nMy available compilers are gcc, clang, and icc. My available operating systems are OS X and Ubuntu. Choose whatever you prefer in your answer.\n\nIf this can't reasonably be answered here then a brief overview and a pointer to some reading material would also be a good answer.\n\nI'm aware of LD_PRELOAD and ld --wrap. The example was chosen so that those methods do not easily suffice. (You could of course just detour the entire hello() function to one that prints \"Hello detoured world!\" but lets pretend you don't have the source code and the function is non-trivial.)\n\nRelated Questions\n\nI was first going to ask how to simply disassemble and reassemble a compiled program but that has been asked. The response was that it's extremely difficult. My sense from the answers is that it's not a common thing to do. I suspect my assumption that disassembling and reassembling is a necessary step for detouring might not be correct.\n\nWhy there are not any disassemblers that can generate re-assemblable asm code?\n\nA similar question on StackOverflow received a lukewarm response. This question is focused just on inserting a detour rather than \"modification\" in general and I think the audience here will be more receptive.\n\nhttps://stackoverflow.com/questions/4309771/disassembling-modifying-and-then-reassembling-a-linux-executable\n\nThis Reverse Engineering question asks about modifying binaries in general. A lot of different tools and LD_PRELOAD are mentioned. Some answers say it's possible to do this with a hex editor. I think that's the method I'd be most interested in.\n\nHow do I add functionality to an existing binary executable?\n\nRecent examples I have seen that refer to doing such a thing\n\nA blog post.\n\nhttp://charlessolar.com/post/tag/disassemble\n\nThis Stack Overflow question.\n\nhttps://stackoverflow.com/questions/9449845/how-to-link-object-file-to-executable-compiled-binary\n\n",
  "votes": "4",
  "answers": 1,
  "views": "1k",
  "tags": [
    "disassembly",
    "c",
    "reassembly"
  ],
  "user": "Praxeolitic",
  "time": "May 23, 2017 at 12:37",
  "comments": [
    {
      "user": "Jason Geffner",
      "text": "Are you looking to make the detour in a single specific binary? Or are you looking to make a generic detour \"patcher\" that will work on any binary that contains a function like your hello() function above?",
      "time": null
    },
    {
      "user": "Praxeolitic",
      "text": "I'm looking to understand the process in general.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "I compiled your program on Ubuntu 14.04 and put it on https://mega.co.nz/#!gdRRxRzZ!dw08GEHvXeTxXqurcpMLOxpXVjZa807TJN0PH60h4Rg;\nyou might want to use that binary if you want to retrace the following\nsteps, because if you don't have the exact version of the C compiler and\nlibs, your binary might be different.\n\nThe file is a zip that includes the original detour.c, the compiled program (detour.orig), and the patched one (detour.patched).\n\nFirst, let's disassemble the binary using objdump:\n\n```\n$ objdump -d detour.orig|less\n.. stuff omitted ..\n000000000040057d <hello>:\n  40057d:       55                      push   %rbp\n  40057e:       48 89 e5                mov    %rsp,%rbp\n  400581:       bf 34 06 40 00          mov    $0x400634,%edi\n  400586:       b8 00 00 00 00          mov    $0x0,%eax\n  40058b:       e8 d0 fe ff ff          callq  400460 <printf@plt>\n  400590:       bf 3b 06 40 00          mov    $0x40063b,%edi\n  400595:       e8 b6 fe ff ff          callq  400450 <puts@plt>\n  40059a:       5d                      pop    %rbp\n  40059b:       c3                      retq\n\n000000000040059c <main>:\n  40059c:       55                      push   %rbp\n  40059d:       48 89 e5                mov    %rsp,%rbp\n  4005a0:       e8 d8 ff ff ff          callq  40057d <hello>\n  4005a5:       5d                      pop    %rbp\n  4005a6:       c3                      retq\n  4005a7:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)\n  4005ae:       00 00\n00000000004005b0 <__libc_csu_init>:\n.. more stuff omitted ..\n\n```\nand also check the data sections:\n\n```\n$ objdump  -s detour.orig | less\n.. stuff omitted ..\nContents of section .rodata:\n 400630 01000200 48656c6c 6f200077 6f726c64  ....Hello .world\n 400640 2100                                 !.\nContents of section .eh_frame_hdr:\n.. more stuff omitted ..\n\n```\nAs you see, the strings Hello, world are in the read-only data section, at 400634 and 40063b. These offsets are passed\nto printf and puts in hello. Why puts? Well, the optimizer is clever enough to rewrite a printf of a constant string\nthat ends in '  \n' into a puts; you can see the '  \n' is omitted from the string in the .rodata section.\n\nNow, we want to insert a puts(\"detoured\"). But there's no space in the hello function, and if we tried to insert some bytes\nthere, everything else in the program would be moved, which we want to avoid. Also, there's no space in the .rodata section\nfor another string, the .eh_frame_hdr starts directly behind it.\n\nHowever, check address 4005a7. The main function returns at 4005a6, and the C compiler used some padding to get the next\nfunction,  __libc_csu_init, at a 16-byte boundary. Which means there are a few unused bytes that we can make use of.\nLooking through the rest of the disassembly, we find some more bytes like that:\n\n```\n4004ba          66 0f 1f 44 00 00\n4004e9          0f 1f 80 00 00 00 00\n400529          0f 1f 80 00 00 00 00\n4005a7          66 0f 1f 84 00 00 00 00 00\n400615          66 66 2e 0f 1f 84 00 00 00 00 00\n\n```\nThe last one of these, 400615, has the size to fit the \"detoured \" string in.\n\nNow what we're going to do with the assembly is patch it to:\n\n```\n400590          jmp 4004e9                              e9 54 ff ff ff\n4004e9          mov $0x400615, %edi; jmp 400529         bf 15 06 40 00 eb 39\n400529          callq 400460; jmp 4005a7                e8 32 ff ff ff eb 77\n4005a7          mov 0x40063b, %edi; jmp 400595          bf eb 06 40 00 eb e7\n\n```\nwhich overwrites the instruction at 400590, places the required instructions in the spare bytes, adds jumps between the parts,\nand restores the overwritten mov before jumping to the next instruction.\n\nNow, it's time to use a hex editor to apply these patches to the binary (don't forget to move the 'detoured ' string to 400615\nas well). The resulting binary should be identical to detour.patched from the zip.\n\nLast, we run the patched program:\n\n```\n$ detour.patched\nHello detoured world!\n\n```\nAs you see, the trick is to make us of unused regions within the program, to avoid moving stuff around, which would break offsets.\nI cheated a bit when i put the \"detoured\" string into the code section - this would fail if anything wanted to write-access the string.\nIf i wanted writable data, i would need to use the data section, and possibly even extend it - but that case is much more\ncompliated since i'd have to fiddle with the ELF headers and sizes, and i'd probably need specific ELF tools to get it right.\nThe current example needs nothing but a hex editor. I even crafted the hex coded manually from the opcodes; to get a bit more \nsophisticated, use the radare2 tool.\n\n",
      "votes": "6",
      "user": "Guntram Blohm",
      "time": "Oct 16, 2014 at 15:23",
      "is_accepted": true,
      "comments": [
        {
          "user": "user45891",
          "text": "I'd just like to point out that one (probably) could also change the section characteristics of the code section to make the string writeable (keeping the size constraints in main) or add new sections to put code and data in - which would remove all size constrictions. (At least for the PE format that works)",
          "time": null
        }
      ]
    }
  ]
}