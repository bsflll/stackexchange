{
  "title": "legitimate memory pages that are marked as RWX?",
  "link": "https://reverseengineering.stackexchange.com/questions/15270/legitimate-memory-pages-that-are-marked-as-rwx",
  "content": "In windows and linux x86 (including x86_64) world, is there any legitimate binary (i.e., a program binary generated by the typical compiling-assembling-linking flow and no manual editing on binary after it is generated) that will have RWX memory pages after being loaded? If yes, what are the use cases?\n\n",
  "votes": "2",
  "answers": 3,
  "views": "3k",
  "tags": [
    "x86",
    "memory",
    "binary"
  ],
  "user": "drdot",
  "time": "May 4, 2017 at 5:35",
  "comments": [
    {
      "user": "julian",
      "text": "operating system? compiler? binary format?",
      "time": null
    },
    {
      "user": "drdot",
      "text": "OS: linux, windows. Compiler: gcc, visual studio, binary: ELF.",
      "time": null
    },
    {
      "user": "julian",
      "text": "ELF binaries won't be executed by a windows kernel and ELF segment permissions are denoted RWE rather than RWX",
      "time": null
    },
    {
      "user": "julian",
      "text": "what does it mean for a binary to be considered \"legitimate\"?",
      "time": null
    },
    {
      "user": "drdot",
      "text": "@SYS_V, a program binary generated by the typical compiling-linking-assembling flow, i.e., no manual editing on binary after it is generated.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "Note: this answer corresponds to the original question\n\nProcess segment permissions may vary across architectures and implementations. For example, it is expected that on more recent x86 Linux systems that GCC creates binaries with non-executable stacks. In contrast with this, it used to be the case that MIPS did not even support an non-executable stack - in other words, every MIPS binary had its stack permissions set to RWE.\n\nA kernel patch had to be developed in order to support MIPS executable stack protection:\n\nHere is a concrete example, using a MIPS ELF binary from a ZTE router:\n\n```\n$ file cspd \ncspd: ELF 32-bit MSB executable, MIPS, MIPS-I version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped\n\n```\nNote the permissions of segment GNU_STACK:\n\n```\n$ readelf -l cspd \n\nElf file type is EXEC (Executable file)\nEntry point 0x59d790\nThere are 8 program headers, starting at offset 52\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  PHDR           0x000034 0x00400034 0x00400034 0x00100 0x00100 R E 0x4\n  INTERP         0x000134 0x00400134 0x00400134 0x00014 0x00014 R   0x1\n      [Requesting program interpreter: /lib/ld-uClibc.so.0]\n  REGINFO        0x000148 0x00400148 0x00400148 0x00018 0x00018 R   0x4\n  LOAD           0x000000 0x00400000 0x00400000 0x1ef050 0x1ef050 R E 0x10000\n  LOAD           0x1ef050 0x005ff050 0x005ff050 0x148e2 0x2a070 RW  0x10000\n  DYNAMIC        0x000160 0x00400160 0x00400160 0x00130 0x00130 RWE 0x4\n  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4    <---\n  NULL           0x000000 0x00000000 0x00000000 0x00000 0x00000     0x4\n\n Section to Segment mapping:\n  Segment Sections...\n   00     \n   01     .interp \n   02     .reginfo \n   03     .interp .reginfo .dynamic .hash .dynsym .dynstr .init .text .MIPS.stubs .fini .rodata \n   04     .data.rel.ro .data .rld_map .got .sbss .bss \n   05     .dynamic \n   06     \n   07     \n\n```\n\n1. Patchwork MIPS: Allow FPU emulator to use non-stack area.\n\n2. MIPS executable stack protection\n\n",
      "votes": "2",
      "user": "julian",
      "time": "May 3, 2017 at 23:46",
      "is_accepted": true,
      "comments": [
        {
          "user": "drdot",
          "text": "Thank you for the answer. I did not realize the question is so broad. I am only interested in the case for x86. Optionally, if you know something about ARM, that would be great. But I am OK with x86 only use cases.",
          "time": null
        }
      ]
    },
    {
      "content": "Just-In-Time Compilation support could be one reason for pages to be legitimately marked RWX.  In iOS MobileSafari is one of a small number of Apple apps that has a \"dynamic codesigning\" entitlement which allows for the RWX pages to be mapped.  Despite the potential danger, JavaScript performance is too important to not have these pages.  This makes Safari a desirable target for exploits.  For more information on a recent iOS exploit that attacked Safari for its RWX pages read the Pegasus Technical Report\n\n",
      "votes": "1",
      "user": "user1593858",
      "time": "May 5, 2017 at 23:15",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "It seems some .NET native binaries, e.g. System.ni.dll have an RWX .xdata section, although I believe they're not generated by a normal compilation workflow (they're produced by ngen AFAIK) so they're probably not covered by the current version of the question.\n\n",
      "votes": "0",
      "user": "Community",
      "time": "May 23, 2017 at 12:37",
      "is_accepted": false,
      "comments": []
    }
  ]
}