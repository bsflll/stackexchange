{
  "title": "IDA interpretation of switch-case statement",
  "link": "https://reverseengineering.stackexchange.com/questions/29629/ida-interpretation-of-switch-case-statement",
  "content": "This is my first question on this forum, so I hope that it would not be offensive or redundant.\n\nSo recently I am attempting to developing some kernel extensions for Apple's macOS using the IOKit framework. However, in the debugging process, I encountered some confusions while looking at the assembly and pseudocode of my binaries generated by IDA.\n\nCurrently, the greatest issue is how the normal switch case statement is interrupted by the decompiler — _bittest64 commands would be yielded with huge numbers as arguments. I am somewhat sure that it has to do with the “lower-bound” of the cases, but I don't know how exactly should I comprehend it. Here is an example:\n\n\n\n\nI can't really see how they relate, particularly the _bittest64 part. Just by the way, the enum kBluetoothIntelHardwareVariantJfP = 0x11 and kBluetoothIntelHardwareVariantSlrF = 0x19.\n\nHappy thanksgiving!\n\n",
  "votes": "0",
  "answers": 1,
  "views": "651",
  "tags": [
    "ida",
    "c++"
  ],
  "user": "vv001",
  "time": "Nov 27, 2021 at 21:04",
  "comments": [
    {
      "user": "MarianD",
      "text": "Welcome to Reverse Engineering StackExchange! Please copy / paste your code as a text instead of pictures. It will help others to help you.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "It's a compiler optimization used to implement switch statements that have many cases leading to one location. Note that the weird output is not Hex-Rays' doing, but rather, a more-or-less direct translation of what's in the assembly language. You didn't show the assembly for your snippet, but here's similar disassembly from a database I have open:\n\n```\n.text:0000000061FEA1C8     lea     eax, [rdi-33h]\n.text:0000000061FEA1CB     cmp     eax, 0Eh\n.text:0000000061FEA1CE     ja      short loc_61FEA1F8\n.text:0000000061FEA1CE\n.text:0000000061FEA1D0     mov     edx, 6381h\n.text:0000000061FEA1D5     bt      edx, eax ; <- this becomes _bittest\n.text:0000000061FEA1D8     jnb     short loc_61FEA1F8\n\n```\nAnd here's its Hex-Rays decompilation:\n\n```\n  if ( (vChildOp - 51) > 0xE )\n    return /* ... */;\n\n  v6 = 25473;\n  if ( !_bittest(&v6, vChildOp - 51) )\n    return /* ... */;\n\n```\nLet's take a closer look at your snippet. You said that kBluetoothIntelHardwareVariantJfP = 0x11 and kBluetoothIntelHardwareVariantSlrF = 0x19. Now look at the constant, 0x39E0000LL. This is 11100111100000000000000000b in binary:\n\n```\n11 1001 1110 0000 0000 0000 0000\n|| |  | |||- bits 0-16 clear   \n|| |  | ||-- bit 17 (i.e., 0x11): first bit set\n|| |  | |--- bit 0x12 set\n|| |  | ---- bit 0x13 set\n|| |  ------ bit 0x14 set\n|| --------- bit 0x17 set\n|----------- bit 0x18 set\n------------ bit 0x19: last bit set\n\n```\nNotice that the switch statement in your example has 7 cases leading to the same label, and that two of the cases correspond to bits 0x19 and 0x11? It is not a coincidence that the constant in the snippet has 7 bits set, including bits 0x11 and 0x19! The bt instruction, translated as the _bittest intrinsic, is just checking to see whether hardwareVariant, or a2 in the decompilation, is one of the values 0x11-0x14 or 0x17-0x19. It performs all 7 comparisons at the same time.\n\nThe if-statement on the outside is the default check: it ensures that the value of a2 is at most 0x19 -- if it's not, it jumps to the default location, i.e., does nothing.\n\n",
      "votes": "1",
      "user": "Rolf Rolles",
      "time": "Nov 28, 2021 at 21:39",
      "is_accepted": true,
      "comments": [
        {
          "user": "blabb",
          "text": "OT on a simple glance  result is an unassigned local a garbage only assigned a value inside the if block{} so does this function return garbage?",
          "time": null
        },
        {
          "user": "Rolf Rolles",
          "text": "@blabb Note that, in the source code, the function's true return type is void. Hex-Rays erroneously thinks this function returns a value, so it tries to create an assignment expression for the rax register. In this case, the only such assignment takes place as part of the bt sequence, which is why we get garbage inside of an if-statement.",
          "time": null
        },
        {
          "user": "blabb",
          "text": "Thanks and again OT  so the Function Type also needs to be modified manually as void blah(x,y) instead of __int64  to fix this but if there was no source to rely how to grapple with this apparently erroneous return in general",
          "time": null
        },
        {
          "user": "Rolf Rolles",
          "text": "@blabb I rely on clues like the one you identified. If some paths through a function don't return a value,  it probably returns void. If none of the calling functions use the return value, it may or may not be void, but there's no harm in marking it as such. If a function supposedly returns void, but calling functions show usage of uninitialized values allocated in the rax register after the call, it does not return void. There's a recursive effect; if you determine a called function returns void, that may give you evidence that a calling function does also.",
          "time": null
        },
        {
          "user": "blabb",
          "text": "ok thanks again actually i was looking for some magic recipes :) to peer at decompiled output  without  accompanying disassembly or source",
          "time": null
        }
      ]
    }
  ]
}