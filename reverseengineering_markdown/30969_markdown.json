{
  "title": "Trying to understand this interrupted (?) function prologue",
  "link": "https://reverseengineering.stackexchange.com/questions/30969/trying-to-understand-this-interrupted-function-prologue",
  "content": "Note: The uninterrupted disassembly is at the bottom\n\nHey, I'm looking at the the assembly and I'm trying to reverse engineer the function\n\nHere, it seems like we are saving the previous rbp. Though, it seems like there is no new value for rbp\n\n```\n0x004010b0      push    rbp\n\n```\nWe are clearing the xmm0 registers\n\n```\n0x004010b1      pxor    xmm0, xmm0\n\n```\nMoving 0x40202c into rdi for the call fgets. This would be the first argument. If I were to view the address at 0x40402c, I would see the string Input\n\n```\n0x004010b5      lea     rdi, str.Input: ; 0x40202c ; const char *s\n\n```\nMaking room for local variables, but it seems odd to be doing it after the lea and pxor. So the previous stack frame never de-alloacted so we just increased it by much larger\n\n```\n0x004010bc      sub     rsp, 0x50\n\n```\nMoving the xmm0 onto the top of stack. I don't think I've ever seen an xmmword before. I also imagine this is a local variable.\n\n```\n0x004010c0      movaps  xmmword [rsp], xmm0\n\n```\nAh, here's the rest of prologue! We are setting the value of rbp to rsp so the stack frame is 0\n\n```\n0x004010c4      mov     rbp, rsp\n\n```\nCreating local variables!\n\n```\n0x004010c7      movaps  xmmword [rsp + 0x10], xmm0\n0x004010cc      movaps  xmmword [rsp + 0x20], xmm0\n0x004010d1      movaps  xmmword [rsp + 0x20], xmm0\n\n```\nAssigning a loval variable 0. Because it is a byte, it is probably a char\n\n```\n0x004010d6      mov     byte [rsp + 0x40], 0\n\n```\nWe passed Input into rdi and called puts so we outputted Input\n\n```\n0x004010db      call    puts       \n\n```\nArguments are passed into rdi, rsi, and rdx. So we have: fgets(rbp, 0x41, stdin).\nIt's also worth nothing that rbp is probably the buffer and we passed 0x41 as the size which is a large buffer. The stack frame is 0 because we only recently moved the value of rsp into rbp. (i.e., rbp = rsp).\nAnd we did not not allocated space after the mov rbp, rsp.\n\n```\n0x004010e0      mov     rdx, qword [stdin] ; 0x404090 ; FILE *stream\n0x004010e7      mov     esi, 0x41 \n0x004010ec      mov     rdi, rbp   \n0x004010ef      call    fgets     \n\n```\nrbp was the buffer so we're moving the string into the first argument. The buffer might have been 65, but the char array could have terminated before that so the string length could have shorter.\n\n```\n0x004010f4      mov     rdi, rbp \n0x004010f7      call    strlen  \n\n```\nPass the string itself, rbp, and the length of the string, which was the return value of strlen (and return values are placed in eax) and pass it into the function\n\n```\n0x004010fc      mov     rdi, rbp\n0x004010ff      mov     esi, eax\n0x00401101      call    fcn.0040152b\n\n```\nClean up the stack and return 0!\n\n```\n0x00401106      add     rsp, 0x50\n0x0040110a      xor     eax, eax\n0x0040110c      pop     rbp\n0x0040110d      ret\n\n```\nSo, I imagine main looks like\n\n```\n#include <stdio.h>\n#include <string.h>\n\n\nint main()\n{\n    char str[65];\n\n    float local_var_1 = 0;\n    float local_var_2 = 0;\n    float local_var_3 = 0;\n    char  rsp_40      = 0;\n\n    puts(\"Input\");\n\n    fgets(str, 65, stdin);\n    int str_length = strlen(str);\n\n    some_fun(str, str_length);\n\n    return 0;\n};\n\n```\nIs there anything wrong with this assessment?\n\nThe original assembly:\n\n```\nmain:\n0x004010b0      push    rbp\n0x004010b1      pxor    xmm0, xmm0\n0x004010b5      lea     rdi, str.Input: ; 0x40202c ; const char *s\n0x004010bc      sub     rsp, 0x50\n0x004010c0      movaps  xmmword [rsp], xmm0\n0x004010c4      mov     rbp, rsp\n0x004010c7      movaps  xmmword [rsp+0x10], xmm0\n0x004010cc      movaps  xmmword [rsp+0x20], xmm0\n0x004010d1      movaps  xmmword [rsp+0x30], xmm0\n0x004010d6      mov     byte [rsp+0x40], 0\n0x004010db      call    puts       ; sym.imp.puts ; int puts(const char *s)\n0x004010e0      mov     rdx, qword [stdin] ; 0x404090 ; FILE *stream\n0x004010e7      mov     esi, 0x41  ; 'A' ; 65 ; int size\n0x004010ec      mov     rdi, rbp   ; char *s\n0x004010ef      call    fgets      ; sym.imp.fgets ; char *fgets(char *s, int size, FILE *stream)\n0x004010f4      mov     rdi, rbp   ; const char *s\n0x004010f7      call    strlen     ; sym.imp.strlen ; size_t strlen(const char *s)\n0x004010fc      mov     rdi, rbp   ; int64_t arg1\n0x004010ff      mov     esi, eax   ; uint64_t arg2\n0x00401101      call    fcn.0040152b\n0x00401106      add     rsp, 0x50\n0x0040110a      xor     eax, eax\n0x0040110c      pop     rbp\n0x0040110d      ret\n\n```\n",
  "votes": "0",
  "answers": 1,
  "views": "81",
  "tags": [
    "disassembly",
    "x86",
    "static-analysis"
  ],
  "user": "Happy Jerry",
  "time": "Oct 8, 2022 at 0:52",
  "comments": [
    {
      "user": "blabb",
      "text": "movaps is similar to doing a memset (....)  in your example it  clears of 0x40 bytes to NULL  [rsp],[rsp+10] , [rsp+20] , [rsp+30]  something roughly equal to char foo[0x40] ={0};",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "As i commented there are no float or xmm operations that are happening in your code\n\nthe xmm operations are compiler optimizations to set a small buffer to Zero\nor memset the buffer to NULL\n\nroughly equivalent to memset(buff,0,size); or most probably a declaration like char foo[SIZE] ={0} optimized away;\n\nsee the demo below\n\nsource code\n\n```\n:\\>type movaps.cpp\n#include <stdio.h>\n#include <string.h>\nint main(void) {\n        char foo[0x41] = {0};\n        puts(\"input\");\n        printf(\"%s\\tsize=%zd  \n\" ,foo,strlen(fgets(foo,0x41,stdin)));\n        return 0;\n}\n\n```\ncompiling with maximum optimizations enabled in vs2019 community as x64\n\n```\n:\\>cl /Zi /W4 /analyze /Ox movaps.cpp /link /release\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.29.30146 for x64\n\n```\nexecuting the compiled binary\n\n```\n:\\>movaps.exe\ninput\njajajajaj\njajajajaj\n        size=10\n\n```\ndisassembling the relevant function main() in this case\n\n```\n:\\>cdb -c \"uf movaps!main;q\" movaps.exe\n\nMicrosoft (R) Windows Debugger Version 10.0.19041.685 AMD64\n\nntdll!LdrpDoDebuggerBreak+0x30:\n00007ff8`516e0930 cc              int     3\n0:000> cdb: Reading initial command 'uf movaps!main;q'\nmovaps!main:\n00007ff6`14501000 4881ec88000000  sub     rsp,88h\n00007ff6`14501007 488b05fadf0600  mov     rax,qword ptr [movaps!__security_cookie (00007ff6`1456f008)]\n00007ff6`1450100e 4833c4          xor     rax,rsp\n00007ff6`14501011 4889442470      mov     qword ptr [rsp+70h],rax\n00007ff6`14501016 0f57c0          xorps   xmm0,xmm0\n00007ff6`14501019 488d0d60c30500  lea     rcx,[movaps!__xt_z+0x8 (00007ff6`1455d380)]\n00007ff6`14501020 33c0            xor     eax,eax\n00007ff6`14501022 0f11442420      movups  xmmword ptr [rsp+20h],xmm0\n00007ff6`14501027 88442460        mov     byte ptr [rsp+60h],al\n00007ff6`1450102b 0f11442430      movups  xmmword ptr [rsp+30h],xmm0\n00007ff6`14501030 0f11442440      movups  xmmword ptr [rsp+40h],xmm0\n00007ff6`14501035 0f11442450      movups  xmmword ptr [rsp+50h],xmm0\n00007ff6`1450103a e861110100      call    movaps!puts (00007ff6`145121a0)\n00007ff6`1450103f 33c9            xor     ecx,ecx\n00007ff6`14501041 e8fa080100      call    movaps!__acrt_iob_func (00007ff6`14511940)\n00007ff6`14501046 4c8bc0          mov     r8,rax\n00007ff6`14501049 488d4c2420      lea     rcx,[rsp+20h]\n00007ff6`1450104e ba41000000      mov     edx,41h\n00007ff6`14501053 e8240c0100      call    movaps!fgets (00007ff6`14511c7c)\n00007ff6`14501058 49c7c0ffffffff  mov     r8,0FFFFFFFFFFFFFFFFh\n00007ff6`1450105f 90              nop\n\nmovaps!main+0x60:\n00007ff6`14501060 49ffc0          inc     r8\n00007ff6`14501063 42803c0000      cmp     byte ptr [rax+r8],0\n00007ff6`14501068 75f6            jne     movaps!main+0x60 (00007ff6`14501060)\n\nmovaps!main+0x6a:\n00007ff6`1450106a 488d542420      lea     rdx,[rsp+20h]\n00007ff6`1450106f 488d0d12c30500  lea     rcx,[movaps!__xt_z+0x10 (00007ff6`1455d388)]\n00007ff6`14501076 e885000000      call    movaps!printf (00007ff6`14501100)\n00007ff6`1450107b 33c0            xor     eax,eax\n00007ff6`1450107d 488b4c2470      mov     rcx,qword ptr [rsp+70h]\n00007ff6`14501082 4833cc          xor     rcx,rsp\n00007ff6`14501085 e856010000      call    movaps!__security_check_cookie (00007ff6`145011e0)\n00007ff6`1450108a 4881c488000000  add     rsp,88h\n00007ff6`14501091 c3              ret\nquit:\n:\\>\n\n```\n",
      "votes": "1",
      "user": "blabb",
      "time": "Oct 8, 2022 at 4:00",
      "is_accepted": false,
      "comments": [
        {
          "user": "MendelG",
          "text": "Can you please help me with: reverseengineering.stackexchange.com/questions/31031/â€¦ ?",
          "time": null
        }
      ]
    }
  ]
}