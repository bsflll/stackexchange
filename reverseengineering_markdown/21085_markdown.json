{
  "title": "The structure of the Python's marshaled code object (or .pyc file)",
  "link": "https://reverseengineering.stackexchange.com/questions/21085/the-structure-of-the-pythons-marshaled-code-object-or-pyc-file",
  "content": "Help me to decipher the Python's marshaled code object. The .pyc files are almost the same: The structure of .pyc files.\n\nI have:\n\nThe main purpose: \n\nI want to find out, how the different code objects stored and referenced from each other. That is, how the links to the child code objects are stored?  The module should have references to all its functions. The function should have references to all other functions, callable from it. Etc. Does Virtual Machine preserves the code object id, when storing it to the .pyc? I don't thinks so, because can't see ids in the .pyc file.\n\nFor example, I have such instruction in the disassembled source:\n\n```\nLOAD_CONST        2 (<code object baz at 0x7f380995e5d0, file \"foo.py\", line 7>)\n\n```\nHence:\n\nI think, I will investigate by the gdb further, but maybe this approach (.pyc file deciphering) also will do the job.\n\nCurrent result:\n\nI used all this information for creating the next file: the first column is the binary representation of marshaled code object, the second is the meaning of each byte sequences, which I have determined already.\n\n```\nb'\n\\xe3                    <don't know>\n\\x00\\x00\\x00\\x00        <foo.py: co_argcount: 0>\n\\x00\\x00\\x00\\x00        <foo.py: co_kwonlyargcount: 0>\n\\x00\\x00\\x00\\x00        <foo.py: co_nlocals: 0>\n\\x03\\x00\\x00\\x00        <foo.py: co_stacksize: 3>               \n@\\x00\\x00\\x00           <foo.py: co_flags = '@' = 0x40 = 64>\ns.\\x00\\x00\\x00          <foo.py: number of bytes for module instructions = '.' = 46>\nd\\x00                   <foo.py: co_code:  0 LOAD_CONST        0 (1)\nZ\\x00                   <foo.py: co_code:  2 STORE_NAME        0 (a)\nd\\x01                   <foo.py: co_code:  4 LOAD_CONST        1 (2)\nZ\\x01                   <foo.py: co_code:  6 STORE_NAME        1 (b)\ne\\x00                   <foo.py: co_code:  8 LOAD_NAME         0 (a)\ne\\x01                   <foo.py: co_code: 10 LOAD_NAME         1 (b)\n\\x17\\x00                <foo.py: co_code: 12 BINARY_ADD\nZ\\x02                   <foo.py: co_code: 14 STORE_NAME        2 (c)\nd\\x02                   <foo.py: co_code: 16 LOAD_CONST        2 (<code object baz at 0x7f380995e5d0, file \"foo.py\", line 7>)\nd\\x03                   <foo.py: co_code: 18 LOAD_CONST        3 ('baz')\n\\x84\\x00                <foo.py: co_code: 20 MAKE_FUNCTION     0\nZ\\x03                   <foo.py: co_code: 22 STORE_NAME        3 (baz)\ne\\x03                   <foo.py: co_code: 24 LOAD_NAME         3 (baz)\ne\\x00                   <foo.py: co_code: 26 LOAD_NAME         0 (a)\ne\\x01                   <foo.py: co_code: 28 LOAD_NAME         1 (b)\n\\x83\\x02                <foo.py: co_code: 30 CALL_FUNCTION     2\nZ\\x04                   <foo.py: co_code: 32 STORE_NAME        4 (multiplication)\ne\\x04                   <foo.py: co_code: 34 LOAD_NAME         4 (multiplication)\nd\\x01                   <foo.py: co_code: 36 LOAD_CONST        1 (2)\n\\x13\\x00                <foo.py: co_code: 38 BINARY_POWER\nZ\\x05                   <foo.py: co_code: 40 STORE_NAME        5 (square)\nd\\x04                   <foo.py: co_code: 42 LOAD_CONST        4 (None)\nS\\x00                   <foo.py: co_code: 44 RETURN_VALUE\n)\\x05                   <foo.py: co_const: size>\n\\xe9\\x01\\x00\\x00\\x00    <foo.py: co_const[0]: 1>\n\\xe9\\x02\\x00\\x00\\x00    <foo.py: co_const[1]: 2>\nc                       <TYPE_CODE>\n\\x02\\x00\\x00\\x00        <baz: co_argcount: 2>\n\\x00\\x00\\x00\\x00        <baz: co_kwonlyargcount: 0>\n\\x02\\x00\\x00\\x00        <baz: co_nlocals: 2>\n\\x02\\x00\\x00\\x00        <baz: co_stacksize: 2>               \nC\\x00\\x00\\x00           <baz: co_flags = 'C' = 0x43 = 67>\ns\\x08\\x00\\x00\\x00       <baz: co_code: size = 8 bytes>\n|\\x00                   <baz: co_code: 0 LOAD_FAST                0 (x) \n|\\x01                   <baz: co_code: 2 LOAD_FAST                1 (y) \n\\x14\\x00                <baz: co_code: 4 BINARY_MULTIPLY                \nS\\x00                   <baz: co_code: 6 RETURN_VALUE                   \n)\\x01                   <baz: co_const: size>\nN                       <baz: co_const[0]: None>\n\\xa9\\x00                <don't know> \n)\\x02                   <baz: co_varnames: size>\n\\xda\\x01                <baz: number of characters of next item>\nx                       <baz: co_varnames[0]: x>\n\\xda\\x01                <baz: number of characters of next item>\ny                       <baz: co_varnames[1]: y>\nr\\x03\\x00\\x00\\x00       <baz: don't know. But the 'r' = 'TYPE_REF'>\nr\\x03\\x00\\x00\\x00       <baz: don't know. But the 'r' = 'TYPE_REF'>\n\\xfa\\x06                <baz: next item length>\nfoo.py                  <baz: co_filename>\n\\xda\\x03                <baz: number of characters of next item>\nbaz                     <baz: co_name: 'baz'>\n\\x07\\x00\\x00\\x00        <baz: co_firstlineno: 7>\ns\\x02\\x00\\x00\\x00       <baz: co_lnotab: size = 2 >\n\\x00\\x01                <baz: co_lnotab>\nr\\x07\\x00\\x00\\x00       <foo.py: co_const[3]: reference to baz>\nN                       <foo.py: co_const[4]: None>\n)\\x06                   <foo.py: co_names: size> \n\\xda\\x01                <foo.py: number of characters of next item>\na                       <foo.py: co_names[0]: a>\n\\xda\\x01                <foo.py: number of characters of next item>\nb                       <foo.py: co_names[1]: b>\n\\xda\\x01                <foo.py: number of characters of next item>\nc                       <foo.py: co_names[2]: c>\nr\\x07\\x00\\x00\\x00       <foo.py: co_names[3]: reference to baz>\nZ\\x0e                   <foo.py: number of characters of next item>\nmultiplication          <foo.py: co_names[4]: multiplication>\nZ\\x06                   <foo.py: number of characters of next item>\nsquare                  <foo.py: co_names[5]: square>\nr\\x03\\x00\\x00\\x00       <foo.py: don't know>     \nr\\x03\\x00\\x00\\x00       <foo.py: don't know>     \nr\\x03\\x00\\x00\\x00       <foo.py: don't know>     \nr\\x06\\x00\\x00\\x00       <foo.py: don't know>     \n\\xda\\x08                <foo.py: number of characters of next item>\n<module>                <foo.py: co_name>\n\\x03\\x00\\x00\\x00        <foo.py: co_firstlineno>\ns  \n\\x00\\x00\\x00         <foo.py: co_lnotab: size = '  \n' = 0A>\n\\x04\\x01                <foo.py: o_lnotab> \n\\x04\\x01                <foo.py: o_lnotab>\n\\x08\\x02                <foo.py: o_lnotab>\n\\x08\\x07                <foo.py: o_lnotab>\n  \n\\x01'                 <foo.py: o_lnotab>\n\n```\n1) The source code: foo.py\n\n```\na = 1 \nb = 2 \nc = a + b \n\ndef baz(x,y):\n    return x * y\n\nmultiplication = baz(a,b)\nsquare = multiplication ** 2\n\n```\n2) The marshaled representation of foo.py.\n\n```\nsource_py = \"foo.py\"\n\nwith open(source_py) as f_source:\n    source_code = f_source.read()\n\ncode_obj_compile = compile(source_code, source_py, \"exec\")\n\ndata = marshal.dumps(code_obj_compile)\n\nprint(data)\n\n```\n3) The full (recursive) disassembly of the code object.\n\n```\nimport types\n\ndis.dis(code_obj_compile)\n\nfor x in code_obj_compile.co_consts:\n    if isinstance(x, types.CodeType):\n        sub_byte_code = x\n        func_name = sub_byte_code.co_name\n        print('  \nDisassembly of %s:' % func_name)\n        dis.dis(sub_byte_code)\n\n```\n4) All code object's field values.\n\n```\ndef print_co_obj_fields(code_obj):\n    # Iterating through all instance attributes\n    # and calling all having the 'co_' prefix\n    for name in dir(code_obj):\n        if name.startswith('co_'):\n            co_field = getattr(code_obj, name)\n            print(f'{name:<20} = {co_field}')\n\nprint_co_obj_fields(code_obj_compile)\n\n```\n",
  "votes": "3",
  "answers": 2,
  "views": "3k",
  "tags": [
    "python"
  ],
  "user": "MiniMax",
  "time": "Apr 10, 2019 at 21:17",
  "comments": [],
  "answers_data": [
    {
      "content": "The answer below is with reference to Python 2.7\n\nThe baz code object is located within the co_consts member. Going by your example.\n\n```\n>>> import marshal\n>>> import dis\n>>> \n>>> source_py = \"foo.py\"\n>>> \n>>> with open(source_py) as f_source:\n...     source_code = f_source.read()\n>>> \n\n>>> code_obj_compile = compile(source_code, source_py, \"exec\")\n\n```\nIf you disassemble, the newly generated code object you can find references to baz\n\n```\n>>> dis.dis(code_obj_compile)\n  1           0 LOAD_CONST               0 (7)\n              3 STORE_NAME               0 (a)\n\n  2           6 LOAD_CONST               1 (5)\n              9 STORE_NAME               1 (b)\n\n  3          12 LOAD_NAME                0 (a)\n             15 LOAD_NAME                1 (b)\n             18 BINARY_ADD\n             19 STORE_NAME               2 (c)\n\n  5          22 LOAD_CONST               2 (<code object baz at 0x7f1dcdb06bb0, file \"foo.py\", line 5>)\n             25 MAKE_FUNCTION            0\n... snip...\n\n```\nThe baz code object is located within the co_consts array of the parent code object as shown below.\n\n```\n>>> code_obj_compile.co_consts[2]\n<code object baz at 0x7f1dcdb06bb0, file \"foo.py\", line 5>\n\n```\nAnd you can disassemble that as well.\n\n```\n>>> dis.dis(code_obj_compile.co_consts[2])\n  6           0 LOAD_FAST                0 (x)\n              3 LOAD_FAST                1 (y)\n              6 BINARY_MULTIPLY\n              7 RETURN_VALUE\n\n```\nThe objects will be created each time the program is run. Hence the addresses will change correspondingly.\n\nJust explained. If you look at the instruction carefully you can notice the LOAD_CONST instruction takes a offset as a parameter - the operand.\n\n```\n  5          22 LOAD_CONST               2 (<code object baz at 0x7f1dcdb06bb0, file \"foo.py\", line 5>)\n\n```\nHere the offset is 2 which instructs the Python Virtual Machine to load the third (zero based) item in the co_consts array on to the evaluation stack. So the \"connection\" is preserved using the offsets into the other metadata members.\n\n",
      "votes": "4",
      "user": "0xec",
      "time": "Apr 9, 2019 at 11:55",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "The purpose of a code object marshaling is the storing and restoring the program to/from the file. Therefore, it should have the coding scheme for all Python's features: objects, bytecode, names, etc, otherwise it can't restore a program from the file.\n\nSo, it uses multiple type identifiers, which can be divided into four groups:\n\nAll types can be seen here: cpython/Python/marshal.c\n\nAlso, the code object has multiple int fields. They doesn't have identifier in the marshaled string, just the sequence of four bytes values.\n\n```\n    int co_argcount;            /* #arguments, except *args */\n    int co_kwonlyargcount;      /* #keyword only arguments */\n    int co_nlocals;             /* #local variables */\n    int co_stacksize;           /* #entries needed for evaluation stack */\n    int co_flags;               /* CO_..., see below */\n    int co_firstlineno;         /* first source line number */\n    \n\n```\nThe full code object structure is here: cpython/Include/code.h \n\nIt is useful to know the order, in which the code object have been dumped, because then we can calculate the each field offset in the resulting string, like - the first four byte is co_argcount, the second is co_kwonlyargcount, etc.\n\nThe order of code object dumping:\n\n```\n    # PyCodeObject *co - pointer to the code object\n    # p                - pointer to the file object,\n    that accumulating marshaled code object before\n    writing to the file.\n    \n    W_TYPE(TYPE_CODE, p);\n    w_long(co->co_argcount, p);\n    w_long(co->co_kwonlyargcount, p);\n    w_long(co->co_nlocals, p);\n    w_long(co->co_stacksize, p);\n    w_long(co->co_flags, p);\n    w_object(co->co_code, p);\n    w_object(co->co_consts, p);\n    w_object(co->co_names, p);\n    w_object(co->co_varnames, p);\n    w_object(co->co_freevars, p);\n    w_object(co->co_cellvars, p);\n    w_object(co->co_filename, p);\n    w_object(co->co_name, p);\n    w_long(co->co_firstlineno, p);\n    w_object(co->co_lnotab, p);\n\n```\n```\nb'\n\\xe3                    <foo.py: '\\xe3' & 0x80 (FLAG_REF)  = 'c' (TYPE_CODE)>\n\\x00\\x00\\x00\\x00        <foo.py: co_argcount: 0>\n\\x00\\x00\\x00\\x00        <foo.py: co_kwonlyargcount: 0>\n\\x00\\x00\\x00\\x00        <foo.py: co_nlocals: 0>\n\\x03\\x00\\x00\\x00        <foo.py: co_stacksize: 3>               \n@\\x00\\x00\\x00           <foo.py: co_flags = '@' = 0x40 = 64>\ns.\\x00\\x00\\x00          <foo.py: number of bytes for module instructions = '.' = 46>\nd\\x00                   <foo.py: co_code:  0 LOAD_CONST        0 (1)\nZ\\x00                   <foo.py: co_code:  2 STORE_NAME        0 (a)\nd\\x01                   <foo.py: co_code:  4 LOAD_CONST        1 (2)\nZ\\x01                   <foo.py: co_code:  6 STORE_NAME        1 (b)\ne\\x00                   <foo.py: co_code:  8 LOAD_NAME         0 (a)\ne\\x01                   <foo.py: co_code: 10 LOAD_NAME         1 (b)\n\\x17\\x00                <foo.py: co_code: 12 BINARY_ADD\nZ\\x02                   <foo.py: co_code: 14 STORE_NAME        2 (c)\nd\\x02                   <foo.py: co_code: 16 LOAD_CONST        2 (<code object baz at 0x7f380995e5d0, file \"foo.py\", line 7>)\nd\\x03                   <foo.py: co_code: 18 LOAD_CONST        3 ('baz')\n\\x84\\x00                <foo.py: co_code: 20 MAKE_FUNCTION     0\nZ\\x03                   <foo.py: co_code: 22 STORE_NAME        3 (baz)\ne\\x03                   <foo.py: co_code: 24 LOAD_NAME         3 (baz)\ne\\x00                   <foo.py: co_code: 26 LOAD_NAME         0 (a)\ne\\x01                   <foo.py: co_code: 28 LOAD_NAME         1 (b)\n\\x83\\x02                <foo.py: co_code: 30 CALL_FUNCTION     2\nZ\\x04                   <foo.py: co_code: 32 STORE_NAME        4 (multiplication)\ne\\x04                   <foo.py: co_code: 34 LOAD_NAME         4 (multiplication)\nd\\x01                   <foo.py: co_code: 36 LOAD_CONST        1 (2)\n\\x13\\x00                <foo.py: co_code: 38 BINARY_POWER\nZ\\x05                   <foo.py: co_code: 40 STORE_NAME        5 (square)\nd\\x04                   <foo.py: co_code: 42 LOAD_CONST        4 (None)\nS\\x00                   <foo.py: co_code: 44 RETURN_VALUE\n)\\x05                   <foo.py: co_const: size>\n\\xe9\\x01\\x00\\x00\\x00    <foo.py: co_const[0]: 1; '\\xe9' & 0x80 (FLAG_REF) = 'i' (TYPE_INT)>\n\\xe9\\x02\\x00\\x00\\x00    <foo.py: co_const[1]: 2; '\\xe9' & 0x80 (FLAG_REF) = 'i' (TYPE_INT)>\nc                       <foo.py: co_const[2]: 'c' = TYPE_CODE>\n\\x02\\x00\\x00\\x00        <baz: co_argcount: 2>\n\\x00\\x00\\x00\\x00        <baz: co_kwonlyargcount: 0>\n\\x02\\x00\\x00\\x00        <baz: co_nlocals: 2>\n\\x02\\x00\\x00\\x00        <baz: co_stacksize: 2>               \nC\\x00\\x00\\x00           <baz: co_flags = 'C' = 0x43 = 67>\ns\\x08\\x00\\x00\\x00       <baz: co_code: size = 8 bytes>\n|\\x00                   <baz: co_code: 0 LOAD_FAST                0 (x) \n|\\x01                   <baz: co_code: 2 LOAD_FAST                1 (y) \n\\x14\\x00                <baz: co_code: 4 BINARY_MULTIPLY                \nS\\x00                   <baz: co_code: 6 RETURN_VALUE                   \n)\\x01                   <baz: co_const: size>\nN                       <baz: co_const[0]: None>\n\\xa9\\x00                <baz: co_names: size = 0  '\\xa9' & 0x80 (FLAG_REF)  = ')'> \n)\\x02                   <baz: co_varnames: size>\n\\xda\\x01                <baz: number of characters of next item; '\\xda' & 0x80 (FLAG_REF)  = 'Z'>\nx                       <baz: co_varnames[0]: x>\n\\xda\\x01                <baz: number of characters of next item; '\\xda' & 0x80 (FLAG_REF)  = 'Z'>\ny                       <baz: co_varnames[1]: y>\nr\\x03\\x00\\x00\\x00       <baz: co_freevars: reference to empty tuple '()'>     \nr\\x03\\x00\\x00\\x00       <baz: co_cellvars: reference to empty tuple '()'>\n\\xfa\\x06                <baz: next item length>\nfoo.py                  <baz: co_filename>\n\\xda\\x03                <baz: number of characters of next item>\nbaz                     <baz: co_name: 'baz'>\n\\x07\\x00\\x00\\x00        <baz: co_firstlineno: 7>\ns\\x02\\x00\\x00\\x00       <baz: co_lnotab: size = 2 >\n\\x00\\x01                <baz: co_lnotab>\nr\\x07\\x00\\x00\\x00       <foo.py: co_const[3]: reference to 'baz'>\nN                       <foo.py: co_const[4]: None>\n)\\x06                   <foo.py: co_names: size> \n\\xda\\x01                <foo.py: number of characters of next item>\na                       <foo.py: co_names[0]: a>\n\\xda\\x01                <foo.py: number of characters of next item>\nb                       <foo.py: co_names[1]: b>\n\\xda\\x01                <foo.py: number of characters of next item>\nc                       <foo.py: co_names[2]: c>\nr\\x07\\x00\\x00\\x00       <foo.py: co_names[3]: reference to 'baz'>\nZ\\x0e                   <foo.py: number of characters of next item>\nmultiplication          <foo.py: co_names[4]: multiplication>\nZ\\x06                   <foo.py: number of characters of next item>\nsquare                  <foo.py: co_names[5]: square>\nr\\x03\\x00\\x00\\x00       <foo.py: co_varnames: reference to empty tuple '()'>     \nr\\x03\\x00\\x00\\x00       <foo.py: co_freevars: reference to emtpy tuple '()'>     \nr\\x03\\x00\\x00\\x00       <foo.py: co_cellvars: reference to empty tuple '()'>\nr\\x06\\x00\\x00\\x00       <foo.py: co_filename: reference to 'foo.py'>     \n\\xda\\x08                <foo.py: number of characters of next item>\n<module>                <foo.py: co_name>\n\\x03\\x00\\x00\\x00        <foo.py: co_firstlineno>\ns  \n\\x00\\x00\\x00         <foo.py: co_lnotab: size = '  \n' = 0A>\n\\x04\\x01                <foo.py: o_lnotab> \n\\x04\\x01                <foo.py: o_lnotab>\n\\x08\\x02                <foo.py: o_lnotab>\n\\x08\\x07                <foo.py: o_lnotab>\n  \n\\x01'                 <foo.py: o_lnotab>\n\n```\nThe useful information:\n\nHow to create a code object in python?\n\n",
      "votes": "1",
      "user": "Community",
      "time": "Jun 17, 2020 at 9:54",
      "is_accepted": true,
      "comments": []
    }
  ]
}