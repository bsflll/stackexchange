{
  "title": "Some more questions related to C++ exceptions (catchHigh)",
  "link": "https://reverseengineering.stackexchange.com/questions/24915/some-more-questions-related-to-c-exceptions-catchhigh",
  "content": "I've came up with the most convoluted example but still can't find the purpose of the catchHigh field. I find it that the right handler can be selected simply by looking at the tryblock map from start to end and comparing the ranges of the tryLow and tryHigh fields to the current state.\n\nI mean I understand that catchHigh is simply the max state that the catch handlers can reach (inclusive?) (from here ehdata.h:140:\n\n```\n__ehstate_t     catchHigh;          // Highest state index of any associated catch\n\n```\n) but I don't understand when this field can be actually useful.\n\nHowever it seems that this value is used by the CRT anyway (vs2019 - frame.cpp:693):\n\n```\n/////////////////////////////////////////////////////////////////////////////\n//\n// GetRangeOfTrysToCheck - determine which try blocks are of interest, given\n//   the current catch block nesting depth.  We only check the trys at a single\n//   depth.\n//\n// Returns:\n//      Address of first try block of interest is returned\n//      pStart and pEnd get the indices of the range in question\n//\nRENAME_EH_EXTERN(__FrameHandler3)::TryBlockMap::IteratorPair RENAME_EH_EXTERN(__FrameHandler3)::GetRangeOfTrysToCheck(\n    RENAME_EH_EXTERN(__FrameHandler3)::TryBlockMap &TryBlockMap,\n    __ehstate_t                                    curState,\n    DispatcherContext                              * /*pDC*/,\n    FuncInfo                                       * pFuncInfo,\n    int                                            CatchDepth\n) {\n    TryBlockMapEntry *pEntry = FUNC_PTRYBLOCK(*pFuncInfo, 0);\n    unsigned start = FUNC_NTRYBLOCKS(*pFuncInfo);\n    unsigned end = start;\n    unsigned end1 = end;\n\n    while (CatchDepth >= 0) {\n            _VCRT_VERIFY(start != -1);\n            start--;\n            if ( TBME_HIGH(pEntry[start]) < curState && curState <= TBME_CATCHHIGH(pEntry[start])\n                    || (start == -1)\n            ) {\n                    CatchDepth--;\n                    end = end1;\n                    end1 = start;\n                    }\n            }\n\n    ++start; // We always overshoot by 1 (we may even wrap around)\n    _VCRT_VERIFY(end <= FUNC_NTRYBLOCKS(*pFuncInfo) && start <= end);\n    auto iterStart = TryBlockMap::iterator(TryBlockMap, start);\n    auto iterEnd = TryBlockMap::iterator(TryBlockMap, end);\n\n    return TryBlockMap::IteratorPair(iterStart, iterEnd);\n}\n\n```\nBtw TBME_HIGH is tryHigh field and TBME_CATCHHIGH is the topic - catchHigh.\n\nHowever I can't seem to follow the above code - what I can do however is show you my example:\n\n```\n#include <cstdio>\n#include <Windows.h>\n#include <winnt.h>\n#include <malloc.h>\nextern \"C\" void* _ReturnAddress(void);\nvoid f() {\n    if (!printf(\"\"))\n        throw 9;\n}\n\nstruct test {\n    test();\n    test(const test&);\n    ~test();\n    test f1(int, test);\n    int a, b;\n} f(int, test) throw(int) {\n    test tmp;\n    f();\n    return tmp;\n}\n\nint printfproxy(size_t szbuffer, const char* format, ...)\n{\n    va_list lst;\n    va_start(lst, format);\n    char* tmp = (char*)_alloca(szbuffer);\n    int a = vsprintf(tmp, format, lst);\n    OutputDebugStringA(tmp);\n    return a;\n}\n\ntest test::f1(int, test a) throw(int) {\n    test tmp;\n    return tmp;\n}\n\ntest::test() : a((int)_ReturnAddress()), b(0) {\n    printfproxy(sizeof \"ctor test @ ffffffff  \n\", \"ctor test @ %X  \n\", a);\n}\n\n\ntest::test(const test& arg) : a((int)_ReturnAddress()), b(arg.a)\n{\n    printfproxy(sizeof \"copy ctor test @ ffffffff  \n\", \"copy ctor test @ %X  \n\", a);\n}\n\ntest::~test() {\n    printfproxy(sizeof \"de ctor test @ ffffffff  \n\", \"de ctor test @ %X  \n\", a);\n}\n\nstruct test4 {\n    int a[3];\n} f4(int, struct test4 arg) throw(int) {\n    test4 tmp;\n    return tmp;\n}\n\nvoid main() {\n    test tmp;\n    test4 tmp2;\n    try {\n        test tmp, tmp3;\n        test4 tmp2;\n        try {\n            if (tmp.b == 0)\n#line 93\n                f(9, tmp).f1(9, tmp), f(7, tmp);\n            else\n                f(7, tmp), f(7, tmp), f4(7, tmp2);\n        }\n        catch (int) {\n            try {\n#line 99\n                printfproxy(sizeof \"handler 2147483647\"\"  \n\", \"handler %d\"\"  \n\", __LINE__); test tmphandler; f(7, tmp);\n            }\n            catch (int) {\n#line 102\n                printfproxy(sizeof \"handler 2147483647\"\"  \n\", \"handler %d\"\"  \n\", __LINE__);\n            }\n        }\n#line 106\n        if (tmp.b == 0)\n            f(9, tmp).f1(9, tmp), f(7, tmp);\n        else\n            f(7, tmp), f(7, tmp), f4(7, tmp2);\n    }\n#line 111\n    catch (int) { printfproxy(sizeof \"handler 2147483647\"\"  \n\", \"handler %d\"\"  \n\", __LINE__); }\n}\n\n```\nHere is the tryblockmap generated by the compiler:\n\n```\nstru_40C9F0     TryBlockMapEntry <11, 12, 13, 1, offset stru_40C9C0> ; offset loc_401554\n                TryBlockMapEntry <4, 9, 13, 1, offset stru_40C9D0> ; offset loc_4014FF\n                TryBlockMapEntry <1, 18, 19, 1, offset stru_40C9E0> ; offset loc_4015FD\n\n```\nAnd here is the point of first exception inside main function (at line 93):\n\n\n\nWe see that at this point the state is 5 (state is represented by var_4 in ida).\n\nMind the break-point - the actual exception happens at the call to f - few instructions later.\n\nSo we look at the smallest range that fits - that is the second trymapentry (offset loc_4014FF). So we execute the handler at line 99:\n\n\n\nNow there in the initial instructions, more specifically the call to printfproxy the state is still - the tryHigh of the previous step + 1 so 10. Then when we enter the call to f the state becomes 0xC (12). Now at this point when the exception occurs inside f the first trymapentry (offset loc_401554) is executed (line 102) for the same reason as before - it's the smallest range that fits the current state (note that the range is inclusive since:\n\n```\ntypedef const struct _s_TryBlockMapEntry {\n    __ehstate_t     tryLow;             // Lowest state index of try\n    __ehstate_t     tryHigh;            // Highest state index of try\n\n```\nand so the 12 fits here at the end).\n\nAlso funny thing to notice is that the appropriate trymapentry starts at state 11 and so if the exception occurred in the beginning where we established that the state is 10 the outermost handler will be executed (line 111) - however that is impossible since the compiler has determined that printfproxy can't throw.\n\nAnyway now let's execute another handler further:\n\n\n\nHere we continue execution at line 106 where another exception is about to occur. This time the state is set to 0xE (14). Which means it's time to execute the outermost handler (offset loc_4015FD @line 111)  because it's the only range that fits.\n\nMy point is we never once reached a point where catchHigh was needed. We only used the idea of the smallest possible range that fits current state. My question is - could there be a situation where this field would be actually needed to determine the right handler?\n\nNote smallest possible range in my mind is if the range is contained in another range - that range. If I had to write an algorithm to find the right handler given state and tryblockmap I would do something like (pseudo-code using range for loop) and never use catchHigh:\n\n```\nfindhandler(\n    state,\n    tryblockmap\n) {\n    int loweststate = INT_MIN, maxstate = INT_MAX;\n    auto handler = nullptr;\n    for (auto a : tryblockmap)\n        if (a.tryLow <= state && a.tryHigh >= state) //if it fits\n            if (a.tryLow > loweststate || a.tryHigh < maxstate) //if it smaller range then previous handler\n                handler = a, loweststate = a.tryLow, maxstate = a.tryHigh;\n\n    return handler;\n}\n\n```\nNote - I'm using VC++6.0 SP5 PP5 to compile.\n\n",
  "votes": "0",
  "answers": 0,
  "views": "251",
  "tags": [
    "x86",
    "c++",
    "seh",
    "msvc"
  ],
  "user": "rec",
  "time": "May 4, 2020 at 19:50",
  "comments": [
    {
      "user": "Igor Skochinsky",
      "text": "Maybe try an example with several catches for the same try",
      "time": null
    },
    {
      "user": "rec",
      "text": "@IgorSkochinsky I tried and the ranges increases after each catch so still no purpose of the catchHIgh field although i understand now how it's used - it's just checked if a state is in the range of any of it's catch handlers and if it's so the handler owning those catches is excluded from the search.",
      "time": null
    }
  ],
  "answers_data": []
}