{
  "title": "Is it possible to capture the standard output of a process in Ollydbg?",
  "link": "https://reverseengineering.stackexchange.com/questions/6350/is-it-possible-to-capture-the-standard-output-of-a-process-in-ollydbg",
  "content": "I'm debugging an out-of-process COM server (an EXE), started by a dummy application I wrote. I attach the debugger when the instance is created and let the dummy application make calls to the server. \n\nIn the debugged process, I can see that it does lots of logging by calling sprintf. I would like to capture this output. Is there a way to do this with OllyDbg 2.01?\n\n",
  "votes": "1",
  "answers": 3,
  "views": "1k",
  "tags": [
    "ollydbg"
  ],
  "user": "TamÃ¡s Szelei",
  "time": "Oct 1, 2014 at 10:47",
  "comments": [],
  "answers_data": [
    {
      "content": "sprintf is a crt function superseded by sprintf_s both take a destination a format string and varargs  no of arguments can range from one to several depending on the format string.\n\ncode for both these functions are normally embedded inside the binary (static) and needs to be located and a preparatory step needs to be done prior to logging the output that will get sprintf'fed to the Destination Buffer;\n\nOllydbg 1.10 \n\noutput below shows both the start of both sprintf versions (note src is available for vc compiled exes cycle the comment column to make src visible) \n\n```\nsprintf \n00401147 >/$  8BFF          MOV     EDI, EDI         ; { sprintf.c:99. \n\n00401120 >/$  55            PUSH    EBP                              \n; __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s,\n _Deref_post_z_ char, _Dest, _In_z_ _Printf_format_string_ const char *, \n_Format) stdio.h:323. \n\n```\nselect the start of function \nright click analysis -> assume arguments -> select Sformat(ptr,format,.....) apply\n\noutput post assume argument operation  cycle back to comment from src \n\n```\n00401147 >/$  8BFF          MOV     EDI, EDI     ;  Decoded as <Sformat>\n\n00401120 >/$  55            PUSH    EBP          ;  Decoded as <Sformat>\n\n```\nnow all you need is a non breaking conditional breakpoint to log all the sprintf output\n\n```\nselect the start of function and click shift+f4 \n\n```\nset radio buttons as follows for both version\n\n```\npause radio button                     never \nlog expression radio button            never \nlog function arguments radio button    always \n\n```\nnow simply f9 and you will have all the sprintf arguments logged to log window or a file you specify (right click in log window to set up file logging )\n\n```\nBreakpoints\nAddress                            Module              Active \n00401120 sprintlo.sprintf_s<128>   sprintlo            Log \"logging sprintf_s_arguments\"\n00401147 sprintlo.sprintf          sprintlo            Log \"logging sprint arguments\" \n\n```\nhere is a sample output\n\n```\nLog data\nCALL to Assumed Sformat from sprintlo.0040104F\n  ptr = 0013FEE0\n  format = \"%s    %03d %s %p\"\n  <%s> = \"sprint logging number\"\n  <%03d> = 0\n  <%s> = \"logme\"\n  <%p> = sprintlo.00401105\nCALL to Assumed Sformat from sprintlo.004010BF\n  ptr = 0013FEE0\n  format = \"%s    %03d %s %p\"\n  <%s> = \"sprint logging number\"\n  <%03d> = 0\n  <%s> = \"logme\"\n  <%p> = sprintlo.00401111\n  ==================================================================================\nCALL to Assumed Sformat from sprintlo.0040104F\n  ptr = 0013FEE0\n  format = \"%s    %03d %s %p\"\n  <%s> = \"sprint logging number\"\n  <%03d> = 4\n  <%s> = \"logme\"\n  <%p> = sprintlo.00401105\nCALL to Assumed Sformat from sprintlo.004010BF\n  ptr = 0013FEE0\n  format = \"%s    %03d %s %p\"\n  <%s> = \"sprint logging number\"\n  <%03d> = 4\n  <%s> = \"logme\"\n  <%p> = sprintlo.00401111\nProcess terminated, exit code 0\n\n```\ncode used for demonstration\n\n```\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <intrin.h>\nvoid insecuresprintf(int in) {\n    char dummybuff[0x80];\n    memset(dummybuff,0,sizeof(dummybuff));\n    void* pvAddressOfReturnAddress = _AddressOfReturnAddress();    \n    sprintf(\n        dummybuff,\n        \"%s    %03d %s %p\\0\\0\",\"sprint logging number\" ,\n        in,\"logme\",*((void**) pvAddressOfReturnAddress)\n        );\n    return;\n}\nvoid securesprintf(int in) {\n    char dummybuff[0x80];\n    memset(dummybuff,0,sizeof(dummybuff));\n    void* pvAddressOfReturnAddress = _AddressOfReturnAddress();    \n    sprintf_s(\n        dummybuff,\n        \"%s    %03d %s %p\\0\\0\",\"sprint logging number\" ,\n        in,\"logme\",*((void**) pvAddressOfReturnAddress)\n        );\n    return ;\n}\nint main (void) { \n    for (int i =0; i<5; i++)    {\n        insecuresprintf(i);\n        securesprintf(i);\n    }\n    return 0;\n}\n\n```\nollydbg 2.01 \n\ninstead of analysis assume arguments you have to shift + f4 directly and specify the function type there  use format 2A (arg1,format,.....) but there is a bug in the function because of which the resulting strings are truncated out \n\n```\nINT3 breakpoints\nAddress   Module    Status       Disassembly                              Comment\n00401120 >sprintlog Cond         PUSH    EBP                              INT sprintlog.sprintf_s<128>(_Dest,_Format)\n00401147 >sprintlog Cond         MOV     EDI, EDI                         INT sprintlog.sprintf(string,format)\n\n```\noutput from ollydbg 2.01 (notice %03d showing correct values but %p %s output are not visible )\n\n```\nLog data\n00401147  Call to sprintlog.sprintf from sprintlog.0040104F\n        0013FEE0  Arg1 = 13FEE0\n        004131AC  Format = \"%s    %03d %s %p\"\n        00413194  <%s> =\n        00000000  <%03d> =\n        0041318C  <%s> =\n        00401105  <%p> =\n00401120  Call to sprintlog.sprintf_s<128> from sprintlog.004010BF\n        0013FEE0  Arg1 = 13FEE0\n        004131E0  Format = \"%s    %03d %s %p\"\n        004131C8  <%s> =\n        00000000  <%03d> =\n        004131C0  <%s> =\n        00401111  <%p> =\n========================================================================================\n00401147  Call to sprintlog.sprintf from sprintlog.0040104F\n        0013FEE0  Arg1 = 13FEE0\n        004131AC  Format = \"%s    %03d %s %p\"\n        00413194  <%s> =\n        00000004  <%03d> =\n        0041318C  <%s> =\n        00401105  <%p> =\n00401120  Call to sprintlog.sprintf_s<128> from sprintlog.004010BF\n        0013FEE0  Arg1 = 13FEE0\n        004131E0  Format = \"%s    %03d %s %p\"\n        004131C8  <%s> =\n        00000004  <%03d> =\n        004131C0  <%s> =\n        00401111  <%p> =\n      Process terminated, exit code 0\n\n```\nbtw it is incredibly simple with windbg \n\n```\n0:000> x *!sprintf*\n7c925bc4 ntdll!sprintf = <no type information>\n00401147 sprintlog!sprintf (void)\n004011e7 sprintlog!sprintf_s (void)\n00401120 sprintlog!sprintf_s<128> (char (*)[128], char *)\n0:000> bp 00401120 \"r $t1 = poi(@esp+4) ; gu; .printf \\\"%ma\\  \n\\\", @$t1 ; gc\"\n0:000> bp 00401147 \"r $t1 = poi(@esp+4) ; gu; .printf \\\"%ma\\  \n\\\", @$t1 ; gc\"\n0:000> .bpcmds\nbp0 0x00401120  \"r $t1 = poi(@esp+4) ; gu; .printf \\\"%ma\\  \n\\\", @$t1 ; gc\";\nbp1 0x00401147  \"r $t1 = poi(@esp+4) ; gu; .printf \\\"%ma\\  \n\\\", @$t1 ; gc\";\n0:000> g\nModLoad: 5cb70000 5cb96000   C:\\WINDOWS\\system32\\ShimEng.dll\nsprint logging number    000 logme 00401105\nsprint logging number    000 logme 00401111\nsprint logging number    001 logme 00401105\nsprint logging number    001 logme 00401111\nsprint logging number    002 logme 00401105\nsprint logging number    002 logme 00401111\nsprint logging number    003 logme 00401105\nsprint logging number    003 logme 00401111\nsprint logging number    004 logme 00401105\nsprint logging number    004 logme 00401111\n\n```\n",
      "votes": "3",
      "user": "blabb",
      "time": "Oct 1, 2014 at 20:10",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "I can think of these options:\n\n1) Edit the .exe flags to mark it as a console process. E.g.\n\n```\nEDITBIN /SUBSYSTEM:CONSOLE comserver.exe\n\n```\n2) Use the debugger to call to AllocConsole() at runtime.\n\n3) Put a breakpoint on the logging function and log the string contents in the breakpoint's action (not sure if it's doable in OllyDbg).\n\n",
      "votes": "1",
      "user": "Igor Skochinsky",
      "time": "Oct 1, 2014 at 11:00",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "sprintf doesnt \"log\" to standard output. it prints to a variable.\n\nanyways: you could use a OllyDbgScript which sets a BP on sprintf and then use BPGOTOcommand to do some actions like dump the formatted variable and run again.\n\n",
      "votes": "0",
      "user": "pHiL",
      "time": "Oct 1, 2014 at 12:04",
      "is_accepted": false,
      "comments": []
    }
  ]
}