{
  "title": "Virtual machine code obfuscation implementation details",
  "link": "https://reverseengineering.stackexchange.com/questions/24956/virtual-machine-code-obfuscation-implementation-details",
  "content": "I want to implement a VM based simple proof-of-concept obfuscator. It should take an exe file as input and produce a new pe file with appended vm section. For simplicity let's say the exe file is compiled as a 32 bit pe.\n\nThe problem is that most materials I've found online explain only how to crack and not how to implement such a solution, or just explain how to implement a simple VM with a very limited number of instructions.\n\nArchitecture\n\nI want to build such an architecture as described in this (Enhance virtual-machine-based code obfuscation security through dynamic bytecode scheduling) paper:\n\n\n\nLet me quote it:\n\n```\nFig.â€‰1. A classical process for VM-based code obfuscation.\nTo obfuscate the code, we first dissemble the code region to be\nprotected into native assembly code (1).\nThe assembly code will be mapped into our virtual instructions (2)\nwhich will then be encoded into a bytecode format (3). Finally,\nthe generated byecode will be inserted into a specific region of\nthe binary which is linked with a VM library (4).\n\n```\nQuestion\n\nLet's say I have implemented a very basic virtual machine with a set of 20 instructions as presented in this [presentation]:\n\n```\niadd, \nisub, \nimul, \nilt, \nieq, \nbr addr, \nbrt addr, \nbrf addr, \niconst value, \nload addr, \ngload addr, \nstore addr, \ngstore addr, \nprint, \npop, \ncall addr, numArgs\nret\nhlt\n\n```\nIn step 2 (Virtualization), I have to somehow map the extracted Intel instruction set to my virtualized instructions. The Intel instruction set is huge (over 200 instructions).\nAnd I have completely no idea how to do this. Starting with the fact that my virtual machine uses fewer of registers then Intel does. \n\n",
  "votes": "2",
  "answers": 2,
  "views": "4k",
  "tags": [
    "obfuscation",
    "deobfuscation",
    "virtual-machines"
  ],
  "user": "Rob D",
  "time": "May 9, 2020 at 19:10",
  "comments": [],
  "answers_data": [
    {
      "content": "You will need to go through each of the over 200 instructions, and figure out how to do the \"same\" thing in your instruction set. So you'll need to see how the stack may be changing, the stack pointer, the program counter, and also if any memory or register changes. For differences like not having enough registers, you could set aside a portion of memory to use to store the values that would otherwise be going into the Intel registers. Look out also for endianness of the data, and whether it is 32-bit, 64-bit, etc.\n\nAnd that's if you can assume that each instruction is independent of the others. The instruction set you're starting from, may have quirks that break this assumption, and you'll need to take care of those. For example, it may have branch delay slots, like in MIPS (Understanding branch delay slots for reversing MIPS), where a condition is evaluated for the branching, and even if the jump/branch happens, the next instruction is evaluated.\n\nAs the mapping may be a challenging task, some people take an alternative approach and start from source code in a high level language (C for instance), and directly compile that to the bytecode of the virtual machine. For example, take a look at the virtualize transform of the Tigress obfuscator. The Tigress obfuscation is source-to-source (C to C), so when virtualize is selected, the resulting C code actually implements the desired virtual machine, and runs the bytecode (compiled for the VM by Tigress) on that virtual machine.\n\nBut in your case, if you have to start with an exe, then you'll need to work on the mapping.\n\n",
      "votes": "3",
      "user": "auspicious99",
      "time": "May 9, 2020 at 16:44",
      "is_accepted": true,
      "comments": [
        {
          "user": "Rob D",
          "text": "This is great answer! Unfortunately it seems that it is more complicated then I thought for. I will start with something easier, such as instruction transformation/code reordering:)",
          "time": null
        },
        {
          "user": "auspicious99",
          "text": "Yes, unfortunately it is not so easy to implement VM-based obfuscation. Once it is successfully implemented, though, it is a powerful form of obfuscation. Good luck with your efforts!",
          "time": null
        }
      ]
    },
    {
      "content": "If you want proof-of-concept VM based obfuscator, you can actually skip the virtualization step and bytecode generation step. You can write an interpreter of x86 instructions in x86 assembler so that the implementation is easy. You can add custom instructions one by one later through assembler macros, for example. This is much less complicated process than writing a full-blown VM.\n\nThe most trivial \"VM\" that runs some x86 instructions can be found here:\n\nhttps://github.com/Barebit/trivial-vm\n\nThe vm1.c merely copies an x86 instruction to a buffer and runs it. It is not even an interpreter. The vm2 does the same but interprets few branch instructions that can't be run directly.\n\n",
      "votes": "3",
      "user": "MazeGen",
      "time": "May 11, 2020 at 7:58",
      "is_accepted": false,
      "comments": []
    }
  ]
}