{
  "title": "Injecting code into an ELF binary , got Segmentation fault(SIGSEGV)",
  "link": "https://reverseengineering.stackexchange.com/questions/26660/injecting-code-into-an-elf-binary-got-segmentation-faultsigsegv",
  "content": "I am currently working on an ELF-injector and my approach is standard: find code cave (long enough sequence of 0's), rewrite it with the instructions I want to execute and then jump back to the start of the original program to execute it as it normally would.\n\n\n\n\n\n\n```\n*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\nBuild fingerprint: 'Meizu/MeizuE3_CN/MeizuE3:7.1.1/NGI77B/1578882816:user/release-keys'\nRevision: '0'\nABI: 'arm'\npid: 14576, tid: 14576, name: load_lib.so  >>> ./load_lib.so <<<\nsignal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x14608\n    r0 000775bd  r1 00000002  r2 00014608  r3 0000000a\n    r4 f2d62279  r5 f28bfcc0  r6 f2d04a90  r7 0000000a\n    r8 f2d62279  r9 f2d725f0  sl f2d62268  fp ffc08818\n    ip 00000000  sp ffc08818  lr f28bfce0  pc 00014608  cpsr 800e0010\n    d0  0000000000000000  d1  0000000000000000\n    d2  0000000000000000  d3  0000000000000000\n    d4  0000000000000000  d5  0000000000000000\n    d6  0000000000000000  d7  0000000000000000\n    d8  0000000000000000  d9  0000000000000000\n    d10 0000000000000000  d11 0000000000000000\n    d12 0000000000000000  d13 0000000000000000\n    d14 0000000000000000  d15 0000000000000000\n    d16 0000001ff2c72000  d17 0000000000000000\n    d18 0000000000002a98  d19 0000000000001080\n    d20 0000000000000000  d21 0000000000000000\n    d22 0000000000000000  d23 0000000000000000\n    d24 0000000000000000  d25 0000000000000000\n    d26 0000000000000000  d27 0000000000000000\n    d28 0000000000000000  d29 0000000000000000\n    d30 0000000000000000  d31 0000000000000000\n    scr 80000000\n\nbacktrace:\n    #00 pc 00014608  <unknown>\n    #01 pc 00074cdc  /data/local/tmp/libc.so\n\nstack:\n         ffc087d8  f2d01370  [anon:linker_alloc]\n         ffc087dc  f2cff040  [anon:linker_alloc]\n         ffc087e0  00000000\n         ffc087e4  00000002\n         ffc087e8  f2c77010\n         ffc087ec  00000001\n         ffc087f0  3f800000\n         ffc087f4  00000000\n         ffc087f8  f2d03d40  [anon:linker_alloc_small_objects]\n         ffc087fc  f2d03d40  [anon:linker_alloc_small_objects]\n         ffc08800  f2d03d48  [anon:linker_alloc_small_objects]\n         ffc08804  ffc08878  [stack]\n         ffc08808  f2d04010  [anon:linker_alloc]\n         ffc0880c  f2d72010\n         ffc08810  f2d03d20  [anon:linker_alloc_small_objects]\n         ffc08814  f2d03d20  [anon:linker_alloc_small_objects]\n    #00  ffc08818  f2d04a90  [anon:linker_alloc]\n         ........  ........\n    #01  ffc08818  f2d04a90  [anon:linker_alloc]\n         ffc0881c  f2d127e3  /system/bin/linker (__dl__ZN6soinfo13call_functionEPKcPFvvE+86)\n         ffc08820  00000000\n         ffc08824  f2d01220  [anon:linker_alloc]\n         ffc08828  00000001\n         ffc0882c  00000001\n         ffc08830  f28d0de0  /data/local/tmp/libc.so\n         ffc08834  f2d12703  /system/bin/linker (__dl__ZN6soinfo10call_arrayEPKcPPFvvEjb+190)\n         ffc08838  00000000\n         ffc0883c  00000000\n         ffc08840  00000000\n         ffc08844  f2d721d0\n         ffc08848  f2d62345  /system/bin/linker\n         ffc0884c  f2d04a90  [anon:linker_alloc]\n         ffc08850  00000000\n         ffc08854  f2d721d0\n\n```\n```\n//my shellcode\ne92d4800    push    {fp, lr}\ne1a0b00d    mov fp, sp\ne3042608    movw    r2, #17928  ; 0x4608\ne3402001    movt    r2, #1\ne30705bd    movw    r0, #30141  ; 0x75bd\ne3400007    movt    r0, #7\ne3a01002    mov r1, #2\ne12fff32    blx r2\ne3060e45    movw    r0, #28229  ; 0x6e45\ne3400001    movt    r0, #1\ne12fff30    blx r0\ne8bd8800    pop {fp, pc}\n\n```\n```\n.init_array:00085DE0 ; ELF Initialization Function Table\n.init_array:00085DE0 ; ===========================================================================\n.init_array:00085DE0\n.init_array:00085DE0 ; Segment type: Pure data\n.init_array:00085DE0                 AREA .init_array, DATA\n.init_array:00085DE0                 ; ORG 0x85DE0\n.init_array:00085DE0 off_85DE0       DCD __start_ae          ; DATA XREF: LOAD:off_9C↑o\n.init_array:00085DE0                                         ; LOAD:off_15C↑o\n.init_array:00085DE4                 DCD sub_74CC0 ;<---my shellcode--------- \n.init_array:00085DE8                 DCD _GLOBAL__sub_I_libgen.cpp+1\n.init_array:00085DEC                 DCD _GLOBAL__sub_I_mntent.cpp+1\n.init_array:00085DF0                 DCD _GLOBAL__sub_I_pty.cpp+1\n.init_array:00085DF4                 DCD _GLOBAL__sub_I_strerror.cpp+1\n.init_array:00085DF8                 DCD _GLOBAL__sub_I_strsignal.cpp+1\n.init_array:00085DFC                 DCD _GLOBAL__sub_I_stubs.cpp+1\n.init_array:00085E00                 DCD __res_key_init+1\n.init_array:00085E04                 DCD jemalloc_constructor+1\n.init_array:00085E04 ; .init_array   ends\n.init_array:00085E04\n\n```\n```\n.text:00074CC0 sub_74CC0                               ; DATA XREF: .init_array:00085DE4↓o\n.text:00074CC0                 STMFD           SP!, {R11,LR}\n.text:00074CC4                 MOV             R11, SP\n.text:00074CC8                 MOV             R2, #0x14608\n.text:00074CD0                 MOV             R0, #(aSLibomegaSo+4) ; file\n.text:00074CD8                 MOV             R1, #2  ; mode\n.text:00074CDC                 BLX             R2      ; dlopen;<---When the code runs here , got signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x14608\n.text:00074CE0                 MOV             R0, #0x16E45\n.text:00074CE8                 BLX             R0      ; __libc_preinit(void)\n.text:00074CEC                 LDMFD           SP!, {R11,PC}\n.text:00074CEC ; End of function sub_74CC0\n.text:00074CEC\n\n```\n```\n.plt:00014608\n.plt:00014608 ; =============== S U B R O U T I N E =======================================\n.plt:00014608\n.plt:00014608 ; Attributes: thunk\n.plt:00014608\n.plt:00014608 ; void *dlopen(const char *file, int mode)\n.plt:00014608 dlopen                                  ; CODE XREF: __libc_init_malloc(libc_globals *)+84↓p\n.plt:00014608                                         ; netdClientInitImpl(void)+8↓p ...\n.plt:00014608                 ADRL            R12, 0x87610\n.plt:00014610                 LDR             PC, [R12,#(dlopen_ptr - 0x87610)]! ; __imp_dlopen\n.plt:00014610 ; End of function dlopen\n.plt:00014610\n\n```\nI've looked up a lot of relevant posts, but I still don't have a clue.\n\nA week, I still have not found the specific reason, I sincerely hope someone can help me\n\n",
  "votes": "1",
  "answers": 1,
  "views": "641",
  "tags": [
    "ida",
    "arm",
    "elf",
    "shellcode",
    "dll-injection"
  ],
  "user": "桂冠-",
  "time": "Dec 29, 2020 at 19:16",
  "comments": [],
  "answers_data": [
    {
      "content": "Is your binary relocated on load (ASLR)? In that case 14608 points to some random memory (probably unallocated). You need to use a position-independent instruction to load the address of the dlopen stub (e.g. ADRL).\n\n",
      "votes": "1",
      "user": "Igor Skochinsky",
      "time": "Dec 29, 2020 at 21:33",
      "is_accepted": true,
      "comments": [
        {
          "user": "桂冠-",
          "text": "In just one sentence, you solved the problem that has been bothering me for a week. Thank you very much for your answer.",
          "time": null
        }
      ]
    }
  ]
}