{
  "title": "How to utilize `FillOutStructureCmd`?",
  "link": "https://reverseengineering.stackexchange.com/questions/30563/how-to-utilize-filloutstructurecmd",
  "content": "Basically I'm extending the CreateStructure.java plugin so it iterates all functions and tries to automatically create structures on all variables.\n\nIt looks something like this:\n\n```\npublic class CreateStructure extends GhidraScript {\n\n    @Override\n    public void run() throws Exception {\n        FunctionIterator funcs = currentProgram.getFunctionManager().getFunctions(true);\n        DecompInterface decomp = setUpDecompiler(currentProgram);\n        for (Function fn : funcs) {\n            Variable[] allvars = fn.getAllVariables();\n            for(Variable var : allvars) {\n                /*DecompileResults res = decomp.decompileFunction(fn, 10000, monitor);\n                ClangNode nodres = null;\n                ClangTokenGroup ccode = res.getCCodeMarkup();\n                println(\"Decompiled \" + fn.getName());\n                ClangToken tokeres = new ClangToken((ClangNode) var.getVariableStorage().getFirstVarnode());\n                */\n                //DecompilerLocation loc = new DecompilerLocation(currentProgram, var.getFirstStorageVarnode().getAddress(), fn.getEntryPoint(), res, tokeres,0,0);\n                setCurrentLocation(var.getMinAddress());\n                FillOutStructureCmd fillCmd =\n                        new FillOutStructureCmd(currentProgram, currentLocation, state.getTool());\n                fillCmd.applyTo(currentProgram, this.monitor);\n            }\n        }\n    }\n    \n    private DecompInterface setUpDecompiler(Program program) {\n        DecompInterface decompInterface = new DecompInterface();\n\n        // call it to get results\n        if (!decompInterface.openProgram(currentProgram)) {\n            println(\"Decompile Error: \" + decompInterface.getLastMessage());\n            return null;\n        }\n\n        DecompileOptions options;\n        options = new DecompileOptions();\n        OptionsService service = state.getTool().getService(OptionsService.class);\n        if (service != null) {\n            ToolOptions opt = service.getOptions(\"Decompiler\");\n            options.grabFromToolAndProgram(null, opt, program);\n        }\n        decompInterface.setOptions(options);\n\n        decompInterface.toggleCCode(true);\n        decompInterface.toggleSyntaxTree(true);\n        decompInterface.setSimplificationStyle(\"decompile\");\n\n        return decompInterface;\n    }\n}\n\n```\nBut it only iterates through the functions variables without creating structures - unlike when I position my cursor on a parameter and execute there.\n\nWhat am I missing?\n\n(You can also see my attempt to retrieve the DecompilerLocation which also doesn't work)\n\n",
  "votes": "1",
  "answers": 1,
  "views": "89",
  "tags": [
    "decompilation",
    "ghidra",
    "java",
    "plugin"
  ],
  "user": "rec",
  "time": "Jun 27, 2022 at 16:35",
  "comments": [],
  "answers_data": [
    {
      "content": "I figure it out something like this does it:\n\n```\npublic class CreateStructure extends GhidraScript {\n\n    @Override\n    public void run() throws Exception {\n        /*println(\"\" + currentLocation.toString());\n        FillOutStructureCmd fillCmd =\n                new FillOutStructureCmd(currentProgram, currentLocation, state.getTool());\n        fillCmd.applyTo(currentProgram, this.monitor);*/\n        FunctionIterator funcs = currentProgram.getFunctionManager().getFunctions(true);\n        DecompInterface decomp = setUpDecompiler(currentProgram);\n        for (Function fn : funcs) {\n            Variable[] allvars = fn.getAllVariables();\n            for(Variable var : allvars) {\n                /*DecompileResults res = decomp.decompileFunction(fn, 10000, monitor);\n                ClangNode nodres = null;\n                ClangTokenGroup ccode = res.getCCodeMarkup();\n                println(\"Decompiled \" + fn.getName());\n                ClangToken tokeres = new ClangToken((ClangNode) var.getVariableStorage().getFirstVarnode());\n                */\n                DataType dattyp = var.getDataType();\n                String datatypstring = dattyp.getDisplayName();\n                println(datatypstring = datatypstring.replaceAll(\"\\\\[|\\\\]|\\\\*|\\\\s\", \"\"));\n                DecompileResults res = decomp.decompileFunction(fn, 10000, monitor);\n                \n                ClangTokenGroup tokengrp = res.getCCodeMarkup();\n                \n                if(tokengrp == null) continue;\n                \n                ClangToken tokeres = null;\n                \n                println(\"searching for \" + datatypstring);\n                \n                mainloop:\n                for(ClangNode  token : tokengrp) {\n                    if(token instanceof ClangFuncProto) {\n                        for(ClangNode  outter : ((ClangFuncProto)token)) {\n                            if(outter instanceof ClangVariableDecl)\n                            for(ClangNode inner2 : ((ClangVariableDecl)outter)) {\n                                if(inner2 instanceof ClangToken) {\n                                    if(((ClangToken)inner2).getText().equals(datatypstring)) {\n                                        tokeres = (ClangToken)inner2;\n                                        println(inner2.getClass().toString());\n                                        break mainloop;\n                                    }\n                                    else {\n                                        println(\"\" + ((ClangToken)inner2).getText());\n                                    }\n                                }\n                                else {\n                                    println(inner2.getClass().toString());\n                                }\n                            }\n                    }\n                }\n                }\n                if(tokeres == null) continue;\n                println(\"found\");\n                \n                //ClangToken tokeres = new ClangToken(null, datatypstring);\n                DecompilerLocation loc = new DecompilerLocation(currentProgram, fn.getEntryPoint(), fn.getEntryPoint(), res, tokeres,1,1);\n                println(\"\" + loc);\n                FillOutStructureCmd fillCmd =\n                        new FillOutStructureCmd(currentProgram, loc, state.getTool());\n                fillCmd.applyTo(currentProgram, this.monitor);\n            }\n        }\n    }\n    \n    private DecompInterface setUpDecompiler(Program program) {\n        DecompInterface decompInterface = new DecompInterface();\n\n        // call it to get results\n        if (!decompInterface.openProgram(currentProgram)) {\n            println(\"Decompile Error: \" + decompInterface.getLastMessage());\n            return null;\n        }\n\n        DecompileOptions options;\n        options = new DecompileOptions();\n        OptionsService service = state.getTool().getService(OptionsService.class);\n        if (service != null) {\n            ToolOptions opt = service.getOptions(\"Decompiler\");\n            options.grabFromToolAndProgram(null, opt, program);\n        }\n        decompInterface.setOptions(options);\n\n        decompInterface.toggleCCode(true);\n        decompInterface.toggleSyntaxTree(true);\n        decompInterface.setSimplificationStyle(\"decompile\");\n\n        return decompInterface;\n    }\n}\n\n```\nNow I only need to seed out the non structure types because currently it's creating structure for everything.\n\n",
      "votes": "1",
      "user": "rec",
      "time": "Jun 27, 2022 at 18:20",
      "is_accepted": false,
      "comments": []
    }
  ]
}