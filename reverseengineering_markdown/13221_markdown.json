{
  "title": "Decoding an unknown image format with \"DREK\" signature (*.drk)",
  "link": "https://reverseengineering.stackexchange.com/questions/13221/decoding-an-unknown-image-format-with-drek-signature-drk",
  "content": "There are some unknow images, which I would like to decode to RRGGBBAA format. It was a really hard work, but at the moment I can somewhat understand, that which part of the binary is responsible for what. But I'm stuck at the end, and I have no idea how to continue it. This is what I've found out:\n\nI know, that the size of the first image is a 9*3.\n\nThere is some kind of table at the begining of the file:\n\n```\n0x08 0x08 0x10\n0x08 0x08 0x08\n0x00 0x00 0x00\n0x10 0x10 0x18\n0x18 0x18 0x20\n0x10 0x14 0x18\n0x08 0x08 0x10\n\n```\nAnd this is the image data:\n\n```\n0x09 0x00 0x03 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01 0x00 0x00 0x00\n0x0c 0x00 0x00 0x00 0x00 0x01 0x03 0x09 0x01 0x01 0x02 0x11 0x01 0x01 0x02 0x02\n0x01 0x0f 0x0f 0x03 0x0a 0x03 0x08 0x05 0x08 0x04 0x08 0x03 0x09 0x00 0x09 0x00\n0x0c 0x00 0x02\n\n```\nThe number of elements in the table can be divided by three, so I think it is some kind of RRGGBB palette.\n\nBut I have no idea, how to decode the imagedata. It's size is not 9*3, so It may be compressed. It is a really small image, and I think that this is why the compression made the binary bigger than it was before.\n\nEdit:\n\nI've uploaded this file here: Download file\n\nI've colored it, to better understand it's structure.\n\nThe first part of the file:\n\n\n\nThe second part of the file:\n\n\n\nI've uploaded two more files.\n\nThe bigger file has a resolution of 800*600 And I suspect it is this one (screenshot):\n\n\n\nAt the beginning (from 3C0), only the the first two or three bytes are set in each 4 byte group. From 0xD28, I cannot recognise any pattern.\n\nEdit2:\n\nSpektre's code works with most of the files. But there are some small icons, with transparency, which look distorted.\n\nFor example this icon: Download\n\nAnd this is how it looks like, over a brownish background: \n\n\n\nIn this case, the scanlines are not fixed-width. And the unknown 252 flags at the beginning of each scanline, and 254 flags after every 32bytes are also different.\n\nI can recognise patterns and symmetry in the binary, but I haven't figured out yet, how it works.\n\nI've colored the scanlines of the icon's imagedata, to have a better overview:\n\n\n\nMany of them starts with, and all of them ends with 0x02\n\nEdit3:\n\nI uploaded some images, with screenshots:\n\nI uploaded two more images, which I found distorted. The first is an icon, which is almost perfect. And the second one is a dragon, which is barely recognisable.  Unfortunately I cannot provide screenshots for this two: Download\n\nI implemented the core algorithm ( from Spektre's answer ) in JS. It can be found, and edited online here: JSFiddle link\n\nEdit4:\n\nI've made some progress with the mountain, and the dragon.\n\nI think, that the first 7 bits of the flag byte shows, on which x coordinate the line starts ( ´xstart = flag>>1;´ ). The least significant bit is a switch, which marks, that the line has this offset or not. You can try/edit the current code here: JSFiddle link\n\nThe result is this:\n\n\n\nThe expected result would be similar to this (which is not far):\n\n\n\nThe distorted parts around the mountain are shadow/transparency, but I still wasn't be able to find any marks/flags about where the blocks with alpha values start and end.\n\nEdit5:\n\nI think, I've found a pattern in the mountain image. After the flag byte, the next byte may show, (flag2>>1), how many (Color, Alpha) blocks are at the beginning of the line.\n\nThe left side of the mountain looks slightly better now:\n\n\n\nUnfortunately this change breaks the other images\n\n",
  "votes": "16",
  "answers": 2,
  "views": "3k",
  "tags": [
    "binary-analysis",
    "file-format",
    "unpacking",
    "decompress",
    "binary-diagnosis"
  ],
  "user": "Iter Ator",
  "time": "Apr 13, 2017 at 12:49",
  "comments": [
    {
      "user": "user10070",
      "text": "I take it you don't know what the image actually looks like or anything? Without a header byte string, this will be tough to crack.",
      "time": null
    },
    {
      "user": "Jongware",
      "text": "Is this all data in the file? Do you have more samples? (Preferably available for downloading.)",
      "time": null
    },
    {
      "user": "Iter Ator",
      "text": "I updated the question with more info, and downloadable samples",
      "time": null
    },
    {
      "user": "Iter Ator",
      "text": "@Spektre I will look at it in detail as soon as arrived home",
      "time": null
    },
    {
      "user": "Iter Ator",
      "text": "@Spektre The integer at 0x388-0x38B points everywhere to 0x3C0. The integer from 0x38C-0x38F shows, where the image data ends. The 16bit integers at 0x3C0 and 0x3C2 are width and height again. And the bytes from 0x3C4-0x3C7 are always zero. As I see, only the 0x37C-0x383 part - which is still unknown - is different in almost every image.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "I was able to decode the images. Spektre did a great job detecting the files structure, and the debug view was really helpful in the process. I implemented the algorithm in JS, and the source code is available here: https://github.com/K-Adam/DrekDecoder\n\nEach line starts with a flag byte. It tells the decoder how many pixels to write and which mode to use. There are three possible write modes:\n\nIn opaque mode each pixel is represented by one byte, which references an RGB color in the palette. In transparent mode, the pixels are pairs of bytes: [Alpha, ColorIndex]\n\nAfter each sequence a control byte follows. Its structure is different from the flag byte, and also different in each writing mode. This control byte will tell how many pixels to write and which mode to use next, or if the end of the line is reached.\n\nFlag byte\n\nIf the flag is zero (flag == 0x0), then the line is empty.\n\nIf the LSB is set (flag & 0b1) then there is an offset at the beginning of the line, and the decoder will start in Skip mode. The rest of the bits will represent the length of the offset (flag >> 1) + 1\n\nIf the second bit is set then transparent, otherwise opaque mode will be used:\n\n```\nmode = (flag & 0b10) ? Transparent : Opaque\n\n```\nThe number of pixels can be found in the 5 MSB (flag >> 3) + 1\n\nSkip mode\n\nThe decoder will simply write n empty pixels to the output. The next byte will be a control byte.\n\nIf LSB is set, then the decoder will switch to transarent mode. The other 7 bits represent the number of transparent pixels.\n\nIf the three LSB is 0b100 then the decoder will continue in Skip mode, otherwise it will change to Opaque mode. The other bits represent the number of pixels (vv >> 3) + 1\n\nOpaque mode\n\nEach data byte references an RGB color in the palette.\n\nIf the LSB is set, then the decoder will switch to transparent mode for (v1 >> 1) + 1 pixels. Otherwise the three LSB of the control byte is the flag:\n\nThe rest is the number of pixels (v1 >> 3) + 1.\n\nTransparent mode\n\nThe transparent blocks are represented by sequence of pairs: [Alpha, Color]. The 5 MSB of the alpha byte is the transparency (0-32). The color byte references an RGB color in the palette.\n\nThe two LSB of the control byte is a flag:\n\nThe rest of the bits is the number of pixels (v1 >> 2) + 1, except for transparent mode, where it is (v1 >> 3) + 1\n\nSince the colors are referenced by index, two bytes are needed to represent a transparent pixel. By looking at the bottom-left part of the mountain, it was clear from those alternating patterns, that it has to be transparent there. The colors around the round icons were also not right, so I suspected that the outer pixels are half transparent as well.\n\nIn the large image 0xFE appears after each 32 bytes. It does not reference a color from the palette, so it has to be some kind of control byte.\n\nThen I started to write down the bytes in binary, where the color seemed not right. I grouped these values by where by where they appear, and then I spotted, that the least significant bits are similar on the boundary of transparent and opaque regions.\n\nAfter further analysis, when I was able to decode the smaller icons by hand, I implemented the algorithm, and tested it for larger ones. From there, it was easy to eliminate the remaining anomalies in the result.\n\n",
      "votes": "4",
      "user": "K-Adam",
      "time": "Aug 22, 2019 at 14:55",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "[Complete ReEdit3] further progress & shortening the text to fit the 30KB limit\n\nFirst some input how I got here (for future readers trying to do the same for different format).\n\nNow finally The decoder\n\nThe code was written in Borlands BDS2006 C++ using VCL TBitmap and AnsiString So you need to rewrite it to your kind of gfx access and strings your programming environment supports. If you need help with the meaning of the gfx code see:\n\nAlso File access functions may have a bit different name. I commented the code a bit but it should be obvious anyway. At least for those that already did things like this.\n\nThe defines just switch between debug and normal decoding. If not present then you do not need the debug image class img at all. To keep this simple and also in 30KB limit I removed the code for the debug draw class (those who want/need it look in the edit history). That means ignoring all the _debug_draw defines ...\n\nNow the icons defined pixels are decoded correctly. But I did a lot of assumptions and may not work on all images. I would need more examples with ScreenShots to make it more robust. The codes itself should encode alpha channel and may be also position/offset.\n\nI changed few codes and now I am temporarily ignoring the 0x02 end of ScanLine which make mess when not properly decoded codes are present. Also I added few special cases I found out. The x-offset for mode1 is also present.\n\nIn the code find line:\n\n```\n// image data (decoded)\n\n```\nThat is where main decoding is. The decoding variables are:\n\nIn comments some of the codes are marked // OK those are not conflicting and straightforward. The rest of comments means what codes are following:\n\nThe Transparent ScanLine data starts after first BYTE so do not skip 2 BYTEs just one !!!\n\nHere some previews:\n\n\n\nAnd the Dragon frames:\n\n\n\nThe C++ source for the decoder:\n\n```\n#ifdef _debug_save\nAnsiString dbg_hdr=\"file                          K  E  R  D              file_size        frames image_ofs                                                                                                                                                                                                   palette_ofs used_colors\\r  \n\";\nAnsiString dbg_img=\"                                                                        frame sz          xs          ys                                                                                                                                                                                                                      xs    ys                \\r  \n\";\n#endif\nvoid load_drk(Graphics::TBitmap *bmp,AnsiString name)\n    {\n    AnsiString s,fnam;\n    fnam=name.SubString(1,name.Length()-4);\n\n    // variables\n    BYTE *dat;\n    int hnd,adr,adr0,siz;\n    int i,x,y,xs,ys,sz,mode,frame,frames;\n    DWORD *p,*dir,pal[256],r,g,b,a;\n    // allow direct pixel access\n    bmp->HandleType=bmDIB;\n    bmp->PixelFormat=pf32bit;\n    // read file into memory\n    hnd=FileOpen(name,fmOpenRead);\n    if (hnd<0) return;\n    siz=FileSeek(hnd,0,2);\n        FileSeek(hnd,0,0);\n    dat=new BYTE[siz];\n    if (dat==NULL) { FileClose(hnd); return; }\n    FileRead(hnd,dat,siz);\n    FileClose(hnd);\n    // decode\n    for (;;)\n        {\n        #ifdef _debug_save\n        // save frames to bmp\n        s=fnam+\"                    \";\n        s=s.SubString(1,20);\n        dbg_hdr+=s;\n        dbg_img+=s;\n        dbg_hdr+=\"00000000: \"; for (i=0;i<0x60;i++) { s=s.sprintf(\"%X \",dat[i]); while (s.Length()<3) s=\"0\"+s; dbg_hdr+=s; }\n        dbg_hdr+=\"\\r  \n\";\n        #endif\n\n        // signature\n        if (siz<0x3C8) break;\n        if (((DWORD*)(dat))[ 0]!='DREK') break;\n        if (((DWORD*)(dat))[ 2]!=   siz) break;\n        // palette\n        for (adr=0x060,i=0;i<256;i++)\n            {\n            b=dat[adr]; adr++;\n            g=dat[adr]; adr++;\n            r=dat[adr]; adr++;\n            pal[i]=(r<<16)|(g<<8)|(b);\n            }\n        // frames\n        frames=((WORD*)(dat+0x0E))[0];\n        adr0  =((DWORD*)(dat))[4];\n        for (frame=0;frame<frames;adr0+=sz+0x60,frame++)\n            {\n            adr=adr0;\n            // resolution\n            if (adr0+0x60>siz) break;\n            sz=((DWORD*)(dat+adr))[4];\n            xs=((DWORD*)(dat+adr))[5];\n            ys=((DWORD*)(dat+adr))[6];\n            if (adr0+0x60+sz>siz) break;\n            bmp->SetSize(xs,ys);\n\n            #ifdef _debug_save\n            // save frames to bmp\n            if (frame) dbg_img+=\"                    \";\n            s=s.sprintf(\"%X: \",adr0); while (s.Length()<10) s=\"0\"+s; dbg_img+=s;\n            for (i=adr0;i<adr0+0x68;i++) { s=s.sprintf(\"%X \",dat[i]); while (s.Length()<3) s=\"0\"+s; dbg_img+=s; }\n            dbg_img+=\"\\r  \n\";\n            #endif\n\n            // scanline table\n            dir=new DWORD[ys+1];\n            if (dir==NULL) break;\n            adr+=0x68;\n            for (y=0;y<ys;y++)\n             dir[y]=adr+(ys<<2)+((DWORD*)(dat+adr))[y];\n            dir[ys]=adr0+sz+0x68;\n\n            #ifdef _debug_draw\n            // set size and palette of debug image\n            img.resize(xs,ys);\n            for (i=0;i<256;i++) img.rgb_pal[i]=pal[i];\n            // copy reference data to debug image\n            for (y=0;y<ys;y++) img.p[y].ref=\"\";\n            if ((png->Height)&&(png->Width))\n                {\n                Graphics::TBitmap *qqq=new Graphics::TBitmap;\n                qqq->Assign(png);\n                qqq->HandleType=bmDIB;\n                qqq->PixelFormat=pf32bit;\n                for (y=0;(y<qqq->Height)&&(y<ys);y++)\n                    {\n                    img.p[y].ref=\"\";\n                    img.p[y].cmp=\"\";\n                    p=(DWORD*)qqq->ScanLine[y];\n                    for (x=0;(x<qqq->Width)&&(x<xs);x++)\n                        {\n                        for (a=0,b=256,g=768;a<256;a++)\n                            {\n                            r=rgb_absdistance(p[x],pal[a]);\n                            if (g>r) { g=r; b=a; }\n                            } a=b;\n                        if (g) g='1'; else g='0';\n                        img.p[y].ref+=char(BYTE(a));\n                        img.p[y].cmp+=char(BYTE(g));\n                        }\n                    }\n                delete qqq;\n                }\n            // copy encoded data to debug image\n            for (y=0;y<ys;y++)\n                {\n                adr=dir[y];\n                img.p[y].adr=adr;\n                img.p[y].enc=\"\";\n                img.p[y].dec=\"\";\n                img.p[y].spc=\"\";\n                for (;adr<dir[y+1];adr++)\n                 img.p[y].enc+=char(BYTE(dat[adr]));\n                }\n            #endif\n\n            // image data (decoded)\n            a=dat[dir[0]];\n            mode=0; if (a!=0xFC) mode=1;\n            for (y=0;y<ys;y++)\n                {\n                adr=dir[y];                     // get actual ScanLine offset in file\n                p=(DWORD*)bmp->ScanLine[y];     // get actual ScanLine pointer in bmp\n                int _sequence=0;\n                int _pixel=0;\n                int _stop=0;\n                int seq=0;\n                for (x=0;x<xs;x++) p[x]=0; x=0;\n\n                if (mode==1)\n                    {\n                    // 1st ScanLine BYTE (x-offset)\n                    a=dat[adr]; adr++;\n                    if (BYTE(a&1)==1)\n                        {\n                        x=(a>>1)+1;\n                        #ifdef _debug_draw\n                        for (i=0;i<x;i++) img.p[y].spc+='\\0';\n                        #endif\n                        }\n                    // 2nd ScanLine BYTE special cases\n                    a=dat[adr];\n                    if (a==0x0D) adr++; \n                    }\n                for (a=0;adr<dir[y+1];)\n                    {\n                    if (mode==0)\n                        {\n                        a=dat[adr]; adr++;              // color index\n                        if (int(x&31)==0)\n                            {\n                            r=a;                        // flag\n                            a=dat[adr]; adr++;          // color index\n                            }\n                        }\n                    if (mode==1) for (;;)\n                        {\n                        a=dat[adr]; adr++;              // color index\n                        if (_pixel) { _pixel=false; break; }\n                        if (_sequence) { seq++; if (seq<6) break; }\n                        // commands\n                        if (a==0x01)\n                            {\n                            a=dat[adr]; adr++;\n                            _pixel=true; _sequence=false;\n                            //if (a==0x07) { adr++; _pixel=false; }\n                            continue;\n                            }\n                        if (a==0x03)\n                            {\n                            if (!_sequence)\n                                {\n                                if (dat[adr]==0x18) _pixel=1;\n                                continue;\n                                }\n                            if (_sequence==0x2B) break;\n                            a=dat[adr]; adr++;\n                            _pixel=true; _sequence=false;\n                            //if (a==0x07) { adr++; _pixel=false; }\n                            continue;\n                            }\n                        if (_sequence) break;\n                        // unused: 0A,14,1F,20,21,22,24,25,26,28,29,2A,2C+\n                        // flag/color prefix\n    //                  if((a==0x02)&&(adr>dir[y]+3)) { _stop=true; break; }    // end of ScanLine\n                        if (a==0x04) { _pixel=1; continue; }    // ?? ?p18 p47 ?p47\n                        if (a==0x05) { _pixel=1; continue; }    // ?? ?18 ?09\n                        if (a==0x06) { _pixel=1; continue; }    // ?? ?p18 ?p47\n                        if (a==0x07) { _pixel=1; continue; }    // ?? ?18 ?46 ?47\n                        if (a==0x08) { _pixel=1; continue; }    // ?? ?09\n                        if (a==0x09) { _pixel=0; continue; }    // ?? ?p02 !!!!!!!!!!!\n                        if (a==0x0B) { _pixel=1; continue; }    // ?? ?p02\n                        if (a==0x0C) { _pixel=1; continue; }    // OK p1D\n                        if (a==0x0D)                            // ?? c04 p23 ?c06 p05 p12\n                            {\n                            _pixel=0;\n                            if (dat[adr]==0x02) _pixel=1;\n                            if (dat[adr]==0x05) _pixel=1;   // p47 c0D p05 | c0D c05 p09\n                            if (dat[adr]==0x12) _pixel=1;\n                            if (dat[adr]==0x23) _pixel=1;\n                            continue;\n                            }\n                        if (a==0x0E) { _pixel=1; continue; }    // OK p24 p26 p16\n                        if (a==0x0F) { _pixel=1; continue; }    // OK p0F\n                        if (a==0x10) { _pixel=1; continue; }    // OK p04\n                        if (a==0x11) { _pixel=1; continue; }    // ?? ?p02\n                        if (a==0x12) { _pixel=1; continue; }    // OK p27\n                        if (a==0x15) { _pixel=1; continue; }    // OK p16\n                        if (a==0x16) { _pixel=1; continue; }    // OK p16\n                        if (a==0x18) { _pixel=1; continue; }    // OK p00 p02\n                        if (a==0x19)                            // ?? p1B\n                            {\n                            _pixel=1;\n                            if (dat[adr]==0x01) _pixel=0;\n                            continue;\n                            }\n                        if (a==0x1A) { _pixel=1; continue; }    // OK p05 p04\n                        if (a==0x1B) { _pixel=1; continue; }    // OK p1F\n                        if (a==0x1C) { _pixel=1; continue; }    // OK p10\n                        if (a==0x1D) { _pixel=1; continue; }    // OK p33 p1E p14\n                        if (a==0x1E) { _pixel=1; continue; }    // OK p34 p50 p13\n\n                        // test from dragon and mountain\n                        if (a==0x49) { _pixel=1; continue; }    // ?? ?p02\n                        if (a==0xE3) { _pixel=1; continue; }    // ?? p18\n                        if (a==0xD7) { _pixel=1; continue; }    // ?? pBC\n                        if (a==0xDA) { _pixel=1; continue; }    // ?? ?p02\n\n                        // sequence start\n                        if (a==0x13) { seq=0; _sequence=a; } // 03\n                        if (a==0x17) { seq=0; _sequence=a; } // 01\n                        if (a==0x23) { seq=0; _sequence=a; } // 01 03\n                        if (a==0x27) { seq=0; _sequence=a; } // 01\n                        if (a==0x2B) { seq=0; _sequence=a; } // 01 !03 03\n                        if (_sequence)\n                            {\n                            if (adr==dir[y]+3) { _sequence=false; break; }\n                            continue;\n                            }\n                        break;\n                        }\n                    if (_stop) break;\n                    if (x>xs) break;\n                    if ((mode==1)&&((a==0xFE)||(a==0xFF))) { a=dat[adr]; adr++; }   // shadows?\n\n                    if ((x>=0)&&(x<xs)) p[x]=pal[a]; x++;\n                    #ifdef _debug_draw\n                    // copy decoded data to debug image\n                    img.p[y].dec+=char(BYTE(a));\n                    #endif\n                    }\n                }\n            delete[] dir; dir=NULL;\n            #ifdef _debug_save\n            // save frames to bmp\n            s=frame;\n            while (s.Length()<3) s=\"0\"+s;\n            png->Assign(bmp);\n            png->SaveToFile(\"decoded_\"+fnam+\"_\"+s+\".png\");\n            #endif\n            }\n        img.compute();\n        break;\n        }\n    delete[] dat;\n    }\n\n```\n",
      "votes": "24",
      "user": "Community",
      "time": "May 23, 2017 at 12:37",
      "is_accepted": false,
      "comments": [
        {
          "user": "Igor Skochinsky",
          "text": "The comments have been moved to chat; please do not use comments for extended discussions.",
          "time": null
        }
      ]
    }
  ]
}