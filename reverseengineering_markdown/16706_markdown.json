{
  "title": "What causes the need for NOP sleds?",
  "link": "https://reverseengineering.stackexchange.com/questions/16706/what-causes-the-need-for-nop-sleds",
  "content": "So when taking a simple scenario and exploiting a stack buffer overflow in which I can execute code on the stack, my payload simply is:\n\n```\nNOP Sled -> Shellcode -> Padding -> New RET Address (Pointing to the NOP Sled)\n\n```\nWhat I get is that we need to have a memory address included in the shellcode which points somewhere into the NOP Sled, which we need because we \"can't be sure\" what the return address is.\n\nWhy can't we be sure?\n\nCould it be simple things such as argv[0] being different, eg. on one system the file might be \"/vuln\" and on another \"/home/user/vuln\" and for this reason the stack is already different?\nDo environment Variables play a role? What else is involved?\n\nBasically my question is: Which factors lead to the stack being different every time we execute / executing the vuln program on another machine?\n\n",
  "votes": "14",
  "answers": 2,
  "views": "4k",
  "tags": [
    "memory",
    "buffer-overflow",
    "security"
  ],
  "user": "L. Heldt",
  "time": "Nov 4, 2017 at 12:57",
  "comments": [],
  "answers_data": [
    {
      "content": "On modern systems the most obvious culprit is probably address space layout randomization, but stack frame layout variablity was problematic for exploit development even before ASLR became widely implemented. This was alluded to in AlephOne's venerable \"Smashing the Stack for Fun and Profit\":\n\nSo this is an issue even without ASLR enabled. Reasons for this involve the following (as far as I know):\n\nInterestingly, the code that manages the runtime stack is generated by the compiler and the compiler cannot know what the absolute positions of stack frames during program runtime will be:\n\nThe way in which memory is allocated and deallocated for stack frames can vary across compilers, as well as different versions of the same compiler toolchain. Why this might be the case is alluded to in the System V i386 Architecture Processor Supplement (page 36):\n\nHere is how all of this ties together:\n\nIn sum, the offset between the buffer being overflowed and the target return address location can vary based on compiler toolchain (GCC, TCC, MSVC, etc), compiler version (3.x, 4.x etc) and the particular options used to compile the binary (alignment value, optimization level, stack protection, etc):\n\nIt has been suggested elsewhere that stack layout indeterminicy can be caused by environmental variables and program arguments:\n\nThis makes sense if we look at how the stack is laid out in virtual memory:\n\n\nIf there are differences across executions in the environment or arguments, the location of the base of the stack may change as well.\n\nTo show that this is not simply idle speculation, we can look at a concrete example. First, we disable ASLR like so:\n\necho 0 | sudo tee /proc/sys/kernel/randomize_va_space\n\nThen we write a quick program in C:\n\n```\n#include <stdio.h>\n\nint test(int a, int b)\n{\n        printf(\"%p  \n\", &a);\n        return a*a + b*b;\n}\n\nint main(void)\n{\n        return test(3, 5);\n}\n\n```\nWhen compiled and then run a few times with steadily increasing argument lengths, it is observed that the position on the stack of one of the local variables changes to lower and lower in virtual memory:\n\n```\n$ gcc -m32 simple.c -o simple\n$ ./simple \n0xffffd210\n$ ./simple AAAAAAAA\n0xffffd200\n$ ./simple AAAAAAAAAAAAAAAA\n0xffffd200\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1f0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1f0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1e0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1e0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1d0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1d0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1c0\n\n```\nThis indicates that changing the sizes of the arguments passed to execve also changes the position of the runtime stack in virtual memory. The weakness of this extremely trivial example is that it does not accurately reflect the complexity of real-world programs or capture how the runtime stack changes throughout execution of more complex processes. \n\nAn additional variable influencing the layout of the runtime stack is whether the binary is dynamically linked or not. If it is dynamically linked, process startup is handled by glibc. On x86 Linux systems the C runtime library function call sequence looks similar to this: \n\n\nThis will depend on what version of glibc the binary is linked against, and the runtime environment will vary across machines. This means that the function call sequence during process startup will vary across systems as well.\n\nSee also:\n\n1. Scott, Michael L. Programming Language Pragmatics. 3rd ed. Page 117\n\n2. Bryant, O'Hallaron. Computer Systems: A Programmer's Perspective. 2nd ed. Page 220\n\n3. Erickson, Jon. Hacking: The Art of Exploitation. 2nd ed. Page 136\n\n",
      "votes": "11",
      "user": "julian",
      "time": "Nov 5, 2017 at 23:16",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "As you mentioned, many things can leave you with a different memory layout than the one you expect: \n\nUsing hardcoded addresses pointing to the stack as the address that will be taken by EIP is the wrong approach. That's how it was done in the early days. Sketchy approach and no DEP/NX in place.\n\nA more stable approach is that instead of jumping to the middle of the stack, you can directly jump to code that will get executed. There are different techniques to do so such as return-to-libc/library or ROP.\n\nAnother simpler approach is checking where your registers point in the moment when the overflow happens (actually, when the segfault is triggered). Imagine that ESP points to 0x12345678. If you have control of the contents of 0x12345678 at the moment of the segfault in a stable way, you can just use the address of a JMP ESP-kind instruction as what will be taken by EIP.\n\nBecause you are certain that the binary itself or the libraries that get loaded (therefore, their instructions) when the binary is executed will always be stored in the same address. (1) \n\nLong story short, the motto goes by... \"If your exploit contains NOPs, you are doing something wrong!\". \n\nTo answer the question in your title, there is no need for NOP sleds.\n\n",
      "votes": "1",
      "user": "newlog",
      "time": "Nov 4, 2017 at 17:21",
      "is_accepted": false,
      "comments": []
    }
  ]
}