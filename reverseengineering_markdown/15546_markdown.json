{
  "title": "ptrace TRACE_PEEKER: Input/output error accessing virtual address contents when traced file is a shared object file",
  "link": "https://reverseengineering.stackexchange.com/questions/15546/ptrace-trace-peeker-input-output-error-accessing-virtual-address-contents-when",
  "content": "I'm using updated Kali and compiling this for 64- bit\n\nWorking through Learning Linux Binary Analysis,'simple ptrace-based debugger' on page 57.\n\nSource code and testfile to debug included.\n\nProblem is accessing the return value of lookup_symbol from the shared object file 'test'.\n\nRegarding the given program:\nThe only thing I've changed is the error check that checks for ET_EXEC, I changed it to ET_DYN so that I can try to trace shared object files, which seem unavoidable when I import stdio.h for the print function. Also, changed the part that checks for ELF files, used use: \n\nThe work of the parent program is done in the lookup_symbol function which searches for the symbol name in the string table and returns the symbol table st_value (the virtual address) of the desired symbol.\n\nFrom TIS ELF Specification \n\nTo search for print_string in 'test':\n\nThe goal is to break at each print_string call and print the registers at that point, then any key can be pressed to continue execution.\n\nWhen running the source code the lookup_symbol function returns 0x6b0 on my comp for the value of symtab->st_value and assigns it to h.symaddr.\n\n0x6b0 is the virtual address (value of) of print_string in the symbol table, confirmed by checking readelf \n\nThe original from the book uses 0x6b0 directly in the following function:\n\nThis function fails with an error on my computer when it attempts to use h.symaddr=0x6b0:\n\n```\nBeginning analysis of pid: 2462 at 6b0\nPTRACE_PEEKER: Input/output error\nhello 1\nhello 2\n\n```\nThe problem is not that it's a virtual address being returned, because as quoted above, both executables and shared object files contain virtual addresses in symbol_table->st_value. I'm not sure why but there is a difference in how this ptracing parent program treats shared objects and executables.\n\nThis is the test file:\n\n```\n#include <stdio.h>\n\nvoid print_string(char * str)\n{\n    printf(\"%s  \n\", str); \n}\n\nint main(int argc, char ** argv)\n{\n    print_string(\"hello 1\");\n    print_string(\"hello 2\");\n    return 0;\n}\n\n```\nThis is the source file:    \n\n```\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <elf.h>\n#include <sys/types.h>\n#include <sys/user.h>\n#include <sys/stat.h>\n#include <sys/ptrace.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n\n\n\n\ntypedef struct handle\n{\n    Elf64_Ehdr *ehdr;\n    Elf64_Phdr *phdr;\n    Elf64_Shdr *shdr;\n    uint8_t *mem;\n    char *symname;\n    Elf64_Addr symaddr;\n    struct user_regs_struct pt_reg;\n    char *exec;\n} handle_t;\n\nElf64_Addr lookup_symbol(handle_t *, const char *);\n\n\n\nint main(int argc, char **argv, char **envp)\n{\n\n    int fd;\n    handle_t h;\n    struct stat st;\n    long trap, orig;\n    int status, pid;\n    char * args[2]; \n\n    if (argc < 3)\n    {\n        printf(\"Usage: %s <program> <function>  \n\", argv[0]);\n        exit(0);\n    }\n\n\n    if ((h.exec = strdup(argv[1])) == NULL)\n    {\n        perror(\"strdup\"); exit(-1);\n    }\n\n    args[0] = h.exec;\n\n    args[1] = NULL;\n\n    if ((h.symname = strdup(argv[2])) == NULL)\n    {\n        perror(\"strdup\");\n        exit(-1);\n    }\n\n    if ((fd = open(argv[1], O_RDONLY)) < 0)\n    {\n        perror(\"open\");\n        exit(-1);\n    }\n\n    if (fstat(fd, &st) < 0) \n    {\n        perror(\"fstat\");\n        exit(-1);\n    }\n\n    h.mem = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\n    if (h.mem == MAP_FAILED)\n    {\n        perror(\"mmap\");\n        exit(-1);\n    }\n\n\n    h.ehdr = (Elf64_Ehdr *)h.mem;\n\n    h.phdr = (Elf64_Phdr *)(h.mem + h.ehdr->e_phoff);\n\n    h.shdr = (Elf64_Shdr *)(h.mem + h.ehdr->e_shoff);\n\n    if (h.mem[0] != 0x7f)\n    {\n        printf(\"%s is not an ELF file  \n\", h.exec);\n        exit(-1);\n    }\n\n    if (h.ehdr->e_type != ET_DYN)\n    {\n        printf(\"%s is not an ELF dynamic  \n\", h.exec);\n        exit(-1);\n    }\n\n    if (h.ehdr->e_shstrndx == 0 || h.ehdr->e_shoff == 0 || h.ehdr->e_shnum == 0)\n    {\n        printf(\"Section header table not found  \n\");\n        exit(-1);\n    }\n\n    if ((h.symaddr = lookup_symbol(&h, h.symname)) == 0)\n    {\n        printf(\"Unable to find symbol: %s not found in executable  \n\", h.symname);\n        exit(-1);\n    }\n\n    close(fd);  \n\n    if ((pid = fork()) < 0)\n    {\n        perror(\"fork\");\n        exit(-1);\n    }\n\n    if (pid == 0)\n    {\n\n        if (ptrace(PTRACE_TRACEME, pid, NULL, NULL) < 0)\n        {\n            perror(\"PTRACE_TRACEME\");\n            exit(-1);\n        }\n\n        execve(h.exec, args, envp);\n        exit(0);\n    }\n\n    wait(&status);\n    printf(\"Beginning analysis of pid: %d at %lx  \n\", pid, h.symaddr);\n\n\n    if ((orig = ptrace(PTRACE_PEEKTEXT, pid, h.symaddr, NULL)) < 0)\n    {\n        perror(\"PTRACE_PEEKER\");\n        exit(-1);\n    }\n    trap = (orig & ~0xff | 0xcc);\n\n\n    printf(\"Made it here\");\n\n\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) < 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\ntrace:\n\n    if (ptrace(PTRACE_CONT, pid, NULL, NULL) < 0)\n    {\n        perror(\"PTRACE_CONT\");\n        exit(-1);\n    }\n    wait(&status);\n\n\n    if (WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP)\n    {\n        if (ptrace(PTRACE_GETREGS, pid, NULL, &h.pt_reg) < 0)\n        {\n            perror(\"PTRACE_GETREGS\");\n            exit(-1);\n        }\n\n        printf(\"  \nExecutable %s (pid: %d) has hit breakpoint 0x%lx  \n\", h.exec, pid, h.symaddr);\n\n    printf(\"%%rcx: %llx  \n%%rdx: %llx  \n%%rbx: %llx  \n\" \n                \"%%rax: %llx  \n%%rdi: %llx  \n%%rsi: %llx  \n\" \n                \"%%r8: %llx  \n%%r9: %llx  \n%%r10: %llx  \n%%\" \n                \"%%r11: %llx  \n%%r12: %llx  \n%%r13: %llx  \n%%\" \n                \"%%r14: %llx  \n%%r15: %llx  \n%%rsp: %llx  \n%%\");\n    printf(\"  \nHit any key to continue: \");\n    getchar();\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, orig) < 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\n\n    h.pt_reg.rip = h.pt_reg.rip - 1;\n    if (ptrace(PTRACE_SETREGS, pid, NULL, &h.pt_reg) < 0)\n    {\n        perror(\"PTRACE_SETREGS\");\n        exit(-1);\n    }\n\n    if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) < 0)\n    {\n        perror(\"PTRACE_SINGLESTEP\");\n        exit(-1);\n    }\n    wait(NULL);\n\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) < 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\n\n    goto trace;\n    }\n\n    if (WIFEXITED(status)) \n        printf(\"Completed tracing pid: %d  \n\", pid);\n\n    exit(0);\n}\n\n\n\n\n    Elf64_Addr lookup_symbol(handle_t *h, const char *symname)\n    {\n        int i, j;\n        char *strtab;\n        Elf64_Sym *symtab;\n        for (i = 0; i < h->ehdr->e_shnum; i++)      \n        {\n            if (h->shdr[i].sh_type == SHT_SYMTAB)   \n            {\n                strtab = (char *)&h->mem[h->shdr[h->shdr[i].sh_link].sh_offset];\n\n                symtab = (Elf64_Sym *)&h->mem[h->shdr[i].sh_offset];\n\n\n                for (j = 0; j < h->shdr[i].sh_size/sizeof(Elf64_Sym); j++)\n                {\n                    if (strcmp(&strtab[symtab->st_name], symname) == 0)\n                        //printf(\"symtab->st_value is 0x%lx  \n\", symtab->st_value);  \n                        return (symtab->st_value);\n                    symtab++;\n                }\n            }\n        }\n        return 0;\n    }\n\n```\n",
  "votes": "2",
  "answers": 2,
  "views": "2k",
  "tags": [
    "elf"
  ],
  "user": "flerb",
  "time": "Jun 21, 2017 at 16:34",
  "comments": [],
  "answers_data": [
    {
      "content": "The problem is that when I compile test.c with gcc, gcc creates a shared object file. \n\nThis is the case with even the simplest of programs:\n    //simplereturn.c\n    int main(void)\n    {\n        return 22;\n    }\n\nfrom readelf:\n\n```\nType:                              DYN (Shared object file)\n\n```\nWhen I try to parse this with tracer, previously I had changed the error-checking section that ensured that the file that I'm parsing with ptrace is ET_EXEC (an executable file). I changed it so it checked if the traced file was ET_DYN (shared object file). \n\nDoing this allowed the error-check to pass for the simple C programs that I wanted to trace, but had unexpected (at least for me) consequences. When lookup_symbol was returning it was in fact returning a virtual address (0x6b0), which agrees with the symbol table of the readelf, and the function address in objdump -D. Can even check it in gdb. However, interestingly, a break at print_string is placed at 0x6bc, while the start of the print_string function is at 0x6b0. Probably not irrelevant.\n\nAfter a lot of research and struggle, the problem was an easy fix. \n\nI created an executable instead of a shared object file. The requisite as far as I can tell is that it uses no external libraries or functions, or I guess probably that it's self-contained. Either way, gcc won't make them.\n\n```\n;test.asm\nsection .text\n    global _start\n\n_start:\n    mov rsi, hello1\n    call print_string\n    mov rsi, hello2\n    call print_string\n\n    xor rdi,rdi\n    mov rax, 60\n    syscall\n\nprint_string:\n    mov rax, 1\n    mov rdi, 1\n    mov rdx, 6\n    syscall\n    ret\n\nsection .data\n    hello1 db \"Hello1\"\n    hello2 db \"Hello2\"\n\n```\nCompiled with nasm -g -f elf64 test.asm && ld -m elf_x86_64 -o testasm testasm.o\n\nNow readelf -a testasm confirms that it's an executable \n\n```\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n Type:                              EXEC (Executable file) //EXEC NOW\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x4000b0\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          616 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         2\n  Size of section headers:           64 (bytes)\n  Number of section headers:         6\n  Section header string table index: 5\n\n```\nAnd I switched the error checking in the original back:\n\n```\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <elf.h>\n#include <sys/types.h>\n#include <sys/user.h>\n#include <sys/stat.h>\n#include <sys/ptrace.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n\n\ntypedef struct handle\n{\n    Elf64_Ehdr *ehdr;\n    Elf64_Phdr *phdr;\n    Elf64_Shdr *shdr;\n    uint8_t *mem;\n    char *symname;\n    Elf64_Addr symaddr;\n    struct user_regs_struct pt_reg;\n    char *exec;\n} handle_t;\n\nElf64_Addr lookup_symbol(handle_t *, const char *);\n\nint main(int argc, char **argv, char **envp)\n{\n    int fd;\n    handle_t h;\n    struct stat st;\n    long trap, orig;\n    int status, pid;\n    char * args[2];\n\n    if (argc < 3)\n    {\n        printf(\"Usage: %s <program> <function>  \n\", argv[0]);\n        exit(0);\n    }\n\n    if ((h.exec = strdup(argv[1])) == NULL)\n    {\n        perror(\"strdup\"); exit(-1);\n    }\n\n    args[0] = h.exec;\n\n    args[1] = NULL;\n\n    if ((h.symname = strdup(argv[2])) == NULL)\n    {\n        perror(\"strdup\");\n        exit(-1);\n    }\n\n    if ((fd = open(argv[1], O_RDONLY)) < 0)\n    {\n        perror(\"open\");\n        exit(-1);\n    }\n\n    if (fstat(fd, &st) < 0) \n    {\n        perror(\"fstat\");\n        exit(-1);\n    }\n\n\n    h.mem = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\n\n    if (h.mem == MAP_FAILED)\n    {\n        perror(\"mmap\");\n        exit(-1);\n    }\n\n\n    h.ehdr = (Elf64_Ehdr *)h.mem;\n\n    h.phdr = (Elf64_Phdr *)(h.mem + h.ehdr->e_phoff);\n\n    h.shdr = (Elf64_Shdr *)(h.mem + h.ehdr->e_shoff);\n\n    if ((h.mem[0] != 0x7f) || strcmp((char *)&h.mem[1], \"ELF\\002\\001\\001\"))\n    {\n        printf(\"%s is not an ELF file  \n\", h.exec);\n        exit(-1);\n    }\n\n    if (h.ehdr->e_type != ET_EXEC) \n    {\n        printf(\"%s is not an ELF executable  \n\", h.exec);\n        exit(-1);\n    }\n\n\n    if (h.ehdr->e_shstrndx == 0 || h.ehdr->e_shoff == 0 || h.ehdr->e_shnum == 0)\n    {\n        printf(\"Section header table not found  \n\");\n        exit(-1);\n    }\n\n    if ((h.symaddr = lookup_symbol(&h, h.symname)) == 0)\n    {\n        printf(\"Unable to find symbol: %s not found in executable  \n\", h.symname);\n        exit(-1);\n    }\n\n\n    close(fd);  \n\n\n    if ((pid = fork()) < 0)\n    {\n        perror(\"fork\");\n        exit(-1);\n    }\n\n    if (pid == 0)\n    {\n        if (ptrace(PTRACE_TRACEME, pid, NULL, NULL) < 0)\n        {\n            perror(\"PTRACE_TRACEME\");\n            exit(-1);\n        }\n        execve(h.exec, args, envp);\n        exit(0);\n    }\n\n\n\n\n    wait(&status);\n    printf(\"Beginning analysis of pid: %d at %lx  \n\", pid, h.symaddr);\n\n    if ((orig = ptrace(PTRACE_PEEKTEXT, pid, h.symaddr, (void *)0)) < 0)\n    {\n        perror(\"PTRACE_PEEKER\");\n        exit(-1);\n    }\n    trap = (orig & ~0xff | 0xcc);\n\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) < 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\ntrace:\n    if (ptrace(PTRACE_CONT, pid, NULL, NULL) < 0)\n    {\n        perror(\"PTRACE_CONT\");\n        exit(-1);\n    }\n    wait(&status);\n\n    if (WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP)\n    {\n        if (ptrace(PTRACE_GETREGS, pid, NULL, &h.pt_reg) < 0)\n        {\n            perror(\"PTRACE_GETREGS\");\n            exit(-1);\n        }\n\n        printf(\"  \nExecutable %s (pid: %d) has hit breakpoint 0x%lx  \n\", h.exec, pid, h.symaddr);\n\n    printf(\"%%rcx: %llx  \n%%rdx: %llx  \n%%rbx: %llx  \n\" \n                \"%%rax: %llx  \n%%rdi: %llx  \n%%rsi: %llx  \n\" \n                \"%%r8: %llx  \n%%r9: %llx  \n%%r10: %llx  \n%%\" \n                \"%%r11: %llx  \n%%r12: %llx  \n%%r13: %llx  \n%%\" \n                \"%%r14: %llx  \n%%r15: %llx  \n%%rsp: %llx  \n%%\");\n    printf(\"  \nHit any key to continue: \");\n    getchar();\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, orig) < 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\n\n    h.pt_reg.rip = h.pt_reg.rip - 1;\n\n    if (ptrace(PTRACE_SETREGS, pid, NULL, &h.pt_reg) < 0)\n    {\n        perror(\"PTRACE_SETREGS\");\n        exit(-1);\n    }\n\n    if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) < 0)\n    {\n        perror(\"PTRACE_SINGLESTEP\");\n        exit(-1);\n    }\n    wait(NULL);\n\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) < 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\n\n    goto trace;\n    }\n\n    if (WIFEXITED(status)) \n        printf(\"Completed tracing pid: %d  \n\", pid);\n\n    exit(0);\n}\n\n\n\n\n    Elf64_Addr lookup_symbol(handle_t *h, const char *symname)\n    {\n        int i, j;\n        char *strtab;\n        Elf64_Sym *symtab;\n        for (i = 0; i < h->ehdr->e_shnum; i++)  \n        {\n            if (h->shdr[i].sh_type == SHT_SYMTAB)\n            {\n                strtab = (char *)&h->mem[h->shdr[h->shdr[i].sh_link].sh_offset];\n\n                symtab = (Elf64_Sym *)&h->mem[h->shdr[i].sh_offset];\n\n                for (j = 0; j < h->shdr[i].sh_size/sizeof(Elf64_Sym); j++)\n                {\n                    if (strcmp(&strtab[symtab->st_name], symname) == 0)\n                        return (symtab->st_value);\n                    symtab++;\n                }\n            }\n        }\n        return 0;\n    }\n\n```\nAnd now when run it it works\n$ ./tracer ./testasm print_string\n\n```\nBeginning analysis of pid: 5378 at 4000d8\n\nExecutable ./testasm (pid: 5378) has hit breakpoint 0x4000d8\n%rcx: 564ed7b07050\n%rdx: 7fb9525a9760\n%rbx: 7fffffc2\n%rax: 1\n%rdi: 3e\n%rsi: 1958ac0\n%r8: 7ffcd2b98848\n%r9: 7ffcd2b98828\n%r10: 3d2bea1a8\n%%r11: 564ed7b07010\n%r12: 0\n%r13: 7fb9527d2728\n%%r14: 57f00000001\n%r15: 801\n%rsp: 203bec\n%\nHit any key to continue: \nHello1\nExecutable ./testasm (pid: 5378) has hit breakpoint 0x4000d8\n%rcx: 564ed7b07050\n%rdx: 7fb9525a9760\n%rbx: 7fffffc2\n%rax: 1\n%rdi: 3e\n%rsi: 1958ac0\n%r8: 7ffcd2b98848\n%r9: 7ffcd2b98828\n%r10: 3d2bea1a8\n%%r11: 564ed7b07010\n%r12: 0\n%r13: 7fb9527d2728\n%%r14: 57f00000001\n%r15: 801\n%rsp: 203bec\n%\nHit any key to continue: \nHello2Completed tracing pid: 5378\n\n```\nchecking gdb and readelf\nLookup symbol returns value at 0x4000d8, as the symbol table from readelf -a testasm says it should:\n\n```\nSymbol table '.symtab' contains 11 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 00000000004000b0     0 SECTION LOCAL  DEFAULT    1 \n     2: 00000000006000ec     0 SECTION LOCAL  DEFAULT    2 \n     3: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test.asm\n     4: 00000000004000d8     0 NOTYPE  LOCAL  DEFAULT    1 print_string\n     5: 00000000006000ec     0 NOTYPE  LOCAL  DEFAULT    2 hello1\n     6: 00000000006000f2     0 NOTYPE  LOCAL  DEFAULT    2 hello2\n     7: 00000000004000b0     0 NOTYPE  GLOBAL DEFAULT    1 _start\n     8: 00000000006000f8     0 NOTYPE  GLOBAL DEFAULT    2 __bss_start\n     9: 00000000006000f8     0 NOTYPE  GLOBAL DEFAULT    2 _edata\n    10: 00000000006000f8     0 NOTYPE  GLOBAL DEFAULT    2 _end\n\n```\nSo the differences between tracing an executable or shared object file in this case were what broke it.\n\n",
      "votes": "1",
      "user": "flerb",
      "time": "Jun 21, 2017 at 16:47",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "You can build without dynamic linking like this:\n\n```\ngcc -static -o test test.c\n\n```\nThen it'll create DT_EXEC type executable not DT_DYN.\n\n",
      "votes": "0",
      "user": "wonbear",
      "time": "Dec 28, 2022 at 6:32",
      "is_accepted": false,
      "comments": []
    }
  ]
}