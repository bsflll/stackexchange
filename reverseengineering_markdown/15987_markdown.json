{
  "title": "IDA Pro - Stack variable only used in one place?",
  "link": "https://reverseengineering.stackexchange.com/questions/15987/ida-pro-stack-variable-only-used-in-one-place",
  "content": "I am working on reverse engineering an algorithm and I am using IDA. This is how the stack definition looks:\n\n```\nvar_41E= word ptr -41Eh\ns= byte ptr -412h\nvar_401= byte ptr -401h (v23)\nvar_400= byte ptr -400h (v22)- IDA shows as db 835\nvar_BD= word ptr -0BDh\nvar_13= byte ptr -13h (v25)\nvar_12= byte ptr -12h\nvar_11= byte ptr -11h\nvar_10= byte ptr -10h\nvar_F= byte ptr -0Fh\nvar_E= byte ptr -0Eh\nvar_D= byte ptr -0Dh\narg_0= dword ptr  8\ndest= dword ptr  0Ch\narg_8= dword ptr  10h\n\n```\nThere is this code block:\n\n```\nloc_1B41AA:\nmov     al, [ebp+edx+var_12]\nxor     [ebp+edx+var_400], al\ninc     edx\ncmp     edx, 4\njnz     short loc_1B41AA\n\n```\nWhich translates to:\n\n```\ndo\n{\n  v23[v11] ^= *(&v26 + v11);\n  ++v11;\n}\nwhile ( v11 != 4 );\n\n```\nThe problem I'm having is, this v23 is never used. I was thinking perhaps this is a pointer to another spot in memory, but I'm unable to find this.\n\nThe next section of code reads:\n\n```\ndo\n{\n  *(&v25 + v11) ^= *(&v22 + v11);\n  ++v11;\n}\nwhile ( v11 != 5 );\n\n```\nWhich again, v22 is never used anywhere else. Nor is v25. \n\nI feel like I'm missing something obvious. I have been able to reversed previous formula's so I just don't understand why this seems to allude me. I was thinking maybe this is some trash code to throw people off, but I'm not sure because I've replicated the rest of the process and the results aren't right. If I need to provide additional information, let me know. \n\nHere is the entire code block for better reference:\nv9 is a 8 byte buffer. byte 0 is not used by the algorithm. I see \"*(&v25 + v11) ^= *(&v22 + v11)\" which seems like it could be altering this array? I suck at stack related things...\n\n```\nv26 = *(_BYTE *)(v9 + 1) ^ 0x42;\nv27 = *(_BYTE *)(v9 + 2) ^ 0x4F;\nv28 = *(_BYTE *)(v9 + 3) ^ 0x4C;\nv29 = *(_BYTE *)(v9 + 4) ^ 0x37;\nv30 = *(_BYTE *)(v9 + 5) ^ 0x37;\nv10 = *(_BYTE *)(v9 + 6);\nv11 = 0;\nv31 = v10 ^ 0x36;\ndo\n{\n  v23[v11] ^= *(&v26 + v11);\n  ++v11;\n}\nwhile ( v11 != 4 );\nLOBYTE(v11) = 1;\ndo\n{\n  *(&v25 + v11) ^= *(&v22 + v11);\n  ++v11;\n}\nwhile ( v11 != 5 );\n\n\n\n.text:001B4166                 mov     esi, [ebp+arg_0]\n.text:001B4169                 mov     edx, [esi+120h]\n.text:001B416F                 add     esp, 10h\n.text:001B4172                 mov     al, [edx+1]\n.text:001B4175                 xor     eax, 42h\n.text:001B4178                 mov     [ebp+var_12], al\n.text:001B417B                 mov     al, [edx+2]\n.text:001B417E                 xor     eax, 4Fh\n.text:001B4181                 mov     [ebp+var_11], al\n.text:001B4184                 mov     al, [edx+3]\n.text:001B4187                 xor     eax, 4Ch\n.text:001B418A                 mov     [ebp+var_10], al\n.text:001B418D                 mov     al, [edx+4]\n.text:001B4190                 xor     eax, 37h\n.text:001B4193                 mov     [ebp+var_F], al\n.text:001B4196                 mov     al, [edx+5]\n.text:001B4199                 xor     eax, 37h\n.text:001B419C                 mov     [ebp+var_E], al\n.text:001B419F                 mov     al, [edx+6]\n.text:001B41A2                 xor     edx, edx\n.text:001B41A4                 xor     eax, 36h\n.text:001B41A7                 mov     [ebp+var_D], al\n.text:001B41AA\n.text:001B41AA loc_1B41AA:                             ; CODE XREF: USBIO::ReadDS1995KeyData(uchar *,ushort)+243j\n.text:001B41AA                 mov     al, [ebp+edx+var_12]\n.text:001B41AE                 xor     [ebp+edx+var_400], al\n.text:001B41B5                 inc     edx\n.text:001B41B6                 cmp     edx, 4\n.text:001B41B9                 jnz     short loc_1B41AA\n.text:001B41BB                 mov     dl, 1\n.text:001B41BD\n.text:001B41BD loc_1B41BD:                             ; CODE XREF: USBIO::ReadDS1995KeyData(uchar *,ushort)+256j\n.text:001B41BD                 mov     al, [ebp+edx+var_401]\n.text:001B41C4                 xor     [ebp+edx+var_13], al\n.text:001B41C8                 inc     edx\n.text:001B41C9                 cmp     edx, 5\n.text:001B41CC                 jnz     short loc_1B41BD\n.text:001B41CE                 xor     ecx, ecx\n.text:001B41D0\n.text:001B41D0 loc_1B41D0:                             ; CODE XREF: USBIO::ReadDS1995KeyData(uchar *,ushort)+283j\n.text:001B41D0                 cmp     ecx, 11h\n.text:001B41D3                 jbe     short loc_1B41DA\n.text:001B41D5                 cmp     ecx, 15h\n.text:001B41D8                 jbe     short loc_1B41F2\n.text:001B41DA\n.text:001B41DA loc_1B41DA:                             ; CODE XREF: USBIO::ReadDS1995KeyData(uchar *,ushort)+25Dj\n.text:001B41DA                 mov     edx, 6\n.text:001B41DF                 mov     eax, ecx\n.text:001B41E1                 mov     esi, edx\n.text:001B41E3                 xor     edx, edx\n.text:001B41E5                 div     esi\n.text:001B41E7                 mov     al, [ebp+edx+var_12]\n.text:001B41EB                 xor     [ebp+ecx+s], al\n.text:001B41F2\n.text:001B41F2 loc_1B41F2:                             ; CODE XREF: USBIO::ReadDS1995KeyData(uchar *,ushort)+262j\n.text:001B41F2                 inc     ecx\n.text:001B41F3                 cmp     ecx, 400h\n.text:001B41F9                 jnz     short loc_1B41D0\n.text:001B41FB                 xor     esi, esi\n.text:001B41FD                 lea     ecx, [ebp+s]\n.text:001B4203                 xor     edx, edx\n\n```\n",
  "votes": "0",
  "answers": 1,
  "views": "565",
  "tags": [
    "ida"
  ],
  "user": "Thomas",
  "time": "Aug 4, 2017 at 9:30",
  "comments": [
    {
      "user": "blabb",
      "text": "possibility of getting an answer may increase if you can edit in the actual assembly instructions",
      "time": null
    },
    {
      "user": "Thomas",
      "text": "@blabb full assembly added for the code segment.",
      "time": null
    },
    {
      "user": "Thomas",
      "text": "@blabb I rewrote the issue in an attempt to clear up what I'm asking. I feel like you're answer is close but I'm missing something suttle.",
      "time": null
    },
    {
      "user": "Igor Skochinsky",
      "text": "I've rolled back the edit because the accepted answer did not match the question anymore. Please ask a new question instead, and include all relevant assembly for the pseudocode, including calls and pushes.",
      "time": null
    },
    {
      "user": "Thomas",
      "text": "@IgorSkochinsky Believe it or not, it was the same question as the answer was the same. The stack was not right. i needed to adjust the stack for v34 to be part of v33. It was like byte 8 in the array:).",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "that code is referencing a byte pointer inside a structure  you need to define a structure in ida assign it members (it references 120 so your structure size should be > 120)  and then define the bytepointer member and re analyze your program ida should now provide a better pseudo code \n\nhere is a small c code that could generate the code in assembly and its ida counter part posted as demo\n\nsrc code as follows compiled and linked with vs 2015 \n\n```\n#include <stdio.h>\n#include <windows.h>\ntypedef struct _MYSTRUCT {\n    DWORD memberone[72];\n    PCHAR  membertwo;\n}Mystruct , *PMystruct;\nvoid docall(PMystruct argone) {\n    char zo[8];\n// disassembly refers to 2 byte in the string passed by addr @(edx+1)   \n    zo[0] = argone->membertwo[1] ^ 13;\n    zo[1] = argone->membertwo[2] ^ 37;\n    zo[2] = argone->membertwo[3] ^ 94;\n    zo[3] = argone->membertwo[4] ^ 94; \n    zo[4] = argone->membertwo[5] ^ 13;\n    zo[5] = argone->membertwo[6] ^ 37;\n    zo[6] = argone->membertwo[7] ^ 94;\n    zo[7] = argone->membertwo[8] ^ 94;\n        for(int i =0; i<8;i++)\n        {\n            printf (\"%c\",zo[i]);\n        }\n}\nint main(void) {\n    Mystruct teststruct;\n    PCHAR mystr = \"Oe@22e@22\";\n    teststruct.membertwo = mystr;\n    docall(&teststruct);\n    return 0;\n}\n\n```\nyou can observe a striking similarity to the disassembly you edited in \n\n```\n.text:00401001 ; int __cdecl docall(Mystruct *argone)\n.text:00401001 docall          proc near               ; CODE XREF: main+17p\n.text:00401001\n.text:00401001 var_C           = byte ptr -0Ch\n.text:00401001 var_4           = dword ptr -4\n.text:00401001 argone          = dword ptr  8\n.text:00401001\n.text:00401001                 push    ebp\n.text:00401002                 mov     ebp, esp\n.text:00401004                 sub     esp, 0Ch\n.text:00401007                 mov     eax, __security_cookie\n.text:0040100C                 xor     eax, ebp\n.text:0040100E                 mov     [ebp+var_4], eax\n.text:00401011                 mov     eax, [ebp+argone]\n.text:00401014                 push    esi\n.text:00401015                 mov     ecx, [eax+Mystruct.membertwo]\n.text:0040101B                 mov     al, [ecx+1]\n.text:0040101E                 xor     al, 0Dh\n.text:00401020                 mov     [ebp+var_C], al\n.text:00401023                 mov     al, [ecx+2]\n.text:00401026                 xor     al, 25h\n.text:00401028                 mov     [ebp+var_C+1], al\n.text:0040102B                 mov     al, [ecx+3]\n.text:0040102E                 xor     al, 5Eh\n.text:00401030                 mov     [ebp+var_C+2], al\n.text:00401033                 mov     al, [ecx+4]\n.text:00401036                 xor     al, 5Eh\n.text:00401038                 mov     [ebp+var_C+3], al\n.text:0040103B                 mov     al, [ecx+5]\n.text:0040103E                 xor     al, 0Dh\n.text:00401040                 mov     [ebp+var_C+4], al\n.text:00401043                 mov     al, [ecx+6]\n.text:00401046                 xor     al, 25h\n.text:00401048                 mov     [ebp+var_C+5], al\n.text:0040104B                 mov     al, [ecx+7]\n.text:0040104E                 xor     al, 5Eh\n.text:00401050                 mov     [ebp+var_C+6], al\n.text:00401053                 mov     al, [ecx+8]\n.text:00401056                 xor     al, 5Eh\n.text:00401058                 xor     esi, esi\n.text:0040105A                 mov     [ebp+var_C+7], al\n.text:0040105D\n.text:0040105D loc_40105D:                             ; CODE XREF: docall+72j\n.text:0040105D                 movzx   eax, [ebp+esi+var_C]\n.text:00401062                 push    eax\n.text:00401063                 push    offset asc_43B1A0 ; \"%\"\n.text:00401068                 call    printf\n.text:0040106D                 inc     esi\n.text:0040106E                 pop     ecx\n.text:0040106F                 pop     ecx\n.text:00401070                 cmp     esi, 8\n.text:00401073                 jl      short loc_40105D\n.text:00401075                 mov     ecx, [ebp+var_4]\n.text:00401078                 xor     ecx, ebp\n.text:0040107A                 pop     esi\n.text:0040107B                 call    __security_check_cookie\n.text:00401080                 mov     esp, ebp\n.text:00401082                 pop     ebp\n.text:00401083                 retn\n.text:00401083 docall          endp\n\n```\nfind and convert the var a,b,c,x,y,.... to a proper sized array so that \ninstead of var a, var b ida would show varx+1 , varx+2 etc\n\ninsert or define a structure of proper size \n\nedit the function and set its function type (from a possible int to Mystruct *) using the above define struct\n\nre analyze the program if you have hexrays redo the decompiling to see a fresh pseudo code should be much better than your present *x+*y+*z = *v/t-infinity \n\nthe code is xorring a specific portion(400 bytes) of the input with gaps in between (11h and 15h) \n\n",
      "votes": "2",
      "user": "blabb",
      "time": "Aug 3, 2017 at 19:25",
      "is_accepted": true,
      "comments": [
        {
          "user": "Thomas",
          "text": "You were right, bad stack setup. Adjusted the variable sizes and it all lined up. I was able to get the new code working 100%. Thanks bro.",
          "time": null
        },
        {
          "user": "blabb",
          "text": "well i was going to write that var_12 is the first byte from xor @ 4178 edx = 0 ( there is a xor edx ,edx,) soi at 41aa it takes rhe first xorred byte and then xors 4 bytes cmp.....,5 then skips upto 11  , 15 with that jbe and xors the remaining 400. byte buffer. its good that you figured it out never trust odd pointers they are almost always array access if yiu defune an array all the odd ptrs will turn into an indexed accesd",
          "time": null
        }
      ]
    }
  ]
}