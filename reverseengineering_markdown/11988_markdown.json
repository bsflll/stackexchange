{
  "title": "Question about Keeloq - A car remote control standard",
  "link": "https://reverseengineering.stackexchange.com/questions/11988/question-about-keeloq-a-car-remote-control-standard",
  "content": "I have a question about Keeloq security. I have an original car remote controller (BFT Mitto 2) and I know this chip uses HCS301 with Keeloq implementation.\n\nI would like to clone this remote for my girlfriend because it's very expensive to buy a new one. I know universal remotes can copy this remote like this stuff (http://www.amazon.fr/T%C3%A9l%C3%A9commande-Copieuse-T%C3%89L%C3%89COMMANDES-t%C3%A9l%C3%A9commandes-descriptif/dp/B00GTV5SUQ) but I'm curious and I think it's a good electronic project for fun. So, I studied the datasheet of this component. I have already spoofed two consecutive commands and I saved the seed code (retrieved by pushing all the buttons).\n\nData 1:\nCrypt part: 0xFD32DEBA Serial number: 0x719A00\n\nData 2:\nCrypt part: 0xB1755164 Serial number: 0x719A00\n\nSEED CODE: 0xFAA7B14\n\nHow can I learn a new remote with this information? I don't know how universal remote works but according to the datasheet I need to know the manufacturer Id to create a device Key. Can you advise me how I can proceed please.\n\nThank you!\n\n",
  "votes": "5",
  "answers": 1,
  "views": "3k",
  "tags": [
    "hardware",
    "encryption",
    "decryption",
    "embedded"
  ],
  "user": null,
  "time": "Jan 13, 2017 at 19:37",
  "comments": [
    {
      "user": "Federico Ferrari",
      "text": "So at the end, there is someone who successfully copy a keeloq rolling code remote?",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "To create a full duplicate, able to generate valid transmission packets you'll need the following information:\n\nSee attached Figure 1-2, from the datasheet, near \"Transmitted information\" at the bottom right:\n\n\n\nUsing those three pieces of information you can theoretically create your own device.\n\nThe serial number is a unique identifier of the remote control, and is trivially retrievable by capturing a single transmission packet because it is sent as-is. OP already retrieved it.\n\nThe serial is later required because it is part of the encrypted data as well, so the ability to retrieve it without first decrypting a transmission might help us down the line when we'll create the encrypted part.\n\nIn order to send a specific key, you'll need to create your own mapping of values to key meaning. This is not as easy as getting a single value of any transmitted message but does not prove any difficulty, just hit every key and capture it's Button Press Information field. OP seems to have managed that as well.\n\nThis is where shit gets serious, we'll need to know what to encrypt in addition to the key:\n\nSee attached Figure 4-2, from the datasheet, right part:\n\n\n\nThese four bits are the same ones sent unencrypted, so we've already discussed their rather easy retrieval.\n\nThese bits are used to identify the device, and according to the datasheet are usually the Least Significant Bits of the previously discussed Serial Number.\n\nUnder normal circumstances, these bits will be zero. They're used to increase the overall Sync Counter size by two bits but are unused by default, according to the datasheet.\n\nOut of the datasheet:\n\nThis is a value incremented every time a button is pressed, so once we get it we'll be able to roughly know what is the next expected value (which will depend on the number of button presses since).\n\nAdditionally:\n\nWhich means we don't have to hit the exact value, and actually can guess a number the the range of up to 32k values further away, nearly half the size of the value-space.\n\nThere are three possible ways to figure it out.\n\nBy reading the EEPROM, which stores the Sync Counter. Since it is not possible to read EEPROM using the HCS301 without first writing it, you cannot normally read it without tinkering with the hardware. If you've managed to do that you can easily duplicate a remote. Good for you!\n\nBy decrypting a single transmission you can get the currently used Sync Counter, and have a rough estimate going forward. Since the counter is incremented relatively rarely (datasheet estimates 10 times a day), you can easily guess enough values to succeed.\n\nBy bruteforcing the entire value, you're also able to get the correct value. Since the key-space is relatively small 64k values, you could go at it. According to this cryptanalysis and related-works review:\n\nNote they quote is taken a bit out of context here. While the original intent was getting samples of known plaintext/ciphertext for the challenge-response part of the chip, they also provide a rough estimate at the protocol's speed.\n\nAnd that essentially means a receiver can handle these many messages in under two minutes.\n\nThankfully, using the 16 values window mentioned above, we can shave off four bits if done properly.\n\nThe A Practical Attack on KeeLoq article describes different vulnerabilities of the KeeLoq encryption espclifically as used for vehicle remote controls and immobilizers. This is a good read if you're interested retrieving the key using cryptanalysis, and it demonstrates several potentially feasible methods. It also reviews related works for your convenience.\n\nI'll iterate possible approaches:\n\nif you've done that, you could just as easily get the key itself together with the Sync Counter.\n\nCryptographically retrieving the key, as described in detail at the above article and it's references.\n\nAccording the datasheet, the chip has a feature called \"Learning\" to communicate / share the key which might use the SYNC value OP has mentioned.\n\nThere are three types of \"Learning\":\n\nIt is possible to use the \"Secure Learning\" feature, with the manufacturer key to calculate the key. For that, you'll need to reverse engineer the Key generation algorithm (stored in the receiver/car) and fetch the manufacturer key from there.\n\nNormal Learning and Secure Learning are only mentioned, but aren't described in the datasheet in depth which makes it harder to bypass those without manual analysis.\n\nAlthough the implementation/design details of \"Secure Learning\" are not described in the datasheet, a patent filing titled \"Secure self learning system\" (USA Patent US 5686904 A) is mentioned on page 29.\n\nThe patent includes the following relevant yet vague paragraph:\n\n",
      "votes": "9",
      "user": "NirIzr",
      "time": "Oct 11, 2016 at 21:01",
      "is_accepted": false,
      "comments": []
    }
  ]
}