{
  "title": "Convert assembly ADC to C#",
  "link": "https://reverseengineering.stackexchange.com/questions/6156/convert-assembly-adc-to-c",
  "content": "I have this dissassembled routine from an executable but I am having troubles to translate it to C#.\n\n```\n.text:005C9290 ; =============== S U B R O U T I N E =======================================\n.text:005C9290\n.text:005C9290 ; Attributes: bp-based frame\n.text:005C9290\n.text:005C9290 sub_5C9290      proc near               ; CODE XREF: .text:00574256p\n.text:005C9290                                         ; sub_5ACC50+68p ...\n.text:005C9290\n.text:005C9290 SystemTimeAsFileTime= _FILETIME ptr -8\n.text:005C9290 arg_0           = dword ptr  8\n.text:005C9290\n.text:005C9290                 push    ebp\n.text:005C9291                 mov     ebp, esp\n.text:005C9293                 push    ecx\n.text:005C9294                 push    ecx\n.text:005C9295                 lea     eax, [ebp+SystemTimeAsFileTime]\n.text:005C9298                 push    eax             ; lpSystemTimeAsFileTime\n.text:005C9299                 call    ds:GetSystemTimeAsFileTime\n.text:005C929F                 mov     eax, [ebp+SystemTimeAsFileTime.dwLowDateTime]\n.text:005C92A2                 mov     ecx, [ebp+SystemTimeAsFileTime.dwHighDateTime]\n.text:005C92A5                 push    0\n.text:005C92A7                 add     eax, 2AC18000h\n.text:005C92AC                 push    offset unk_989680\n.text:005C92B1                 adc     ecx, 0FE624E21h\n.text:005C92B7                 push    ecx\n.text:005C92B8                 push    eax\n.text:005C92B9                 call    sub_5D0500\n.text:005C92BE                 mov     ecx, [ebp+arg_0]\n.text:005C92C1                 test    ecx, ecx\n.text:005C92C3                 jz      short locret_5C92C7\n.text:005C92C5                 mov     [ecx], eax\n.text:005C92C7\n.text:005C92C7 locret_5C92C7:                          ; CODE XREF: sub_5C9290+33j\n.text:005C92C7                 leave\n.text:005C92C8                 retn\n.text:005C92C8 sub_5C9290      endp\n.text:005C92C8\n.text:005C92C9\n\n```\nHowever, I have this pseudo-code from this function generated by IDA Pro:\n\n```\n__int64 __cdecl sub_5C9290(int a1)\n{\n  __int64 result; // qax@1\n  unsigned __int64 v2; // ST00_8@1\n  struct _FILETIME SystemTimeAsFileTime; // [sp+0h] [bp-8h]@1\n\n  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);\n  HIDWORD(v2) = ((_DWORD)SystemTimeAsFileTime.dwLowDateTime >= 0xD53E8000u)\n              + SystemTimeAsFileTime.dwHighDateTime\n              - 27111903;\n  LODWORD(v2) = SystemTimeAsFileTime.dwLowDateTime + 717324288;\n  result = sub_5D0500(v2, (unsigned int)&unk_989680, 0);\n  if ( a1 )\n    *(_DWORD *)a1 = result;\n  return result;\n}\n\n```\nOne problems is that code won't compile, this code doesn't make sense:\n\n```\nHIDWORD(v2) = ((_DWORD)SystemTimeAsFileTime.dwLowDateTime >= 0xD53E8000u)\n              + SystemTimeAsFileTime.dwHighDateTime\n              - 27111903;\n\n```\nAlso one problem is the ADC command which all I can find is that it is exactly as ADD but it also adds the CARRY FLAG to the result, but I can't find any ways to reproduce this command in C#.\nAnd what about all those HIDWORD and LODWORD macros?\n\n",
  "votes": "1",
  "answers": 1,
  "views": "2k",
  "tags": [
    "ida",
    "disassembly",
    "c#"
  ],
  "user": "Leandro Battochio",
  "time": "Sep 2, 2014 at 6:22",
  "comments": [
    {
      "user": "Iwillnotexist Idonotexist",
      "text": "You should consider an add followed by an adc to just be an extended (in this case, 64-bit) addition. In this particular case a 64-bit constant (0FE624E212AC18000h) is being added to a two-limb value made up of ecx:eax.",
      "time": null
    },
    {
      "user": "Iwillnotexist Idonotexist",
      "text": "D53E8000h is -2AC18000h. The snippet confusing you is merely the calculation of the carry value.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "This is 64-bit math. The compiler has to do the addition in two steps because the processor can only work 32 bits at a time. And carry has to be propagated from the low addition to the high one - same way when you do addition of multiple-digit numbers on paper.\n\nHere's what the current version of the decompiler (1.7) produces (after fixing the function prototype):\n\n```\nresult = sub5D0500(time - 116444736000000000i64, 10000000i64);\n\n```\nAnd (just a guess) if you rename sub5D0500 to __alldiv (compiler helper function for 64-bit division), it becomes:\n\n```\nresult = (time - 116444736000000000i64) / 10000000;\n\n```\nApparently you're looking at MSVC's _time64 implementation. From time64.c:\n\n```\n/*\n * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970\n */\n#define EPOCH_BIAS  116444736000000000i64\n[...]\n__time64_t __cdecl _time64 (\n        __time64_t *timeptr\n        )\n{\n        __time64_t tim;\n        FT nt_time;\n        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );\n        tim = (__time64_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);\n        if (timeptr)\n                *timeptr = tim;         /* store time if requested */\n        return tim;\n}\n\n```\n",
      "votes": "2",
      "user": "Igor Skochinsky",
      "time": "Sep 2, 2014 at 3:27",
      "is_accepted": true,
      "comments": [
        {
          "user": "Leandro Battochio",
          "text": "sub5D0500 is this: pastebin.com/JDN5PAjh So what exact am I looking at? (Pseudo: pastebin.com/tqA05MW6)",
          "time": null
        }
      ]
    }
  ]
}