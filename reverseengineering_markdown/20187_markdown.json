{
  "title": "Impossible to execute a program with radare2 : TO DO continue",
  "link": "https://reverseengineering.stackexchange.com/questions/20187/impossible-to-execute-a-program-with-radare2-to-do-continue",
  "content": "I am trying to crack a crackme. I already catch the flag because I seen the string variable which represants flag. I would like to catch the flag on an other way, I want to set a breakpoint when there is a comparison of the string. I want to use radare2.\n\nWhen I use the dc command to run the program which should stop to breakpoint I set up, I have the message TO DO continue. I don't know why. I expected a message in the form :\n\n```\nstring 1 : TheStringIEnter string 2 : TheFlagOfTheChallenge\n\n```\nThis is the commands I execute :\n\n```\nradare 2 -d ch1.bin\ns sym.main\naaa\npdf\nVV\n:\n:> db 0x08048705\n:> dc\nTODO continue\n:> \n\n```\nThis is the output of pdf command :\n\n```\n[0x0804869d]> pdf\n/ (fcn) main 155\n|   main (int argc, char **argv, char **envp);\n|           ; var int local_ch @ ebp-0xc\n|           ; var int local_8h @ ebp-0x8\n|           ; var int local_4h @ esp+0x4\n|           ; DATA XREF from entry0 (0x8048507)\n|           0x0804869d      8d4c2404       lea ecx, [local_4h]         ; 4\n|           0x080486a1      83e4f0         and esp, 0xfffffff0\n|           0x080486a4      ff71fc         push dword [ecx - 4]\n|           0x080486a7      55             push ebp\n|           0x080486a8      89e5           mov ebp, esp\n|           0x080486aa      51             push ecx\n|           0x080486ab      83ec24         sub esp, 0x24               ; '$'\n|           0x080486ae      c745f8418804.  mov dword [local_8h], str.123456789 ; 0x8048841 ; \"123456789\"\n|           0x080486b5      c704244c8804.  mov dword [esp], str.       ; [0x804884c:4]=0x23232323 ; \"############################################################\"\n|           0x080486bc      e807feffff     call sym.imp.puts           ; int puts(const char *s)\n|           0x080486c1      c704248c8804.  mov dword [esp], str.welcome_to_challenge ; [0x804888c:4]=0x20202323 ; \"##        Welcome to this challenge        ##\"\n|           0x080486c8      e8fbfdffff     call sym.imp.puts           ; int puts(const char *s)\n|           0x080486cd      c70424cc8804.  mov dword [esp], str.       ; [0x80488cc:4]=0x23232323 ; \"############################################################  \n\"\n|           0x080486d4      e8effdffff     call sym.imp.puts           ; int puts(const char *s)\n|           0x080486d9      c704240c8904.  mov dword [esp], str.please_enter_pass: ; [0x804890c:4]=0x69756556 ; \"Please enter the password : \"\n|           0x080486e0      e8b3fdffff     call sym.imp.printf         ; int printf(const char *format)\n|           0x080486e5      8b45f4         mov eax, dword [local_ch]\n|           0x080486e8      890424         mov dword [esp], eax\n|           0x080486eb      e80effffff     call sym.getString\n|           0x080486f0      8945f4         mov dword [local_ch], eax\n|           0x080486f3      8b45f8         mov eax, dword [local_8h]\n|           0x080486f6      89442404       mov dword [local_4h], eax\n|           0x080486fa      8b45f4         mov eax, dword [local_ch]\n|           0x080486fd      890424         mov dword [esp], eax\n|           0x08048700      e8d3fdffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)\n|           0x08048705      85c0           test eax, eax\n|       ,=< 0x08048707      7515           jne 0x804871e\n|       |   0x08048709      8b45f8         mov eax, dword [local_8h]\n|       |   0x0804870c      89442404       mov dword [local_4h], eax\n|       |   0x08048710      c70424308904.  mov dword [esp], str.good_job:__s ; [0x8048930:4]=0x6e656942 ; \"Good job ! You just pass the challenge with the pass : %s!  \n\"\n|       |   0x08048717      e87cfdffff     call sym.imp.printf         ; int printf(const char *format)\n|      ,==< 0x0804871c      eb0c           jmp 0x804872a\n|      ||   ; CODE XREF from main (0x8048707)\n|      |`-> 0x0804871e      c70424708904.  mov dword [esp], str.bad__password. ; [0x8048970:4]=0x6d6d6f44 ; \"Bad password.\"\n|      |    0x08048725      e89efdffff     call sym.imp.puts           ; int puts(const char *s)\n|      |    ; CODE XREF from main (0x804871c)\n|      `--> 0x0804872a      b800000000     mov eax, 0\n|           0x0804872f      83c424         add esp, 0x24               ; '$'\n|           0x08048732      59             pop ecx\n|           0x08048733      5d             pop ebp\n|           0x08048734      8d61fc         lea esp, [ecx - 4]\n\\           0x08048737      c3             ret\n[0x0804869d]> \n\n```\n",
  "votes": "1",
  "answers": 1,
  "views": "6k",
  "tags": [
    "binary-analysis",
    "decompilation",
    "radare2",
    "breakpoint"
  ],
  "user": null,
  "time": "Dec 24, 2018 at 13:41",
  "comments": [
    {
      "user": "sudhackar",
      "text": "I think there are issues already open for this. Disable ESIL emulation and don't open in debug mode. Use doo in normal mode for dc to work",
      "time": null
    },
    {
      "user": "user26834",
      "text": "Ok, I executed the doo command and it works : radare2 ch1.bin aaa s sym.main pdf ood db 0x08048705 dc Now, radare2 show me this message : hit breakpoint at: 8048705. How can I print the two strings which are compared.",
      "time": null
    },
    {
      "user": "sudhackar",
      "text": "Can you share the binary?",
      "time": null
    },
    {
      "user": "user26834",
      "text": "Sure, this is the link of the challenge : root-me.org/fr/Challenges/Cracking/ELF-0-protection",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "Here's how you do it with debugging.\n\n```\n$ r2 ch1.bin\n[0x080484f0]> aaa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n[x] Analyze function calls (aac)\n[x] Analyze len bytes of instructions for references (aar)\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan)\n[x] Type matching analysis for all functions (afta)\n[x] Use -AA or aaaa to perform additional experimental analysis.\n[0x080484f0]> doo\nProcess with PID 18337 started...\nFile dbg:///tmp/ch1.bin  reopened in read-write mode\n= attach 18337 18337\n18337\n[0xf7f6fc70]> pdf @ sym.main ~strcmp\n│           0x08048700      e8d3fdffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)\n\n```\nSet a breakpoint at the strcmp call and continue execution.\n\n```\n[0xf7f6fc70]> s 0x08048700\n[0x08048700]> db 0x08048700\n[0x08048700]> dc\n############################################################\n##        Bienvennue dans ce challenge de cracking        ##\n############################################################\n\nVeuillez entrer le mot de passe : test\nhit breakpoint at: 8048700\n\n```\nUse pxr to dump esp with flags and information about addresses.\n\n```\n[0x08048700]> pxr@esp~:0..5\n0xfff45270  0x09075570  pU.. @esp eax (test)\n0xfff45274  0x08048841  A... (.rodata) (/tmp/ch1.bin) str.123456789 program R X 'xor dword [edx], esi' 'ch1.bin' (123456789)\n0xfff45278  0xfff452a8  .R.. stack R W 0x0 -->  edi\n0xfff4527c  0x08048769  i... (.text) (/tmp/ch1.bin) sym.__libc_csu_init program R X 'lea eax, [ebx - 0xe8]' 'ch1.bin'\n0xfff45280  0x00000000  .... edi\n[0x08048700]>\n\n```\nStack top points to our input test passed as first param to strcmp. The next dword points to the second param at 0x08048841 string 123456789.\n\nSince strcmp is a library function you can use ltrace to do the same.\n\n```\n$ ltrace ./ch1.bin\n__libc_start_main(0x804869d, 1, 0xffbe8304, 0x8048750 <unfinished ...>\nputs(\"################################\"...############################################################\n)                                               = 61\nputs(\"##        Bienvennue dans ce cha\"...##        Bienvennue dans ce challenge de cracking        ##\n)                                               = 61\nputs(\"################################\"...############################################################\n\n)                                               = 62\nprintf(\"Veuillez entrer le mot de passe \"...)                                             = 34\nmalloc(2)                                                                                 = 0x9352570\ngetchar(2, 0, 0xffbe8258, 0xf7d792f6Veuillez entrer le mot de passe : test\n)                                                     = 116\nrealloc(0x9352570, 2)                                                                     = 0x9352570\ngetchar(0x9352570, 2, 0xffbe8258, 0xf7d792f6)                                             = 101\nrealloc(0x9352570, 3)                                                                     = 0x9352570\ngetchar(0x9352570, 3, 0xffbe8258, 0xf7d792f6)                                             = 115\nrealloc(0x9352570, 4)                                                                     = 0x9352570\ngetchar(0x9352570, 4, 0xffbe8258, 0xf7d792f6)                                             = 116\nrealloc(0x9352570, 5)                                                                     = 0x9352570\ngetchar(0x9352570, 5, 0xffbe8258, 0xf7d792f6)                                             = 10\nstrcmp(\"test\", \"123456789\")                                                               = 1\nputs(\"Dommage, essaye encore une fois.\"...Dommage, essaye encore une fois.\n)                                               = 33\n+++ exited (status 0) +++\n\n```\nTBF you don't need to debug it at all and just static analysis would do.\n\n```\n[0x080484f0]> pdf @ sym.main~strcmp\n│           0x08048700      e8d3fdffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)\n[0x080484f0]> s 0x08048700\n[0x08048700]> pd-10\n│           0x080486d9      c704240c8904.  mov dword [esp], str.Veuillez_entrer_le_mot_de_passe_: ; [0x804890c:4]=0x69756556 ; \"Veuillez entrer le mot de passe : \" ; const char *format\n│           0x080486e0      e8b3fdffff     call sym.imp.printf         ; int printf(const char *format)\n│           0x080486e5      8b45f4         mov eax, dword [s1]\n│           0x080486e8      890424         mov dword [esp], eax\n│           0x080486eb      e80effffff     call sym.getString\n│           0x080486f0      8945f4         mov dword [s1], eax\n│           0x080486f3      8b45f8         mov eax, dword [local_8h]\n│           0x080486f6      89442404       mov dword [s2], eax         ; const char *s2\n│           0x080486fa      8b45f4         mov eax, dword [s1]\n│           0x080486fd      890424         mov dword [esp], eax        ; const char *s1\n[0x08048700]>\n\n```\nNow we know the arguments to strcmp : s1 and local_8h. s1 was populated with a call to sym.getString, so thats probably our input and hence local_8h is the string we need to find to match.\n\nWe'll see where it was used//modified (read/write) in the function. Use afv(R/W)\n\n```\n[0x08048700]> afv?\nUsage: afv  [rbs]\n| afvr[?]                       manipulate register based arguments\n| afvb[?]                       manipulate bp based arguments/locals\n| afvs[?]                       manipulate sp based arguments/locals\n| afv*                          output r2 command to add args/locals to flagspace\n| afvR [varname]                list addresses where vars are accessed (READ)\n| afvW [varname]                list addresses where vars are accessed (WRITE)\n| afva                          analyze function arguments/locals\n| afvd name                     output r2 command for displaying the value of args/locals in the debugger\n| afvn [new_name] ([old_name])  rename argument/local\n| afvt [name] [new_type]        change type for given argument/local\n| afv-([name])                  remove all or given var\n\n```\nUse this on local_8h\n\n```\n[0x08048700]> afvR local_8h\n  local_8h  0x80486f3,0x8048709\n[0x08048700]> afvW local_8h\n  local_8h  0x80486ae\n\n```\nAt 0x80486ae it was written to or initialized.\n\n```\n[0x08048700]> pd3 @ 0x80486ae \n│           0x080486ae      c745f8418804.  mov dword [local_8h], str.123456789 ; 0x8048841 ; \"123456789\"\n│           0x080486b5      c704244c8804.  mov dword [esp], str.       ; [0x804884c:4]=0x23232323 ; \"############################################################\" ; const char *s\n│           0x080486bc      e807feffff     call sym.imp.puts           ; int puts(const char *s)\n[0x08048700]> \n\n```\nHere r2 resolved the address 0x8048841 to a string 123456789\n\n",
      "votes": "3",
      "user": "sudhackar",
      "time": "Dec 27, 2018 at 11:29",
      "is_accepted": true,
      "comments": []
    }
  ]
}