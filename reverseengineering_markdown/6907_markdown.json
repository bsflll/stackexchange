{
  "title": "IDA segmentation problem",
  "link": "https://reverseengineering.stackexchange.com/questions/6907/ida-segmentation-problem",
  "content": "In the program I'm trying to reverse engineer, originally IDA only created three segments: CODE, DATA and .idata.\n\nUsing the information from the compiler source code (http://pastebin.com/ParJ3683 lines 30-78), I determined that infact DATA was concatenated out of (at least) four segments, DATA,INITDATA,EXITDATA and BSS.\n\nSo I created three new segments with the specified alignments (word/dword) and the appropriate boundaries; while all data appeared in the correct segment bounds, all references to what had been in the DATA segment and is now in BSS are now totally messed up:\n\n```\nCODE:00401A8A                 push    ds:globalErrorMessagesCaption[eax*4] ; lpCaption\n\n```\nturned into \n\n```\nCODE:00401A8A                 push    dword ptr ds:(algn_481049+187h)[eax*4] ; lpCaption\n\n```\nThe section header is\n\n```\n_BSS:00481106 ; Segment type: Pure data\n_BSS:00481106 _BSS            segment dword public 'DATA' use32\n_BSS:00481106                 assume cs:_BSS\n_BSS:00481106                 ;org 481106h\n\n```\nWhat has gone wrong here and how can I fix it?\n\n",
  "votes": "4",
  "answers": 2,
  "views": "3k",
  "tags": [
    "ida",
    "segmentation"
  ],
  "user": "Skynet",
  "time": "Dec 28, 2014 at 15:17",
  "comments": [],
  "answers_data": [
    {
      "content": "Short answer: your newly created segments probably have an invalid selector value of 0, and things should start working again as soon as you set the selector to a valid value (e.g. SetSegmentAttr(here, SEGATTR_SEL, 1) at the command prompt). The reason is that all selectors created by IDA for a PE32(+) have the same base and are mostly equivalent.\n\nLong answer:\n\nThere are certain differences between recent IDA versions in the way segment editing via the UI works. Segment editing via the UI can cause complex operations under the hood, and the resulting behaviour is not always intuitive. That's why I'd rather not give a solution in terms of UI operations.\n\nThe segment editing functions available in IDC and Python are much simpler and straightforward, and they can be invoked from IDA's command prompt (including symbolic names for flag values, like SEGMOD_KEEP). For trickier stuff I find it most convenient to compose my own operations as named snippets in the code snippet editor (Shift-F2). With a suitable Jump() at the end of the operation - to position the cursor on the most likely candidate for the next operation - this makes it easy to get a lot of stuff done in no time flat. \n\nThe IDC/Python segment editing functions are slightly better documented than the whole UI stuff and, being simpler, they are easier to get a handle on by way of experimentation. And much less prone to nasty surprises. If bad things have happened - as in your case - they can often be repaired by probing a working example in one IDA instance with commands like this:\n\n```\nGetSegmentAttr(here, SEGATTR_FLAGS)\n\n```\nand then switching to the other IDA instance containing the 'patient' and poking in the newly discovered value:\n\n```\nSetSegmentAttr(here, SEGATTR_FLAGS, 0x10)\n\n```\nSince both IDA instances share the same command prompt history, entering the second command is as simple as hitting the up arrow and modifying the query that was entered in the other IDA instance. In your case things will probably start working again if you set SEGATTR_SEL for the newly created segments to the same value as an existing (and hence correctly configured) segment. To find the magic flags and their names I prefer grepping $(IDA)/idc/idc.idc over consulting the help file, since idc.idc tends to be more comprehensive and more up to date.\n\nNote: view windows like \"Program Segmentation\" do not refresh on their own but they can be refreshed by hitting their hotkey again (e.g. Shift-F7 for \"Program Segmentation\"), and also by entering \"RefreshLists()\" at the command prompt. Also, all the stuff I wrote here is probably far from optimal, but it's the best I am able to do based on my limited knowledge and existing documentation...\n\nLast but not least, segments are not very significant for PE32(+) targets with their flat address spaces. I find them convenient for tagging ranges of code as belonging to a certain module (e.g. 'CRT', 'Lua', whatever) but it is not really necessary to create a faithful representation of the segments contained in the source code, since they are mostly for the benefit of the linker and end up being merged into a tiny number of PE sections.\n\n",
      "votes": "2",
      "user": "DarthGizka",
      "time": "Dec 29, 2014 at 16:59",
      "is_accepted": true,
      "comments": [
        {
          "user": "Skynet",
          "text": "Luckily I did a backup and restored it - how do I do segment splitting with IDC the \"proper\" way?",
          "time": null
        }
      ]
    },
    {
      "content": "IDA cannot reference symbols within a segment unless that segment has a valid selector, so that's the most important property to set for a new segment. The selector can be set in the 'Create Segment...' dialogue via the field \"base in paragraphs\". \n\nGetSegmentAttr(here, SEGATTR_SEL) tells you what the proper selector is, if the cursor is in the segment to be split. You can type the expression right into the input field of the dialogue; by the same token you can type here into the begin address field and SegEnd(here) into the end address field.\n\nHere's an IDC snippet (Shift-F2) that splits the current segment at the current position, cloning most relevant properties (including SEGATTR_SEL):\n\n\n```\nCompileEx(\n  \"class HelperFunctions {\"\n    \"copy_seg_attr (src, dst, attr) { SetSegmentAttr(dst, attr, GetSegmentAttr(src, attr)); }\"\n  \"};\", 0  );\n\nauto ori_seg, ok, fn;\n\nori_seg = SegStart(here);\n\nok = AddSegEx(\n   here, \n   SegEnd(here), \n   GetSegmentAttr(here, SEGATTR_SEL),\n   GetSegmentAttr(here, SEGATTR_BITNESS),\n   GetSegmentAttr(here, SEGATTR_ALIGN),\n   GetSegmentAttr(here, SEGATTR_COMB),\n   ADDSEG_NOSREG  );\n\nif (!ok)  return Warning(\"AddSegEx() failed\");\n\nfn = HelperFunctions();    \nfn.copy_seg_attr(ori_seg, here, SEGATTR_PERM);\nfn.copy_seg_attr(ori_seg, here, SEGATTR_FLAGS);\nfn.copy_seg_attr(ori_seg, here, SEGATTR_ES);\nfn.copy_seg_attr(ori_seg, here, SEGATTR_SS);\nfn.copy_seg_attr(ori_seg, here, SEGATTR_DS);\nfn.copy_seg_attr(ori_seg, here, SEGATTR_TYPE);\nfn.copy_seg_attr(ori_seg, here, SEGATTR_COLOR);\n\nRenameSeg(here, AskStr(\"\", \"segment name\"));\n\n```\nNote: 'inlining' a class definition via Compile() or CompileEx() was the only trick I found for defining a function inside a snippet. It seems to work only in newer IDAs though (tested with 6.6 and 6.7), and only if the Compile() is right at the start of the snippet. \n\nFor older IDA versions the helper function has to be defined in some other way, for example in a separate .idc file, and the call to AddSegEx() needs to be replaced with AddSeg().\n\nAlso, I couldn't find a way to query the segment class, and so it cannot be copied even though there is a function SetSegClass() that can set it.\n\nThe inverse operation - merging the next segment into the current one - is much simpler:\n\n```\nauto seg_beg, seg_end, next_seg;\n\nseg_beg = SegStart(here);\n\nif (seg_beg == -1)  return Warning(\"no segment here\");\n\nnext_seg = NextSeg(here);\n\nif (next_seg == SegEnd(here))\n{\n   seg_end = SegEnd(next_seg);\n\n   DelSeg(next_seg, SEGMOD_KEEP);\n   SetSegBounds(seg_beg, seg_beg, seg_end, SEGMOD_KEEP);\n\n   Jump(PrevNotTail(seg_end));\n}\n\n```\nWith a snippet like this you can merge a whole boatload of segments with just a single click per segment, which is handy for memory dumps. Or for undoing accidental segment splits...\n\n",
      "votes": "0",
      "user": "DarthGizka",
      "time": "Jan 9, 2015 at 15:16",
      "is_accepted": false,
      "comments": []
    }
  ]
}