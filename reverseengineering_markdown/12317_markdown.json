{
  "title": "Identify Jump Statements due to Switch/Case in IDA Pro",
  "link": "https://reverseengineering.stackexchange.com/questions/12317/identify-jump-statements-due-to-switch-case-in-ida-pro",
  "content": "I want to identify the jump statements due to switch/case in an IDA Pro disassembled binary. My ultimate goal is to read the jump table entries. I am also interested in function table/vtables. For switch/case, I see the jump statements as:\n\nThe operand types of these jumps, as I see from GetOperandValue(inst.ea, 0), are \"Memory Reference\" (type value 2). The jump statements like jb short loc_6B2A8154 has operand type \"Immediate Near Address\" (type value 7). However, the jump statements like jmp ds:__imp_memset in the thunk functions to call imported functions also have the operand type \"Memory Reference\". \n\nIs there any way I can distinguish between jump statements for switch/case and thunk functions? \n\n",
  "votes": "4",
  "answers": 3,
  "views": "4k",
  "tags": [
    "disassembly",
    "idapython"
  ],
  "user": "ssultana",
  "time": "Apr 1, 2016 at 18:05",
  "comments": [],
  "answers_data": [
    {
      "content": "In many cases, IDA already knows that a jump is part of a jump-table and probably the result of a switch. When this is true, you can access it using IDAPython.\n\nThe relevant functions are get_switch_info_ex(ea) and get_switch_info_ex(ea).\nLooking in IDAPython's documentation, we find:\n\nTo get the results variable from the example, we use the following code:\n\n```\nsi = idaapi.get_switch_info_ex(ea)\nresults = idaapi.calc_switch_cases(ea, si)\nif not results:\n    print \"No switch related jump at 0x{:X}\".format(ea)\n\n```\nSo to check if an instruction is a switch or not, you can use the following function:\n\n```\ndef is_switch(ea):\n    si = idaapi.get_switch_info_ex(ea)\n    results = idaapi.calc_switch_cases(ea, si)\n    return bool(results)\n\n```\nIf you wish to use it, I've written a basic wrapper class for IDA's switch in Sark. See here.\n\n",
      "votes": "3",
      "user": "tmr232",
      "time": "Sep 29, 2016 at 21:34",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "On the x86 architecture, jump statements due to switch/case statements often follow the pattern:\n\n```\njmp <offset> [<index-register> * 4]   ;; pointers are 4 bytes\n\n```\nwhere <index-register> contains the value being switched on and the \"4\" is the scaling factor. Depending on your compiler may have good results searching for jump instructions with indexed memory operands.\n\nHowever the compiler is free to compile switch statements into cascades of cmp and jnz statements if it determines that doing so would produce more efficient code. For instance:\n\n```\nswitch (foo) {\ncase 1: do_something(); break;\ncase 10000: do_something_else(); break;\ncase 1000000: do_final_thing(); break;\n}\n\n```\nwould be terribly inefficient implemented as a table lookup. Therefore, just looking for indexed memory operands won't necessarily find all switch/cases in your program.\n\nYou need also take into account that the compiler may write the switch differently. It is fully possible that it might determine that it is better to emit the sequence\n\n```\nmov eax,table_offset[eax*4]\njmp eax\n\n```\nor, as in old hand-rolled binaries adapted from hand-written assembler written for 8086 or 80286 real mode:\n\n```\nshl eax,4\njmp table_offset[eax]\n\n```\nTo cover all bases, you will be forced to use other techniques like backward slicing to determine the destinations of a compiled switch/case statement.\n\n",
      "votes": "0",
      "user": "John Källén",
      "time": "Apr 1, 2016 at 18:25",
      "is_accepted": false,
      "comments": [
        {
          "user": "ssultana",
          "text": "Thanks for explaining other switch/case scenarios. I'll have to take care of those. However, I am taking figuring out the indexed memory operands for switch/case jumps as a first step. I am using IDA Python scripting to get the instruction types, operand types and values, etc. Using IDA Python, I still cannot distinguish between switch/case jumps to indexed memory references and other memory references due to thunk functions. Any pointer would be appreciated.",
          "time": null
        },
        {
          "user": "John Källén",
          "text": "I'm not familiar with IDA but could you, after identifying the indirect jmp, then compare that its opcode startis with FF 24 85 / 8D / 95 / 9D etc. I.e mask out the i part of the sib byte of the indirect jump?",
          "time": null
        }
      ]
    },
    {
      "content": "Similar to Sark's solution, minsc at https://github.com/arizvisa/ida-minsc provides a wrapper around the same switch_info_t that is fetched in IDAPython using the get_switch_info function from nalt.hpp. It is worth noting that these solutions use the disassembler exclusively (as opposed to the decompiler).\n\nDisclaimer: I'm the maintainer of the ida-minsc plugin.\n\nTo get to the minsc wrapper, the database.get.switch function is used to fetch a switch_t. The following python disassembles a branch instruction and then uses its address to get the \"switch\" identified by the disassembler. The switch_t that is returned contains 0x10 total cases and exposes numerous properties that can be used to extract information from the \"switch\". As per the question, the database.type.switch function can be used to detect if an address branches to a table used by the \"switch\" (or belongs to a handler) that was detected by the disassembler.\n\n```\nPython>db.disasm()\n'277ef564: jmp ds:jpt_277EF564[eax*4]'\n\nPython>sw=db.get.switch()\nPython>sw\n<class 'switch_t{16}' at 0x277ef54f> default:0x277ef699 branch[8]:0x277ef6b3 indirect[16]:0x277ef6d3 register:%eax\n\nPython>db.t.switch()\nTrue\n\n```\nThe switch_t.range property returns the entire range of cases for the switch that was determined by the disassembler. Similarly, the switch_t.cases property is used to return only the cases that do not dispatch to the \"default\" handler for the fetched \"switch\". Also, if one wants to create a breakpoint logging the case being dispatched to by the \"switch\", the switch_t.ea property can be combined with the switch_t.register property in order to identify the register needing to be captured.\n\n```\n# Return the full range of cases supported by the \"switch\".\nPython>sw.range\n(0x10000000, 0x10000001, 0x10000002, 0x10000003, 0x10000004, 0x10000005, 0x10000006, 0x10000007, 0x10000008, 0x10000009, 0x1000000a, 0x1000000b, 0x1000000c, 0x1000000d, 0x1000000e, 0x1000000f)\n\n# Return the cases of the \"switch\" that dispatch to a non-default case.\nPython>sw.cases\n(0x10000000, 0x10000001, 0x10000002, 0x10000003, 0x10000004, 0x10000005, 0x10000007, 0x10000008, 0x10000009, 0x1000000a, 0x1000000b, 0x1000000c, 0x1000000d, 0x1000000e, 0x1000000f)\n\n# Other properties that could be useful...\nPython>db.disasm(sw.ea)\n'277ef54f: add eax, 0F0000000h'\n\nPython>sw.register\n<class 'register_t' index=0 dtype=dt_dword name='eax' position=0+32>\n\nPython>database.up(sw.branch_ea)\n[ref_t(address=0x277ef564, access=access_t(r))]\n\nPython>[db.disasm(ea) for ea in database.up(sw.branch_ea)]\n['277ef564: jmp ds:jpt_277EF564[eax*4]']\n\n# Display operand information that might be used for filtering.\nPython>ea, = database.up(sw.branch_ea)\nPython>ins.type.branch(ea)\nTrue\n\nPython>instruction.ops_access(ea)\n(opref_t(address=0x277ef564, opnum=0, access=access_t(rx)))\n\nPython>ins.ops(ea)\n(SegmentOffsetBaseIndexScale(segment=%ds, offset=0x277ef6b3, base=None, index=%eax, scale=4))\n\n```\nFor addresses being dispatched to by the \"switch\", the switch_t.handlers property can be used to return the address of each handler, with the switch_t.default property being responsible for returning the address of the \"default\" handler. To return the handler for a specific case, the switch_t.case() function can be used as in the following python.\n\n```\n# Return all of the available handlers used by the \"switch\".\nPython>sw.handlers\n(0x277ef67e, 0x277ef56b, 0x277ef644, 0x277ef685, 0x277ef699)\n\n# Return the default handler for the \"switch\".\nPython>sw.default\n0x277ef699\n\n# Return the handler for a specific case.\nPython>sw.case(0x10000000)\n0x277ef67e\n\n```\nBy combining the handler-related properties, one can create a python dictionary for looking up the dispatcher for a specific case as in the following code. However, it is probably more useful to determine the number of cases that are implemented by each handler in order to distinguish what is actually worth reversing. This can be done by inverting the dictionary so that its key references the handler, with its value containing the list of cases being supported.\n\n```\nPython>{case : sw.case(case) for case in sw.range}\n{0x10000000: 0x277ef67e, 0x10000001: 0x277ef67e, 0x10000002: 0x277ef67e, 0x10000003: 0x277ef67e, 0x10000004: 0x277ef67e, 0x10000005: 0x277ef67e, 0x10000006: 0x277ef699, 0x10000007: 0x277ef67e, 0x10000008: 0x277ef56b, 0x10000009: 0x277ef67e, 0x1000000a: 0x277ef67e, 0x1000000b: 0x277ef644, 0x1000000c: 0x277ef67e, 0x1000000d: 0x277ef67e, 0x1000000e: 0x277ef67e, 0x1000000f: 0x277ef685}\n\n# Invert the table of case<->handlers.\nPython>handlers={}\nPython>[ handlers.setdefault(sw.case(case), []).append(case) for case in sw.cases ]\n[None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]\n\nPython>handlers\n{0x277ef67e: [0x10000000, 0x10000001, 0x10000002, 0x10000003, 0x10000004, 0x10000005, 0x10000007, 0x10000009, 0x1000000a, 0x1000000c, 0x1000000d, 0x1000000e], 0x277ef699: [0x10000006], 0x277ef56b: [0x10000008], 0x277ef644: [0x1000000b], 0x277ef685: [0x1000000f]} \n\n```\nThis dictionary can be used for operations such as notating the handler address with a descriptive name, color, etc. The following python produces a name following the format \"case(number1,number2,number3,...)\" and applies it as a label for each handler. Afterwards, the database.names namespace is used with the \"bounds\" matcher and function.chunk to list all the labels within the current function chunk...showing the labels we just applied.\n\n```\n# Assign a label to the address of each individual case.\nPython>for ea, cases in handlers.items():\nPython> db.name(ea, \"case({:s})\".format(','.join(hex(case) for case in sorted(cases))), listed=True)\nPython>\n\n# List all the labels within the current function chunk.\nPython>db.names.list(bounds=func.chunk())\n[322] 0x277ef53e : ^C* : jsvda_920\n[323] 0x277ef56b : ^C* : case(10000008)\n[324] 0x277ef644 : ^C* : case(1000000b)\n[325] 0x277ef67e : ^C* : case(10000000,10000001,10000002,10000003,10000004,10000005,10000007,10000009,1000000a,1000000c,1000000d,1000000e)\n[326] 0x277ef685 : ^C* : case(1000000f)\n[327] 0x277ef699 : ^C* : def_277EF564\n\n```\nFor enumerating switches, the function.switches function can be used with an address belonging to a function. The next python combines this with the database.functions namespace to identify every function containing 1 or more switches within the database. After all of the candidate functions have been enumerated, the function.tag function is used to store the total number of cases that are handled by the switches within each function.\n\n```\n# Collect all functions that have at least one \"switch\" within its body.\nPython>functions_with_switches = {ea for ea in db.functions() if next(func.switches(ea), None) is not None}\nPython>functions_with_switches\nset([0x277bd6cd, 0x277d5b8f, 0x2780c071, 0x2780e8b1, 0x277a7833, 0x277beb74, 0x277fef38, 0x277ac0fb, 0x277a2ebd, 0x277ef53e])\n\n# Iterate through all functions and collect the number of \"switch\" statements detected by the disassembler.\nPython>for ea in functions_with_switches:\nPython> count = sum(len(sw.cases) for sw in func.switches(ea))\nPython> fn.tag(ea, 'switch.cases', count)\n\n```\nOnce a function has been tagged and indexed with some value, database.functions can be used with the \"tagged\" matcher to narrow down the list of functions containing our previously identified switches. To query the index for the number of cases tagged to each function, the database.select function can also be used.\n\n```\nPython>db.functions(tagged='switch.cases')\n[0x277a2ebd, 0x277a7833, 0x277ac0fb, 0x277bd6cd, 0x277beb74, 0x277d5b8f, 0x277ef53e, 0x277fef38, 0x2780c071, 0x2780e8b1]\n\nPython>db.functions.list(tagged='switch.cases')\n[0]  +0x02ebd : 0x277a2ebd..0x277a3331 : (1) Fvt* : __cdecl jsvda_919                                             : lvars:330 args:5 refs:4 exits:1\n[1]  +0x07833 : 0x277a7833..0x277a78ff : (1) Fv-* : __cdecl sub_277A7833                                          : lvars:010 args:4 refs:1 exits:1\n[2]  +0x0c0fb : 0x277ac0fb..0x277ac61b : (1) Fvt* : __cdecl sub_277AC0FB                                          : lvars:024 args:7 refs:1 exits:1\n[3]  +0x1d6cd : 0x277bd6cd..0x277bd82c : (1) Fvt* : __cdecl jsvda_950                                             : lvars:010 args:3 refs:5 exits:1\n[4]  +0x1eb74 : 0x277beb74..0x277beca6 : (1) F-t* : __cdecl sub_277BEB74                                          : lvars:008 args:4 refs:1 exits:1\n[5]  +0x35b8f : 0x277d5b8f..0x277d6059 : (1) FvT* : __cdecl JSVDA::204                                            : lvars:02c args:8 refs:2 exits:1\n[6]  +0x4f53e : 0x277ef53e..0x277ef6b3 : (1) Fvt* : __cdecl jsvda_920                                             : lvars:014 args:4 refs:3 exits:1\n[7]  +0x5ef38 : 0x277fef38..0x277ff219 : (1) Fvt* : __cdecl sub_277FEF38                                          : lvars:040 args:3 refs:1 exits:1\n[8]  +0x6c071 : 0x2780c071..0x2780c5cc : (1) FvT* : __cdecl JSVDA::object_6b3a6::getPathAttributeFromBucket_6c071 : lvars:024 args:5 refs:6 exits:1\n[9]  +0x6e8b1 : 0x2780e8b1..0x2780eabb : (1) F--* : __cdecl sub_2780E8B1                                          : lvars:00c args:4 refs:1 exits:1\n\nPython>for ea, res in db.select('switch.cases'):\nPython> print(res['switch.cases'], hex(ea), func.name(ea), sum(1 for blk in function.blocks(ea)))\nPython>\n11 277a2ebd jsvda_919 111\n8 277a7833 sub_277A7833 25\n10 277ac0fb sub_277AC0FB 136\n16 277bd6cd jsvda_950 47\n15 277beb74 sub_277BEB74 30\n9 277d5b8f JSVDA::204 116\n15 277ef53e jsvda_920 35\n13 277fef38 sub_277FEF38 76\n15 2780c071 JSVDA::object_6b3a6::getPathAttributeFromBucket_6c071 120\n11 2780e8b1 sub_2780E8B1 81\n\n```\n",
      "votes": "0",
      "user": "Ali Rizvi-Santiago",
      "time": "Aug 15, 2024 at 20:07",
      "is_accepted": false,
      "comments": []
    }
  ]
}