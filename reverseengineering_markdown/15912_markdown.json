{
  "title": "Translate addresses on stack to the exported function names",
  "link": "https://reverseengineering.stackexchange.com/questions/15912/translate-addresses-on-stack-to-the-exported-function-names",
  "content": "I'm investigating a bug that happens in proprietary DLL that doesn't have PDB symbols.\n\nThe callstack looks like this:\n\n```\nKernelBase.dll!7710c54f()\n[Frames below may be incorrect and/or missing, no symbols loaded for KernelBase.dll]    \nmsvcr90.dll!__CxxThrowException@8()\nScrUsSsDtceLib.dll!5ec92ef1()\nScrUsSsDtceLib.dll!5ec91ec4()\nScrUsSsDtceLib.dll!5ec96f86()\nScrUsSsDtceLib.dll!5ec9de1c()\nScrUsSsDtceLib.dll!5ec9d5f5()\nScrUsSsDtceLib.dll!5ecc2f5d()\nvcomp90.dll!_vcomp::ParallelRegion::HandlerThreadFunc(void *,unsigned long)\nvcomp90.dll!_vcomp::NullAPCFunc(unsigned long)\nkernel32.dll!759b336a()\nntdll.dll!777e9902()\nntdll.dll!777e98d5()\n\n```\nAlso I see the following DLL exports in Dependency Walker.\n\n```\nOrdinal Hint    Entry Point Function\n1   0   0x000135D0  IScrUsDtce2D::IScrUsDtce2D(void)\n2   1   0x00013B30  IScrUsDtce3D::IScrUsDtce3D(void)\n3   2   0x00013F50  IScrUsDtce2D::~IScrUsDtce2D(void)\n4   3   0x00013B50  IScrUsDtce3D::~IScrUsDtce3D(void)\n5   4   0x00012AA0  class IScrUsDtce2D & IScrUsDtce2D::operator=(class IScrUsDtce2D const &)\n6   5   0x00012AD0  class IScrUsDtce3D & IScrUsDtce3D::operator=(class IScrUsDtce3D const &)\n7   6   0x000139A0  int IScrUsDtce2D::FilterImage(unsigned short const *,unsigned short *,int,int)\n8   7   0x00013DC0  int IScrUsDtce3D::FilterVolume(int,unsigned char const * const *,unsigned char * *,int)\n9   8   0x00013620  int IScrUsDtce2D::Init(char const *,struct UsDtceImgInfo const &,enum IScrUsDtce2D::ProcType,unsigned short const *)\n10  9   0x00013BA0  int IScrUsDtce3D::Init(char const *,struct UsDtceImgInfo const &,enum IScrUsDtce3D::ProcType)\n11  10  0x000137F0  int IScrUsDtce2D::InitSSC(char const *,struct UsDtceImgInfo const &,enum IScrUsDtce2D::ProcType,unsigned short const *,bool,float *,int)\n\n```\nIs there any way to understand which functions are called?\n\nUPD: I understand that bigger part of the callstack addresses may be private functions.\n\n",
  "votes": "0",
  "answers": 1,
  "views": "93",
  "tags": [
    "debugging"
  ],
  "user": "Vitaliy",
  "time": "Jul 25, 2017 at 18:53",
  "comments": [],
  "answers_data": [
    {
      "content": "post unadulterated stack use kb and paste the exact output\nit is kinda difficult to understand what the symbols are in the stack paste\nif they are return address ebp , args ?   \n\nmost of the time you may need a disassembler application like ida / radare2 etc that does some extra work to analyze function boundaries and possibly name them\n\nfor example this is a stack from livekd.exe from sysinternals\n\n```\n0:002> ~0kb\n # ChildEBP RetAddr  Args to Child              \n00 0021eab0 77546a64 7570179c 000000cc 00000000 ntdll!KiFastSystemCallRet\n01 0021eab4 7570179c 000000cc 00000000 00000000 ntdll!NtWaitForSingleObject+0xc\n02 0021eb20 76bebaf3 000000cc ffffffff 00000000 KERNELBASE!WaitForSingleObjectEx+0x98\n03 0021eb38 76bebaa2 000000cc ffffffff 00000000 kernel32!WaitForSingleObjectExImplementation+0x75\n*** ERROR: Module load completed but symbols could not be loaded for e:\\sysint\\livekd.exe\n04 0021eb4c 00076038 000000cc ffffffff 00000000 kernel32!WaitForSingleObject+0x12\nWARNING: Stack unwind information not available. Following frames may be wrong.\n05 0021fae8 000795e6 00000001 002fbec0 002fbee8 livekd+0x6038\n06 0021fb30 76bf3c45 7ffdf000 0021fb7c 775637eb livekd+0x95e6\n07 0021fb3c 775637eb 7ffdf000 770c043e 00000000 kernel32!BaseThreadInitThunk+0xe\n08 0021fb7c 775637be 00079663 7ffdf000 00000000 ntdll!__RtlUserThreadStart+0x70\n09 0021fb94 00000000 00079663 7ffdf000 00000000 ntdll!_RtlUserThreadStart+0x1b\n\n```\nyou can find where livekd is loaded with \n\n```\n0:002> lm m live*\nBrowse full module list\nstart    end        module name\n00070000 0010d000   livekd     (no symbols)       \n\n```\nnow assume you load it in radare2 with the same base address 0x70000 you can seek to the return address in stack 0x76038\n\nradare does some analysis and says this address belongs to main()\n\n```\nradare2 -B 0x70000 -AA e:\\SYSINT\\livekd.exe\n\n[0x00079663]> s 0x76038\n\n[0x00076038]> pd 5\n|           0x00076038      6860894200     push 0x428960\n|           0x0007603d      ffd6           call esi\n|           0x0007603f      6860894200     push 0x428960\n|           0x00076044      c705c47b4200.  mov dword [0x427bc4], 0     ; [0x427bc4:4]=-1\n|           0x0007604e      ff158c704100   call dword [0x41708c]\n[0x00076038]> afn\n\nmain <-------------\n[0x00076038]>\n\n```\nanother example \n\n```\n[0x00076038]> s 0x795e6\n[0x000795e6]> afn\nentry0  <----------------\n[0x000795e6]>\n\n```\n",
      "votes": "1",
      "user": "blabb",
      "time": "Jul 26, 2017 at 5:34",
      "is_accepted": true,
      "comments": []
    }
  ]
}