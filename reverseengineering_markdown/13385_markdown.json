{
  "title": "How to know if PE Header import function is being imported by Ordinal rather than by name",
  "link": "https://reverseengineering.stackexchange.com/questions/13385/how-to-know-if-pe-header-import-function-is-being-imported-by-ordinal-rather-tha",
  "content": "I want to know how to find out if an imported function in a PE header is being imported by ordinal rather than by name because I came across an executable that does that. Here is the DLL that imports all functions by ordinal except for one (from WS2_32.dll):\n\nScreenshot from program called ExeinfoPE\n\n\nThis is what I'm doing to get to the imports:\n\nHere is how I extract the functions (only works for functions imported by name):\n\n```\nvoid extractFunctions(IMAGE_IMPORT_DESCRIPTOR dll, uintptr_t sectionStartAddrRaw) {\n    uintptr_t selectedFunctionImport = dll.Characteristics + sectionStartAddrRaw;\n    uintptr_t selectedFunctionImportIAT = dll.FirstThunk + sectionStartAddrRaw;\n\n    while (true) {\n        IMAGE_THUNK_DATA thunkPtrToImportByName = *(IMAGE_THUNK_DATA*)selectedFunctionImport;\n        selectedFunctionImport += sizeof(IMAGE_THUNK_DATA); //Next loop we'll loop over to the next IMAGE_THUNK_DATA.\n        if (thunkPtrToImportByName.u1.Function == NULL) { //Check if we need to exit the looping since there are no more functions to import.\n            break;\n        }\n\n        IMAGE_IMPORT_BY_NAME* functionImport = (IMAGE_IMPORT_BY_NAME*)(thunkPtrToImportByName.u1.Function + sectionStartAddrRaw);\n\n        Function function;\n        function.name = std::string(functionImport->Name); //Access violation here if the function needs to be imported by ordinal, instead of by name.\n        function.locationInIAT = selectedFunctionImportIAT;\n        function.locationInOriginalIAT = selectedFunctionImportIAT - sectionStartAddrRaw + header.OptionalHeader.ImageBase;\n\n        selectedFunctionImportIAT += sizeof(IMAGE_THUNK_DATA);\n        dlls.back().functions.push_back(function); //We assume that IMAGE_IMPORT_DESCRIPTOR dll is the last one in the dlls vector.]\n    }\n}\n\n```\nI noticed that every function Hint/Ordinal inside ExeinfoPE that is imported by name is 0. However, in my code functionImport->Hint is always set to something, regardless if the function is supposed to be imported by name or ordinal.\n\nThe IMAGE_IMPORT_DESCRIPTOR cannot have information on whether the functions inside that IMAGE_IMPORT_DESCRIPTOR are imported by ordinal or name, since one of the functions is imported by name and all of the others are imported by ordinal. So, I'm all out of ideas here.\n\nHere are the data structures I'm using for your reference so no need to Google:\n\n```\ntypedef struct _IMAGE_THUNK_DATA {\n    union {\n        uint32_t* Function;             // address of imported function\n        uint32_t  Ordinal;              // ordinal value of function\n        PIMAGE_IMPORT_BY_NAME AddressOfData;        // RVA of imported name\n        DWORD ForwarderStringl              // RVA to forwarder string\n    } u1;\n} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;\n\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR {\n    union {\n        DWORD   Characteristics; /* 0 for terminating null import descriptor  */\n        DWORD   OriginalFirstThunk; /* RVA to original unbound IAT */\n    } DUMMYUNIONNAME;\n\n    DWORD   TimeDateStamp;  /* 0 if not bound,\n    * -1 if bound, and real date\\time stamp\n    *    in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\n    * (new BIND)\n    * otherwise date/time stamp of DLL bound to\n    * (Old BIND)\n    */\n    DWORD   ForwarderChain; /* -1 if no forwarders */\n    DWORD   Name;\n    /* RVA to IAT (if bound this IAT has actual addresses) */\n    DWORD   FirstThunk;\n} IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;\n\ntypedef struct _IMAGE_IMPORT_BY_NAME {\n    WORD    Hint;\n    BYTE    Name[1];\n} IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;\n\n```\n",
  "votes": "3",
  "answers": 1,
  "views": "5k",
  "tags": [
    "windows",
    "pe"
  ],
  "user": "Majiick",
  "time": "Aug 28, 2016 at 6:20",
  "comments": [
    {
      "user": "Majiick",
      "text": "I found something relevant on page 51 of Windows' pe header documentation under the topic \"Import Lookup Table\", gyazo.com/0fde0a89b514b3e40a163e9934391e4f Looks like the first bit of the IMAGE_THUNK_DATA->Ordinal is a flag, and if it is set then the function should be imported by ordinal. It's late right now, I will write the answer tomorrow or someone else write it.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "Extracted from http://www.pelib.com/:\n\nA more detailed explanation extracted from a volatility plugin (lines 363-367):\n\n```\n350  while 1:\n351      thunk = obj.Object('_IMAGE_THUNK_DATA',\n352                 offset = self.obj_parent.DllBase + self.OriginalFirstThunk +\n353                 i * self.obj_vm.profile.get_obj_size('_IMAGE_THUNK_DATA'),\n354                 vm = self.obj_native_vm)\n\n355      # We've reached the end when the element is zero \n357      if thunk == None or thunk.AddressOfData == 0:\n358          break\n359      o = obj.NoneObject(\"Ordinal not accessible?\")\n361      n = obj.NoneObject(\"Imported by ordinal?\")\n362      f = obj.NoneObject(\"FirstThunk not accessible\")\n\n363      # If the highest bit (32 for x86 and 64 for x64) is set, the function is \n365      # imported by ordinal and the lowest 16-bits contain the ordinal value. \n366      # Otherwise, the lowest bits (0-31 for x86 and 0-63 for x64) contain an \n367      # RVA to an _IMAGE_IMPORT_BY_NAME struct. \n368      if thunk.OrdinalBit == 1:\n369          o = thunk.Ordinal & 0xFFFF\n370      else:\n371          iibn = obj.Object(\"_IMAGE_IMPORT_BY_NAME\",\n372                            offset = self.obj_parent.DllBase +\n373                            thunk.AddressOfData,\n374                            vm = self.obj_native_vm)\n375          o = iibn.Hint\n376          n = iibn.Name\n377      # See if the import is bound (i.e. resolved)\n379      first_thunk = obj.Object('_IMAGE_THUNK_DATA',\n380                      offset = self.obj_parent.DllBase + self.FirstThunk +\n381                      i * self.obj_vm.profile.get_obj_size('_IMAGE_THUNK_DATA'),\n382                      vm = self.obj_native_vm)\n383      if first_thunk:\n384          f = first_thunk.Function.v()\n385      yield o, f, str(n or '')\n387      i += 1\n\n```\n",
      "votes": "4",
      "user": "knx",
      "time": "Aug 28, 2016 at 7:33",
      "is_accepted": true,
      "comments": []
    }
  ]
}