{
  "title": "Wrapping usercall from Hex-Rays",
  "link": "https://reverseengineering.stackexchange.com/questions/11081/wrapping-usercall-from-hex-rays",
  "content": "I am trying to call a function generated by Hex-Rays by injecting a DLL, but have so far only managed to crash the process.\n\nThis is the code generated by Hex-Rays\n\n```\nint __usercall sub_54C3A0@<eax>(int a1@<esi>, void *a2@<ecx>)\n{\n  char *v2; // eax@1\n  char *v3; // edx@1\n  char v4; // cl@2\n  int result; // eax@4\n  char v6[84]; // [sp+0h] [bp-58h]@1\n\n  sub_432BA0(a2);\n  dword_81D7CC = 1;\n  sub_432B40(\"xxx_\");\n  v2 = (char *)sub_431620(55);\n  v3 = (char *)(v6 - v2);\n  do\n  {\n    v4 = *v2;\n    v2[(_DWORD)v3] = *v2;\n    ++v2;\n  }\n  while ( v4 );\n  sub_4330E0(*(_DWORD *)v6);\n  sub_437270();\n  dword_81D7CC = 0;\n  result = 0;\n  if ( v6[0] )\n  {\n    dword_81DAE0 = 0;\n    if ( sub_54C480(100, a1) || dword_81DAE0 || sub_54C480(75, a1) || dword_81DAE0 || sub_54C480(50, a1) )\n      result = 1;\n  }\n  return result;\n}\n\n```\nAnd this is my code\n\n```\nstatic DWORD hook_address = 0x54C3A0;\n__declspec(naked) int hook()\n{\n    __asm {\n        push esi // a1\n        push ecx // a2\n        call hook_address\n        retn 4\n    }\n}\n\n```\nWhat would the correct wrapper look like, and why?\n\n",
  "votes": "1",
  "answers": 1,
  "views": "1k",
  "tags": [
    "ida",
    "assembly",
    "hexrays"
  ],
  "user": "Magnus von Wachenfeldt",
  "time": "Dec 16, 2015 at 17:12",
  "comments": [
    {
      "user": "0xec",
      "text": "It should be mov esi, a1 , mov ecx, a2. Note that usercall is not actually any calling convention. It is a way of representing unknown/custom calling conventions. See this answer.",
      "time": null
    },
    {
      "user": "Magnus von Wachenfeldt",
      "text": "I tried that, still get access violation.",
      "time": null
    },
    {
      "user": "rev",
      "text": "Do it like this: mov esi, a1, mov ecx, a2, call hook_address, ret. Using retn 4 clears 4 bytes from the stack, but usercalls don't need it because their arguments are in registers, not in the stack.",
      "time": null
    },
    {
      "user": "Magnus von Wachenfeldt",
      "text": "That worked. Also, the address was wrong all the time. After running the program from IDA the addresses updated. No wonder I got access violations all over the place.",
      "time": null
    },
    {
      "user": "tmr232",
      "text": "@AcidShout can you write your comment as an answer so that this question can be marked answered, and also help others in future?",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "Your hook is wrong because retn 4 is for __stdcalls, not __usercalls, and because you must move arguments to registers, not push them. Do it like this:\n\n```\nmov esi, a1\nmov ecx, a2\ncall hook_address\nret\n\n```\nretn 4 would clean 4 bytes from the stack, but you didn't push anything, so it's not correct, which is why you use ret instead.\n\n",
      "votes": "4",
      "user": "rev",
      "time": "Oct 13, 2015 at 13:05",
      "is_accepted": false,
      "comments": []
    }
  ]
}