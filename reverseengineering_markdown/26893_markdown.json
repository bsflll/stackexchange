{
  "title": "How to write these 4 example x86 assembly instructions in opcodes, according to the Intel docs?",
  "link": "https://reverseengineering.stackexchange.com/questions/26893/how-to-write-these-4-example-x86-assembly-instructions-in-opcodes-according-to",
  "content": "Okay so I have been studying Chapter 2 of Volume 2 of the Intel Manuals.\n\nI have as best an understanding as I can get of the ModR/M byte, the REX byte, the SIB byte, and the general instruction encoding (by just reading with no practice or practical tinkering yet). Now, from my understanding, the \"instruction\" encoding is different from the whole \"call\" encoding (as I would call it): that is, the instruction plus the operands. That took me days to realize, and I'm still not certain of it.\n\nSo I am going to try to apply my knowledge now on these 4 types of calls.\n\n```\nopcode              instruction           operand encoding\n04 ib               ADD AL, imm8          I\nREX + 80 /0 ib      ADD r/m8*, imm8       MI\n00 /r               ADD r/m8, r8          MR\nREX.W + 03 /r       ADD r64, r/m64        RM\n\n```\nFirst some background:\n\nLooking at the \"Instruction Operand Encoding\" table, I see this:\n\n```\noperand encoding    operand 1             operand 2\nRM                  ModRM:reg (r, w)      ModRM:r/m (r)\nMR                  ModRM:r/m (r, w)      ModRM:reg (r)\nMI                  ModRM:r/m (r, w)      imm8\nI                   AL/AX/EAX/RAX         imm8\n\n```\nSo I see those \"operand encoding\" strings like MR. That gives me 00 /r from the example instructions. So we have two hex values, 00, and then there's the /r. I have re-read it's meaning a dozen times but still don't know what it means.\n\nI have thought a lot about all of the above parts, but it just feels like something is missing. I can't piece it together to apply this knowledge yet.\n\nSo already I am lost. I just studied the ModRM, reg, and r/m stuff, but I don't know what they mean here. Going back and rereading.\n\nThe ModR/M byte is an addressing-form specifier byte. It is divided into 3 parts or \"fields\".\n\nWe don't have to deal with the SIB codes in this question.\n\nThat doesn't really give me any actionable information. Then there are the rich tables of every value the ModR/M byte takes up in tables 2-1 through 2-3. I am not really sure how the columns and rows line up and what they mean yet.\n\nSo, I don't know how to write down those 4 examples of instructions into opcodes, even if I were to select registers or memory addresses for them at random.\n\nSkipping to section 3.1.1.1, I have studied all of the keywords there too.\n\nThose 3 are relevant for the instructions above.\n\nThen there is \"Table 3-1. Register Codes\", which I think shows you something about what the decimal/binary value is of each register, which is useful somewhere in this equation.\n\nThat's pretty much it on what I need to know. Everything else in this book seems to be the individual instruction details, or the advanced instruction info which I don't care about yet (like VEX).\n\nBut I've read this stuff about 5 times through so far and I still don't have a solid understanding of how to write 1 instruction call yet, for the goal of writing a machine code generator without using gcc/clang/llvm/etc..\n\nI see this image too, but don't know what to do with it entirely yet.\n\n\n\nHow do you write these 4 example x86 assembly instructions in opcodes, according to the Intel docs? How do I interpret the \"operand encoding\" values in the table above? Say we select some random registers or slots of memory that fit the instruction type constraints above, then how do you figure out how to write it down into hex code using the Intel Manuals?\n\n",
  "votes": "1",
  "answers": 1,
  "views": "1k",
  "tags": [
    "assembly",
    "x86",
    "binary"
  ],
  "user": "Lance Pollard",
  "time": "Jan 28, 2021 at 0:33",
  "comments": [
    {
      "user": "Igor Skochinsky",
      "text": "reverseengineering.stackexchange.com/a/3673/60 could be useful",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "This Answer is not a forward engineering answer like you seek\n\nbut a reverse engineereed answer\n\nthere exists many utilities,frameworks that can encode  the Mnemonic of Your choice\n\none of them is the keystone-engine (pip install keystone-engine for python binding)\n\nusing one of those utilities  we can encode  what we seek to understand\nand look at the encoded bytes and try to make sense of those\nib/r/modrm/sib/rex/lock theories\n\nshown below is a simple encoding of add r,imm8 variant using keystone\n\n```\nfrom keystone import *\nfrom binascii import *\nprint( \"REGISTER_GROUP names are based on legends,epics&lores from arachnid yarn\")\nprint( \"ACCUMULATOR_REGISTER_GROUP  = [AL,AX,EAX,RAX]\")\nprint( \"BASE_REGISTER_GROUP         = [BL,BX,EBX,RBX]\")\nprint( \"COUNT_REGISTER_GROUP        = [CL,CX,ECX,RCX]\")\nprint( \"DATA_REGISTER_GROUP         = [DL,DX,EDX,RDX]\")\nprint( \"Mnemonic Add r,imm8\")\n\nCODE_R_IMM8 = [\nb\"add   al  ,0xff\",\nb\"add   bl  ,0xff\",\nb\"add   cl  ,0xff\",\nb\"add   dl  ,0xff\",\nb\"add   ax  ,0xff\",\nb\"add   bx  ,0xff\",\nb\"add   cx  ,0xff\",\nb\"add   dx  ,0xff\",\nb\"add   eax ,0xff\",\nb\"add   ebx ,0xff\",\nb\"add   ecx ,0xff\",\nb\"add   edx ,0xff\",\nb\"add   rax ,0xff\",\nb\"add   rbx ,0xff\",\nb\"add   rcx ,0xff\",\nb\"add   rdx ,0xff\"\n]\n\nfor i in range (0,len(CODE_R_IMM8),1):\n    print(\"%40s\" % CODE_R_IMM8[i],end=\"\\t\")\n    print(hexlify((Ks(KS_ARCH_X86,KS_MODE_64).asm(CODE_R_IMM8[i],0x10000000,as_bytes=True))[0]))\n\n```\nexecuted\n\n```\n:\\>python openc.py\nREGISTER_GROUP names are based on legends,epics&lores from arachnid yarn\nACCUMULATOR_REGISTER_GROUP  = [AL,AX,EAX,RAX]\nBASE_REGISTER_GROUP         = [BL,BX,EBX,RBX]\nCOUNT_REGISTER_GROUP        = [CL,CX,ECX,RCX]\nDATA_REGISTER_GROUP         = [DL,DX,EDX,RDX]\nMnemonic Add r,imm8\n                      b'add   al  ,0xff'        b'04ff'\n                      b'add   bl  ,0xff'        b'80c3ff'\n                      b'add   cl  ,0xff'        b'80c1ff'\n                      b'add   dl  ,0xff'        b'80c2ff'\n                      b'add   ax  ,0xff'        b'6605ff00'\n                      b'add   bx  ,0xff'        b'6681c3ff00'\n                      b'add   cx  ,0xff'        b'6681c1ff00'\n                      b'add   dx  ,0xff'        b'6681c2ff00'\n                      b'add   eax ,0xff'        b'05ff000000'\n                      b'add   ebx ,0xff'        b'81c3ff000000'\n                      b'add   ecx ,0xff'        b'81c1ff000000'\n                      b'add   edx ,0xff'        b'81c2ff000000'\n                      b'add   rax ,0xff'        b'4805ff000000'\n                      b'add   rbx ,0xff'        b'4881c3ff000000'\n                      b'add   rcx ,0xff'        b'4881c1ff000000'\n                      b'add   rdx ,0xff'        b'4881c2ff000000'\n\n```\nyou can also refer to this site for explanation of each bytes in the encoded\nbytes of chosen memmonic\n\n",
      "votes": "1",
      "user": "blabb",
      "time": "Jan 28, 2021 at 5:53",
      "is_accepted": false,
      "comments": []
    }
  ]
}