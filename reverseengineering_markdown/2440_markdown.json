{
  "title": "Mixed 16/32-bit code reversing using IDA",
  "link": "https://reverseengineering.stackexchange.com/questions/2440/mixed-16-32-bit-code-reversing-using-ida",
  "content": "I am trying to reverse engineer a binary blob I expect to transition from 16-bit real mode into 32-bit protected mode (it is boot time code), so I expect the code to contain code of both sorts.\n\nWhen I launch IDA, I am given the option of 16 or 32-bit code, but not mixed.\n\nHow do I instruct IDA to attempt to disassemble data at a given address as 32-bit mode?\n\nI can using the 16-bit analyzer deduce the initial jump (unoriginally) and IDA happily analyses the code from there. I can see where the 32-bit code jumps to (far jump, so IDA doesn't try to analyze it), but IDA treats this as 16-bit when I hit C.\n\nOther than launching a 16, and a 32-bit dissasmbly session, can I do this in one?\n\n",
  "votes": "10",
  "answers": 2,
  "views": "9k",
  "tags": [
    "ida",
    "x86"
  ],
  "user": null,
  "time": "Jul 9, 2013 at 20:36",
  "comments": [
    {
      "user": "Willem Hengeveld",
      "text": "The arm processor module can do exactly this. So i guess it is a feature that could be implemented in theory.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "Ida Free 5\n\n```\nEdit -> Segments ->CreateSegment\n\n```\nin the dialog\n\n```\nsegment name  = seg001....seg00n\nstart         = <start address viz 0x0A\nend           = <end address viz 0x1e\nbase          = 0x0 \nclass         = some text viz 32one,32two,16three\nradio button  = 32 bit segment or 16 bit segment as needed\nclick yes to a cryptic dialog \n\n```\nexample \nthe binary stream contains 16 bit dos puts routine and 32 bit random pushes intermixed\n\n```\nC:\\Documents and Settings\\Admin\\Desktop>xxd -g 1 1632blob.bin\n0000000: b4 01 cd 21 88 c2 b4 02 cd 21 68 78 56 34 12 68  ...!.....!hxV4.h\n0000010: 0d d0 37 13 68 be ba 37 13 68 00 0d db ba b4 01  ..7.h..7.h......\n0000020: cd 21 88 c2 b4 02 cd 21 68 78 56 34 12 68 0d d0  .!.....!hxV4.h..\n0000030: 37 13 68 be ba 37 13 68 00 0d db ba b4 01 cd 21  7.h..7.h.......!\n0000040: 88 c2 b4 02 cd 21 68 78 56 34 12 68 0d d0 37 13  .....!hxV4.h..7.\n0000050: 68 be ba 37 13 68 00 0d db ba                    h..7.h....\n\nC:\\Documents and Settings\\Admin\\Desktop>\n\n```\nloading this blob as binary file moving to offset 0 and pressing c would disassemble all bytes as 16 bit \n\nnow you can move to offset 0x0a and create a 32 bit segment with start as 0x0a end as 0x1e base as 0x0 class as 32one use 32bitsegment radio button and press c again to create 32 bit disassembly\n\nsee below\n\n```\nseg000:0000                ;\nseg000:0000                ; +-------------------------------------------------------------------------+\nseg000:0000                ; ¦     This file is generated by The Interactive Disassembler (IDA)        ¦\nseg000:0000                ; ¦     Copyright (c) 2010 by Hex-Rays SA, <>           ¦\nseg000:0000                ; ¦                      Licensed to: Freeware version                      ¦\nseg000:0000                ; +-------------------------------------------------------------------------+\nseg000:0000                ;\nseg000:0000                ; Input MD5   : AEB17B9F8C4FD00BF2C04A4B3399CED1\nseg000:0000\nseg000:0000                ; ---------------------------------------------------------------------------\nseg000:0000\nseg000:0000                                .686p\nseg000:0000                                .mmx\nseg000:0000                                .model flat\nseg000:0000\nseg000:0000                ; ---------------------------------------------------------------------------\nseg000:0000\nseg000:0000                ; Segment type: Pure code\nseg000:0000                seg000          segment byte public 'CODE' use16\nseg000:0000                                assume cs:seg000\nseg000:0000                                assume es:seg005, ss:seg005, ds:seg005, fs:seg005, gs:seg005\nseg000:0000 B4 01                          mov     ah, 1\nseg000:0002 CD 21                          int     21h\nseg000:0004 88 C2                          mov     dl, al\nseg000:0006 B4 02                          mov     ah, 2\nseg000:0008 CD 21                          int     21h\nseg000:0008                seg000          ends\nseg000:0008\nseg001:0000000A                ; ---------------------------------------------------------------------------\nseg001:0000000A\nseg001:0000000A                ; Segment type: Regular\nseg001:0000000A                seg001          segment byte public '32one' use32\nseg001:0000000A                                assume cs:seg001\nseg001:0000000A                                ;org 0Ah\nseg001:0000000A                                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\nseg001:0000000A 68 78 56 34 12                 push    12345678h\nseg001:0000000F 68 0D D0 37 13                 push    1337D00Dh\nseg001:00000014 68 BE BA 37 13                 push    1337BABEh\nseg001:00000019 68 00 0D DB BA                 push    0BADB0D00h\nseg001:00000019                seg001          ends\nseg001:00000019\nseg002:001E                ; ---------------------------------------------------------------------------\nseg002:001E\nseg002:001E                ; Segment type: Pure code\nseg002:001E                seg002          segment byte public 'CODE' use16\nseg002:001E                                assume cs:seg002\nseg002:001E                                ;org 1Eh\nseg002:001E                                assume es:seg005, ss:seg005, ds:seg005, fs:seg005, gs:seg005\nseg002:001E B4 01                          mov     ah, 1\nseg002:0020 CD 21                          int     21h\nseg002:0022 88 C2                          mov     dl, al\nseg002:0024 B4 02                          mov     ah, 2\nseg002:0026 CD 21                          int     21h\nseg002:0026                seg002          ends\nseg002:0026\nseg003:00000028                ; ---------------------------------------------------------------------------\nseg003:00000028\nseg003:00000028                ; Segment type: Regular\nseg003:00000028                seg003          segment byte public '32two' use32\nseg003:00000028                                assume cs:seg003\nseg003:00000028                                ;org 28h\nseg003:00000028                                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\nseg003:00000028 68 78 56 34 12                 push    12345678h\nseg003:0000002D 68 0D D0 37 13                 push    1337D00Dh\nseg003:00000032 68 BE BA 37 13                 push    1337BABEh\nseg003:00000037 68 00 0D DB BA                 push    0BADB0D00h\nseg003:00000037                seg003          ends\nseg003:00000037\nseg004:003C                ; ---------------------------------------------------------------------------\nseg004:003C\nseg004:003C                ; Segment type: Pure code\nseg004:003C                seg004          segment byte public 'CODE' use16\nseg004:003C                                assume cs:seg004\nseg004:003C                                ;org 3Ch\nseg004:003C                                assume es:seg005, ss:seg005, ds:seg005, fs:seg005, gs:seg005\nseg004:003C B4 01                          mov     ah, 1\nseg004:003E CD 21                          int     21h\nseg004:0040 88 C2                          mov     dl, al\nseg004:0042 B4 02                          mov     ah, 2\nseg004:0044 CD 21                          int     21h\nseg004:0044                seg004          ends\nseg004:0044\nseg005:00000046                ; ---------------------------------------------------------------------------\nseg005:00000046\nseg005:00000046                ; Segment type: Regular\nseg005:00000046                seg005          segment byte public '32three' use32\nseg005:00000046                                assume cs:seg005\nseg005:00000046                                ;org 46h\nseg005:00000046                                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\nseg005:00000046 68 78 56 34 12                 push    12345678h\nseg005:0000004B 68 0D D0 37 13                 push    1337D00Dh\nseg005:00000050 68 BE BA 37 13                 push    1337BABEh\nseg005:00000055 68 00 0D DB BA                 push    0BADB0D00h\nseg005:00000055                seg005          ends\nseg005:00000055\nseg005:00000055\nseg005:00000055                                end\n\n```\n",
      "votes": "7",
      "user": "blabb",
      "time": "Jul 10, 2013 at 5:09",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "You could either do it manually or create a custom loader module for your binary blob. What you need to do is separate code into 2 segments: 32-bit segment and 16-bit segment, and specify appropriate addressing mode. IDA supports 16, 32, 64 bit modes. If needed you could manually create 2 different code segments and change address mode manually by pressing Alt+S \n\nIn order to incorporate it in a loader, you may utilize getseg and set_segm_addressing from segment.hpp out of IDA SDK:\n\n```\n// Get pointer to segment by linear address\n//      ea - linear address belonging to the segment\n// returns: NULL or pointer to segment structure\n\ninline segment_t *getseg(ea_t ea) { return (segment_t *)(segs.get_area(ea)); } \n\n```\n\n// Change segment addressing mode (16, 32, 64 bits)\n// You must use this function to change segment addressing, never change\n// the 'bitness' field directly.\n// This function will delete all instructions, comments and names in the segment\n//      s      - pointer to segment\n//      bitness- new addressing mode of segment\n//                 2: 64bit segment\n//                 1: 32bit segment\n//                 0: 16bit segment\n// returns: 1-ok, 0-failure\n\nidaman bool ida_export set_segm_addressing(segment_t *s, size_t bitness);\n\nFirstly, you will need to get a pointer to a segment structure using getseg. Thereafter, you could change segment addressing mode to 16 or 32 bit using set_segm_addressing. \n\n\n",
      "votes": "10",
      "user": "PSS",
      "time": "Jul 10, 2013 at 5:21",
      "is_accepted": false,
      "comments": []
    }
  ]
}