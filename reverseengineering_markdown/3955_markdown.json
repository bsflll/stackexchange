{
  "title": "how to reverse DeviceIoControl?",
  "link": "https://reverseengineering.stackexchange.com/questions/3955/how-to-reverse-deviceiocontrol",
  "content": "I have started reversing this piece of malware. At some point it creates a service and starts it, then immediately it calls the function DeviceIoControl and the malware went from \"paused\" to \"running\" under ollydbg. I've searched a little bit, and I understand that this function serves to communicate with the service it just had created.\n\nBut how exactly do I reverse it? How do I know what it does? And how can I continue stepping under ollydbg? Or do I have to move to windbg or some other kernel-mode debugger?\n\n",
  "votes": "5",
  "answers": 2,
  "views": "4k",
  "tags": [
    "malware",
    "kernel-mode"
  ],
  "user": "user4170",
  "time": "Mar 26, 2014 at 7:13",
  "comments": [],
  "answers_data": [
    {
      "content": "You cannot step into kernel mode from Ollydbg. You need a kernel debugger like windbg, as ollydbg is a user mode debugger. \n\nSince you posed the question, I assume you neither have a kernel debugging connection,\nnor the driver where that control code is sent for analyzing it, as answered by Jonathon.\n\nUsage of proper security measures to deal with malware assumed and emphasized from here onward.\n\nI assume the malware is running already as your query states that you are on DeviceIoControl.\n\nI am going to use ollydbg 2.01.\n\nAttach ollydbg to an unknown process \n\nPress Ctrl+G and start typing ntdll.ntDeviceIo and the list box  will show \nntdll.ntDeviceIoControl now  select it and follow label.\n\nPress F2 to set a breakpoint, and F9 to run the attached process.\n\n```\nINT3 breakpoints, item 0\n  Address = 7C90D27E NtDeviceIoControlFile\n  Module = ntdll\n  Status = Active\n  Disassembly = MOV     EAX, 42\n  Comment = ntdll.NtDeviceIoControlFile(guessed Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8,Arg9,Arg10)\n\n```\nOllydbg should break when a control code is sent and stack should look like this:\n\n```\nCPU Stack\n    Address   Value      ASCII Comments\n    0013EF50  [7C801675  u€|   ; /RETURN from ntdll.NtDeviceIoControlFile to kernel32.DeviceIoControl+4C\n    0013EF54  /00000090        ; |Arg1 = 90\n    0013EF58  |00000000        ; |Arg2 = 0\n    0013EF5C  |00000000        ; |Arg3 = 0\n    0013EF60  |00000000        ; |Arg4 = 0\n    0013EF64  |0013EF88  ˆï    ; |Arg5 = 13EF88\n    0013EF68  |83050024  $ ƒ   ; |Arg6 = 83050024\n    0013EF6C  |00000000        ; |Arg7 = 0\n    0013EF70  |00000000        ; |Arg8 = 0\n    0013EF74  |0013EFEC  ìï    ; |Arg9 = 13EFEC\n    0013EF78  |00000004        ; \\Arg10 = 4\n\n```\nFrom the specs of DeviceIoControlCode, the first argument points to handle and the sixth argument is the control code\n\nHaving windbg installed can make things easier from here, but we will not use windbg at this moment as it has a steep learning curve.\n\nOpen ollydbg handle window and find what does the handle point to (0x90 in the above paste) - it points to a device:\n\n```\nHandles, item 9\n  Handle = 00000090\n  Type = File (dev)   <-------- it is a _FILE_OBJECT\n  Refs =    2.\n  Access = 0012019F (FILE_GENERIC_READ|FILE_GENERIC_WRITE)\n  Tag =\n  Info =\n  Translated name = \\Device\\Dbgv\n\n```\nNow run Process Explorer from SysInternals. Select the unknown process, and press Ctrl+H to make the lower pane show handles.\n\nSelect the handle 90, right click and select properties. Process Explorer will show the address of the Device Object as noted by Ollydbg. This device object is a File Object:\n\n\n\nollydbg 2.01 can show memory above 0x7fffffff (kernel mode memory) we will use that feature to find the driver associated with this device \n\nRead about the FILE_OBJECT structure relevant to your OS. In Windows XP you will find the address of device object at +4 from file object.\n\nSelect the dump window press Ctrl+G and type in the address process explorer showed viz \n\n```\n863c87f0 and follow expression \n\nCPU Dump\nAddress   Hex dump                                         ASCII\n863C87F0  05 00 70 00|A8 D3 51 86|00 00 00 00|00 00 00 00|  p ¨ÓQ†\n\n```\nSo 8651d3a8 in the paste above points to the device object for this file object.\n\nRead about DEVICE_OBJECT structure.  In Windows XP, the address of the driver object is at device object + 8.  Following there with Ctrl+G -> follow expression as done earlier\n\n```\nCPU Dump\nAddress   Hex dump                                         ASCII\n8651D3A8  03 00 B8 00|01 00 00 00|48 2C F1 86|00 00 00 00|  ¸    H,ñ†\n\n```\nnotice 86f12c48 is driver object. Read about DRIVER_OBJECT structure.\n\n+0xc is Driver Start and +0x10 is Driver Size --> Ctrl+G to follow:\n\n```\nCPU Dump\nAddress   Hex dump                                         ASCII\n86F12C48  04 00 A8 00|A8 D3 51 86|12 00 00 00|00 30 2A A9|  ¨ ¨ÓQ†    0*©\n86F12C58  00 3D 00 00|48 9C D8 86|F0 2C F1 86|18 00 18 00|  =  HœØ†ð,ñ† \n\n```\na92a3000 is DriverStart and size of driver is 3d00.\n\nCtrl+G to follow:\n\n```\nCPU Dump\nAddress   Hex dump                                         ASCII\nA92A3000  4D 5A 90 00|03 00 00 00|04 00 00 00|FF FF 00 00| MZ       ÿÿ\nA92A3010  B8 00 00 00|00 00 00 00|40 00 00 00|00 00 00 00| ¸       @\n\n```\nThe famous IMAGE_DOS_HEADER is noticeable.\n\nSelect from a92a3000 to a92a6d00,  Right-Click -> Edit -> binary copy and paste the bytes to a new file in any hex editor (HxD for example), and save it as malwaredriver.sys :)\n\n```\nfoo:\\>dir malwaredriver.sys\n\n26/03/2014  14:04            15,616 malwaredriver.sys\n\n\\>set /a 0x3d00\n15616\n\\>file malwaredriver.sys\n\nmalwaredriver.sys; PE32 executable for MS Windows (native) Intel 80386 32-bit\n\n:\\>\n\n```\nYou can now analyze the driver statically.\n\nRead about DRIVER_OBJECT structure carefully to find you can readily know the handler for IRP_MJ_DEVICE_IO_CONTROL handler in ollydbg. It would be at +0x70 from Driverobject in XP. For this particular driver, the IRP_MJ_DEVICE_IO_CONTROL_HANDLER is at \n\n```\nCPU Dump\nAddress   Value      ASCII Comments\n86F12CB8   A92A4168  hA*©\n\n```\nYou can follow and disassemble this memory in ollydbg. Select cpu dump press ctrl+g to disassemble an unknown driver \n\n```\nCPU Disasm\nAddress   Command                             Comments\nA92A4168  MOV     EDI, EDI                    ; IRP_MJ_DEVICE_IO_CONTROL_HANDLER(pdevob,pirp)\nA92A416A  PUSH    EBP\nA92A416B  MOV     EBP, ESP\nA92A416D  SUB     ESP, 24\nA92A4170  PUSH    EBX\nA92A4171  PUSH    ESI\nA92A4172  MOV     ESI, DWORD PTR SS:[EBP+0C]  ; irp\nA92A4175  MOV     EAX, DWORD PTR DS:[ESI+60]  ; nt!_irp -y Tail.overlay.cur->maj\nA92A4178  MOV     EDX, DWORD PTR DS:[ESI+0C]  ; nt!_irp Tail.overlay.cur->par.DeviceIo.ty\nA92A417B  XOR     EBX, EBX\nA92A417D  PUSH    EDI\nA92A417E  LEA     EDI, [ESI+18]\nA92A4181  MOV     DWORD PTR DS:[EDI], EBX\nA92A4183  MOV     DWORD PTR DS:[ESI+1C], EBX\nA92A4186  MOVZX   ECX, BYTE PTR DS:[EAX]\nA92A4189  SUB     ECX, EBX\nA92A418B  JE      SHORT A92A41F7              ; case 0 create\nA92A418D  DEC     ECX\nA92A418E  DEC     ECX\nA92A418F  JE      SHORT A92A41CA              ; case 2 close\nA92A4191  SUB     ECX, 0C\nA92A4194  JNE     A92A42BB                    ; unhandled\nA92A419A  MOV     ECX, DWORD PTR DS:[EAX+0C]  ; ioctl\nA92A419D  MOV     EBX, ECX\nA92A419F  AND     EBX, 00000003\nA92A41A2  CMP     BL, 3\nA92A41A5  JNE     SHORT A92A41AC              ; buff align\nA92A41A7  MOV     EBX, DWORD PTR DS:[ESI+3C]\nA92A41AA  JMP     SHORT A92A41AE\nA92A41AC  MOV     EBX, EDX                    ; inbuff\nA92A41AE  PUSH    DWORD PTR SS:[EBP+8]        ; devobj\nA92A41B1  PUSH    EDI\nA92A41B2  PUSH    ECX\nA92A41B3  PUSH    DWORD PTR DS:[EAX+4]        ; bufflen\nA92A41B6  PUSH    EBX\nA92A41B7  PUSH    DWORD PTR DS:[EAX+8]        ; ioctlcode\nA92A41BA  PUSH    EDX\nA92A41BB  PUSH    1\nA92A41BD  PUSH    DWORD PTR DS:[EAX+18]       ; fobj\nA92A41C0  CALL    A92A3EEC                    ; actual_handler\n\n```\nHere the ioctl code is handled:\n\n```\nCPU Disasm\nAddress   Command                                  Comments\nA92A3EF8  MOV     ESI, DWORD PTR SS:[EBP+24]\nA92A3EFB  XOR     EBX, EBX\nA92A3EFD  MOV     DWORD PTR DS:[ESI], EBX\nA92A3EFF  MOV     DWORD PTR DS:[ESI+4], EBX\nA92A3F02  MOV     ECX, DWORD PTR SS:[EBP+20]\nA92A3F05  MOV     EAX, 83050020\nA92A3F0A  CMP     ECX, EAX\nA92A3F0C  JA      A92A40F1  this code will take this path as 24 > 20\n\n```\n===========\n\n```\nCPU Disasm\nAddress     Hex dump                  Command                Comments\nA92A40F1    81F9 24000583             CMP     ECX, 83050024\nA92A40F7    74 3F                     JE      SHORT A92A4138 path taken\n\n```\nThe control code does this work and sends some 320 on some condition\n\n```\n[code]\nCPU Disasm\nAddress   Command                             Comments\nA92A4138  PUSH    4\nA92A413A  POP     EAX\nA92A413B  CMP     DWORD PTR SS:[EBP+1C], EAX\nA92A413E  JB      SHORT A92A4152\nA92A4140  MOV     ECX, DWORD PTR SS:[EBP+18]\nA92A4143  CMP     ECX, EBX\nA92A4145  JE      SHORT A92A4152\nA92A4147  MOV     DWORD PTR DS:[ECX], 320      <------------\nA92A414D  MOV     DWORD PTR DS:[ESI+4], EAX\nA92A4150  JMP     SHORT A92A4158\nA92A4152  MOV     DWORD PTR DS:[ESI], C000000D\nA92A4158  MOV     AL, 1\nA92A415A  CALL    A92A46D5\nA92A415F  RETN    24\n\n```\nThe driver analysed here is the driver loaded by dbgview (dbgv.sys) from SysInternals. This control code checks for an incompatible version of driver loaded in memory. Follow through can be practiced with the specific driver and specific version:\n\n```\n(4.75) build time Thu Aug 07 04:51:27 2008\n\n```\nWith windbg inastalled you can do the same with just few commands as posted below\n\n```\nC:\\>tlist | grep -i dbgview\n\n3724 Dbgview.exe       DebugView on \\\\ (local)\n\nC:\\>kd -kl -c \".foreach /pS 1 /ps 4 (place  { .shell -ci \\\"!handle 0 3 0n3724 Fi\nle \\\" grep File } ) {dt nt!_FILE_OBJECT -y Dev->Dri->DriverS place};q\" | grep -i\n +0x00c\n +0x00c DriverStart       : 0xf7451000 Void  \n +0x00c DriverStart       : 0xf73c5000 Void   \n +0x00c DriverStart       : 0xa87f9000 Void   \n +0x00c DriverStart       : 0xf7451000 Void   \n +0x00c DriverStart       : 0xf7451000 Void   \n\nC:\\>kd -kl -c \".reload ; lm a (0xf7451000); lm a (0xf73c5000) ; lm a (0xa87f9000);q\" | grep -i defer\n\n f7451000 f746f880   ftdisk     (deferred)    \n f73c5000 f73db880   KSecDD     (deferred)    \n a87f9000 a87fcd00   Dbgv       (deferred)    \n\n\nC:\\>kd -kl -c \".writemem  malware.sys a87f9000 a87fcfff ;q\" | grep -A 1 lkd\n\n lkd> kd: Reading initial command '.writemem  malware.sys a87f9000 a87fcfff ;q'     \n Writing 4000 bytes........    \n\nC:\\>file malware.sys  \n\n malware.sys; PE32 executable for MS Windows (native) Intel 80386 32-bit   \n\n```\nAn explanation for the commands above as follows\n\n```\nkd -kl is local kernel debugging\n\n!handle command has the capability to search for kernel handle  \nwhen you input a Pid \n\nThe explanation for arguments for this commands are \n\n 0 = all handles \n 3 = default flag provides basic+object information\n 0n3724 = pid (can be from task manager\n File = type of Object to search for \n\n\n!dt can display memebers of nested structures with ease \n-y with dt takes partial inputs (wild card entries ) \n and displays  all matching structure members \n\nand the output is manipulatable with any text / stream handling \nsoftware like grep , sed . awk . find etc\n\n```\n",
      "votes": "15",
      "user": "perror",
      "time": "Apr 12, 2014 at 7:44",
      "is_accepted": true,
      "comments": [
        {
          "user": "fileoffset",
          "text": "Lot's of good tips here!",
          "time": null
        }
      ]
    },
    {
      "content": "More specifically, it sounds like your executable is loading a Device Driver.  Userspace executables often communicates with drivers via IOCTLs (or I/O Controls).\n\nDeviceIoControl does just that: sends an IOCTL to the driver.  Note the second parameter to this function: DWORD dwIoControlCode.  This is the code that identifies which IOCTL the program is requesting the driver to perform.  It is just a 32-bit DWORD value.\n\nNow, on the driver side there are a few things you need to know. (Be prepared to swim through a few structures!)\n\nWhen a driver is first loaded, its DriverEntry function will be called. This is passed a pointer to the driver's DRIVER_OBJECT.  In this structure there is an array named MajorFunction, which is a set of function pointers that the kernel will call when userspace tries to do something with the driver (e.g. Open, Close, or send IOCTL). These functions are identified by IRP Major Function Codes.\n\nIn the case of ioctls sent by DeviceIoControl, the IRP_MJ_DEVICE_CONTROL function is called. This function is called for any ioctl.  Now to determine which dwIoControlCode was passed to DeviceIoControl, the ioctl-handling function will look at Parameters.DeviceIoControl.IoControlCode.\n\nFrom this value, there is often a switch-statement which selects different behavior depending on the control code.\n\nSo first, you want to load up the .sys driver into IDA. The function that IDA marks as DriverEntry is really a wrapper generated by the DDK. The real DriverEntry is usually jmp'd to at the end of this stub.\n\nIn the real DriverEntry, you'll want to locate where the MajorFunction entries are populated. It might look something like this:\n\n\n\n",
      "votes": "9",
      "user": "Jonathon Reinhart",
      "time": "Mar 26, 2014 at 5:49",
      "is_accepted": false,
      "comments": []
    }
  ]
}