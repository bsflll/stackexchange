{
  "title": "Why can't you edit pseudo code?",
  "link": "https://reverseengineering.stackexchange.com/questions/25640/why-cant-you-edit-pseudo-code",
  "content": "Dabbler in re here, so potentially a stupid question...\nI know ida, binary ninja, and ghidra are really powerful at generating pseudo code.\nFrom everything I've read pseudo code can't be edited in realtime but can be edited as assembly, I was just wondering why you couldn't do a similar process to the one below?\n\nAlternatively,\n\nI know this method wouldn't be fast... but I am surprised no one has tried a method like this as far as I'm aware? Am I just missing something obvious?\n\n",
  "votes": "3",
  "answers": 3,
  "views": "9k",
  "tags": [
    "ida",
    "ghidra"
  ],
  "user": "Spyindabox",
  "time": "Aug 13, 2020 at 13:33",
  "comments": [
    {
      "user": "0xC0000022L",
      "text": "Hi and welcome to RE.SE! IDA creates no pseudo-code. IDA is a pure disassembler. To get anything like pseudo-code you'll have to shell out twice the amount you pay for IDA itself for the Hex-Rays plugin (single architecture, for further architectures discounts apply) or you have to build and install something like the RetDec plugin.",
      "time": null
    },
    {
      "user": "Heath Mitchell",
      "text": "I'm working on this, which currently is just a proof of concept but shows that it's possible: reddit.com/r/ghidra/comments/sbqnwf/â€¦",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "This is not entirely correct. Quite the opposite even: Decompilers cannot be perfect (the compilation step looses too much information). Hence they need some help by a human (the reverse engineer). Giving this help is, at least in my opinion, the most important step during reverse engineering: get data types right. Sure, renaming variables helps a lot with readability, but the decompiler doesn't really need it. Changing the type of a variable or function though, feeds information back into the decompiler, which then can run another pass and improve the result. This result can then again further be improved by the human. If I would need to name the most important step during static binary reverse engineering, I would call out this cycle: decompile, re-type, repeat.\n\nNow that we got this out of the way, I'll try to address the suggested steps you propose: I am not entirely sure I understand what you mean but I think a huge problem arises in step 2/4:\n\ncode generated by a decompiler is not really C/C++ code. Formally, it only qualifies as pseudo-code that has a C-like syntax. The differences between valid C and \"decompiler C\" depends on your decompiler of course (Hex-Rays, Binary Ninja, Ghidra), but to give a simple examples (there are more, many of which are far more serious): If Ghidra's decompiler is not sure what data type a given variable is, it will assign the \"type\" undefined. This is not a valid data type in C of course, and hence cannot be compiled into an executable (i.e. step 4 fails).\n\n",
      "votes": "8",
      "user": "0xC0000022L",
      "time": "Aug 10, 2020 at 9:07",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "@born brings up some great points, but I do think it's definitely worth saying there's not much inherently impossible about the whole idea. Compiling and grabbing assembly is likely not the best bet, though.\n\nPassing the entire thing off as impossible is just not right. IDA clearly has potential in the area; Select psuedocode and click \"Copy to Assembly\". It'll generate comments in the assembly that map it to where the psuedocode functions come from.\n\nHere's a comparison of the three different relevant phases of a program; source, psuedocode, and ASM:\n\nSource (clang -w -o test) :\n\n```\nint main(void)\n{\n  printf(\"hello world\");\n}\n\n```\nNote the incorrect, but functional, use of printf(\"string\") instead of printf(\"%s\", \"string\"). This is another debate, but it'll screw up decompilation\n\nDecompilation By IDA (psuedocode):\n\n```\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  printf(\"hello world\", argv, envp);\n  return 0;\n}\n\n```\nThis is just wrong. printf won't accept those values, it's expecting 0 extra arguments due to a lack of formatting \"%s\" strings in \"hello world\". A simple mistake has screwed up the psuedocode output.\n\nDisassembly by IDA (note some of these instructions might not be right)\n\n```\npush    rbp\nmov     rbp, rsp\nsub     rsp, 10h\n; 2:   printf(\"hello world\", argv, envp);\nlea     rdi, aHelloWorld ; \"hello world\"\nmov     al, 0\ncall    _printf\n; 3:   return 0;\nxor     ecx, ecx\nmov     [rbp+var_4], eax\nmov     eax, ecx\nadd     rsp, 10h\npop     rbp\nretn\n\n```\nLet's say you wanted to edit the string:\nSure, just edit the place it references. Oh, but you want one longer than 11 characters, so you'll need to find somewhere unused and map the string pointer to that address instead. That's complicated.\n\nThe entire executable section of the program is 12 instructions long, too. You have almost no space to change anything, and adding stuff is an entirely different ballgame.\n\nLikely Reasons it hasn't been done\n\nI don't think it's anywhere near impossible though. Not by compiling for sure. But what you could try, is something like these:\n\nBoth of these require an understanding of assembly to verify the patches were correct; A wrong one will grind your program to a halt, and no tool doing this will be reliably correct.\n\n#2 still has flaws. I've spent 2+ hours perfecting decompilation/disassembly on a single function; everything in memory properly named, manually defined every struct, etc. Even with perfect decompilation, it still needs work to be compiled.\n\nMaybe you could do that work yourself in some complex script. This is a problem I'd recommend revisiting when you're experienced; it's a really interesting topic, and IDAPython might make it almost feasible.\n\n",
      "votes": "0",
      "user": "kat",
      "time": "Aug 13, 2020 at 9:18",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "for editing in every owning pseudo code do think psychology corelations of it and then you get the human meaning for those who didnt change indetity based on it\nonly for who didnt read\n\nbut if code is not accessible (no pseudo code) you can make a dictionary of character to binary and to its functions on the cpu that have high performance on java or python(slow)\n\n",
      "votes": "-6",
      "user": "Noam lima",
      "time": "Aug 10, 2020 at 20:03",
      "is_accepted": false,
      "comments": []
    }
  ]
}