{
  "title": "How to recover information stored in .ctors section?",
  "link": "https://reverseengineering.stackexchange.com/questions/6285/how-to-recover-information-stored-in-ctors-section",
  "content": "Test is on x86, 32-bit Linux. I am using g++ 4.6.3 and objdump 2.22\n\nHere is a simple C++ code I am working on:\n\n```\n#include <iostream>\n\nusing namespace std;\n\nmain()\n{\n    cout << \"Hello World!\" << endl;\n    return 0;\n}\n\n```\nWhen I compile it into assembly code using :\n\n```\ngcc -S hello.cc\n\n```\nI can find out a ctors section in the hello.s below:\n\n```\n.section    .ctors,\"aw\",@progbits\n.align 4\n.long   _GLOBAL__sub_I_main\n.weakref    _ZL20__gthrw_pthread_oncePiPFvvE,pthread_once\n.weakref    _ZL27__gthrw_pthread_getspecificj,pthread_getspecific\n.weakref    _ZL27__gthrw_pthread_setspecificjPKv,pthread_setspecific\n.weakref    _ZL22__gthrw_pthread_createPmPK14pthread_attr_tPFPvS3_ES3_,pthread_create\n.weakref    _ZL20__gthrw_pthread_joinmPPv,pthread_join\n.weakref    _ZL21__gthrw_pthread_equalmm,pthread_equal\n.weakref    _ZL20__gthrw_pthread_selfv,pthread_self\n.weakref    _ZL22__gthrw_pthread_detachm,pthread_detach\n.weakref    _ZL22__gthrw_pthread_cancelm,pthread_cancel\n.weakref    _ZL19__gthrw_sched_yieldv,sched_yield\n.weakref    _ZL26__gthrw_pthread_mutex_lockP15pthread_mutex_t,pthread_mutex_lock\n.weakref    _ZL29__gthrw_pthread_mutex_trylockP15pthread_mutex_t,pthread_mutex_trylock\n.weakref    _ZL31__gthrw_pthread_mutex_timedlockP15pthread_mutex_tPK8timespec,pthread_mutex_timedlock\n.weakref    _ZL28__gthrw_pthread_mutex_unlockP15pthread_mutex_t,pthread_mutex_unlock\n.weakref    _ZL26__gthrw_pthread_mutex_initP15pthread_mutex_tPK19pthread_mutexattr_t,pthread_mutex_init\n.weakref    _ZL29__gthrw_pthread_mutex_destroyP15pthread_mutex_t,pthread_mutex_destroy\n.weakref    _ZL30__gthrw_pthread_cond_broadcastP14pthread_cond_t,pthread_cond_broadcast\n.weakref    _ZL27__gthrw_pthread_cond_signalP14pthread_cond_t,pthread_cond_signal\n.weakref    _ZL25__gthrw_pthread_cond_waitP14pthread_cond_tP15pthread_mutex_t,pthread_cond_wait\n.weakref    _ZL30__gthrw_pthread_cond_timedwaitP14pthread_cond_tP15pthread_mutex_tPK8timespec,pthread_cond_timedwait\n.weakref    _ZL28__gthrw_pthread_cond_destroyP14pthread_cond_t,pthread_cond_destroy\n.weakref    _ZL26__gthrw_pthread_key_createPjPFvPvE,pthread_key_create\n.weakref    _ZL26__gthrw_pthread_key_deletej,pthread_key_delete\n.weakref    _ZL30__gthrw_pthread_mutexattr_initP19pthread_mutexattr_t,pthread_mutexattr_init\n.weakref    _ZL33__gthrw_pthread_mutexattr_settypeP19pthread_mutexattr_ti,pthread_mutexattr_settype\n.weakref    _ZL33__gthrw_pthread_mutexattr_destroyP19pthread_mutexattr_t,pthread_mutexattr_destroy\n\n```\nHowever, when I assembly the asm code, producing an exe file and use the objdump produce the ctors section's contain like this:\n\n```\nobjdump -Dr -j .ctors hellocpp\n\n```\nAll I can get is like this:\n\n```\nhellocpp:     file format elf32-i386\n\n\nDisassembly of section .ctors:\n\n08049efc <__CTOR_LIST__>:\n 8049efc:   ff                      (bad)  \n 8049efd:   ff                      (bad)  \n 8049efe:   ff                      (bad)  \n 8049eff:   ff 00                   incl   (%eax)\n\n08049f00 <__CTOR_END__>:\n 8049f00:   00 00                   add    %al,(%eax)\n ...\n\n```\nCurrently I am trying to recover the content of some ELF binaries compiled from c++ program..\n\nSo I am wondering if there is a way to get the content of ctors which equals to what g++ produced?\n\nThanks a lot for @Igor's help. But I am still trapped in looking for class's constructor and destructor  info from ELF binary.\n\nWhen evolving class definition, g++ would produce these info in the .ctors section:\n\n```\n    .globl  _ZN8ComputerC1Ev\n    .set    _ZN8ComputerC1Ev,_ZN8ComputerC2Ev\n    .globl  _ZN8ComputerD1Ev\n    .set    _ZN8ComputerD1Ev,_ZN8ComputerD2Ev\n\n```\nGenerally _ZN8ComputerC2Ev is the name of a class's constructor while _ZN8ComputerD2Ev is its  destructor.\n\nHowever, I just can not find corresponding info in the objdump dumped .ctors or .init_array sections.. I also tried .eh_frame and gcc_except_table, but the information dumped is massive.. I can not figure out the meaning of those information..\n\nCould anyone give me guide?\n\n",
  "votes": "7",
  "answers": 2,
  "views": "4k",
  "tags": [
    "disassembly",
    "x86",
    "c++",
    "elf"
  ],
  "user": "lllllllllllll",
  "time": "Jun 17, 2020 at 9:54",
  "comments": [],
  "answers_data": [
    {
      "content": "The .ctors section is a list of pointers terminated with -1 (0xFFFFFFFF), so it does not make sense to disassemble it. If you rearrange the bytes as data, you get:\n\n```\n__CTOR_LIST__: .long 0xffffffff\n__CTOR_END__:  .long 0x00000000\n\n```\nSo, for whatever reason, the resulting exe does not actually use the .ctors section. I suspect the linker instead placed the pointers into the new-style .init_array section. Note that it is, again, a list of pointers, and not code.\n\nEdit:\n\nThe .ctors or .init_array sections only contain so-called constructor functions - functions that need to be executed at startup, before the main() itself. These are usually compiler-generated functions that perform construction of global objects (such as cin, cout etc.), or other startup-related tasks. You can, in fact, add your own functions to that list using __attribute__((constructor)).\n\nWhat does not go there are general C++ class constructors - there is no need to execute those on startup. They will be called when and if you construct an object of a specific class - e.g. by declaring a variable or calling operator new.\n\n",
      "votes": "9",
      "user": "Community",
      "time": "May 23, 2017 at 12:37",
      "is_accepted": true,
      "comments": [
        {
          "user": "lllllllllllll",
          "text": "Groovy! I dump the content of .init_array section and it contains the address of _GLOBAL__sub_I_main function!",
          "time": null
        }
      ]
    },
    {
      "content": "As Igor stated, the .ctors section is a list of function pointers, ending with a sentinel value of 0xffffffff. To see its contents, just do\n\n```\n$ objdump -s -j.ctors bar.so\n\n```\nBut your assembly file only contains weak symbols. Those are foreign functions in other libraries, and are invoked when their libraries are loaded at runtime.\n\nFor example, put this in a file bar.cpp:\n\n```\nclass Foo {\npublic:\n  int i;\n\n  Foo(int n) : i(n) {\n  }\n};\n\nFoo global_foo(123);\n\n```\nCompile with\n\n```\n$ g++ -shared -fPIC bar.cpp -obar.so\n\n```\nThe contents of the .init_array section is\n\n```\n$ objdump -s -j.init_array bar.so\n\nbar.so:     file format elf64-x86-64\n\nContents of section .init_array:\n 200820 ad060000 00000000                    ........        \n\n```\nThere's a function pointer there, 0xad060000 00000000. But you have to change its endianness, e.g. with Python:\n\n```\n>>> import struct\n>>> import binascii\n>>> binascii.hexlify(struct.pack(\"<Q\", 0xad06000000000000))\n'00000000000006ad'\n\n```\nNow list all symbols and grep for that address:\n\n```\n$ objdump -C --syms bar.so | grep 00000000000006ad\n00000000000006ad l     F .text  0000000000000015\n  [... on above line ...] global constructors keyed to bar.cpp\n\n```\nThe disassembly for it,\n\n```\n$ objdump -C -d bar.so\n\n```\nshows\n\n```\n00000000000006ad <global constructors keyed to bar.cpp>:\n 6ad:   55                      push   %rbp\n 6ae:   48 89 e5                mov    %rsp,%rbp\n 6b1:   be ff ff 00 00          mov    $0xffff,%esi\n 6b6:   bf 01 00 00 00          mov    $0x1,%edi\n 6bb:   e8 ba ff ff ff          callq  67a <__static_initialization_and_destruction_0(int, int)>\n 6c0:   c9                      leaveq \n 6c1:   c3                      retq   \n\n```\nwhich jumps to __static_initialization_and_destruction_0(int, int):\n\n```\n000000000000067a <__static_initialization_and_destruction_0(int, int)>:\n 67a:   55                      push   %rbp\n 67b:   48 89 e5                mov    %rsp,%rbp\n 67e:   48 83 ec 10             sub    $0x10,%rsp\n 682:   89 7d fc                mov    %edi,-0x4(%rbp)\n 685:   89 75 f8                mov    %esi,-0x8(%rbp)\n 688:   83 7d fc 01             cmpl   $0x1,-0x4(%rbp)\n 68c:   75 1d                   jne    6ab <__static_initialization_and_destruction_0(int, int)+0x31>\n 68e:   81 7d f8 ff ff 00 00    cmpl   $0xffff,-0x8(%rbp)\n 695:   75 14                   jne    6ab <__static_initialization_and_destruction_0(int, int)+0x31>\n 697:   be 7b 00 00 00          mov    $0x7b,%esi\n 69c:   48 8b 05 9d 03 20 00    mov    0x20039d(%rip),%rax        # 200a40 <_DYNAMIC+0x1e8>\n 6a3:   48 89 c7                mov    %rax,%rdi\n 6a6:   e8 f5 fe ff ff          callq  5a0 <Foo::Foo(int)@plt>\n 6ab:   c9                      leaveq \n 6ac:   c3                      retq   \n\n```\nwhich puts 123 (0x7b) on the stack and calls Foo::Foo(int).\n\n",
      "votes": "5",
      "user": "csl",
      "time": "Jun 3, 2016 at 9:02",
      "is_accepted": false,
      "comments": []
    }
  ]
}