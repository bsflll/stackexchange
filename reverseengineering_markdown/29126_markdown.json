{
  "title": "How to identify method order in disassembled C++ object",
  "link": "https://reverseengineering.stackexchange.com/questions/29126/how-to-identify-method-order-in-disassembled-c-object",
  "content": "Here are some chunks:\n\n```\n  v13 = cocos2d::FileUtils::getInstance(v9);\n  (*(void (__fastcall **)(char *))(*(_DWORD *)v13 + 64))(&v46);\n\n  v19 = cocos2d::FileUtils::getInstance(fileHandle);\n  v21 = *(void (__fastcall **)(char *, int, unsigned __int8 *))(*(_DWORD *)v19 + 28);\n  v21(&v44, v20, &v42);\n\n  v23 = cocos2d::FileUtils::getInstance(v22),\n  v24 = (cocos2d::FileUtils *)(*(int (**)(void))(*(_DWORD *)v23 + 152))(),\n\n```\ncocos2d is an open source project, and I have downloaded it, but I have no idea how to determine what the order of the methods are.  So, how do I identify what method 28, 64, or 152 really is?  (Dead-listings only, can't execute the code to find the answer).\n\n",
  "votes": "0",
  "answers": 2,
  "views": "238",
  "tags": [
    "disassembly",
    "c++"
  ],
  "user": "FrankRizzo",
  "time": "Aug 11, 2021 at 1:11",
  "comments": [
    {
      "user": "mindoverflow",
      "text": "This looks more like a decompilation, but that's besides the point. Is this snippet from the library/dll itself or from a program written using the library?",
      "time": null
    },
    {
      "user": "FrankRizzo",
      "text": "The above is a Hex Rays \"Pseudo-C\" decompilation of some code from an .SO that has statically linked against the Cocos2D library.  I've picked up a little more information about it.  This is the method used to call virtual C++ methods.  But the question still remains.  How do I work out WHICH virtual C++ method these refer to.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "I presume the binary is fully optimized and stripped of debug info\nMy answer pertains to a windows binary (ex getinst.exe) but the generic concept applies to elf (ex foo.so )\n\nsome base presumptions about cocos2d from google are\n\nFileUtils* s_sharedFileUtils\nstaticprotected\nThe singleton pointer of FileUtils.\n\nshown below is a bare minimum proof of concept singleton c++ code\n\n```\n:\\>type getinst.cpp\n#include <iostream>\nusing namespace std;\nclass Singleton\n{\n        static Singleton *instance;\n        Singleton() {}\npublic:\n        static Singleton *getInstance()\n        {\n                if (!instance)\n                        instance = new Singleton;\n                return instance;\n        }\n        virtual void funcone() { cout << \"funcone  \n\"; }\n        virtual void functwo() { cout << \"functwo  \n\"; }\n        virtual void functre() { cout << \"functre  \n\"; }\n        virtual void funcfor() { cout << \"funcfor  \n\"; }\n};\nSingleton *Singleton::instance = nullptr;\nint main()\n{\n        Singleton *s = s->getInstance();\n        s->funcone();\n        s->functwo();\n        s->functre();\n        s->funcfor();\n        return 0;\n}\n\n```\ncompilation and linking with vs2017 as 32bit (x86) Full Optimization and nodebuginfo\n\n```\n:\\>type complink.bat\ncl /W4 /analyze:autolog- /EHsc /Ox /nologo getinst.cpp /link /release\n\n```\ncontents of Directory pre and post compilation and execution of compiled binary\n\n```\n:\\>ls -lg\ntotal 5\n-rw-r--r-- 1 197121  69 Aug 15 09:43 complink.bat\n-rw-r--r-- 1 197121 603 Aug 15 09:24 getinst.cpp\n\n:\\>complink.bat\n\n:\\>cl /W4 /analyze:autolog- /EHsc /Ox /nologo getinst.cpp /link /release\ngetinst.cpp\n\n:\\>ls -lg\ntotal 261\n-rw-r--r-- 1 197121     69 Aug 15 09:43 complink.bat\n-rw-r--r-- 1 197121    603 Aug 15 09:24 getinst.cpp\n-rwxr-xr-x 1 197121 183808 Aug 15 09:49 getinst.exe\n-rw-r--r-- 1 197121  76677 Aug 15 09:49 getinst.obj\n\n:\\>getinst.exe\nfuncone\nfunctwo\nfunctre\nfuncfor\n\n```\nlets dig into disassembly / find The RTTI / rename / etc\n\nusing a hex editor search for pattern \".?A\"\nI am using xxd a Commandline hex dumper\n\nalso I am providing a partial name .?AVSing to illustrate the point\nbut on an unknown binary  you maybe forced to analyze all the results of .?A\n\n```\n:\\>xxd -g 4 getinst.exe |grep -B 1 -i \".?AVSing\"\n0002a8e0: 676f7279 40737464 40400000 8cf44100  gory@std@@....A.\n0002a8f0: 00000000 2e3f4156 53696e67 6c65746f  .....?AVSingleto\n\n```\nthe Address of Partial Mangled class name Starts at 0x2a8f8\n( &StartofPattern + 4) == ( 0x2a8f4 + 4 ) == Singleton@@\n\n```\n:\\>xxd -s 0x2a8f8 -l 16 getinst.exe\n0002a8f8: 5369 6e67 6c65 746f 6e40 4000 8cf4 4100  Singleton@@...A. \n\n```\nPrepend ??_7 and Append 6B@ to this partial Mangled name\npass the conacatenated string to undname.exe or c++filt or demangler.com to get a Demangled or undecorated Name\n\n```\n:\\>undname ??_7Singleton@@6B@\nMicrosoft (R) C++ Name Undecorator\nCopyright (C) Microsoft Corporation. All rights reserved.\n\nUndecoration of :- \"??_7Singleton@@6B@\"\nis :- \"const Singleton::`vftable'\" \n\n```\nThis Class name is part of a Structure Called _TypeDescriptor\nhttps://www.geoffchappell.com/studies/msvc/language/predefined/\n\n```\ntypedef struct _TypeDescriptor\n{\n    const void *pVFTable;\n    void *spare;\n    char name []; <<<<<<<<<<<<<<\n} _TypeDescriptor;\n\n```\nwhich is a member of another structure\n\n```\ntypedef const struct _s__RTTICompleteObjectLocator {\n    unsigned long signature;\n    unsigned long offset;\n    unsigned long cdOffset;\n    _TypeDescriptor *pTypeDescriptor; <<<<<<<<<<\n    __RTTIClassHierarchyDescriptor *pClassDescriptor;\n} __RTTICompleteObjectLocator;\n\n```\nfind the cross references to these two structures\nif the offset member is == 0 (SINGLE INHERITANCE)\nthe vtable follows the __RTTICompleteObjectLocator with methods\n\nfrom the dump above\n\n```\n _TypeDescriptor.name       = 0x2a8f4\n _TypeDescriptor.spare      = 0x2a8f0\n  _TypeDescriptor.pVFTable  = (FO) 0x2a8ec -> 0x42baec (VA)\n  FO = FileOffset ,VA = VirtualAddress\n  VA == python -c \"print(hex(0x2a8ec-0x29e00+0x42b000))\" \n\n```\nfind xref to 0x42baec There Are 2 xrefs\n\n```\n  :\\>xxd -g4 getinst.exe | grep ecba4200\n00027e90: 00000000 00000000 ecba4200 a08c4200  ..........B...B.\n00027eb0: b88c4200 00000000 ecba4200 00000000  ..B.......B.....\n\n```\nFrom First Cross Reference\n\n```\n__RTTICompleteObjectLocator->pTypeDescriptor    = 0x27e98\n__RTTICompleteObjectLocator.cdOffset            = 0x27e94\n__RTTICompleteObjectLocator.offset              = 0x27e90\n__RTTICompleteObjectLocator.signature           = 0x27e8c\n\n```\nfind cross reference  to VA of 0x27e8c\n\n```\ndumpbin /SECTION:.rdata getinst.exe\n\nSECTION HEADER #2\n  .rdata name\n    EA7E virtual size\n   1C000 virtual address (0041C000 to 0042AA7D)\n    EC00 size of raw data\n   1B200 file pointer to raw data (0001B200 to 00029DFF)\n\n\npython -c \"print(hex(0x27e8c-0x1b200+0x41c000))\"\n0x428c8c\n\n:\\>xxd -g4 getinst.exe | grep 8c8c4200\n0001b470: 66626974 20736574 00000000 8c8c4200  fbit set......B.\n\n```\nthe methods follow 0x1b47c at 0x1b480\n\n```\n:\\>xxd -g 4 -s 0x1b480 -l 64  getinst.exe\n0001b480: 50204000 90204000 70204000 30204000  P @.. @.p @.0 @.\n0001b490: 66756e63 6f6e650a 00000000 66756e63  funcone.....func\n0001b4a0: 74776f0a 00000000 66756e63 7472650a  two.....functre.\n0001b4b0: 00000000 66756e63 666f720a 00000000  ....funcfor.....\n\n```\n4 methods\n\n```\n0x402050 \n0x402090\n0x402070\n0x402030\n\n```\ndisasm of the methods\n\n```\n:\\>dumpbin /disasm /range:0x402030,0x4020b0 getinst.exe\n\n  00402030: 68 B4 C2 41 00     push        41C2B4h == 0x1b4b4 == funcfor\n  00402035: 68 48 BE 42 00     push        42BE48h\n  0040203A: E8 E1 F0 FF FF     call        00401120\n  0040203F: 83 C4 08           add         esp,8\n  00402042: C3                 ret\n  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  00402050: 68 90 C2 41 00     push        41C290h  \n  :\\>python -c \"print(hex(0x1b490-0x1b200+0x41c000))\"\n    0x41c290  \n   :\\>dumpbin /rawdata /range:0x41c290,0x41c29f getinst.exe\n  0041C290: 66 75 6E 63 6F 6E 65 0A 00 00 00 00 66 75 6E 63  funcone.....func\n  \n  00402055: 68 48 BE 42 00     push        42BE48h\n  0040205A: E8 C1 F0 FF FF     call        00401120\n  0040205F: 83 C4 08           add         esp,8\n  00402062: C3                 ret\n  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  00402070: 68 A8 C2 41 00     push        41C2A8h == 0x1b4a8 == functre\n  00402075: 68 48 BE 42 00     push        42BE48h\n  0040207A: E8 A1 F0 FF FF     call        00401120\n  0040207F: 83 C4 08           add         esp,8\n  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  00402090: 68 9C C2 41 00     push        41C29Ch == 0x1b492 == functwo\n  00402095: 68 48 BE 42 00     push        42BE48h\n  0040209A: E8 81 F0 FF FF     call        00401120\n  0040209F: 83 C4 08           add         esp,8\n  004020A2: C3                 ret\n  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\n```\nthe 4 methods retrieved without symbol information using basic tools and manual fishing.\n\nhope you can apply this to your cocos2d\n\n",
      "votes": "1",
      "user": "blabb",
      "time": "Aug 15, 2021 at 23:05",
      "is_accepted": false,
      "comments": [
        {
          "user": "FrankRizzo",
          "text": "This is BY FAR the most incredible answer I've ever seen here.  The amount of work required is STAGGERING!  The ONLY thing that makes it less than 100% ideal for my question is that my instance is in a Linux .SO compiled for ARM.  :-\\",
          "time": null
        }
      ]
    },
    {
      "content": "If you are using IDA Pro, there are plugins to reconstruct the RTTI (runtime type identification) of the classes you are interested in. Take a look at medigate. There are other similar plugins as well which you can find on the web.\n\n",
      "votes": "0",
      "user": "Jack",
      "time": "Aug 27, 2021 at 6:07",
      "is_accepted": false,
      "comments": []
    }
  ]
}