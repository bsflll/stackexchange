{
  "title": "Image decompression: Reconstructed LZW dictionary somewhat, not exactly matches original dictionary",
  "link": "https://reverseengineering.stackexchange.com/questions/30606/image-decompression-reconstructed-lzw-dictionary-somewhat-not-exactly-matches",
  "content": "I am attempting to reverse an animation format that uses (I think) some form of LZW for each of the frames.\n\nI have determined that a 12-bit code is used throughout the image. Here is a short target image with the code words separated out:\n\n```\n[0x0ff, 0x100, 0x101, 0x102, 0x103, 0x104, 0x104, 0x02f, 0x106, 0x02f, 0x105, 0x108, 0x109, 0x10a, 0x10b, 0x107, 0x10c, 0x106, 0x10b, 0x10e, 0x10f, 0x103, 0x10d, 0x111, 0x02f, 0x110, 0x113, 0x109, 0x112, 0x01c, 0x116, 0x01c, 0x10c, 0x114, 0x119, 0x100, 0x111, 0x117, 0x11c, 0x118, 0x107, 0x11a, 0x110, 0x11b, 0x11c, 0x01d, 0x122, 0x116, 0x10c, 0x11f, 0x10b, 0x120, 0x117, 0x122, 0x128, 0x117, 0x107, 0x125, 0x108, 0x126, 0x116, 0x128, 0x123, 0x11c, 0x107, 0x12b, 0x103, 0x12c, 0x01c, 0x12e, 0x01d, 0x11d, 0x124, 0x106, 0x131, 0x100, 0x132, 0x134, 0x136, 0x137, 0x106, 0x131, 0x139, 0x12e, 0x13b, 0x12a, 0x107, 0x125, 0x13d, 0x129, 0x13f, 0x13c, 0x02f, 0x11f, 0x141, 0x12f, 0x143, 0x13c, 0x105, 0x112, 0x103, 0x10d, 0x11d, 0x13a, 0x147, 0x130, 0x107, 0x102, 0x112, 0x107, 0x102, 0x10c, 0x01b, 0x121, 0x142, 0x14b, 0x14c, 0x14d, 0x154, 0x100, 0x14e, 0x14f, 0x152, 0x157, 0x154, 0x106, 0x153, 0x02f, 0x0ff, 0x107, 0x01b, 0x15d, 0x156, 0x157, 0x14b, 0x14d, 0x13b, 0x107, 0x0ff, 0x107, 0x01c, 0x15e, 0x160, 0x167, 0x13b, 0x13e, 0x11e, 0x10c, 0x116, 0x166, 0x168, 0x168, 0x134, 0x123, 0x115, 0x15e, 0x15f, 0x16f, 0x170, 0x172, 0x106, 0x0ff, 0x164, 0x165, 0x16e, 0x176, 0x17c, 0x107, 0x0ff, 0x16c, 0x17a, 0x15d, 0x17c, 0x17d, 0x106, 0x100, 0x17e, 0x174, 0x181, 0x16f, 0x107, 0x101, 0x183, 0x17b, 0x157, 0x180, 0x186, 0x106, 0x102, 0x187, 0x18a, 0x152, 0x174, 0x175, 0x152, 0x107, 0x103, 0x18c, 0x190, 0x13b, 0x18f, 0x188, 0x147, 0x107, 0x104, 0x192, 0x147, 0x17b, 0x18f, 0x14b, 0x01b, 0x107, 0x105, 0x198, 0x194, 0x180, 0x179, 0x195, 0x19f, 0x106, 0x109, 0x192, 0x175, 0x184, 0x126, 0x1a2, 0x16d, 0x15d, 0x106, 0x10a, 0x1a4, 0x1a2, 0x107, 0x0ff, 0x120, 0x195, 0x15e, 0x107, 0x10b, 0x1ab, 0x1a6, 0x106, 0x101, 0x1ad, 0x195, 0x107, 0x10e, 0x1b0, 0x14f, 0x107, 0x104, 0x1b2, 0x1a0, 0x106, 0x10f, 0x1b0, 0x16b, 0x108, 0x12c, 0x107, 0x113, 0x1a4, 0x16b, 0x02f, 0x10a, 0x159, 0x02f, 0x114, 0x18c, 0x13c, 0x10f, 0x14d, 0x11a, 0x148, 0x140, 0x106, 0x113, 0x10c, 0x12b, 0x1bc, 0x138, 0x11f, 0x154, 0x1c0, 0x12b, 0x10d, 0x1c1, 0x101, 0x1c4]\n\n```\nBased on the understanding I gained from this example and this one, I wrote the following decoder for just the compressed image stream:\n\n```\n#!/bin/python3\n\nimport bitstring\n\ndef decompress_frame(data):\n    compressed_stream = bitstring.ConstBitStream(data)\n    bitmap_stream = []\n\n    # INITIALIZE THE CODEBOOK.\n    # The codebook should be initailized to the literal values 0x00 to 0xff in index order.\n    code_book = []\n    for initial_code in range(0x000, 0x100):\n        code_book.append([initial_code])\n\n    # DECODE THE FIRST PIXEL.\n    # A 12-bit code is used throughout the image - no larger, no smaller.\n    CODE_LENGTH: int = 12\n    # The first pixel is always interpreted as a literal pixel.\n    code_word = compressed_stream.read(CODE_LENGTH).uint\n    bitmap_stream.append(code_word)\n    previous_code_word = code_word\n    while True:\n        # READ THE NEXT CODE WORD.\n        try:\n            code_word = compressed_stream.read(CODE_LENGTH).uint\n        except bitstring.ReadError:\n            print(\"Out of bits\")\n            break\n\n        # CHECK IF THE CODE WORD IS IN THE CODEBOOK.\n        code_word_in_code_book = code_word < len(code_book)\n        if code_word_in_code_book:\n            # WRITE THE LITERAL PIXELS FOR THIS CODE WORD.\n            literal_pixels = code_book[code_word]\n            bitmap_stream.extend(literal_pixels)\n\n            # ADD THE NEXT CODE TO THE CODEBOOK.\n            # When the code word is already in the codebook, the next code is formed by \n            # the previous code word and the first pixel of this code word.\n            previous_code_word_pixels = code_book[previous_code_word]\n            code_word_first_pixel = [code_book[code_word][0]]\n            code_string = previous_code_word_pixels + code_word_first_pixel\n            code_book.extend([code_string])\n        else:\n            # ADD THE NEXT CODE TO THE CODEBOOK.\n            # When the code word is not in the codebook, add a code word formed by\n            # the literal pixel string for the previous code word followed by the first \n            # literal pixel for the previous code word.\n            previous_code_word_pixels = []\n            previous_code_word_pixels = code_book[previous_code_word]\n            previous_code_word_first_pixel = [code_book[previous_code_word][0]]\n            code_string = previous_code_word_pixels + previous_code_word_first_pixel\n            code_book.extend([code_string])\n\n            # WRITE THE LITERAL PIXELS FOR THE ADDED CODE WORD.\n            bitmap_stream.extend(code_string)\n\n        previous_code_word = code_word\n\n    return code_book, bytes(bitmap_stream)\n\nwith open('Frame0', 'rb') as sample_file:\n    code_book, uncompressed_image = decompress_frame(sample_file.read())\n    for index, entry in enumerate(code_book):\n        print(f'{index:03x}: {entry}')\n\n```\nFrom the first added entry (entry 0x100), here's the beginning of the emitted codebook:\n\n```\n0x100: [255, 255],\n0x101: [255, 255, 255],\n0x102: [255, 255, 255, 255],\n0x103: [255, 255, 255, 255, 255],\n0x104: [255, 255, 255, 255, 255, 255],\n0x105: [255, 255, 255, 255, 255, 255, 255],\n0x106: [255, 255, 255, 255, 255, 255, 47],\n0x107: [47, 255],\n0x108: [255, 255, 255, 255, 255, 255, 47, 47],\n0x109: [47, 255],\n0x10A: [255, 255, 255, 255, 255, 255, 255, 255],\n0x10B: [255, 255, 255, 255, 255, 255, 47, 47, 47],\n0x10C: [47, 255, 255]\n\n```\n(Full attempted codebook at https://pastebin.com/hWBsxdTE .)\n\nHowever, starting at 0x106, the rebuilt codebook gets off track and never gets back on again. When I do a pixdump of the emitted pixels, I see nothing recognizable. However, by some breakpointing in OllyDbg, I extracted the correct codebook from memory for this same frame. Here is the start of the correct codebook, as extracted from memory and verified to decompress the image correctly:\n\n```\n0x100: [255, 255],\n0x101: [255, 255, 255],\n0x102: [255, 255, 255, 255],\n0x103: [255, 255, 255, 255, 255],\n0x104: [255, 255, 255, 255, 255, 255],\n0x105: [255, 255, 255, 255, 255, 255, 255],\n0x106: [47, 47],\n0x107: [47, 47, 47],\n0x108: [255, 255, 255, 255, 255, 255, 255],\n0x109: [255, 255, 255, 255, 255, 255, 255, 255],\n0x10A: [255, 255, 255, 255, 255, 255, 255, 255, 255],\n0x10B: [255, 255, 255, 255, 255, 255, 255, 255, 255, 255],\n0x10C: [47, 47, 47, 47]\n\n```\n(Full dumped codebook at https://pastebin.com/x7V0VmkY .)\n\nThe structure of the dumped (correct) codebook suggested to me that maybe some sort of hashing was going on, but I do not see hashing logic in the disassembly. (My disassembly skills aren't super strong so I could have missed it.) There are no debugging symbols or helpful strings that I can find.\n\nAny thoughts on what my decoder script could be missing here that would cause a malformed codebook and thus incorrectly decoded image?\n\nFor the example frame discussed above, this is the correct image (taken as a screenshot from the animation):\n\n\n\n",
  "votes": "3",
  "answers": 0,
  "views": "61",
  "tags": [
    "disassembly",
    "decompress",
    "graphics"
  ],
  "user": "Nathanael Gentry",
  "time": "Jul 8, 2022 at 2:34",
  "comments": [],
  "answers_data": []
}