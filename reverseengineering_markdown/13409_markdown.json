{
  "title": "Help me reverse this",
  "link": "https://reverseengineering.stackexchange.com/questions/13409/help-me-reverse-this",
  "content": "It's been 4 nights I'm struggling decompiling this one. It's an Android native library that I ran through IDA to get C code.\n\nJava signature :\n\n```\nbyte[] resultArray = new byte[-2 + dataArray.length];\ndataLength= dataArray.length;\ndecryptData(byte[] resultArray, byte[] dataArray, int dataLength, int enumValue /* in our case should be 01 */, long paramLong /* dunno */)\n\n```\nThe disassembly in C :\n\n```\n//----- (00001354) --------------------------------------------------------\nint __fastcall doXor(int result, int a2, int a3, int a4, int a5, int a6, char a7)\n{\n  int v7; // r5@1\n  int v8; // r6@1\n  int v9; // r7@1\n  int v10; // r1@1\n  char v11; // lr@3\n  char v12; // t1@3\n  char v13; // t1@3\n\n  v7 = a2 - 1;\n  v8 = a3 - 1;\n  v9 = result - 1;\n  v10 = a2 + a5 - 1;\n  while ( v7 != v10 )\n  {\n    v12 = *(_BYTE *)(v7++ + 1);\n    v11 = v12;\n    v13 = *(_BYTE *)(v8++ + 1);\n    *(_BYTE *)(v9++ + 1) = v11 ^ v13;\n  } // ====== so far this one just does a xor in the full array\n  //   ===>what does this one do?\n  *(_BYTE *)(result + a5) = *(_BYTE *)(a3 + a5) ^ a7;\n\n  return result;\n}\n\n//----- (00001384) --------------------------------------------------------\nint getNumber()\n{\n  __int32 v0; // r0@1\n\n  v0 = time(0);\n  srand48(v0);\n  return (unsigned __int8)lrand48();\n}\n\n//----- (00001398) --------------------------------------------------------\nint __fastcall getKey(void *a1, unsigned int a2, unsigned __int8 a3, int a4, char a5)\n{\n  void *v5; // r8@1\n  unsigned int v6; // r7@1\n  unsigned int v7; // r10@1\n  void *v8; // r5@1\n  __int64 v9; // r0@1\n  signed int v10; // r6@1\n  __int64 v12; // [sp+8h] [bp-30h]@1\n  int v13; // [sp+14h] [bp-24h]@1\n\n  v5 = a1;\n  v6 = a2;\n  v7 = a2 >> 3;\n  v8 = a1;\n  v13 = _stack_chk_guard; //a stack guard\n  LODWORD(v9) = crc64(a3, (int)&a5, _stack_chk_guard, 8);\n  v10 = 0;\n  v12 = v9;\n  do\n  {\n    ++v10;\n    if ( 8 * v10 > v6 )\n    {\n      if ( v6 >= 8 * v10 - 8 )\n        LODWORD(v9) = memcpy(v8, &v12, (size_t)((char *)v5 + v6 - (_DWORD)v8));\n    }\n    else\n    {\n      v9 = v12;\n      *(_QWORD *)v8 = v12;\n    }\n    v8 = (char *)v8 + 8;\n  }while ( v10 <= (signed int)v7 );\n  if ( v13 != _stack_chk_guard )\n    _stack_chk_fail(v9);\n  return v9;\n}\n\n\n//----- (000014E4) --------------------------------------------------------\nsigned int __fastcall decryptData(void *a1, unsigned int *a2, int a3, int a4, __int64 a5)\n{\n  int v5; // r4@1\n  void *v6; // r11@1\n  unsigned int *v7; // r10@1\n  unsigned int v8; // r7@3\n  int v9; // r9@3\n  int v10; // ST10_4@3\n  void *v11; // r8@3\n  const void *v12; // r5@3\n  int v13; // r6@3\n  signed int result; // r0@5\n\n  v5 = a3;\n  v6 = a1;\n  v7 = a2;\n  if ( check == 1 )\n  {\n    if ( a5 )\n    {\n      result = 0;\n    }\n    else\n    {\n      v8 = *(_BYTE *)a2;\n      v9 = a4 + v8;\n      v10 = *((_BYTE *)a2 + a3 - 1);\n      v11 = malloc(a3 - 1);\n      v12 = malloc(v5 - 1);\n      getKey(v11, (unsigned __int16)(v5 - 1), v9, (2596069104u * (unsigned __int64)v8 >> 32) + 305419896 * v8, -16 * v8);\n      v13 = v5 - 2;\n      doXor((int)v12, (int)((char *)v7 + 1), (int)v11, v10, v13, (unsigned __int64)v13 >> 32, v10);\n      memcpy(v6, v12, v5 - 2);\n      if ( *((char *)v12 + v5 - 2) != v9 )\n        v13 = 0;\n      if ( v11 )\n        free(v11);\n      free((void *)v12);\n      result = v13;\n    }\n  }\n  else\n  {\n    result = -1;\n  }\n  return result;\n}\n\n```\nI have the implementation of crc64.\nWhat I fail to understand is where does it get the seed from the data array for the getKey.\n\nI'm not sure, I think it stores in the last 2 bytes the key that is used to generated the bigger key for xor. Please help, I'm really struggling and my C skills are a rusty.\n\nHere is a set of data :\n\n```\n$type = \"01\";\n$length = \"37\";\n$data=\"ea8bf72287a0af8aa65edf259a43\".\n\"e1d8a67f71bce448273199848e401b33\".\n\"da379966a12ce4442e31991b71bde449\".\n\"39bb907d71bce448cc\";\n\n```\nNormally, first 8 bytes gives the latitude and second longitude which in this case is :\nf8869e63e888bb3f29ae997e0bc6e93f\n\nSo basically I assume we can expect this to be the coded version :\nea8bf72287a0af8aa65edf259a43e1d8\nThe inverse of xor is a xor so after xor it gives :\n120d69416f2814b58ff0465b918508e7\n\nWhich hypothetically is our partial xor key.\n\nNow questions :\n\nIf you want to help outside stack and discuss this please contact me.\nMany thanks\n\n",
  "votes": "2",
  "answers": 1,
  "views": "3k",
  "tags": [
    "decompilation",
    "c",
    "decryption",
    "xor"
  ],
  "user": "TecHunter",
  "time": "Sep 6, 2016 at 18:26",
  "comments": [],
  "answers_data": [
    {
      "content": "Here's your code with names given to most variables. That's quite a bit of code so I'll try to only iterate the important parts. I also added a few comments in the code to help reading, although I didn't try to cover all code with comments. Make sure you go over the named parameters, I believe those will help you understand the code quickly. Viewing the code in a syntax highlighting editor will also help (couldn't get SO to highlight).\n\nPlease add a comment about anything that's not clear enough.\n\nthe NI prefix is my initials, you can ignore it. \n\nFirst, doXor:\n\nThis function simply XORs all bytes except the last byte, which is treated a bit differently, but more on that later. This is not part of the while loop simply because it's recevied differently in doXor. A possible reasoning behind this is to force any user of doXor to explicitly deal with this value, as it's somewhat important for asserting the validity of the decrpyed message.\n\n```\n//----- (00001354) --------------------------------------------------------\nint __fastcall doXor(int result, int a2_NI_source, int a3_NI_key, int a4_NI_unused_copy_source_last_byte, int a5_NI_length, int a6_NI_unused, char a7_NI_source_last_byte)\n{\n  int v7; // r5@1\n  int v8; // r6@1\n  int v9; // r7@1\n  int v10; // r1@1\n  char v11; // lr@3\n  char v12; // t1@3\n  char v13; // t1@3\n\n  v7_NI_source_pos = a2_NI_source - 1;\n  v8_NI_key_pos = a3_NI_key - 1;\n  v9_NI_result_pos = result - 1;\n  v10_NI_source_end_loc = a2_NI_source + a5_NI_length - 1;\n  while ( v7_NI_source_pos != v10_NI_source_end_loc )\n  {\n    // Ready bytes from v7_NI_source_pos and v8_NI_key_pos\n    v12 = *(_BYTE *)(v7_NI_source_pos++ + 1); // READ BYTE OF a2 + offset\n    v11 = v12;\n    v13 = *(_BYTE *)(v8_NI_key_pos++ + 1); // READ BYTE OF a2 + offset\n\n    // Xor two values and place in v9_NI_result_pos\n    *(_BYTE *)(v9_NI_result_pos++ + 1) = v11 ^ v13;\n  } // ====== so far this one just does a xor in the full array\n  //   ===>what does this one do?\n\n  // XOR LAST BYTE OF key with a7_NI_source_last_byte (see decryptData for code that retreives the byte)\n  *(_BYTE *)(result + a5_NI_length) = *(_BYTE *)(a3_NI_key + a5_NI_length) ^ a7_NI_source_last_byte;\n\n  return result;\n}\n\n```\nSecond, getNumber:\n\nThis is never actually used, but generates a single byte of random data which is somewhat biased for sepcificaly the value 255 because casting a \"nonnegative long integer uniformly distributed between 0 and 2^31\" to a unsigned byte will, in most cases, yield a number above 255.\n\ntime will return the current local time in seconds since Epoch, srand48 will seed the builtin PRNG with that result and lrand48 return the random number.\n\n```\n//----- (00001384) --------------------------------------------------------\n// This is never used in provided code! :S\nint getNumber()\n{\n  __int32 v0; // r0@1\n\n  // Seed srand48 using current local time in seconds since Epoch\n  v0 = time(0);\n  srand48(v0);\n  // Return 1 byte integer casted from nonnegative long integer uniformly distributed between 0 and 2^31 \n  return (unsigned __int8)lrand48();\n}\n\n```\nThird, getKey:\n\n[EDIT] A simple stream padding based on passed values. It is unclear what crc64 does and how are it's parameters used, but it appears as if it does not receive a buffer.\nThe low dword returned from crc64 is copied repeatedly to create the key sequence, and is used as the internal PRNG state. crc64 is there for the function creating the initial state, or the seed function for geyKey.\nIt has some decompliation bloat (that is, extra redundant C statements caused by the decompiler not doing the best job it could) but basically this function fills the requested buffer with the same value over and over.\n\n```\n//----- (00001398) --------------------------------------------------------\nint __fastcall getKey(void *a1_NI_key_buffer, unsigned int a2_NI_key_length, unsigned __int8 a3, int a4_NI_unused, char a5)\n{\n  void *v5; // r8@1\n  unsigned int v6; // r7@1\n  unsigned int v7; // r10@1\n  void *v8; // r5@1\n  __int64 v9; // r0@1\n  signed int v10; // r6@1\n  __int64 v12; // [sp+8h] [bp-30h]@1\n  int v13; // [sp+14h] [bp-24h]@1\n\n  v5_NI_key_buffer = a1_NI_key_buffer;\n  v6_NI_key_length = a2_NI_key_length;\n  v7_NI_key_8byte_chunks = a2_NI_key_length >> 3;\n  v8_NI_key_buffer_pos = a1_NI_key_buffer;\n  v13_NI_stack_guard = _stack_chk_guard; //a stack guard\n  LODWORD(v9_NIl_partial_crc_state) = crc64(a3, (int)&a5, _stack_chk_guard, 8);\n  v10_NI_current_8byte_chunk = 0;\n  v12_NI_full_crc_state = v9_NIl_partial_crc_state;\n\n  // Loop on 8 byte long chunks of the required key length\n  do\n  {\n    // increase the counter for the current 8byte chunk we're using\n    ++v10_NI_current_8byte_chunk;\n\n    // If current 8byte chunk exceeds the required length\n    if ( 8 * v10_NI_current_8byte_chunk > v6_NI_key_length )\n    {\n      // If some bytes of the 8byte chunks are needed\n      if ( v6_NI_key_length >= 8 * v10_NI_current_8byte_chunk - 8 )\n      {\n        // Copy portion of v12_NI_full_crc_state needed to fill the buffer\n        LODWORD(v9_NIl_partial_crc_state) = memcpy(v8_NI_key_buffer_pos, &v12_NI_full_crc_state, (size_t)((char *)v5_NI_key_buffer + v6_NI_key_length - (_DWORD)v8_NI_key_buffer_pos));\n      }\n    }\n    else\n    {\n      // Set v9_NIl_partial_crc_state to the initial v12_NI_full_crc_state\n      v9_NIl_partial_crc_state = v12_NI_full_crc_state;\n      *(_QWORD *)v8_NI_key_buffer_pos = v12_NI_full_crc_state;\n    }\n    v8_NI_key_buffer_pos = (char *)v8_NI_key_buffer_pos + 8;\n  }while ( v10_NI_current_8byte_chunk <= (signed int)v7_NI_key_8byte_chunks );\n\n  // Make sure stack wasn't damaged in the process\n  if ( v13_NI_stack_guard != _stack_chk_guard )\n    _stack_chk_fail(v9_NIl_partial_crc_state);\n  return v9_NIl_partial_crc_state;\n}\n\n```\nLast but not least, decryptData:\n\nThis is where the magic happens, buy it's not too magical. Basically, the first byte is used to feed getKey with a state, togather with a4_NI_unknown_constant parameter passed to decryptData. These two bytes are what determines the entire getKey function.\n\nThe last byte (treated strangly in doXor is used as a basic sanify/error detection byte and must result in the correct value for the message to be accepted and properly decrypted.\n\n```\n//----- (000014E4) --------------------------------------------------------\nsigned int __fastcall decryptData(void *a1_NI_result, unsigned int *a2_NI_source, int a3_NI_length, int a4_NI_unknown_constant, __int64 a5)\n{\n  int v5; // r4@1\n  void *v6; // r11@1\n  unsigned int *v7; // r10@1\n  unsigned int v8; // r7@3\n  int v9; // r9@3\n  int v10; // ST10_4@3\n  void *v11; // r8@3\n  const void *v12; // r5@3\n  int v13; // r6@3\n  signed int result; // r0@5\n\n  v5_NI_length_copy = a3_NI_length;\n  v6_NI_result_copy = a1_NI_result;\n  v7_NI_source_copy = a2_NI_source;\n  if ( check == 1 )\n  {\n    if ( a5 )\n    {\n      result = 0;\n    }\n    else\n    {\n      v8_NI_source_first_byte = *(_BYTE *)a2_NI_source;\n      v9_NI_unknown_plus_first_byte = a4_NI_unknown_constant + v8_NI_source_first_byte;\n      v10_NI_source_last_byte = *((_BYTE *)a2_NI_source + a3_NI_length - 1);\n      v11_NI_key = malloc(a3_NI_length - 1);\n      v12_NI_temp_result = malloc(v5_NI_length_copy - 1);\n\n      // generate xor key based on:\n      // 1. length of data\n      // 2. unknown constant provided to decryptData as a4_NI_unknown_constant\n      // 3. first byte of encrypted string\n      getKey(v11_NI_key, (unsigned __int16)(v5_NI_length_copy - 1), v9_NI_unknown_plus_first_byte, (2596069104u * (unsigned __int64)v8_NI_source_first_byte >> 32) + 305419896 * v8_NI_source_first_byte, -16 * v8_NI_source_first_byte);\n      v13_result_length = v5_NI_length_copy - 2;\n\n      // XOR\n      doXor((int)v12_NI_temp_result, (int)((char *)v7_NI_source_copy + 1), (int)v11_NI_key, v10_NI_source_last_byte, v13_result_length, (unsigned __int64)v13_result_length >> 32, v10_NI_source_last_byte);\n\n      // Copy result from v12_NI_temp_result to user provided reulst buffer v6_NI_result_copy\n      memcpy(v6_NI_result_copy, v12_NI_temp_result, v5_NI_length_copy - 2);\n\n      // If last byte in v12_NI_temp_result is not the same as v9_NI_unknown_plus_first_byte, return Null\n      if ( *((char *)v12_NI_temp_result + v5_NI_length_copy - 2) != v9_NI_unknown_plus_first_byte )\n        v13_result_length = 0;\n\n      // If key allocated, free it\n      if ( v11_NI_key )\n        free(v11_NI_key);\n\n      // Free v12_NI_temp_result\n      free((void *)v12_NI_temp_result);\n\n      // return v13_result_length\n      result = v13_result_length;\n    }\n  }\n  else\n  {\n    result = -1;\n  }\n  return result;\n}\n\n```\nFinally, sepcific answers to your questions:\n\nI think the best way for you to proceed now is implementing a simulator that receives a message and tries to decrypt it using the information above. I may have made mistakes or overlooked some small details, but those will be eaier to identify by seeing errors in the produced decryption and following up on those.\n\n",
      "votes": "2",
      "user": "NirIzr",
      "time": "Sep 6, 2016 at 10:46",
      "is_accepted": true,
      "comments": [
        {
          "user": "TecHunter",
          "text": "thank you, I will review this later and give you feedback and hopefully the bounty.",
          "time": null
        },
        {
          "user": "NirIzr",
          "text": "You're welcome! If you have any further questions or issues you'd like me to focus more on go ahead and point those out.",
          "time": null
        },
        {
          "user": "TecHunter",
          "text": "The getKey function is the most important part here. I need to understand how we retrieve the key from the data",
          "time": null
        },
        {
          "user": "NirIzr",
          "text": "@TecHunter: it's actually simpler than I thought, I described it and now we're after crc64 which is missing here. Mostly, crc64 is used repeatedly as the actual XOR key which makes decrypting messages quite easy. Yay! I've edited my answer to reflect the additional details.",
          "time": null
        },
        {
          "user": "TecHunter",
          "text": "@Nirlzr great, here is the full C code gist i've reversed completely the crc64 function",
          "time": null
        }
      ]
    }
  ]
}