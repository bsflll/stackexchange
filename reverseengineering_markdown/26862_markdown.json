{
  "title": "How to simplify a function \"calling itself's reference\"",
  "link": "https://reverseengineering.stackexchange.com/questions/26862/how-to-simplify-a-function-calling-itselfs-reference",
  "content": "I encounter often a function calling itself (in the pseudo code) such as:\n\n```\nresult = (**(__int64 (__fastcall ***)(volatile signed __int32 *))lambda)(lambda);\n\n```\nHere a more complete context:\n\n```\n__int64 __fastcall CR_maybeParseWithLambda(_QWORD *a1, __int64 newPtr, __int64 positionOrCounter)\n{\n  volatile signed __int32 *lambda; // rdi\n  __int64 result; // rax\n\n  lambda = (volatile signed __int32 *)a1[1];\n  if ( lambda )\n  {\n    result = (unsigned int)_InterlockedExchangeAdd(lambda + 2, 0xFFFFFFFF);\n    if ( (_DWORD)result == 1 )\n    {\n      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))lambda)(lambda);\n      if ( _InterlockedExchangeAdd(lambda + 3, 0xFFFFFFFF) == 1 )\n        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)lambda + 8i64))(lambda);\n      a1[1] = positionOrCounter;\n      *a1 = newPtr;\n    }\n    else\n    {\n      a1[1] = positionOrCounter;\n      *a1 = newPtr;\n    }\n  }\n  else\n  {\n    a1[1] = positionOrCounter;\n    *a1 = newPtr;\n  }\n  return result;\n}\n\n```\nThe disassembly:\n\n```\n.text:0000000180005F70 ; __int64 __fastcall CR_maybeParseWithLambda(_QWORD *a1, __int64 newPtr, __int64 positionOrCounter)\n.text:0000000180005F70 CR_maybeParseWithLambda proc near       ; CODE XREF: sub_180005B10+10F↑p\n.text:0000000180005F70                                         ; sub_180005B10+14A↑p ...\n.text:0000000180005F70\n.text:0000000180005F70 arg_0           = qword ptr  8\n.text:0000000180005F70 arg_8           = qword ptr  10h\n.text:0000000180005F70 arg_10          = qword ptr  18h\n.text:0000000180005F70 arg_18          = qword ptr  20h\n.text:0000000180005F70\n.text:0000000180005F70                 mov     [rsp+arg_8], rbx\n.text:0000000180005F75                 mov     [rsp+arg_10], rbp\n.text:0000000180005F7A                 mov     [rsp+arg_18], rsi\n.text:0000000180005F7F                 push    rdi\n.text:0000000180005F80                 sub     rsp, 20h\n.text:0000000180005F84                 mov     rdi, [rcx+8]\n.text:0000000180005F88                 mov     rsi, r8\n.text:0000000180005F8B                 mov     rbp, rdx\n.text:0000000180005F8E                 mov     rbx, rcx\n.text:0000000180005F91                 test    rdi, rdi\n.text:0000000180005F94                 jz      short loc_180005FF3\n.text:0000000180005F96\n.text:0000000180005F96 loc_180005F96:                          ; DATA XREF: .rdata:0000000180401E74↓o\n.text:0000000180005F96                                         ; .rdata:0000000180401E84↓o ...\n.text:0000000180005F96                 mov     [rsp+28h+arg_0], r14\n.text:0000000180005F9B                 or      r14d, 0FFFFFFFFh\n.text:0000000180005F9F                 mov     eax, r14d\n.text:0000000180005FA2                 lock xadd [rdi+8], eax\n.text:0000000180005FA7                 cmp     eax, 1\n.text:0000000180005FAA                 jnz     short loc_180005FEA\n.text:0000000180005FAC                 mov     rax, [rdi]\n.text:0000000180005FAF                 mov     rcx, rdi\n.text:0000000180005FB2                 call    qword ptr [rax]\n.text:0000000180005FB4                 lock xadd [rdi+0Ch], r14d\n.text:0000000180005FBA                 cmp     r14d, 1\n.text:0000000180005FBE                 jnz     short loc_180005FC9\n.text:0000000180005FC0                 mov     rax, [rdi]\n.text:0000000180005FC3                 mov     rcx, rdi\n.text:0000000180005FC6                 call    qword ptr [rax+8]\n.text:0000000180005FC9\n.text:0000000180005FC9 loc_180005FC9:                          ; CODE XREF: CR_maybeParseWithLambda+4E↑j\n.text:0000000180005FC9                 mov     [rbx+8], rsi\n.text:0000000180005FCD                 mov     [rbx], rbp\n.text:0000000180005FD0\n.text:0000000180005FD0 loc_180005FD0:                          ; CODE XREF: CR_maybeParseWithLambda+81↓j\n.text:0000000180005FD0                 mov     r14, [rsp+28h+arg_0]\n.text:0000000180005FD5\n.text:0000000180005FD5 loc_180005FD5:                          ; CODE XREF: CR_maybeParseWithLambda+8A↓j\n.text:0000000180005FD5                                         ; DATA XREF: .pdata:0000000180483888↓o ...\n.text:0000000180005FD5                 mov     rbx, [rsp+28h+arg_8]\n.text:0000000180005FDA                 mov     rbp, [rsp+28h+arg_10]\n.text:0000000180005FDF                 mov     rsi, [rsp+28h+arg_18]\n.text:0000000180005FE4                 add     rsp, 20h\n.text:0000000180005FE8                 pop     rdi\n.text:0000000180005FE9                 retn\n\n```\n",
  "votes": "0",
  "answers": 1,
  "views": "159",
  "tags": [
    "ida",
    "disassembly",
    "assembly",
    "c",
    "static-analysis"
  ],
  "user": "Soleil",
  "time": "Jan 24, 2021 at 22:54",
  "comments": [],
  "answers_data": [
    {
      "content": "It's not calling itself; you're overlooking the * dereferences at the beginning of the call expression. As in:\n\nresult = (**(__int64 (__fastcall ***)(volatile signed __int32 *))lambda)(lambda);\n\nNotice the two ** inside of the first parenthesis? It's dereferencing the address held in the variable named lambda, which the assembly makes clear:\n\n```\n.text:0000000180005FAC    mov     rax, [rdi]      ; dereference #1\n.text:0000000180005FAF    mov     rcx, rdi\n.text:0000000180005FB2    call    qword ptr [rax] ; dereference #2\n\n```\nThis is a call to a virtual function. #1 loads the VTable pointer out of the object; #2 calls the function pointer at +0 into the VTable.\n\nIn general, this is always going to look nasty in the decompilation before you have created a structure type for lambda, and a second type for its VTable. Once you do that, it will show you something pretty like this (taken from my ComRAT IDB):\n\n```\nif ( v9 )\n{\n  if ( !_InterlockedDecrement(&v9->_Uses) )\n  {\n    v9->_Destroy(v9);\n    if ( !_InterlockedDecrement(&v9->_Weaks) )\n      v9->_Delete_this(v9);\n  }\n}\n\n```\n",
      "votes": "3",
      "user": "Rolf Rolles",
      "time": "Jan 25, 2021 at 8:57",
      "is_accepted": false,
      "comments": []
    }
  ]
}