{
  "title": "Find the entry point in Interrupt Vector Table ARM9",
  "link": "https://reverseengineering.stackexchange.com/questions/27657/find-the-entry-point-in-interrupt-vector-table-arm9",
  "content": "I'm analyzing the firmware of a device that has the cpu ARM946E-S. It has not a file system, just assembly code and strings.\n\nI've disassembled the firmware using ida pro, but I couldn't find the entry point.\n\nI know that in the interrupt address table there is a pointer called 'Reset', I could use it to start dynamic analysis, but I could not find the IAT either.\n\nObviously, I've tried to analyze it using binwalk and radare2 unsuccessfully.\n\nCan someone tell me how to find the interrupt address table?\n\nEDIT\n\nAfter Brendan Dolan-Gavitt's answer.\n\nIn cpu documentation, there is a control register called “alternate vector select”.\n\n\nI do not know how to get the control register table.\n\nAnd I have another doubt. My firmware is 16MB, so where is the IVT if the Bit 13 is set?\n\nSince it was impossible for me to locate the IVT I’ve decided to try the approach suggested by Brendan:\n\nEach entry of the IVT is an arm instruction that jumps to a specific location. The only instruction that does an unconditional jump is b (branch). So I inferred that the IVT is composed of a set of b instructions.\n\nThe opcode of b is EA. So searching in the hexadecimal version of the firmware…\n\nIt finds only one occurrence.\n\nAnalysing that location with radare2:\n\n\nThose branch instructions point to themselves. It doesn’t make any sense.\n\n",
  "votes": "3",
  "answers": 2,
  "views": "977",
  "tags": [
    "disassembly",
    "firmware",
    "arm",
    "entry-point",
    "iat"
  ],
  "user": "Andrea Olla",
  "time": "May 17, 2021 at 9:17",
  "comments": [
    {
      "user": "Igor Skochinsky",
      "text": "show us a hexdump of the first 64-128 or so bytes",
      "time": null
    },
    {
      "user": "Andrea Olla",
      "text": "That is the first part:  link",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "For the ARM946E-S Technical Reference Manual, the exception vectors (including the reset vector) should be located at either 0x00000000 or 0xFFFF0000 in memory, depending on whether the Alternate vectors select bit is set. The layout of these vectors looks like:\n\n```\nException                   |       Address            \n----------------------------|-----------------------\nReset                       |      0xffff0000           \nUndefined Instruction       |      0xffff0004       \nSWI                         |      0xffff0008  \nPrefetch Abort              |      0xffff000c       \nData Abort                  |      0xffff0010 \nReserved                    |      0xffff0014  \nIRQ                         |      0xffff0018   \nFIQ                         |      0xffff001c  \n\n```\n(Table reproduced from this blog post, but you can also find it somewhere in the ARM Architecture Reference Manual)\n\nNote that each of these is not a pointer but an ARM instruction (usually a jump to the handler for that vecor). You can see an example of how this is implemented in something like Linux by looking at the kernel entry point code: https://github.com/torvalds/linux/blob/f77ac2e378be9dd61eb88728f0840642f045d9d1/arch/arm/kernel/entry-armv.S#L1183-L1191\n\nOne complication in your case is that since you're dealing with a firmware image rather than looking at this in memory you'll have to figure out where the image is actually mapped in memory. Alternatively you can just try to disassemble the whole image (e.g. using objdump to get a linear disassembly) and look for a sequence of branch instructions that matches.\n\n",
      "votes": "3",
      "user": "Brendan Dolan-Gavitt",
      "time": "May 12, 2021 at 15:37",
      "is_accepted": false,
      "comments": [
        {
          "user": "Andrea Olla",
          "text": "Thank you, I've tried what you suggested to me and I've updated the questions.",
          "time": null
        }
      ]
    },
    {
      "content": "The first bytes are the exception vectors:\n\n```\nCODE:00000000                 LDR             PC, =0x1000005C\nCODE:00000004 ; ---------------------------------------------------------------------------\nCODE:00000004                 LDR             PC, =0x10000044\nCODE:00000008 ; ---------------------------------------------------------------------------\nCODE:00000008                 LDR             PC, =0x10000048\nCODE:0000000C ; ---------------------------------------------------------------------------\nCODE:0000000C                 LDR             PC, =0x1000004C\nCODE:00000010 ; ---------------------------------------------------------------------------\nCODE:00000010                 LDR             PC, =0x10000050\nCODE:00000010 ; ---------------------------------------------------------------------------\nCODE:00000014                 ALIGN 8\nCODE:00000018                 LDR             PC, =0x10000054\nCODE:0000001C ; ---------------------------------------------------------------------------\nCODE:0000001C                 LDR             PC, =0x10000058\nCODE:0000001C ; ---------------------------------------------------------------------------\nCODE:00000020 off_20          DCD 0x1000005C          ; DATA XREF: CODE:00000000↑r\nCODE:00000024 off_24          DCD 0x10000044          ; DATA XREF: CODE:00000004↑r\nCODE:00000028 off_28          DCD 0x10000048          ; CODE XREF: sub_1D8↓j\nCODE:00000028                                         ; DATA XREF: CODE:00000008↑r ...\nCODE:0000002C off_2C          DCD 0x1000004C          ; DATA XREF: CODE:0000000C↑r\nCODE:00000030 off_30          DCD 0x10000050          ; DATA XREF: CODE:00000010↑r\nCODE:00000034 off_34          DCD 0x10000054          ; DATA XREF: CODE:00000018↑r\nCODE:00000038 off_38          DCD 0x10000058          ; DATA XREF: CODE:0000001C↑r\n\n```\nApparently the code is mapped at 0x10000000. After rebasing, we can see that the loops you've found are dummy  handlers:\n\n```\nCODE:10000000                 LDR             PC, =Reset_Handler\nCODE:10000004 ; ---------------------------------------------------------------------------\nCODE:10000004                 LDR             PC, =Undef_Hander\nCODE:10000008 ; ---------------------------------------------------------------------------\nCODE:10000008                 LDR             PC, =SWI_Handler\nCODE:1000000C ; ---------------------------------------------------------------------------\nCODE:1000000C                 LDR             PC, =PrefAbort_Handler\nCODE:10000010 ; ---------------------------------------------------------------------------\nCODE:10000010                 LDR             PC, =DataAbort_Handler\nCODE:10000010 ; ---------------------------------------------------------------------------\nCODE:10000014                 ALIGN 8\nCODE:10000018                 LDR             PC, =IRQ_Handler\nCODE:1000001C ; ---------------------------------------------------------------------------\nCODE:1000001C                 LDR             PC, =FIQ_Handler\nCODE:1000001C ; ---------------------------------------------------------------------------\nCODE:10000020 off_10000020    DCD Reset_Handler       ; DATA XREF: CODE:10000000↑r\nCODE:10000024 off_10000024    DCD Undef_Hander        ; DATA XREF: CODE:10000004↑r\nCODE:10000028 off_10000028    DCD SWI_Handler         ; DATA XREF: CODE:10000008↑r\nCODE:1000002C off_1000002C    DCD PrefAbort_Handler   ; DATA XREF: CODE:1000000C↑r\nCODE:10000030 off_10000030    DCD DataAbort_Handler   ; DATA XREF: CODE:10000010↑r\nCODE:10000034 off_10000034    DCD IRQ_Handler         ; DATA XREF: CODE:10000018↑r\nCODE:10000038 off_10000038    DCD FIQ_Handler         ; DATA XREF: CODE:1000001C↑r\nCODE:1000003C aV10            DCB \"v1.0\"\nCODE:10000040                 DCD 0x1C200\nCODE:10000044\nCODE:10000044 ; =============== S U B R O U T I N E =======================================\nCODE:10000044\nCODE:10000044 ; Attributes: noreturn\nCODE:10000044\nCODE:10000044 Undef_Hander                            ; CODE XREF: CODE:10000004↑j\nCODE:10000044                                         ; Undef_Hander↓j\nCODE:10000044                                         ; DATA XREF: ...\nCODE:10000044                 B               Undef_Hander\nCODE:10000044 ; End of function Undef_Hander\nCODE:10000044\nCODE:10000048\nCODE:10000048 ; =============== S U B R O U T I N E =======================================\nCODE:10000048\nCODE:10000048 ; Attributes: noreturn\nCODE:10000048\nCODE:10000048 SWI_Handler                             ; CODE XREF: CODE:10000008↑j\nCODE:10000048                                         ; SWI_Handler↓j\nCODE:10000048                                         ; DATA XREF: ...\nCODE:10000048                 B               SWI_Handler\nCODE:10000048 ; End of function SWI_Handler\nCODE:10000048\nCODE:1000004C\nCODE:1000004C ; =============== S U B R O U T I N E =======================================\nCODE:1000004C\nCODE:1000004C ; Attributes: noreturn\nCODE:1000004C\nCODE:1000004C PrefAbort_Handler                       ; CODE XREF: CODE:1000000C↑j\nCODE:1000004C                                         ; PrefAbort_Handler↓j\nCODE:1000004C                                         ; DATA XREF: ...\nCODE:1000004C                 B               PrefAbort_Handler\nCODE:1000004C ; End of function PrefAbort_Handler\nCODE:1000004C\nCODE:10000050\nCODE:10000050 ; =============== S U B R O U T I N E =======================================\nCODE:10000050\nCODE:10000050 ; Attributes: noreturn\nCODE:10000050\nCODE:10000050 DataAbort_Handler                       ; CODE XREF: CODE:10000010↑j\nCODE:10000050                                         ; DataAbort_Handler↓j\nCODE:10000050                                         ; DATA XREF: ...\nCODE:10000050                 B               DataAbort_Handler\nCODE:10000050 ; End of function DataAbort_Handler\nCODE:10000050\nCODE:10000054\nCODE:10000054 ; =============== S U B R O U T I N E =======================================\nCODE:10000054\nCODE:10000054 ; Attributes: noreturn\nCODE:10000054\nCODE:10000054 IRQ_Handler                             ; CODE XREF: CODE:10000018↑j\nCODE:10000054                                         ; IRQ_Handler↓j\nCODE:10000054                                         ; DATA XREF: ...\nCODE:10000054                 B               IRQ_Handler\nCODE:10000054 ; End of function IRQ_Handler\nCODE:10000054\nCODE:10000058\nCODE:10000058 ; =============== S U B R O U T I N E =======================================\nCODE:10000058\nCODE:10000058 ; Attributes: noreturn\nCODE:10000058\nCODE:10000058 FIQ_Handler                             ; CODE XREF: CODE:1000001C↑j\nCODE:10000058                                         ; FIQ_Handler↓j\nCODE:10000058                                         ; DATA XREF: ...\nCODE:10000058                 B               FIQ_Handler\nCODE:10000058 ; End of function FIQ_Handler\nCODE:10000058\nCODE:1000005C ; ---------------------------------------------------------------------------\nCODE:1000005C\nCODE:1000005C Reset_Handler                           ; CODE XREF: CODE:10000000↑j\nCODE:1000005C                                         ; DATA XREF: CODE:10000000↑o ...\nCODE:1000005C                 MOV             R1, #0x12\nCODE:10000060                 ORR             R0, R1, #0\nCODE:10000064                 MCR             p15, 0, R0,c9,c1, 1\nCODE:10000068                 MOV             R1, #0x12\nCODE:1000006C                 ORR             R0, R1, #0x100000\nCODE:10000070                 MCR             p15, 0, R0,c9,c1, 0\nCODE:10000074                 MRC             p15, 0, R0,c1,c0, 0\nCODE:10000078                 ORR             R0, R0, #0x50000\nCODE:1000007C                 MCR             p15, 0, R0,c1,c0, 0\nCODE:10000080                 LDR             R0, =0x5200F010\nCODE:10000084                 LDR             R1, [R0]\nCODE:10000088                 ORR             R1, R1, #0xE\nCODE:1000008C                 STR             R1, [R0]\nCODE:10000090                 LDR             R12, =sub_10000140\nCODE:10000094                 BX              R12     ; sub_10000140\n\n```\nThe code in Reset_Handler performs the very basic hw init then jumps to the code which prepares the rest of the environment (copies code and data to its final location then jumps to it).\n\n",
      "votes": "2",
      "user": "Igor Skochinsky",
      "time": "May 17, 2021 at 11:03",
      "is_accepted": false,
      "comments": [
        {
          "user": "Andrea Olla",
          "text": "Thanks! What have you used to disassembly it?",
          "time": null
        },
        {
          "user": "Igor Skochinsky",
          "text": "@AndreaOlla IDA obviously. P.S. I renamed the handlers manually.",
          "time": null
        }
      ]
    }
  ]
}