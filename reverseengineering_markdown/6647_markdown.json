{
  "title": "How to cause program to stop execution when a particular value is found in memory",
  "link": "https://reverseengineering.stackexchange.com/questions/6647/how-to-cause-program-to-stop-execution-when-a-particular-value-is-found-in-memor",
  "content": "I am new to reverse engineering. This is my problem:\nI am running a program and I know a value 'X' will be calculated during execution.\nNow how do i set the IDA or ollydbg to break when value X appears for the first time in the memory. (I guess it is similar to Memory/Data Breakpoints)\nPlease help.\n\n",
  "votes": "1",
  "answers": 4,
  "views": "2k",
  "tags": [
    "ida",
    "ollydbg",
    "patch-reversing"
  ],
  "user": "ASHUTOSH",
  "time": "Nov 17, 2014 at 13:33",
  "comments": [
    {
      "user": "Guntram Blohm",
      "text": "Do you know where in memory your value should appear? If so, you can set a breakpoint on that memory address. If not, the only way to do this is running an emulator and check the state of the emulated machine after each instruction.",
      "time": null
    },
    {
      "user": "0xC0000022L",
      "text": "The idea of reverse code engineering is usually not to \"scan\" a whole memory range for a specific value (on Windows Cheat Engine can do that for you; but don't do it for malicious samples!!!), but to selectively understand the code and work your way to the location of interest. This requires that you have an in-depth understanding of the representation certain library/runtime/OS features have in a program and being able to match those to the assembly code IDA or OllyDbg give you.",
      "time": null
    },
    {
      "user": "josh",
      "text": "@Guntram Blohm: This seems no longer quite accurate in Ida 6.3. Quote Hex-Rays: \"Page breakpoints are memory access breakpoints that can be set to detect when the application reads, writes, or executes code/data in a specific memory range. Page breakpoints are very similar to hardware breakpoints but there is no limitation on the number of page breakpoints that can be set or their size, in contrast with normal hardware breakpoints.\"",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "Well, I was tying few weeks ago to implement an ollyscript which triggers conditional beakpoints on each line where a desired alpha/numerical value is found.\n\nThis program gives the user the choice of following one of 3 methods:\n\n1- Trace methode (which works with numbers)\n\n2- Memory breakpoints \n\n3- Smart research by setting unconditional breakpoints (works by two passes)\n\n```\nCOE \nLC  \nlog \" This script is realised by AGAWA001 of StackExchange \"    \nlog \" This script should be executed on ODbgScript version +1.82.6\" \nlog \" This script must rerun twice atleast in case of smartresearch\"    \nlog \" you must restart your program once terminated to clear useless breakpoints\"   \nlog \" This script is used to check existence of an alpha/numeric value in memory\"   \nlog \" Unicode strings arent suppoted try to input first two unicode characters as number\"   \nlog \" in case when script stops, press spacebar focused on script window to force it to run\"    \nlog \" This script removes all beakpoints prealably set up and changes labels from command lines\"    \nlog \" To run this script as quick as possible, ollydbg window is prefered to be minimized during execution \"    \nlog \" All insider windows (log window,bp window,memory ,...) must be closed apart script window to ensure shortest runtime\" \nlog \" Trace procedure can encounter T-flag error, in this case try to get a grasp on it by binding esc key focused on script window\"    \nlog \" Some debuggers dont support ask command, so values must be injected manually and carefully instead of userprompt command in same line\"    \n\nlog \"--------------------------------------------------------------------------------------\"    \nlog \" This is beta version, Contact me whether you find any bugs, regards.\" \nlog \"--------------------------------------------------------------------------------------\"    \n\nvar str \nvar tmp \nvar start   \nvar finish  \nvar addr    \nvar ending  \nvar beginning   \nvar val \nvar value   \nvar swtch   \nvar stack   \nvar stackend    \nvar buff    \nvar offset  \nvar dll \nvar processkill \nmov processkill,0   \nmov offset,4    \nalloc 1000                          \nmov buff, $RESULT   \nmov offst,ff    \nGMEMI esp, MEMORYBASE   \nmov stack,$RESULT   \nGMEMI $RESULT, MEMORYSIZE   \nmov stackend,$RESULT    \nadd stackend,stack  \ngmi eip,MODULEBASE  \nmov start,$RESULT   \nmov finish,$RESULT  \ngmi eip,MODULESIZE  \nadd finish,$RESULT  \ngcmt finish \ncmp $RESULT,\"complete\"  \nje bypass   \ncmp $RESULT,\"done\"  \nje exit \npreop eip   \ngcmt $RESULT    \ncmp $RESULT,\"ready\" \nje check2   \npreop eip   \ngcmt $RESULT    \nmov val,$RESULT \nlen $RESULT \nifg $RESULT,1   \natoi val    \nmov val,$RESULT \nmov dll,0   \nife val>>1f,1   \nmul val,-1  \nmov addr,eip-val    \njmp boucl   \nelse    \nmov addr,eip+val    \njmp boucl2  \nendif   \nendif   \ncheck2: \nmov processkill,1   \nbypass: \nmul offst,10    \nask \"Enter value to look for (preceded by 'str:' in case of a formatted string ex: str:password ) \" \nadd offst,buff  \ncmp $RESULT, 0  \nje  theend  \nmov str,$RESULT \nmov value,$RESULT   \nstr str \nlen str \nmov tmp,$RESULT \ncmp tmp,5   \njb ok   \nstr str \nscmp  str, \"str:\", 4    \njne ok  \nbuf str \nmov [esp-100],str   \nmov value,0 \nmov value,[esp-100+4]   \nkeepon: \nmov [buff+offset-4],[esp-100+offset]    \nadd offset,4    \ncmp tmp,offset  \njbe nok \njmp keepon  \nok: \nmov [buff+offset-4],value   \nnok:    \ncmp processkill,1   \nje loop \nMSGYN \"do you want to set breakpoints on dlls ? \"   \nifeq $RESULT, 0 \nmov dll,0   \nelse    \nmov dll,1   \nendif   \ncmp $RESULT,2   \nje theend   \njmp firstcheck  \nreturnback: \nmov val,value   \nMSGYN \"do you want to trace the information ? press no to proceed smart research \"  \ncmp $RESULT, 2  \njne traced  \n\n\n\n\nfirstcheck: \nmov val,0   \nmov addr,0  \nmov tmp,0   \nmov str,0   \nrepeat: \nmov [2*str+offst],c0+str    \nadd str,1   \ncmp str,3   \njl repeat   \nmov str,value   \nbuf str \nfindmem str, addr   \ncmp $RESULT, 0  \nje cont \nmov addr,$RESULT    \nitoa addr   \nlog \"value found in memory at \" + $RESULT   \nifeq tmp,0  \nmsgyn \"value found in memory would you like to set memory breakpoint there (see log) ?\" \nmov tmp,$RESULT \ncmp $RESULT,2   \nje returnback   \nendif   \nmov val,addr    \nGMEMI addr, MEMORYBASE  \nmov addr,$RESULT    \ngmi addr,PATH   \nadd buff,300    \nmov [buff],$RESULT  \nlen [buff]  \nmov str,$RESULT \nadd str,buff    \nsub str,3   \ncmp [str],\"dll\" \nsub buff,300    \nje cont \nGMEMI addr, MEMORYSIZE  \ncmp val,start   \njb performm \ncmp val, finish \nja performm \nadd addr,$RESULT    \njmp repeat  \nperformm:   \ncmp val,stack   \njb performm2    \ncmp val, stackend   \nja performm2    \nmov addr,val    \nmov str,4   \njmp changeplan  \nperformm2:  \nmov str,$RESULT     \nsub str,1   \nchangeplan: \ncmp tmp,0   \nje saut \nbprm addr,str   \nmov val,[buff+400]  \nmov [buff+404+val],addr \nmov [buff+408+val],str  \nadd val,8   \nmov [buff+400],val  \nsaut:   \nadd addr,str    \ncmp tmp,0   \nje repeat   \njmp cont    \n\n\n\n\n\ntraced: \ncmp $RESULT, 0  \nje smartsearch  \n\n\n\nitoa val    \nmov val,$RESULT \nconcatenate:    \nlen val \ncmp $RESULT,8   \nje stopit   \nmov val,\"0\"+val \njmp concatenate \nstopit: \nmov str, \" EAX==\" + val+ \" | EBX==\" + val+ \" | ECX==\" + val+ \" | EDX==\" + val+ \" | ESI==\" + val+ \" | EDI==\" + val   \nlog \"---------------------value to trace is---------------------------\" \nlog str \nlog \"-----------------------------------------------------------------\" \nticnd str   \nmov swtch,1 \njmp passover    \ntrace:  \nprecontinue:    \nsti \nmov addr,eip    \nti  \ncmp eip,addr    \nje precontinue  \npassover:   \nifeq dll,0  \ncmp eip,start   \njb run  \ncmp eip,finish  \nja run  \njmp continue    \nrun:    \nrtr \nsti \ncmp eip,start   \njb run  \ncmp eip,finish  \nja run  \njmp trace   \nendif   \ncontinue:   \npreop eip   \nmov addr,$RESULT    \nGOPI addr, 1, DATA  \ncmp $RESULT,value   \nje detected1    \nGOPI addr, 2, DATA  \ncmp $RESULT,value   \nje detected2    \nGOPI addr, 1, ADDR  \ncmp $RESULT,7   \nja checkval \nmov val,[buff]  \ncmp swtch,1 \nje trace    \njmp redo2   \ncheckval:   \nmov tmp,0   \ncmp [$RESULT],value \nand [offst+1],ff00ff00  \nmov val,7   \nje affect   \nadd tmp,1   \ncmp [$RESULT+1],value   \nje affect   \nadd tmp,1   \ncmp [$RESULT+2],value   \nje affect   \nadd tmp,1   \ncmp [$RESULT+3],value   \nje affect   \nGOPI addr, 2, ADDR  \ncmp $RESULT,8   \nadd [offst+1],400050    \nadd [offst+1],val   \nadd [offst+3],val   \njb compare  \njmp round2  \naffect: \nadd [offst+1],400050    \nadd [offst+1],val   \nadd [offst+3],val   \nitoa $RESULT+tmp    \nmov addr,$RESULT    \nmov tmp,0   \nmov val, buff+100   \njmp concat  \nround2: \nmov tmp,0   \ncmp [$RESULT],value \nje affect   \nadd tmp,1   \ncmp [$RESULT+1],value   \nje affect2  \nadd tmp,1   \ncmp [$RESULT+2],value   \nje affect2  \nadd tmp,1   \ncmp [$RESULT+3],value   \nje affect2  \ncmp swtch,1 \nje trace    \njmp redo2   \naffect2:    \nitoa $RESULT+tmp    \nmov addr,$RESULT    \nmov tmp,0   \nmov val, buff+100   \njmp concat  \ncompare:    \nmov val,[buff]  \nmov [buff+e08],31303041 \ncmp swtch,1 \nje trace    \njmp redo2   \ndetected1:  \nGOPI addr, 1, ADDR  \njmp branch  \ndetected2:  \nGOPI addr, 2, ADDR  \nbranch:     \nmov tmp,$RESULT \nmov str,addr    \nitoa str    \nmov str,$RESULT \nitoa value  \ncmp tmp,0   \nje eaxx \ncmp tmp,1   \nje ecxx \ncmp tmp,2   \nje edxx \ncmp tmp,3   \nje ebxx \ncmp tmp,6   \nje esii \ncmp tmp,7   \nje edii \nlog \"eip=\"+str  \nmov addr,tmp    \nmov tmp,0   \nmov val, buff+100   \nitoa addr   \nmov addr,$RESULT    \nmov str,0   \nconcat: \nmov str,0   \nmov str,[buff+tmp]  \nitoa str    \nmov str,$RESULT \nmov [val] , \"[\" \nmov [val+1],  addr  \nlen [val]   \nmov [val+$RESULT], \"] == \"  \nmov [val+$RESULT+5], str    \nadd val,$RESULT+5   \nlen [val]   \nmov [val+$RESULT], \"&\"  \nadd val,$RESULT+1   \nmov [val],0 \nadd tmp,1   \natoi addr   \nmov addr,0  \nmov addr,$RESULT    \nadd addr,1  \ncmp offset-4,tmp    \njbe dobp    \ncmp [addr],[buff+tmp]   \njne dobp2   \nitoa addr   \nmov addr,$RESULT    \njmp concat  \ndobp:   \nitoa addr   \nlog \"found at :\" + $RESULT  \nmsgyn \"perfect value found in memory ,would you like to clear all previous conditional breakpoints? press no to keep all breakpoints, cancel to stop script (see log window)\"   \nifeq $RESULT,1  \nbc  \nelse    \nifeq $RESULT,2  \njmp theend  \nendif   \nendif   \ndobp2:  \nmov [val-1],0   \nmov [buff+e04],57414741 \ngstr buff+100   \nBPCND eip, $RESULT  \ncmt finish,\"done\"   \nitoa eip    \nLBL eip,\"no\"+$RESULT    \nfill buff+100, val-buff-100, 0  \nmov val,[buff]  \ncmp swtch,1 \nje trace    \njmp redo2   \neaxx:   \nlog \"eip=\"+str  \nBPCND eip, \"EAX == \" + $RESULT  \ngcmt start  \ncmp $RESULT,\"done\"  \njne check4  \ngcmt finish \ncmp $RESULT,\"complete\"  \nje check4   \nitoa eip    \nLBL eip,\"no\"+$RESULT    \ncheck4: \ncmp swtch,1 \nje trace    \njmp redo2   \nebxx:   \nlog \"eip=\"+str  \nBPCND eip, \"EBX == \" + $RESULT  \ngcmt start  \ncmp $RESULT,\"done\"  \njne check3  \ngcmt finish \ncmp $RESULT,\"complete\"  \nje check3   \nitoa eip    \nLBL eip,\"no\"+$RESULT    \ncheck3: \ngcmt start  \ncmp $RESULT,\"done\"  \njne check5  \ngcmt finish \ncmp $RESULT,\"complete\"  \nje check5   \nitoa eip    \nLBL eip,\"no\"+$RESULT    \ncheck5: \ncmp swtch,1 \nje trace    \njmp redo2   \necxx:   \nlog \"eip=\"+str  \nBPCND eip, \"ECX == \" + $RESULT  \ngcmt start  \ncmp $RESULT,\"done\"  \njne check6  \ngcmt finish \ncmp $RESULT,\"complete\"  \nje check6   \nitoa eip    \nLBL eip,\"no\"+$RESULT    \ncheck6: \ncmp swtch,1 \nje trace    \njmp redo2   \nedxx:   \nlog \"eip=\"+str  \nBPCND eip, \"EDX == \" + $RESULT  \ngcmt start  \ncmp $RESULT,\"done\"  \njne check7  \ngcmt finish \ncmp $RESULT,\"complete\"  \nje check7   \nitoa eip    \nLBL eip,\"no\"+$RESULT    \ncheck7: \ncmp swtch,1 \nje trace    \njmp redo2   \nesii:   \nlog \"eip=\"+str  \nBPCND eip, \"ESI == \" + $RESULT  \ngcmt start  \ncmp $RESULT,\"done\"  \njne check8  \ngcmt finish \ncmp $RESULT,\"complete\"  \nje check8   \nitoa eip    \nLBL eip,\"no\"+$RESULT    \ncheck8: \ncmp swtch,1 \nje trace    \njmp redo2   \nedii:   \nlog \"eip=\"+str  \nBPCND eip, \"EDI == \" + $RESULT  \ngcmt start  \ncmp $RESULT,\"done\"  \njne check9  \ngcmt finish \ncmp $RESULT,\"complete\"  \nje check9   \nitoa eip    \nLBL eip,\"no\"+$RESULT    \ncheck9: \ncmp swtch,1 \nje trace    \njmp redo2   \n\n\n\ncont:   \n\nlog \"-----------------end memorybreakpoints---------------------\"   \nloop:   \nCOE \nerun    \n\n\nifeq dll,0  \ncmp eip,start   \njb run2 \ncmp eip,finish  \nja run2 \njmp continue2   \nrun2:   \nBPMC    \nredoit: \nCOE \nerun    \ncmp eip,start   \njb redoit   \ncmp eip,finish  \nja redoit   \nmov val,0   \nmov str,buff+404    \nbpaffect:   \nbprm [str],[str+4]  \nadd str,8   \nadd val,8   \ncmp [buff+400],val  \njne bpaffect    \njmp loop    \ncontinue2:  \nendif                           \n\n\n\nmov addr, eip   \nGOPI addr, 1, DATA  \ncmp $RESULT, value  \nje detected1    \nGOPI addr, 2, DATA  \ncmp $RESULT, value  \nje detected2    \nGOPI addr, 1, ADDR  \ncmp $RESULT,7   \nja checkval \nGOPI addr, 2, ADDR  \ncmp $RESULT,8   \njb redo2    \njmp round2  \ndetected1:  \nGOPI addr, 1, ADDR  \njmp branch  \ndetected2:  \nGOPI addr, 2, ADDR  \njmp branch  \n\n\n\nifeq dll,0  \ncmp eip,start   \njb run2 \ncmp eip,finish  \nja run2 \njmp continue2   \nrun2:   \nBPMC    \nredoit: \nCOE \nrtr \nsti \ncmp eip,start   \njb redoit   \ncmp eip,finish  \nja redoit   \nmov val,0   \nmov str,buff+404    \nbpaffect:   \nbprm [str],[str+4]  \nadd str,8   \nadd val,8   \ncmp [buff+400],val  \njne bpaffect    \njmp loop    \ncontinue2:  \nendif                           \n\n\nredo2:  \n\njmp loop    \n\n\n\nsmartsearch:    \nmov dll,0   \nmov addr, eip   \nboucl:  \nmov str,addr    \npreop addr  \nifeq $RESULT,addr-1 \npreop $RESULT   \nmov addr,$RESULT    \njmp boucl   \nendif   \nmov addr,$RESULT    \ncmp addr,str    \nje finishit \nopcode addr \nmov [buff+200],$RESULT_1    \nmov str,buff+200    \nckecknext:  \nadd str,1   \nscmp  [str], \"[\", 1 \nje dobreak  \ncmp [str],0 \nje boucll   \njmp ckecknext   \ndobreak:    \nbp  addr    \nmov dll,addr-eip    \nitoa dll    \nmov dll,$RESULT \npreop eip   \ncmt $RESULT,dll \nmov val,addr    \nitoa val    \nLBL val,\"yes\"+$RESULT   \nboucll: \ngstr buff+200   \nlen $RESULT \nfill buff+200, $RESULT, 0   \njmp boucl   \n\nfinishit:   \nmov dll,0   \nmov start,addr  \nmov addr, eip   \nboucl2: \nGCI addr, size  \ncmp $RESULT,0   \nje loopp    \nmov addr,addr +$RESULT  \npreop addr  \nifeq $RESULT,addr-1 \njmp boucl2  \nendif   \nopcode addr \ncmp addr,finish \njae loopp   \nmov [buff+200],$RESULT_1    \nmov str,buff+200    \nckecknext2: \nadd str,1   \nscmp  [str], \"[\", 1 \nje dobreak2 \ncmp [str],0 \nje boucll2  \njmp ckecknext2  \ndobreak2:   \nmov dll,addr-eip    \nitoa dll    \nmov dll,$RESULT \npreop eip   \ncmt $RESULT,dll \nGCI addr, size  \nbp  addr    \nmov val,addr    \nitoa val    \nLBL val,\"yes\"+$RESULT   \nboucll2:    \ngstr buff+200   \nlen $RESULT \nfill buff+200, $RESULT, 0   \njmp boucl2  \n\nloopp:  \npreop eip   \ncmt $RESULT,\"ready\" \njmp loop    \n\nexit:   \nmov val,start   \nagain:  \nifeq val,finish \njmp lafin   \nendif   \nendif   \nmov str,\"\"  \nglbl val    \nifNeq $RESULT,0 \nMOV str,$RESULT \nendif   \nscmp str,\"yes\",3    \njne skipit  \nbc val  \nlbl val,\"\"  \nskipit: \nGCI val, size   \nmov val,val+$RESULT \njmp again   \nlafin:  \npreop eip   \ncmt $RESULT,\"\"  \ncmt finish,\"complete\"   \nmsg \"finished, save a copy of ./udd/<exename>.udd to store script results\"  \ntheend: \nRet                     \n\n```\n",
      "votes": "3",
      "user": "Abr001am",
      "time": "Jul 22, 2015 at 18:41",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "I wouldn't say I'm new to RE but I'm certainly not an expert, so please take my answer with a grain of salt. Chances are, what you are actually looking for is probably not the actual value, but how that value relates to your program, ie; the number 42 doesn't really mean anything without any context or dimension.\n\nWhat you've described would be a very naive way of finding how a program deals with and stores data, and effectively the only way to implement it, would be to continually search entire regions of memory (easily many megabytes in size), at every given moment - provided it actually stores the value in memory any way - OR, stop at every instruction to see if any reference is made to your value.\n\nThis is not impossible, but likely impractical. As mentioned in comments, The RE way of doing this, would be to find the context where your value might actually appear, for example, if you are looking for your health in a video game, you would start by finding any code that would heal you or damage you or check whether you are still alive etc.\n\nWithout any more information there is not more we can help you with, perhaps you could edit your question to provide more?\n\n",
      "votes": "0",
      "user": "Al Longley",
      "time": "Nov 22, 2014 at 6:33",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "This has multiple interpretations, which you have to deal with differently.\n\nFor this interpretation you have to find the code where your value is actually calculated. The you can set a breakpoint, inspect the values of the register in question, and continue if the value is not found.\n\nThis is the easy one. Just set a memory breakpoint on the address you know where the value must appear. Additionally you can inspect the value and only break if the value X is actually set.\n\nIn this case, the value may be stored in different adresses each time you run the code. However, you should still be able to identfy the code where the object is used, so you know the address of the object (or memoryblock). You can then reference this adress and inspect the value and continue if it is not reached.\n\nHow exactly you do each of those techniques depends on the debugger you use. I'm using usually windbg and with conditional breakpoints you can do all of this. The harder part is to find out, where exactly your value is, because in modern computers you have 4GB+ of RAM or more, so there are MANY places where the same value can be found if you just look for a particular number without context.\n\nI once write a small tool for ding this though. I created a memory dump and and looked for all places, where my value was. Then I let the program continue and took another dump when the value changed. I compared only the addresses that I found before. Usually it took only 2-3 iterations to find the address. This method only works though, if the value is always at the same address and doesn't move with dynamic allocated memory.\n\n",
      "votes": "0",
      "user": "Devolus",
      "time": "Jan 26, 2015 at 11:38",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "You can try and use DIE.\n\nDIE uses IDA's debugger to get the values passed to and from functions during runtime. After execution, it will generate a \"value-view\" window, listing all the values it collected. If your value is there, you can see where it was used / generated. Note that if the value is not passed to or returned from functions it will not appear in the value view.\n\nFrom there, you can set breakpoints (or conditional breakpoints) at the relevant locations and debug the program again.\n\nThis does require an up-to-date version of IDA Pro, though.\n\n",
      "votes": "0",
      "user": "tmr232",
      "time": "Jun 25, 2015 at 20:19",
      "is_accepted": false,
      "comments": []
    }
  ]
}