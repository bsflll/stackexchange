{
  "title": "Trying to replicate encryption of an android app",
  "link": "https://reverseengineering.stackexchange.com/questions/24771/trying-to-replicate-encryption-of-an-android-app",
  "content": "I was trying to replicate/copy the encryption of an android app which uses CryptoJS with sha256 encryption as having seen in the source code of the android app. fingerprinting the app, it was built with reactJS and TypeScript and apparently compiled with Babel compiler, which all I don't understand them thoroughly.\nthe code encrypts a signature to communicate with the server, Here is a snippet of the code:\n\n```\nf = t.type + \"&\" + encodeURIComponent(t.url) + \"&\" + n + \"&\" + u + \"&\" + b + \n                                \"&LS8goCQy4O2w5xnPmEOp/PjtKe37+d9HxRthqug9VC0=\",\nSignature = hexToBase64((0, c.default)(f).toString());\n\n```\nin the snippet code Signature = hexToBase64((0, c.default)(f).toString()); the signature is calculated but unfortunately because of source code was uglified and minified, in my research I identified the code responsible to calculate the signature is as follows:\n\n```\n__d(function (g, r, i, a, m, e, d) {\n        var t,\n        n;\n        t = this,\n        n = function (t) {\n            return (function (n) {\n                var o = t,\n                s = o.lib,\n                c = s.WordArray,\n                f = s.Hasher,\n                h = o.algo,\n                u = [],\n                l = [];\n                !(function () {\n                    function t(t) {\n                        for (var o = n.sqrt(t), s = 2; s <= o; s++)\n                            if (!(t % s))\n                                return !1;\n                        return !0\n                    }\n                    function o(t) {\n                        return 4294967296 * (t - (0 | t)) | 0\n                    }\n                    for (var s = 2, c = 0; c < 64; )\n                        t(s) && (c < 8 && (u[c] = o(n.pow(s, .5))), l[c] = o(n.pow(s, .3333333333333333)), c++), s++\n                })();\n                var _ = [],\n                v = h.SHA256 = f.extend({\n                    _doReset: function () {\n                        this._hash = new c.init(u.slice(0))\n                    },\n                    _doProcessBlock: function (t, n) {\n                        for (var o = this._hash.words, s = o[0], c = o[1], f = o[2], h = o[3], u = o[4], v = o[5], p = o[6], H = o[7], y = 0; y < 64; y++) {\n                            if (y < 16)\n                                _[y] = 0 | t[n + y];\n                            else {\n                                var w = _[y - 15],\n                                A = (w << 25 | w >>> 7) ^ (w << 14 | w >>> 18) ^ w >>> 3,\n                                S = _[y - 2],\n                                B = (S << 15 | S >>> 17) ^ (S << 13 | S >>> 19) ^ S >>> 10;\n                                _[y] = A + _[y - 7] + B + _[y - 16]\n                            }\n                            var b = s & c ^ s & f ^ c & f,\n                            x = (s << 30 | s >>> 2) ^ (s << 19 | s >>> 13) ^ (s << 10 | s >>> 22),\n                            j = H + ((u << 26 | u >>> 6) ^ (u << 21 | u >>> 11) ^ (u << 7 | u >>> 25)) + (u & v ^ ~u & p) + l[y] + _[y];\n                            H = p,\n                            p = v,\n                            v = u,\n                            u = h + j | 0,\n                            h = f,\n                            f = c,\n                            c = s,\n                            s = j + (x + b) | 0\n                        }\n                        o[0] = o[0] + s | 0,\n                        o[1] = o[1] + c | 0,\n                        o[2] = o[2] + f | 0,\n                        o[3] = o[3] + h | 0,\n                        o[4] = o[4] + u | 0,\n                        o[5] = o[5] + v | 0,\n                        o[6] = o[6] + p | 0,\n                        o[7] = o[7] + H | 0\n                    },\n                    _doFinalize: function () {\n                        var t = this._data,\n                        o = t.words,\n                        s = 8 * this._nDataBytes,\n                        c = 8 * t.sigBytes;\n                        return o[c >>> 5] |= 128 << 24 - c % 32,\n                        o[14 + (c + 64 >>> 9 << 4)] = n.floor(s / 4294967296),\n                        o[15 + (c + 64 >>> 9 << 4)] = s,\n                        t.sigBytes = 4 * o.length,\n                        this._process(),\n                        this._hash\n                    },\n                    clone: function () {\n                        var t = f.clone.call(this);\n                        return t._hash = this._hash.clone(),\n                        t\n                    }\n                });\n                o.SHA256 = f._createHelper(v),\n                o.HmacSHA256 = f._createHmacHelper(v)\n            })(Math),\n            t.SHA256\n        },\n        \"object\" == typeof e ? m.exports = e = n(r(d[0])) : \"function\" == typeof define && define.amd ? define([\"./core\"], n) : n(t.CryptoJS)\n    }, 725, [726]);\n\n\n```\nanother method with same functionality but with some minor changes was also defined:\n\n```\n    __d(function (g, r, i, a, m, e, d) {\n        var t,\n        n;\n        t = this,\n        n = function () {\n            var t = t || (function (t, n) {\n                var o = Object.create || (function () {\n                    function t() {}\n                    return function (n) {\n                        var o;\n                        return t.prototype = n,\n                        o = new t,\n                        t.prototype = null,\n                        o\n                    }\n                })(),\n                s = {},\n                c = s.lib = {},\n                u = c.Base = {\n                    extend: function (t) {\n                        var n = o(this);\n                        return t && n.mixIn(t),\n                        n.hasOwnProperty('init') && this.init !== n.init || (n.init = function () {\n                            n.$super.init.apply(this, arguments)\n                        }),\n                        n.init.prototype = n,\n                        n.$super = this,\n                        n\n                    },\n                    create: function () {\n                        var t = this.extend();\n                        return t.init.apply(t, arguments),\n                        t\n                    },\n                    init: function () {},\n                    mixIn: function (t) {\n                        for (var n in t)\n                            t.hasOwnProperty(n) && (this[n] = t[n]);\n                        t.hasOwnProperty('toString') && (this.toString = t.toString)\n                    },\n                    clone: function () {\n                        return this.init.prototype.extend(this)\n                    }\n                },\n                f = c.WordArray = u.extend({\n                    init: function (t, n) {\n                        t = this.words = t || [],\n                        this.sigBytes = void 0 != n ? n : 4 * t.length\n                    },\n                    toString: function (t) {\n                        return (t || p).stringify(this)\n                    },\n                    concat: function (t) {\n                        var n = this.words,\n                        o = t.words,\n                        s = this.sigBytes,\n                        c = t.sigBytes;\n                        if (this.clamp(), s % 4)\n                            for (var u = 0; u < c; u++) {\n                                var f = o[u >>> 2] >>> 24 - u % 4 * 8 & 255;\n                                n[s + u >>> 2] |= f << 24 - (s + u) % 4 * 8\n                            }\n                        else\n                            for (u = 0; u < c; u += 4)\n                                n[s + u >>> 2] = o[u >>> 2];\n                        return this.sigBytes += c,\n                        this\n                    },\n                    clamp: function () {\n                        var n = this.words,\n                        o = this.sigBytes;\n                        n[o >>> 2] &= 4294967295 << 32 - o % 4 * 8,\n                        n.length = t.ceil(o / 4)\n                    },\n                    clone: function () {\n                        var t = u.clone.call(this);\n                        return t.words = this.words.slice(0),\n                        t\n                    },\n                    random: function (n) {\n                        for (var o, s = [], c = function (n) {\n                            n = n;\n                            var o = 987654321,\n                            s = 4294967295;\n                            return function () {\n                                var c = ((o = 36969 * (65535 & o) + (o >> 16) & s) << 16) + (n = 18e3 * (65535 & n) + (n >> 16) & s) & s;\n                                return c /= 4294967296,\n                                (c += .5) * (t.random() > .5 ? 1 : -1)\n                            }\n                        }, u = 0; u < n; u += 4) {\n                            var h = c(4294967296 * (o || t.random()));\n                            o = 987654071 * h(),\n                            s.push(4294967296 * h() | 0)\n                        }\n                        return new f.init(s, n)\n                    }\n                }),\n                h = s.enc = {},\n                p = h.Hex = {\n                    stringify: function (t) {\n                        for (var n = t.words, o = t.sigBytes, s = [], c = 0; c < o; c++) {\n                            var u = n[c >>> 2] >>> 24 - c % 4 * 8 & 255;\n                            s.push((u >>> 4).toString(16)),\n                            s.push((15 & u).toString(16))\n                        }\n                        return s.join('')\n                    },\n                    parse: function (t) {\n                        for (var n = t.length, o = [], s = 0; s < n; s += 2)\n                            o[s >>> 3] |= parseInt(t.substr(s, 2), 16) << 24 - s % 8 * 4;\n                        return new f.init(o, n / 2)\n                    }\n                },\n                l = h.Latin1 = {\n                    stringify: function (t) {\n                        for (var n = t.words, o = t.sigBytes, s = [], c = 0; c < o; c++) {\n                            var u = n[c >>> 2] >>> 24 - c % 4 * 8 & 255;\n                            s.push(String.fromCharCode(u))\n                        }\n                        return s.join('')\n                    },\n                    parse: function (t) {\n                        for (var n = t.length, o = [], s = 0; s < n; s++)\n                            o[s >>> 2] |= (255 & t.charCodeAt(s)) << 24 - s % 4 * 8;\n                        return new f.init(o, n)\n                    }\n                },\n                y = h.Utf8 = {\n                    stringify: function (t) {\n                        try {\n                            return decodeURIComponent(escape(l.stringify(t)))\n                        } catch (t) {\n                            throw new Error('Malformed UTF-8 data')\n                        }\n                    },\n                    parse: function (t) {\n                        return l.parse(unescape(encodeURIComponent(t)))\n                    }\n                },\n                v = c.BufferedBlockAlgorithm = u.extend({\n                    reset: function () {\n                        this._data = new f.init,\n                        this._nDataBytes = 0\n                    },\n                    _append: function (t) {\n                        'string' == typeof t && (t = y.parse(t)),\n                        this._data.concat(t),\n                        this._nDataBytes += t.sigBytes\n                    },\n                    _process: function (n) {\n                        var o = this._data,\n                        s = o.words,\n                        c = o.sigBytes,\n                        u = this.blockSize,\n                        h = c / (4 * u),\n                        p = (h = n ? t.ceil(h) : t.max((0 | h) - this._minBufferSize, 0)) * u,\n                        l = t.min(4 * p, c);\n                        if (p) {\n                            for (var y = 0; y < p; y += u)\n                                this._doProcessBlock(s, y);\n                            var v = s.splice(0, p);\n                            o.sigBytes -= l\n                        }\n                        return new f.init(v, l)\n                    },\n                    clone: function () {\n                        var t = u.clone.call(this);\n                        return t._data = this._data.clone(),\n                        t\n                    },\n                    _minBufferSize: 0\n                }),\n                w = (c.Hasher = v.extend({\n                        cfg: u.extend(),\n                        init: function (t) {\n                            this.cfg = this.cfg.extend(t),\n                            this.reset()\n                        },\n                        reset: function () {\n                            v.reset.call(this),\n                            this._doReset()\n                        },\n                        update: function (t) {\n                            return this._append(t),\n                            this._process(),\n                            this\n                        },\n                        finalize: function (t) {\n                            return t && this._append(t),\n                            this._doFinalize()\n                        },\n                        blockSize: 16,\n                        _createHelper: function (t) {\n                            return function (n, o) {\n                                return new t.init(o).finalize(n)\n                            }\n                        },\n                        _createHmacHelper: function (t) {\n                            return function (n, o) {\n                                return new w.HMAC.init(t, o).finalize(n)\n                            }\n                        }\n                    }), s.algo = {});\n                return s\n            })(Math);\n            return t\n        },\n        \"object\" == typeof e ? m.exports = e = n() : \"function\" == typeof define && define.amd ? define([], n) : t.CryptoJS = n()\n    }, 726, []);\n\n\n```\nI didn't really understand which one is responsible to reproduce a signature like this : aoRxyvXwpTMh5wzMSz3nGZkkHwo6spNL1cz6qwjvnBA=\n\nadditionally in my research I was able to produce a signature but the server always returns invalid signature: \n\n```\napp signature : aoRxyvXwpTMh5wzMSz3nGZkkHwo6spNL1cz6qwjvnBA=\n\nsignature produced : Xpw28zTUMeJE9x4ki73tTs55IxDQy5Y4d0p9kgQgfo8=\n\n\n```\nwhat am I missing from the above code snippet? can I change it into a pure javascript code?\n\n",
  "votes": "2",
  "answers": 0,
  "views": "101",
  "tags": [
    "android",
    "encryption",
    "obfuscation",
    "patch-reversing",
    "javascript"
  ],
  "user": "hanan",
  "time": "Apr 21, 2020 at 8:11",
  "comments": [],
  "answers_data": []
}