{
  "title": "Correct way to understand local_ in ghidra disassembly",
  "link": "https://reverseengineering.stackexchange.com/questions/26456/correct-way-to-understand-local-in-ghidra-disassembly",
  "content": "Attached is the part of a disassembled main from a x86 binary file, generated by ghidra.\n\n```\n                             **************************************************************\n                             *                          FUNCTION                          *\n                             **************************************************************\n                             undefined main(undefined1 param_1)\n             undefined         AL:1           <RETURN>                                XREF[1]:     0804835e(W)  \n             undefined1        Stack[0x4]:1   param_1                                 XREF[1]:     08048309(*)  \n             undefined4        EAX:4          str_in                                  XREF[1]:     0804835e(W)  \n             undefined4        Stack[0x0]:4   local_res0                              XREF[1]:     08048310(R)  \n             undefined4        Stack[-0x10]:4 local_10                                XREF[6]:     08048358(R), \n                                                                                                   08048363(W), \n                                                                                                   0804836d(R), \n                                                                                                   08048388(R), \n                                                                                                   08048393(W), \n                                                                                                   0804839d(R)  \n             undefined4        Stack[-0x14]:4 local_14                                XREF[2]:     0804831a(W), \n                                                                                                   08048366(R)  \n             undefined4        Stack[-0x18]:4 local_18                                XREF[2]:     08048321(W), \n                                                                                                   08048396(R)  \n             undefined4        Stack[-0x2c]:4 local_2c                                XREF[3]:     08048369(W), \n                                                                                                   08048399(W), \n                                                                                                   080483ac(W)  \n             undefined4        Stack[-0x30]:4 local_30                                XREF[12]:    08048328(*), \n                                                                                                   08048334(*), \n                                                                                                   08048340(*), \n                                                                                                   0804834c(*), \n                                                                                                   0804835b(*), \n                                                                                                   08048370(*), \n                                                                                                   0804837c(*), \n                                                                                                   0804838b(*), \n                                                                                                   080483a0(*), \n                                                                                                   080483b4(*), \n                                                                                                   080483c2(*), \n                                                                                                   080483d0(*)  \n                             main                                            XREF[2]:     Entry Point(*), \n                                                                                          _start:08048167(*)  \n        08048309 8d 4c 24 04     LEA        ECX=>param_1,[ESP + 0x4]\n        0804830d 83 e4 f0        AND        ESP,0xfffffff0\n        08048310 ff 71 fc        PUSH       dword ptr [ECX + local_res0]\n        08048313 55              PUSH       EBP\n        08048314 89 e5           MOV        EBP,ESP\n        08048316 51              PUSH       ECX\n        08048317 83 ec 24        SUB        ESP,0x24\n        0804831a c7 45 f4        MOV        dword ptr [EBP + local_14],DAT_080a6b19          = 6Ah    j\n                 19 6b 0a 08\n        08048321 c7 45 f0        MOV        dword ptr [EBP + local_18],s_the_ripper_080a6b1e = \"the ripper\"\n                 1e 6b 0a 08\n\n```\nSame code from gdb\n\n```\n   0x08048309 <+0>: lea    ecx,[esp+0x4]\n   0x0804830d <+4>: and    esp,0xfffffff0\n   0x08048310 <+7>: push   DWORD PTR [ecx-0x4]\n   0x08048313 <+10>:    push   ebp\n   0x08048314 <+11>:    mov    ebp,esp\n   0x08048316 <+13>:    push   ecx\n   0x08048317 <+14>:    sub    esp,0x24\n=> 0x0804831a <+17>:    mov    DWORD PTR [ebp-0xc],0x80a6b19\n\n```\nWhy is ghidra changeing [ebp-0xc] to [EBP + local_14].\nSimilar question I found is Ghidra interpreting stack pointers wrongly but reading the answer, I'm not getting the meaning of [EBP + local_14] Here, is ghidra just renaming -0xc to a easily readable name like local_14? I'm not getting how to make sense of this exactly.\n\nIn the function header, it is shown that Stack[-0x10]:4 local_10. I assume it means that local_10 is 4 byte variable at Stack[-0x10], where Stack is the stack pointer upon entry to function. But why is it added to ebp. What's the meaning of that representation used by ghidra?\n\n",
  "votes": "4",
  "answers": 1,
  "views": "5k",
  "tags": [
    "disassembly",
    "binary-analysis",
    "x86",
    "gdb",
    "ghidra"
  ],
  "user": "Mah35h",
  "time": "Dec 6, 2020 at 16:52",
  "comments": [
    {
      "user": "rustyMagnet",
      "text": "Before doing anything with Ghidra, I start to help Ghidra by telling it the return types of functions ( int, void, char *, etc ). Then I do the same for the function parameters.  Just this step alone starts to clear up the local variables.  Did you try that ?",
      "time": null
    },
    {
      "user": "hairlessbear",
      "text": "One thing you can do that may make this more obvious is to turn off the setting that causes Ghidra to use the local_ variables directly in the assembly. You can do this via Edit -> Tool Options -> Listing Fields -> Operands Field -> Markup Stack Variable References. This will change the display to show the normal operands, with an arrow indicating what stack variable is being referenced.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "Since local variables are usually placed on the stack in x86 and esp register can change during function execution, it is more convenient to save the value of esp register on function entry and access data relatively to that value. ebp register is used for this purpose. So you will often see\n\n```\npush ebp\nmov ebp, esp\n\n```\nlines at the begining of functions. In the example you have provided it is the case - all local variables are accessed this way, through ebp.\n\nNow, there are two different naming conventions for local variables:\n\nWhy do we add 0x8 in the second one? Because two dwords (8 bytes) were pushed onto the stack before esp value was saved into ebp and in x86 architecture stack \"grows downwards\", which means if you push something onto it, this value will be saved there and esp will be decreased accordingly (in this case, twice, by 4 bytes). So, in your particular example, you have the instruction\n\n```\nmov    DWORD PTR [ebp-0xc],0x80a6b19\n\n```\nwhich would be displayed as\n\n```\nmov    DWORD PTR [ebp+local_c],0x80a6b19\n\n```\nin the first convention and\n\n```\nmov    DWORD PTR [ebp+local_14],0x80a6b19\n\n```\nin the second one, implemented in Ghidra, since 0xc + 0x8 = 0x14.\n\n",
      "votes": "9",
      "user": "bart1e",
      "time": "Dec 8, 2020 at 17:26",
      "is_accepted": true,
      "comments": [
        {
          "user": "Mah35h",
          "text": "Just to confirm. In the second convention, when it shows ebp+local_14 , ebp actually mean the value of esp at the beginning of of the function call and not the value of ebp when the instruction is ran?",
          "time": null
        },
        {
          "user": "bart1e",
          "text": "No, it is current ebp value (which is entry_esp-8).",
          "time": null
        },
        {
          "user": "Mah35h",
          "text": "then value of local_14 should be -0xC right. Else it'll point to wrong memory location when added with ebp",
          "time": null
        },
        {
          "user": "bart1e",
          "text": "Exactly. And that's why I called this convention \"less intuitive\".",
          "time": null
        }
      ]
    }
  ]
}