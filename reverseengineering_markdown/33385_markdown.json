{
  "title": "Optimize VAX instruction with IDA microcode",
  "link": "https://reverseengineering.stackexchange.com/questions/33385/optimize-vax-instruction-with-ida-microcode",
  "content": "I learning microcode, and i tried to use microavx plugin, it always catch Internal ERROR 50757\n\n\nI also try to code a small plugin, but got same error when run emit() function\n\n```\nimport ida_ua\nimport ida_hexrays\nimport ida_idp\nimport ida_typeinf\nimport ida_idaapi\nimport sys\nimport ida_allins\n# an empty / NULL mop_t\n\n\n# EVEX-encoded instruction, intel.hpp (ida sdk)\nAUX_EVEX = 0x10000\n\n# register widths (bytes)\nXMM_SIZE = 16\nYMM_SIZE = 32\nZMM_SIZE = 64\n\n# type sizes (bytes)\nFLOAT_SIZE = 4\nDOUBLE_SIZE = 8\nDWORD_SIZE = 4\nQWORD_SIZE = 8\n\n\ndef is_mem_op(op):\n    \"\"\"\n    Return true if the given operand *looks* like a mem op.\n    \"\"\"\n    return op.type in [ida_ua.o_mem, ida_ua.o_displ, ida_ua.o_phrase]\n\ndef is_xmm_reg(op):\n    \"\"\"\n    Return true if the given operand is a XMM register.\n    \"\"\"\n    if op.type != ida_ua.o_reg:\n        return False\n    if op.dtype != ida_ua.dt_byte16:\n        return False\n    return True\n\ndef is_ymm_reg(op):\n    \"\"\"\n    Return true if the given operand is a YMM register.\n    \"\"\"\n    if op.type != ida_ua.o_reg:\n        return False\n    if op.dtype != ida_ua.dt_byte32:\n        return False\n    return True\n\ndef is_avx_reg(op):\n    \"\"\"\n    Return true if the given operand is a XMM or YMM register.\n    \"\"\"\n    return bool(is_xmm_reg(op) or is_ymm_reg(op))\ndef is_avx_512(insn):\n    return insn.auxpref & 0x10  \n\n\ndef store_operand_hack(cdg, x, y):\n    print(\"operan\" ,x,y)\n    return cdg.store_operand(x, y)\n\n\nclass AVXLifter(ida_hexrays.microcode_filter_t):\n    def __init__(self):\n        super(AVXLifter, self).__init__()\n\n        self._avx_handlers = {\n        ida_allins.NN_vxorps: self.v_bitwise_ps,\n        }\n\n    def match(self, cdg):\n        \"\"\"\n        Return true if the lifter supports this AVX instruction.\n        \"\"\"\n        print(\"matching...\")\n        insn = cdg.insn \n        ea = insn.ea\n        #asm = ida_ua.decode_insn(insn, ea)\n        print(f\"Matching instruction at {hex(ea)}: {ida_ua.ua_mnem(ea)}\")\n        # if is_avx_512(cdg.insn):\n        #     print(\"not avx instruction\")\n        #     return False\n        return cdg.insn.itype in self._avx_handlers\n\n    def apply(self, cdg):\n        \"\"\"\n        Generate microcode for the current instruction.\n        \"\"\"\n        print(\"applying...\")\n        cdg.store_operand = lambda x, y: store_operand_hack(cdg, x, y)\n        return self._avx_handlers.get(cdg.insn.itype, lambda *args: ida_hexrays.MERR_OK)(cdg, cdg.insn)\n\n    def install(self):\n        \"\"\"\n        Install the AVX codegen lifter.\n        \"\"\"\n        print(\"installing \")\n        ida_hexrays.install_microcode_filter(self, True)\n        print(\"Installed AVX lifter... (%u instr supported)\" % len(self._avx_handlers))\n\n    def remove(self):\n        \"\"\"\n        Remove the AVX codegen lifter.\n        \"\"\"\n        print(\"removing..dn4m\")\n        ida_hexrays.install_microcode_filter(self, False)\n        print(\"Removed AVX lifter...\")\n    def v_bitwise_ps(self, cdg, insn):\n        \"\"\"\n        VORPS xmm1, xmm2, xmm3/m128\n        VORPS ymm1, ymm2, ymm3/m256\n\n        VXORPS xmm1, xmm2, xmm3/m128\n        VXORPS ymm1, ymm2, ymm3/m256\n\n        VANDPS xmm1, xmm2, xmm3/m128\n        VANDPS ymm1, ymm2, ymm3/m256\n        \"\"\"\n        assert is_avx_reg(insn.Op1) and is_avx_reg(insn.Op2)\n        op_size = XMM_SIZE if is_xmm_reg(insn.Op1) else YMM_SIZE\n\n        # op3 -- m128/m256\n        if is_mem_op(insn.Op3):\n            r_reg = cdg.load_operand(2)\n\n        # op3 -- xmm3/ymm3\n        else:\n            assert is_avx_reg(insn.Op3)\n            r_reg = ida_hexrays.reg2mreg(insn.Op3.reg)\n\n        itype2mcode = \\\n        {\n            ida_allins.NN_vorps: ida_hexrays.m_or,\n            ida_allins.NN_vandps: ida_hexrays.m_and,\n            ida_allins.NN_vxorps: ida_hexrays.m_xor,\n        }\n\n        # get the hexrays microcode op to use for this instruction\n        mcode_op = itype2mcode[insn.itype]\n\n        # wrap the source micro-reg as a micro-operand\n        r_mop = ida_hexrays.mop_t(r_reg, op_size)\n\n        # op2 -- xmm2/ymm2\n        l_reg = ida_hexrays.reg2mreg(insn.Op2.reg)\n        l_mop = ida_hexrays.mop_t(l_reg, op_size)\n\n        # op1 -- xmm1/ymm1\n        d_reg = ida_hexrays.reg2mreg(insn.Op1.reg)\n        d_mop = ida_hexrays.mop_t(d_reg, op_size)\n\n        # emit the microcode for this insn\n\n\n        cdg.emit(mcode_op, l_mop, r_mop, d_mop)\n\n        # clear upper 128 bits of ymm1\n        if op_size == XMM_SIZE:\n            clear_upper(cdg, d_reg)\n\n        return ida_hexrays.MERR_OK\n\nclass MicroAVX(ida_idaapi.plugin_t):\n    \"\"\"\n    Plugin cho AVX Lifter.\n    \"\"\"\n\n    flags = ida_idaapi.PLUGIN_PROC | ida_idaapi.PLUGIN_HIDE\n    comment = \"AVX support for the Hex-Rays x64 Decompiler\"\n    wanted_name = \"MicroAVX\"\n    loaded = False\n\n    def init(self):\n        if ida_idp.ph.id != ida_idp.PLFM_386:\n            return ida_idaapi.PLUGIN_SKIP\n\n        if not ida_hexrays.init_hexrays_plugin():\n            return ida_idaapi.PLUGIN_SKIP\n\n        self.avx_lifter = AVXLifter()\n        self.avx_lifter.install()\n        sys.modules[\"__main__\"].lifter = self.avx_lifter\n        self.loaded = True\n        return ida_idaapi.PLUGIN_KEEP\n\n    def run(self, arg):\n        ida_kernwin.warning(\"%s cannot be run as a script in IDA.\" % self.wanted_name)\n\n    def term(self):\n        if self.loaded:\n            self.avx_lifter.remove()\n            self.avx_lifter = None\n\n\ndef PLUGIN_ENTRY():\n    \"\"\"Plugin entry point for IDA Pro.\"\"\"\n    print(\"Start VAX Optimize from dn4m\")\n    return MicroAVX()\n\n\n```\n```\nInstruction type: 1114, Selected microcode op: 21\nmcode_op: 21\nl_mop: 1, 32\nr_mop: 1, 32\nd_mop: 1, 32\n401530: INTERR 50757\nException in SwigDirector_microcode_filter_t::apply (SWIG director method error. Error detected when calling 'microcode_filter_t.apply')\nTraceback (most recent call last):\n  File \"C:/Users/dn4m/AppData/Roaming/Hex-Rays/IDA Pro/plugins/xorlifting.py\", line 104, in apply\n    return self._avx_handlers.get(cdg.insn.itype, lambda *args: ida_hexrays.MERR_OK)(cdg, cdg.insn)\n  File \"C:/Users/dn4m/AppData/Roaming/Hex-Rays/IDA Pro/plugins/xorlifting.py\", line 172, in v_bitwise_ps\n    cdg.emit(mcode_op, l_mop, r_mop, d_mop)\n  File \"C:\\App\\IDA_Pro_83\\python\\3\\ida_hexrays.py\", line 16693, in emit\n    return _ida_hexrays.codegen_t_emit(self, *args)\nRuntimeError: INTERR: 50757\n\n```\n",
  "votes": "0",
  "answers": 0,
  "views": "27",
  "tags": [
    "ida",
    "assembly"
  ],
  "user": "3ud4jm0nj4",
  "time": "Feb 13 at 9:15",
  "comments": [],
  "answers_data": []
}