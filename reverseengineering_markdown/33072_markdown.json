{
  "title": "IDAPython: Getting all arguments passed to function",
  "link": "https://reverseengineering.stackexchange.com/questions/33072/idapython-getting-all-arguments-passed-to-function",
  "content": "I am working on getting two specific arguments from a function that is called around 1000 times in an executable. Is there any way of looping through all XREFs that reference the function and print out the arguments supplied to it?\n\nThis question was asked before on Is there any way to get a list of function arguments used with IDC? but I'm wondering if it is possible via IDAPython specifically\n\n",
  "votes": "1",
  "answers": 2,
  "views": "126",
  "tags": [
    "ida",
    "x86",
    "idapython"
  ],
  "user": "Surasia",
  "time": "Jul 11, 2024 at 8:51",
  "comments": [
    {
      "user": "Ali Rizvi-Santiago",
      "text": "How do you plan to process it, (or rather) what information are you trying to extract? Do you just want to print out the address of each call along with the inputs that are fed to it (like via the decompiler), or do you want the address of each param and its storage (like via the disassembler)? As mentioned in the ref'd question, each parameter is likely calculated...which makes the decompiler better for just displaying things for comparison. However, if you're trying to process the storage location, addressing, (or something else) the disassembler might be better for that.",
      "time": null
    },
    {
      "user": "Surasia",
      "text": "this is one of the cases that all functions simply pass a constant defined at a memory address to the function, so I'd like to get what is defined in that memory adrdess.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "You can also use the minsc plugin, over at https://github.com/arizvisa/ida-minsc which aims to simplify a lot of these common reversing tasks with regards to scraping things out of (or importing things into) the disassembler.\n\nDisclaimer: I maintain the minsc plugin, over at https://github.com/arizvisa/ida-minsc.\n\nThe following snippet requests all \"up\" references to a function \"threadSafeObjectAllocator_170b0\" that are executable (+x). This implies that each returned reference will be a branch instruction. The list of references are then assigned to the variable \"calls\".\n\n```\nimport database as db, function as func, instruction as ins\nea = 'threadSafeObjectAllocator_170b0'\ncalls = {ref for ref in func.up(ea) if 'x' in ref}\nprint([(n, \"{!s}\".format(t), s) for n, t, s in zip(func.args.names(func.by(ea)), func.args(func.by(ea)), func.args.storage(func.by(ea)))])\n\n```\nAfterwards, the list of calls will be used to get the address of the instruction for the desired parameter, \"desired_argument_index\". As we are making an assumption that the parameter that we want to scrape is an integer, we can use instruction.ops_immediate to filter the instruction for any operands that constain immediate values. We then collect both the address of the call instruction and the operand containing the immediate being used as one of the call instruction's parameters.\n\n```\nimmediates = []\nfor call in calls:\n    args = func.xref.args(call)         # idaapi.get_arg_addrs(int(call))\n    arg = args[desired_argument_index]\n    oprefs = ins.ops_immediate(arg)\n    immediates.extend(((call, opref) for opref in oprefs))\n\n# output our results\nfor call, ref in immediates:\n    print(db.disasm(call), ins.op(ref))\n\n```\nTo save what we just determined, we can iterate through our list of \"immediates\" and apply the operand value from each item as a tag for the address of each \"call\" in the list. This way if we want to get the results at a later point of time (perhaps to process it differently), we can use the tag to query it, process it differently, and format it according to our needs.\n\n```\ntagname = 'parameter.1'\n\nfor call, opref in immediates:\n    db.tag(call, tagname, ins.op(opref))\n    print('found op', ref, hex(ins.op(ref)), db.disasm(ref))\n\n# use db.selectcontents to query all functions containing our tag,\n# and then query each function for the immediate was just stached\n# so that we can decode the string referenced by each immediate.\nfor f, _ in db.selectcontents(tagname):\n    for ea, res in func.select(f, tagname):\n        print(db.disasm(ea), db.get.string(res[tagname]))\n    continue\n\n```\nAs per the selected answer, the decompiler supports the simplification of expressions and in some situations can be a better choice. Taking inspiration from the plugin bundled with the weggli project at https://github.com/weggli-rs/weggli, you can combine it with the decompiler to filter for certain expressions. Although this is experimental (in regards to minsc), there is a GH discussion on this toy at https://github.com/arizvisa/ida-minsc/discussions/194. (Feel free to ask related questions there too).\n\n```\nimport hexrays\nrefs = {ref for ref in func.up(ea) if 'x' in ref}\nfor cf in map(hexrays.function, refs):\n    for expr in hexrays.match(cf, 'threadSafeObjectAllocator_170b0(_);'):\n        call_expr = hexrays.tree.parent(cf, expr, opname='call')\n        print(hex(expr.ea), hexrays.repr(call_expr))\n    continue\n\n```\nResults look like the following. At this point you can just follow the original answer to get from the cexpr_t of type cot_call (stored as \"call_expr\") to the cnumber_t for your parameter, and then convert it to an integer in a similar way.\n\n```\n277a13da threadSafeObjectAllocator_170b0(1, 0x1A4u, 'WVMC', 0x4000, sub_277EC9B9, (void **)&lp_object_4)\n277bf49a threadSafeObjectAllocator_170b0(1, 0xC0u, 1213481296, 1, (void (__cdecl *)(void *))JSVDA::object_78250::destroy_67f69, (void **)&ap_result_14)\n277bf49a threadSafeObjectAllocator_170b0(1, 0x10u, 1196641612, 0x4000, (void (__cdecl *)(void *))sub_277BEDE1, (void **)(ap_result_14[45] + 28))\n277ca8bb threadSafeObjectAllocator_170b0(1, 0xCu, 'IPSF', 0x4000, sub_277A77CC, (void **)v34 + 10)\n277a5dc5 threadSafeObjectAllocator_170b0(1, 0xCu, 1230000966, 0x4000, sub_277A77CC, (void **)v69 + 10)\n...\n277b6c64 threadSafeObjectAllocator_170b0(1, av_size_8 + 0xA8, 'IEV', 0x4000, (void (__cdecl *)(void *))threadSafeHeapFree_177eb, (void **)&ap_result_14)\n277b6c25 threadSafeObjectAllocator_170b0(1, av_size_8 + 32, 'GES', 0x4000, jsvda_943, (void **)&ap_result_14)\n277b6c00 threadSafeObjectAllocator_170b0(1, av_size_8 + 16, 'CCV', 0x4000, (void (__cdecl *)(void *))threadSafeHeapFree_177eb, (void **)&ap_result_14)\n277b6b9e threadSafeObjectAllocator_170b0(1, av_size_8 + 52, 'AFV', 0x4000, (void (__cdecl *)(void *))threadSafeHeapFree_177eb, (void **)&ap_result_14)\n277b6bc3 threadSafeObjectAllocator_170b0(1, av_size_8 + 16, 'BCV', 0x4000, sub_277B8E42, (void **)&ap_result_14)\n\n```\n",
      "votes": "1",
      "user": "Ali Rizvi-Santiago",
      "time": "Jul 20, 2024 at 2:27",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "As per the accepted answer in the referenced question, you can decompile each function referencing your target function, and then scrape your results out of the ctree representation. This can be done with the visitor pattern implemented by the ida_hexrays.ctree_visitor_t class while filtering for the cot_call expression type. The following closure implements a filter that collects each expression into a list.\n\n```\nimport ida_hexrays\n\n# via ctree\ndef collect_exprs_with_op(body, ops):\n    res = []\n    class visitor_pattern_sucks(ida_hexrays.ctree_visitor_t):\n        def visit_expr(self, cexpr):\n            if cexpr.op in ops:\n                res.append(cexpr)\n            return 0\n    visitor_pattern_sucks(0).apply_to(body, None)\n    return res\n\n```\nAfter that, you then need to collect references to your target function so that you can decompile each function containing a reference, and extract the full expression from the decompiler output.\n\n```\n# vars to use for stuff\nea = int(whatever_address)\ndesired_argument_index = int(1)\n\n# collect references to address (calls and branches)\nrefs = []\nfor X in idautils.XrefsTo(ea):\n    if X.type in {idaapi.fl_CF, idaapi.fl_CN, idaapi.fl_JF, idaapi.fl_JN}:\n        refs.append(X.frm)\n    continue\n\n```\nNext you need to use those references to decompile each function being referenced, and then use the collect_exprs_with_op function (that we defined) to collect all the cot_call expressions. Afterwards, each cexpr_t can be filtered for any that match the list of references that were just used.\n\n```\n# decompile the function associated w/ each reference.\ncollection = []\nfor fn in map(idaapi.get_func, refs):\n\n    # if idaapi.get_func returned None, then the reference\n    # isn't in a function and it can be skipped.\n    if not fn:\n        continue\n\n    # decompile function and use visitor to enumerate\n    # the entire ctree body for any citem that is \"cot_call\".\n    cfunc = ida_hexrays.decompile_func(fn)\n    exprs = collect_exprs_with_op(cfunc.body, {ida_hexrays.cot_call})\n\n    # filter each expression for an address that\n    # matches one of our references.\n    filtered = [cexpr for cexpr in exprs if cexpr.ea in refs]\n\n    # stash each expression into our list\n    collection.extend(filtered)\n\n```\nNow that each expression has been collected, we can iterate through each cot_call expression and extract the desired argument from its \"operands\". For cot_call, the function arguments can be reached via the \"a\" attribute which is of type carglist_t and can be treated as an array.\n\n```\n# iterate through filtered expressions, collect the\n# arguments, select our desired index, and then stash\n# both the call expression and the argument we want.\nresults = []\nfor call in collection:\n    args = call.operands['a']\n    arg = args[desired_argument_index]\n    results.append((call, arg))\n\n```\nNow the results contain the ctree expression for each call, and the carg_t for the selected argument. If the expression type is a number, you can access it via the \"n\" attribute. If it's an expression, use the \"x\" attribute. If it's already your desired reference, you can access its address via \"obj_ea\". Each expression type and the attribute to use for its operands can be found in the hexrays.hpp file under the enum ctype_t enumeration.\n\n```\nfor call, arg in results:\n    print(hex(call.ea), call.dstr())\n    print(hex(arg.ea), arg.op, arg.dstr())\n\n```\nThat will output results that look like this.\n\n```\n277a13e5 threadSafeObjectAllocator_170b0(1, 0x1A4u, 'WVMC', 0x4000, sub_277EC9B9, (void **)&lp_object_4)\n277a13d0 61 'WVMC'\n277a16c9 threadSafeObjectAllocator_170b0(1, 0xCu, 4475977, 0x4000, sub_277F1377, (void **)&ap_result_14)\n277a16c0 61 4475977\n277a1a28 threadSafeObjectAllocator_170b0(1, sizeof(threadContext_19c5), 'TTTV', 0x4000, (void (__cdecl *)(void *))sub_277F128A, (void **)&lp_threadContext_4)\n277a1a1f 61 'TTTV'\n277a25d0 threadSafeObjectAllocator_170b0(1, 0xCu, 'IPSF', 0x4000, sub_277A77CC, (void **)&lp_objectFSPI_4)\n277a25c7 61 'IPSF'\n277a2620 threadSafeObjectAllocator_170b0(1, 0xCu, 'IPSF', 0x4000, sub_277A77CC, (void **)&lp_objectFSPI_4)\n...\n2780d98e threadSafeObjectAllocator_170b0(1, 0x34u, 'VIVN', 0x4000, sub_2780E590, (void **)((char *)ap_result_c + v39))\n2780d985 61 'VIVN'\n2780dcbe threadSafeObjectAllocator_170b0(1, 0x18u, 1414092366, 0x4000, sub_2780F124, (void **)&ap_result_14)\n2780dcb3 61 1414092366\n\n```\nIn order to convert a cnumber_t (from the \"n\" attribute) to a python integer, you'll need to get an instance of the tinfo_t to fit the integer to with cnumber_t.value. In most cases you can be lazy and just create a tinfo_t for an integer.. However, to copy the parameter type from your target function you can grab its type and use tinfo_t.get_nth_arg.\n\n```\nprototype = idc.guess_func(ea)\nti = prototype.get_nth_arg(desired_argument_index)      # lazy: idaapi.tinfo_t(idaapi.BT_INT)\n\n# Output each integer.\nfor call, arg in results:\n    print(hex(arg.n.value(ti)))\n\n```\nHowever, it's also probably worth noting that you can also use cexpr_t.dstr to render to a string and then parse it like that if you don't care to go this far.\n\nIf you prefer to avoid the decompiler for some reason (incorrect frames, not all refs are in a function, speed, etc.), you can utilise the parameter identification and tracking system (PIT) in some cases to locate the instruction responsible for passing the parameter to your target function. This PIT feature is what produces those comments containing the parameter name/type in the disassembly before calling a target function and can allow you to avoid having to extract the location information using the target function's prototype. You can access this information in IDAPython via the idaapi.get_arg_addrs function.\n\n```\ncandidates = []\nfor ea in refs:\n    locations = idaapi.get_arg_addrs(ea)\n    location = locations[desired_argument_index]\n    candidates.append(location)\n\n```\nIt is probably important to note that if there is more than one path that assigns the parameters needed to call a particular function, the get_arg_addrs api will prioritize the addresses of the parameters that are contiguous to the basic-block containing your target instruction (as opposed to the parameters initialized by the basic-block that branches to your target instruction).\n\nAfter getting the address of each instruction responsible for passing the parameter that you are interested in, it is necessary to decode the instruction in order to extract your desired value out of its operands. For non-zero constants, it is pretty common that your value is an immediate that can be easily decoded out of the operand. In other cases, though, your value may be calculated by instructions prior to calling your target function. It is for this reason that it is generally recommended to use the decompiler's output which simplifies the inputs that are used for a function's parameters.\n\nThe next snippet uses the addresses collected via get_arg_addrs to decode the instruction identified by the disassembler as corresponding to the target function's parameters. After decoding the instruction, the operands are checked in order to identify the one that is being used to modify memory (or register) in order to pass a value as a parameter. From the operand, we can extract the constant that we want and then save it for later.\n\n```\n# this is not using reg_accesses_t vector (7.5), opting instead for\n# the CF_USE flags to identify the instruction operand being used.\nfor location in candidates:\n    insn = idaapi.insn_t()\n    length = idaapi.decode_insn(insn, location)\n\n    indices = [idaapi.CF_USE1, idaapi.CF_USE2, idaapi.CF_USE3, idaapi.CF_USE4, idaapi.CF_USE5, idaapi.CF_USE6, idaapi.CF_USE7, idaapi.CF_USE8]\n    used_operands = [index for index, flag in enumerate(indices) if insn.get_canon_feature() & flag]\n\n    # generally, something hacky like rendering the whole mnemonic\n    # or the operand as a string to process would also suffice.\n    operands = [insn.ops[index] for index in used_operands]\n    for op in operands:\n        if op.type in {idaapi.o_imm}:\n            immediates.append(op.value)\n        continue\n    continue\n\n```\n",
      "votes": "1",
      "user": "Ali Rizvi-Santiago",
      "time": "Jul 20, 2024 at 1:44",
      "is_accepted": false,
      "comments": []
    }
  ]
}