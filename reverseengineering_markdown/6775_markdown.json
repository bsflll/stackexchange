{
  "title": "Why are those instructions generated?",
  "link": "https://reverseengineering.stackexchange.com/questions/6775/why-are-those-instructions-generated",
  "content": "After disassembling a program, I see the following asm code generated :\n\n```\n.text:004D5911 mov     [ebp+var_4], ecx\n.text:004D5914 mov     ecx, [ebp+var_4]\n.text:004D5917 test    ecx, ecx\n.text:004D5919 jnz     short loc_4D591F\n\n```\nI don't get why [ebp+var_4] is copied back to ecx.\n\nIs this an artifact (missed optimization) from the compiler which requires test to take registers as operands?\n\n",
  "votes": "8",
  "answers": 1,
  "views": "240",
  "tags": [
    "disassembly",
    "compilers"
  ],
  "user": "Eric",
  "time": "Dec 7, 2014 at 12:57",
  "comments": [
    {
      "user": "Guntram Blohm",
      "text": "You answered your own question. Yes.",
      "time": null
    },
    {
      "user": "Guntram Blohm",
      "text": "This might also be part of a loop that starts at 4D5914, with the first instruction initializing the loop control variable. Though this seems unlikely, since a) the jnz jumps if cx is not zero, and b) this seems to be an IDA disassembly, and ida would have generated a loc_... label if there was a jump to this address.",
      "time": null
    },
    {
      "user": "Fewmitz",
      "text": "I've also seen compilers do this for alignment reasons. inside a particular section",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "This is a common pattern in assembly generated by gcc at least. When it is not asked to optimize the generated code, the translation between C and asm is really straightforward. One statement in C produces a few lines of asm. Next statement: a few more lines of asm, and so on.\n\nIn your case:\n\n```\nmov     [ebp+var_4], ecx\n\n```\nis probably the end of a line of C, while:\n\n```\nmov     ecx, [ebp+var_4]\n\n```\nis the beginning of the next one.\n\nThese instructions are optimized out as soon as -O1 (or higher) is provided.\n\n",
      "votes": "3",
      "user": "Celelibi",
      "time": "Dec 8, 2014 at 3:21",
      "is_accepted": false,
      "comments": [
        {
          "user": "David Hoelzer",
          "text": "Optimization, as mentioned in this answer, will eliminate this oddity which you have correctly identified as a compiler artifact.  Things like these are quite useful for figuring out whether code was \"hand written\", compiled or, potentially, identifying which compiler was used to build a particular piece of code.",
          "time": null
        }
      ]
    }
  ]
}