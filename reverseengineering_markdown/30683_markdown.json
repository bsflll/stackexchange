{
  "title": "Need help decoding bytes to number",
  "link": "https://reverseengineering.stackexchange.com/questions/30683/need-help-decoding-bytes-to-number",
  "content": "I've got a really really old file format from an accounting software, late '70s, DOS, QBasic or QuickBasic. Source code is lost, only .exe file remaining, file needs emulator.\n\nThe file formate seems to be mainly nullterminated strings and unsigned values, usually 2 bytes / 16 bits in Little Endian notation.\n\nI have received some data and can read most of it, but there's a really strange encoding for the transaction value. I've collected all the data and posted it in a Google Sheet:\nhttps://docs.google.com/spreadsheets/d/1hV2cvtVP7YEMxwiEizNZYO89JF_zFhzJbUl9WqWTmx8/edit?usp=sharing (no sign-in required).\n\nI have tried to decode the number.\n\nI have decoded the last byte (byte 7, column AF) and somewhat matched it with the expected value, IF the first (leftmost) bit is a 1.\nThe (java) formula then is:\n\n```\n        final byte lastByte = s.Byte7;\n        final byte testByte = (byte) (lastByte & 0b01111111);\n        if (testByte == lastByte) continue; // does not start with 1-bit\n\n        final double result = Math.pow(2, testByte - 1);\n\n```\nSo in other words, if we have the byte 7 and lose its leading 1, it's v = 2^(byte7-1).\nThis brings exact results for all values being of 2^x. Any other values are close, but I assume the other bytes need to be taken into account then, too.\n\nHaven't gotten further yet. Perhaps it's an old standard of storing floating point values, but I've never seen this before, and it looks like it has nothing to do with the IEEE floating point numbers of Java, because I tried all conversions (LE/BE, bytes2float/double, signed/unsigned, exponential and logarithmic conversions).\n\nI'll try Base64 and other not-8-bits-per-byte strategies next.\n\nI'll post a bounty of 200 ASAP. (Update: A bounty of 100, as I'm new to this site and only have 101 reputation yet... sorry)\n\nUpdate: Looks like this is simply the old Microsoft Binary Format. Now I'll write some converting algorithm to read it in Java.\n\n",
  "votes": "2",
  "answers": 1,
  "views": "112",
  "tags": [
    "binary-analysis",
    "binary-format",
    "unknown-data"
  ],
  "user": "JayC667",
  "time": "Jul 23, 2022 at 9:09",
  "comments": [],
  "answers_data": [
    {
      "content": "Okay, I finally managed to convert it.\n\nUsually a byte-wise conversion is way better than what I did here, but result are OK so far, and basically it's all the same anyway.\n\nAnd yes, I'm not taking care of infinity or NaN or all the other exceptional values.\n\n```\nstatic public double fromMBF64(final byte[] msbin) {\n    if (msbin == null) throw new IllegalArgumentException(\"msbin can not be null.\");\n    if (msbin.length != 8) throw new IllegalArgumentException(\"msbin has wrong size. Expected 8 bytes, but got \" + msbin.length + \" instead.\");\n\n    final int expBiased = JcUMath.toUnsigned(msbin[0]) - 128 - 1;\n    final double exp = Math.pow(2, expBiased);\n    final int sign = JcBits.testBit(msbin, 8) ? -1 : 1;\n    double mantisse = 1;\n    for (int i = 0; i < 55; i++) {\n        final int pos = 9 + i;\n        final boolean isSet = JcBits.testBit(msbin, pos);\n        if (!isSet) continue;\n\n        final double expVal = Math.pow(2, i + 1);\n        final double off = 1 / expVal;\n        mantisse += off;\n    }\n    return sign * exp * mantisse;\n}\n\n```\nalong with the utility functions\n\n```\nstatic public long toUnsigned(final int pValue, final long pMaxValue) {\n    if (pValue >= 0) return pValue;\n    return pValue + (2 * pMaxValue + 2);\n}\nstatic public short toUnsigned(final byte pValue) {\n    return (short) toUnsigned(pValue, Byte.MAX_VALUE);\n}\n\nstatic public boolean testBit(final long pVariable, final int pTestPosition) {\n    final long pattern = 1L << pTestPosition;\n    return (pVariable & pattern) != 0;\n}\nstatic public boolean testBit(final byte[] pBytes, final int pIndex) {\n    final int arrIndex = pIndex / 8;\n    final byte b = pBytes[arrIndex];\n    final int bit = 7 - pIndex % 8;\n    return testBit(b, bit);\n}\n\n```\nNote that the bytes have to be in Big Endian order. So if you're reading Little Endian, simply reverse the byte[]:\n\n```\nstatic public byte[] reverse(final byte[] pArray, final int pOffset, final int pLength) {\n    if (pArray == null) return null;\n    if (pLength < 1) return new byte[0];\n\n    final byte[] ret = new byte[pLength];\n    for (int i = 0; i < pLength; i++) {\n        final byte t = pArray[pOffset + pLength - i - 1];\n        ret[i] = t;\n    }\n    return ret;\n}\nstatic public byte[] reverse(final byte... pArray) {\n    if (pArray == null) return null;\n    return reverse(pArray, 0, pArray.length);\n}\n\n```\nWhen I find the time I'll create a bit-shifting-based conversion, similar to this: https://gist.github.com/pmachapman/05094e12d0711745e3fd7093f7ab67cf, and post it in here.\n\n",
      "votes": "2",
      "user": "JayC667",
      "time": "Jul 25, 2022 at 10:09",
      "is_accepted": false,
      "comments": []
    }
  ]
}