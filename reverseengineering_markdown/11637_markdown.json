{
  "title": "How to display only the IR for your program code",
  "link": "https://reverseengineering.stackexchange.com/questions/11637/how-to-display-only-the-ir-for-your-program-code",
  "content": "I have a simple C program that is literally\n\n```\nint main(void) {\n    return 0;\n}\n\n```\nWhen I convert this to assembly, gcc -S, it grows to around 10 lines. As expected.\n\nThen when I convert it into binary, and then from that to VEX IR it grows to * a lot * of instructions. You can see this with valgrind --tool=lackey --trace-mem=yes <FILE>\n\nMy question is two-folded:\n\n",
  "votes": "2",
  "answers": 1,
  "views": "1k",
  "tags": [
    "decompilation"
  ],
  "user": "soupman",
  "time": "Jun 17, 2020 at 9:54",
  "comments": [],
  "answers_data": [
    {
      "content": "What follows is based primarily on information found in  Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation.\n\nThere are at least 2 reasons for this:\n\nWhen I executed valgrind --tool=lackey --trace-mem=yes test, where test was an ELF32 binary created from the example C code in the original post using GCC, these were the results (truncated, plus arrows pointing to lines that will be discussed subsequently):\n\n```\n.\n.\n.\nI  04cec101,3\nI  04cec104,3\nI  04cec107,2\n==11736== \n==11736== Counted 0 calls to main()                <---------- (1)\n==11736== \n==11736== Jccs:\n==11736==   total:         44,420\n==11736==   taken:         21,288 ( 47%)\n==11736== \n==11736== Executed:\n==11736==   SBs entered:   44,083\n==11736==   SBs completed: 30,750\n==11736==   guest instrs:  211,953                 \n==11736==   IRStmts:       1,304,900               \n==11736== \n==11736== Ratios:\n==11736==   guest instrs : SB entered  = 48 : 10\n==11736==        IRStmts : SB entered  = 296 : 10\n==11736==        IRStmts : guest instr = 61 : 10   <---------- (2)\n==11736== \n==11736== Exit code:       0\n\n```\nAs we can see at (2), there are significantly more IR statements than machine code instructions, which is in line with what is expected of translation of CISC instructions into Valgrind's IR.\n\n(1) has to do with the second part of the question \n\nHere is an example of a single x86 instruction producing multiple IR statements:\n\n```\n0x24F27C: addl %ebx,%eax                 <---------- x86 instruction + operands\n4: ------ IMark(0x24F27C, 2) ------\n5: PUT(60) = 0x24F27C:I32       # put %eip\n6: t3 = GET:I32(0)              # get %eax\n7: t2 = GET:I32(12)             # get %ebx\n8: t1 = Add32(t3,t2)            # addl\n9: PUT(32) = 0x3:I32            # put eflags val1\n10: PUT(36) = t3                # put eflags val2\n11: PUT(40) = t2                # put eflags val3\n12: PUT(44) = 0x0:I32           # put eflags val4\n13: PUT(0) = t1                 # put %eax\n\n```\nThis does not seem possible due to how Valgrind transforms machine code (disassembly + resynthesis). \n\nWe observe in (1) that 0 calls to main() were made when Valgrind instrumented the test binary. Since main() does nothing, it is possible that it is optimized out during the machine code -> IL -> instrumented IR -> machine code translation process.\n\nThe translation process actually consists of 8 phases, where\n\nAfter optimization and potentially arbitrary transformation, it is an open question as to whether any of the IR code output by lackey bears any discernible resemblance to the machine code generated by GCC for main().\n\nSupplementary resources:\n\nhttps://fosdem.org/2017/schedule/event/valgrind_vex_future/\n\nhttps://fosdem.org/2017/schedule/event/valgrind_vex_future/attachments/slides/1842/export/events/attachments/valgrind_vex_future/slides/1842/valgrind_vex_future.pdf\n\nhttps://github.com/trailofbits/libvex/blob/master/VEX/pub/libvex_ir.h\n\nhttps://arxiv.org/pdf/0810.0372.pdf\n\nhttp://www.ittc.ku.edu/~kulkarni/teaching/EECS768/slides/chapter3.pdf\n\nhttps://docs.angr.io/docs/ir.html\n\n\n1. Nicholas Nethercote and Julian Seward. Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation. In Proc. of the ACM SIGPLAN 2007 Conference on Programming Language Design and Implementation (PLDI), June 2007.\n\n\n",
      "votes": "4",
      "user": "julian",
      "time": "Aug 12, 2017 at 4:20",
      "is_accepted": false,
      "comments": []
    }
  ]
}