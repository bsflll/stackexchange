{
  "title": "Find flag from GO binary challenge [closed]",
  "link": "https://reverseengineering.stackexchange.com/questions/21519/find-flag-from-go-binary-challenge",
  "content": "I have GO binary file from challenge (that already over).\n\nI spent around 3 days to find the flag without results.\n\nI'm trying to load the file with gdb and using the following command:\n\nFirst, Trying to find the entry point:\n\n```\ninfo files\n\n```\nAfter I got the entry point I did break *<ENTRYPOINTADDR>\nThen layout asm and then I just try to figure when I need to add break point before the print that ask me to enter a password.\n\nAlso trying with info frame and show registers and to print the values but nothing found.\n\nI just want to learn how to find the flag from this ELF file\n\nI would love to know how to solve it\n\nGO binary File\n\n",
  "votes": "0",
  "answers": 2,
  "views": "2k",
  "tags": [
    "patch-reversing"
  ],
  "user": "user28772",
  "time": "5 years ago",
  "comments": [],
  "answers_data": [
    {
      "content": "Since you have already spent a lot of time on it, I will just show you how to solve it step by step. I recommend you to repeat steps I'm describing, since the best way to learn is to practice.\n\nI will use radare2 for solving this challenge, but it's of course possible to use other tools as well. The reason I chose it is simple: it recognises go library functions, so it will be easier to find interesting parts of the executable.\n\nAt the beginning, we have to find out where to start our analysis. Run:\n\n```\nr2 -c aei -d revengme\n\n```\nto open this program in debug mode in radare2. Then type aaa to analyse entire binary. It may take some time; just wait until it finishes.\n\nNow, to go to the main function, type:\n\n```\ns sym.go.main.main\n\n```\nYou may now see its contents by typing pdf. You will see several library functions there. Since, at this point we know only that the program prints something and waits for some input, it's natural to look for routines performing these tasks. To find every call to functions printing output, you can use radare2 internal grep like so:\n\n```\npdf ~print\n\n```\n, to search for 'print' pattern in the pdf output. You may do the same thing with Read to see only one reference to sym.go.bufio.__Reader_.ReadLine.\n\nSince analysing program control flow is easier in graph mode, let us switch to it by typing V! and then G. You will see something like this:\n\n\n\nand you may navigate using arrows to see the rest of the graph. In the image above, we can spot two interesting functions: sym.go.bufio.__Reader_.ReadLine as stated previously and sym.go.main.ObfStr that suggests that most important strings are obfuscated as we could have expected.\n\nNow, after reading user input the program has to somehow check if it's valid. So we are looking for the fragment responsible for it.\n\n\nOn the image above, you may spot a call to sym.go.runtime.memequal that seems to do this job. You may see its signature here, but it basically takes two pointers to memory regions and the length to compare them. Additionally, it is only called when value in rcx is equal to [rsp+20h] as shown in the upper rectangle.\n\nHence, we may conclude that [rsp+20h] actually contains the length of the password we are trying to obtain. In fact we see even more: we know where the addresses of strings being compared are stored! These are [rsp] and [rsp+8h] respectively. And that is the end of our static analysis. We may now proceed to dynamic one.\n\nWe run radare2 in debug mode to be able to dynamically analyse the program and now we will do so.\n\nWe just put the breakpoints where we want to see actual memory stored on the stack. We have to know two things:\n\nHence our points of interest are those two presented on the second image. Since it isn't position independent code, their addresses will not change throughout different executions. These are:\n\nTo put breakpoints there, use db address command. To continue execution until they are hit, use dc. You will be prompted to write the password, but write anything - at this moment we only want to get the expected length of the string. After the first breakpoint is hit, run V! once again to see:\n\nOn the upper right corner you can see the stack contents. Now we are only interested in length, so [rsp+20h]. The value stored there is displayed in the third row - it is 0x26, so the password contains 38 characters.\n\nNow, type ood to restart the application (it will preserve the breakpoints however). Since you know that the password length is 38 just type 38 random characters when you are prompted to. Then, when you hit the second breakpoint, you may read the stack contents once again and you will see the addresses of two strings: one that you have just typed, and the second, desired one.\n\nImportant note: the pointers will be shown in little endian format, so starting with the least significant byte and ending with the most significant one.\n\nYou will be interested in 0xc000018240, that contains the string you are looking for, that is:\n\n```\nBSidesTLV{revenge is best served cold}\n\n```\nNote2: To cause radare2 to treat n specific bytes as data in current location, you can use Cd n command.\n\n",
      "votes": "3",
      "user": "Community",
      "time": "Jun 17, 2020 at 9:54",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "bart1e answered your question right \nthis is just an extension to his answer with a different tool ghidra and reversing purely statically without running the binary.\n\ngolang uses a different approach to calling functions it provides a memory slot in stack for arguments to the functions as well as multiple values it can return from a function \n\nfor example a function can return a sum and product of two integers in the same function like   \n\nfunc doMagic (x,y) { return x+y ,x*y ) \n\nso roughly the disassembly will look like\n( it is just a simplification of details not absolute syntax or exact types are used )\n\nit just tries to reiterate how golang uses stack\ninstead of traditional x64 abi registers or x86 abi memory / stack for arguments and conventional\nreturns in rax/eax \n\n```\nmov [stack] , x\nmov [stack] , y\nmov [stack] , &fret1\nmov [stack] , &fret2\ncall doMagic\n\nand inside doMagic \nt1 = x \nt2 = y\nt3 = t1  + t2\nt4 = t1  * t2\nfret1 = t3\nfret2 = t4\nret\n\n```\nso reading around I found golang embeds the function names and its address in .gopclntab section and was fooling around with renaming the functions and successfully renamed the functions with this hack of script below but the decompilation was still looking a horrible mess\n\n```\nfrom ghidra import *\nmem = currentProgram.getMemory()\nstart = mem.getBlock(\".gopclntab\").getStart()\nprovider = ghidra.app.util.bin.MemoryByteProvider(mem,start)\nbread = ghidra.app.util.bin.BinaryReader(provider,True)\nnumfun = bread.readInt(8)\nfor i in range(0x10,numfun*0x10,0x10):  \n    faddr = bread.readInt(bread.readInt(i+8))\n    fname = bread.readAsciiString(bread.readInt(bread.readInt(i+8) + 8))\n    print( \"creating function at \" + hex(faddr) + \"\\t\" + fname )\n    removeFunctionAt(toAddr(faddr))\n    createFunction(toAddr(faddr),fname)\n\n```\nso i scoured around and hit upon a GitHub entry by felberj a ghidra script for golang \n\ndownloaded the script for 9.04 version copied it to ghidra/extension dir as instructed \nin the project window did File->installExtension and restarted ghidra\n\nnow i imported the binary again this time making sure i used the newly added golang language entry instead of default gcc x64 ghidra proposes \n\nand apart from renaming functions this extension also decoded the return types and changed the storage type of arguments to custom storage and assigned proper stack address to all the arguments and return values.\n\nnow the decompilation of main.main was looking a bit more readable  \n\n```\nvoid main.main(void)\n\n{\n\n  byte Wrong [17];\n  byte EPas [20];\n  byte good [30];\n  byte Ans [38];\n  byte retry [40];\n\n\n  ppbVar1 = *(in_FS_OFFSET + 0xfffffff8) + 0x10;\n  if (good + 4 < *ppbVar1 || good + 4 == *ppbVar1) {\n    runtime.morestack_noctxt();\n    main.main();\n    return;\n  }\n  EPas._0_8_ = 0xc5d38ad8cfdec4ef;EPas._8_4_ = 0xda8ad8df;EPas._12_4_ = 0xddd9d9cb;\n  EPas._16_4_ = 0x90ced8c5;\n  Wrong[0] = 0xf9; Wrong._1_4_ = 0xc2dec7c5;Wrong._5_4_ = 0x8acdc4c3;Wrong._9_4_ = 0xdd8ad9c3;\n  Wrong._13_4_ = 0xcdc4c5d8;\n  Ans._0_6_ = 0xd9cfcec3f9e8;  Ans._6_2_ = 0xe6fe;  Ans._8_2_ = 0xd1fc;  Ans._10_4_ = 0xcfdccfd8;\n  Ans._14_4_ = 0x8acfcdc4;  Ans._18_4_ = 0xc88ad9c3;  Ans._22_4_ = 0x8aded9cf;  Ans._26_4_ = 0xdcd8cfd9;\n  Ans._30_4_ = 0xc98acecf;  Ans._34_4_ = 0xd7cec6c5;\n  good._0_4_ = 0x8adfc5f3;  good._4_4_ = 0xc9cbd8e9;  good._8_4_ = 0x8acecfc1;  good._12_2_ = 0xdec3;\n  good._14_2_ = 0x8a86;  good._16_2_ = 0x8aeb;  good._18_4_ = 0xc5d8cfe2;  good._22_4_ = 0x8ad9c38a;\n  good._26_4_ = 0xc4d8c5c8;\n  retry._0_8_ = 0xc5fd8ade8dc4c5ee;  retry._8_4_ = 0x86d3d8d8;  retry._12_4_ = 0xc6cff88a;\n  retry._16_4_ = 0x8a86d2cb;  retry._20_4_ = 0xc6c3c2e9;  retry._24_4_ = 0xc4cb8ac6;\n  retry._28_4_ = 0xd8fe8ace;  retry._32_4_ = 0xcbc28ad3;  retry._36_4_ = 0xd8cfced8;\n\n  uStack224 = 0x14;\n  rVar3 = main.ObfStr(EPas,0x14,0x14);\n  uStack0000000000000020 = SUB168(rVar3,0);\n  uStack0000000000000028 = SUB168(rVar3 >> 0x40,0);\n  uStack0000000000000018 = runtime.convTstring(in_stack_fffffffffffffe10,in_stack_fffffffffffffe18);\n  pdStack232 = &DAT_0049a600;\n  puVar7 = 0x1;\n  lVar9 = 1;\n  fmt.Fprint(&PTR_DAT_004d3a60,DAT_0055b7f0,&pdStack232,1,1);\n  uStack152 = DAT_0055b7e8;\n  apuStack96[0] = 0x0;\n  FUN_00451d15();\n  lVar5 = 0x1000;\n  lVar6 = 0x1000;\n  runtime.makeslice(&DAT_0049a740,0x1000,0x1000);\n  puStack184 = 0x0;\n  puVar8 = puVar7;\n  FUN_00451d15();\n  uStack176 = 0x1000;\n  uStack168 = 0x1000;\n  ppuStack160 = &PTR_DAT_004d3a40;\n  uStack112 = 0xffffffffffffffff;\n  uStack104 = 0xffffffffffffffff;\n  puStack184 = puVar7;\n  apuStack96[0] = puVar7;\n  FUN_0045207a();\n  rVar2 = bufio.(*Reader).ReadLine(apuStack96);\n  uStack0000000000000010 = SUB488(rVar2,0);\n  uStack0000000000000018 = SUB488(rVar2 >> 0x40,0);\n  uStack0000000000000020 = SUB488(rVar2 >> 0x80,0);\n  uStack0000000000000028 = SUB488(rVar2 >> 0xc0,0);\n  if (lStack480 != 0) {\n    uStack208 = 0x11;\n    rVar3 = main.ObfStr(Wrong,0x11,0x11);\n    uStack0000000000000020 = SUB168(rVar3,0);\n    uStack0000000000000028 = SUB168(rVar3 >> 0x40,0);\n    uStack0000000000000018 = runtime.convTstring(puVar8,lVar9);\n    if (lStack480 != 0) {\n      lStack480 = *(lStack480 + 8);\n    }\n    pdStack216 = &DAT_0049a600;\n    puVar8 = 0x2;\n    lVar9 = 2;\n    lStack200 = lStack480;\n    rVar4 = fmt.Fprintln(&PTR_DAT_004d3a60,DAT_0055b7f0,&pdStack216,2,2);\n    uStack0000000000000040 = SUB248(rVar4 >> 0x80,0);\n  }\n  rVar3 = main.ObfStr(Ans,0x26,0x26);\n  uStack0000000000000020 = SUB168(rVar3,0);\n  uStack0000000000000028 = SUB168(rVar3 >> 0x40,0);\n  if ((lVar9 == lVar6) &&\n     (uStack0000000000000020 = runtime.memequal(lVar5,puVar8,lVar6), puVar8 != '\\0')) {\n    uStack240 = 0x1e;\n    rVar3 = main.ObfStr(good,0x1e,0x1e);\n    uStack0000000000000020 = SUB168(rVar3,0);\n    uStack0000000000000028 = SUB168(rVar3 >> 0x40,0);\n    uStack0000000000000018 = runtime.convTstring(puVar8,lVar9);\n    pdStack248 = &DAT_0049a600;\n    fmt.Fprintln(&PTR_DAT_004d3a60,DAT_0055b7f0,&pdStack248,1,1);\n    return;\n  }\n  uStack256 = 0x28;\n  rVar3 = main.ObfStr(retry,0x28,0x28);\n  uStack0000000000000020 = SUB168(rVar3,0);\n  uStack0000000000000028 = SUB168(rVar3 >> 0x40,0);\n  uStack0000000000000018 = runtime.convTstring(puVar8,lVar9);\n  pdStack264 = &DAT_0049a600;\n  fmt.Fprintln(&PTR_DAT_004d3a60,DAT_0055b7f0,&pdStack264,1,1);\n  return;\n}\n\n```\nso as you can see it prints a string Enter password \nreads a line \ncompares the entered pass with a obfuscated (simple xor with byte 0xaa ) actual password \nand prints good , you are a hero \nor prints wrong retry\n\nthe deobfuscation routine is main.obfstr() it takes a bytearray and length to xor \nand returns a xorred string back\n\nbased on these observations we can write a simple  xor script \n\nthat takes an address the byte to xor and length and xor the results to get the pass without running the binary\n\nhere is naive xor script (na√Øve because it ran for me the one time i tested in my machine and can have innumerable unanticipated corner case bugs)\n\n```\n#Desc xors a memory block of len unsigned bytes with a single unsigend byte like (0xff ^ 0xaa)\n#@author      blabb \n#@category    _NEW_\n#@keybinding  \n#@menupath    none\n#@toolbar     \n\nimport ghidra\ndef hexdump( a ):\n    for j in range(0,len(a),16):\n        for i in range(j,j+16,1):\n            if( i < len(a)):\n                print ( \"%02x \" % a[i]),\n            else:\n                print ( \"%02x \" % 0 ),  \n        for i in range(j,j+16,1):\n            if( i < len(a)):\n                print ( \"%c\" % chr( a[i] ) ),\n            else:\n                print ( \" \" ),\n        print(\"  \n\")\n\nbaseaddr = askAddress( \"XOR MEMORY\",\"Enter Base Addreess\")\nxorby    = askInt    ( \"XOR MEMORY\",\"Enter Byte to xor with\")\nxorlen   = askInt    ( \"XOR MEMORY\",\"enter length of xor block\")\nres = []\nprovider = ghidra.app.util.bin.MemoryByteProvider(currentProgram.getMemory(),baseaddr)\nbr =       ghidra.app.util.bin.BinaryReader(provider,True)\nfor i in range(0,xorlen,1):\n    res.append((br.readUnsignedByte(i) ^ xorby))\nhexdump(res)\n\n```\nrunning this and providing the memory address for password 0x4d3ae0,xorbyte 0xaa,len 0x26 \n\nwe can easily get the password \n\n```\nxormem.py> Finished!\nxormem.py> Running...\n42  53  69  64  65  73  54  4c  56  7b  72  65  76  65  6e  67  B S i d e s T L V { r e v e n g \n\n65  20  69  73  20  62  65  73  74  20  73  65  72  76  65  64  e   i s   b e s t   s e r v e d \n\n20  63  6f  6c  64  7d  00  00  00  00  00  00  00  00  00  00    c o l d }                     \n\nxormem.py> Finished!\n\n```\n",
      "votes": "1",
      "user": "blabb",
      "time": "Jun 25, 2019 at 7:17",
      "is_accepted": false,
      "comments": []
    }
  ]
}