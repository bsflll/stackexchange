{
  "title": "What purpose of mov %esp,%ebp?",
  "link": "https://reverseengineering.stackexchange.com/questions/2073/what-purpose-of-mov-esp-ebp",
  "content": "When execution enters a new function by performing call  I do often see this code template (asm list generated by Gnu Debugger when in debugging mode):\n\n```\n0x00401170  push   %ebp\n0x00401171  mov    %esp,%ebp\n0x00401173  pop    %ebp\n\n```\nSo what's the purpose of moving esp to ebp?\n\n",
  "votes": "19",
  "answers": 2,
  "views": "24k",
  "tags": [
    "disassembly"
  ],
  "user": "PaulD",
  "time": "Mar 3, 2014 at 10:46",
  "comments": [
    {
      "user": "cb88",
      "text": "Dunno if these sort of things are on topic here? Anyway see here: stackoverflow.com/questions/2515598/push-ebp-movlesp-ebp",
      "time": null
    },
    {
      "user": "Robert Mason",
      "text": "I think yes, albeit very basic, as disassembly questions are on topic.  Furthermore, there are reasons to use frame pointers that are more related to reverse engineering (e.g. debugging, runtime code analysis) than others (e.g. easy to implement alloca(), ease of remembering offsets)",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "Moving esp into ebp is done as a debugging aid and in some cases for exception handling.  ebp is often called the frame pointer.  With this in mind, think of what happens if you call several functions.  ebp points to a block of memory where you pushed the old ebp, which itself points to another saved ebp, etc.  Thus, you have a linked list of stack frames.  From these, you can look at the return addresses (which are always 4 bytes above the frame pointer in the stack frame) to find out what line of code called a stack frame in question.  The instruction pointer can tell you the location of current execution.  This allows you to generate a stacktrace which is useful for debugging by showing the flow of execution throughout a program.\n\nAs a practical example consider the following code:\n\n```\nvoid foo();\nvoid bar();\nvoid baz();\nvoid quux();\n\nvoid foo() {\n    bar();\n}\n\nvoid bar() {\n    baz();\n    quux();\n}\n\nvoid baz() {\n    //do nothing\n}\n\nvoid quux() {\n    *(int*)(0) = 1; //SEGFAULT!\n}\n\nint main() {\n    foo();\n    return 0;\n}\n\n```\nThis generates the following assembly (with Debian gcc 4.7.2-4 gcc -m32 -g test.c, snipped):\n\n```\n080483dc <foo>:\n 80483dc:   55                      push   %ebp\n 80483dd:   89 e5                   mov    %esp,%ebp\n 80483df:   83 ec 08                sub    $0x8,%esp\n 80483e2:   e8 02 00 00 00          call   80483e9 <bar>\n 80483e7:   c9                      leave  \n 80483e8:   c3                      ret    \n\n080483e9 <bar>:\n 80483e9:   55                      push   %ebp\n 80483ea:   89 e5                   mov    %esp,%ebp\n 80483ec:   83 ec 08                sub    $0x8,%esp\n 80483ef:   e8 07 00 00 00          call   80483fb <baz>\n 80483f4:   e8 07 00 00 00          call   8048400 <quux>\n 80483f9:   c9                      leave  \n 80483fa:   c3                      ret    \n\n080483fb <baz>:\n 80483fb:   55                      push   %ebp\n 80483fc:   89 e5                   mov    %esp,%ebp\n 80483fe:   5d                      pop    %ebp\n 80483ff:   c3                      ret    \n\n08048400 <quux>:\n 8048400:   55                      push   %ebp\n 8048401:   89 e5                   mov    %esp,%ebp\n 8048403:   b8 00 00 00 00          mov    $0x0,%eax\n 8048408:   c7 00 01 00 00 00       movl   $0x1,(%eax)\n 804840e:   5d                      pop    %ebp\n 804840f:   c3                      ret    \n\n08048410 <main>:\n 8048410:   55                      push   %ebp\n 8048411:   89 e5                   mov    %esp,%ebp\n 8048413:   83 e4 f0                and    $0xfffffff0,%esp\n 8048416:   e8 c1 ff ff ff          call   80483dc <foo>\n 804841b:   b8 00 00 00 00          mov    $0x0,%eax\n 8048420:   c9                      leave  \n 8048421:   c3                      ret    \n\n```\nNote that leave is the same as:\n\n```\nmov %ebp, %esp\npop %ebp\n\n```\nWith this in mind, and the standard-ish C calling convention on x86, we know that the stack at the segfault is going to look like:\n\nThe instruction pointer will be 0x08048408. ebp will point to 10..\n\nAt this point, the processor generates an exception, which the operating system processes.  It then sends SIGSEGV to the process, which obligingly terminates and dumps core.  You then bring up the core dump in gdb with gdb -c core, and you type in file a.out and bt, and it gives you in response:\n\n```\n#0  0x08048408 in quux () at test.c:20\n#1  0x080483f9 in bar () at test.c:12\n#2  0x080483e7 in foo () at test.c:7\n#3  0x0804841b in main () at test.c:24\n\n```\n#0 is generated from the instruction pointer.  Then, it goes to ebp (10), looks at the previous item on the stack (9), and generates #1.  It follows ebp (i.e. mov %ebp, (%ebp)) to (7), and looks 4 bytes above that (6) to generate #2.  It finally follows (7) to (4) and looks at (3) to generate #3.\n\nNote:  This is but one way of doing such stack tracing.  GDB is very, very smart, and can perform the stack trace even when you use -fomit-frame-pointer.  However, in a very basic implementation this is probably the simplest way to generate a stack trace.\n\n",
      "votes": "25",
      "user": "Robert Mason",
      "time": "May 22, 2013 at 15:40",
      "is_accepted": true,
      "comments": [
        {
          "user": "0xC0000022L",
          "text": "why not use gcc -S in the first place and get annotated code?",
          "time": null
        },
        {
          "user": "Robert Mason",
          "text": "I wanted to have real memory addresses that would match up with a stack trace in a live program.  I also think objdump/gdb examples fit the rev-eng theme better.",
          "time": null
        }
      ]
    },
    {
      "content": "I like Robert explanation, it has a very good example, but.. I think it misses the point of which is the real purpose of this instruction.  \n\nWell.. not really, not only. It is part of the standard function prologue for x86 (32 bit), and it is the (common) technique to set up a function stack frame, so that parameters and locals are accessible as fixed offsets of ebp, which is, after all, the *B*ase frame *P*ointer.\n\nMaking ebp equal to esp at function entry, you will have a fixed, relative pointer inside the stack, that will not change for the lifetime of your function, and you will able to access parameters and locals as (fixed) positive and (fixed) negative offsets, respectively, to ebp.\n\nYou can or cannot see this standard prologue in release, optimized code: optimizers can do (and often do) FPO (frame pointer optimization) to get rid of ebp and just use esp inside your function to access params and locals. This is much trickier (I would not do it by hand) as esp can vary during the function lifetime, and therefore a parameter, for example, can be accessed using 2 different offsets at two distinct points in the code.\n\n",
      "votes": "23",
      "user": "microtherion",
      "time": "May 25, 2013 at 21:03",
      "is_accepted": false,
      "comments": [
        {
          "user": "Robert Mason",
          "text": "That is true, however in a large amount of compiled code the stack pointer doesn't change over the duration of the function as the compiler just subs once and uses fixed offsets vice push/pop.  For purposes of reverse engineering I'm much more interested in what ebp can tell me about the structure of the program than how it makes the programmer's life easier (especially in compiled code).",
          "time": null
        },
        {
          "user": "Robert Mason",
          "text": "That being said, thanks for filling the (rather gaping) hole I left in my explanation.",
          "time": null
        }
      ]
    }
  ]
}