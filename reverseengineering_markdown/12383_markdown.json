{
  "title": "Can a keygen be created for this protection algorithm? [closed]",
  "link": "https://reverseengineering.stackexchange.com/questions/12383/can-a-keygen-be-created-for-this-protection-algorithm",
  "content": "I reverse engineered a program protection algorithm and got the result in this source file I wrote, but I would know this type of protection.\nPlease tell me what is the type of this protection ? And is there any ability to create a keygen of this algorithm ?\n\n```\n#include <stdio.h>\n#include <string.h>\n\nchar* transformStrip = \"123456789ABCDEFGHIJKLMNPQRSTUVWXYZ\";\n\nchar* myusername = \"MYUSERNAME\";\nchar* myserial   = \"MYSERIAL33222222222222222\";\n\n//OK\nint TransformChar(char c)\n{\n    for(int i=0;i<0x22;i++)\n    {\n        if(transformStrip[i] == c)\n            return i;\n    }\n    return 0;\n}\n\n//OK\nbool MagicCalculator1(char* magicBuffer, int number)\n{\n    int a = 0;\n    //int rez = 0;\n    for (int i=0;i<0x20;i++)\n    {\n        int rez = (unsigned char)magicBuffer[i];\n        rez *= number;\n        rez += a;\n        magicBuffer[i] = (unsigned char)rez;\n        if(rez >= 0x100)\n        {\n            a = rez;\n            if(a < 0)\n                a += 0xFF;\n            a >>= 8;\n        }else\n            a = 0;\n    }\n    return (bool)a;\n}\n\nbool MagicCalculator2(char* magicBuffer, int position)\n{\n    int a = 0;\n    for (int i=0;i<0x20;i++)\n    {\n        int rez = magicBuffer[i];\n        a += rez;\n        rez = position + a;\n        magicBuffer[i] = (char) rez;\n        position = 0;\n        if(rez >= 0x100)\n        {\n            a = rez;\n        }else\n            a = 0;\n\n    }\n    return (bool)a;\n}\n\n// sizeof(magicBuffer) = 0x20\n// OK\nint SerialMagicGenerator(char* serial, char* magicBuffer, int number)\n{\n    int serialLength = strlen(serial);\n    if (serialLength <= 0)\n        return 0;\n\n    for(int i=0;i<serialLength;i++)\n    {\n        char c = serial[i];\n        if (c != '\\x20' && c != '\\x2D')\n        {\n            int pos = TransformChar(c);\n            if (MagicCalculator1(magicBuffer, number))\n                return -1;\n            if (MagicCalculator2(magicBuffer, pos))\n                return -1;\n        }\n    }\n    return 0;\n}\n\nunsigned short MagicValidator(char* combinedBuffer, int number)\n{\n    int c = 0;\n    if(number)\n    {\n        for(int i=0;i<number;i++)\n        {\n            int rez = ((unsigned char) combinedBuffer[i]) << 8;\n            c ^= rez;\n            for(int j=0;j<8;j++)\n            {\n                if(c & 0x8000)\n                {\n                    c += c;\n                    c ^= 0x1021;\n                }else\n                    c <<= 1;\n            }\n        }\n    }\n    unsigned short s = (unsigned short) ( ((c & 0xFF) << 8) | ((c & 0xFF00) >> 8) );\n    return s;\n}\n\nbool UsernameMagicVerifier(char* randomizedUsername, char* magicBuffer)\n{\n    char combinedBuffer[0x20];\n    memset(combinedBuffer, 0, 0x20);\n    memcpy(combinedBuffer, randomizedUsername, 0x10);\n    memcpy(combinedBuffer + 0x10, magicBuffer, 0x10);\n    unsigned short mustHaveValue = (unsigned short) (MagicValidator(combinedBuffer, 0x1E) & 0x7FFF);\n    unsigned short foundValue =    (unsigned short) ((*(unsigned short*) (magicBuffer + 0xE)) & 0x7FFF);\n    return (mustHaveValue == foundValue);\n}\n\nbool FinalizerVerifier(void*a, void*b)\n{\n    //assuming this always returns true\n    return true;\n}\n\nchar RandomizedUsernameBuffer[0x10];\n\nchar* RandomizeUsername(char* username)\n{\n    memset(RandomizedUsernameBuffer, 0, 0x10);\n    int usernameLength = strlen(username);\n    if(usernameLength >= 1)\n    {\n        if(usernameLength < 0x10)\n        {\n            int size = (usernameLength >> 2) * 4;\n            memcpy(RandomizedUsernameBuffer, username, size);\n            memcpy(RandomizedUsernameBuffer + size, username + size, usernameLength & 3);\n            if( usernameLength + 1 < 0x10 )\n            {\n                char* ptr;\n                ptr = RandomizedUsernameBuffer + size + (usernameLength & 3) + 1;\n                for(int i=0;ptr<RandomizedUsernameBuffer+0x10;ptr++)\n                {\n                    if( username[i] != '\\0')\n                    {\n                        *ptr = username[i];\n                        i++;\n                    }else\n                        i = 0;\n                }\n            }\n        }\n    }\n    return RandomizedUsernameBuffer;\n}\n\nbool SerialChecker(char* username, char* serial)\n{\n    char magicBuffer[0x20];\n    memset(magicBuffer, 0, 0x20);\n    char* randomizedUsername = RandomizeUsername(username);\n    SerialMagicGenerator(serial, magicBuffer, 0x22);\n    if ( UsernameMagicVerifier(randomizedUsername, magicBuffer) )\n    {\n        return FinalizerVerifier(/*?*/NULL, /*?*/NULL);\n    }\n    return false;\n}\n\nint main()\n{\n    SerialChecker(myusername, myserial);\n    return 0;\n}\n\n```\n",
  "votes": "-1",
  "answers": 1,
  "views": "256",
  "tags": [
    "c",
    "crackme",
    "protection"
  ],
  "user": "Etor Madiv",
  "time": "9 years ago",
  "comments": [],
  "answers_data": [
    {
      "content": "Short, slightly snarky answer: yes, there must be a way to make a keygen. If there wasn't, the creators of the software themselves wouldn't be able to create keys to sell.\n\nLonger answer: If the software vendor wants the encryption to be non-identifiable for people who have reversed the decryption part, they need to use some assymetric key algorithm, where the public key is embedded into the software, and the private key stays with the vendor. There are well-known algorithms, and corresponding libraries, to do that, like RSA. However, those are not used in your program, once because they are too big, and also because they contain lookup tables which make them easily identifiable.\n\nFrom a first glance at your algorithm, there's nothing much happening that's too difficult to reverse. Your RandomizeUserName just seems to shuffle the bits of the user name in the same way that the keygen would; your MagicCalculator functions seem to check if the serial number is well-formed, for some definition of well-formed. Then, MagicValidator calculates what looks like a 16-bit CRC on the 16 bytes username + 14 first bytes of the serial, then compares that to bytes 15/16 of the serial.\n\nSo, a keygen would have to:\n- perform the same calculation on a username that your RandomizeUserName does\n- invent 14 bytes of serial\n- generate the CRC from the randomized user name + serial, and put it into bytes 15/16\n- append 16 more bytes to the serial in a way that MagicCalculator1 and 2 are satisfied (return 0), choose any bytes you want to achieve this\n- undo SerialMagicGenerator to get a serial that includes blanks and dashes just like SerialMagicGenerator does.\n\nSo, with a bit of experimenting and trial-and-error, it should be very well possible to make a key generator for this.\n\n",
      "votes": "4",
      "user": "user2823000",
      "time": "Apr 9, 2016 at 12:11",
      "is_accepted": true,
      "comments": [
        {
          "user": "Etor Madiv",
          "text": "Should I create an algorithm that bruteforce a serial that meet the conditions ? Or is there a way reverse the whole algorithm ?",
          "time": null
        }
      ]
    }
  ]
}