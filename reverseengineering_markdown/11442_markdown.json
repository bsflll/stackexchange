{
  "title": "Understanding subtle differences between addressing modes in X86",
  "link": "https://reverseengineering.stackexchange.com/questions/11442/understanding-subtle-differences-between-addressing-modes-in-x86",
  "content": "I'm trying to have a whole picture of all the possible addressing modes of X86 instructions. Starting from this I studied the Intel IA-32 reference and multiple secondary references found online.\n\nI'd like to understand them correctly, so here's my doubts:\n\n\n\nMy doubts:\n\nAnd now the 32-bit addressing modes\n\n\n\nHere everything is enough clear, I was just wondering, as for 16 bits if displacement in 32 bits are signed or unsigned? SIB and displacement can be combined easily if I understand it correctly, eg [EAX + EBX*2 + 10] will generate a mod == 01 with specific SIB byte and additional single byte for signed displacement. Are these values considered absolute in a flat memory space or segments must be considered here too?\n\n",
  "votes": "6",
  "answers": 2,
  "views": "3k",
  "tags": [
    "assembly",
    "x86"
  ],
  "user": "Jack",
  "time": "Dec 16, 2015 at 17:11",
  "comments": [],
  "answers_data": [
    {
      "content": "These are a lot of questions at once, i'll answer at least some of them. But, please not, unless you're writing an assembler or disassembler yourself, you shouldn't really go into the gory details of every single bit. And unless you have done a lot of programming in assembler, and reading and understanding disassembled code, you shouldn't even try to write an assembler or disassembler yourself.\n\nDon't misunderstand me, writing your own assembler can be an interesting and educational experience. But the gory details aren't first thing you should learn to understand the concept of a processor and its assembly language.\n\nThat out of the way:\n\nIt doesn't matter if the 16 bit displacement is signed or unsigned. If it overflows, it overflows, and it's always cut to 16 bit. So if you add offset 0xfff0 to address 0x1234, you'll get 0x1224 as result.  It doesn't really matter if you interpret this as \"0xfff0 is equal to -0x0010, so we subtract 0x10 from 0x1234\" or \"add 0xfff0 to 0x1234, get 0x11224, and strip the overflow bit\". Or, if you add 0x89ab and 0x89ab, you get 0x1356. 0x11356 with the overflow bit stripped, to be precise. It doesn't matter if you take 0x89ab as (decimal) 35243, or -30293. The possible results - 35243+35243=70486, 35243-30293=4950, -30293-30293=-60586 - do all have the same representation - 0x1356 - in 16 bit hex.\n\nYes, mod=0b00 and R/M=0b110 is just an indirect address. mov cx, [1234h] and mov cx, WORD PTR ds:0x1234 are two ways of writing the same thing. Note i corrected your cl to cx; whether or not you use an 8-bit or 16-bit register is part of the instruction, not of the addressing mode. If you have a register, the size is clear from the register name, but in an instruction like mov [1234h],5, you don't know if the 5 is a byte, word, or dword value. mov word ptr ds:1234h, 5 makes this clear.\n\nYes, all addresses are relative to the chosen segment - ds in most cases, ss if you use bp, and the given register if you use an explicit override prefix. Note there wasn't a way to index relative to sp in 16 bit mode, and bp, if used at all, was always the first register in R1+R2 combinations, forcing ss to be used with bp. In 32 bit mode, more combinations are possible, and [ebp+ebx] uses ss, while [ebx+ebp] uses ds. (However, 32 bit mode also means protected mode, and in all but the most pathological cases, operating systems use the same selector values for ss and ds, and cs as well. See below).\n\nSo [BP+SI+10h] means [SS:BP+SI+10h], which means (SS<<4 + BP + SI + 10h) on the address bus lines. Note that those 16 bit processors had 20 bits on the address bus, which means overflow could occur, and the overflow bit was cut off as well. So, FFF0:0010 and 0000:0000 are actually the same address on an 8086 - 00000 - since bit 20 from 100000 got cut off. On a 32 bit processor, this bit 20 actually exists. Which means some programs, that used that mechanism to obfuscate their copy protections, stopped working when the 80386 was introduced. Or would have, if IBM hadn't invented a mechanism around it - the nefarious A20 gate. Google for that if you're inclined to do so.\n\nPrefixes 66h and 67h - ask someone else. Although i've been reading and writing assembler code for more than 20 years, i never had reason to learn the relation between hex bytes and processor instructions. See above. Well, i guess there are two exceptions: 90h is NOP, and cch is INT3. And byte sequences like PQRST, 50h 51h 52h 53h 54h are push-register instructions, which makes them useful for locating procedure starts.\n\nIn 32 bit modes, the displacements are just as \"signed\" or \"unsigned\" as in 16 bit modes. Just treat them as 32 bit values that get added, which might result in an overflow that's thrown away. \n\nAnd of course, these values are considered relative to the \"segment\"s as well. Just that 32 bit implies protected mode, which means the segments are called selectors, have different semantics, and get generally ignored by most application programmers.\n\nAt first, when the 8086 was introduced, it was meant to replace the older 8080 processor (and the Z80, which was from a different company, compatible to the 8080, but better and more successful). The 8080 had 64 KB at a maximum altogether, so programmers had to squeeze everything - code, data, stack - into those 64 KB, and most of the time, a part of these 64 KB was used by hardware, so you had even less.\n\nWhen the 8086, and the segment registers, were designed, someone at intel probably thought \"We're giving people much more space - 64 kb code AND 64 kb data AND 64 kb stack, so programs can be much larger; we can multitask between several programs, the operating system will manage the segment registers to assign space to each program, and every program can be so much bigger than today\".\n\nBut in fact, programs got much larger quickly, so the idea \"segment registers should concern the OS only\" wasn't ever used. Instead, programs had to juggle segments on their own, which was a major PITA for everybody from compiler builders to application programmers, and everybody had to learn - and know - about them to get anything done.\n\nWhen 32 bit processors started, with 4 GB addressable in a linear fashion, segments suddenly became big enough that application programmers didn't have to care about them anymore. These days, juggling segments and assigning them to memory maps is strictly the task of the operating system, and due to protected mode, programs couldn't change them even if they wanted. So, what most operating systems do is provide one single flat block of memory to the program, and have cs, ds, es and ss map to that block identically. Your application just sees 4 GB of addressable memory (not all of that needs to be truly mapped to physical memory however), and it doesn't matter to the application anymore which segment registers it uses - [DS:1234] is the same as [ES:1234] is the same as [SS:1234] is the same as [CS:1234].\n\nThe exception to this is the new registers FS and GS, for example, Windows uses FS for Structured Exception Handling, and Linux uses GS for Thread local storage. These segments are NOT mapped to the standard 4 GB block, but an application won't notice, since neither of these registers is ever used without an explicit prefix. (Note ES can not be used in the same way, since instructions like stos[bwd] and movs[bwd] use ES:EDI by default).\n\n",
      "votes": "6",
      "user": "Guntram Blohm",
      "time": "Nov 30, 2015 at 19:20",
      "is_accepted": true,
      "comments": [
        {
          "user": "Jack",
          "text": "Thanks for the detailed answer, I really appreciate it and I'll take some time to read it. Actually I'm quite practical with assemblers and I coded fully working assemblers/cpus of simple architectures for emulation purposes (Z80, Mos6502) so I have no problems with the details or the semantics as long as it's explained in a consistent and non-ambigue way. But I've never dug into x86 and now I realize why CISC architectures and backward compatiblity are really double edged swords.",
          "time": null
        },
        {
          "user": "blabb",
          "text": ":) nice to get refreshed  guntram blohm wasnt answering on stack overflow when debug.com was the king of the hill",
          "time": null
        },
        {
          "user": "Jack",
          "text": "Everything is quite clear, if I got it right from a reversing/programming point of view the segment registers in protected mode are still used but their values are just indices inside the GDT and LDT and the translation is made internally by the CPU so it's transparent to the process that is running. This means that even in protected mode a mov ax, [0x123]defaults to mov ax, [ds:0x123] but the value inside ds doesn't mean anything with respect to real memory.",
          "time": null
        }
      ]
    },
    {
      "content": "The 8086 is a descendant of the 8080 and 8085, whose codings are, for the most part, octal-based. The same is true for the 8086 and 8088, as well as its descendants, 80186, 80286, 80386, 80486, Pentium, etc. The 32-bit addressing modes, which were added starting with the 80386, also followed this pattern. You will only create confusion if write everything in hexadecimal, rather than in octal.\n\nFor the most part, each byte may be segmented into 2+3+3 bits, for 3 octal digits, the first digit ranging between 0 and 3, the last two digits each ranging from 0 to 7. There are a few exceptions, such as the opcodes for the conditional jump instructions: e.g. 70-7f in hexadecimal. In contrast to the 8080, 8085 and Z80, which encode only 8 conditions, the 8086, 8088 and x86 descendants encode 16 conditions.\n\nIn later times, the legacy was forgotten - even by those writing the documentation at Intel and designing x86 upgrades, so there was a tendency for hexadecimal to creep into the coding the newer versions of the x86 family.\n\nFor many opcodes, in addition to the first opcode byte, which contained the main operation and - sometimes - an operand, a second and subsequent opcode bytes may be used to encode operands in different addressing modes. In the official literature, this is listed as the ModR/M byte as the first of them.\n\nNormally, I write them as 3 octal digits: \"xrm\", with \"x\" being \"Mod\" and \"m\" as \"R/M\". Together \"xm\" is used to indicate one operand, while \"r\" is used to indicate a second register operand or an actual mnemonic. In particular, the instructions labelled \"/0\", ... \"/7\" respectively have \"x0m\", ..., \"x7m\" as their ModR/M bytes, and only the \"xm\" part is used to indicate an operand. The \"r\" part is used to specify the mnemonic.\n\nThe legacy (16-bit) addressing mode is given by the following:\n\n```\n    16-Bit Addressing\n    ─────────────────\n    xm D    for register R or direct [D] or indexed [X+D] mode.\n    ────    ───────────────────────────────────────────────────\n    06 Iw   for direct addressing [Iw], with 16-bit displacement D = Iw.\n    3m      for register m in one of the enumerated lists:\n                    8-bit registers:        R ∈ (AL,CL,DL,BL,AH,CH,DL,BH),\n                    16-bit registers:       R ∈ (AX,CX,DX,BX,SP,BP,SI,DI),\n                    32-bit registers:       R ∈ (EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI)\n                    MM registers:           R ∈ (MM0,MM1,MM2,MM3,MM4,MM5,MM6,MM7)\n                    XMM registers:          R ∈ (XMM0,XMM1,XMM2,XMM3,XMM4,XMM5,XMM6,XMM7)\n            depending on the operation.\n    0m      indexed mode [X], with 0-bit (empty) displacement D = 0, m ≠ 6.\n    1m Is   indexed mode [X+Is], with signed 8-bit displacement D = Is.\n    2m Iw   indexed mode [X+Iw], with 16-bit displacement D = Iw.\n    x0 D    indexed mode [BX+SI+D], with X = BX+SI, x ≠ 3.\n    x1 D    indexed mode [BX+DI+D], with X = BX+DI, x ≠ 3.\n    x2 D    indexed mode [BP+SI+D], with X = BP+SI, x ≠ 3.\n    x3 D    indexed mode [BP+DI+D], with X = BP+DI, x ≠ 3.\n    x4 D    indexed mode [SI+D], with X = SI, x ≠ 3.\n    x5 D    indexed mode [DI+D], with X = DI, x ≠ 3.\n    x7 D    indexed mode [BX+D], with X = BX, x ≠ 3.\n\n```\nExamples where the \"r\" digit encodes opcodes include:\n\n```\n    200 xrm D Ib    Ap(r) Eb(xmD),Ib\n    201 xrm D Iw    Ap(r) Ew(xmD),Iw        [16]\n    201 xrm D Id    Ap(r) Ed(xmD),Id        [32]\n    203 xrm D Is    Ap(r) Ew(xmD),Is        [16]\n    203 xrm D Is    Ap(r) Ed(xmD),Is        [32]\n\n```\nwhere Eb(xmD), Ew(xmD) or Ed(xmD) are, the effective addresses encoded by xm and D for registers (if x = 3) or pointers to data (if x ≠ 3) of 8-bit, 16-bit or 32-bit size, respectively; Ib, Iw, Id are immediate values of respective sizes 8, 16 and 32 bits, Is is a signed 8-bit value and the operation is encoded by \"r\" in the enumerated list\n\n```\n    Ap ∈ (add, or, adc, sbb, and, sub, xor, cmp)\n\n```\nThis is the same encoding used where the operation is in the first opcode byte and the scheme just laid out is part of the following larger scheme:\n\n```\n    OpCode          Operation\n    ──────          ─────────\n    0p0 xrm D       Ap(p) Eb(xmD),Rb(r)\n    0p1 xrm D       Ap(p) Ew(xmD),Rw(r)     [16]\n    0p1 xrm D       Ap(p) Ed(xmD),Rd(r)     [32]\n    0p2 xrm D       Ap(p) Rb(r),Eb(xmD)\n    0p3 xrm D       Ap(p) Rw(r),Ew(xmD)     [16]\n    0p3 xrm D       Ap(p) Rd(r),Ed(xmD)     [32]\n    0p4 Ib          Ap(p) AL,Ib\n    0p5 Iw          Ap(p) AX,Iw             [16]\n    0p5 Id          Ap(p) EAX,Id            [32]\n    200 xrm D Ib    Ap(r) Eb(xmD),Ib\n    201 xrm D Iw    Ap(r) Ew(xmD),Iw        [16]\n    201 xrm D Id    Ap(r) Ed(xmD),Id        [32]\n    203 xrm D Is    Ap(r) Ew(xmD),Is        [16]\n    203 xrm D Is    Ap(r) Ed(xmD),Is        [32]\n\n```\nwhich includes cases where the \"r\" of \"xrm\" encodes an 8-bit register as Rb(r), 16-bit register as Rw(r) or 32-bit register as Rd(r).\n\n[16] marks the legacy 16-bit 8086 mode, and [32] marks the 32-bit 80386 mode; and for 80386 and above, which one is the default depends on which mode the CPU is operating in. The opcode 146 can be used as a prefix to reverse between [16] and [32] for a given instruction.\n\nThe (32-bit) addressing mode, for 80386 on up, is given by the following:\n\n```\n    32-bit Addressing Mode\n    ──────────────────────\n    xm D [sib Δ]\n    ────────────\n    05 Id           32-bit address [Id], D = Id\n    04 sib Δ        [B(0bΔ)+S(si)], with 0-bit (empty) displacement D = 0\n    14 sib Δ Is     [B(1bΔ)+S(si)+Is], with a signed 8-bit displacement D = Is\n    24 sib Δ Id     [B(2bΔ)+S(si)+Id], with a 32-bit displacement D = Id\n    0m              [Rd(m)], with 0-bit displacement D = 0, m ≠ 4, 5\n    1m Is           [Rd(m)+Is], with a signed 8-bit displacement D = Is, m ≠ 4\n    2m Id           [Rd(m)+Id], with a 32-bit displacement D = Id, m ≠ 4\n    3m              Register R, encoded by m\n\n```\nwith the following encodings in the case m = 4 (x ≠ 3), involving an additional byte \"sib\" with octal digits s ∈ {0,1,2,3} and i,b ∈ {0,1,2,3,4,5,6,7}, with possible further displacement bytes Δ beyond it:\n\n```\n    xb Δ    B(xbΔ)\n    ── ─    ──────\n    05 Id   Id\n    15 Ib   EBP+Ib\n    25 Id   EBP+Id\n    xb      Rd(b), x ≠ 3, b ≠ 5\n\n    si      S(si)\n    ──      ─────\n    s4      0\n    ni      2ⁿ Rd(i), i ≠ 4\n\n```\nWhich addressing mode is default, for the 80386 and above, depends on which mode the CPU is in; and the opcode 147 can be used as a prefix to reverse between the two addressing modes for a given instruction.\n\n",
      "votes": "0",
      "user": "NinjaDarth",
      "time": "Jul 31, 2024 at 9:25",
      "is_accepted": false,
      "comments": []
    }
  ]
}