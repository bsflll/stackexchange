{
  "title": "Help with IOLI crackme0x02",
  "link": "https://reverseengineering.stackexchange.com/questions/11602/help-with-ioli-crackme0x02",
  "content": "I am studying IOLI crackme0x02. It is clear to me that rewriting the jump at 0x8048451 with no instructions the crackme can be patched. However, I want to  understand better what the code does. My problem is that I am unable to find where the entered password is located.\n\nI interpreted what radare2 is showing that there are 3 local variables.\n\n```\n│          ; arg int arg_22_2     @ ebp+0x5a\n│          ; arg int arg_123      @ ebp+0x1ec\n│          ; var int local_1      @ ebp-0x4\n│          ; var int local_2      @ ebp-0x8\n│          ; var int local_3      @ ebp-0xc\n...\n|           0x0804840c      c70424618504.  movl $str.Password:, (%esp) ; [0x8048561:4]=0x73736150  LEA str.Password: ; \"Password: \" @ 0x8048561\n|           0x08048413      e804ffffff     calll sym.imp.printf\n|           0x08048418      8d45fc         leal -4(%ebp), %eax\n|           0x0804841b      89442404       movl %eax, 4(%esp)\n|           0x0804841f      c704246c8504.  movl $0x804856c, (%esp)     ; [0x804856c:4]=0x50006425 \n|           0x08048426      e8e1feffff     calll sym.imp.scanf\n|           0x0804842b      c745f85a0000.  movl $0x5a, -8(%ebp)        ; [0x5a:4]=-1 ; 'Z' ; 90\n|           0x08048432      c745f4ec0100.  movl $0x1ec, -0xc(%ebp)     ; [0x1ec:4]=-1 ; 492\n|           0x08048439      8b55f4         movl -0xc(%ebp), %edx\n|           0x0804843c      8d45f8         leal -8(%ebp), %eax\n|           0x0804843f      0110           addl %edx, (%eax)\n|           0x08048441      8b45f8         movl -8(%ebp), %eax\n|           0x08048444      0faf45f8       imull -8(%ebp), %eax\n|           0x08048448      8945f4         movl %eax, -0xc(%ebp)\n|           0x0804844b      8b45fc         movl -4(%ebp), %eax\n|           0x0804844e      3b45f4         cmpl -0xc(%ebp), %eax\n|       ,=< 0x08048451      750e           jne 0x8048461              \n|       |   0x08048453      c704246f8504.  movl $str.Password_OK_:__n, (%esp) ; [0x804856f:4]=0x73736150  LEA str.Password_OK_:__n ; \"Password OK :).\" @ 0x804856f\n|       |   0x0804845a      e8bdfeffff     calll sym.imp.printf\n|      ,==< 0x0804845f      eb0c           jmp 0x804846d              \n|      |`-> 0x08048461      c704247f8504.  movl $str.Invalid_Password__n, (%esp) ; [0x804857f:4]=0x61766e49  LEA str.Invalid_Password__n ; \"Invalid Password!.\" @ 0x804857f\n|      |    0x08048468      e8affeffff     calll sym.imp.printf\n|      |    ; JMP XREF from 0x0804845f (sym.main)\n\n```\nSince I am not yet familiar with radare2, I put a breakpoint in gdb after the scanf (0x0804842b), and inspected the local variables. It seems that neither they, neither the address they are pointing to are the password.\n\nI have two questions regarding this crackme:\n\n",
  "votes": "2",
  "answers": 2,
  "views": "2k",
  "tags": [
    "gdb",
    "crackme",
    "radare2"
  ],
  "user": "robert",
  "time": "Dec 20, 2015 at 12:54",
  "comments": [],
  "answers_data": [
    {
      "content": "It's after the scanf() function it can get a bit confusing however I can explain this for you as I reversed this binary back to it's C code without the source.\n\nThe Assembly after scanf():\n\n```\n|           0x08048426      e8e1feffff     call sym.imp.scanf\n|           0x0804842b      c745f85a0000.  mov dword [ebp - local_8h], 0x5a ; 'Z'\n|           0x08048432      c745f4ec0100.  mov dword [ebp - local_ch], 0x1ec\n|           0x08048439      8b55f4         mov edx, dword [ebp - local_ch]\n|           0x0804843c      8d45f8         lea eax, dword [ebp - local_8h]\n|           0x0804843f      0110           add dword [eax], edx\n|           0x08048441      8b45f8         mov eax, dword [ebp - local_8h]\n|           0x08048444      0faf45f8       imul eax, dword [ebp - local_8h]\n|           0x08048448      8945f4         mov dword [ebp - local_ch], eax\n|           0x0804844b      8b45fc         mov eax, dword [ebp - local_4h]\n|           0x0804844e      3b45f4         cmp eax, dword [ebp - local_ch]\n|       ,=< 0x08048451      750e           jne 0x8048461\n|       |   0x08048453      c704246f8504.  mov dword [esp], str.Password_OK_:__n ; [0x804856f:4]=0x73736150 LEA str.Password_OK_:__n ; \"Password OK :).\" @ 0x804856f\n|       |   0x0804845a      e8bdfeffff     call sym.imp.printf\n|      ,==< 0x0804845f      eb0c           jmp 0x804846d\n|      ||   ; JMP XREF from 0x08048451 (sym.main)\n|      |`-> 0x08048461      c704247f8504.  mov dword [esp], str.Invalid_Password__n ; [0x804857f:4]=0x61766e49 LEA str.Invalid_Password__n ; \"Invalid Password!.\" @ 0x804857f\n|      |    0x08048468      e8affeffff     call sym.imp.printf\n|      |    ; JMP XREF from 0x0804845f (sym.main)\n|      `--> 0x0804846d      b800000000     mov eax, 0\n|           0x08048472      c9             leave\n\\           0x08048473      c3             ret\n\n```\nFirst Part:\n\n```\n|           0x0804842b      c745f85a0000.  mov dword [ebp - local_8h], 0x5a ; 'Z'\n|           0x08048432      c745f4ec0100.  mov dword [ebp - local_ch], 0x1e\n\n```\nHere we can see values being \"moved\" into memory at the base pointer minus 0x8 and minus 0xc. Remember that the 'h' means hex and local means is just the hex value minus the value of ebp or the base pointer. ebp stands for Extended Base Pointer.\n\nTo figure out what values are being stored convert the hex to decimal:\n\n```\n0x5a = 90\n0x1e = 492\n\n```\nThink of this as storing variable in memory like:\n\n```\nint a = 90\nint b = 492\n\n```\nSecond Part:\n\n```\n|           0x08048439      8b55f4         mov edx, dword [ebp - local_ch]\n|           0x0804843c      8d45f8         lea eax, dword [ebp - local_8h]\n|           0x0804843f      0110           add dword [eax], edx\n|           0x08048441      8b45f8         mov eax, dword [ebp - local_8h]\n\n```\nRemember that computing something using registers is faster than computing it from memory so before each operation the compiler is going to try to move what it can into the registers to make it's calculations.\n\nWe move ebp-0xc -> 0x1e into the edx register then we load the effective address (lea) of ebp-0x8 -> 0x5a. \n\nThe add instruction adds the two values and saves them to [eax] which is now the same as a pointer to ebp-0x8 since it's saving it to memory we can assume we are replacing an existing variable with a new computed value because we move the value return from add to the same location in memory effectively overwriting it.\n\nSo we can assume again our code is something like this:\n\n```\nint a = 90\nint b = 492\na = a + b\n\n```\nThird Part:\n\n```\n|           0x08048444      0faf45f8       imul eax, dword [ebp - local_8h]\n|           0x08048448      8945f4         mov dword [ebp - local_ch], eax\n|           0x0804844b      8b45fc         mov eax, dword [ebp - local_4h]\n|           0x0804844e      3b45f4         cmp eax, dword [ebp - local_ch]\n|       ,=< 0x08048451      750e           jne 0x8048461\n\n```\nYou may not be familiar with the imul instruction but it simply multiplies two integers. We are multiplying the value of eax which is the return value of the add operation (582 or 90 + 492) then storing the value in eax overwriting it's previous value of 582. Thus we are executing (a + b) * (a + b) or 582 * 582.\n\nWe then move the value you enter with scanf() from memory into eax and compare it to (a + b) * (a + b). If the jump afterwards is not equal to zero it will go to 0x8048461 showing invalid password otherwise it will jump to valid password. It will exit if the password is valid or invalid.\n\nNow that you have a better understanding now you can put the source code together like I have:\n\n```\n#include <stdio.h>\nint main(int argc, char *argv[]){\n        int a,b,c;\n        printf(\"IOLI Crackme Level 0x02  \n\");\n        printf(\"Password: \");\n        scanf(\"%d\", &a);\n        b = 90;\n        c = 492;\n        c = ((b + c) * (b + c));\n        if(a == c){\n                printf(\"Password OK :)  \n\");\n        }\n        else{\n                printf(\"Invalid Password!  \n\");\n        }\n        return 0;\n}\n\n```\nHere is my version of the program compiled and it's control flow graph:\n\n\nHope this helps and good luck with you reverse engineering journey!\n\n",
      "votes": "3",
      "user": null,
      "time": "Nov 20, 2016 at 1:31",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "If you take a look at what happens before scanf, you'll see this:\n\n```\n[0x080483e4]> pd 4 @ 0x08048418\n│           0x08048418      8d45fc         lea eax, [ebp-local_1]\n│           0x0804841b      89442404       mov dword [esp + 4], eax\n│           0x0804841f      c704246c8504.  mov dword [esp], 0x804856c  ; [0x804856c:4]=0x50006425 \n│           0x08048426      e8e1feffff     call sym.imp.scanf\n[0x080483e4]> psz @ 0x804856c\n%d\n\n```\n0x804856c being the address of the format string (here, %d), and ebp-local_1 the offset where your result is stored.\n\nAs for you x/4x issue, radare2 will print you 4 words, in hex, namely 0x00000000    0x08048330    0x00000000    0xf7e1a72e.\n\n",
      "votes": "1",
      "user": "jvoisin",
      "time": "Dec 20, 2015 at 14:15",
      "is_accepted": false,
      "comments": []
    }
  ]
}