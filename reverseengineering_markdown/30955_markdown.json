{
  "title": "problem with hooking __usercall function and asm code",
  "link": "https://reverseengineering.stackexchange.com/questions/30955/problem-with-hooking-usercall-function-and-asm-code",
  "content": "I need a hook function with the __usercall convention.\nI already hooked functions that were defined as __usercall and __userpurge, but this time it's __usercall with arguments that are also passed through the stack.\nThe main problem is in calling the original function. After ret (it doesn't matter retn, retf, regardless of the operand) the function goes to an address that has nothing to do with the program itself.\n\n```\nvoid __usercall fn(float *o@<ebx>, char *a2, int a3, int a4, float a5, float a6, float a7, float a6, int a7, int a10, _DWORD *a11, float a12)\n\n```\nfunction begin:\n\n```\n.text:00414350 83 EC 1C                             sub     esp, 1Ch\n.text:00414353 83 3D 24 F3 50 00 00                 cmp     dword_50F324, 0\n.text:0041435A 55                                   push    ebp             ; green\n.text:0041435B 8B 6C 24 28                          mov     ebp, [esp+20h+a3]\n.text:0041435F 56                                   push    esi             ; red\n.text:00414360 8B 74 24 48                          mov     esi, [esp+24h+a10]\n\n```\nfunction end:\n\n```\n.text:00414965 5F                                   pop     edi\n.text:00414966 5E                                   pop     esi\n.text:00414967 5D                                   pop     ebp\n.text:00414968 83 C4 1C                             add     esp, 1Ch\n.text:0041496B C3                                   retn\n\n```\nIn the code itself, after calling the function, 0x2C is added to the esp\n\nhook code:\n\n```\nvoid __stdcall hook(float* a1, char* a2, int a3, int a4, float a5, float a6, float a7, float a8, int a9, int a10, void* a11, float a12) {\n    original_proxy(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);\n}\n\n__declspec(naked) void __stdcall proxy(char* a2, int a3, int a4, float a5, float a6, float a7, float a8, int a9, int a10, void* a11, float a12) {\n    _asm {\n        //without \"enter\" arguments will be null\n        //\n        //if you do not pass arguments manually,\n        //but immediately call the hook function,\n        //then everything will be fine with the arguments\n        enter 0x0, 0x0\n        push a12\n        push a11\n        push a10\n        push a9\n        push a8\n        push a7\n        push a6\n        push a5\n        push a4\n        push a3\n        push a2\n        push ebx\n        call hook\n        leave\n        ret\n    }\n}\n\n__declspec(naked) void __stdcall original_proxy(float* a1, char* a2, int a3, int a4, float a5, float a6, float a7, float a8, int a9, int a10, void* a11, float a12) {\n    _asm {\n        push a12\n        push a11\n        push a10\n        push a9\n        push a8\n        push a7\n        push a6\n        push a5\n        push a4\n        push a3\n        push a2\n        mov ebx, a1\n        call original\n        retn //after that the code goes to another address (it is always the same)\n    }\n}\n\n```\nWhat could be the problem? Most likely something is wrong with asm, but then why does the code go to the same address after ret?\n\nSorry for my English, the translator can't always convey the meaning correctly.\nThanks in advance!\n\n",
  "votes": "1",
  "answers": 0,
  "views": "173",
  "tags": [
    "c++",
    "function-hooking",
    "assembly",
    "hooking"
  ],
  "user": "user42122",
  "time": "Oct 5, 2022 at 13:06",
  "comments": [],
  "answers_data": []
}