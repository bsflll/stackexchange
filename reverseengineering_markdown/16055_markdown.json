{
  "title": "idapython - Get Xrefs to a stack variable",
  "link": "https://reverseengineering.stackexchange.com/questions/16055/idapython-get-xrefs-to-a-stack-variable",
  "content": "I am trying to write an IDAPython script that will return a list of references to a local stack-frame variable. However, I couldn't find any API that does so.\n\nWhat I am trying to achieve is a code like:\nxrefs = get_variable_references('arg_4') that will return the results corresponding with the GUI's results:\n\n\n\nThanks in advance.\n\n",
  "votes": "8",
  "answers": 3,
  "views": "5k",
  "tags": [
    "ida",
    "disassembly",
    "idapython",
    "disassemblers",
    "idapro-sdk"
  ],
  "user": "Aviv",
  "time": "Aug 10, 2017 at 15:17",
  "comments": [],
  "answers_data": [
    {
      "content": "There is one function that does this: build_stkvar_xrefs, defined in C++ but exposed via the Python SWIG bindings. IDA builds stack xrefs dynamically when you ask for it. In order to use the function, it requires a little bit of setup.\n\nYou'll need to use a few functions to get what you need:\n\nHere's an example of how this all ties together:\n\n```\n# 0x4012d0 is the function address\n# 0x4012dc is an instruction address referencing\n# a stack variable. It looks like:\n# mov [ebp - 4], ecx\n\npFunc = get_func(0x4012d0)\npFrame = get_frame(pFunc)\ninst = DecodeInstruction(0x4012dc)\nop = inst[0] #first operand references stack var\npMember, val = get_stkvar(op, op.addr)\nxrefs = xreflist_t()\nbuild_stkvar_xrefs(xrefs, pFunc, pMember)\nfor xref in xrefs:\n    print hex(xref.ea) #print xref address\n\n# Contrived member dictionary example.\ndictMem = dict()\nx = 0\nwhile(x < pFrame.memqty):\n    dictMem[GetMemberName(pFrame.id, pFrame.get_member(x).soff)] = pFrame.get_member(x)\n    x = x+1\n# given var name you can now use the\n# dictionary to grab the member_t to pass\n# to build_stkvar_xrefs\npMem = dictMem[\"var_4\"]\nxrefs = xreflist_t()\nbuild_stkvar_xrefs(xrefs, pFunc, pMem)\nfor xref in xrefs:\n    print hex(xref.ea) #print xrefs to var_4\n\n```\nsoff isn't a stack offset. I think it means \"structure offset\", and it's an offset into the frame structure so you can retrieve other bits of information. You'll need this field to use other stack variable related functions such as: SetMemberType, SetMemberName, GetMemberName, DelStrucMember, etc. \n\nSo, for a simple on the fly variable name to xref lookup, you can do something like:\n\n```\ndef get_stack_xrefs(func_ea, var_name):\n    pFunc = get_func(func_ea)\n    pFrame = get_frame(pFunc)\n    pMember = None\n    result = []\n    while(x < pFrame.memqty):\n        if GetMemberName(pFrame.id, pFrame.get_member(x).soff) == var_name:\n           pMember = pFrame.get_member(x)\n           break; \n        x = x+1\n    if pMember: \n        xrefs = xreflist_t()\n        build_stkvar_xrefs(xrefs, pFunc, pMember)\n        for each in xrefs:\n            result.append(each.ea)\n    return result\n\n```\nIf you want more information on these functions, I recommend taking a look at the following modules from the IDA SDK documentation (in no particular order):\n\nReference: https://www.hex-rays.com/products/ida/support/sdkdoc/files.html\n\n",
      "votes": "7",
      "user": "mayahustle",
      "time": "Aug 15, 2017 at 21:30",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "TL;DR: There's no simple API to achieve this, code is at the end of the answer or here.\n\nAs far as I know, there is no easy way to get the references to stack structure. It seems like calling idautils.XrefsTo(sid) where sid is the frame id (retrieved using idc.GetFrame) should work, however I couldn't get it to yield any result in my attempts.\n\nInstead, however, you could walk over the function's instructions and calculate the offsets into the stack manually whenever a stack reference operand is encountered.\n\nI created a gist snippet to show just that, and although I think it's quite self-explanatory I'll go over it briefly here.\n\nFirst, we'll need a mapping of stack offsets to arguments, this is taken care of by the find_stack_members function, which uses the idc.GetFrame API function mentioned above to get the structure ID for the stack of a specific function. Then, it uses idautils.StructMembers API to iterate over the stack variables.\n\nOne interesting piece of logic in the find_stack_members function is that it uses the <space>r member name as the base of the stack (where the stack is once the function is entered), this is used later in find_stack_xrefs to calculate the stack offset of a variable based on the current stack delta and the operand immediate value.\n\nThe find_stack_xrefs function iterates over the instructions in the given function, and skips any instruction but those with a operand defined to reference the stack (note that arguments that reference the stack but aren't defined as such by either IDA's auto-analysis or manually will not be treated and hence will not count as a cross-reference).\n\nIf a stack offset operand exists in the instrcution, the find_stack_xrefs function will proceed to calculate it's offset using the stack's base offset (previously retrieved by find_stack_members), the current stack delta (calculated by IDA and available using the API idc.GetSpd) and the immediate taken from the Operand structure.\n\nFor convenience, I'm also including the code here:\n\n```\nimport idc, idaapi, idautils, ida_xref\n\ndef find_stack_members(func_ea):\n    members = {}\n    base = None\n    frame = idc.GetFrame(func_ea)\n    for frame_member in idautils.StructMembers(frame):\n        member_offset, member_name, _ = frame_member\n        members[member_offset] = member_name\n        if member_name == ' r':\n            base = member_offset\n    if not base:\n        raise ValueError(\"Failed identifying the stack's base address using the return address hidden stack member\")\n    return members, base\n\ndef find_stack_xrefs(func_offset):\n    func_ea = ida_funcs.get_func(func_offset).startEA\n    members, stack_base = find_stack_members(func_ea)\n    for func_item in FuncItems(func_ea):\n        flags = idc.GetFlags(ea)\n        stkvar = 0 if idc.isStkvar0(flags) else 1 if idc.isStkvar1(flags) else None\n        if not stkvar:\n            continue\n        ida_ua.decode_insn(func_item)\n        op = ida_ua.cmd.Operands[stkvar]\n        stack_offset = op.addr + idc.GetSpd(func_item) + stack_base\n        member = members[stack_offset]\n        print(\"At offset {:x} stack member {} is referenced by operand number {}\".format(func_item, member, stkvar))\n\nif __name__ == \"__main__\":\n    find_stack_xrefs(idc.ScreenEA())\n\n```\n",
      "votes": "6",
      "user": "NirIzr",
      "time": "Oct 17, 2017 at 11:00",
      "is_accepted": false,
      "comments": [
        {
          "user": "KulaGGin",
          "text": "This code doesn't work: it's outdated, it has multiple bugs and the algorithm is simply wrong. Don't anyone use it. I'll give you just a few examples: flags = idc.GetFlags(ea) is just wrong, there is no ea variable in this script. Meaning this code never actually worked. The idc.GetSpd(func_item) call is again wrong: GetSpd takes past-the-end address, not the address of the current instruction.",
          "time": null
        },
        {
          "user": "KulaGGin",
          "text": "And even after you supply a proper argument for GetSpd, the formula op.addr + idc.GetSpd(func_item) + stack_base is still wrong. The GetSpd gets the difference between the initial and current values of ESP and doesn't help to determine which stack variable is referenced and on what offset. For example, I have instruction mov     [rbp+0F0h+var_18], rax at address 0x14001242A. var_18 is at offset 0x18 respectively. The past-the-end address is 0x140012431, so I do idc.GetSpd(0x140012431), and get -0x118.",
          "time": null
        },
        {
          "user": "KulaGGin",
          "text": "Then formula: op.addr + idc.GetSpd(func_item) + stack_base turns into: 0x14001242A + (-0x118) + 0x118, which equals to 0x14001242A, which is the instruction address, not the stack offset. Which makes this answer completely wrong. If you want a working solution, check out the accepted answer by @mayahustle.",
          "time": null
        },
        {
          "user": "NirIzr",
          "text": "@KulaGGin Thanks for catching my errors! It's been a while and I'm not sure I tested the code. It was meant as a thought process snippet more than as a working solution. Thanks for pointing it out!",
          "time": null
        }
      ]
    },
    {
      "content": "Disclaimer: I maintain the ida-minsc plugin.\n\nUsing the minsc plugin at https://github.com/arizvisa/ida-minsc, you can do something like the following. For demonstration, we start out by disassembling the current instruction containing a stack operand. (We'd normally plug in an address, by giving it a parameter).\n\n```\nPython>db.disasm()\n'1c00feb4f: movzx eax, [rbp+57h+var_C8]'\n\n```\nNext we'll just display the operands for the current instruction in case we want to verify that the operand is definitely using the stack segment. This is using instruction.ops.\n\n```\nPython>ins.ops()\n(<class 'register_t' index=0 dtype=dt_dword name='eax' position=0+32>, SegmentOffsetBaseIndexScale(segment=%ss, offset=-0x71, base=%rbp, index=None, scale=1))\n\n```\nWe want the stack variable pointed to by the second operand, so we can use instruction.op_stack for this. This gives us a frame member of type member_t. If the operand is a structure path (as opposed to a stack variable), we could also use instruction.op_structure to get a regular structure member. For the record, both actually have the same effect when reading the operand (and only differ when modifying an operand).\n\n```\nPython>ins.op_stack(1)\n<member '$ F1C0077F18.var_C8' index=6 offset=-0xd0 size=+0x1 typeinfo='char'>\n\n```\nNext, we want the references to that frame member. We can snag these using the member_t.refs() method.\n\n```\nPython>ins.op_stack(1).refs()\n[opref_t(address=0x1c00fe9ae, opnum=0, access=access_t(w)), opref_t(address=0x1c00fea14, opnum=1, access=access_t(r)), opref_t(address=0x1c00feaed, opnum=1, access=access_t(r)), opref_t(address=0x1c00feb4f, opnum=1, access=access_t(r))]\n\n```\nFinally, we can iterate through the references that we snagged, disassemble the address, and then get the stack variable for those.\n\n```\nPython>for ref in ins.op_stack(1).refs():\nPython> print(ins.op_stack(ref))\nPython> print(db.disasm(ref))\n\n<member '$ F1C0077F18.var_C8' index=6 offset=-0xd0 size=+0x1 typeinfo='char'>\n1c00fe9ae: mov [rbp+57h+var_C8], 1\n<member '$ F1C0077F18.var_C8' index=6 offset=-0xd0 size=+0x1 typeinfo='char'>\n1c00fea14: movzx eax, [rbp+57h+var_C8]\n<member '$ F1C0077F18.var_C8' index=6 offset=-0xd0 size=+0x1 typeinfo='char'>\n1c00feaed: movzx eax, [rbp+57h+var_C8]\n<member '$ F1C0077F18.var_C8' index=6 offset=-0xd0 size=+0x1 typeinfo='char'>\n1c00feb4f: movzx eax, [rbp+57h+var_C8]\n\n```\nIf you want to grab them from an arbitrary frame member, you can grab the frame using function.frame(ea). Once the frame structure has been fetched, we can use the members_t attribute to access individual or multiple members.\n\n```\nPython>func.frame()\n<class 'structure' name='$ F1C0077F18' offset=-0x120 size=0x128>.\n\nPython>func.frame().members\n<class 'structure' name='$ F1C0077F18' offset=-0x120 size=0x128>\n     -120+0x28                                             [None, 40]\n[0]   -f8+0x8                  PLARGE_INTEGER 'Timeout'    (<class 'type'>, 8)\n[1]   -f0+0x8          PEVENT_DATA_DESCRIPTOR 'var_E8'     (<class 'type'>, 8)\n[2]   -e8+0x4                             int 'var_E0'     (<class 'int'>, 4)\n[3]   -e4+0x4                             int 'var_DC'     (<class 'int'>, 4)\n[4]   -e0+0x4                             int 'var_D8'     (<class 'int'>, 4)\n      -dc+0x4                                              [None, 4]\n...\n      -20+0x8                                              [None, 8]\n[18]  -18+0x1                            char 'var_10'     (<class 'int'>, 1)\n      -17+0xf                                              [None, 15]\n[19]   -8+0x8                         char[8] ' s'         [(<class 'int'>, 1), 8]\n[20]    0+0x8                         char[8] ' r'         [(<class 'int'>, 1), 8]\n\n```\nWe only want references for members that are typed (and not an argument), so we can start out by listing the results using the members_t.list method and filtering the results for the purpose of verifying things prior to collecting everything.\n\n```\nPython>func.frame().members.list(typed=True, args=False)\n[ 0] -f8:+0x8                 PLARGE_INTEGER 'Timeout'    (<class 'type'>, 8)                                                      (flag=35500400,dt_type=30000000)\n[ 1] -f0:+0x8         PEVENT_DATA_DESCRIPTOR 'var_E8'     (<class 'type'>, 8)                                                      (flag=35500400,dt_type=30000000)\n[ 7] -cc:+0x10                          GUID 'ActivityId' <class 'structure' name='_GUID' offset=-0xcc size=0x10>                  (flag=60000400,dt_type=60000000,typeid=ff00000000003840)\n[ 8] -b8:+0x10 struct _EVENT_DATA_DESCRIPTOR 'var_B0'     <class 'structure' name='_EVENT_DATA_DESCRIPTOR' offset=-0xb8 size=0x10> (flag=60000400,dt_type=60000000,typeid=ff0000000000df8c)\n[11] -88:+0x10 struct _EVENT_DATA_DESCRIPTOR 'var_80'     <class 'structure' name='_EVENT_DATA_DESCRIPTOR' offset=-0x88 size=0x10> (flag=60000400,dt_type=60000000,typeid=ff0000000000df8c)\n[14] -58:+0x10 struct _EVENT_DATA_DESCRIPTOR 'var_50'     <class 'structure' name='_EVENT_DATA_DESCRIPTOR' offset=-0x58 size=0x10> (flag=60000400,dt_type=60000000,typeid=ff0000000000df8c)\n\n```\nNow we can iterate through all the results, skip any references that aren't writing to the variable by checking its reference, and outputting a disassembly of the basic-block (using function.block that contains it.\n\n```\nPython>for m in func.frame().members(typed=True, args=False):\nPython>  for ref in m.refs():\nPython>    if 'w' not in ref: continue\nPython>    print(func.block(ref), ref)\nPython>    print(db.disasm(func.block(ref)))\nPython>    print()\nPython>\n\nbounds_t(left=0x1c0077f55, right=0x1c0077f79) opref_t(address=0x1c0077f69, opnum=0, access=access_t(w))\n1c0077f55: mov rcx, qword ptr cs:WPP_MAIN_CB.Queue\n1c0077f5c: lea rax, WPP_887fffb207bc3747f0ee19f0a3430899_Traceguids\n1c0077f63: mov r9d, 0Ah\n1c0077f69: mov [rsp+110h+Timeout], rax\n1c0077f6e: mov dl, 4\n1c0077f70: lea r8d, [r9+5]\n1c0077f74: call WPP_RECORDER_SF_\n\nopref_t(address=0x1c00fea47, opnum=0, access=access_t(w))\nbounds_t(left=0x1c00fea14, right=0x1c00fea51) opref_t(address=0x1c00fea47, opnum=0, access=access_t(w))\n1c00fea14: movzx eax, [rbp+57h+var_C8]\n1c00fea18: lea r8, [rbp+57h+ActivityId]\n1c00fea1c: mov [rsp+110h+var_E0], eax\n1c00fea20: lea rdx, dword_1C0213D87\n1c00fea27: lea rax, [rsp+110h+var_E0]\n1c00fea2c: mov [rbp+57h+var_88], 4\n1c00fea34: mov [rbp+57h+var_90], rax\n1c00fea38: xor r9d, r9d\n1c00fea3b: lea rax, [rbp+57h+var_B0]\n1c00fea3f: mov rcx, rdi\n1c00fea42: mov [rsp+110h+var_E8], rax\n1c00fea47: mov dword ptr [rsp+110h+Timeout], r13d\n1c00fea4c: call _tlgWriteTransfer_EtwWriteTransfer\n\n...\n\nopref_t(address=0x1c0077fca, opnum=0, access=access_t(w))\nbounds_t(left=0x1c0077fb4, right=0x1c0077fd8) opref_t(address=0x1c0077fca, opnum=0, access=access_t(w))\n1c0077fb4: cmp cs:bool InputTraceLogging::Perf::s_userCritLoggingEnabled, r14b\n1c0077fbb: lea rdi, dword_1C0246A60\n1c0077fc2: mov esi, 6\n1c0077fc7: xorps xmm0, xmm0\n1c0077fca: movups xmmword ptr [rbp+57h+ActivityId.Data1], xmm0\n1c0077fce: lea r13d, [rsi-3]\n1c0077fd2: jnz loc_1C00FE9AE\n\n```\n",
      "votes": "0",
      "user": "Ali Rizvi-Santiago",
      "time": "Jul 20, 2024 at 23:13",
      "is_accepted": false,
      "comments": []
    }
  ]
}