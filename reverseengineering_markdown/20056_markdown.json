{
  "title": "IDA does not create Vtbl structs for child classes loaded from PDB",
  "link": "https://reverseengineering.stackexchange.com/questions/20056/ida-does-not-create-vtbl-structs-for-child-classes-loaded-from-pdb",
  "content": "I'm decompiling a MFC 4.0 application, and now loaded the MFCS42.PDB from the MFC 4.2 source into IDA 7.0 (not having the MFC 4.0 source) to make it create the appropriate structs representing the many MFC classes and virtual function tables.\n\nHowever, IDA seems to only create *Vtbl structs for the very base classes, like CObject, not for child classes like CCmdTarget, which looks as follows:\n\n```\nstruct CObjectVtbl // totally correct\n{\n    CRuntimeClass *(__thiscall *GetRuntimeClass)(CObject *this);\n    void (__thiscall *~CObject)(CObject *this);\n    void (__thiscall *Serialize)(CObject *this, CArchive *);\n    void (__thiscall *AssertValid)(CObject *this);\n    void (__thiscall *Dump)(CObject *this, CDumpContext *);\n};\nstruct __cppobj CObject // totally correct\n{\n    CObjectVtbl *vfptr;\n};\n\nstruct __cppobj CCmdTarget : CObject // wrong, makes it have only a CObject vftable\n{\n    int m_dwRef;\n    IUnknown *m_pOuterUnknown;\n    unsigned int m_xInnerUnknown;\n    CCmdTarget::XDispatch m_xDispatch;\n    int m_bResultExpected;\n    CCmdTarget::XConnPtContainer m_xConnPtContainer;\n    AFX_MODULE_STATE *m_pModuleState;\n};\n\n```\nIn effect, this results in missing new virtual functions of CCmdTarget, as it only references the CObjectVtbl by inheriting from CObject, but CCmdTarget has 7 more methods.\n\nI previously hand-crafted these structures (which is tedious as you can guess), and it should actually look more like this:\n\n```\n// CObject and CObjectVtbl same as above\n\nstruct CCmdTargetVtbl : CObjectVtbl // inherit to keep base methods\n{\n    BOOL (__thiscall *OnCmdMsg)(CCmdTarget *this, UINT nID, int nCode, void *pExtra, void *pHandlerInfo);\n    void (__thiscall *OnFinalRelease)(CCmdTarget *this);\n    AFX_MSGMAP *(__thiscall *GetMessageMap)(CCmdTarget *this);\n    int field_20; // Don't know names yet\n    int field_24;\n    int field_28;\n    int field_2C;\n};\nstruct CCmdTargetMembers // member struct to reuse it in child classes\n{\n    int m_dwRef;\n    IUnknown *m_pOuterUnknown;\n    unsigned int m_xInnerUnknown;\n    CCmdTarget::XDispatch m_xDispatch;\n    int m_bResultExpected;\n    CCmdTarget::XConnPtContainer m_xConnPtContainer;\n    AFX_MODULE_STATE *m_pModuleState;\n};\nstruct CCmdTarget\n{\n    CCmdTargetVtbl *vfptr;\n    CCmdTargetMembers members;\n};\n\n```\nOnly this way, accessing virtual functions on child classes makes sense as their vftables are known. A sample hexrays decompilation shows that it does not make much sense with only the base vftables available:\n\nDecompilation with child vftables:\n\n```\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n    int nReturnCode; // esi MAPDST\n    CWinApp *pWinApp; // edi\n    CWinThreadVtbl *pThread; // ebx\n\n    nReturnCode = -1;\n    pWinApp = (CWinApp *)CBumperApp::instance;\n    if ( AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nShowCmd) )\n    {\n        pThread = &pWinApp->vftable->CWinThread;\n        if ( pWinApp->vftable->InitApplication(pWinApp) )\n        {\n            if ( pThread->InitInstance((CWinThread *)pWinApp) )\n            {\n                nReturnCode = pThread->Run((CWinThread *)pWinApp);\n            }\n[...]\n\n```\nDecompilation without child vftables:\n\n```\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n    int nReturnCode; // esi MAPDST\n    CWinApp *pWinApp; // edi\n    CObjectVtbl *pThread; // ebx\n\n    nReturnCode = -1;\n    pWinApp = CBumperApp::instance;\n    if ( AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nShowCmd) )\n    {\n        pThread = pWinApp->vfptr;\n        if ( pWinApp->vfptr[5].GetRuntimeClass(pWinApp) ) // nonsense\n        {\n            if ( (pThread[2].Serialize)(pWinApp) ) // nonsense\n            {\n                nReturnCode = (pThread[2].AssertValid)(pWinApp); // nonsense\n            }\n[...]\n\n```\nIs there any way to get IDA to load the vftables for child classes from the PDB and create all required structs? Or is this not yet possible in IDA 7.0?\n\nTo my knowledge, the PDB should have that info. Is there a tool to look into the PDB file to see if it indeed has this info?\n\n",
  "votes": "3",
  "answers": 1,
  "views": "2k",
  "tags": [
    "ida",
    "virtual-functions",
    "pdb"
  ],
  "user": "Ray",
  "time": "Dec 6, 2018 at 7:56",
  "comments": [],
  "answers_data": [
    {
      "content": "As far as I know, everything you've said is 100% correct. I've experienced the same issues. In fact, I was working on this exact problem in the background when a friend sent me a link to this post.\n\nThere are actually three related issues here. First, prior to IDA 7.2, IDA's type system did not have a concept of a virtual function table per se. Meaning, although you can create a structure with a bunch of function pointers in it, IDA did not have a mechanism for changing the type of the VTable pointer in a derived object. \"Derivation\" meant simply that everything from the base class was included literally at offset 0. Fortunately, IDA 7.2 does understand the concept of VTables in inheritance. There is a bit of documentation on Hex-Rays' website. The end of that page summarizes the rules:\n\nThe second issue is that the PDB plugin currently does not take advantage of these recent changes to the type system. I.e., it does not generate VTable type/class VTable member names according to the rules above.\n\nThe third issue is that the PDB file format is, frankly, a nightmare. You can view the contents of a PDB with the \"dia2dump\" sample that comes with Visual Studio (in the \"DIA SDK\" directory), however, be forewarned that the output is often wrong, misleading, or missing important information. The handling of virtual function information is especially terrible. I haven't completed my investigations, but one thing I've learned so far is that only base classes have SymTagVTable symbols. I.e., for a class B that derives from another class A with a VTable, only A will have a SymTagVTable symbol, not B. This is even true if B defines additional virtual functions that were not defined in A. And currently, the PDB plugin only creates VTables if the class has a SymTagVTable symbol, hence the behavior that you are seeing. Instead, you have to iterate through the member functions of B and check whether they are virtual using the get_virtual method -- which, by the way, is something that dia2dump does not do. I'm still investigating how all of this works for multiple inheritance.\n\nIn short, the solution to your problem -- and my problem -- lies in modifying the IDA 7.2 PDB plugin (which comes with the SDK) to:\n\nAgain, this is what I am also currently working on.\n\n",
      "votes": "7",
      "user": "Rolf Rolles",
      "time": "Dec 5, 2018 at 21:06",
      "is_accepted": true,
      "comments": [
        {
          "user": "Ray",
          "text": "This is a great coverage of what is new in IDA 7.2 on CPP / OOP things. I already quickly read about it, but did not realize it already starts here. I'm not eligible to update to 7.2 at this time, but I'm looking forward to do so in the future, and try to at least name my structures and fields in a way to match their new pattern for now, maybe via a script.",
          "time": null
        }
      ]
    }
  ]
}