{
  "title": "VADs with RWX permission in winlogon.exe process",
  "link": "https://reverseengineering.stackexchange.com/questions/3567/vads-with-rwx-permission-in-winlogon-exe-process",
  "content": "On a clean Windows XP SP2 installation running inside a VirtualBox VM, when doing a snapshot with vboxmangage debugvm --dumpguestcore and analyzing it in Volatility, I always find 9 VADs with PAGE_EXECUTE_READWRITE permissions in winlogon.exe process.\n\nI have already asked this question here, but for winlogon and csrss process: \nVADs with RWX permission in winlogon and csrss processes\n\nI was able to find out that RWX VADs in csrss.exe processes are heaps. Unforunately I can't confirm this for the VADs in winlogon.exe. \n\nBut I've read an article \"Integrity verification of user space code\" in the Digital Investigations journal, where there is some information about these RWX VADs. The article can be found here: http://www.dfrws.org/2013/proceedings/DFRWS2013-12.pdf\n\nIn this article Andrew White and his colleagues make the following statement:\n\nUnforunately I can't confirm this. Which I assume is due to me using Windows XP SP2 while they use XP SP3. Which probably results in a change of this address.\n\nThe code they've written for their approach is open source (it is based on volatility plugins), you can find it here: https://github.com/a-white/Hashtest The function they've written to extract the array in the data section is:\n\n```\ndef get_winlogon_allocations(self, task, ps_ad):\n    \"\"\"Get the EXECUTE_READWRITE pages used by winlogon\"\"\"\n    if str(task.ImageFileName) == \"winlogon.exe\":\n        base = task.SectionBaseAddress\n        addrs = []\n        # TODO - determine better method of finding offset\n        start = 0x72b0c  # will change for other versions of winlogon\n        current = start\n        while True:\n            value = ps_ad.zread(base + current, 4)\n            value = struct.unpack(\"<L\", value)[0]\n            if value > 0 and value % 0x1000 == 0:\n                addrs.append(value)\n                current += 0x8\n            else:\n                break\n        return addrs\n    else:\n        return []\n\n```\nDo you have an idea how they found this address? Or any hints that can point me to the correct address?\n\nThank you in advance and best regards!\n\n",
  "votes": "2",
  "answers": 2,
  "views": "480",
  "tags": [
    "windows",
    "memory",
    "digital-forensics"
  ],
  "user": "user3365",
  "time": "Apr 13, 2017 at 12:49",
  "comments": [],
  "answers_data": [
    {
      "content": "winlogon iirc allocates more than 9 RWX pages but does not free only these 9 pages until you create the dump\n\nyou observe these pages in dump because dump is premature death    \n\nif you wait sufficiently in shut down/logoff path you can probably catch the VirtualFree()'s    \n\ni already posted in the previous post you linked that almost all these pages contain code that saves teh flags and registers with pushf pushad sequence and jumps to some address via jmp eax\n\nbelow is a live stack where code is executed from an RWX page (this page will be freed wont be available when you create dump)\n\none way to find out the address in your setup could be to search the dump for the specific DWORD that is shown in !vad output a RWX page in winlogon memory  a sample of which is also pasted below\n\n```\nkd> kb\nChildEBP RetAddr  Args to Child              \n01e8f8b8 01010cf0 00000000 000080fd 00004000 winlogon!RmvpOpenNtDeviceFromWin32Path+0x23b\n01e8f904 01010bd8 000002a4 000002a4 00000000 winlogon!RmvpOpenNtDeviceFromWin32Path+0x1ea\n01e8f91c 0100e477 000002a4 000002a4 00000000 winlogon!RmvpOpenNtDeviceFromWin32Path+0xd2\n01e8fc04 01058b0a 00000001 01058c00 01e8fc4c winlogon!CheckForUserObjectUpdates+0xb3\n01e8fc70 02f7179d 000002a4 01049efc 00000000 winlogon!AutoPtrBase<_SECURITY_DESCRIPTOR>::AutoPtrBase<_SECURITY_DESCRIPTOR>+0x20\nWARNING: Frame IP not in any known module. Following frames may be wrong.\n01e8fef8 7c92796d 000002a4 7c97e460 000cfb20 0x2f7179d\n01e8ff40 7c9279ab 01049efc 000002a4 00000000 ntdll!RtlpWorkerCallout+0x70\n01e8ff60 7c927a6d 00000000 000002a4 000cfb20 ntdll!RtlpExecuteWorkerRequest+0x1a\n01e8ff74 7c927a44 7c927991 00000000 000002a4 ntdll!RtlpApcCallout+0x11\n01e8ffb4 7c80b713 00000000 00000000 00000000 ntdll!RtlpWorkerThread+0x87\n01e8ffec 00000000 7c910250 00000000 00000000 kernel32!BaseThreadStart+0x37\n\n```\none page in call stack is not in any known module disassemble and look\n\n```\nkd> ub 02f7179d\n02f71789 0000            add     byte ptr [eax],al\n02f7178b 0000            add     byte ptr [eax],al\n02f7178d 0000            add     byte ptr [eax],al\n02f7178f 0000            add     byte ptr [eax],al\n02f71791 53              push    ebx\n02f71792 52              push    edx\n02f71793 e8f8ca09fe      call    winlogon!DeleteRasConnections+0x3c (0100e290)\n02f71798 e8d78a0efe      call    winlogon!CreateAndHoldWPAGlobalMutex (0105a274)\nkd> u 02f7179d\n02f7179d 9c              pushfd\n02f7179e 60              pushad\n02f7179f 56              push    esi\n02f717a0 57              push    edi\n02f717a1 6a08            push    8\n02f717a3 e854cb09fe      call    winlogon!DeleteRasConnections+0xa8 (0100e2fc)\n02f717a8 ffe0            jmp     eax\n02f717aa 90              nop\n\n```\nso winlogon!CreateAndHoldWPAGlobalMutex (0105a274) is being executed from an unknown page\nwhen our access breakpoint broke \n\n```\nkd> r\neax=968dab54 ebx=00010000 ecx=000080fd edx=0000ffff esi=00000000 edi=00010000\neip=01010d41 esp=01e8f8b0 ebp=01e8f8b8 iopl=0         nv up ei ng nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000282\nwinlogon!RmvpOpenNtDeviceFromWin32Path+0x23b:\n001b:01010d41 c1f810          sar     eax,10h  <--- eip is +1 when hardware bp is hit\n\nkd> ub @eip\nwinlogon!RmvpOpenNtDeviceFromWin32Path+0x21f:\n01010d25 03c6            add     eax,esi\n01010d27 5e              pop     esi\n01010d28 5d              pop     ebp\n01010d29 c20800          ret     8\n01010d2c a1042b0701      mov     eax,dword ptr [winlogon!MMX_available+0x39c (01072b04)]  < read access not hit \n01010d31 69c0fd430300    imul    eax,eax,343FDh\n01010d37 05c39e2600      add     eax,269EC3h\n01010d3c a3042b0701      mov     dword ptr [winlogon!MMX_available+0x39c (01072b04)],eax  < we hit write access here match eax with data \n\n```\nand 72b0c also holds the page address from where execution is happening \ntry !vad on winlogon and confirm if it is RWX and search winlogon memory \n\n```\nkd> dd 01072b04 l4\n01072b04  968dab54 00000002 02f70000 00000000\n\n\nkd> !process 0 0 winlogon.exe\nPROCESS 81167cf8  SessionId: 0  Cid: 0218    Peb: 7ffdf000  ParentCid: 0168\n    DirBase: 088f5000  ObjectTable: e14a0600  HandleCount: 185.\n    Image: winlogon.exe\n\n\n\nkd> !grep -i -c \"!vad @@c++(((nt!_EPROCESS *) 0x81167cf8)->VadRoot)\" -e \"execute_readwrite\"\n\n812287d8 ( 9)       2f70     2f73         4 Private      EXECUTE_READWRITE \n\n\nkd> dd 01072b04 \n01072b04  968dab54 00000002 02f70000 00000000\n01072b14  00000000 00000000 00000000 00000000\n01072b24  00000000 00000000 00000000 00000000\n01072b34  00000000 00000000 00000000 00000000\n01072b44  00000000 00000000 00000000 00000000\n01072b54  00000000 00000000 00000000 00000000\n01072b64  00000000 00000000 00000000 00000000\n01072b74  00000000 00000000 00000000 00000000\n\n\nkd> lm m winlo*\nstart    end        module name\n01000000 01081000   winlogon   (pdb symbols)    \n\n\nkd> s -d winlogon l?81000 02f70000\n01072b0c  02f70000 00000000 00000000 00000000  ................\n\n```\nyou can search your dump for rwx page address instead of 72b0c if it showed say 68900\nyou will be able to find cross referances to the address in winlogon address space \n\n(windbg command # (search assembly pattern )\n\n```\nkd> # 72b0c 1008000 l?11000\nwinlogon!CheckForUserObjectUpdates+0x49:\n0100e40d 8b04c50c2b0701  mov     eax,dword ptr winlogon!MMX_available+0x3a4 (01072b0c)[eax*8]\nwinlogon!MprLogonNotify+0xda:\n01010812 8b04f50c2b0701  mov     eax,dword ptr winlogon!MMX_available+0x3a4 (01072b0c)[esi*8]\nwinlogon!RmvpOpenNtDeviceFromWin32Path+0x157:\n01010c5d 8934fd0c2b0701  mov     dword ptr winlogon!MMX_available+0x3a4 (01072b0c)[edi*8],esi\n\n```\nthe last one is a write location and edi contains the count \n\nhere is the RWX VirtualAlloc in xp sp3 you should be able to find similar pattern in sp2 also\n\n```\n01010CDC  PUSH    40               ; /Protect = PAGE_EXECUTE_READWRITE\n01010CDE  PUSH    3000             ; |AllocationType = MEM_COMMIT|MEM_RESERVE\n01010CE3  PUSH    4000             ; |Size = 4000 (16384.)\n01010CE8  PUSH    ESI              ; |/Arg2 = FFFFFFFF\n01010CE9  PUSH    0                ; ||Arg1 = 00000000\n01010CEB  CALL    winlogon.01010D05; |\\winlogon.01010D05\n01010CF0  IMUL    EAX, EBX         ; |\n01010CF3  ADD     EAX, EDI         ; |ntdll.7C910228\n01010CF5  PUSH    EAX              ; |Address = NULL\n01010CF6  CALL    K32.VirtualAlloc]; \\VirtualAlloc\n\n```\n",
      "votes": "2",
      "user": "blabb",
      "time": "Jan 28, 2014 at 20:50",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "I was able to find the correct address in winlogon.exe process for Windows XP SP2. It is 0x71ac4. \n\nI dumped the winlogon.exe process from memory using volatility. Then with a hex-editor I was able to find the addresses of the RWX VADs in the process, the array of addresses starts at 0x71ac4. The problem why I could not find these addresses in the first place is simple: it's the endianness. I searched for little-endian occurrences of the addresses but they are in big-endian. \n\nThanks to one of my co-workers for pointing me on this. :-)\n\n",
      "votes": "1",
      "user": "user3365",
      "time": "Jan 28, 2014 at 17:14",
      "is_accepted": false,
      "comments": []
    }
  ]
}