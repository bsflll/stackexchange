{
  "title": "The compiler adds a function call to user-defined functions. What does the function do? (x64 Windows executable)",
  "link": "https://reverseengineering.stackexchange.com/questions/27917/the-compiler-adds-a-function-call-to-user-defined-functions-what-does-the-funct",
  "content": "I compiled a simple executable with Visual Studio in x64 Windows. Source code:\n\n```\nlong test(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j) {\n  printf(\"%d %d %d\", a, b, c);\n  return 0x0123456789acdef;\n}\n\nint main() {\n  test(1,2,3,4,5,6,7,8,9,10);\n}\n\n\n```\nIf you compile the executable with GCC, then you get what you'd expect: one function call in main (it calls test) and one function call in test (it calls printf).\n\nHowever, if you compile the executable with Visual Studio on an x64 Windows machine, then  in both main and test, an additional call is made to some function. Let's call that function mystery. I'd like to know what the mystery function is for.\n\nHere is the disassembly of the main function. I have added a comment to show where the mystery function is called.\n\n```\nint main (int argc, char **argv, char **envp);\n; var int64_t var_c8h @ rbp+0xc8\n; var int64_t var_20h @ rsp+0x20\n; var int64_t var_28h @ rsp+0x28\n; var int64_t var_30h @ rsp+0x30\n; var int64_t var_38h @ rsp+0x38\n; var int64_t var_40h @ rsp+0x40\n; var int64_t var_48h @ rsp+0x48\n; var int64_t var_50h @ rsp+0x50\n\npush rbp\npush rdi\nsub rsp, 0x118\nlea rbp, [var_50h]\nlea rcx, [0x1400c1003]\ncall fcn.140034cf1         ; Mystery function here!\nmov dword [var_48h], 0xa\nmov dword [var_40h], 9\nmov dword [var_38h], 8\nmov dword [var_30h], 7\nmov dword [var_28h], 6\nmov dword [var_20h], 5\nmov r9d, 4\nmov r8d, 3\nmov edx, 2\nmov ecx, 1\ncall fcn.140033e73\nxor eax, eax\nlea rsp, [var_c8h]\npop rdi\npop rbp\nret\n\n```\nThe same mystery function is also called in the test function:\n\n```\ntest (int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4);\n; var int64_t var_c8h @ rbp+0xc8\n; var int64_t var_20h_2 @ rsp+0x20\n; var int64_t var_8h @ rsp+0x100\n; var int64_t var_10h @ rsp+0x108\n; var int64_t var_18h @ rsp+0x110\n; var int64_t var_20h @ rsp+0x118\n; arg int64_t arg1 @ rcx\n; arg int64_t arg2 @ rdx\n; arg int64_t arg3 @ r8\n; arg int64_t arg4 @ r9\n\nmov dword [var_20h], r9d   ; arg4\nmov dword [var_18h], r8d   ; arg3\nmov dword [var_10h], edx   ; arg2\nmov dword [var_8h], ecx    ; arg1\npush rbp\npush rdi\nsub rsp, 0xe8\nlea rbp, [var_20h_2]\nlea rcx, [0x1400c1003]\ncall fcn.140034cf1         ; Mystery function here!!!\nmov r9d, dword [var_18h]\nmov r8d, dword [var_10h]\nmov edx, dword [var_8h]\nlea rcx, str._d__d__d      ; 0x14009ff98 ; \"%d %d %d\"      \ncall fcn.1400335b3\nmov eax, 0x789acdef\nlea rsp, [var_c8h]\npop rdi\npop rbp\nret\n\n```\nHere are the contents of the mystery function:\n\n```\n├ 60: mystery (int64_t arg1);\n│           ; var int64_t var_20h @ rsp+0x20\n│           ; var int64_t var_8h @ rsp+0x40\n│           ; arg int64_t arg1 @ rcx\n│           0x1400387d8      48894c2408     mov qword [var_8h], rcx    ; arg1\n│           0x1400387dd      4883ec38       sub rsp, 0x38\n│           0x1400387e1      488b442440     mov rax, qword [var_8h]\n│           0x1400387e6      4889442420     mov qword [var_20h], rax\n│           0x1400387eb      488b442440     mov rax, qword [var_8h]\n│           0x1400387f0      0fb600         movzx eax, byte [rax]\n│           0x1400387f3      85c0           test eax, eax\n│       ┌─< 0x1400387f5      7418           je 0x14003880f\n│       │   0x1400387f7      833d06fa0700.  cmp dword [0x1400b8204], 0 ; [0x1400b8204:4]=0\n│      ┌──< 0x1400387fe      740f           je 0x14003880f\n│      ││   0x140038800      ff15fa770800   call qword [sym.imp.KERNEL32.dll_GetCurrentThreadId] ; [0x1400c0000:8]=0xc0738 reloc.KERNEL32.dll_GetCurrentThreadId ; \"8\\a\\f\" ; DWORD GetCurrentThreadId(void)\n│      ││   0x140038806      3905f8f90700   cmp dword [0x1400b8204], eax ; [0x1400b8204:4]=0\n│     ┌───< 0x14003880c      7501           jne 0x14003880f\n│     │││   0x14003880e      90             nop\n│     │││   ; CODE XREFS from mystery @ 0x1400387f5, 0x1400387fe, 0x14003880c\n│     └└└─> 0x14003880f      4883c438       add rsp, 0x38\n└           0x140038813      c3             ret\n\n```\nThe call to KERNEL32.dll_GetCurrentThreadId in the mystery function seemed interesting, but I couldn't find any information about functions, which get added by the compiler and call GetCurrentThreadId.\n\nThe question arose because I was studying the Microsoft x64 calling convention and I noticed that the mystery function didn't seem to use \"home space\" (also known as \"shadow space\", 32 bytes of space on the stack that's assigned to each function). I wanted to know what that function is and why home space wasn't assigned to it.\n\nSo the question is, what is the mystery function?\n\n",
  "votes": "4",
  "answers": 2,
  "views": "1k",
  "tags": [
    "disassembly"
  ],
  "user": "Nopslide__",
  "time": "Jun 29, 2021 at 10:08",
  "comments": [],
  "answers_data": [
    {
      "content": "The \"mystery\" function you refer to is called __CheckForDebuggerJustMyCode and is inserted by MSVC when /JMC (Just My Code debugging) option is enabled. From docs:\n\nTo verify that the \"mystery\" function indeed corresponds to __CheckForDebuggerJustMyCode, you can put the breakpoint in Visual Studio in the main's first line, press F5 to start debugging, and then ctrl + alt + d to show window with the assembly generated by the compiler. You will get something like this:\n\n\n\n",
      "votes": "10",
      "user": "bart1e",
      "time": "Jun 30, 2021 at 14:19",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "provide full code compiler version and compiler / linker arguments\n\nhere i checked it with msvc 2017 x64 and i don't find any mystery function\n\nalso i ran it on Compiler Explorer  with several versions of msvc x64 and they dont spit it either\n\n```\n:\\>cl 2>&1 | head -n 1\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.16.27045 for x64\n\n:\\>cat myst.cpp\n#include <stdio.h>\nlong test(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j) {\n  printf(\"%d %d %d\", a, b, c);\n  return 0x0123456789acdef;\n}\n\nint main() {\n  test(1,2,3,4,5,6,7,8,9,10);\n}\n\n:\\>cl /Zi /W4 /analyze /Od /EHsc /nologo myst.cpp /link /release\nmyst.cpp\nmyst.cpp(4): warning C4305: 'return': truncation from '__int64' to 'long'\nmyst.cpp(4): warning C4309: 'return': truncation of constant value\nmyst.cpp(2): warning C4100: 'j': unreferenced formal parameter\nmyst.cpp(2): warning C4100: 'i': unreferenced formal parameter\nmyst.cpp(2): warning C4100: 'h': unreferenced formal parameter\nmyst.cpp(2): warning C4100: 'g': unreferenced formal parameter\nmyst.cpp(2): warning C4100: 'f': unreferenced formal parameter\nmyst.cpp(2): warning C4100: 'e': unreferenced formal parameter\nmyst.cpp(2): warning C4100: 'd': unreferenced formal parameter\n\n:\\>cdb -c \"uf myst!main;q\" myst.exe | awk /Reading/,/quit/\n0:000> cdb: Reading initial command 'uf myst!main;q'\nmyst!main:\n00007ff6`538a1040 4883ec58        sub     rsp,58h\n00007ff6`538a1044 c74424480a000000 mov     dword ptr [rsp+48h],0Ah\n00007ff6`538a104c c744244009000000 mov     dword ptr [rsp+40h],9\n00007ff6`538a1054 c744243808000000 mov     dword ptr [rsp+38h],8\n00007ff6`538a105c c744243007000000 mov     dword ptr [rsp+30h],7\n00007ff6`538a1064 c744242806000000 mov     dword ptr [rsp+28h],6\n00007ff6`538a106c c744242005000000 mov     dword ptr [rsp+20h],5\n00007ff6`538a1074 41b904000000    mov     r9d,4\n00007ff6`538a107a 41b803000000    mov     r8d,3\n00007ff6`538a1080 ba02000000      mov     edx,2\n00007ff6`538a1085 b901000000      mov     ecx,1\n00007ff6`538a108a e871ffffff      call    myst!test (00007ff6`538a1000)\n00007ff6`538a108f 33c0            xor     eax,eax\n00007ff6`538a1091 4883c458        add     rsp,58h\n00007ff6`538a1095 c3              ret\nquit:\n\n:\\>cdb -c \"uf myst!test;q\" myst.exe | awk /Reading/,/quit/\n0:000> cdb: Reading initial command 'uf myst!test;q'\nmyst!test:\n00007ff6`538a1000 44894c2420      mov     dword ptr [rsp+20h],r9d\n00007ff6`538a1005 4489442418      mov     dword ptr [rsp+18h],r8d\n00007ff6`538a100a 89542410        mov     dword ptr [rsp+10h],edx\n00007ff6`538a100e 894c2408        mov     dword ptr [rsp+8],ecx\n00007ff6`538a1012 4883ec28        sub     rsp,28h\n00007ff6`538a1016 448b4c2440      mov     r9d,dword ptr [rsp+40h]\n00007ff6`538a101b 448b442438      mov     r8d,dword ptr [rsp+38h]\n00007ff6`538a1020 8b542430        mov     edx,dword ptr [rsp+30h]\n00007ff6`538a1024 488d0d15c30400  lea     rcx,[myst!__xt_z+0x8 (00007ff6`538ed340)]\n00007ff6`538a102b e8d0000000      call    myst!printf (00007ff6`538a1100)\n00007ff6`538a1030 b8efcd9a78      mov     eax,789ACDEFh\n00007ff6`538a1035 4883c428        add     rsp,28h\n00007ff6`538a1039 c3              ret\nquit:\n\n```\nedit\nas bart1e pointed out in his answer it was debug_just_my_code\nthe argument /jmc wasn't documented in cl /? in vs 2017 but has been implemented\n\n```\n:\\>cl /? >args.txt\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.16.27045 for x64\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n\n:\\>grep -ir jmc args.txt\n\n:\\>grep -ir jm args.txt\n\n:\\>grep -ir j args.txt\n/Fm[file] name map file                 /Fo<file> name object file\n/Fm: <file> name map file               /Fo: <file> name object file\n/P preprocess to file                   /Fx merge injected code to file\n    c++latest - latest draft standard (feature set subject to change)\n/permissive[-] enable some nonconforming code to compile (feature set subject to change) (on by default)\n  alignedNew[-]         enable C++17 alignment of dynamically allocated objects (on by default)\n/Zp[n] pack structs on n-byte boundary  /Zl omit default library name in .OBJ\n/bigobj generate extended object format /c compile only, no link\n/J default char type is unsigned\n/Yd put debug info in every .OBJ        /Yl[sym] inject .PCH ref for debug lib\n\n:\\> \n\n```\npassing jmc and resulting just my code function call addition\n\n```\n:\\>cdb -c \"uf myst!main;uf myst!__CheckForDebuggerJustMyCode;q\" myst.exe | awk /Reading/,/quit/\n0:000> cdb: Reading initial command 'uf myst!main;uf myst!__CheckForDebuggerJustMyCode;q'\n\nmyst!main:\n00007ff7`3c031050 4883ec58        sub     rsp,58h\n00007ff7`3c031054 488d0da84f0600  lea     rcx,[myst!_DebuggerCurrentSteppingThreadId <PERF> (myst+0x66003) (00007ff7`3c096003)]\n00007ff7`3c03105b e844010000      call    myst!__CheckForDebuggerJustMyCode (00007ff7`3c0311a4)\n00007ff7`3c031060 c74424480a000000 mov     dword ptr [rsp+48h],0Ah\n00007ff7`3c031068 c744244009000000 mov     dword ptr [rsp+40h],9\n00007ff7`3c031070 c744243808000000 mov     dword ptr [rsp+38h],8\n00007ff7`3c031078 c744243007000000 mov     dword ptr [rsp+30h],7\n00007ff7`3c031080 c744242806000000 mov     dword ptr [rsp+28h],6\n00007ff7`3c031088 c744242005000000 mov     dword ptr [rsp+20h],5\n00007ff7`3c031090 41b904000000    mov     r9d,4\n00007ff7`3c031096 41b803000000    mov     r8d,3\n00007ff7`3c03109c ba02000000      mov     edx,2\n00007ff7`3c0310a1 b901000000      mov     ecx,1\n00007ff7`3c0310a6 e855ffffff      call    myst!test (00007ff7`3c031000)\n00007ff7`3c0310ab 33c0            xor     eax,eax\n00007ff7`3c0310ad 4883c458        add     rsp,58h\n00007ff7`3c0310b1 c3              ret\n\n\nmyst!__CheckForDebuggerJustMyCode:\n00007ff7`3c0311a4 48894c2408      mov     qword ptr [rsp+8],rcx\n00007ff7`3c0311a9 4883ec38        sub     rsp,38h\n00007ff7`3c0311ad 488b442440      mov     rax,qword ptr [rsp+40h]\n00007ff7`3c0311b2 4889442420      mov     qword ptr [rsp+20h],rax\n00007ff7`3c0311b7 488b442440      mov     rax,qword ptr [rsp+40h]\n00007ff7`3c0311bc 0fb600          movzx   eax,byte ptr [rax]\n00007ff7`3c0311bf 85c0            test    eax,eax\n00007ff7`3c0311c1 7418            je      myst!__CheckForDebuggerJustMyCode+0x37 (00007ff7`3c0311db)\n\nmyst!__CheckForDebuggerJustMyCode+0x1f:\n00007ff7`3c0311c3 833d7ef4050000  cmp     dword ptr [myst!__DebuggerCurrentSteppingThreadId (00007ff7`3c090648)],0\n00007ff7`3c0311ca 740f            je      myst!__CheckForDebuggerJustMyCode+0x37 (00007ff7`3c0311db)\n\nmyst!__CheckForDebuggerJustMyCode+0x28:\n00007ff7`3c0311cc ff152ebe0400    call    qword ptr [myst!_imp_GetCurrentThreadId (00007ff7`3c07d000)]\n00007ff7`3c0311d2 390570f40500    cmp     dword ptr [myst!__DebuggerCurrentSteppingThreadId (00007ff7`3c090648)],eax\n00007ff7`3c0311d8 7501            jne     myst!__CheckForDebuggerJustMyCode+0x37 (00007ff7`3c0311db)\n\nmyst!__CheckForDebuggerJustMyCode+0x36:\n00007ff7`3c0311da 90              nop\n\nmyst!__CheckForDebuggerJustMyCode+0x37:\n00007ff7`3c0311db 4883c438        add     rsp,38h\n00007ff7`3c0311df c3              ret\nquit:\n\n```\n",
      "votes": "3",
      "user": "blabb",
      "time": "Jun 30, 2021 at 18:21",
      "is_accepted": false,
      "comments": []
    }
  ]
}