{
  "title": "IL for decompiler to human-readable format",
  "link": "https://reverseengineering.stackexchange.com/questions/8835/il-for-decompiler-to-human-readable-format",
  "content": "After writing my own disassembler, I am now looking to making its assembly listing more human readable, e.g. from an (artificial) example\n\n```\npush    ebp\nmov     ebp, esp\nsub     esp, 10h\nmov     eax, dword ptr [55431824h]\nimul    eax, dword ptr [ebp+8]\nadd     eax, dword ptr [ebp+0ch]\nmov     dword ptr [ebp-4], eax\nmov     eax, dword ptr [ebp-4]\nleave\nret     10h\n\n```\nvia (> marks an auto-recognized prologue/epilogue):\n\n```\n>push    ebp\n>mov     ebp, esp\n>sub     esp, 10h\n\n mov     eax, dword ptr [_global_55431824]\n imul    eax, dword ptr [arg_0]\n add     eax, dword ptr [arg_4]\n mov     dword ptr [local_4], eax\n mov     eax, dword ptr [local_4]\n\n>leave\n>ret     10h\n\n```\ntowards\n\n```\neax = 10\neax *= arg_0\neax += arg_4\nlocal_4 = eax\neax = local_4\nreturn\n\n```\nAt this point, each pseudo instruction is still tied to its original disassembled representation. When printing out, I can scan for certain sequences and so I replace the first two lines with\n\n```\neax = 10 * arg_0\n\n```\nand then just skip printing the next line. However, there is a limit to how far I can get with that. Concatenating the next operation, which would lead to\n\n```\neax = 10 * arg_0 + arg_4\n\n```\nrequires to look ahead two instructions, and would only work for this specific combination of mov, imul, and add, while assuring the same destination register is still targeted and the intermediate instructions have no lasting effect on other registers.\n\nThe goal is to end up with something like this:\n\n```\nlocal_4 = 10 * arg_0 + arg_4\neax = local_4\nreturn\n\n```\nwhere obviously eax is specifically assigned a value before a return, so the last line can be\n\n```\nreturn eax\n\n```\nand finally the entire construction can be collapsed into\n\n```\nreturn 10 * arg_0 + arg_4\n\n```\n(which is very close to what I started with in the original trivial C program). I am struggling with the internal representation of composite lines such as the last one. The otherwise very reliable decompiler page backerstreet.com/creating_statements casually switches between raw assembler and C-like compound statements:\n\n```\nif(!expr1 && !expr2)\n  ...\n\n```\nwithout explaining how this intermediate step is stored in memory and can create the output string.\n\nWhat type of intermediate storage form should I be looking at, which (a) can be constructed from the original disassembled instructions, (b) can have its elements combined and rearranged, and (c) can be translated into human-readable output such as the last line?\n\nIt may be worth mentioning that I am not aiming to create the Definitive Universal Decompiler :) My test input was compiled with an ancient version (most likely pre-1993) of Delphi Pascal, but while its assembly is not really optimized and fairly readable to begin with, I'd still like to go the extra mile and make my computer do what it does best and make it yet easier to understand the code.\n\nBelow is some actual disassembly. The basic block number is followed by a dominator bit set (the loops hex number; I generate them but have not used that data yet). The ENTRY and EXIT numbers are to basic blocks again and used to generate a .dot view of the function.\n\n```\n; ## BLOCK 0; loops: 01; EXIT to 1, 4\n401966A8    (  0)  8B 15 42201590       mov     edx,dword ptr [42201590]\n401966AE    (  0)  8B 12                mov     edx,dword ptr [edx]\n401966B0    (  0)  80 BA 39 01 00 00 02 cmp     byte ptr [edx+139h],2\n401966B7    (  0)  75 11                jnz     label_4\n\n; ## BLOCK 1; loops: 03; ENTER from 0; EXIT to 2, 4\n401966B9    (  0)  83 78 24 02          cmp     dword ptr [eax+24h],2\n401966BD    (  0)  7D 0B                jge     label_4\n\n; ## BLOCK 2; loops: 07; ENTER from 1; EXIT to 3=RET\n401966BF    (  0)  BA 02 00 00 00       mov     edx,2\n401966C4    (  0)  2B 50 24             sub     edx,dword ptr [eax+24h]\n401966C7    (  0)  8B C2                mov     eax,edx\n\n; ## BLOCK 3 (epilog); loops: 0F; ENTER from 2\n401966C9          >C3                   retn    \n\n; ## BLOCK 4; loops: 11; ENTER from 0, 1; EXIT to 5, 7\n                        label_4:\n401966CA    (  0)  8B 15 42201590       mov     edx,dword ptr [42201590]\n401966D0    (  0)  8B 12                mov     edx,dword ptr [edx]\n401966D2    (  0)  80 BA 39 01 00 00 01 cmp     byte ptr [edx+139h],1\n401966D9    (  0)  75 0D                jnz     label_7\n\n; ## BLOCK 5; loops: 31; ENTER from 4; EXIT to 6, 7\n401966DB    (  0)  83 78 24 00          cmp     dword ptr [eax+24h],0\n401966DF    (  0)  75 07                jnz     label_7\n\n; ## BLOCK 6; loops: 71; ENTER from 5; EXIT to 8=RET\n401966E1    (  0)  B8 01 00 00 00       mov     eax,1\n401966E6    (  0)  EB 02                jmp     label_8\n\n; ## BLOCK 7; loops: 91; ENTER from 4, 5; EXIT to 8=RET\n                        label_7:\n401966E8    (  0)  33 C0                xor     eax,eax\n\n; ## BLOCK 8 (epilog); loops: 0111; ENTER from 6, 7\n                        label_8:\n401966EA          >C3                   retn    \n\n401966EB                align 4\n\n```\nThis is the .dot image; clear ifs are yellow, and the nodes contain their dominator bit sets so I can try and make sense of them (a TO-DO as yet). This explains the flow but you cannot see how much code each node represents.\n\n\n\nThe disassembly gets parsed into the following pseudo-code. Some notes are manually added.\n\n```\n; #### PARSED\n401966A8    (  0)       edx = Main.UnitList@20551314 ;\n401966AE    (  0)       edx = (dword)[edx] ;\n401966B0    (  0)       if ((byte)[edx + 139h] != 2) goto label_4 ;\n\n401966B9    (  0)       if ((dword)[eax + 24h] >= 2) goto label_4 ;\n\n401966BF    (  0)       edx = 2 ;\n401966C4    (  0)       edx -= (dword)[eax + 24h] ;\n401966C7    (  0)       return edx ; MOV EAX,.. where an exit block follows\n\n                        return ;  .. and this line is generated by the actual exit block\n\n                    label_4:\n401966CA    (  0)       edx = Main.UnitList@20551314 ;\n401966D0    (  0)       edx = (dword)[edx] ;\n401966D2    (  0)       if ((byte)[edx + 139h] != 1) goto label_7 ;\n\n401966DB    (  0)       if ((dword)[eax + 24h] != 0) goto label_7 ;\n\n401966E1    (  0)       eax = 1 ;\n401966E6    (  0)       return ;  this was a jump-to-exit-block, so missed\n\n                    label_7:\n401966E8    (  0)       eax = 0 ; this was a XOR, not a MOV, so missed\n\n                    label_8:\n                        return ;\n\n```\nThe loss in verbosity is already worth the effort: from 21 lines of code to 16 lines, even though the lookahead to check if EAX got written to right before a RET failed twice.\n\nYet, it is obvious that the two successive ifs at 401966B0 can be combined into a single one, with an OR. Inverting the condition, that whole block can be a single if and braced up to the return, removing label_4.\nThe manipulation of edx from 401966BF onwards can be concatenated into a single return statement.\nAlso, the if conditions at 401966D2 can be combined into a single one and put inside an if block. Since there is a return at its end, an else is not necessary there. Manually reconstructed:\n\n```\n401966A8    (  0)       edx = Main.UnitList@20551314 ;\n401966AE    (  0)       edx = (dword)[edx] ;\n401966B0    (  0)       if ((byte)[edx + 139h] == 2 &&\n401966B9    (  0)           (dword)[eax + 24h] < 2)\n                        {\n401966BF    (  0)           return 2 - (dword)[eax + 24h] ;\n                        }\n\n401966CA    (  0)       edx = Main.UnitList@20551314 ;\n401966D0    (  0)       edx = (dword)[edx] ;\n401966D2    (  0)       if ((byte)[edx + 139h] == 1 &&\n401966DB    (  0)          (dword)[eax + 24h] == 0)\n                        {\n401966E1    (  0)           return 1 ;\n                        }\n\n401966E8    (  0)       return 0 ;\n\n```\nreducing the original 21 lines to a mere 11. Furthermore, register value propagation resolves the references to the global class Main.UnitList. I manually created names for its elements; 401966A8 and forwards collapses into\n\n```\n401966B0    (  0)       if (Main.UnitList.flag == 2 &&\n401966B9    (  0)           Main.UnitList.count < 2)\n\n```\nwhich makes the code practically readable.\n\nAccessing eax before it gets written is not an error here. The function is a class function, and eax points to a class instance, so (dword)[eax + 24h] reads a data member of the structure. Main.UnitList is a pointer to a globally declared class instance, since it points into the BSS.\n\n",
  "votes": "8",
  "answers": 2,
  "views": "1k",
  "tags": [
    "disassembly",
    "decompilation"
  ],
  "user": "Jongware",
  "time": "May 8, 2015 at 9:48",
  "comments": [
    {
      "user": "Guntram Blohm",
      "text": "What you're trying to do is very hard. Consider how long the Hex-Rays decompilers have been developed, and how much manual tuning the results need.",
      "time": null
    },
    {
      "user": "Jongware",
      "text": "@GuntramBlohm: well I cannot but agree with that. The next step, from registers and 'local' variable to 'actual' variables, is within my capabilities (tracking the life time of each registers), but then I end up with a list of singular operations, which I want to concatenate – at least for the trivial cases. That needs an IL, conceptually separated from the original assembly.",
      "time": null
    },
    {
      "user": "yaspr",
      "text": "Indeed, as @GuntramBlohm stated, decompilation isn't for the faint of heart. But, it is doable, though you'll have to make difficult choices. Check out McSema (blog.trailofbits.com/2014/08/07/…), it does a remarkable job transforming x86 assembly into LLVM IR. Keep in mind that what you're trying to do requires the extensive use of heuristics & pattern matching.",
      "time": null
    },
    {
      "user": "Jongware",
      "text": "@yaspr: that looks good! Yes, as my target is fairly limited (I added a paragraph about that), I may look in to pattern matching. The compiler that was used was an oldie, no fancy optimizations – here and there not even (humanly) obvious ones.",
      "time": null
    },
    {
      "user": "yaspr",
      "text": "@Jongware Well, I kind of noticed the stack operations which most modern compilers would've avoided; my thought was either this is -O0 code or an old compiler.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "For creating \"humanly\" readable expressions, i'd use an arithmetic parse tree. In fact, one separate parse tree for each of the registers and memory locations that are involved.\n\nEvery assignment copies the root of the target tree to the destination tree.\n\nEvery arithmetic operation creates a new root containing the operation, with the operands as the left & right child. The resulting tree is assigned to the target of the arithmetic operation.\n\nYour example builds up like this:\n\n\n\nFrom there, emitting the resulting formula is just a ltr tree walk. You'll probably want to simplify your expression first; you can replace an operator that has two constant subnodes with the operation result, and you might want to transform your tree by moving constants down where possible, like this:\n\n```\n              eax\n               |\n              add\n               |\n     +---------+--------+\n     |                  |\n    add                 5\n     |                  \n+----+-------+          \n|            |\n2           ebx\n\n\n              eax\n               |\n              add\n               |\n     +---------+--------+\n     |                  |\n    add                ebx\n     |                  \n+----+-------+         \n|            |\n2            5\n\n              eax\n               |\n              add\n               |\n     +---------+--------+\n     |                  |\n     7                 ebx\n\n```\nGoogle for \"expression tree\" and \"constant folding\" for more resources on this.\n\nMind that trees might be \"self-referencing\", especially in loops; the loop control variable will be seen at the top node, and somewhere down the tree as well. This is actually a good way to identify loop variables.\n\nI'd probably start with trying to recognize basic blocks (everything that doesn't contain a jmp instruction or destination), and then build and dump the expression trees for these basic blocks. If you get this working well, you might continue by identifying stuff that stretches over several blocks, but is constant in some of them, like loops, to find out what's being built over the whole function.\n\nEDIT: Another example, which shows how to treat register moves\n\nA raw register move just copies the tree from the source register to the destination register. This is from an old watcom C program, compiled when imul was slow, and a series of shift/add instructions was faster; the compiler calculates var*45 here:\n\n```\nmov eax, [var]\nmov edx, eax      <-- tree copy here (not much of a tree, however)\nshl edx, 2\nadd eax, edx\nmov edx, eax      <-- tree copy again\nshl eax, 3\nadd eax, edx\n\n```\n\n\n",
      "votes": "3",
      "user": "Guntram Blohm",
      "time": "May 8, 2015 at 6:32",
      "is_accepted": true,
      "comments": [
        {
          "user": "Jongware",
          "text": "Thanks for the excellent example. I already have the Basic Blocks (improved since my last question on those), and they help a lot in deciding variable scope. Since variables need cleaning up anyway, could that be done by storing the raw register moves in this same tree and then cleaning up the branches?",
          "time": null
        },
        {
          "user": "Guntram Blohm",
          "text": "Added another example. A raw register move translates to the tree being copied from the source to the destination. At the end, each register has a tree that has the register value (edx, not shown in the last step, still has var*5), and each tree depends on input variables only (there's no edx in the last representation of eax, even though it was used in the calculation). After cleaning up the eax tree, you have var mul 45.",
          "time": null
        }
      ]
    },
    {
      "content": "What you're describing here is essentially the same as a static binary translator that uses a high level language such as C as its output target rather than a specific architecture.  It's not quite as advanced a mechanism as decompiling but it has proven quite effective in restricted domains such as arcade video games. (eg http://vide.malban.de/vectrex-programs/vecfever )  There have been a few of these written; I have code for work in progress that does this for 6809, 6502, z80 and Cinematronic CPUs for example (though probably not immediately usable - it's a coming-together of four separate background projects with no great urgency).  Anyway feel free to poke around and see if there's anything here that is helpful to you: http://gtoal.com/SBTPROJECT/ (the 6809 one is probably the cleanest code if you're just browsing and not actually running it)\n\nThere's a bit of a writeup of the overall method at http://gtoal.com/sbt/\n\nOutput looks something like this:\n\n```\n            //        LDA   $FFFF,X                 ; 0431: A6 1F         \n      A = memory[(UINT16)(X + 0xffff)];\n  //  N = A;\n  //  Z = A;\n  //  V = 0;\n\n            //        LEAU  ,X                      ; 0433: 33 84         \n      U = X;\n\n            //        LDX   #$0EC8                  ; 0435: 8E 0E C8      \n      X = 0x0ec8;\n  //  Z = X;\n  //  N = (X) >> 8;\n  //  V = 0;\n\n```\n(the commented out lines are due to optimisation of redundant stores)\n\nRather than output functional code for execution, you could satisfy the OP's request by outputting comments that describe in detail what the operations are doing.\n\nOther practical translators have been written by David Welch, Norbert Keher, Thomas Sontowski and others.  There is also Project Orion which is a multi-person multi-target translator headed up by Neil Bradley (respected emulator author) and several other members of the Orion mailing list - that translator had working front ends for 6502 and z80, with 68000 and 6809 also being under development, and built an internal AST (Abstract Syntax Tree, much as described in one of the earlier answers in this thread) in order to output cleaner and more efficient code to a variety of back ends including C.  (There is also some academic work produced by Christina Cifuentes et al.)\n\nGraham\n\nPS When the output is a generic IR (Internal Representation) such as C or LLVM's internal IR, as opposed to when you produce binary directly, or indirectly by outputting asm for a specific architecture) the technique is properly called \"Compiled Instruction Set Simulation\" - but most people just call it static binary translation.\n\n",
      "votes": "1",
      "user": "Graham Toal",
      "time": "Apr 16, 2020 at 9:43",
      "is_accepted": false,
      "comments": []
    }
  ]
}