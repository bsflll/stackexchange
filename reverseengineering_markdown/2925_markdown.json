{
  "title": "Thread-Switching with PyDbg",
  "link": "https://reverseengineering.stackexchange.com/questions/2925/thread-switching-with-pydbg",
  "content": "I'm having trouble switching from debugging one thread to another in pydbg. I don't have much experience with multithreading, so I'm hoping that I'm just missing something obvious.\n\nBasically, I want to suspend all threads, then start single stepping in one thread. In my case, there are two threds. \n\nFirst, I suspend all threads. Then, I set a breakpoint on the location where EIP will be when thread 2 is resumed. (This location is confirmed by using IDA). Then, I enable single-stepping as I would in any other context, and resume Thread 2.\n\nHowever, pydbg doesn't seem to catch the breakpoint exception! Thread 2 seems to resume and even though it MUST hit that address, there is no indication that pydbg is catching the breakpoint exception. I included a \"print \"HIT BREAKPOINT\" inside pydbg's internal breakpoint handler, and that never seems to be called after resuming Thread 2. \n\nI'm not too sure about where to go next, so any suggestions are appreciated!\n\n```\n    dbg.suspend_all_threads()\n    print dbg.enumerate_threads()[0]\n    oldcontext = dbg.get_thread_context(thread_id=dbg.enumerate_threads()[0])\n    if (dbg.disasm(oldcontext.Eip) == \"ret\"):\n        print disasm_at(dbg,oldcontext.Eip)\n        print \"Thread EIP at a ret\"\n        addrstr = int(\"0x\"+(dbg.read(oldcontext.Esp + 4,4))[::-1].encode(\"hex\"),16)\n        print hex(addrstr)\n        dbg.bp_set(0x7C90D21A,handler=Thread_Start_bp_Handler)\n        print dbg.read(0x7C90D21A,1).encode(\"hex\")\n    dbg.bp_set(oldcontext.Eip + dbg.instruction.length,handler=Thread_Start_bp_Handler)\n    dbg.set_thread_context(oldcontext,thread_id=dbg.enumerate_threads()[0])\n    dbg.context = oldcontext\n    dbg.resume_thread(dbg.enumerate_threads()[0])\n    dbg.single_step(enable=True)\n    return DBG_CONTINUE\n\n```\nSorry about the \"magic numbers\", but they are correct as far as I can tell.\n\n",
  "votes": "11",
  "answers": 1,
  "views": "362",
  "tags": [
    "windows",
    "debuggers",
    "thread"
  ],
  "user": "Unix-dude",
  "time": "Oct 17, 2013 at 12:58",
  "comments": [],
  "answers_data": [
    {
      "content": "One of your problems is that you try to single step through Thread2 and you only refer to Thread1 in your code:\n\n```\ndbg.enumerate_threads()[0] # <--- Return handle to the first thread.\n\n```\nIn addition, the code the you posted is not reflective of the complete structure of your script, which makes it hard to judge wether you have other errors or not. You also try to set breakpoint within the sub-brach that disassembles your instructions, which does not make a lot of sense to me logically. Let me try to explain what I know, and lay it out in an organized manner. That way you might look back at your code, re-think it and correct it.\n\nLet's start with basic framework of debugging an application with pydbg:\n\nThis is how it could look like:\n\n```\nfrom pydbg import *\nfrom pydbg.defines import *\n\n# This is maximum number of instructions we will log\nMAX_INSTRUCTIONS = 20\n\n# Address of the breakpoint\nfunc_address = \"0x7C90D21A\"\n\n# Create debugger instance\ndbg = pydbg()\n\n# PID to attach to\npid = int(raw_input(\"Enter PID: \"))\n\n# Attach to the process with debugger instance created earlier.\n# Attaching the debugger will pause the process.\ndbg.attach(pid)\n\n# Let's set the breakpoint and handler as thread_step_setter,\n# which we will define a little later...\ndbg.bp_set(func_address, handler=thread_step_setter)\n\n# Let's set our \"personalized\" handler for Single Step Exception\n# It will get triggered if execution of a thread goes into single step mode.\ndbg.set_callback(EXCEPTION_SINGLE_STEP, single_step_handler)\n\n# Setup is done. Let's run it...\ndbg.run() \n\n```\nNow having the basic structure, let's define our personalized handlers for breakpoint and single stepping. The code snippet below defines our \"custom\" handlers. What will happen is when breakpoint hits we will iterate through threads and set them to single step mode. It will in turn trigger single step exception, which we will handle and disassemble MAX_INSTRUCTIONS amount of instructions:\n\n```\ndef thread_step_setter(dbg):\n    dbg.suspend_all_threads()\n    for thread_id in dbg.enumerate_threads():\n        print \"Single step for thread: 0x%08x\" % thread_id\n        h_thread = dbg.open_thread(thread_id)\n        dbg.single_step(True, h_thread)\n        dbg.close_handle(h_thread)\n\n    # Resume execution, which will pass control to step handler\n    dbg.resume_all_threads()\n\n    return DBG_CONTINUE\n\ndef single_step_handler(dbg):\n    global total_instructions\n    if instructions == MAX_INSTRUCTION:\n        dbg.single_step(False)\n        return DBG_CONTINUE\n    else:\n        # Disassemble the instruction\n        current_instruction = dbg.disasm(dbg.context,Eip)\n        print \"#%d\\t0x%08x : %s\" % (total_instructions, dbg.context.Eip, current_instruction)\n        total_instructions += 1\n        dbg.single_step(True)\n\n    return DBG_CONTINUE\n\n```\nDiscloser: I do not guarantee that the code above will work if copied and pasted. I typed it out and haven't tested it. However, if basic understanding is acquired, the small syntactical error could be easily fixed. I apologize in advanced if I have any. I don't currently have means or time to test it.\n\nI really hope it helps you out.\n\n",
      "votes": "4",
      "user": "PSS",
      "time": "Nov 5, 2013 at 5:05",
      "is_accepted": false,
      "comments": []
    }
  ]
}