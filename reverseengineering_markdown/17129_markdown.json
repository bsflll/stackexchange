{
  "title": "Finding the encryption key in a binary - IDA Pro and how an S-box might be represented in the binary",
  "link": "https://reverseengineering.stackexchange.com/questions/17129/finding-the-encryption-key-in-a-binary-ida-pro-and-how-an-s-box-might-be-repre",
  "content": "In practicing reading source code and analysing I've been looking at a program called aescrypt2_huawei which floats around the web and encrypts/decrypts the XML config file from Huawei routers like the HG8245 router installed by Internet Service Providers. The router is discussed on a number of blogs and the aescrypt2 can be downloaded and examined. I have also found the source code and put it on GitHub.\n\nSo far I've found:\n\nWhat I haven't found:\n\nRunning findcrypt in IDA Pro is also not turning up anything which leads me to believe my findcrypt plugin isn't working. However, I then start looking for the S-boxes sequence 0x63 0x7c which can easily be found in the source code and IDA pro doesn't find that either... I then dropped to hexdump and searched for 0x63 and it is not there. Given that I can see the S-box in the source and I just compiled the binary myself what am I doing wrong?\n\nShouldn't the forward S-box appear in the data segment more or less as-is?\n\nAnd now that I've found the key through the debugger in the .bss segment why isn't the string in the data segment?\n\n",
  "votes": "3",
  "answers": 1,
  "views": "9k",
  "tags": [
    "ida",
    "encryption"
  ],
  "user": "Cameron Lowell Palmer",
  "time": "Jan 6, 2018 at 16:07",
  "comments": [],
  "answers_data": [
    {
      "content": "As you probably saw in the source-code, the forward S-box is present several times and initialized at two different places. \n\nThe first time that the forward S-box (Fsb) is declared is at the top of aes.c:\n\n```\nuint32 FSb[256];\n\n```\nThis array is then dynamically generated by aes_gen_tables() like this:\n\n```\nFSb[0x00] = 0x63;\nRSb[0x63] = 0x00;\n\nfor( i = 1; i < 256; i++ )\n{\n    x = pow[255 - log[i]];\n\n    y = x;  y = ( y << 1 ) | ( y >> 7 );\n    x ^= y; y = ( y << 1 ) | ( y >> 7 );\n    x ^= y; y = ( y << 1 ) | ( y >> 7 );\n    x ^= y; y = ( y << 1 ) | ( y >> 7 );\n    x ^= y ^ 0x63;\n\n    FSb[i] = x;\n    RSb[x] = i;\n}\n\n```\nThe other initialization of Fsb[256] is easy to spot in the code file and is a static constant which is defined like this:\n\n```\n/* forward S-box */\n\nstatic const uint32 FSb[256] =\n{\n    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,\n    0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,\n    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,\n    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,\n\n         < ... Truncated for readability ... >\n\n    0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,\n    0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16\n};\n\n```\nYes, the author of the program describes it in the comments:\n\n```\n/* uncomment the following line to use pre-computed tables */\n/* otherwise the tables will be generated at the first run */\n\n/* #define FIXED_TABLES */\n\n#ifndef FIXED_TABLES\n\n/* forward S-box & tables */\n...\n...\n...\n\n#else\n\n/* forward S-box */\n\nstatic const uint32 FSb[256] =\n{\n    0x63, 0x7C, 0x77, ...\n...\n...\n\n```\nThus, if you want the array to be pre-determined, just uncomment #define FIXED_TABLES and you'll be fine.\n\nThe functions which is responsible to generate the forward S-box is aes_gen_tables( void ) which is called from aes_set_key( ... ). The latter is called from the aescrypt2.c. We can spot the call to aes_set_key() in IDA:\n\n\n\nFrom there, locating aes_gen_tables() is easy peasy:\n\n\n\nAs we said, the array is dynamically filled with values and we can view it using the debugger. Let's find the address of the array to be initialized and put a Hardware Breakpoint on Write on this address.\n\nHere's the part where the first item of the Fsb is initialized:\n\n\n\nThis is the equivalent part from the source code:\n\n```\n/* generate the forward and reverse S-boxes */\n\nFSb[0x00] = 0x63;\nRSb[0x63] = 0x00;\n\n```\nNow put the Hardware Breakpoint on 0x00412F00:\n\n\n\nNow we all set and we can start the debug session. Press the play button and start the program, then you'll have to input information to the console that has just popped up. After done, pressing Enter in the console will trigger our HW breakpoint. This is where Fsb[0] is set to 0x63. Press the play button and the breakpoint again will be triggered, this time it's at the end of the generation loop and our array will be filled:\n\n \n\nThere we go, now we found our forward S-box after it was dynamically generated by the program.\n\n",
      "votes": "8",
      "user": "Megabeets",
      "time": "Jan 6, 2018 at 20:30",
      "is_accepted": true,
      "comments": [
        {
          "user": "Cameron Lowell Palmer",
          "text": "I was wondering how to set a hardware breakpoint like that although I didn't know what it was called. Also, I was trying not to cheat too much by looking at the source code so I didn't notice that #define either. Very cool!",
          "time": null
        }
      ]
    }
  ]
}