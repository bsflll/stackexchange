{
  "title": "Force gcc to use more complex instructions",
  "link": "https://reverseengineering.stackexchange.com/questions/24980/force-gcc-to-use-more-complex-instructions",
  "content": "I am reverse engineering a piece of assembly. I am trying to write the equivalent code in C, however, when I compile my code, gcc prefers to use simple instructions instead of the complex ones that are used in my assembly. I was wondering if I can suggest or force gcc to use more complex instructions.\n\nEDIT: I have already tried using the -O options but they will change lots of other variables and therefore, don't look like a good solution.\n\nYou can find examples here:\n\n```\n// original assembly\nlea     rdx, [rax+0x20]\n\n// generated by gcc\nadd     rax, 0x20\nmov     rdx, rax\n\n// C code\n0x20+((uint8_t *)lParm1)  // long lParm1\n\n```\n```\n// original assembly\ntest    eax, eax\n\n// generated by gcc\nmov     [rbp-0x10], eax\ncmp     [rbp-0x10], 0x0\n\n// C code\nif (!iVar)  // int iVar\n\n```\n```\n// original assembly\nmov     eax, [rax+0x40]\n\n// generated by gcc\nadd     rax, 0x40\nmov     eax, [rax]\n\n// C code\n(float)*(int *)(lParm1 + 0x40)\n\n```\n",
  "votes": "0",
  "answers": 0,
  "views": "204",
  "tags": [
    "assembly",
    "decompilation",
    "gcc"
  ],
  "user": "Bat",
  "time": "May 11, 2020 at 14:07",
  "comments": [
    {
      "user": "sbluff",
      "text": "can you please share the c code that generates that set of instructions?",
      "time": null
    },
    {
      "user": "Robert",
      "text": "Often the original code smaller (is only one command vs. two). Therefore you may try to enable optimization for code size via -Os parameter.",
      "time": null
    },
    {
      "user": "Bat",
      "text": "I have already tried that. The thing is that it more or less achieves what I want but then changes lots of other variables. Therefore, doesn't seem like a good option",
      "time": null
    },
    {
      "user": "Robert",
      "text": "Please edit your question and include in detail what you already tried and why it  is not a suitable solution.",
      "time": null
    },
    {
      "user": "0xC0000022L",
      "text": "Actually in order to achieve what you want, you need to have a toolchain (including not just compiler frontend and backend, but also assembler and linker - linker if you use LTO or similar) which can produce the desired code. And then, depending on those (and the specs file - try gcc -dumpspecs) you can use -mtune, -mcpu and -march as well as some more architecture-specific options to optimize for a CPU model and so on. However, your question should be clarified further ... also, you may want to look at RetDec and LLVM IR, perhaps?!",
      "time": null
    }
  ],
  "answers_data": []
}