{
  "title": "How can I objdump the assembler code of dynamically linked functions in a dynamically linked executable?",
  "link": "https://reverseengineering.stackexchange.com/questions/22614/how-can-i-objdump-the-assembler-code-of-dynamically-linked-functions-in-a-dynami",
  "content": "Compiling a minimal C++ program:\ng++ -g -Wall -Wextra -std=c++17 -o prog main.cpp\n\n```\nint main()\n{\n}\n\n```\nPerforming an objdump -C -D prog of all sections I am given the following output:\n\n```\nprog:     file format elf64-x86-64\n\n\nDisassembly of section .interp:\n\n0000000000400200 <.interp>:\n  400200:   2f                      (bad)  \n  400201:   6c                      insb   (%dx),%es:(%rdi)\n  400202:   69 62 36 34 2f 6c 64    imul   $0x646c2f34,0x36(%rdx),%esp\n  400209:   2d 6c 69 6e 75          sub    $0x756e696c,%eax\n  40020e:   78 2d                   js     40023d <_init-0x193>\n  400210:   78 38                   js     40024a <_init-0x186>\n  400212:   36 2d 36 34 2e 73       ss sub $0x732e3436,%eax\n  400218:   6f                      outsl  %ds:(%rsi),(%dx)\n  400219:   2e 32 00                xor    %cs:(%rax),%al\n\nDisassembly of section .note.ABI-tag:\n\n000000000040021c <.note.ABI-tag>:\n  40021c:   04 00                   add    $0x0,%al\n  40021e:   00 00                   add    %al,(%rax)\n  400220:   10 00                   adc    %al,(%rax)\n  400222:   00 00                   add    %al,(%rax)\n  400224:   01 00                   add    %eax,(%rax)\n  400226:   00 00                   add    %al,(%rax)\n  400228:   47                      rex.RXB\n  400229:   4e 55                   rex.WRX push %rbp\n  40022b:   00 00                   add    %al,(%rax)\n  40022d:   00 00                   add    %al,(%rax)\n  40022f:   00 02                   add    %al,(%rdx)\n  400231:   00 00                   add    %al,(%rax)\n  400233:   00 06                   add    %al,(%rsi)\n  400235:   00 00                   add    %al,(%rax)\n  400237:   00 20                   add    %ah,(%rax)\n  400239:   00 00                   add    %al,(%rax)\n    ...\n\nDisassembly of section .hash:\n\n0000000000400240 <.hash>:\n  400240:   03 00                   add    (%rax),%eax\n  400242:   00 00                   add    %al,(%rax)\n  400244:   05 00 00 00 01          add    $0x1000000,%eax\n  400249:   00 00                   add    %al,(%rax)\n  40024b:   00 04 00                add    %al,(%rax,%rax,1)\n    ...\n  40025e:   00 00                   add    %al,(%rax)\n  400260:   02 00                   add    (%rax),%al\n  400262:   00 00                   add    %al,(%rax)\n  400264:   03 00                   add    (%rax),%eax\n    ...\n\nDisassembly of section .dynsym:\n\n0000000000400268 <.dynsym>:\n    ...\n  400280:   10 00                   adc    %al,(%rax)\n  400282:   00 00                   add    %al,(%rax)\n  400284:   20 00                   and    %al,(%rax)\n    ...\n  400296:   00 00                   add    %al,(%rax)\n  400298:   77 00                   ja     40029a <_init-0x136>\n  40029a:   00 00                   add    %al,(%rax)\n  40029c:   12 00                   adc    (%rax),%al\n    ...\n  4002ae:   00 00                   add    %al,(%rax)\n  4002b0:   1f                      (bad)  \n  4002b1:   00 00                   add    %al,(%rax)\n  4002b3:   00 20                   add    %ah,(%rax)\n    ...\n  4002c5:   00 00                   add    %al,(%rax)\n  4002c7:   00 3b                   add    %bh,(%rbx)\n  4002c9:   00 00                   add    %al,(%rax)\n  4002cb:   00 20                   add    %ah,(%rax)\n    ...\n\nDisassembly of section .dynstr:\n\n00000000004002e0 <.dynstr>:\n  4002e0:   00 6c 69 62             add    %ch,0x62(%rcx,%rbp,2)\n  4002e4:   73 74                   jae    40035a <_init-0x76>\n  4002e6:   64 63 2b                movslq %fs:(%rbx),%ebp\n  4002e9:   2b 2e                   sub    (%rsi),%ebp\n  4002eb:   73 6f                   jae    40035c <_init-0x74>\n  4002ed:   2e 36 00 5f 5f          cs add %bl,%ss:0x5f(%rdi)\n  4002f2:   67 6d                   insl   (%dx),%es:(%edi)\n  4002f4:   6f                      outsl  %ds:(%rsi),(%dx)\n  4002f5:   6e                      outsb  %ds:(%rsi),(%dx)\n  4002f6:   5f                      pop    %rdi\n  4002f7:   73 74                   jae    40036d <_init-0x63>\n  4002f9:   61                      (bad)  \n  4002fa:   72 74                   jb     400370 <_init-0x60>\n  4002fc:   5f                      pop    %rdi\n  4002fd:   5f                      pop    %rdi\n  4002fe:   00 5f 49                add    %bl,0x49(%rdi)\n  400301:   54                      push   %rsp\n  400302:   4d 5f                   rex.WRB pop %r15\n  400304:   64 65 72 65             fs gs jb 40036d <_init-0x63>\n  400308:   67 69 73 74 65 72 54    imul   $0x4d547265,0x74(%ebx),%esi\n  40030f:   4d \n  400310:   43 6c                   rex.XB insb (%dx),%es:(%rdi)\n  400312:   6f                      outsl  %ds:(%rsi),(%dx)\n  400313:   6e                      outsb  %ds:(%rsi),(%dx)\n  400314:   65 54                   gs push %rsp\n  400316:   61                      (bad)  \n  400317:   62                      (bad)  \n  400318:   6c                      insb   (%dx),%es:(%rdi)\n  400319:   65 00 5f 49             add    %bl,%gs:0x49(%rdi)\n  40031d:   54                      push   %rsp\n  40031e:   4d 5f                   rex.WRB pop %r15\n  400320:   72 65                   jb     400387 <_init-0x49>\n  400322:   67 69 73 74 65 72 54    imul   $0x4d547265,0x74(%ebx),%esi\n  400329:   4d \n  40032a:   43 6c                   rex.XB insb (%dx),%es:(%rdi)\n  40032c:   6f                      outsl  %ds:(%rsi),(%dx)\n  40032d:   6e                      outsb  %ds:(%rsi),(%dx)\n  40032e:   65 54                   gs push %rsp\n  400330:   61                      (bad)  \n  400331:   62                      (bad)  \n  400332:   6c                      insb   (%dx),%es:(%rdi)\n  400333:   65 00 6c 69 62          add    %ch,%gs:0x62(%rcx,%rbp,2)\n  400338:   6d                      insl   (%dx),%es:(%rdi)\n  400339:   2e 73 6f                jae,pn 4003ab <_init-0x25>\n  40033c:   2e 36 00 6c 69 62       cs add %ch,%ss:0x62(%rcx,%rbp,2)\n  400342:   67 63 63 5f             movslq 0x5f(%ebx),%esp\n  400346:   73 2e                   jae    400376 <_init-0x5a>\n  400348:   73 6f                   jae    4003b9 <_init-0x17>\n  40034a:   2e 31 00                xor    %eax,%cs:(%rax)\n  40034d:   6c                      insb   (%dx),%es:(%rdi)\n  40034e:   69 62 63 2e 73 6f 2e    imul   $0x2e6f732e,0x63(%rdx),%esp\n  400355:   36 00 5f 5f             add    %bl,%ss:0x5f(%rdi)\n  400359:   6c                      insb   (%dx),%es:(%rdi)\n  40035a:   69 62 63 5f 73 74 61    imul   $0x6174735f,0x63(%rdx),%esp\n  400361:   72 74                   jb     4003d7 <_init+0x7>\n  400363:   5f                      pop    %rdi\n  400364:   6d                      insl   (%dx),%es:(%rdi)\n  400365:   61                      (bad)  \n  400366:   69 6e 00 47 4c 49 42    imul   $0x42494c47,0x0(%rsi),%ebp\n  40036d:   43 5f                   rex.XB pop %r15\n  40036f:   32 2e                   xor    (%rsi),%ch\n  400371:   32 2e                   xor    (%rsi),%ch\n  400373:   35                      .byte 0x35\n    ...\n\nDisassembly of section .gnu.version:\n\n0000000000400376 <.gnu.version>:\n  400376:   00 00                   add    %al,(%rax)\n  400378:   00 00                   add    %al,(%rax)\n  40037a:   02 00                   add    (%rax),%al\n  40037c:   00 00                   add    %al,(%rax)\n    ...\n\nDisassembly of section .gnu.version_r:\n\n0000000000400380 <.gnu.version_r>:\n  400380:   01 00                   add    %eax,(%rax)\n  400382:   01 00                   add    %eax,(%rax)\n  400384:   6d                      insl   (%dx),%es:(%rdi)\n  400385:   00 00                   add    %al,(%rax)\n  400387:   00 10                   add    %dl,(%rax)\n  400389:   00 00                   add    %al,(%rax)\n  40038b:   00 00                   add    %al,(%rax)\n  40038d:   00 00                   add    %al,(%rax)\n  40038f:   00 75 1a                add    %dh,0x1a(%rbp)\n  400392:   69 09 00 00 02 00       imul   $0x20000,(%rcx),%ecx\n  400398:   89 00                   mov    %eax,(%rax)\n  40039a:   00 00                   add    %al,(%rax)\n  40039c:   00 00                   add    %al,(%rax)\n    ...\n\nDisassembly of section .rela.dyn:\n\n00000000004003a0 <.rela.dyn>:\n  4003a0:   d0 08                   rorb   (%rax)\n  4003a2:   60                      (bad)  \n  4003a3:   00 00                   add    %al,(%rax)\n  4003a5:   00 00                   add    %al,(%rax)\n  4003a7:   00 06                   add    %al,(%rsi)\n  4003a9:   00 00                   add    %al,(%rax)\n  4003ab:   00 01                   add    %al,(%rcx)\n    ...\n\nDisassembly of section .rela.plt:\n\n00000000004003b8 <.rela.plt>:\n  4003b8:   f0 08 60 00             lock or %ah,0x0(%rax)\n  4003bc:   00 00                   add    %al,(%rax)\n  4003be:   00 00                   add    %al,(%rax)\n  4003c0:   07                      (bad)  \n  4003c1:   00 00                   add    %al,(%rax)\n  4003c3:   00 02                   add    %al,(%rdx)\n    ...\n\nDisassembly of section .init:\n\n00000000004003d0 <_init>:\n  4003d0:   48 83 ec 08             sub    $0x8,%rsp\n  4003d4:   48 8b 05 f5 04 20 00    mov    0x2004f5(%rip),%rax        # 6008d0 <_DYNAMIC+0x200>\n  4003db:   48 85 c0                test   %rax,%rax\n  4003de:   74 05                   je     4003e5 <_init+0x15>\n  4003e0:   e8 2b 00 00 00          callq  400410 <__libc_start_main@plt+0x10>\n  4003e5:   48 83 c4 08             add    $0x8,%rsp\n  4003e9:   c3                      retq   \n\nDisassembly of section .plt:\n\n00000000004003f0 <__libc_start_main@plt-0x10>:\n  4003f0:   ff 35 ea 04 20 00       pushq  0x2004ea(%rip)        # 6008e0 <_GLOBAL_OFFSET_TABLE_+0x8>\n  4003f6:   ff 25 ec 04 20 00       jmpq   *0x2004ec(%rip)        # 6008e8 <_GLOBAL_OFFSET_TABLE_+0x10>\n  4003fc:   0f 1f 40 00             nopl   0x0(%rax)\n\n0000000000400400 <__libc_start_main@plt>:\n  400400:   ff 25 ea 04 20 00       jmpq   *0x2004ea(%rip)        # 6008f0 <_GLOBAL_OFFSET_TABLE_+0x18>\n  400406:   68 00 00 00 00          pushq  $0x0\n  40040b:   e9 e0 ff ff ff          jmpq   4003f0 <_init+0x20>\n\nDisassembly of section .plt.got:\n\n0000000000400410 <.plt.got>:\n  400410:   ff 25 ba 04 20 00       jmpq   *0x2004ba(%rip)        # 6008d0 <_DYNAMIC+0x200>\n  400416:   66 90                   xchg   %ax,%ax\n\nDisassembly of section .text:\n\n0000000000400420 <_start>:\n  400420:   31 ed                   xor    %ebp,%ebp\n  400422:   49 89 d1                mov    %rdx,%r9\n  400425:   5e                      pop    %rsi\n  400426:   48 89 e2                mov    %rsp,%rdx\n  400429:   48 83 e4 f0             and    $0xfffffffffffffff0,%rsp\n  40042d:   50                      push   %rax\n  40042e:   54                      push   %rsp\n  40042f:   49 c7 c0 80 05 40 00    mov    $0x400580,%r8\n  400436:   48 c7 c1 10 05 40 00    mov    $0x400510,%rcx\n  40043d:   48 c7 c7 f7 04 40 00    mov    $0x4004f7,%rdi\n  400444:   e8 b7 ff ff ff          callq  400400 <__libc_start_main@plt>\n  400449:   f4                      hlt    \n  40044a:   66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)\n\n0000000000400450 <deregister_tm_clones>:\n  400450:   55                      push   %rbp\n  400451:   b8 08 09 60 00          mov    $0x600908,%eax\n  400456:   48 3d 08 09 60 00       cmp    $0x600908,%rax\n  40045c:   48 89 e5                mov    %rsp,%rbp\n  40045f:   74 17                   je     400478 <deregister_tm_clones+0x28>\n  400461:   b8 00 00 00 00          mov    $0x0,%eax\n  400466:   48 85 c0                test   %rax,%rax\n  400469:   74 0d                   je     400478 <deregister_tm_clones+0x28>\n  40046b:   5d                      pop    %rbp\n  40046c:   bf 08 09 60 00          mov    $0x600908,%edi\n  400471:   ff e0                   jmpq   *%rax\n  400473:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)\n  400478:   5d                      pop    %rbp\n  400479:   c3                      retq   \n  40047a:   66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)\n\n0000000000400480 <register_tm_clones>:\n  400480:   be 08 09 60 00          mov    $0x600908,%esi\n  400485:   55                      push   %rbp\n  400486:   48 81 ee 08 09 60 00    sub    $0x600908,%rsi\n  40048d:   48 89 e5                mov    %rsp,%rbp\n  400490:   48 c1 fe 03             sar    $0x3,%rsi\n  400494:   48 89 f0                mov    %rsi,%rax\n  400497:   48 c1 e8 3f             shr    $0x3f,%rax\n  40049b:   48 01 c6                add    %rax,%rsi\n  40049e:   48 d1 fe                sar    %rsi\n  4004a1:   74 15                   je     4004b8 <register_tm_clones+0x38>\n  4004a3:   b8 00 00 00 00          mov    $0x0,%eax\n  4004a8:   48 85 c0                test   %rax,%rax\n  4004ab:   74 0b                   je     4004b8 <register_tm_clones+0x38>\n  4004ad:   5d                      pop    %rbp\n  4004ae:   bf 08 09 60 00          mov    $0x600908,%edi\n  4004b3:   ff e0                   jmpq   *%rax\n  4004b5:   0f 1f 00                nopl   (%rax)\n  4004b8:   5d                      pop    %rbp\n  4004b9:   c3                      retq   \n  4004ba:   66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)\n\n00000000004004c0 <__do_global_dtors_aux>:\n  4004c0:   80 3d 41 04 20 00 00    cmpb   $0x0,0x200441(%rip)        # 600908 <__TMC_END__>\n  4004c7:   75 17                   jne    4004e0 <__do_global_dtors_aux+0x20>\n  4004c9:   55                      push   %rbp\n  4004ca:   48 89 e5                mov    %rsp,%rbp\n  4004cd:   e8 7e ff ff ff          callq  400450 <deregister_tm_clones>\n  4004d2:   c6 05 2f 04 20 00 01    movb   $0x1,0x20042f(%rip)        # 600908 <__TMC_END__>\n  4004d9:   5d                      pop    %rbp\n  4004da:   c3                      retq   \n  4004db:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)\n  4004e0:   f3 c3                   repz retq \n  4004e2:   0f 1f 40 00             nopl   0x0(%rax)\n  4004e6:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)\n  4004ed:   00 00 00 \n\n00000000004004f0 <frame_dummy>:\n  4004f0:   55                      push   %rbp\n  4004f1:   48 89 e5                mov    %rsp,%rbp\n  4004f4:   5d                      pop    %rbp\n  4004f5:   eb 89                   jmp    400480 <register_tm_clones>\n\n00000000004004f7 <main>:\n  4004f7:   55                      push   %rbp\n  4004f8:   48 89 e5                mov    %rsp,%rbp\n  4004fb:   b8 00 00 00 00          mov    $0x0,%eax\n  400500:   5d                      pop    %rbp\n  400501:   c3                      retq   \n  400502:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)\n  400509:   00 00 00 \n  40050c:   0f 1f 40 00             nopl   0x0(%rax)\n\n    ...\n\n  (Due to limits of the body in SO questions I'm cutting it off here)\n\n```\nBut as I'm single stepping through the debugger, I eventually end up in the assembler code of __libc_start_main (whose code is not seen in the objdump of the program):\n\n```\n0x00007ffffe790740 <__libc_start_main+0>:   push   %r14\n0x00007ffffe790742 <__libc_start_main+2>:   push   %r13\n0x00007ffffe790744 <__libc_start_main+4>:   push   %r12\n0x00007ffffe790746 <__libc_start_main+6>:   push   %rbp\n0x00007ffffe790747 <__libc_start_main+7>:   mov    %rcx,%rbp\n0x00007ffffe79074a <__libc_start_main+10>:  push   %rbx\n0x00007ffffe79074b <__libc_start_main+11>:  sub    $0x90,%rsp\n0x00007ffffe790752 <__libc_start_main+18>:  mov    0x3a37ef(%rip),%rax        # 0x7ffffeb33f48\n0x00007ffffe790759 <__libc_start_main+25>:  mov    %rdi,0x18(%rsp)\n0x00007ffffe79075e <__libc_start_main+30>:  mov    %esi,0x14(%rsp)\n0x00007ffffe790762 <__libc_start_main+34>:  mov    %rdx,0x8(%rsp)\n0x00007ffffe790767 <__libc_start_main+39>:  test   %rax,%rax\n0x00007ffffe79076a <__libc_start_main+42>:  je     0x7ffffe790837 <__libc_start_main+247>\n0x00007ffffe790770 <__libc_start_main+48>:  mov    (%rax),%eax\n0x00007ffffe790772 <__libc_start_main+50>:  xor    %edx,%edx\n0x00007ffffe790774 <__libc_start_main+52>:  test   %eax,%eax\n0x00007ffffe790776 <__libc_start_main+54>:  sete   %dl\n0x00007ffffe790779 <__libc_start_main+57>:  lea    0x3a3900(%rip),%rax        # 0x7ffffeb34080 <__libc_multiple_libcs>\n0x00007ffffe790780 <__libc_start_main+64>:  test   %r9,%r9\n0x00007ffffe790783 <__libc_start_main+67>:  mov    %edx,(%rax)\n0x00007ffffe790785 <__libc_start_main+69>:  je     0x7ffffe790793 <__libc_start_main+83>\n0x00007ffffe790787 <__libc_start_main+71>:  xor    %edx,%edx\n0x00007ffffe790789 <__libc_start_main+73>:  xor    %esi,%esi\n0x00007ffffe79078b <__libc_start_main+75>:  mov    %r9,%rdi\n0x00007ffffe79078e <__libc_start_main+78>:  callq  0x7ffffe7aa280 <__GI___cxa_atexit>\n0x00007ffffe790793 <__libc_start_main+83>:  mov    0x3a36d6(%rip),%rdx        # 0x7ffffeb33e70\n0x00007ffffe79079a <__libc_start_main+90>:  mov    (%rdx),%ebx\n0x00007ffffe79079c <__libc_start_main+92>:  and    $0x2,%ebx\n0x00007ffffe79079f <__libc_start_main+95>:  jne    0x7ffffe790876 <__libc_start_main+310>\n0x00007ffffe7907a5 <__libc_start_main+101>: test   %rbp,%rbp\n0x00007ffffe7907a8 <__libc_start_main+104>: je     0x7ffffe7907bf <__libc_start_main+127>\n0x00007ffffe7907aa <__libc_start_main+106>: mov    0x3a3707(%rip),%rax        # 0x7ffffeb33eb8\n0x00007ffffe7907b1 <__libc_start_main+113>: mov    0x8(%rsp),%rsi\n0x00007ffffe7907b6 <__libc_start_main+118>: mov    0x14(%rsp),%edi\n0x00007ffffe7907ba <__libc_start_main+122>: mov    (%rax),%rdx\n0x00007ffffe7907bd <__libc_start_main+125>: callq  *%rbp\n0x00007ffffe7907bf <__libc_start_main+127>: mov    0x3a36aa(%rip),%rax        # 0x7ffffeb33e70\n0x00007ffffe7907c6 <__libc_start_main+134>: mov    0x170(%rax),%r14d\n0x00007ffffe7907cd <__libc_start_main+141>: test   %r14d,%r14d\n0x00007ffffe7907d0 <__libc_start_main+144>: jne    0x7ffffe7908cb <__libc_start_main+395>\n0x00007ffffe7907d6 <__libc_start_main+150>: test   %ebx,%ebx\n0x00007ffffe7907d8 <__libc_start_main+152>: jne    0x7ffffe7908a8 <__libc_start_main+360>\n0x00007ffffe7907de <__libc_start_main+158>: lea    0x20(%rsp),%rdi\n0x00007ffffe7907e3 <__libc_start_main+163>: callq  0x7ffffe7a5250 <_setjmp>\n0x00007ffffe7907e8 <__libc_start_main+168>: test   %eax,%eax\n0x00007ffffe7907ea <__libc_start_main+170>: jne    0x7ffffe79083e <__libc_start_main+254>\n0x00007ffffe7907ec <__libc_start_main+172>: mov    %fs:0x300,%rax\n0x00007ffffe7907f5 <__libc_start_main+181>: mov    %rax,0x68(%rsp)\n0x00007ffffe7907fa <__libc_start_main+186>: mov    %fs:0x2f8,%rax\n0x00007ffffe790803 <__libc_start_main+195>: mov    %rax,0x70(%rsp)\n0x00007ffffe790808 <__libc_start_main+200>: lea    0x20(%rsp),%rax\n0x00007ffffe79080d <__libc_start_main+205>: mov    %rax,%fs:0x300\n0x00007ffffe790816 <__libc_start_main+214>: mov    0x3a369b(%rip),%rax        # 0x7ffffeb33eb8\n0x00007ffffe79081d <__libc_start_main+221>: mov    0x8(%rsp),%rsi\n0x00007ffffe790822 <__libc_start_main+226>: mov    0x14(%rsp),%edi\n0x00007ffffe790826 <__libc_start_main+230>: mov    (%rax),%rdx\n0x00007ffffe790829 <__libc_start_main+233>: mov    0x18(%rsp),%rax\n0x00007ffffe79082e <__libc_start_main+238>: callq  *%rax\n0x00007ffffe790830 <__libc_start_main+240>: mov    %eax,%edi\n0x00007ffffe790832 <__libc_start_main+242>: callq  0x7ffffe7aa030 <__GI_exit>\n0x00007ffffe790837 <__libc_start_main+247>: xor    %edx,%edx\n0x00007ffffe790839 <__libc_start_main+249>: jmpq   0x7ffffe790779 <__libc_start_main+57>\n0x00007ffffe79083e <__libc_start_main+254>: mov    0x3a8ecb(%rip),%rax        # 0x7ffffeb39710 <__libc_pthread_functions+400>\n0x00007ffffe790845 <__libc_start_main+261>: ror    $0x11,%rax\n0x00007ffffe790849 <__libc_start_main+265>: xor    %fs:0x30,%rax\n0x00007ffffe790852 <__libc_start_main+274>: callq  *%rax\n0x00007ffffe790854 <__libc_start_main+276>: mov    0x3a8ea5(%rip),%rax        # 0x7ffffeb39700 <__libc_pthread_functions+384>\n0x00007ffffe79085b <__libc_start_main+283>: ror    $0x11,%rax\n0x00007ffffe79085f <__libc_start_main+287>: xor    %fs:0x30,%rax\n0x00007ffffe790868 <__libc_start_main+296>: lock decl (%rax)\n0x00007ffffe79086b <__libc_start_main+299>: sete   %dl\n0x00007ffffe79086e <__libc_start_main+302>: test   %dl,%dl\n0x00007ffffe790870 <__libc_start_main+304>: je     0x7ffffe790892 <__libc_start_main+338>\n0x00007ffffe790872 <__libc_start_main+306>: xor    %eax,%eax\n0x00007ffffe790874 <__libc_start_main+308>: jmp    0x7ffffe790830 <__libc_start_main+240>\n0x00007ffffe790876 <__libc_start_main+310>: mov    0x8(%rsp),%rax\n0x00007ffffe79087b <__libc_start_main+315>: lea    0x16bdb3(%rip),%rdi        # 0x7ffffe8fc635\n0x00007ffffe790882 <__libc_start_main+322>: mov    (%rax),%rsi\n0x00007ffffe790885 <__libc_start_main+325>: xor    %eax,%eax\n0x00007ffffe790887 <__libc_start_main+327>: callq  *0x118(%rdx)\n0x00007ffffe79088d <__libc_start_main+333>: jmpq   0x7ffffe7907a5 <__libc_start_main+101>\n0x00007ffffe790892 <__libc_start_main+338>: mov    $0x3c,%edx\n0x00007ffffe790897 <__libc_start_main+343>: nopw   0x0(%rax,%rax,1)\n0x00007ffffe7908a0 <__libc_start_main+352>: xor    %edi,%edi\n0x00007ffffe7908a2 <__libc_start_main+354>: mov    %edx,%eax\n0x00007ffffe7908a4 <__libc_start_main+356>: syscall \n0x00007ffffe7908a6 <__libc_start_main+358>: jmp    0x7ffffe7908a0 <__libc_start_main+352>\n0x00007ffffe7908a8 <__libc_start_main+360>: mov    0x8(%rsp),%rax\n0x00007ffffe7908ad <__libc_start_main+365>: mov    0x3a35bc(%rip),%rdx        # 0x7ffffeb33e70\n0x00007ffffe7908b4 <__libc_start_main+372>: lea    0x16bd94(%rip),%rdi        # 0x7ffffe8fc64f\n0x00007ffffe7908bb <__libc_start_main+379>: mov    (%rax),%rsi\n0x00007ffffe7908be <__libc_start_main+382>: xor    %eax,%eax\n0x00007ffffe7908c0 <__libc_start_main+384>: callq  *0x118(%rdx)\n0x00007ffffe7908c6 <__libc_start_main+390>: jmpq   0x7ffffe7907de <__libc_start_main+158>\n0x00007ffffe7908cb <__libc_start_main+395>: mov    0x168(%rax),%r13\n0x00007ffffe7908d2 <__libc_start_main+402>: mov    0x3a3527(%rip),%rax        # 0x7ffffeb33e00\n0x00007ffffe7908d9 <__libc_start_main+409>: xor    %r12d,%r12d\n0x00007ffffe7908dc <__libc_start_main+412>: mov    (%rax),%rbp\n0x00007ffffe7908df <__libc_start_main+415>: mov    0x18(%r13),%rax\n0x00007ffffe7908e3 <__libc_start_main+419>: test   %rax,%rax\n0x00007ffffe7908e6 <__libc_start_main+422>: je     0x7ffffe7908f8 <__libc_start_main+440>\n0x00007ffffe7908e8 <__libc_start_main+424>: mov    %r12d,%edi\n0x00007ffffe7908eb <__libc_start_main+427>: add    $0x47,%rdi\n0x00007ffffe7908ef <__libc_start_main+431>: shl    $0x4,%rdi\n0x00007ffffe7908f3 <__libc_start_main+435>: add    %rbp,%rdi\n0x00007ffffe7908f6 <__libc_start_main+438>: callq  *%rax\n0x00007ffffe7908f8 <__libc_start_main+440>: add    $0x1,%r12d\n0x00007ffffe7908fc <__libc_start_main+444>: mov    0x40(%r13),%r13\n0x00007ffffe790900 <__libc_start_main+448>: cmp    %r12d,%r14d\n0x00007ffffe790903 <__libc_start_main+451>: jne    0x7ffffe7908df <__libc_start_main+415>\n0x00007ffffe790905 <__libc_start_main+453>: jmpq   0x7ffffe7907d6 <__libc_start_main+150>\n\n```\nAnd then eventually the assembler code of __GI_exit (again, whose code is not seen in the objdump of the program):\n\n```\n0x00007ffffe7aa030 <__GI_exit+0>:  lea    0x38a5c1(%rip),%rsi        # 0x7ffffeb345f8 <__exit_funcs>\n0x00007ffffe7aa037 <__GI_exit+7>:  sub    $0x8,%rsp\n0x00007ffffe7aa03b <__GI_exit+11>: mov    $0x1,%edx\n0x00007ffffe7aa040 <__GI_exit+16>: callq  0x7ffffe7a9f10 <__run_exit_handlers>\n\n```\nAnd then a few more, and so on, until the program exits.\n\nSo, my question is, how can I view this extra assembler code when objdumping my dynamically linked executable?\n\nI tried statically compiling it as well (the file was massive when I objdumped it), and there wasn't a 1-to-1 relationship in the dynamically linked code of the dynamically linked executable and the (formerly) dynamically linked code of the statically linked executable.\n\nI'm assuming there are some optimizations going on that contort the (formerly) dynamically linked code in the statically linked executable for the better.\n\nBut my mission is to objdump the dynamically linked code in the dynamically linked executable; not to objdump the (formerly) dynamically linked code in the statically linked executable.\n\n",
  "votes": "2",
  "answers": 1,
  "views": "708",
  "tags": [
    "disassembly",
    "assembly",
    "objdump"
  ],
  "user": "John DeBord",
  "time": "Nov 24, 2019 at 23:47",
  "comments": [
    {
      "user": "John DeBord",
      "text": "Am I using the terminology in its proper context? Or which is preferred among the three: assembler code, functions, or sections?",
      "time": null
    },
    {
      "user": "Chris Stratton",
      "text": "Simply run objdump on the relevant dynamic libraries.  There are probably elegant ways to find what you want, but the forward text search in most pagers will do it, too.  Some of the code ultimately involved would live in the dynamic linker itself.  Of course it might be more useful to track down the source for all of these, in most cases it is published.",
      "time": null
    },
    {
      "user": "John DeBord",
      "text": "@ChrisStratton \"...forward text search in most pagers...\" What is a forward text search in a pager? \"Some of the code ultimately involved would live in the dynamic linker itself.\" Code can live in the dynamic linker? \"Of course it might be more useful to track down the source for all of these, in most cases it is published.\" How would I track down the sources for this assembler code? And published where?",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "The point of dynamic linking a library is not including the library in the object, so the sections you want to disassemble just aren't there.\nYou could even replace the dynamic library (the .so object) with something else, which could result in different code being run by your same main program.\n\nSo you first need to identify which dynamic objects are referenced by your program. For this, you can used ldd. Example:\n\n```\n$ cat x.c\nint main(void) {\n}\n$ cc -o x x.c\n$ ldd x\nlinux-vdso.so.1 (0x00007fff553e8000)\nlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff12b0fa000)\n/lib64/ld-linux-x86-64.so.2 (0x00007ff12b6ed000)\n$\n\n```\nNow you can objdump the files referenced here. Note you won't find the vdso anywhere; it resides in the kernel and is automatically provided for every program that runs. See man 7 vdso for more information.\n\nTo see the source code, just google for glibc source; you'll find the source of the C library itself (libc.so.6) and the dynamic loader (ld-linux-x86-64) there.\n\n",
      "votes": "3",
      "user": "Guntram Blohm",
      "time": "Nov 25, 2019 at 8:43",
      "is_accepted": true,
      "comments": []
    }
  ]
}