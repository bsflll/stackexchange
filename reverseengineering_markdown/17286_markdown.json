{
  "title": "how to find the encryption algorithm?",
  "link": "https://reverseengineering.stackexchange.com/questions/17286/how-to-find-the-encryption-algorithm",
  "content": "I have an arm complied so file and find the decrypt function which pseudocode generated by IDA Pro is like this:\n\n```\nchar __cdecl EncodeUtil::getDecryptStr()\n{\n  int *v0; // r0\n  int *v1; // r7\n  unsigned int i; // r5\n  char v3; // r6\n  int v5; // [sp+4h] [bp-1Ch]\n\n  v1 = v0;\n  HttpUtility::URLDecode(&v5);\n  for ( i = 0; i < *(_DWORD *)(v5 - 12); ++i )\n  {\n    sub_3B25D0(&v5);\n    v3 = byte_41A7DD[i & 7]; //byte_41A7DD     DCB 0xC, 0x17, 0xDE, 0x22, 0x2C, 0xC9, 0x37, 0x43\n    *(_BYTE *)(v5 + i) ^= v3;\n    sub_3B25D0(&v5);\n    if ( !*(_BYTE *)(v5 + i) )\n    {\n      sub_3B25D0(&v5);\n      *(_BYTE *)(v5 + i) ^= v3;\n    }\n  }\n  sub_3B2E20(v1, &v5);\n  sub_3B1CCC(&v5);\n  return (char)v1;\n}\n\n```\nand the sub_3B25D0 function is:\n\n```\nint *__fastcall sub_3B25D0(int *result)\n{\n  if ( *(_DWORD *)(*result - 4) >= 0 )\n    result = sub_3B2580(result);\n  return result;\n}\n\n```\nand the sub_3B2580 function is:\n\n```\nint *__fastcall sub_3B2580(int *result)\n{\n  int v1; // r3\n  int *v2; // r4\n\n  v1 = *result;\n  v2 = result;\n  if ( (int *)(*result - 12) != &dword_4C60C0 )\n  {\n    if ( *(_DWORD *)(v1 - 4) > 0 )\n    {\n      result = sub_3B1D0C(result, 0, 0, 0);\n      v1 = *v2;\n    }\n    *(_DWORD *)(v1 - 4) = -1;\n  }\n  return result;\n}\n\n```\nand then sub_3B1D0C\n\n```\nint *__fastcall sub_3B1D0C(int *result, size_t a2, int a3, int a4)\n{\n  int v4; // r12\n  int v5; // r10\n  int v6; // r8\n  int v7; // r7\n  unsigned int v8; // r3\n  unsigned int v9; // r8\n  int *v10; // r5\n  int v11; // r4\n  size_t v12; // r6\n  size_t v13; // r10\n  int v14; // r0\n  int v15; // r9\n  bool v16; // zf\n  int v17; // r7\n  int v18; // r4\n  const void *v19; // r1\n  int v20; // r7\n  int v21; // r4\n  _BYTE *v22; // r1\n  char v23; // [sp+4h] [bp-24h]\n\n  v4 = *result;\n  v5 = *(_DWORD *)(*result - 12);\n  v6 = a4 - a3;\n  v7 = a4;\n  v8 = *(_DWORD *)(*result - 8);\n  v9 = v6 + v5;\n  v10 = result;\n  v11 = a3;\n  v12 = a2;\n  v13 = v5 - a2 - a3;\n  if ( v9 > v8 || *(_DWORD *)(v4 - 4) > 0 )\n  {\n    v14 = sub_3B1B30(v9, v8, &v23);\n    if ( v12 )\n    {\n      v22 = (_BYTE *)*v10;\n      if ( v12 == 1 )\n      {\n        *(_BYTE *)(v14 + 12) = *v22;\n        v15 = v14 + 12;\n      }\n      else\n      {\n        v15 = v14 + 12;\n        memcpy((void *)(v14 + 12), v22, v12);\n      }\n    }\n    else\n    {\n      v15 = v14 + 12;\n    }\n    if ( v13 )\n    {\n      v20 = v7 + v12;\n      v21 = v11 + v12;\n      if ( v13 == 1 )\n        *(_BYTE *)(v15 + v20) = *(_BYTE *)(*v10 + v21);\n      else\n        memcpy((void *)(v15 + v20), (const void *)(*v10 + v21), v13);\n    }\n    result = (int *)(*v10 - 12);\n    if ( result != &dword_4C60C0 )\n      result = (int *)sub_3B1C84();\n    v4 = v15;\n    *v10 = v15;\n  }\n  else\n  {\n    v16 = a3 == v7;\n    if ( a3 != v7 )\n      v16 = v13 == 0;\n    if ( !v16 )\n    {\n      v17 = v7 + a2;\n      v18 = a3 + a2;\n      result = (int *)(v4 + v17);\n      v19 = (const void *)(v4 + a3 + a2);\n      if ( v13 == 1 )\n        *(_BYTE *)(v4 + v17) = *(_BYTE *)(v4 + v18);\n      else\n        result = (int *)memmove(result, v19, v13);\n      v4 = *v10;\n    }\n  }\n  if ( (int *)(v4 - 12) != &dword_4C60C0 )\n  {\n    *(_DWORD *)(v4 - 4) = 0;\n    *(_DWORD *)(v4 - 12) = v9;\n    *(_BYTE *)(v4 + v9) = 0;\n  }\n  return result;\n}\n\n```\ncan anyone give a best guess what does the function do after HttpUtility::URLDecode ?\n\nAs inspired by @NirIzr's answer below and some of the comments, I wrote a snippet of Java code to try the XOR like this:\n\n```\n public static void main(String args[])\n    {\n        byte[] _bytes = null;\n        byte[] key = {(byte) 0xC,(byte)0x17,(byte)0xDE,(byte)0x22,(byte)0x2C,(byte)0xC9,(byte)0x37,(byte)0x43};\n        String s = \"%EB%9Ff%C5%A4q%D0%D9%88%F2M%87%C9Z%92%A6%83%BC%3B%86%8B%2D%8B%EC\";\n        try {\n            String decoded = URLDecoder.decode(s,\"UTF-8\");\n            _bytes = decoded.getBytes();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n\n        for(int i=0;i<_bytes.length;i++){\n            _bytes[i] = (byte)(_bytes[i] ^ key[i%key.length]);\n        }\n\n        System.out.println(new String(_bytes));\n\n    }\n\n```\nBut the out put didn't seems to be good:\n\n�cD�mF�����v��c͓tm���1��&���c�v�����͓t��\n\n",
  "votes": "3",
  "answers": 2,
  "views": "935",
  "tags": [
    "c",
    "decryption",
    "decompress"
  ],
  "user": "armnotstrong",
  "time": "Jun 17, 2020 at 9:54",
  "comments": [
    {
      "user": "sudhackar",
      "text": "Can you share the binary so that we can help you better?",
      "time": null
    },
    {
      "user": "armnotstrong",
      "text": "@sudhackar sure, the .so file could be found here and you can search for EncodeUtil.getDecryptStr to find the function",
      "time": null
    },
    {
      "user": "Avery3R",
      "text": "Have you tried just xoring it with the byte array that you have commented? If that doesn't work I'd try stepping through it with a debugger.",
      "time": null
    },
    {
      "user": "Paweł Łukasik",
      "text": "it would be best if you would have some examples to run them through, but it looks like xoring would do what can be also noted from what does the encryptStr does.",
      "time": null
    },
    {
      "user": "armnotstrong",
      "text": "@PawełŁukasik @Avery3R I think you can use %EB%9Ff%C5%A4q%D0%D9%88%F2M%87%C9Z%92%A6%83%BC%3B%86%8B%2D%8B%EC this string(which is encoded first using httpUrlEncode according to the code) to do the test, moreover, I upload the SQLite DB which contains the encrypted string here",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "All the credit for this this answer should go to the @NirIzr and @Avery3R.\n\nHere is a python script that implements the xoring mentioned by these kind people:\n\n```\nimport urllib\nimport binascii\ndata = \"%EB%9Ff%C5%A4q%D0%D9%88%F2M%87%C9Z%92%A6%83%BC%3B%86%8B%2D%8B%EC\" #quoted data as is\nunquoted = urllib.unquote(data)\nkey = binascii.unhexlify(\"0C17DE222CC93743\") # the key\nidx = 0\nres = \"\"\nfor c in unquoted:\n    res += chr(ord(c) ^ ord(key[idx % len(key)]))\n    idx += 1\nprint res\n\n```\nThe result of running: \n\n```\n╭─wireshrink@[cenzored] ~/test  \n╰─$ python ./test.py \n爸爸的哥哥叫大伯\n\n```\nI think that you either forgot to encode it back to UTF8 before printing or there is some other issue in your code or default environment that is  related to encoding.\n\n",
      "votes": "4",
      "user": "w s",
      "time": "Jan 30, 2018 at 13:30",
      "is_accepted": true,
      "comments": [
        {
          "user": "armnotstrong",
          "text": "Thanks, I will figure out what the problem is with my java code :D",
          "time": null
        },
        {
          "user": "Paweł Łukasik",
          "text": "interesting content (via google translate): \"爸爸的哥哥叫大伯\"->\"Dad's brother called uncle\" ;)",
          "time": null
        },
        {
          "user": "armnotstrong",
          "text": "@PawełŁukasik LOL",
          "time": null
        }
      ]
    },
    {
      "content": "First, I have to say several things don't quite add up in the decompilation, and I often find it easier to understand disassembly than decompilation\n\nLet's start with the function doing most of the work - sub_3B25D0.\n\nAs this function is somewhat long and has a little bit of quote-unquote scary math in it, our first impression may be that this function does all or most of the encryption heavy lifting. However after further investigation (and i won't dwell into this here) you can clearly see indications of an compression algorithm. There are multiple key elements revealing that, and you can find a full explanation of how to differentiate compression from encryption in this answer.\n\nI'll however go over some of the key indications as they appear in the code snippet you provided.\n\nTherefore, lets rename sub_3B1D0C to NI_BlockDecompression. You may use your own initials. I'm assuming it's a decompression and not a compression function merely because you called the flow \"Decrypt\", impling input is intangible.\n\nNow, going bottom to top, we can briefly review sub_3B2580 and sub_3B25D0 and see those functions just run a couple of simple sanity checks on input but basically don't do anything interesting. after a brief peek it looks like there's some kind of protection against running the NI_BlockDecompression function more than once on the same string, not sure though. Let's just skip them and get to the second interesting function - getDecryptStr.\n\nI find the multiple calls to sub_3B25D0 quite odd, and I suggest you look further into what's going on there. The EncodeUtil::getDecryptStr function just seem to xor bytes with the hardcoded \"XOR encryption\" key at byte_41A7DD.\n\n",
      "votes": "4",
      "user": "NirIzr",
      "time": "Jan 30, 2018 at 2:54",
      "is_accepted": false,
      "comments": [
        {
          "user": "armnotstrong",
          "text": "Hi, @Nirlzr thanks for your answer, seems promise, I will dig into that",
          "time": null
        },
        {
          "user": "armnotstrong",
          "text": "Hi, @Nirlzr check the edit :-( could you give some pseudocode, so I can try to understand that?",
          "time": null
        },
        {
          "user": "NirIzr",
          "text": "@armnotstrong You're doing the xor (although, again, the code there is not merely a xor. there some peculiarities with calling sub_3B25D0 multiple times etc) but not performing the decompression.",
          "time": null
        }
      ]
    }
  ]
}