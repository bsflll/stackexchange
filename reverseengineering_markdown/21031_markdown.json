{
  "title": "windbg - What is the relation between the VAD (!vad), the PTEs (!pte), and loaded modules and sections (lm and !dh)?",
  "link": "https://reverseengineering.stackexchange.com/questions/21031/windbg-what-is-the-relation-between-the-vad-vad-the-ptes-pte-and-loade",
  "content": "[cross-posted (but closed the original) from https://stackoverflow.com/q/55438806/254959]\n\nI'm trying to gain a better understanding on Windows process memory, and have some gaps with regards to the relationship between the VAD tree, the PTEs and loaded modules.\n\nThe output below are captured from a kernel debugging session, but in the context of a simple process which runs a simple compiled \"hello world\" C program.\n\n```\nkd> lm\nstart             end                 module name\n00007ffd`ea8f0000 00007ffd`ea91b000   vertdll    (deferred)             \n00007ffd`ea920000 00007ffd`eab00000   ntdll      (pdb symbols)          C:\\ProgramData\\Dbg\\sym  \ntdll.pdb\\13B64B553003FA22AB7CCD36A3A5431F1  \ntdll.pdb\nfffff416`a3800000 fffff416`a3b94000   win32kfull   (deferred)             \nfffff416`a3ba0000 fffff416`a3db2000   win32kbase   (deferred)             \nfffff416`a3dc0000 fffff416`a3dca000   TSDDD      (deferred)             \nfffff416`a3dd0000 fffff416`a3e11000   cdd        (deferred)             \nfffff416`a4290000 fffff416`a4307000   win32k     (deferred)             \nfffff800`a5c01000 fffff800`a64d3000   nt         (pdb symbols)          C:\\ProgramData\\Dbg\\sym  \ntkrnlmp.pdb\\31C51B7D1C2545A88F69E13FC73E68941  \ntkrnlmp.pdb\nfffff800`a64d3000 fffff800`a6552000   hal        (deferred)             \nfffff800`a6600000 fffff800`a6647000   kd_02_8086   (deferred)             \n...\nfffff80b`85960000 fffff80b`8597c000   disk       (deferred)             \n...\n\n```\n```\nkd> !vad\nVAD           Level     Start       End Commit\nffff8908f102b0c0  4     7ffe0     7ffe0      1 Private      READONLY           \nffff8908ef465290  3     7ffe1     7ffef     -1 Private      READONLY           \nffff8908f169f100  4   fb63c20   fb63d1f      6 Private      READWRITE          \nffff8908ef4c86e0  2   fb63e00   fb63fff      3 Private      READWRITE          \nffff8908ef17e3b0  3  2e38e030  2e38e03f      0 Mapped       READWRITE          Pagefile section, shared commit 0x10\nffff8908ef592280  4  2e38e040  2e38e046      1 Private      READWRITE          \nffff8908f1873410  1  2e38e050  2e38e068      0 Mapped       READONLY           Pagefile section, shared commit 0x19\nffff8908ef106a00  3  2e38e070  2e38e073      0 Mapped       READONLY           Pagefile section, shared commit 0x4\nffff8908f19eea10  2  2e38e080  2e38e080      0 Mapped       READONLY           Pagefile section, shared commit 0x1\nffff8908f0fba340  3  2e38e090  2e38e090      1 Private      READWRITE          \nffff8908f0fdc980  0  2e38e0a0  2e3900a0      1 Private      READWRITE          \nffff8908ef215060  3  2e390130  2e39022f     17 Private      READWRITE          \nffff8908ef084860  2  2e390230  2e3902f4      0 Mapped       READONLY           \\Windows\\System32\\locale.nls\nffff8908f14e3e90  3 7ff67f9a0 7ff67fa9f      0 Mapped       READONLY           Pagefile section, shared commit 0x5\nffff8908ef3025c0  1 7ff67faa0 7ff67fac2      0 Mapped       READONLY           Pagefile section, shared commit 0x23\nffff8908f0ef7c70  4 7ff67fe30 7ff67fe51      3 Mapped  Exe  EXECUTE_WRITECOPY  \\Users\\user\\Desktop\\test\\x64\\Release\\test.exe\nffff8908ef6ad770  3 7ffde5240 7ffde52c7      5 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\apphelp.dll\nffff8908ef1bcf70  4 7ffde7470 7ffde76d5      8 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\KernelBase.dll\nffff8908f16717a0  2 7ffde9270 7ffde931d      5 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\kernel32.dll\nffff8908f0e50c30  3 7ffdea920 7ffdeaaff     12 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32  \ntdll.dll\n\n```\nWhen I !pte and even db on one of the modules that is not in the !vad output (specifically, the disk module), it is a valid, mapped-in address, and I can even read its content.\n\n```\nkd> !pte fffff80b`85960000\n                                           VA fffff80b85960000\nPXE at FFFFFB7DBEDF6F80    PPE at FFFFFB7DBEDF0170    PDE at FFFFFB7DBE02E160    PTE at FFFFFB7C05C2CB00\ncontains 0000000001109063  contains 0A0000007E55D863  contains 0A00000002A81863  contains 890000007D044963\npfn 1109      ---DA--KWEV  pfn 7e55d     ---DA--KWEV  pfn 2a81      ---DA--KWEV  pfn 7d044     -G-DA--KW-V\n\n```\n```\nkd> db fffff80b`85960000\nfffff80b`85960000  4d 5a 90 00 03 00 00 00-04 00 00 00 ff ff 00 00  MZ..............\nfffff80b`85960010  b8 00 00 00 00 00 00 00-40 00 00 00 00 00 00 00  ........@.......\nfffff80b`85960020  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\nfffff80b`85960030  00 00 00 00 00 00 00 00-00 00 00 00 d8 00 00 00  ................\nfffff80b`85960040  0e 1f ba 0e 00 b4 09 cd-21 b8 01 4c cd 21 54 68  ........!..L.!Th\nfffff80b`85960050  69 73 20 70 72 6f 67 72-61 6d 20 63 61 6e 6e 6f  is program canno\nfffff80b`85960060  74 20 62 65 20 72 75 6e-20 69 6e 20 44 4f 53 20  t be run in DOS \nfffff80b`85960070  6d 6f 64 65 2e 0d 0d 0a-24 00 00 00 00 00 00 00  mode....$.......\n\n```\nWhy then, does !vad not contain this entry?\n\n```\nkd> !dh 7ff67fe30000\n\nFile Type: EXECUTABLE IMAGE\nFILE HEADER VALUES\n    8664 machine (X64)\n       6 number of sections\n5CA04653 time date stamp Sat Mar 30 21:47:15 2019\n\n       0 file pointer to symbol table\n       0 number of symbols\n      F0 size of optional header\n      22 characteristics\n            Executable\n            App can handle >2gb addresses\n\n...\n\nSECTION HEADER #1\n   .text name\n   10FA0 virtual size\n    1000 virtual address\n   11000 size of raw data\n...\n60000020 flags\n         Code\n         (no align specified)\n         Execute Read\n\nSECTION HEADER #2\n  .rdata name\n    96F6 virtual size\n   12000 virtual address\n    9800 size of raw data\n   11400 file pointer to raw data\n...\n40000040 flags\n         Initialized Data\n         (no align specified)\n         Read Only\n\n...\n\nSECTION HEADER #6\n  .reloc name\n     614 virtual size\n   21000 virtual address\n     800 size of raw data\n...\n42000040 flags\n         Initialized Data\n         Discardable\n         (no align specified)\n         Read Only\n\n```\nAnd, according to the Windows Internals book,\n\nSo I would expect that each loaded module would be represented by a few VAD entries, for each section with different memory access protection.\n\nBut !vad shows each loaded module as a single entry with the permission EXECUTE_WRITECOPY.\n\n```\nkd> !vad\nVAD           Level     Start       End Commit\n...\nffff8908f0ef7c70  4 7ff67fe30 7ff67fe51      3 Mapped  Exe  EXECUTE_WRITECOPY  \\Users\\user\\Desktop\\test\\x64\\Release\\test.exe\nffff8908ef6ad770  3 7ffde5240 7ffde52c7      5 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\apphelp.dll\nffff8908ef1bcf70  4 7ffde7470 7ffde76d5      8 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\KernelBase.dll\nffff8908f16717a0  2 7ffde9270 7ffde931d      5 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\kernel32.dll\nffff8908f0e50c30  3 7ffdea920 7ffdeaaff     12 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32  \ntdll.dll\n\n```\nWhy is that so?\n\n",
  "votes": "1",
  "answers": 1,
  "views": "2k",
  "tags": [
    "windows",
    "windbg",
    "kernel"
  ],
  "user": "Pie Faced",
  "time": "Apr 3, 2019 at 14:21",
  "comments": [],
  "answers_data": [
    {
      "content": "when you are in kd session lm displays both kernelmode modules and user mode modules\n\nuse lm u to display only usermode modules \n\nthis will be consistent with the !vad display \n\nkernel mode modules aren't associated with a single process and as such they are not a part of processes virtual address descriptor table \n\nobviously you can get the pte for any virtual address and obviously you can read from any virtual address \n\niirc the versus is the qualifier in the Quote  the image VADS all will have MEM_IMAGE as their type and they would be contiguous\nyou cant split them to their individual sections from !vad \n\nyou need to be in usermode and do !vadump for the specific image in the specific process\n\na single CONTIGOUS MEM_IMAGE vad \n\n```\n0: kd> !vad ffffde04de1b7d90\nVAD           Level     Start       End Commit\nffffde04de1b7d90  0 7ffdb7c80 7ffdb7e6c     21 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32  \ntdll.dll\n\nTotal VADs: 1, average level: 1, maximum depth: 0\nTotal private commit: 0x15 pages (84 KB)\nTotal shared commit:  0 pages (0 KB)\n\n```\nI attached this process to a local windbg in the target \n\nthe split for this vad \n\n```\nBaseAddress:       00007ffdb7c80000  << + \nRegionSize:        0000000000001000  <<  ====\nState:             00001000  MEM_COMMIT\nProtect:           00000002  PAGE_READONLY\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7c81000 <<<<<<<<<<<< + \nRegionSize:        0000000000117000 << ====\nState:             00001000  MEM_COMMIT\nProtect:           00000020  PAGE_EXECUTE_READ\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7d98000 <<<<<<<<<<<<<<\nRegionSize:        0000000000047000\nState:             00001000  MEM_COMMIT\nProtect:           00000002  PAGE_READONLY\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7ddf000\nRegionSize:        0000000000001000\nState:             00001000  MEM_COMMIT\nProtect:           00000004  PAGE_READWRITE\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7de0000\nRegionSize:        0000000000002000\nState:             00001000  MEM_COMMIT\nProtect:           00000008  PAGE_WRITECOPY\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7de2000\nRegionSize:        0000000000008000\nState:             00001000  MEM_COMMIT\nProtect:           00000004  PAGE_READWRITE\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7dea000  <<<< + \nRegionSize:        0000000000083000  <<<  =====      ((00007ffdb7e6d000 - page size) / pagesize)  = vad end  7ffdb7e6c\nState:             00001000  MEM_COMMIT\nProtect:           00000002  PAGE_READONLY\nType:              01000000  MEM_IMAGE\n\n```\nthe lm in usermode \n\n```\n0:001> lm m ntdll\nBrowse full module list\nstart             end                 module name\n00007ffd`b7c80000 00007ffd`b7e6d000   ntdll     \n\n```\nyou can do !dh here and add look at the virtual address  each virtual address will match \n!vadumps entry and  will show what different protections are applied \n\nread about VirtualAlloc and Virtual Protect \n\nyou can allot a very big memory and change protections for page sizes inbetween them \nthe big allocation is equivalent for vad  while !vadump in usermode will show the virtualprotected state \n\na process can access only the usermode virtual addresses it cannot access the kernel mode addresses it need a mechanism to do that (syscalls do that work)  \n\n",
      "votes": "2",
      "user": "blabb",
      "time": "Apr 3, 2019 at 21:19",
      "is_accepted": true,
      "comments": []
    }
  ]
}