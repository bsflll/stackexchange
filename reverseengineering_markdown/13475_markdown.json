{
  "title": "How can I determine if a piece of code is an encryption algorithm?",
  "link": "https://reverseengineering.stackexchange.com/questions/13475/how-can-i-determine-if-a-piece-of-code-is-an-encryption-algorithm",
  "content": "I am trying to reverse engineer a malware, and came across a piece of code that I suspect is an encryption/decryption procedure, however I do not know for sure. I can recognize that it extracts its payload from it's own .rsrc section.\n I scanned this algorithm with FindCrypt and IDAScope, Both plugins failed identifying it as a cryptographic algorithm.\n\nI am not familiar with cryptographic algorithms. What are some good indications of code being an encryption or decryption algorithm, and what indications rule it out?\n\nThe extraction algorithm is(generated by IDA):\n\n```\nint __stdcall sub_9001320(int a1, unsigned int a2, int a3)\n{\n// a1 = a3 = 0x09003000\n// a2 = 0x7600\n\n\n\n  int result; // eax@2\n  char v4; // al@23\n  unsigned int l; // [sp+4h] [bp-4Ch]@33\n  unsigned int k; // [sp+10h] [bp-40h]@19\n  unsigned int v7; // [sp+14h] [bp-3Ch]@19\n  int v8; // [sp+18h] [bp-38h]@40\n  signed int j; // [sp+1Ch] [bp-34h]@13\n  unsigned int v10; // [sp+20h] [bp-30h]@5\n  unsigned int i; // [sp+24h] [bp-2Ch]@5\n  unsigned int v12; // [sp+28h] [bp-28h]@5\n  unsigned int v13; // [sp+2Ch] [bp-24h]@5\n  signed int v14; // [sp+30h] [bp-20h]@13\n  unsigned int v15; // [sp+34h] [bp-1Ch]@5\n  unsigned int v16; // [sp+38h] [bp-18h]@5\n  unsigned __int8 v17; // [sp+3Fh] [bp-11h]@5\n  signed int v18; // [sp+40h] [bp-10h]@5\n  _DWORD *lpAddress; // [sp+44h] [bp-Ch]@11\n  unsigned int v20; // [sp+48h] [bp-8h]@13\n  unsigned int v21; // [sp+4Ch] [bp-4h]@16\n\n  if ( a2 > 0xC )\n  {\n    if ( *(_DWORD *)a1 == 1083581807 )\n    {\n      v16 = sub_9001300(a1);\n      v18 = 12;\n      v17 = 0;\n      v15 = 9;\n      v12 = 256;\n      v13 = 256;\n      v10 = 8 * a2 - 96;\n      for ( i = 9; v10 >= i; v10 -= i )\n      {\n        if ( i != 12 && v13 == 1 << i )\n          ++i;\n        ++v13;\n      }\n      lpAddress = VirtualAlloc(0, 0xC000u, 0x1000u, 4u);\n      if ( lpAddress )\n      {\n        v20 = 0;\n        v14 = 256;\n        for ( j = 0; j <= 255; ++j )\n        {\n          lpAddress[3 * j] = 0;\n          lpAddress[3 * j + 2] = 0;\n          lpAddress[3 * j + 1] = 1;\n        }\n        v21 = 0;\n        while ( v21 < v16 && v12 < v13 )\n        {\n          v7 = 0;\n          for ( k = 0; k < v15; ++k )\n          {\n            if ( (1 << (7 - (v17 + 8 * v18) % 8)) & *(_BYTE *)(a1 + (v17 + 8 * v18) / 8) )\n              v7 |= 1 << k;\n            v4 = (v17 + 1) % 8;\n            v17 = (v17 + 1) % 8;\n            if ( !v4 )\n              ++v18;\n          }\n          if ( v7 > 0xFF )\n          {\n            if ( v20 < 0xF00 && v7 > v20 + 255 )\n              return 0;\n            if ( v21 + lpAddress[3 * v7 + 1] > v16 )\n              return 0;\n            for ( l = 0; l < lpAddress[3 * v7 + 1]; ++l )\n              *(_BYTE *)(a3 + l + v21) = *(_BYTE *)(a3 + l + lpAddress[3 * v7]);\n          }\n          else\n          {\n            *(_BYTE *)(v21 + a3) = v7;\n          }\n          if ( v20 == 3840 )\n          {\n            if ( (unsigned int)++v14 >> 12 )\n              v14 = 256;\n          }\n          if ( v20 >= 0xF00 )\n          {\n            v8 = v14 - 1;\n            if ( v14 == 256 )\n              v8 = 4095;\n          }\n          else\n          {\n            v8 = v20 + v14;\n          }\n          lpAddress[3 * v8] = v21;\n          lpAddress[3 * v8 + 1] = lpAddress[3 * v7 + 1] + 1;\n          lpAddress[3 * v8 + 2] = 0;\n          if ( v20 < 0xF00 )\n            ++v20;\n          v21 = v21 + lpAddress[3 * v8 + 1] - 1;\n          ++v12;\n          if ( v15 < 0xC && 1 << v15 == v12 )\n            ++v15;\n        }\n        if ( v21 >= v16 )\n        {\n          // sub_9001000 is only called onece and always return 0\n          if ( *(_DWORD *)(a1 + 8) == sub_9001000(a3, v16) )\n          {\n            VirtualFree(lpAddress, 0, 0x8000u);\n            result = 0;\n          }\n          else\n          {\n            result = 0;\n          }\n        }\n        else\n        {\n          result = 0;\n        }\n      }\n      else\n      {\n        result = 0;\n      }\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\n\n\nint __stdcall sub_9001300(int a1)\n{\n  int result; // eax@2\n\n  if ( *(_DWORD *)a1 == 1083581807 )\n    result = *(_DWORD *)(a1 + 4);\n  else\n    result = 0;\n  return result;\n}\n\n```\nFile info:\n     file format pei-i386\n\n```\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         00001000  09001000  09001000  00001000  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .rdata        00001000  09002000  09002000  00002000  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  2 .rsrc         00005000  09003000  09003000  00003000  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  3 .reloc        00001000  09008000  09008000  00008000  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n\n```\n",
  "votes": "3",
  "answers": 1,
  "views": "604",
  "tags": [
    "malware",
    "unpacking",
    "encryption",
    "decryption",
    "encodings"
  ],
  "user": "JACK M",
  "time": "Sep 9, 2016 at 21:50",
  "comments": [
    {
      "user": "ebux",
      "text": "It seems to be a compression algorithm and not a cryptographic one.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "TL;DR: What we have here is probably not an encryption algorithm, it is more likely a decompression loop, by the look of it. It simply does not do anything that could be considered even remotely similar to encryption.\n\nEncryption algorithms are divided into two classes. First is a stream cipher. From wikipedia:\n\nSecond is a block cypher. From wikipedia:\n\nWhat we have here is probably not an encryption algorithm. It simply does not do anything that could be considered even remotely similar to encryption. Some of the things that are often found in encryption algorithms but are missing here (not a complete list but just the first few things I came up with):\n\nEncryption algorithms are usually long (and one might say ugly). Usually structured and meticulous on performing operations on all bytes in long repeated sequences. You'll often see multiple iterations of a fixed length performing a single or few operations.\n\nThis is more resembling a compression/decompression algorithm, as sequences of bytes are copied on certain conditions, while bytes are constructed into the decompressed buffer on others.\n\nLets go over the code and see:\n\n```\nint __stdcall sub_9001320(int a1, unsigned int a2, int a3)\n{\n// a1 = a3 = 0x09003000\n// a2 = 0x7600\n\n  int result; // eax@2\n  char v4; // al@23\n  unsigned int l; // [sp+4h] [bp-4Ch]@33\n  unsigned int k; // [sp+10h] [bp-40h]@19\n  unsigned int v7; // [sp+14h] [bp-3Ch]@19\n  int v8; // [sp+18h] [bp-38h]@40\n  signed int j; // [sp+1Ch] [bp-34h]@13\n  unsigned int v10; // [sp+20h] [bp-30h]@5\n  unsigned int i; // [sp+24h] [bp-2Ch]@5\n  unsigned int v12; // [sp+28h] [bp-28h]@5\n  unsigned int v13; // [sp+2Ch] [bp-24h]@5\n  signed int v14; // [sp+30h] [bp-20h]@13\n  unsigned int v15; // [sp+34h] [bp-1Ch]@5\n  unsigned int v16; // [sp+38h] [bp-18h]@5\n  unsigned __int8 v17; // [sp+3Fh] [bp-11h]@5\n  signed int v18; // [sp+40h] [bp-10h]@5\n  _DWORD *lpAddress; // [sp+44h] [bp-Ch]@11\n  unsigned int v20; // [sp+48h] [bp-8h]@13\n  unsigned int v21; // [sp+4Ch] [bp-4h]@16\n\n```\nFunction definiton\n\n```\n  if ( a2 > 0xC )\n  {\n\n```\nAssert a certain length is at least 96 bytes. Although there are some block ciphers accepting this as block size, it's not too common and most widely accepted block ciphers do not support this block size.\n\n```\n    if ( *(_DWORD *)a1 == 1083581807 )\n    {\n\n```\nAssert certain first bytes of buffer are fixed, this just looks odd without context.\n\n```\n      v16 = sub_9001300(a1);\n\n```\nSet v16 to second dword of input buffer\n\n```\n      v18 = 12;\n      v17 = 0;\n      v15 = 9;\n      v12 = 256;\n      v13 = 256;\n      v10 = 8 * a2 - 96;\n\n```\nSome more variable initializations\n\n```\n      for ( i = 9; v10 >= i; v10 -= i )\n      {\n        if ( i != 12 && v13 == 1 << i )\n          ++i;\n        ++v13;\n      }\n\n```\nIncrease v13 according to original length. Without going too much into specifics here, this doesn't look like any cipher seed/initialization.\n\n```\n      lpAddress = VirtualAlloc(0, 0xC000u, 0x1000u, 4u);\n      if ( lpAddress )\n      {\n\n```\nAllocate a hardcoded length buffer to work on as temporary data\n\n```\n        v20 = 0;\n        v14 = 256;\n        for ( j = 0; j <= 255; ++j )\n        {\n          lpAddress[3 * j] = 0;\n          lpAddress[3 * j + 2] = 0;\n          lpAddress[3 * j + 1] = 1;\n        }\n\n```\nInitialize said buffer, 2/3 with 0s, 1/3 with 1s. this is probably a boolean buffer.\n\n```\n        v21 = 0;\n        while ( v21 < v16 && v12 < v13 )\n        {\n\n```\nLoop v16 times. remember v16 is user supplied as the second dword in provided buffer. The second dword after the magic is probably a length.\n\n```\n          v7 = 0;\n          for ( k = 0; k < v15; ++k )\n          {\n\n```\nAnother loop, this time for 9 iterations. This means we have 9 iterations for each character in the guessed length parameter. Most block ciphers will have more iterations, and those won't be per character. Most stream ciphers will not process data but instead generate a stream of bytes to XOR with. We don't see a XOR here either.\n\n```\n            if ( (1 << (7 - (v17 + 8 * v18) % 8)) & *(_BYTE *)(a1 + (v17 + 8 * v18) / 8) )\n              v7 |= 1 << k;\n\n```\nBits are only added to v7, also not productive for any type of encryption algorithm.\n\n```\n            v4 = (v17 + 1) % 8;\n            v17 = (v17 + 1) % 8;\n\n```\nThese two are byte-sized counters.\n\n```\n            if ( !v4 )\n              ++v18;\n          }\n\n```\nIncrease another counter, used for determining how many bits in v7 will be set. This entire loop decides which bits of v7 will be set, depending on a fixed sequence and wether certain bits of the input buffer are\n\n```\n          if ( v7 > 0xFF )\n          {\n            if ( v20 < 0xF00 && v7 > v20 + 255 )\n              return 0;\n            if ( v21 + lpAddress[3 * v7 + 1] > v16 )\n              return 0;\n            for ( l = 0; l < lpAddress[3 * v7 + 1]; ++l )\n              *(_BYTE *)(a3 + l + v21) = *(_BYTE *)(a3 + l + lpAddress[3 * v7]);\n          }\n\n```\nIf v7 is above 0xff do some sanity (and return on invalid state/data) and then copy a sequence of bytes until a null terminator is reached from a3 to a3, at offsets determined by the value of lpAddress at a specific offset determined by v7.\n\n```\n          else\n          {\n            *(_BYTE *)(v21 + a3) = v7;\n          }\n\n```\nif v7 is below or equal to 255, simply assign it in specified location.\n\n```\n          if ( v20 == 3840 )\n          {\n            if ( (unsigned int)++v14 >> 12 )\n              v14 = 256;\n          }\n          if ( v20 >= 0xF00 )\n          {\n            v8 = v14 - 1;\n            if ( v14 == 256 )\n              v8 = 4095;\n          }\n          else\n          {\n            v8 = v20 + v14;\n          }\n\n```\nReset values of v8 and v4 based on values of offset variables, namely v20 and themselves.\n\n```\n          lpAddress[3 * v8] = v21;\n          lpAddress[3 * v8 + 1] = lpAddress[3 * v7 + 1] + 1;\n          lpAddress[3 * v8 + 2] = 0;\n\n```\nSet a few other values in lpAddress based hardcoded values (0) and a copy of a single value.\n\n```\n          if ( v20 < 0xF00 )\n            ++v20;\n          v21 = v21 + lpAddress[3 * v8 + 1] - 1;\n          ++v12;\n          if ( v15 < 0xC && 1 << v15 == v12 )\n            ++v15;\n        }\n\n```\nSome more counter update based on input and reset of overflows.\n\n```\n        if ( v21 >= v16 )\n        {\n          // sub_9001000 is only called onece and always return 0\n          if ( *(_DWORD *)(a1 + 8) == sub_9001000(a3, v16) )\n          {\n            VirtualFree(lpAddress, 0, 0x8000u);\n            result = 0;\n          }\n          else\n          {\n            result = 0;\n          }\n        }\n        else\n        {\n          result = 0;\n        }\n      }\n      else\n      {\n        result = 0;\n      }\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\n\n```\nIn case of any invalid input, return 0\n\n```\nint __stdcall sub_9001300(int a1)\n{\n  int result; // eax@2\n\n  if ( *(_DWORD *)a1 == 1083581807 )\n    result = *(_DWORD *)(a1 + 4);\n  else\n    result = 0;\n  return result;\n}\n\n```\nAssert buffer starts with a hardcoded dword (which we already know is the case because of a previous if statement) and return the value in the second dword.\n\n",
      "votes": "11",
      "user": "Community",
      "time": "Jun 17, 2020 at 9:54",
      "is_accepted": true,
      "comments": [
        {
          "user": "John Greene",
          "text": "Not even a modicum of P-box or S-box, much less rotate instruction sequence.",
          "time": null
        }
      ]
    }
  ]
}