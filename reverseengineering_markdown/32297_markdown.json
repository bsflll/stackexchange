{
  "title": "Adding a program header to ELF",
  "link": "https://reverseengineering.stackexchange.com/questions/32297/adding-a-program-header-to-elf",
  "content": "I am a newbie in this, and I am trying to add a program header to a simple ELF64 \"Hello World\" program on Ubuntu. All in changing the binary data of the ELF.\n\nI went to the end of the program headers (Start of program headers + (Size of program headers * Number of program headers)) and inserted a 56 byte length program header of a valid address in the file. I then increased the Number of programs headers by 1, and increased the Entry point address and the Start of section headers by 56.\n\nIs there anything I am still missing? I get errors while trying to run readelf on my modified ELF and it clearly shows that I messed something up.\n\nI get many errors when using -a (most of them is: readelf: Error: Reading 16 bytes extends past end of file for version need aux (3)). When I am trying to run my modified ELF, it gives me segmentation fault at the beginning:\n\n```\n>strace ./helloWorld-modified\nexecve(\"./helloWorld-modified\", [\"./helloWorld-modified\"], 0x7fffbb83ddb0 /* 25 vars */) = -1 EINVAL (Invalid argument)\n--- SIGSEGV {si_signo=SIGSEGV, si_code=SI_KERNEL, si_addr=NULL} ---\n+++ killed by SIGSEGV +++\nSegmentation fault\n\n```\nPlease tell if I need to add more context here. I am adding the original readelf -h:\n\n```\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x530\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          6448 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         9\n  Size of section headers:           64 (bytes)\n  Number of section headers:         29\n  Section header string table index: 28\n\n```\nThis is the program header data I added:\n\n```\n  LOAD           0x00000000000020a8 0x0000000000010000 0x0000000000000000\n                 0x0000000000000020 0x0000000000000020  R      0x0\n\n```\n",
  "votes": "1",
  "answers": 1,
  "views": "525",
  "tags": [
    "linux",
    "elf"
  ],
  "user": "Roy Avidan",
  "time": "Sep 17, 2023 at 12:26",
  "comments": [],
  "answers_data": [
    {
      "content": "I'm by no means an expert in this area, but in non-PIE ELFs I believe there can be header entries near the end of the binary that are easy to mess up that way, on top of all the other data offsets you're shifting.\n\nWhatever you're ultimately trying to do, it'd probably help to get a library that's already designed to do it like LIEF:\nhttps://lief-project.github.io/doc/stable/tutorials/\n\nThen you can look at the binaries to see how it made the changes.\n\nThis will add a new section:\n\n```\nimport lief\n\nbin = lief.parse('test.o')\n\nprint('Original sections:')\nprint('Name\\tType\\tOffset\\tVirtual\\tSize  \nFlags')\nfor section in bin.sections:\n    print(f'{section.name}\\t{section.type}\\t{hex(section.offset)}\\t{hex(section.virtual_address)}\\t{hex(section.size)}')\n    if len(section.flags_list):\n        print(f'\\t\\t{section.flags_list}')\n\n    if section.name == '.text':\n        text_flags = section.flags\n\n# This alloocates new bytes in the binary and is the safest way to add a section\n# Instead of setting content, you can try to manually set the other fields but it's hit and miss working with it that way\nsec = lief.ELF.Section()\nsec.name = \"my_section\"\nsec.type = lief.ELF.SECTION_TYPES.PROGBITS\nsec.content = [0xCC] * 512\nsec.alignment = 8\n\n# Copy .text sections flags to our section (should be ALLOC and EXECINSTR )\nif text_flags:\n    sec.flags = text_flags\n\nbin.add(sec)\n\nprint('  \n  \nModified sections:')\nprint('Name\\tType\\tOffset\\tVirtual\\tSize')\nfor section in bin.sections:\n    if section.name == 'my_section':\n        section.virtual_address = 0x20000\n\n    print(f'{section.name}\\t{section.type}\\t{hex(section.offset)}\\t{hex(section.virtual_address)}\\t{hex(section.size)}')\n    if len(section.flags_list):\n        print(f'\\t\\t{section.flags_list}')\n\nbin.write('test2.o')\n\n```\nThen verify:\n\n```\n$ objdump -h test2.o\n...\n27 my_section    00000200  0000000000020000  0000000000020000  00005000  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n\n```\nYou can dig down and do some more manual surgery with it, but I'm not that well-versed in it.\n\nKeep in mind that when you do have a process compiled with PIE enabled, it's going to completely ignore the virtual address and any code there had better be relocatable:\n\n```\n(gdb) info proc mappings\nprocess 3550\nMapped address spaces:\n\n          Start Addr           End Addr       Size     Offset  Perms  objfile\n      0x555555554000     0x555555556000     0x2000        0x0  r--p   /home/osboxes/test2.o\n      0x555555556000     0x555555557000     0x1000     0x2000  r-xp   /home/osboxes/test2.o\n      0x555555557000     0x555555558000     0x1000     0x3000  r--p   /home/osboxes/test2.o\n      0x555555558000     0x55555555a000     0x2000     0x3000  rw-p   /home/osboxes/test2.o\n      0x555555561000     0x555555562000     0x1000     0x5000  r-xp   /home/osboxes/test2.o\n\n(gdb) x /16xb 0x555555561000\n0x555555561000: 0xcc    0xcc    0xcc    0xcc    0xcc    0xcc    0xcc    0xcc\n0x555555561008: 0xcc    0xcc    0xcc    0xcc    0xcc    0xcc    0xcc    0xcc\n\n```\n",
      "votes": "1",
      "user": "Nathan Smith",
      "time": "Sep 19, 2023 at 13:48",
      "is_accepted": false,
      "comments": []
    }
  ]
}