{
  "title": "Get interface definition of undocumented COM objects",
  "link": "https://reverseengineering.stackexchange.com/questions/19947/get-interface-definition-of-undocumented-com-objects",
  "content": "I have started exploring COM objects, initially I got to it from UAC bypass methods but I guess my question is general. The general question is: How can I get from (elevated) CLSID in the registry to calling the functions in the COM interface?. Explanation of the research I performed and my specific questions next. I will use IFileOperation COM (CLSID = 3AD05575-8857-4850-9277-11B85BDB8E09) and ICMLuaUtil COM (CLSID = 3E5FC7F9-9A51-4367-9063-A120244FBEC7) as an example in this post. \n\nCOM objects are listed in the registry under HKEY_CLASSES_ROOT\\CLSID. The default value has the COM name and the server DLL file. \n\nNow, in order to list the interfaces associated with it I used oleview, for IFileOperation it showed all the interfaces but for ICMLuaUtil it showed only the . \n\nEven after I get the interface name, I have to get the function list and signatures, this can be extracted from the idl file. A great answer presented here shows how to get from an interface name to its function signatures by examining the example code and searching for idl file with the same name as the imports in the sdk folder. I have tried applying similar approach with the two interfaces with partial success. \n\nOther methods I tried are:\n\nMy question is how do I get from the (sometimes undocumented) COM objects to concrete interface definition so I could use it in my code? The UACMe project has a concrete definition of the interface for ICMLuaUtil, so there must be a method to obtain it. What are the guidelines and steps to obtain those function signatures?\n\n",
  "votes": "4",
  "answers": 3,
  "views": "4k",
  "tags": [
    "windows",
    "dll",
    "functions",
    "com",
    "windows-10"
  ],
  "user": "Anton.P",
  "time": "Nov 22, 2018 at 19:50",
  "comments": [
    {
      "user": "0xC0000022L",
      "text": "Hi and welcome to RE.SE! I'm confused. One of the sentences trails off just like . And furthermore why do you think you need an interface name? IIDs/CLSIDs/GUIDs is all that COM will ever care about. It all starts with IUnknown and both the documentation (MSDN) as well as several books explain in great detail how to instantiate COM objects. However, those are all non-RCE topics. Whether there is an interface definition (IDL or otherwise) solely depends on the author. After all COM is meant to allow black-box objects to interact with each other. Only caller and callee need to know.",
      "time": null
    },
    {
      "user": "Anton.P",
      "text": "@0xC0000022L thanks for taking the time to understand the question. I do realize that functions which handle COMs (CoCreateInstance, CoGetObject..) require IIDs/CLSIDs only. Let me narrow the question, for ICMLuaUtil, where I got no interface name/idl file, how can I get the IID and how to figure out the method signatures for it? it was done before, and I wish to learn how to reproduce the results (github.com/hfiref0x/UACME/blob/â€¦)",
      "time": null
    },
    {
      "user": "Biswapriyo",
      "text": "@Anton.P Do you have the basic knowledge of C++ class, constructor, destructor, inheritance? I want to add some info.",
      "time": null
    },
    {
      "user": "Anton.P",
      "text": "@Biswapriyo yes I am familiar with C++ (know it well and familiar with the concepts you listed), and I would be glad to get more info",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "Now, this can't be a full-fledged answer from A to Z, unfortunately. But for COM there are only a few steps that are really specific to COM.\n\nThe project you linked clearly has reverse-engineered the interfaces (elvint.h). What this means first and foremost is that the names of the interfaces needn't necessarily match what Microsoft called them (in your case they match, though). However, if the binaries implementing the respective COM interfaces or their proxy DLL are official system files, PDB files can be fetched for them and even though Microsoft has severely cut down on public symbols, this often allows you to assign more meaningful names to functions/methods.\n\nOf course the author(s) of the linked project already knew what they were looking for and it seems to be system components that somehow \"magically\" are able to circumvent the typical UAC elevation prompt even though one should expect them to show one.\n\nNow say they found that the Connection Manager configuration (related to RAS) contained such functionality, they'd now go ahead and perform an action that you'd expect to require elevation but which doesn't. Then they'd look up the DLLs loaded into the process and either find an InProc server or a proxy leading them to an OutProc server.\n\nFailing the lookup step they could simply survey all the system DLLs, looking for the typical COM bunch of exported functions (the first being the most obvious):\n\n... and then inspect the version info resource. With the pefile module this becomes a simple Python scripting job. It's basically that first step you always have with RCE: intelligence gathering. It's not strictly RCE (as in sifting through or manipulating disassembly) but it's an intrinsic part of all the RCE jobs I've done so far.\n\nBut in your case you already used oleview.exe and therefore knew the most important information:\n\n\n\n... which is why I found your comment confusing:\n\nNow having found cmlua.dll to be the DLL to implement our (COM) object of interest, we can go ahead and load that into IDA (or another disassembler) and we will get prompted to load the debug symbol from Microsoft's symbol servers.\n\nAnd once the symbols are loaded we get to see this:\n\n\n\nLooks familiar?\n\nTo get the IDL you need to match the vtable of the CCMLuaUtil class to the interface pointer its DLL returns when asked for that specific class. Looking into DllGetClassObject will enable you to figure out the IID.\n\nNow from here on this is going to be the same old grunt job of making sense of the disassembly (or the pseudo code if you can afford the decompiler plugin).\n\nNow if we get lucky we can save a whole lot of time if the COM server (typically a DLL) in question contains a TYPELIB resource, which is the compiled version of an IDL and therefore the best starting point to get to an IDL quickly. For cmlua.dll we're out of luck, however.\n\nFurthermore if you had no symbols like with Windows components, you would have to dig yourself into the disassembly starting from DllGetClassObject which is well-known and well-documented and should be trivial to understand even for the layperson. Going from there and equipped with the knowledge that the three first methods of any COM interface are inherited from IUnknown you'd then try to make sense of the implementation of each method (apart from those well-known first three) and assign hopefully meaningful names to the functions and their parameters. That is: the whole task becomes a bit more tedious without debug symbols, but not at all impossible.\n\n",
      "votes": "5",
      "user": "0xC0000022L",
      "time": "Nov 23, 2018 at 10:03",
      "is_accepted": true,
      "comments": [
        {
          "user": "Anton.P",
          "text": "I can't even imagine a better answer than this one. Thank you so much. I tried loading the DLL with IDA and indeed after obtaining the symbols I see the signatures. There is a lot of information I need to parse, try out, and apply on my research. Thanks!!",
          "time": null
        }
      ]
    },
    {
      "content": "well the answers out there are good this is just an addition to show how you could arrive using windbg in command line\n\ndbh is an utility in windbg installation that can load any binary and provide a lot of static information \nusing it and the command line version of windbg cdb.exe you can get the methods in two commands (notice the method names are demangled)\n\n```\nC:\\>dbh c:\\Windows\\System32\\cmlua.dll  \"x CCM*\" | grep -i vf\n    11            1002d58 :   CCMLuaUtil::`vftable'\n\nC:\\>cdb -c \"dps cmlua.dll+2d58\" -z c:\\Windows\\System32\\cmlua.dll\n\nMicrosoft (R) Windows Debugger Version 10.0.16299.15 X86\nLoading Dump File [c:\\Windows\\System32\\cmlua.dll]\n\n\ncmlua!_DllMainCRTStartup:\n100061e7 8bff            mov     edi,edi\n\n0:000> cdb: Reading initial command 'dps cmlua.dll+2d58'\n\n10002d58  100042ad cmlua!CCMLuaUtil::QueryInterface\n10002d5c  10004e82 cmlua!CCMLuaUtil::AddRef\n10002d60  10004279 cmlua!CCMLuaUtil::Release\n10002d64  10004346 cmlua!CCMLuaUtil::SetRasCredentials\n10002d68  10004401 cmlua!CCMLuaUtil::SetRasEntryProperties\n10002d6c  100044dd cmlua!CCMLuaUtil::DeleteRasEntry\n10002d70  10004573 cmlua!CCMLuaUtil::LaunchInfSection\n10002d74  100045e1 cmlua!CCMLuaUtil::LaunchInfSectionEx\n10002d78  10004630 cmlua!CCMLuaUtil::CreateLayerDirectory\n10002d7c  1000466e cmlua!CCMLuaUtil::ShellExec\n10002d80  10004690 cmlua!CCMLuaUtil::SetRegistryStringValue\n10002d84  10004701 cmlua!CCMLuaUtil::DeleteRegistryStringValue\n10002d88  100055da cmlua!CCMLuaUtil::DeleteRegKeysWithoutSubKeys\n10002d8c  10004767 cmlua!CCMLuaUtil::DeleteRegTree\n10002d90  100048cc cmlua!CCMLuaUtil::ExitWindowsFunc\n10002d94  10005c72 cmlua!CCMLuaUtil::AllowAccessToTheWorld\n10002d98  100048d9 cmlua!CCMLuaUtil::CreateFileAndClose\n10002d9c  1000560f cmlua!CCMLuaUtil::DeleteHiddenCmProfileFiles\n10002da0  1000492a cmlua!CCMLuaUtil::CallCustomActionDll\n10002da4  10004b6c cmlua!CCMLuaUtil::RunCustomActionExe\n10002da8  10004c2c cmlua!CCMLuaUtil::SetRasSubEntryProperties\n10002dac  10004d0e cmlua!CCMLuaUtil::DeleteRasSubEntry\n10002db0  10004da7 cmlua!CCMLuaUtil::SetCustomAuthData\n10002db4  10005cdb cmlua!CCMLuaUtil::`vector deleting destructor'\n10002db8  00000000\n10002dbc  10009138 cmlua!hProxyDll+0x10\n10002dc0  10009188 cmlua!hProxyDll+0x60\n10002dc4  00000000\n10002dc8  69727453\n10002dcc  6343676e\n10002dd0  706f4368\n10002dd4  20784579\n0:000>\n\n```\nnow dbh has a switch -d which would output mangled names and you can leverage that switch to print the parameters to the Methods \n\n```\nC:\\>echo off\n\nfor /F %i in ('dbh -d c:\\Windows\\System32\\cmlua.dll  \"x *CCM*\"  ^| awk \"{print $4}\"') do  dbh c:\\windows\\system32\\cmlua.\ndll undec %i\n\n?Release@CCMLuaUtil@@UAGKXZ =\npublic: virtual unsigned long __stdcall CCMLuaUtil::Release(void)\n\n??_ECCMLuaUtil@@UAEPAXI@Z =\npublic: virtual void * __thiscall CCMLuaUtil::`vector deleting destructor'(unsigned int)\n\n??0CCMLuaUtil@@QAE@XZ =\npublic: __thiscall CCMLuaUtil::CCMLuaUtil(void)\n\n?AddRef@CCMLuaUtil@@UAGKXZ =\npublic: virtual unsigned long __stdcall CCMLuaUtil::AddRef(void)\n\n?CreateFileAndClose@CCMLuaUtil@@UAGJPBGKKKK@Z =\npublic: virtual long __stdcall CCMLuaUtil::CreateFileAndClose(unsigned short const *,unsigned long,unsigned long,unsigne\nd long,unsigned long)\n\n?DeleteHiddenCmProfileFiles@CCMLuaUtil@@UAGJPBG@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteHiddenCmProfileFiles(unsigned short const *)\n\n??_GCCMLuaUtil@@UAEPAXI@Z =\npublic: virtual void * __thiscall CCMLuaUtil::`scalar deleting destructor'(unsigned int)\n\n?SetRasSubEntryProperties@CCMLuaUtil@@UAGJPBG0KPAPAGK@Z =\npublic: virtual long __stdcall CCMLuaUtil::SetRasSubEntryProperties(unsigned short const *,unsigned short const *,unsign\ned long,unsigned short * *,unsigned long)\n\n?QueryInterface@CCMLuaUtil@@UAGJABU_GUID@@PAPAX@Z =\npublic: virtual long __stdcall CCMLuaUtil::QueryInterface(struct _GUID const &,void * *)\n\n?CCMLuaUtil_CreateInstance@@YGJABU_GUID@@PAPAX@Z =\nlong __stdcall CCMLuaUtil_CreateInstance(struct _GUID const &,void * *)\n\n?ExitWindowsFunc@CCMLuaUtil@@UAGJXZ =\npublic: virtual long __stdcall CCMLuaUtil::ExitWindowsFunc(void)\n\n?CreateLayerDirectory@CCMLuaUtil@@UAGJPBG@Z =\npublic: virtual long __stdcall CCMLuaUtil::CreateLayerDirectory(unsigned short const *)\n\n?LaunchInfSectionEx@CCMLuaUtil@@UAGJPBG0K@Z =\npublic: virtual long __stdcall CCMLuaUtil::LaunchInfSectionEx(unsigned short const *,unsigned short const *,unsigned lon\ng)\n\n?ShellExec@CCMLuaUtil@@UAGJPBG00KK@Z =\npublic: virtual long __stdcall CCMLuaUtil::ShellExec(unsigned short const *,unsigned short const *,unsigned short const\n*,unsigned long,unsigned long)\n\n?DeleteRasEntry@CCMLuaUtil@@UAGJPBG0@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteRasEntry(unsigned short const *,unsigned short const *)\n\n?DeleteRegistryStringValue@CCMLuaUtil@@UAGJHPBG0@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteRegistryStringValue(int,unsigned short const *,unsigned short const *)\n\n??_7CCMLuaUtil@@6B@ =\nconst CCMLuaUtil::`vftable'\n\n?LaunchInfSection@CCMLuaUtil@@UAGJPBG00H@Z =\npublic: virtual long __stdcall CCMLuaUtil::LaunchInfSection(unsigned short const *,unsigned short const *,unsigned short\n const *,int)\n\n?SetCustomAuthData@CCMLuaUtil@@UAGJPBG00K@Z =\npublic: virtual long __stdcall CCMLuaUtil::SetCustomAuthData(unsigned short const *,unsigned short const *,unsigned shor\nt const *,unsigned long)\n\n?DeleteRasSubEntry@CCMLuaUtil@@UAGJPBG0K@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteRasSubEntry(unsigned short const *,unsigned short const *,unsigned long\n)\n\n?DeleteRegTree@CCMLuaUtil@@UAGJHPBG@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteRegTree(int,unsigned short const *)\n\n?DeleteRegKeysWithoutSubKeys@CCMLuaUtil@@UAGJHPBGH@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteRegKeysWithoutSubKeys(int,unsigned short const *,int)\n\n?CallCustomActionDll@CCMLuaUtil@@UAGJPBG000PAK@Z =\npublic: virtual long __stdcall CCMLuaUtil::CallCustomActionDll(unsigned short const *,unsigned short const *,unsigned sh\nort const *,unsigned short const *,unsigned long *)\n\n?SetRegistryStringValue@CCMLuaUtil@@UAGJHPBG00@Z =\npublic: virtual long __stdcall CCMLuaUtil::SetRegistryStringValue(int,unsigned short const *,unsigned short const *,unsi\ngned short const *)\n\n?SetRasCredentials@CCMLuaUtil@@UAGJPBG00H@Z =\npublic: virtual long __stdcall CCMLuaUtil::SetRasCredentials(unsigned short const *,unsigned short const *,unsigned shor\nt const *,int)\n\n?SetRasEntryProperties@CCMLuaUtil@@UAGJPBG0PAPAGK@Z =\npublic: virtual long __stdcall CCMLuaUtil::SetRasEntryProperties(unsigned short const *,unsigned short const *,unsigned\nshort * *,unsigned long)\n\n?AllowAccessToTheWorld@CCMLuaUtil@@UAGJPBG@Z =\npublic: virtual long __stdcall CCMLuaUtil::AllowAccessToTheWorld(unsigned short const *)\n\n?RunCustomActionExe@CCMLuaUtil@@UAGJPBG0PAPAG@Z =\npublic: virtual long __stdcall CCMLuaUtil::RunCustomActionExe(unsigned short const *,unsigned short const *,unsigned sho\nrt * *)\n\n```\n",
      "votes": "3",
      "user": "blabb",
      "time": "Nov 25, 2018 at 16:33",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "This is just an extension of @0xC0000022L's answer. For this question, I will explain ICMLuaUtil COM interface below because IFileOperation COM interface is in shell32.dll, too big ;)\n\nYou mentioned the wrong CLSID. Here I provide a list of them:\n\n```\nGUID CLSID_CmstpLua = {3E5FC7F9-9A51-4367-9063-A120244FBEC7}\nGUID IID_ICmstpLua = {6EF07F29-F9B8-4DA4-B59E-13DEA060AD60}\nGUID IID_ICmstpLua2 = {AE8AFD54-5B57-4961-8A9B-12ADF23B696A}\n\nGUID CLSID_CMLuaUtil = {3E000D72-A845-4CD9-BD83-80C07C3B881F}\nGUID IID_ICMLuaUtil = {6EDD6D74-C007-4E75-B76A-E5740995E24C}\n\n```\nHow to find the DLL file path from CLSID without using any 3rd party program? Open this registry path HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{CLSID} in RegEdit. For this case, try this command:\n\n```\nREG Query \"HKLM\\SOFTWARE\\Classes\\CLSID\\{3E000D72-A845-4CD9-BD83-80C07C3B881F}\\InprocServer32\" /VE\nREG Query \"HKLM\\SOFTWARE\\Classes\\Interface\\{6EDD6D74-C007-4E75-B76A-E5740995E24C}\" /VE\n\n```\nThe path will be %SystemRoot%\\System32\\cmlua.dll. Open it in IDA (or any disassembler/decompiler) and load the PDB symbol file. Go to the functions window with Shift + F3 and search for the constructor or the destructor by typing those words in that window. Open that function in assembly view. There must be a variable like const CCMLuaUtil::vftable because you-know-why. Double click on it and you will see the layout of that COM class in assembly view. \n\n\n\nThere are many advantages of the assembly view. In the assembly view, all the methods in that class are placed in actual order but the functions windows may not (according to settings). The methods are actually placed as function pointers. For 64 bit binary there will be dq (qword 8 bytes) before every methods (in the above screenshot). The first three methods are inherited from IUnknown interface. If you are writing that class (as struct) in C, you've to include those three.\n\nSee another canonical answer for further reference. One can see a real example of this method in my repository GitHub: WslReverse where I showed the hidden COM interface of LxssManager.DLL. Also this video about Practical C++ Decompilation | Recon 2011 | Igor Skochinsky helped me a lot.\n\n",
      "votes": "2",
      "user": "Biswapriyo",
      "time": "Nov 25, 2018 at 15:41",
      "is_accepted": false,
      "comments": [
        {
          "user": "Anton.P",
          "text": "Thx for the extra information, I will of course go over it also, but I have a preliminary question, how do you know which interface relates to which CLSID? in oleview, CMLuaUtil doesn't have any interfaces associated with it",
          "time": null
        },
        {
          "user": "Anton.P",
          "text": "my question is how do you understand that IID_ICMLuaUtil is related to  CLSID_CMLuaUtil? (other than the name of course which is not mendatory, e.g. in the IFileOperation COM some of the supported interfaces doesnt share its name). The commands do reveal the DLLs but I fail to understand the general approach of fining the link between them",
          "time": null
        },
        {
          "user": "Biswapriyo",
          "text": "@Anton.P This would be the oversimplificated answer: i.sstatic.net/ZpIRF.png",
          "time": null
        }
      ]
    }
  ]
}