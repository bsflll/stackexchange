{
  "title": "An issue when unpacking UPX",
  "link": "https://reverseengineering.stackexchange.com/questions/5889/an-issue-when-unpacking-upx",
  "content": "Since I love to play with the WinAPI or debugging in general, I decided to write a small unpacker for the open source PE executable packer UPX today (Windows version).\n\nIn order to accomplish this, I proceeded as follow:\n\nAfter reaching the OEP, I proceed as follows in order to dump the process:\n\nAfter creating the dump with fixed OEP & RAW offsets/sizes for the sections, I fix the dump with ImpREC (right now manually, but I plan to use ImpREC.dll or the ImpREC lite source in order to assemble everything in one tool at a later point).\n\nThe thing that confuses me though, is the fact, that the resulting binaries worked perfectly fine (exact match with the MUP) for one test case (a small hello world fasm application) and my dump file was exactly the same I had received through OllyDump, but when I tried to do the same unpacking with an UPX packed version of putty.exe, my dumped memory varied from the one OllyDump had dumped starting at RAW offset 0x73970 (exact match before that address). \n\nHowever - the file size is again the same one (and all bytes before that offset match), just after that certain address the bytes magically won't match anymore (they are still non-zero though).\n\nI studied the source code in OllyDump.c thoroughly regarding this difference, but as for now I didn't find my mistake... In some cases my dumps are equal to the ones generated by OllyDump and in some they aren't. Or is the mistake probably in my approach already?\n\nNote: Source code omitted on purpose, since it's a few hundred lines long and super messy as for now. Can/will add further details if required or if I missed something, please just let me know in the comments.\n\n",
  "votes": "4",
  "answers": 1,
  "views": "1k",
  "tags": [
    "unpacking",
    "dumping",
    "upx"
  ],
  "user": "beta",
  "time": "Jul 18, 2014 at 20:28",
  "comments": [],
  "answers_data": [
    {
      "content": "Hard to tell what the reason for the differences might be without actually seeing the differences, but one guess is that you're doing ReadProcessMemory(hProcess, header32.ImageBase, buffer, header32.SizeOfImage, bytes_read), while the other tool may be doing foreach(section) {ReadProcessMemory(hProcess, header32.ImageBase + section.RVA, buffer, section.VirtualSize, bytes_read)}; this may cause the \"caves\" between sections to differ.\n\n(BTW, I assume your header32.ImageBase is the actual base address of the module in memory, not just the image base address from the PE headers, since ASLR could relocate it at runtime.)\n\n",
      "votes": "1",
      "user": "Jason Geffner",
      "time": "Jul 18, 2014 at 14:03",
      "is_accepted": true,
      "comments": [
        {
          "user": "beta",
          "text": "Thank you I gotta check this out next week (forgot my laptop at the office).",
          "time": null
        }
      ]
    }
  ]
}