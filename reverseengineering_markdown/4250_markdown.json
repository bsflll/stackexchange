{
  "title": "Why addresses of variable on stack are not consecutive?",
  "link": "https://reverseengineering.stackexchange.com/questions/4250/why-addresses-of-variable-on-stack-are-not-consecutive",
  "content": "The code below is generated by gcc from a simple scanf program. \nMy question is that \n\nC code \n\n```\n#include <stdio.h>\nint main() {\n  int x;\n  printf (\"Enter X:  \n\");\n  scanf (\"%d\", &x);\n  printf (\"You entered %d...  \n\", x);\n  return 0;\n};\n\n```\nasm\n\n```\nmain            proc near\nvar_20          = dword ptr -20h\nvar_1C          = dword ptr -1Ch\nvar_4           = dword ptr -4\n                push    ebp\n                mov     ebp, esp\n                and     esp, 0FFFFFFF0h\n                sub     esp, 20h\n                mov     [esp+20h+var_20], offset aEnterX ; \"Enter X:\"\n                call    _puts\n                mov     eax, offset aD  ; \"%d\"\n                lea     edx, [esp+20h+var_4]\n                mov     [esp+20h+var_1C], edx\n                mov     [esp+20h+var_20], eax\n                call    ___isoc99_scanf\n                mov     edx, [esp+20h+var_4]\n                mov     eax, off set aYouEnteredD___ ; \"You entered %d...  \n\"\n                mov     [esp+20h+var_1C], edx\n                mov     [esp+20h+var_20], eax\n                call    _printf\n                mov     eax, 0\n                leave\n                retn\nmain            endp\n\n```\n",
  "votes": "4",
  "answers": 4,
  "views": "1k",
  "tags": [
    "disassembly",
    "assembly",
    "x86",
    "c"
  ],
  "user": "upton",
  "time": "May 3, 2014 at 17:43",
  "comments": [],
  "answers_data": [
    {
      "content": "There is only actually one local variable in your function: x. This variable is located on the stack where you would expect it, at ebp-4. IDA is getting confused because this particular function, instead of pushing variables onto the stack before calling a function, is moving them instead. This tricks IDA into thinking those are local variables when they're actually just the locations at the top of the stack.\n\n```\nmov     [esp+20h+var_1C], edx  <===> push edx\nmov     [esp+20h+var_20], eax  <===> push eax\n\n```\nI can't definitively explain why gcc is doing this, but my guess is that you compiled without optimizations. This instruction layout might make debugging easier.\n\nI think you're also confusing calling conventions with local variable cleanup. Every function needs to clean up its own local variable area. Your main() function is doing that with the leave instruction. Calling conventions are related to cleaning up the parameters passed to a function.\n\n",
      "votes": "5",
      "user": "Community",
      "time": "May 23, 2017 at 12:37",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "there is no add esp ,20 because of the leave instruction (LEAVE PROCDURE ) instruction \n\nquoted ftom intel instruction manual\n\n```\n6.5.2 LEAVE Instruction\nThe LEAVE instruction, which does not have any operands, reverses the action of the previous ENTER instruction. \nThe LEAVE instruction copies the contents of the EBP register into the ESP register to release all stack space allocated to the procedure. Then it restores the old value ofthe EBP register from the stack. This simultaneously \nrestores the ESP register to its original value. A subsequent RET instruction then can remove any arguments and \nthe return address pushed on the stack by the calling program for use by the procedure.\n\n```\nas to the other part in your question i guess it is because the compiler didn't generate any push argument instruction it utilises the top part for moving the args into stack \nand bottom part for varargs storage \n\n```\nmov [esp],%d\nmov [esp+4] , ADDR where to store the input ie ADDR of [esp+1c]\n\n```\n",
      "votes": "3",
      "user": "blabb",
      "time": "May 3, 2014 at 17:44",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "There's actually only one stack variable in this function: var_4\n\nIn the disassembly above, IDA incorrectly detects arguments passed to _puts(), ___isoc99_scanf(), and _printf() as local stack variables. To see this, let's analyze the following snippet:\n\n```\nmov     [esp+20h+var_20], offset aEnterX ; \"Enter X:\"\ncall    _puts\n\n```\nvar_20 is defined by IDA at the beginning of this function as -20h, so mov [esp+20h+var_20], offset aEnterX is effectively saying mov [esp+20h+-20h], offset aEnterX, which is the same as mov [esp], offset aEnterX. In other words, the code is just pushing offset aEnterX onto the stack before calling _puts(), and IDA is unfortunately detecting that \"alternative push\" as a local stack variable.\n\n",
      "votes": "3",
      "user": "Jason Geffner",
      "time": "May 3, 2014 at 17:48",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "(I deal more with code generated by Visual C++, so some parts of this answer are just educated guesses.)\n\nVariable alignment and even presence on the stack is up to the compiler and can differ based on the specific compiler version you use, the optimization options being used, and other factors.\n\nThe 3 variables in your example are not all \"real\" variables. var_4 is the variable corresponding to your x, whereas var_1C and var_20 are simply results of GCC's approach to passing arguments to deeper function calls. When you write scanf(\"%d\", &x);, GCC knows that it will need to pass two 4-byte variables to that function on the stack, so it pre-emptively reserves enough room for them upon entering the function. This way, it doesn't need to push anything onto the stack (which might be problematic if there's no stack space left...), it just needs to mov the arguments into that preallocated space.\n\nThat doesn't explain why there's a gap between the two allocations, though. GCC also prefers to align stack allocations to 16 bytes1, and this is where I am guessing it seems that the sizes needed for \"real local variables\" and \"space reserved for deeper function arguments\" are aligned independently before being summed into the final value of \"reserved stack space\".\n\n1You can control this alignment by using -mpreferred-stack-boundary=num.\n\nAs you can see in this example, that instruction does not always get generated. Its counterpart, sub esp, N, is a much better indicator. From that you can make educated guesses about the amount/sizes of local variables.\n\nCalling convention is not related to a function's local variables, it controls the way the arguments are passed into the function and whose responsibility it is to clean them up afterwards.\n\nThe function in your example begins with push ebp; mov ebp, esp, which saves the original values of both ebp and esp. The leave instruction at the end does the reverse - it restores the saved values of esp and ebp, so there's no need to calculate anything.\n\nThe saved ebp is also known as a frame pointer. It is possible to instruct the compiler not to generate it, in which case the original value of esp needs to be restored using that calculation you mentioned.\n\n",
      "votes": "2",
      "user": "Community",
      "time": "May 23, 2017 at 12:37",
      "is_accepted": false,
      "comments": []
    }
  ]
}