{
  "title": "How to organize vtables in IDA Pro?",
  "link": "https://reverseengineering.stackexchange.com/questions/11811/how-to-organize-vtables-in-ida-pro",
  "content": "I am using IDA Pro to disassemble a C++ behemoth with 1600+ classes, many of them having pure virtual methods.\n\nSome classes also are made up of multiple base classes, in hierarchies 5+ levels deep.\n\nIda PRO supports making structures of pointers, to handle vtables, but some of the final classes can have multiple different vtables in the same \"slot\", due to heavy polymorphism, so how you organize the vtables? How you tell IDA that in this method, or that method, what vtable is actually being refered to?\n\n",
  "votes": "23",
  "answers": 1,
  "views": "21k",
  "tags": [
    "ida",
    "c++",
    "hexrays"
  ],
  "user": "speeder",
  "time": "Jan 20, 2016 at 18:29",
  "comments": [
    {
      "user": "Jongware",
      "text": "Funny enough I solved this once for a class heavy executable by writing my own disassembler. At its current state it can gather class members and functions from several DLLs. But not a general solution: the code relies extremely on the particular compiler the code was written with.",
      "time": null
    },
    {
      "user": "speeder",
      "text": "Why I was downvoted?",
      "time": null
    },
    {
      "user": "sudhackar",
      "text": "Athough this question is quite old try using HexRaysPyTools for hexrays",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "This depends on the compiler originally used as each creates slightly different layouts. You can find tutorials for most compilers on the net, I'm going to focus MSVC as that's the one I have experience with, and since it provides a hidden compiler switch printing how classes will be layouted in memory which I'm going to use for illustration.\n\nAs you might have already guessed, you have to recreate C++ classes with C structs. This is possible but bothersome, especially if you have as many classes as you said. Some tips to make it less annoying:\n\nDepending on how fancy your polymorphism is, your C structs have to be more or less fancy aswell. So let's start with the simple cases first and work our way to the more complicated ones.\n\nNo inheritance (base class)\n\nThe simplest case does not use any inheritance at all, only some members and (pure) virtual methods to start with:\n\n```\nclass Animal {\n    int _age;\n    Animal() { _age = 0; }\n    int getAge() { return _age; }\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() = 0;\n};\n\n```\nMSVC layout:\n\n```\nclass Animal    size(8):\n        +---\n 0      | {vfptr} // pointer to the vftable (s. below)\n 4      | _age    // members of Animal\n        +---\n\nAnimal::$vftable@:\n        | &Animal_meta    // ignore meta for our examples\n        |  0              // the (pure) virtual method follow\n 0      | &Animal::setAge    \n 1      | &Animal::makeSound\n\n```\nIDA representation:\n\n```\nstruct Animal;\nstruct Animal_vtbl {\n  void (__thiscall *setAge)(Animal *this, int value);\n  void (__thiscall *makeSound)(Animal *this);\n};\nstruct Animal_mbrs {\n  int _age;\n};\nstruct Animal {\n  Animal_vtbl *__vftable;\n  Animal_mbrs __members;\n};\n\n```\nSingle inheritance\n\nLet's quickly breed a Dog inheriting from Animal, implement the makeSound method, and add a new virtual method to set the fur color:\n\n```\nclass Dog : public Animal {\n    int _furColor;\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() { cout << \"Woof Woof\"; }\n    virtual void setFurColor(int color) { _furColor = color; }\n};\n\n```\nMSVC layout: The Animal base class is simply embedded inside the Dog class. The embedded Animal vftable also grabs all the virtual Dog methods and adds them at its end. The members of Dog appear behind Animals members:\n\n```\nclass Dog       size(12):\n        +---\n 0      | +--- (base class Animal)\n 0      | | {vfptr}\n 4      | | _age\n        | +---\n 8      | _furColor\n        +---\n\nDog::$vftable@:\n        | &Dog_meta\n        |  0\n 0      | &Dog::setAge\n 1      | &Dog::makeSound\n 2      | &Dog::setFurColor // Added behind the Animal methods!\n\n```\nIDA representation: Leaving Animal structures untouched, we add the following:\n\n```\nstruct Dog;\nstruct Dog_vtbl : Animal_vtbl {\n  void (__thiscall *setFurColor)(Dog *this, int color);\n};\nstruct Dog_mbrs : Animal_mbrs {\n  int _furColor;\n};\nstruct Dog {\n  Dog_vtbl *__vftable;\n  Dog_mbrs __members;\n};\n\n```\nMultiple inheritance\n\nThis requires a bit of mind-mangling. For this, we make it possible to kill our dog (sorry if that's cruel to you, I'm bad at creating happy examples):\n\n```\nclass Killable {\n    bool _isDead;\n    virtual void kill() { makeDeathSound(); _isDead = true; }\n    virtual void makeDeathSound() = 0;\n};\n\nclass Dog : public Animal, public Killable {\n    int _furColor;\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() { cout << \"Woof Woof\"; }\n    virtual void setFurColor(int color) { _furColor = color; }\n    virtual void makeDeathSound() { cout << \"I'll call WWF, bark-blerg\"; }\n};\n\n```\nMSVC layout: As with the Animal base class, it embeds the second Killable base class into the Dog class aswell, and keeps Dogs members separate. While Dog-specific virtual methods are still merged with the Animal vftable (aka the first base class), Killable related ones are in a separate Killable-related vftable, so we now have:\n\n```\nclass Dog       size(20):\n        +---\n 0      | +--- (base class Animal)\n 0      | | {vfptr}\n 4      | | _age\n        | +---\n 8      | +--- (base class Killable)\n 8      | | {vfptr}\n12      | | _isDead\n        | | <alignment member> (size=3) // since _isDead is a 1-byte bool\n        | +---\n16      | _furColor\n        +---\n\nDog::$vftable@Animal@:\n        | &Dog_meta\n        |  0\n 0      | &Dog::setAge\n 1      | &Dog::makeSound\n 2      | &Dog::setFurColor // Dog methods still merged with Animal!\n\nDog::$vftable@Killable@: // All the Killable-related methods in here\n        | -8 // offset for `this` pointer in Killable methods to get a Dog pointer\n 0      | &Killable::kill\n 1      | &Dog::makeDeathSound\n\n```\nIDA representation: We keep a Dog-specific vftable at the start which reuses the Animal vftable internally, as the Dog virtual methods are still appended to Animals vftable. Then Animals members follow as usual. Now, the untouched Killable structs follow, since nothing gets merged into them. At the end, our Dog members follow. If you compare this to the offsets MSVC printed, it makes sense:\n\n```\nstruct Killable;\nstruct Killable_vtbl {\n    void (__thiscall *kill)(Killable *this);\n    void (__thiscall *makeDeathSound)(Killable *this);\n};\nstruct Killable_mbrs {\n    bool _isDead;\n};\nstruct Killable {\n  Killable_vtbl* __vftable;\n  Killable_mbrs __members;\n};\n\nstruct Dog;\nstruct Dog_vtbl : Animal_vtbl {\n  void (__thiscall *setFurColor)(Dog *this, int color);\n};\nstruct Dog_mbrs { // No more base Animal members as they're split up now!\n  int _furColor; \n};\nstruct Dog {\n  Dog_vtbl *__vftable; // Still contains animal methods.\n  Animal_mbrs __members_Animal; // Animal members come here separately.\n  Killable_vtbl *__vftable_Killable;\n  Killable_mbrs __members_Killable;\n  Dog_mbrs __members;\n};\n\n```\nLet's see how this looks like in the Dog::ctor pseudocode:\n\n```\nDog *__thiscall Dog::ctor(Dog *this)\n{\n  j_Animal::ctor((Animal *)this);\n  j_Killable::ctor((Killable *)&this->__vftable_Killable);\n  this->__vftable = (Dog_vftable *)&Dog::`vftable';\n  this->__vftable_Killable = (Killable_vftable *)&Dog::`vftable';\n  return this;\n}\n\n```\nAs typical for constructors, the base class constructors are called first. Then, the vftables required for Dog are set. But something doesn't make sense: Why is Dog::vftable assigned to our __vftable_Killable? Well, I used IDA 7.0's naming here, and what I previously mentioned is that it doesn't mark which vftable maps to which base class anymore (unlike the script). With the IDA 6.0 or my IDAPython script, it would say:\n\n```\nDog *__thiscall Dog::ctor(Dog *this)\n{\n  j_Animal::ctor((Animal *)this);\n  j_Killable::ctor((Killable *)&this->__vftable_Killable);\n  this->__vftable = (Dog_vftable *)&Dog::`vftable for Animal';\n  this->__vftable_Killable = (Killable_vftable *)&Dog::`vftable for Killable';\n  return this;\n}\n\n```\nNow the names aren't the same and make more sense, so don't get busted by this IDA 7 annoyance, double click the names to check where they'll actually lead.\n\nBonus: Classes inherited from classes using multiple inheritance (wew)\n\nThis one kept me a little baffled for some time, maybe because it's not covered in most tutorials on the net on which I so rely on, or maybe because I'm just dumb. Let's inherit from Dog with our Terrier class.\n\n```\nclass Terrier : public Dog {\n    int _annoyanceLevel;\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() { cout << \"Bark Bark not Woof Woof\"; }\n    virtual void annoy() { _annoyanceLevel++; }\n};\n\n```\nMSVC layout: It doesn't seem too special. The Animal vftable still merges the new virtual methods of our Terrier, and everything else has its separate vftable:\n\n```\nclass Terrier   size(24):\n        +---\n 0      | +--- (base class Dog)\n 0      | | +--- (base class Animal)\n 0      | | | {vfptr}\n 4      | | | _age\n        | | +---\n 8      | | +--- (base class Killable)\n 8      | | | {vfptr}\n12      | | | _isDead\n        | | | <alignment member> (size=3)\n        | | +---\n16      | | _furColor\n        | +---\n20      | _annoyanceLevel\n        +---\n\nTerrier::$vftable@Animal@:\n        | &Terrier_meta\n        |  0\n 0      | &Terrier::setAge\n 1      | &Terrier::makeSound\n 2      | &Dog::setFurColor\n 3      | &Terrier::annoy // Animal even takes the Terrier methods (greedy!)\n\nTerrier::$vftable@Killable@:\n        | -8\n 0      | &Killable::kill\n 1      | &Dog::makeDeathSound\n\n```\nIDA representation: It's pretty similar to our first Dog struct creation, just that we need to respect the second base class of Dog aswell.\n\n```\nstruct Terrier_vtbl : Dog_vtbl {\n  void (__thiscall *annoy)(Terrier *this);\n};\nstruct Terrier_mbrs : Dog_mbrs {\n  int _annoyanceLevel;\n};\nstruct Terrier {\n  Terrier_vtbl *__vftable;\n  Animal_mbrs __members_Animal;\n  Killable_vtbl *__vftable_Killable;\n  Killable_mbrs __members_Killable;\n  Terrier_mbrs __members;\n};\n\n```\n",
      "votes": "39",
      "user": "Ray",
      "time": "Mar 16, 2023 at 10:35",
      "is_accepted": false,
      "comments": [
        {
          "user": "savram",
          "text": "Is \"__thiscall\" necessary to work?",
          "time": null
        },
        {
          "user": "Trass3r",
          "text": "For reference here's what 7.2+ generates: hex-rays.com/products/ida/support/idadoc/1691.shtml",
          "time": null
        }
      ]
    }
  ]
}