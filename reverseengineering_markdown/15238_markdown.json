{
  "title": "Is there a way to debug an elf file that runs with no problems with damaged header?",
  "link": "https://reverseengineering.stackexchange.com/questions/15238/is-there-a-way-to-debug-an-elf-file-that-runs-with-no-problems-with-damaged-head",
  "content": "My question is general, but to have an example to work with, let us take one from Whirlwind Tutorial. \n\n```\n; tiny.asm\nBITS 32\n          org     0x00010000\n          db      0x7F, \"ELF\"             ; e_ident\n          dd      1                                       ; p_type\n          dd      0                                       ; p_offset\n          dd      $$                                      ; p_vaddr \n          dw      2                       ; e_type        ; p_paddr\n          dw      3                       ; e_machine\n          dd      _start                  ; e_version     ; p_filesz\n          dd      _start                  ; e_entry       ; p_memsz\n          dd      4                       ; e_phoff       ; p_flags\n_start:\n          mov     bl, 42                  ; e_shoff       ; p_align\n          xor     eax, eax\n          inc     eax                     ; e_flags\n          int     0x80\n          db      0\n          dw      0x34                    ; e_ehsize\n          dw      0x20                    ; e_phentsize\n          db      1                       ; e_phnum\n                                          ; e_shentsize\n                                          ; e_shnum\n                                          ; e_shstrndx\n\nfilesize      equ     $ - $$  ; tiny.asm\n\n```\nTo get a binary compile with nasm -f bin -o tiny nasm.asm;chmod +x tiny. Executable in it self, is a bit of tiny monster. It is smaller than ELF header, yet contains ELF header, program header and program code - yet Linux (at least on my 64 Debian) runs it. \n\nI would like to be able to debug this types files that have (intentionally or not) damaged/incorrect elf header. Is there a tool to fix elf header? Is there debugger that will manage to run this file?\n\nWhat I tried is to get entry point: readelf -h tiny but readelf refuses even to look at the file: readelf: Error: tiny: Failed to read file header. objdump is no better.  \n\nRunning rabin2 -e tiny we get entry address (with some warnings):\n\n```\n[Entrypoints]\nvaddr=0x00010020 paddr=0x00010020 baddr=0x00000000 laddr=0x00000000 haddr=0x00000018 type=program\n\n```\nI managed to get some dissasembly using radare2 tiny and pd command:\n\n```\n [0x00010020]> pd\n        ;-- entry0:\n        0x00010020      b32a           mov bl, 0x2a                ; '*' ; 42\n        0x00010022      31c0           xor eax, eax\n        0x00010024      40             inc eax\n        0x00010025      cd80           int 0x80\n        0x00010027      003400         add byte [eax + eax], dh\n        0x0001002a      2000           and byte [eax], al\n        ;-- section_end.uphdr:\n        0x0001002c  ~   01ff           add edi, edi\n\n```\nNext I tried gdb tiny, lldb tiny but neither worked. Free version 5.0 of IDA stops at infinite loop. \n\nSo is there a way to repair elf in automatic/semi-automatic way? Or maybe some other trick that would allow debugging this (or similar) binary? One idea that comes to my mind is to patch entry point with instruction that loops and attach gdb. Would that work?\n\nIf no tool for repairing elf exists, which files in kernel source contain code responsible for loading binary?\n\n",
  "votes": "4",
  "answers": 1,
  "views": "3k",
  "tags": [
    "debugging",
    "linux",
    "elf"
  ],
  "user": "Tahtisilma",
  "time": "Apr 27, 2017 at 11:39",
  "comments": [
    {
      "user": "Igor Skochinsky",
      "text": "try padding it with zeroes",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "Several options are available for analyzing ELF binaries with damaged or corrupted headers. These include, but are not limited to:\n\nThis particular binary is a challenge for standard tools for a few reasons:\n\nRadare2 is able to attach to the process:\n\n```\n$ r2 -d tiny-i386 \nProcess with PID 6756 started...\n= attach 6756 6756\nbin.baddr 0x00010000\nUsing 0x10000\nWarning: Cannot initialize program headers\nWarning: Cannot initialize section headers\nWarning: Cannot initialize strings table\nWarning: Cannot initialize dynamic strings\nWarning: Cannot initialize dynamic section\nWarning: read (init_offset)\nasm.bits 32\n[0x00010020]> pd 5\n            ;-- eip:\n            0x00010020      b32a           mov bl, 0x2a                ; '*' ; 42\n            0x00010022      31c0           xor eax, eax\n            0x00010024      40             inc eax\n            0x00010025      cd80           int 0x80\n            0x00010027      003400         add byte [eax + eax], dh\n[0x00010020]>\n\n```\nFor such a small program, something like r2 seems rather heavyweight. There are only 7 bytes of instructions.\n\nOne can also roll their own ptrace-based debugger. A good guide for this can be found\nat How debuggers work: Part 1 - Basics .\n\nEmulation is easy in this case since the program is so simple. Emulation is a good solution for this kind of challenge since no information is needed besides the offsets of the first and last instructions. This information can be retrieved manually from a hex dump without needing to parse the header at all.\n\nHere is a script for emulating the binary in the question:\n\n```\n#!/usr/bin/python3\n\nfrom unicorn import *\nfrom unicorn.x86_const import *\nfrom capstone import *\nimport struct\n\n\nBASE = 0x100000\nSTACK_ADDR = 0x0\nSTACK_SIZE = 1024 * 1024\n\ndef read(name):\n   with open(name, 'rb') as f:\n      return f.read()\n\n#https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/shellcode.py\n# callback for tracing instructions\ndef hook_code(uc, address, size, user_data):\n    instruction = uc.mem_read(address, size)    # read this instruction code from memory\n    md = user_data\n    for i in md.disasm(instruction, address):\n        print(\">>> Tracing instruction at 0x%x, instruction size = 0x%x, disassembly:\\t%s\\t%s\" %(i.address, i.size, i.mnemonic, i.op_str))\n\n\n# callback for tracing Linux interrupt\ndef hook_intr(uc, intno, user_data):\n    # only handle syscall\n    if intno != 0x80:\n        print(\"got interrupt %x ???\" %intno);\n        uc.emu_stop()\n        return\n\n    eax = uc.reg_read(UC_X86_REG_EAX)\n    eip = uc.reg_read(UC_X86_REG_EIP)\n\n    print(\">>> 0x%x: INTERRUPT: 0x%x, EAX = 0x%x\" %(eip, intno, eax))\n\n    uc.emu_stop()\n\n\n\ndef main():\n\n    mu = Uc(UC_ARCH_X86, UC_MODE_32)    # initialize emulation engine class\n    mu.mem_map(BASE, STACK_SIZE)    # allocate space at base address\n    mu.mem_map(STACK_ADDR, STACK_SIZE)  # allocate space for stack\n\n    mu.mem_write(BASE, read(\"./tiny_binaries/tiny-i386\"))   # write file to memory\n    mu.reg_write(UC_X86_REG_ESP, STACK_ADDR + STACK_SIZE - 1)   # initialize stack\n\n    md = Cs(CS_ARCH_X86, CS_MODE_32)    # initialize disassembler engine class\n\n    # add hooks\n    mu.hook_add(UC_HOOK_CODE, hook_code, md)    # pass disassembler engine to hook\n    mu.hook_add(UC_HOOK_INTR, hook_intr)\n\n    mu.emu_start(BASE + 0x20, BASE + 0x27)\n\n    print(\">>> Emulation Complete.\")\n\nif __name__ == \"__main__\":\n    main()\n\n```\nThe following output is produced by the emulated execution of the binary:\n\n```\n$ ./emulate_tiny-i386.py \n>>> Tracing instruction at 0x100020, instruction size = 0x2, disassembly:   mov bl, 0x2a\n>>> Tracing instruction at 0x100022, instruction size = 0x2, disassembly:   xor eax, eax\n>>> Tracing instruction at 0x100024, instruction size = 0x1, disassembly:   inc eax\n>>> Tracing instruction at 0x100025, instruction size = 0x2, disassembly:   int 0x80\n>>> 0x100025: INTERRUPT: 0x80, EAX = 0x1\n>>> Emulation Complete.\n\n```\nA full write-up can be found here: Analyzing ELF Binaries with Malformed Headers Part 1 - Emulating Tiny Programs. Full disclosure: I'm the author of the article.\n\nSince the entirety of the program is contained within the header, repairing it means rebuilding the binary. The program header table must be separated from the ELF header, the code then must be appended to the end of the program header table, and finally the entry point must be recalculate to point to the new offset of the first instruction in the binary. In this particular case, this can be done relatively straightforwardly using a tool called lepton (I am the developer). Here is the script to accomplish rebuilding the binary:\n\n```\n#!/usr/bin/python3\n\nfrom lepton import *\n\ndef main():\n    # create new headers\n    with open(\"tiny-i386\", \"rb\") as f:\n        elf_file = ELFFile(f, new_header=True)\n\n    # recompose binary\n    with open(\"repaired_tiny-i386\", \"wb\") as f:\n        f.write(elf_file.recompose_binary())    # this moves the program header out of the file\n                                                # header and recalculates the entry point\n    print(\"  \n\\tRepaired header field values:  \n\")\n    elf_file.ELF_header.print_fields()          # call once entry point has been recalculated\n\n\nif __name__==\"__main__\":\n    main()\n\n```\nAfter being rebuilt, readelf can successfully parse the new binary:\n\n```\n$ readelf -h repaired_tiny-i386 \nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x10054\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          0 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         1\n  Size of section headers:           0 (bytes)\n  Number of section headers:         0\n  Section header string table index: 0\n\n$ readelf -l repaired_tiny-i386 \n\nElf file type is EXEC (Executable file)\nEntry point 0x10054\nThere is 1 program header, starting at offset 52\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  LOAD           0x000000 0x00010000 0x00030002 0x10020 0x10020 R   0xc0312ab3\n\n```\nThe runtime behavior of the new file is identical to the original:\n\n```\n$ strace ./repaired_tiny-i386 \nexecve(\"./repaired_tiny-i386\", [\"./repaired_tiny-i386\"], 0x7ffd19a0f1b0 /* 52 vars */) = 0\nstrace: [ Process PID=5822 runs in 32 bit mode. ]\nexit(42)                                = ?\n+++ exited with 42 +++\n\n```\nMore details, information and examples can be found in the description of the lepton repository.\n\nIn general, if the binary executes, it should be possible to attach ptrace. GDB, however, is very brittle and is easy to render useless. Emulation seems to be the most robust solution, since parsing the ELF header is largely unecessary and one can hook any instruction executed (total control, essentially). \n\nOn a final note, a detailed presentation of how the kernel loads ELF programs can be found in the LWN article How programs get run: ELF binaries. Included in the discussion are links to relevant code in the kernel.\n\n",
      "votes": "4",
      "user": "julian",
      "time": "Oct 1, 2019 at 16:58",
      "is_accepted": false,
      "comments": []
    }
  ]
}