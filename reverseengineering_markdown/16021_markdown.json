{
  "title": "What compression algorithm is this?",
  "link": "https://reverseengineering.stackexchange.com/questions/16021/what-compression-algorithm-is-this",
  "content": "I've reversed the following decompression algorithm from a game. It appears to be some variant of LZ77, however none of the descriptions of variants seem quite close enough what I've got. Is this a specific flavor of LZ77, and if not, how would I go about creating an equivalent compression method? The files have no header.\n\n```\nunsigned int decompress(uint8_t *decompressed, uint8_t *compressed)\n{\n    uint32_t distance, length, i, j;\n    uint8_t temp, *compressed_ptr = compressed,\n        *decompressed_ptr = decompressed, *backwards_ptr = NULL;\n\n    while (1)\n    {\n        temp = *(compressed_ptr++);\n        length = (temp & 7) + 1;\n        distance = temp >> 3;\n\n        if (distance == 0x1E)\n            distance = *(compressed_ptr++) + 0x1E;\n        else if (distance > 0x1E)\n        {\n            distance += *compressed_ptr;\n            distance += (*(++compressed_ptr) << 8) + 0xFF;\n            compressed_ptr++;\n            if (distance == 0x1011D)\n                length--;\n        }\n\n        if (distance != 0)\n        {\n            memcpy(decompressed_ptr, compressed_ptr, distance);\n            decompressed_ptr += distance;\n            compressed_ptr += distance;\n        }\n\n        for (i = length; i > 0; i--)\n        {\n            temp = *(compressed_ptr++);\n            length = temp & 7;\n            distance = temp >> 3;\n\n            if (length == 0)\n            {\n                length = *(compressed_ptr++);\n                if (length == 0)\n                {\n                    return (uintptr_t)decompressed_ptr -\n                        (uintptr_t)decompressed;\n                }\n                length += 7;\n            }\n\n            if (distance == 0x1E)\n                distance = *(compressed_ptr++) + 0x1E;\n            else if (distance > 0x1E)\n            {\n                distance += *compressed_ptr;\n                distance += (*(++compressed_ptr) << 8) + 0xFF;\n                compressed_ptr++;\n            }\n\n            backwards_ptr = decompressed_ptr - distance - 1;\n            for (j = length; j > 0; j--)\n                *(decompressed_ptr++) = *(backwards_ptr++);\n        }\n    }\n}\n\n```\n",
  "votes": "8",
  "answers": 2,
  "views": "1k",
  "tags": [
    "decompress"
  ],
  "user": "kirby",
  "time": "Aug 6, 2017 at 17:22",
  "comments": [],
  "answers_data": [
    {
      "content": "As you say it is an LZ77 style format, however I could not find a specific algorithm which it matches.  The compressed data forms a number of blocks, each of which contain at least one of some data, or some back references.\n\nBased on the code I've put together a listing of the data structure of the compressed data.\n\nThe format of each block is as follows:\n\n```\nSection                | Length\n-----------------------|-------\nHeader                 | 1 to 3 Bytes (see header explanation)\nData                   | 0 to 0x1011D (65821) Bytes\nBack references        | 0 to 8 occurences of 1 to 4 Bytes (see back reference explanation)\n\n```\nThe header is as follows:\n\n```\nSection                | Length\n-----------------------|-------\nNum Back References    | 3 bits\nData Length            | 5 bits\nAdditional Data Length | 0 to 2 Bytes\n\n```\nThe number of back references is encoded into the first 3 bits as a 1 indexed number, allowing a number from 1 (0b000) to 8 (0b111).\nIn the case that more than 8 back references are required a data length of 0 can be set so you can have several consecutive blocks containing only back references.\n\nThe data length is encoded into the next 5 bits.\nIf the data length is less than 0x1E (30) then it is encoded directly into the top 5 bits of the header.\nIf it is between 0x1E and 0x11E (286) then a single additional byte will be used, this byte should be the length of the data - 0x11E.\nIf it is between 0x11E and 0x1011D (65821) then two additional bytes are used as a 16 bit number, which should be the length of the data - 0x11E.\n\nIf the data length is the maximum possible (0x1011D) then the number of back references is reduced by one, allowing 0 back references.  This allows consecutive data sections without back references.\n\nThe format of the back references is similar to that of the header:\n\n```\nSection                | Length\n-----------------------|-------\nData Length            | 3 bits\nData Distance          | 5 bits\nAdditional Data Length | 0 to 1 Byte\nAdditional Distance    | 0 to 2 Bytes\n\n```\nThe length of data (in bytes) to which the reference refers is encoded into the first 3 bits, allowing length of 0 - 7.\nIf the length is greater than 7 then these 3 bits are set to 0 and an additional byte is added, containing the length - 7, this allows lengths of up to 262 bytes.\n\nThe distance represents the position of the back reference, in bytes back from the current end of the decompressed data.  The distance and additional distance bytes are calculated in the same way as the Data Length in the header.\n\nWhen set, each back reference will copy the calculated data length in bytes from current_position - distance - 1 to the output stream.\n\nThere is a special case of a back reference with the length and additional length set to 0.  This signifies the end of the stream, and the decompressor will return.\n\nThe overall format of a block is reasonably evident from the code, however didn't really make sense until I'd worked out the reasoning behind the magic numbers.\n\nThe interesting thing here was the special case of distance = 0x1011D.\nTo get to the branch which checks for that distance the distance from the intial distance = temp >> 3; must be greater than 0x1E, so it must be 0x1F, as no other value above 0x1E would fit in the top 5 bits of temp.\nWith this information we can calculate the necessary values of the next 2 bytes (a, and b):\n\n```\n0x1011D = 0x1F + a + (b << 8) + 0xFF\n0x1001E = 0x1F + a + (b << 8)\n0x0FFFF = a + (b << 8)\n\n```\nAs a and b are 8 bit numbers they must necessarily both be 0xFF.\nThus 0x1011D is the largest possible value for distance at that point.\n\nThe reasoning for the length-- associated with the conditional becomes apparent: This allows for raw data blocks with no back references, for use in cases such as images or other poorly compressible data.\n\nOther than this, the range of numbers that the Data Length supports can be easily calculated by considering the result of setting temp to 0b11111??? and 0b11110??? and checking the maximum and minimum values of the following two bytes.\n\nHaving understood the block header format the back reference format is fairly easy to understand, the main gotcha being that length = 0 with a following byte of 0 ends the stream.\n\nIf you do not need the files to fit in the same space as the original files then the easiest way to \"compress\" your own files is to ignore the actual compression features of the format, and do the bare minimum of creating maximum size data blocks until the final block, which will have a single back reference, that being the end of stream signal.  A quick implementation of this follows.\n\n```\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <fstream>\n#include <iterator>\n\nunsigned int decompress(uint8_t *decompressed, uint8_t *compressed)\n{\n    uint32_t distance, length, i, j;\n    uint8_t temp, *compressed_ptr = compressed,\n            *decompressed_ptr = decompressed, *backwards_ptr = NULL;\n\n    while (1)\n    {\n        temp = *(compressed_ptr++);\n        length = (temp & 7) + 1;\n        distance = temp >> 3;\n\n        if (distance == 0x1E)\n            distance = *(compressed_ptr++) + 0x1E;\n        else if (distance > 0x1E)\n        {\n            distance += *compressed_ptr;\n            distance += (*(++compressed_ptr) << 8) + 0xFF;\n            compressed_ptr++;\n            if (distance == 0x1011D)\n                length--;\n        }\n\n        if (distance != 0)\n        {\n            std::memcpy(decompressed_ptr, compressed_ptr, distance);\n            decompressed_ptr += distance;\n            compressed_ptr += distance;\n        }\n\n        for (i = length; i > 0; i--)\n        {\n            temp = *(compressed_ptr++);\n            length = temp & 7;\n            distance = temp >> 3;\n\n            if (length == 0)\n            {\n                length = *(compressed_ptr++);\n                if (length == 0)\n                {\n                    return (uintptr_t)decompressed_ptr -\n                        (uintptr_t)decompressed;\n                }\n                length += 7;\n            }\n\n            if (distance == 0x1E)\n                distance = *(compressed_ptr++) + 0x1E;\n            else if (distance > 0x1E)\n            {\n                distance += *compressed_ptr;\n                distance += (*(++compressed_ptr) << 8) + 0xFF;\n                compressed_ptr++;\n            }\n\n            backwards_ptr = decompressed_ptr - distance - 1;\n            for (j = length; j > 0; j--)\n                *(decompressed_ptr++) = *(backwards_ptr++);\n        }\n    }\n}\n\nstd::vector<uint8_t> compress(const std::vector<uint8_t>& input)\n{\n    const uint32_t max_distance = 0x1011D;\n    std::vector<uint8_t> output;\n\n    auto input_it = input.begin();\n\n    // Repeat as many max length blocks as we can\n    auto remaining_input = std::distance(input_it, input.end());\n    while(remaining_input > max_distance)\n    {\n        output.push_back(0xF8);\n        output.push_back(0xFF);\n        output.push_back(0xFF);\n        std::copy(input_it, input_it + max_distance, std::back_inserter(output));\n        input_it += max_distance;\n\n        remaining_input = std::distance(input_it, input.end());\n    }\n\n    // Add a final block with the remaining data\n    if(remaining_input > 0x11D)\n    {\n        output.push_back(0xF8);\n        const uint16_t header_bytes = remaining_input - 0x11E;\n        output.push_back(header_bytes & 0xFF);\n        output.push_back(header_bytes >> 8);\n        std::copy(input_it, input.end(), std::back_inserter(output));\n    }\n    else if(remaining_input > 0x1D)\n    {\n        output.push_back(0xF0);\n        const uint8_t header_byte = remaining_input - 0x1E;\n        output.push_back(header_byte);\n        std::copy(input_it, input.end(), std::back_inserter(output));\n    }\n    else\n    {\n        const uint8_t header_byte = remaining_input << 3;\n        output.push_back(header_byte);\n        std::copy(input_it, input.end(), std::back_inserter(output));\n    }\n\n    // Add a special case 0 length back reference to end the stream\n    output.push_back(0x00);\n    output.push_back(0x00);\n\n    return output;\n}\n\nint main(int argc, char* argv[])\n{\n    std::deque<std::string> args(argv, argv+argc);\n    args.pop_front();\n\n    if(args.empty())\n    {\n        std::cerr << \"No input files!\" << std::endl;\n        return 1;\n    }\n\n    for(const auto& filename : args)\n    {\n        std::ifstream in_file(filename, std::ios::in | std::ios::binary);\n        if(!in_file.good())\n        {\n            std::cerr << \"Bad input file: \" << filename << std::endl;\n            return 1;\n        }\n\n        std::cout << \"Compressing \" << filename << std::endl;\n\n        std::vector<uint8_t> input(\n            (std::istreambuf_iterator<char>(in_file)),\n            (std::istreambuf_iterator<char>())\n        );\n\n        auto compressed = compress(input);\n        std::cout << \"Compressed from \" << input.size() << \" to \" << compressed.size() << std::endl;\n\n        const std::string new_filename = filename + \".compres\";\n        std::ofstream out_file(new_filename);\n        out_file.write((char*)compressed.data(), compressed.size());\n        out_file.close();\n        std::cout << \"Saved as \" << new_filename << std::endl;\n\n        const int buffer_length = 2000000;\n        uint8_t buffer[buffer_length];\n\n        const int size = decompress(buffer, compressed.data());\n\n        std::vector<uint8_t> regenerated;\n        regenerated.assign(buffer, buffer + size);\n\n        if(regenerated == input)\n            std::cout << \"Regenerated file matches original.\" << std::endl;\n        else\n            std::cout << \"Regenerated file DOES NOT MATCH original!\" << std::endl;\n    }\n\n    return 0;\n}\n\n```\nCompile: clang++ --std=c++14 -o fake_compress fake_compress.cpp\n\nAnd run:\n\n```\n$ ./fake_compress havok.xml\nCompressing havok.xml\nCompressed from 137261 to 137272\nSaved as havok.xml.compres\nRegenerated file matches original.\n\n```\n",
      "votes": "8",
      "user": "zed0",
      "time": "Aug 8, 2017 at 23:39",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "Most general purpose LZ77-like formats are optimized for efficient  insertion of individual literal characters, and for the arbitrary sequence of literals and backward references - this is useful to achieve good compression rates on  natural language text as well on text-like binary data (executable code). They also have a notion of a sliding dictionary window to handle files or streams of arbitrary sizes.\n\nThe routine in your question appears to handle a format adapted specifically for in-memory data (note the absence of a sliding window) with many (up to 8 in a row) consecutive references to the decompressed buffer, interspersed with occasional long strings that have to be copied literally. \n\nNote that there are only two ways to add characters to the decompressed stream: by literal copying using a memcpy call, and by copying in a loop using the backwards pointer. In other words, these two modes of operation are \"copying a (fairly long) dictionary from the compressed stream\", and \"reading references to the dictionary from the compressed stream and copying strings from the dictionary\". There is no special provision for individual literal characters.\n\nAny straightforward implementation of an LZ77 compression algorithm (a function of a character string into a stream of tokens \"literal character\" or \"distance/length\") would do. Then you'll be able to write a program to pack these tokens according to the limitation of the format (pay attention to the magic value 0x1011D). \n\nAlternatively, as you're unlikely to be limited by the media size, you may avoid the need to do any actual compression (the analog of compression level 0). For your purposes, it could be enough to represent all the data as a sequence of long literals, using the \"distance\" field for the length of literal string and setting the \"length\" field to 0 to indicate that there are no dictionary references following the literal string. Repeat until the data is exhausted.\n\n",
      "votes": "2",
      "user": "Leo B.",
      "time": "Aug 8, 2017 at 9:21",
      "is_accepted": false,
      "comments": []
    }
  ]
}