{
  "title": "Is there any easy way to define a field in big struct by IDA?",
  "link": "https://reverseengineering.stackexchange.com/questions/31426/is-there-any-easy-way-to-define-a-field-in-big-struct-by-ida",
  "content": "By tracing malloc or similar memory allocation functions, I got a huge struct.\n\nInitially, since I didn't know the intent of the various fields of the struct, I defined it with a byte array.\n\n```\nstruct NCSI_INTERFACE_ATTRIBUTES\n{\n  BYTE Gap[12880];\n};\n\n```\nAs the analysis progressed, I reverted some fields. By calculating the offset, I split the Gap in two and reduce some of the bytes to replace it with the field type I want.\n\n```\nstruct NCSI_INTERFACE_ATTRIBUTES\n{\n  NET_LUID_LH InterfaceLuid;\n  GUID InterfaceGuid;\n  BYTE Gap[4512];\n  NCSI_CAPABILITY_CHANGE_REASON CapabilityChangeReasonV4; // DWORD enum\n  BYTE Gap1[3932];\n  NCSI_CAPABILITY_CHANGE_REASON CapabilityChangeReasonV6; // DWORD enum\n  BYTE Gap2[4404];\n};\n\n```\nNow, I found two new field need to define. They're at the offset Gap[4508] and Gap[3936 + 4508] (You will see why I use + here for description at the follow).\n\nFor the first field at Gap[4508], it's easy, just reduce Gap size to 4508 then define a new DWORD field follow it, done.\n\nFor the second field, since it's an offset relative to the Gap, I'd have to manually calculate the size of all the fields after the Gap (possibly including alignment) and then insert at the correct location, either in Gap1 or Gap2. For insert I may need to split the Gap1/Gap2 again. This is error prone and time consuming.\n\nSo I'm here to ask if there is a way in IDA to do all this easily.\n\nFor example, I provide a field of struct, a offset relative to the field, the new field type/size, IDA split the Gap, insert the new field and keep the struct size not change (reduce the Gap by the new field type).\n\n\n\n",
  "votes": "2",
  "answers": 2,
  "views": "181",
  "tags": [
    "ida"
  ],
  "user": "huang",
  "time": "Jan 17, 2023 at 19:35",
  "comments": [
    {
      "user": "0xC0000022L",
      "text": "One way you can go about this is instead of declaring the byte array in-line, simply declare a union in its place. One member of the union will be a byte array the maximum size of the struct you uncovered (as you had), the other member will be a newly defined struct with the evolving view of the structure as you learn more about it.",
      "time": null
    },
    {
      "user": "huang",
      "text": "@0xC0000022L For the newly defined struct in the union, how can I specific a field with a offset directly, instead of thinking about placing gaps before and after it?",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "This specific case looks like that you have an array of other structures (or sequential similar structures, but according to using the + it is unlikely because it is standard pattern for accessing the array) inside the structure in question. It is possible (and very much likely because of the size of the gap between them) that capability change reasons are also members of these structures. The size of the inner structure should be 3936 (a value that is multiplied by family), and it starts somewhere inside the first Gap field.\nIn this case I would create a separate type for the inner structure, and place the array of 2 such structures inside the main structure according to the use of inner fields inside (you can check assembly code that accesses both capability change reasons for that).\n\n",
      "votes": "1",
      "user": "w s",
      "time": "Jan 18, 2023 at 10:07",
      "is_accepted": false,
      "comments": [
        {
          "user": "huang",
          "text": "This is a viable solution, but it would be better if IDA provided a progressive field definition feature. As 0xC0000022L pointed out in the comments, union is an option, but this feature IDA can clearly do better, and this feature is what most people need (at least i think so).",
          "time": null
        }
      ]
    },
    {
      "content": "If you're okay with scripting, the ida-minsc plugin that I maintain at https://github.com/arizvisa/ida-minsc allows for slice assignments and other things that might help with contiguous layout of structures and other things.\n\nThe following is just me pasting your structure into a database, dumping its contents, adding an enumeration. Afterwards, I updated it (using the UI) with your new structure.\n\n```\nPython>st=struc.by('NCSI_INTERFACE_ATTRIBUTES')\n\nPython>st.members\n<class 'structure' name='NCSI_INTERFACE_ATTRIBUTES' size=0x3250>\n[0]    0+0x3250 BYTE[12880] 'Gap' [(<class 'int'>, 1), 12880]\n\nPython>enum.new('NCSI_CAPABILITY_CHANGE_REASON')\n0xff003556\n\nPython>st.members\n<class 'structure' name='NCSI_INTERFACE_ATTRIBUTES' size=0x3250>\n[0]    0+0x8                      NET_LUID_LH 'InterfaceLuid'            <class 'union' name='_NET_LUID_LH' size=0x8>\n[1]    8+0x10                            GUID 'InterfaceGuid'            <class 'structure' name='_GUID' offset=0x8 size=0x10>\n[2]   18+0x11a0                    BYTE[4512] 'Gap'                      [(<class 'int'>, 1), 4512]\n[3] 11b8+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV4' (<class 'int'>, 4)\n[4] 11bc+0xf5c                     BYTE[3932] 'Gap1'                     [(<class 'int'>, 1), 3932]\n[5] 2118+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV6' (<class 'int'>, 4)\n[6] 211c+0x1134                    BYTE[4404] 'Gap2'                     [(<class 'int'>, 1), 4404]\n\n```\nNext, I selected the member to modify, and then replaced it using a BYTE[4508] and a 4-byte integer.\n\n```\nPython>st.members[2:3]\n[<member 'NCSI_INTERFACE_ATTRIBUTES.Gap' index=2 offset=0x18 size=+0x11a0 typeinfo='BYTE[4512]'>]\n\nPython>st.members[2:3] = ['BYTE[4508]', (int,4)]\n\nPython>st.members\n<class 'structure' name='NCSI_INTERFACE_ATTRIBUTES' size=0x3250>\n[0]    0+0x8                      NET_LUID_LH 'InterfaceLuid'            <class 'union' name='_NET_LUID_LH' size=0x8>\n[1]    8+0x10                            GUID 'InterfaceGuid'            <class 'structure' name='_GUID' offset=0x8 size=0x10>\n[2]   18+0x119c                    BYTE[4508] 'field_18'                 [(<class 'int'>, 1), 4508]\n[3] 11b4+0x4                              int 'field_11B4'               (<class 'int'>, 4)\n[4] 11b8+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV4' (<class 'int'>, 4)\n[5] 11bc+0xf5c                     BYTE[3932] 'Gap1'                     [(<class 'int'>, 1), 3932]\n[6] 2118+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV6' (<class 'int'>, 4)\n[7] 211c+0x1134                    BYTE[4404] 'Gap2'                     [(<class 'int'>, 1), 4404]\n\n```\nI wasn't sure about the other field you're trying to split (as it looks like an array with some variations between them), but you can subtract the base offset from this object to get a quick calculation out of it. In the following, I'm subtracting the array multiple (3936) to translate the offset of that \"gap\" field across 0. Afterwards, I use the translated offsets of both members (-0xf48 and 0x254) to do another slice assignment.\n\n```\nPython>st.members - 3936\n<class 'structure' name='NCSI_INTERFACE_ATTRIBUTES' offset=-0xf60 size=0x3250>\n[0] -f60+0x8                      NET_LUID_LH 'InterfaceLuid'            <class 'union' name='_NET_LUID_LH' offset=-0xf60 size=0x8>\n[1] -f58+0x10                            GUID 'InterfaceGuid'            <class 'structure' name='_GUID' offset=-0xf58 size=0x10>\n[2] -f48+0x119c                    BYTE[4508] 'field_18'                 [(<class 'int'>, 1), 4508]\n[3]  254+0x4                              int 'field_11B4'               (<class 'int'>, 4)\n[4]  258+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV4' (<class 'int'>, 4)\n[5]  25c+0xf5c                     BYTE[3932] 'Gap1'                     [(<class 'int'>, 1), 3932]\n[6] 11b8+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV6' (<class 'int'>, 4)\n[7] 11bc+0x1134                    BYTE[4404] 'Gap2'                     [(<class 'int'>, 1), 4404]\n\nPython>st.members[2:3] = ['_BYTE[0xf48]', '_BYTE[0x254]']\n\nPython>st.members\n<class 'structure' name='NCSI_INTERFACE_ATTRIBUTES' size=0x3250>\n[0]    0+0x8                      NET_LUID_LH 'InterfaceLuid'            <class 'union' name='_NET_LUID_LH' size=0x8>\n[1]    8+0x10                            GUID 'InterfaceGuid'            <class 'structure' name='_GUID' offset=0x8 size=0x10>\n[2]   18+0xf48                    _BYTE[3912] 'field_18'                 [(<class 'int'>, 1), 3912]\n[3]  f60+0x254                     _BYTE[596] 'field_F60'                [(<class 'int'>, 1), 596]\n[4] 11b4+0x4                              int 'field_11B4'               (<class 'int'>, 4)\n[5] 11b8+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV4' (<class 'int'>, 4)\n[6] 11bc+0xf5c                     BYTE[3932] 'Gap1'                     [(<class 'int'>, 1), 3932]\n[7] 2118+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV6' (<class 'int'>, 4)\n[8] 211c+0x1134                    BYTE[4404] 'Gap2'                     [(<class 'int'>, 1), 4404]\n\n```\nSlice assignments in this thing work with lists of types. So that includes IDAPython's struc_t and member_t as well as the wrapped types that I've been using throughout this answer. The following is just an example of using random things to extend the structure. It's using 2 floats, an 8-element array of 2-byte ints, a GUID (fetched using the old IDAPython structure api), and a copy of the same structure's last 2 members (7..9). For reference, the new members start at offset 0x3250.\n\n```\nPython>st.members[9:9] = [float]*2 + [ [(int,2), 8] ]+ [idaapi.get_struc(idaapi.get_struc_id('GUID'))] + st.members[7:]\nWARNING:root:internal.structure.members.layout_setslice(0xff003554, slice(9, 9, None), [...], 0) : Using alternative name \"CapabilityChangeReasonV6_3278\" for new member at offset +0x3278 of structure (0xff003554) as the member (0xff003564) at offset +0x2118 is currently using the requested name \"CapabilityChangeReasonV6\".\nWARNING:root:internal.structure.members.layout_setslice(0xff003554, slice(9, 9, None), [...], 0x0) : Using alternative name \"Gap2_327C\" for new member at offset +0x327c of structure (0xff003554) as the member (0xff003565) at offset +0x211c is currently using the requested name \"Gap2\".\n\nPython>st.members\n<class 'structure' name='NCSI_INTERFACE_ATTRIBUTES' size=0x43b0>\n[0]     0+0x8                      NET_LUID_LH 'InterfaceLuid'                 <class 'union' name='_NET_LUID_LH' size=0x8>\n[1]     8+0x10                            GUID 'InterfaceGuid'                 <class 'structure' name='_GUID' offset=0x8 size=0x10>\n[2]    18+0xf48                    _BYTE[3912] 'field_18'                      [(<class 'int'>, 1), 3912]\n[3]   f60+0x254                     _BYTE[596] 'field_F60'                     [(<class 'int'>, 1), 596]\n[4]  11b4+0x4                              int 'field_11B4'                    (<class 'int'>, 4)\n[5]  11b8+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV4'      (<class 'int'>, 4)\n[6]  11bc+0xf5c                     BYTE[3932] 'Gap1'                          [(<class 'int'>, 1), 3932]\n[7]  2118+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV6'      (<class 'int'>, 4)\n[8]  211c+0x1134                    BYTE[4404] 'Gap2'                          [(<class 'int'>, 1), 4404]\n[9]  3250+0x4                            float 'field_3250'                    (<class 'float'>, 4)\n[10] 3254+0x4                            float 'field_3254'                    (<class 'float'>, 4)\n[11] 3258+0x10                      __int16[8] 'field_3258'                    [(<class 'int'>, 2), 8]\n[12] 3268+0x10                           _GUID 'field_3268'                    <class 'structure' name='_GUID' offset=0x3268 size=0x10>\n[13] 3278+0x4    NCSI_CAPABILITY_CHANGE_REASON 'CapabilityChangeReasonV6_3278' (<class 'int'>, 4)\n[14] 327c+0x1134                    BYTE[4404] 'Gap2_327C'                     [(<class 'int'>, 1), 4404]\n\n```\nAlthough rumor has it that the structure/frame/enum APIs will be deprecated soon...So, this should still work (8.4) until the next version of IDA when that happens.\n\n",
      "votes": "0",
      "user": "Ali Rizvi-Santiago",
      "time": "Jul 3, 2024 at 16:15",
      "is_accepted": false,
      "comments": []
    }
  ]
}