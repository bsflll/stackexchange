{
  "title": "On SPARC, what happens when a branch is placed in the branch-delay slot of another branch?",
  "link": "https://reverseengineering.stackexchange.com/questions/1962/on-sparc-what-happens-when-a-branch-is-placed-in-the-branch-delay-slot-of-anoth",
  "content": "Our team recently had to look at SPARC assembly specifications, the problem is that I do not have a SPARC processor to try things on it (I should set up a simulator or get one of these old Sparc station on my desk... I know).\n\nSomehow, the ba (branch always) instruction puzzled me because it is a delayed branch execution instruction. This mean that the instruction located just after the ba get executed before the jump occurs.\n\nOne of my colleague raised a very interesting question, what does occur in this case:\n\n```\n0x804b38 ba 0x805a10\n0x804b3c ba 0x806844\n...\n0x805a10 add %r3, %r2, %r5\n...\n0x806844 sub %r3, %r5, %r2\n...\n\n```\nOur guess, following the specifications, is that the run should behave like this:\n\n```\n0x805a10 add %r3, %r2, %r5\n0x806844 sub %r3, %r5, %r2\n0x806848 ...\n\n```\nWhich means that you can probably jump and pick up one instruction inside a block of others and run to the next ba... I wonder what the CFG would look like.\n\nWhatever, it was the \"simple\" case, what if we have dynamic jumps (the jmp instruction is like a ba but based on the address stored in the given register):\n\n```\n0x804b38 jmp %r3\n0x804b3c jmp %r0\n...\n(%r3)    change %r0\n...\n\n```\nWould it be a good way to mislead a static-analyzer ? Or, is there a way to have an easy computation to guess what it is doing ?\n\n",
  "votes": "4",
  "answers": 1,
  "views": "788",
  "tags": [
    "obfuscation",
    "binary-analysis",
    "sparc"
  ],
  "user": "perror",
  "time": "Apr 30, 2013 at 15:36",
  "comments": [
    {
      "user": "0xC0000022L",
      "text": "do you have more code, e.g. a full binary? I have a SPARC to try it on ;)",
      "time": null
    },
    {
      "user": "perror",
      "text": "Sorry, I just speculate based on the specifications... :-/ I need to get a sparc and a complete build chain quickly. I have to try.",
      "time": null
    },
    {
      "user": "Mellowcandle",
      "text": "@0xC0000022L I deleted my comment, I didn't read the question till the end...",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "I edited the whole example a little so that it would better match the question.\n\nMy SPARC assembly fu is weak, but what I did was write a little \"Hello world\" with a twist (or one could say with jumps/gotos) in C and use gcc -S to translate it to assembly. I have a SPARC on which I am running it, details:\n\n```\n$ isainfo -v\n64-bit sparcv9 applications\n        vis2 vis\n32-bit sparc applications\n        vis2 vis v8plus div32 mul32\n\n```\nNB: b is the same as jmp, it's just a different mnemonic for the same thing, really. One takes an immediate value (b), the other a register (jmp).\n\nIt turns out that what the link you gave is true for GCC:\n\nI reckon we need to do this with and without debugger, because it's not clear whether it might behave differently under a debugger. So the code should output something readable so we can see what kind of effect our tinkering has ;)\n\n```\n#include <stdio.h>\n\nint foo(int argc)\n{\n        switch(argc)\n        {\n        case 0:\n        case 1:\n                goto a1;\n        case 2:\n                return 3;\n        case 4:\n                goto a2;\n        case 5:\n                return -1;\n        default:\n                goto a4;\n        }\na1:     return 1;\na2:     return 2;\na4:     return 4;\n}\n\nint main(int argc, char** argv)\n{\n        printf(\"Hello world: %i  \n\", foo(argc));\n        return foo(argc);\n}\n\n```\nThis gives me plenty of branch instructions to play around with the idea raised in the question.\n\nHere's the assembly before I tinkered with it:\n\n```\n        .file   \"test.c\"\n        .section        \".text\"\n        .align 4\n        .global foo\n        .type   foo, #function\n        .proc   04\nfoo:\n        !#PROLOGUE# 0\n        save    %sp, -120, %sp\n        !#PROLOGUE# 1\n        st      %i0, [%fp+68]\n        ld      [%fp+68], %g1\n        cmp     %g1, 5\n        bgu     .LL11\n        nop\n        ld      [%fp+68], %g1\n        sll     %g1, 2, %i5\n        sethi   %hi(.LL12), %g1\n        or      %g1, %lo(.LL12), %g1\n        ld      [%i5+%g1], %g1\n        jmp     %g1\n         nop\n.LL6:\n        mov     3, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL9:\n        mov     -1, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL5:\n        mov     1, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL8:\n        mov     2, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL11:\n        mov     4, %g1\n        st      %g1, [%fp-20]\n.LL1:\n        ld      [%fp-20], %i0\n        ret\n        restore\n        .align 4\n        .align 4\n.LL12:\n        .word   .LL5\n        .word   .LL5\n        .word   .LL6\n        .word   .LL11\n        .word   .LL8\n        .word   .LL9\n        .size   foo, .-foo\n        .section        \".rodata\"\n        .align 8\n.LLC0:\n        .asciz  \"Hello world: %i  \n\"\n        .section        \".text\"\n        .align 4\n        .global main\n        .type   main, #function\n        .proc   04\nmain:\n        !#PROLOGUE# 0\n        save    %sp, -112, %sp\n        !#PROLOGUE# 1\n        st      %i0, [%fp+68]\n        st      %i1, [%fp+72]\n        ld      [%fp+68], %o0\n        call    foo, 0\n         nop\n        mov     %o0, %o5\n        sethi   %hi(.LLC0), %g1\n        or      %g1, %lo(.LLC0), %o0\n        mov     %o5, %o1\n        call    printf, 0\n         nop\n        ld      [%fp+68], %o0\n        call    foo, 0\n         nop\n        mov     %o0, %g1\n        mov     %g1, %i0\n        ret\n        restore\n        .size   main, .-main\n        .ident  \"GCC: (GNU) 3.4.3 (csl-sol210-3_4-branch+sol_rpath)\"\n\n```\nI'll concentrate on modifying the result of foo(), so I won't repeat all of the assembly code again but instead only bits and pieces.\n\nbtw: GCC created the extra indentation for the nop instructions, but it makes it easy to spot them, of course.\n\nHere are the steps to get to the modified program.\n\nFirst, I felt compelled to \"optimize\" the instructions in LL6, LL9, LL5, LL8, LL11 and LL1 like this:\n\n```\n.LL6:\n        mov     3, %i0\n        b       .LL1\n         nop\n.LL9:\n        mov     -1, %i0\n        b       .LL1\n         nop\n.LL5:\n        mov     1, %i0\n        b       .LL1\n         nop\n.LL8:\n        mov     2, %i0\n        b       .LL1\n         nop\n.LL11:\n        mov     4, %i0\n.LL1:\n        ret\n        restore\n\n```\nIt should be clear that if your colleague is right, we should be able to substitute the nop instructions for a mov ..., %i0 to see something other than the expected value.\n\nI called my modified assembly file modified.s so as to not confuse myself ;)\n\nFirst test is with my \"optimizations only\". I wrote a little test script:\n\n```\n#!/usr/bin/env bash\nfor i in optimized test; do\n        echo -n \"$i: \"; ./$i\n        echo -n \"$i: \"; ./$i a1\n        echo -n \"$i: \"; ./$i a1 a2\n        echo -n \"$i: \"; ./$i a1 a2 a3\ndone\n\n```\nThe binaries are called optimized (my \"optimizations\" from above) and test (plain assembly created by GCC from C code).\n\nResults:\n\n```\n$ ./runtest\noptimized: Hello world: 1\noptimized: Hello world: 3\noptimized: Hello world: 4\noptimized: Hello world: 2\ntest: Hello world: 1\ntest: Hello world: 3\ntest: Hello world: 4\ntest: Hello world: 2\n\n```\nSo my \"optimizations\" seem to be just fine. Now let's tinker a little.\n\nThe claim is that anything past a jmp (i.e. b) will get executed before the jump itself. We have several labels with jumps, so let's replace the nop in each with something that changes the value inside %i0 and thus the return value of foo().\n\nThe changes:\n\n```\n.LL6:\n        mov     3, %i0\n        b       .LL1\n        mov     30, %i0\n.LL9:\n        mov     -1, %i0\n        b       .LL1\n        mov     42, %i0\n.LL5:\n        mov     1, %i0\n        b       .LL1\n        mov     10, %i0\n.LL8:\n        mov     2, %i0\n        b       .LL1\n        mov     20, %i0\n.LL11:\n        mov     4, %i0\n.LL1:\n        ret\n        restore\n\n```\nSo except for return code -1 (which becomes 42) and 4 (which stays the same) everything should now return the original value times ten.\n\nLet's see the results (I added modified to the list of items in my for loop):\n\n```\n$ ./runtest\noptimized: Hello world: 1\noptimized: Hello world: 3\noptimized: Hello world: 4\noptimized: Hello world: 2\ntest: Hello world: 1\ntest: Hello world: 3\ntest: Hello world: 4\ntest: Hello world: 2\nmodified: Hello world: 10\nmodified: Hello world: 30\nmodified: Hello world: 4\nmodified: Hello world: 20\n\n```\n```\n        mov     39, %i0\n        jmp     %g1\n        b       .LL11\n        b       .LL1\n.LL6:\n        mov     37, %i0\n        b       .LL1\n        mov     30, %i0\n[...]\n.LL11:\n        mov     4, %i0\n.LL1:\n        ret\n        restore\n\n```\nAmending the test script, here's the output:\n\n```\n$ ./runtest\noptimized: Hello world: 1\noptimized: Hello world: 3\noptimized: Hello world: 4\noptimized: Hello world: 2\ntest: Hello world: 1\ntest: Hello world: 3\ntest: Hello world: 4\ntest: Hello world: 2\nmodified: Hello world: 10\nmodified: Hello world: 30\nmodified: Hello world: 4\nmodified: Hello world: 20\nquestion: Hello world: 4\nquestion: Hello world: 4\nquestion: Hello world: 4\nquestion: Hello world: 4\n\n```\nBaffling!\n\nYou can play tricks on the reverse engineer's mind with this - no doubt. I learned something new and that alone was worth it.\n\nHere's the situation\n\n```\njmp     %g1\nb       .LL11 ; <-- this is the branch taken\nb       .LL1\nmov     37, %i0 ; <-- but this gets executed first (at least in GDB)\n\n```\nNow I don't know whether this is true for all SPARC machines, but certainly for the one I was using for my tests (specs at the top)\n\nYes, this can certainly be used to trick the unwitting reverse engineer and perhaps the disassembler (static analysis tool). It's basically an opaque predicate. I.e. the outcome is clear at compile time, but it looks like it's dynamic.\n\nIt's difficult to see how good different disassemblers cope, given that I only have IDA Pro and objdump available here. My educated guess would be that they cope the same as with other opaque predicates, i.e. sometimes they'll get fooled, sometimes they'll be surprisingly smart. So whether or not this is a suitable obfuscation method remains unsolved.\n\nAs opposed to prior to the edit, IDA seems to be mildly confused by the new code, watch this graph view:\n\n\nclick here for full size image (previous version)\n\n0x106CC is the mov 39, %i0 instruction, found via IDA.\n\n```\n$ gdb -q ./question\n(no debugging symbols found)\n(gdb) b *0x106CC\nBreakpoint 1 at 0x106cc\n(gdb) run a1\nStarting program: /export/home/builder/test/question a1\n[New LWP 1]\n[New LWP 2]\n[LWP 2 exited]\n[New LWP 2]\n(no debugging symbols found)\n(no debugging symbols found)\n\nBreakpoint 1, 0x000106cc in foo ()\n(gdb) disp/i $pc\n1: x/i $pc\n0x106cc <foo+44>:       mov  0x27, %i0\n(gdb) si\n0x000106d0 in foo ()\n1: x/i $pc\n0x106d0 <foo+48>:       jmp  %g1\n0x106d4 <foo+52>:       b  0x1070c <foo+108>\n0x106d8 <foo+56>:       b  0x10710 <foo+112>\n0x106dc <foo+60>:       mov  0x25, %i0\n(gdb)\n0x000106d4 in foo ()\n1: x/i $pc\n0x106d4 <foo+52>:       b  0x1070c <foo+108>\n0x106d8 <foo+56>:       b  0x10710 <foo+112>\n0x106dc <foo+60>:       mov  0x25, %i0\n(gdb)\n0x000106dc in foo ()\n1: x/i $pc\n0x106dc <foo+60>:       mov  0x25, %i0\n(gdb)\n0x0001070c in foo ()\n1: x/i $pc\n0x1070c <foo+108>:      mov  4, %i0\n(gdb)\n0x00010710 in foo ()\n1: x/i $pc\n0x10710 <foo+112>:      ret\n0x10714 <foo+116>:      restore\n(gdb)\n\n```\nSo according to GDB we are executing the mov 37, %i0 before the branching. This seems to suggest to me that even when you chain multiple branch instructions, the first thing to be executed is whatever comes after the last one in the chain.\n\n",
      "votes": "8",
      "user": "perror",
      "time": "Apr 30, 2013 at 7:37",
      "is_accepted": true,
      "comments": [
        {
          "user": "0xC0000022L",
          "text": "@perror: concerning your edit (thanks!), have a look at this user script, I've been using it for a while now.",
          "time": null
        },
        {
          "user": "perror",
          "text": "You compare this to an opaque predicate, but it only fuzz the structure of the CFG. I don't think it breaks the analyzer at a semantic level (except if you do not know what a jmp is suppose to do in SPARC). Or maybe I did miss something ?",
          "time": null
        }
      ]
    }
  ]
}