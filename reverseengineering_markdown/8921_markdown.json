{
  "title": "How are obfuscators detected?",
  "link": "https://reverseengineering.stackexchange.com/questions/8921/how-are-obfuscators-detected",
  "content": "I'm guessing that tools like PeiD detect packers by looking for signatures inside the packed binary and by measuring the entropy. Is there any other work that tries to determine if a binary is obfuscated in some way based on some property of the binary? Would this be able to detect control flow obfuscations as in the case of ollvm?\n\n",
  "votes": "7",
  "answers": 2,
  "views": "2k",
  "tags": [
    "obfuscation",
    "unpacking"
  ],
  "user": null,
  "time": "May 17, 2015 at 22:08",
  "comments": [
    {
      "user": "Dominik Antal",
      "text": "I'm sure in case of .NET each obfuscation software has some unique \"footprint\" on the binary produced. If glancing on the binary is not an option :)",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "I wouldn't say that obfuscation detection is strictly related to entropy.\nWhen I detected obfuscated code areas I did it by simple statistical comparison of probabilities of appearances of specific assembly commands.\n\nFor example number of jump related commands will be significantly larger in a binary with control flow obfuscation.\nNumber of arithmetic related commands will be significantly larger in a binary with opaque predicates.\nNumber of some specific code sequences such as jmp $+5 or push addr; ret will be significantly larger when such an obfuscations are applied.\n\nThese heuristics usually working pretty well on the code which is not packed (packed code, however, can be detected by entropy measurement and existence of segments related to well known packers or with unknown meaning).\n\n",
      "votes": "8",
      "user": "w s",
      "time": "May 18, 2015 at 5:45",
      "is_accepted": false,
      "comments": [
        {
          "user": "joxeankoret",
          "text": "One of the tricks I use to detect obfuscation is to count the number of functions and the number of basic blocks and then check the exit basic blocks to determine if the \"exit instructions\" make any sense.",
          "time": null
        },
        {
          "user": "w s",
          "text": "Counting (number of function prologues + number of function epilogues)/(code size) may be also good heuristic.",
          "time": null
        },
        {
          "user": "w s",
          "text": "Generally speaking there a lot of different metrics which can be relatively simply accounted. Relation between code and data sizes, number of jumps, number of ALU ops, number of load/store operations related to code size - all this may give a lot of information. Using the famous triad of multidimensional statistics (factor, discriminant and cluster analysis) on a these metrics should give a good detection ratio.",
          "time": null
        }
      ]
    },
    {
      "content": "I think that, in general, it may be difficult to distinguish obfuscated code from code generated by a compiler that is either extremely bad or extremely good.\n\nExtreme cases of obfuscation are relatively esay to detect.  But an obfuscator that's trying to be stealthy will not be easy to detect.\n\n",
      "votes": "2",
      "user": "debray",
      "time": "May 19, 2015 at 20:04",
      "is_accepted": false,
      "comments": []
    }
  ]
}