{
  "title": "Import Reconstruction in runtime library? any open source ones or any import reconstructors source codes?",
  "link": "https://reverseengineering.stackexchange.com/questions/25294/import-reconstruction-in-runtime-library-any-open-source-ones-or-any-import-rec",
  "content": "I want to implement a full blown import reconstructor into my app without any external dll's or Shell Executes to EXEs. I want to just have the ability to get IAT Import addresses to certain imported DLL's by name or Ordinal. So I can easily patch the IAT to do hacks. At the moment I do this all by hand and have to rely on updating the IAT addresses for every function I am hooking I want this to be automatic by putting in dll name and dll import name and get the import addresses. If I hook using anything other then IAT.. like (DWORD)GetProcAddress(\"dllname\", \"import name\"); it will be detected because it's hooking inside of a DLL that's outside the main game.. even though the anticheat also cares about editing the CODE of the Game itself same as it does for DLL's it doesn't seem to care about memory edits which is what IAT hooking does.\n\nI tried a bunch of solutions such as PE-Sieve and libpeconv both don't handle packed IAT's..\n\nI was going to make my own Auto Import Scanner.. but its too much work.. i need to first find a small \nx86 disasm and opcode length counter then I could loop the whole game EXE and scan for absolute addresses and double check them with *(DWORD*) against (DWORD)GetProcAddress(\"dllname\", \"import name\"); if any of the addresses match then I found my IAT addresses.\n\n```\n– 8B0D MOV ECX,[ADDRESS]\n– 8B15 MOV EDX,[ADDRESS]\n– 8B1D MOV EBX,[ADDRESS]\n– 8B25 MOV ESP,[ADDRESS]\n– 8B2D MOV EBP,[ADDRESS]\n– 8B35 MOV ESI,[ADDRESS]\n– 8B3D MOV EDI,[ADDRESS]\n– A1 MOV EAX,[ADDRESS]\n- FF15 CALL [ADDRESS]\n– FF25 JMP [ADDRESS]\n– FF35 PUSH [ADDRESS]\n\n```\nAnyone got a code that already do this? or anything similar to this.. i would really appreciate it.\n\nHere is what I got so far.. it kinda works gets 80-85% of all imports.. but the ones that are double jumped and some with crap instructions that needs a re-pass I'm still working on that anyone got these patterns complete?\n\n```\n#define ResolveRVA(base,rva) (( (uint8_t*)base) +rva)\n#define RVA2VA(type, base, rva) (type)((ULONG_PTR) base + rva)\n\nBOOL SnapShotModules(DWORD dwPID)\n{\n    BOOL           bRet = TRUE;\n\n    // Get all modules for this process:\n    std::vector<HMODULE> hModules;\n    const HMODULE hSelf = GetModuleHandle(NULL);\n    {\n        DWORD nModules;\n        EnumProcessModules(GetCurrentProcess(), NULL, 0, &nModules);\n        hModules.resize(nModules);\n        EnumProcessModules(GetCurrentProcess(), &hModules[0], nModules, &nModules);\n    }\n\n    if (!hSelf)\n    {\n        printf(\"Invalid Process Handle  \n\");\n        return FALSE;\n    }\n\n    gs_ModuleList.clear();\n\n    IAT_Module_Info modulefullInfo = { 0 };\n    MODULEINFO modinfo = { 0 };\n    char moduleName[256] = { 0 };\n    char moduleFileName[1000] = { 0 };\n\n    char myProcessFilePath[1000] = { 0 };\n    GetModuleFileNameExA(GetCurrentProcess(), NULL, myProcessFilePath, 1000);\n    LPCSTR MyProcessFileName = PathFindFileName(myProcessFilePath);\n    for (auto hModule : hModules) {\n        if (hModule == hSelf)\n            continue;\n\n        GetModuleInformation(GetCurrentProcess(), hModule, &modinfo, sizeof(modinfo));\n        GetModuleBaseName(GetCurrentProcess(), hModule, moduleName, sizeof(moduleName) / sizeof(char));\n        GetModuleFileName(hModule, moduleFileName, sizeof(moduleFileName) / sizeof(char));\n        if (_strcmpi(moduleName, MyProcessFileName) == 0) continue;\n        strcpy(modulefullInfo.DllName, moduleName);\n        modulefullInfo.ImageSize = modinfo.SizeOfImage;\n        modulefullInfo.ImageBase = (DWORD)modinfo.lpBaseOfDll;\n        modulefullInfo.EntryPoint = (BYTE*)modinfo.EntryPoint;\n        strcpy(modulefullInfo.DllFileName, moduleFileName);\n        gs_ModuleList.push_back(modulefullInfo);\n    }\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*\nFunction : Retrieve API info by its addr and the module it belongs to\nParams   : pBuf points to the image mapped to our space*/\n/************************************************************************/\nvoid GetAPIInfo(DWORD ptrAPI, const IAT_Module_Info *iat_module_info, DWORD ptrAPIObfuscated = NULL)\n{\n    //try to load the dll into our space\n    HMODULE hDll = NULL;\n    if(iat_module_info)\n        hDll = LoadLibrary(iat_module_info->DllFileName);\n\n    if (NULL == hDll)\n        return;\n\n    //now ask for info from Export\n    PIMAGE_DOS_HEADER pDOSHDR = (PIMAGE_DOS_HEADER)hDll;\n    PIMAGE_NT_HEADERS pNTHDR = (PIMAGE_NT_HEADERS)((BYTE *)pDOSHDR + pDOSHDR->e_lfanew);\n    if (pNTHDR->OptionalHeader.NumberOfRvaAndSizes < IMAGE_DIRECTORY_ENTRY_EXPORT + 1)\n        return;\n\n    PIMAGE_EXPORT_DIRECTORY pExpDIR = (PIMAGE_EXPORT_DIRECTORY)\n        ((BYTE *)pDOSHDR\n            + pNTHDR->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n    DWORD dwFunctions = pExpDIR->NumberOfFunctions;\n    DWORD *ptrAddrFunc = (DWORD *)((BYTE *)pDOSHDR + pExpDIR->AddressOfFunctions);\n    DWORD i = 0;\n\n    //get index by address\n    for (i = 0; i < dwFunctions; i++)\n    {\n        if (ptrAPIObfuscated && ((DWORD)pDOSHDR + ptrAddrFunc[i]) == ptrAPIObfuscated)\n            break;\n        if (!ptrAPIObfuscated && ((DWORD)pDOSHDR + ptrAddrFunc[i]) == *(DWORD*)ptrAPI)\n            break;\n    }\n\n    //not match\n    if (i == dwFunctions)\n        return;\n\n    //get name and ordinal\n    DWORD dwNames = pExpDIR->NumberOfNames;\n    DWORD *pNames = (DWORD *)((BYTE *)pDOSHDR + pExpDIR->AddressOfNames);\n    WORD *pNameOrd = (WORD *)((BYTE *)pDOSHDR + pExpDIR->AddressOfNameOrdinals);\n    DWORD j = 0;\n    char *pszName = NULL;\n    SIZE_T nLen = 0;\n    for (j = 0; j < dwNames; j++)\n    {\n        if (pNameOrd[j] == i)\n        {\n            pszName = (char *)pDOSHDR + pNames[j];\n            nLen = strlen(pszName);\n            /*printf(\"%X\\t%04X\\t%s  \n\",\n                *(DWORD *)ptrAPI,\n                j,\n                pszName\n            );*/\n\n            //Save information\n            IAT_Import_Information iat_found = { 0 };\n            iat_found.IATAddress = ptrAPI;\n            strcpy(iat_found.IATFunctionName, pszName);\n            strcpy(iat_found.IATModuleName, iat_module_info->DllName);\n            listOfIATImports.push_back(iat_found);\n            if(ptrAPIObfuscated)\n                printf(\"Added Obfuscated %X %X, %s -> %s  \n\", ptrAPI, ptrAPIObfuscated, iat_module_info->DllName, pszName);\n            else\n                printf(\"Added %X %X, %s -> %s  \n\", ptrAPI, *(DWORD*)ptrAPI, iat_module_info->DllName, pszName);\n        }\n    }\n}\n\n/************************************************************************/\n/*\nFunction : rebuild Import Info according to IAT\nParams   : ptrIAT point to the page where IAT in\nppBuf [IN/OUT] is the memory space for the exe, may be updated\ndwImageSize is the exe's image size                                                                  */\n/************************************************************************/\nvoid FixImport(DWORD dwPID, DWORD ptrIAT, DWORD ptrIATEnd, DWORD dwImageSize)\n{\n    if (gs_ModuleList.size() == 0) {\n        printf(\"No Modules loaded, can't fix anything  \n\");\n        return;\n    }\n\n    //now verify every DWORD item is a valid FuncPtr with some dll.\n    //we need to snapshot the process.\n    std::list<IAT_Module_Info>::iterator it;\n    IAT_Module_Info iat_module_info;\n    printf(\"ptrIAT = %X ptrIATEnd = %X  \n\", ptrIAT, ptrIATEnd);\n\n    DWORD ptrIndex = ptrIAT;\n    DWORD dwModBase = NULL;  //????????????\n    DWORD dwModSize = NULL;\n    DWORD dwModHit = NULL;\n    while (TRUE)\n    {\n        //thz should always continue, even if BadPtr or invalid funcptr\n        if (ptrIndex <= ptrIATEnd\n            && IsBadReadPtr((const void *)*(DWORD *)ptrIndex, sizeof(DWORD)))\n        {\n            ptrIndex += sizeof(DWORD);\n            continue;\n        }\n\n        //now we may end, be careful\n        if (ptrIndex > ptrIATEnd\n            && (NULL == *(DWORD*)ptrIndex)\n            && (NULL == *(DWORD*)(ptrIndex + sizeof(DWORD))))\n        {\n            break;\n        }\n\n        if (ptrIndex > ptrIATEnd\n            && IsBadReadPtr((const void *)*(DWORD *)ptrIndex, sizeof(DWORD))\n            )\n        {\n            ptrIndex += sizeof(DWORD);\n            continue;\n        }\n\n        //////////////////////////////////////////////////////////////////////////\n        //whether in a module range\n        dwModHit = NULL;\n\n        //??????????\n        if (*(DWORD *)ptrIndex >= dwModBase\n            && *(DWORD *)ptrIndex < dwModBase + dwModSize)\n        {\n            dwModHit = dwModBase;\n        }\n\n        //have to loop every module\n        if (dwModHit == NULL)\n        {\n            for (it = gs_ModuleList.begin(); it != gs_ModuleList.end(); it++)\n            {\n                iat_module_info = *it;\n                dwModBase = (DWORD)iat_module_info.ImageBase;\n                dwModSize = (DWORD)iat_module_info.ImageSize;\n\n                if (*(DWORD *)ptrIndex >= dwModBase\n                    && *(DWORD *)ptrIndex < dwModBase + dwModSize)\n                {\n                    //printf(\"ptrIndex %X %X, Mod: %X, Size: %X  \n\", *(DWORD *)ptrIndex, ptrIndex, dwModBase, dwModSize);\n                    //printf(\"Module: %s  \n\", iat_module_info.DllName);\n                    break;\n                }\n                memset(&iat_module_info, 0, sizeof(IAT_Module_Info));\n            }//end for(\n        }//end if(NULL == \n\n        if (iat_module_info.ImageBase == 0 && iat_module_info.ImageSize == 0) {\n            bool passDone = false;\n            DWORD deObfuscatedAddress = *(DWORD*)ptrIndex;\n            retryPass:\n            printf(\"%X %X  \n\", (BYTE)deObfuscatedAddress, *(BYTE*)deObfuscatedAddress);\n            if (*(BYTE*)deObfuscatedAddress == 0xE9) //JMP relative\n                deObfuscatedAddress = (*(DWORD*)(deObfuscatedAddress + 1)) + deObfuscatedAddress + 5;\n            else if (*(BYTE*)deObfuscatedAddress == 0x68) { //PUSH\n                printf(\"PUSH = %X %X  \n\", deObfuscatedAddress, *(DWORD*)(deObfuscatedAddress + 1));\n                deObfuscatedAddress = *(DWORD*)(deObfuscatedAddress + 1);\n            }\n            else if ((BYTE)deObfuscatedAddress == 0xC0) { //shl (invalid opcode)\n                printf(\"invalid = %X %X %X  \n\", ptrIndex, deObfuscatedAddress, (DWORD*)deObfuscatedAddress);\n                deObfuscatedAddress = *(DWORD*)(ptrIndex + insn_len((void*)ptrIndex));\n                printf(\"invalid = %X %X %X  \n\", ptrIndex, deObfuscatedAddress, (DWORD*)deObfuscatedAddress);\n                passDone = true;\n                goto retryPass;\n            } else if ((BYTE)deObfuscatedAddress == 0xC8) { //enter (invalid opcode)\n                printf(\"invalid = %X %X %X  \n\", ptrIndex, deObfuscatedAddress, (DWORD*)deObfuscatedAddress);\n                deObfuscatedAddress = *(DWORD*)(ptrIndex + insn_len((void*)ptrIndex));\n                printf(\"invalid = %X %X %X  \n\", ptrIndex, deObfuscatedAddress, (DWORD*)deObfuscatedAddress);\n                passDone = true;\n                goto retryPass;\n            } else {\n                if (passDone) goto continueGo;\n                printf(\"b unknown deob %X %X %X %X  \n\", ptrIndex, *(BYTE*)ptrIndex, *(DWORD*)ptrIndex, deObfuscatedAddress);\n                deObfuscatedAddress += insn_len((void*)deObfuscatedAddress);\n                printf(\"a unknown deob %X %X %X %X  \n\", ptrIndex, *(BYTE*)ptrIndex, *(DWORD*)ptrIndex, deObfuscatedAddress);\n                passDone = true;\n                goto retryPass;\n            }\n            continueGo:\n            for (it = gs_ModuleList.begin(); it != gs_ModuleList.end(); it++)\n            {\n                iat_module_info = *it;\n                dwModBase = (DWORD)iat_module_info.ImageBase;\n                dwModSize = (DWORD)iat_module_info.ImageSize;\n\n                if (deObfuscatedAddress >= dwModBase\n                    && deObfuscatedAddress < dwModBase + dwModSize)\n                {\n                    //printf(\"ptrIndex %X %X, Mod: %X, Size: %X  \n\", deObfuscatedAddress, ptrIndex, dwModBase, dwModSize);\n                    //printf(\"Module: %s  \n\", iat_module_info.DllName);\n                    break;\n                }\n                memset(&iat_module_info, 0, sizeof(IAT_Module_Info));\n            }\n            GetAPIInfo(ptrIndex, &iat_module_info, deObfuscatedAddress);\n            ptrIndex += sizeof(DWORD);\n            memset(&iat_module_info, 0, sizeof(IAT_Module_Info));\n            continue;\n        }\n\n        //now *ptrIndex in dwModBase\n        //now retrieve API info (Hint, name) from the module's export\n        //printf(\"ptrIndex %X %X, Mod: %X, Size: %X  \n\", *(DWORD *)ptrIndex, ptrIndex, dwModBase, dwModSize);\n        GetAPIInfo(ptrIndex, &iat_module_info);\n        ptrIndex += sizeof(DWORD);\n    }\n}\n\n/************************************************************************/\n/*\nFunction : Get AddressOfEntryPoint  (or Original Entry Point)\nParams   : lpAddr is the Base where the exe mapped into\nReturn   : OEP (RVA)             */\n/************************************************************************/\nDWORD GetOEP(LPVOID lpAddr)\n{\n    PIMAGE_DOS_HEADER pDOSHDR = (PIMAGE_DOS_HEADER)lpAddr;\n    PIMAGE_NT_HEADERS pNTHDR = (PIMAGE_NT_HEADERS)((unsigned char *)pDOSHDR + pDOSHDR->e_lfanew);\n    return pNTHDR->OptionalHeader.AddressOfEntryPoint;\n}\n\n/************************************************************************/\n/*\nFunction : Retrieve a process's Import Info only by IAT\nParam    : lpAddr is the address the exe mapped into (within our space)\nptrIATEnd [out] used to receive the 1st IAT we found (FF25 XXXX, FF15YYYY)\nReturn   : the beginning of the page where IAT in\nSearch for FF25 XXXX,  or FF15 yyyy\nHelloWorld.exe\n004001E0 > .  EA07D577      DD USER32.MessageBoxA\n004001E4      00000000      DD 00000000\n004001E8 >/$  6A 00         PUSH 0                                   ; /Style = MB_OK|MB_APPLMODAL\n004001EA  |.  6A 00         PUSH 0                                   ; |Title = NULL\n004001EC  |.  6A 00         PUSH 0                                   ; |Text = NULL\n004001EE  |.  6A 00         PUSH 0                                   ; |hOwner = NULL\n004001F0  |.  E8 01000000   CALL <JMP.&USER32.MessageBoxA>           ; \\MessageBoxA\n004001F5  \\.  C3            RETN\n004001F6   $- FF25 E0014000 JMP DWORD PTR DS:[<&USER32.MessageBoxA>] ;  USER32.MessageBoxA\nNotepad.exe\n0100740B   .  FF15 38130001      CALL DWORD PTR DS:[<&msvcrt.__set_app_ty>;  msvcrt.__set_app_type\nMSPaint.exe\n1000CA65    8B35 58D10110   MOV ESI,DWORD PTR DS:[<&KERNEL32.LCMapSt>; kernel32.LCMapStringW\n*/\n/************************************************************************/\n\n/*\nNeed to check all of these\n– 8B0D MOV ECX,[ADDRESS]\n– 8B15 MOV EDX,[ADDRESS]\n– 8B1D MOV EBX,[ADDRESS]\n– 8B25 MOV ESP,[ADDRESS]\n– 8B2D MOV EBP,[ADDRESS]\n– 8B35 MOV ESI,[ADDRESS]\n– 8B3D MOV EDI,[ADDRESS]\n– A1 MOV EAX,[ADDRESS]\n- FF15 CALL [ADDRESS]\n– FF25 JMP [ADDRESS]\n– FF35 PUSH [ADDRESS]\n*/\n\nDWORD SearchIAT(LPVOID lpAddr, DWORD dwImageSize, DWORD pImageBase, DWORD dwMaxIATImageSize, DWORD *ptrIATEnd)\n{\n    DWORD pImageSectionStart = 0;\n    DWORD instruction_length;\n    DWORD *ptrFuncAddr = NULL;     //like xxx in JMP DWORD PTR DS:[XXXX]\n    DWORD ptrFuncAddrHighest = NULL;\n    DWORD dwOEP = NULL;\n    BYTE *pCode = NULL;\n    DWORD i = NULL;\n    WORD  wJMP = 0x25FF;\n    WORD  wCALL = 0x15FF;\n\n    dwOEP = GetOEP(lpAddr);\n    i = dwOEP;\n    pCode = (BYTE *)((BYTE *)lpAddr + dwOEP);\n\n    // get the location of the module's IMAGE_NT_HEADERS structure\n    IMAGE_NT_HEADERS *pNtHdr = ImageNtHeader(lpAddr);\n    // section table immediately follows the IMAGE_NT_HEADERS\n    IMAGE_SECTION_HEADER *pSectionHdr = (IMAGE_SECTION_HEADER *)(pNtHdr + 1);\n\n    bool got = false;\n    for (int scn = 0; scn < pNtHdr->FileHeader.NumberOfSections; ++scn)\n    {\n        char *name = (char*)pSectionHdr->Name;\n        DWORD SectionStart = (DWORD)lpAddr + pSectionHdr->VirtualAddress;\n        DWORD SectionEnd = (DWORD)lpAddr + pSectionHdr->VirtualAddress + pSectionHdr->Misc.VirtualSize - 1;\n\n        if (got) {\n            pImageSectionStart = SectionStart;\n            break;\n        }\n\n        if (SectionStart == pImageBase + dwOEP && SectionEnd < dwImageSize) {\n            got = true;\n            //next one is imports.\n            ++pSectionHdr;\n            continue;\n        }\n        ++pSectionHdr;\n    }\n\n    if (!pImageSectionStart)\n        pImageSectionStart = dwImageSize;\n\n    printf(\"Found OEP at %X, ImageSize = %X,%X  \n\", dwOEP, dwImageSize, pImageSectionStart);\n\n    //search for FF 25 XXXX, FF 15 YYYY from OEP, had better use Disasm engine \n    //but we just do it simply\n    while (i < pImageSectionStart)\n    {\n        if (memcmp(pCode, &wJMP, sizeof(WORD))\n            && memcmp(pCode, &wCALL, sizeof(WORD)))\n        {\n            //\n            instruction_length = insn_len(pCode);\n            pCode += instruction_length;\n            i += instruction_length;\n            continue;\n        }\n\n        //check illegal, *ptrFuncAddr > pImageBase  && *ptrFuncAddr <= pImageBase + dwImageSize\n        ptrFuncAddr = (DWORD *)(pCode + sizeof(WORD));\n        if (*ptrFuncAddr < (DWORD)pImageBase || *ptrFuncAddr >= (DWORD)pImageBase + dwImageSize)\n        {\n            instruction_length = insn_len(pCode);\n            pCode += instruction_length;\n            i += instruction_length;\n            continue;\n        }\n\n        //need to fix relocation\n        *(DWORD *)ptrFuncAddr = (long)lpAddr + *(long *)ptrFuncAddr - (long)pImageBase;\n        //now found one item that may belongs to IAT\n        ptrFuncAddr = (DWORD *)*ptrFuncAddr;\n\n        if ((DWORD)ptrFuncAddr > ptrFuncAddrHighest) {\n            ptrFuncAddrHighest = (DWORD)ptrFuncAddr;\n            printf(\"highest = %X  \n\", ptrFuncAddrHighest);\n        }\n\n        //recheck illegal, \n        //for system dlls, what about user dlls? well, whatever, there must be system dlls\n        //what if we found IAT for system dlls, so we found the user dlls.\n        //What if the IAT tables are not continous????????\n        if (*ptrFuncAddr < dwMaxIATImageSize)\n        {\n            instruction_length = insn_len(pCode);\n            pCode += instruction_length;\n            i += instruction_length;\n            continue;\n        }\n        break;\n    }\n\n    //now it seems ptrFuncAddr points some item in IAT, \n    //make ptrFuncAddr point to the beginning of the page\n    //we use 0xFFFEFFFF, because ptrFuncAddr is the memory addr we allocated, not by loadlibrary\n    *ptrIATEnd = (DWORD)ptrFuncAddrHighest;\n    ptrFuncAddr = (DWORD*)(((DWORD)ptrFuncAddr & 0xFFFFF000)\n        + ((DWORD)lpAddr & 0x0FFF)\n        );\n    return (DWORD)ptrFuncAddr;\n\n    //return NULL;\n}\n\nunsigned long Get_Import_Address(char* DLL, char* Library, char* Import, int ordinal = -1)\n{\n    HMODULE mhLoadedDLL = NULL;\n    do\n    {\n        if (!DLL)\n            mhLoadedDLL = GetModuleHandle(NULL);\n        else\n            mhLoadedDLL = GetModuleHandle(DLL);\n        Sleep(100);\n    } while (!mhLoadedDLL);\n\n    MODULEINFO modinfo;\n    GetModuleInformation(GetCurrentProcess(), mhLoadedDLL, &modinfo, sizeof(MODULEINFO));\n    DWORD ModuleSize = (unsigned long)modinfo.SizeOfImage;\n\n    PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)mhLoadedDLL;\n    PIMAGE_NT_HEADERS NtHeader;\n    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;\n    UINT Index = 0;\n\n\n    NtHeader = (PIMAGE_NT_HEADERS)(((PBYTE)DosHeader) + DosHeader->e_lfanew);\n    if (NtHeader->Signature != IMAGE_NT_SIGNATURE)\n        return 0;\n\n    ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(((PBYTE)DosHeader) + NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\n\n    if (mhLoadedDLL) {\n        ULONG Sz;\n        ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToDataEx(mhLoadedDLL, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &Sz, nullptr);\n    }\n\n    __try {\n        //\n        // Iterate over import descriptors/DLLs.\n        //\n        for (Index = 0; (ImportDescriptor[Index].Characteristics != 0 || ImportDescriptor[Index].Name); Index++) {\n            PSTR dllName = (PSTR)(((PBYTE)DosHeader) + ImportDescriptor[Index].Name);\n\n            if (_strcmpi(dllName, Library) == 0) {\n                // This the DLL we are after.\n                PIMAGE_THUNK_DATA Thunk;\n                PIMAGE_THUNK_DATA OrigThunk;\n\n                Thunk = (PIMAGE_THUNK_DATA)(((PBYTE)DosHeader) + ImportDescriptor[Index].FirstThunk);\n                OrigThunk = (PIMAGE_THUNK_DATA)(((PBYTE)DosHeader) + ImportDescriptor[Index].OriginalFirstThunk);\n\n                //Reset\n                Thunk = (PIMAGE_THUNK_DATA)(((PBYTE)DosHeader) + ImportDescriptor[Index].FirstThunk);\n                OrigThunk = (PIMAGE_THUNK_DATA)(((PBYTE)DosHeader) + ImportDescriptor[Index].OriginalFirstThunk);\n\n                for (; OrigThunk->u1.Function != NULL; OrigThunk++, Thunk++)\n                {\n                    if (ordinal != -1) {\n                        if ((OrigThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) && IMAGE_ORDINAL(OrigThunk->u1.Ordinal) == ordinal) //send ordinal\n                            return (DWORD)Thunk; //Address of import returns.\n                    }\n\n                    if (OrigThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) { // Ordinal import - we can handle named imports only, so skip it.\n                        continue;\n                    }\n\n                    PIMAGE_IMPORT_BY_NAME importt = (PIMAGE_IMPORT_BY_NAME)(((PBYTE)DosHeader) + OrigThunk->u1.AddressOfData);\n\n                    if (_strcmpi(Import, (char*)importt->Name) == 0) {\n                        return (DWORD)Thunk; //Address of import returns.\n                    }\n                }\n\n                unsigned long ptrFuncsIndex = (unsigned long)ImportDescriptor[Index].FirstThunk + (DWORD)mhLoadedDLL;\n                DWORD impAddress = (DWORD)GetProcAddress(GetModuleHandle(Library), Import);\n\n                //First get all modules loaded, so you can find the maximum ImageBase+ImageSize for IAT Max Size calculation.\n                if (gs_ModuleList.size() == 0) {\n                    BOOL bRet = SnapShotModules((DWORD)GetCurrentProcess());\n                    if (!bRet)\n                    {\n                        printf(\"Failed to get Modules  \n\");\n                        return 0;\n                    }\n                }\n\n                DWORD dwMaxIATImageSize = 0x70000000;\n                if (gs_ModuleList.size() > 0) {\n                    auto max_it = std::max_element(gs_ModuleList.begin(), gs_ModuleList.end(), [](const IAT_Module_Info& l, const IAT_Module_Info& h) {\n                        return l.ImageBase < h.ImageBase;\n                    });\n\n                    if (max_it->ImageBase > 0)\n                        dwMaxIATImageSize = (DWORD)max_it->ImageBase + max_it->ImageSize;\n\n                    printf(\"Highest Imported DLL = %X %s  \n\", max_it->ImageBase, max_it->DllName);\n                }\n                //now we do more, retrieve the Page where IAT in\n                DWORD ptrIATEnd = NULL;\n                DWORD ptrIAT = SearchIAT(mhLoadedDLL, ModuleSize, NtHeader->OptionalHeader.ImageBase, dwMaxIATImageSize, &ptrIATEnd);\n\n                printf(\"Rebuilding IAT,Found IAT in page %X, IAT End %X  \n\", ptrIAT, ptrIATEnd);\n                if(listOfIATImports.size() == 0)\n                    FixImport((DWORD)GetCurrentProcess(), ptrIAT, ptrIATEnd, ModuleSize);\n\n                if (listOfIATImports.size() > 0) {\n                    auto match = std::find_if(listOfIATImports.cbegin(), listOfIATImports.cend(), [Library, Import](const IAT_Import_Information& s) {\n                        return _strcmpi(s.IATModuleName, Library) == 0 && _strcmpi(s.IATFunctionName, Import) == 0;\n                    });\n\n                    if (match != listOfIATImports.cend()) {\n                        printf(\"Found IAT = %X, %s %s  \n\", match->IATAddress, match->IATModuleName, match->IATFunctionName);\n                    }\n\n                    std::list<IAT_Import_Information>::iterator i;\n                    for (i = listOfIATImports.begin();\n                        i != listOfIATImports.end();\n                        i++)\n                    {\n                        printf(\"Module: %s Import: %s Address: %X  \n\", i->IATModuleName, i->IATFunctionName, i->IATAddress);\n                    }\n\n                } else {\n                    printf(\"Couldn't find module %s, import %s  \n\", Library, Import);\n                }\n\n            }\n        }\n    }\n    __except (1) {\n        printf(\"Exception hit parsing imports  \n\");\n    }\n    return 0;\n}\n\n```\n",
  "votes": "1",
  "answers": 1,
  "views": "196",
  "tags": [
    "iat",
    "import-reconstruction"
  ],
  "user": "SSpoke",
  "time": "Jun 15, 2020 at 2:20",
  "comments": [],
  "answers_data": [
    {
      "content": "Here is my final code.. it works.. gets all imports except a missing a few like 10 at most.. which are hardly important anyways. It misses GetCurrentProcessId(),GetCurrentProcess(),LoadLibrary. It misses them because I have no idea how to decode 0xA1 (MOV EAX, [XXXXXX]) opcode or 0xFF35 opcode (push [XXXXXX]). Although this library is very useful to me and it will help me in many projects to come.. I will release it on github now.\n\nimports address revolver file contains this\n\n```\n#include <psapi.h> //GetModuleInformation IAT\n#include <tlhelp32.h> //MODULEENTRY32 IAT\n#include <shlwapi.h> //PathFindFileName IAT\n#include <DbgHelp.h> //detours, GetImports, PE information BaseAddressStart/End etc.\n#include <unordered_set> //std::unordered_set<DWORD>\n#include <unordered_map> //std::map\n#include <string>\n#include <algorithm>\n#include <iterator>\n#include <vector>\n\n#pragma comment(lib, \"dbghelp.lib\")\n#pragma comment(lib, \"psapi.lib\") //GetModuleInformation IAT\n#pragma comment(lib, \"Shlwapi.lib\") //PathFindFileName IAT\n\nstruct IAT_Module_Info\n{\n    DWORD ImageBase;\n    DWORD ImageSize;\n    BYTE* EntryPoint;\n    char DllName[256];\n    char DllFileName[1000];\n};\n\nstatic std::list<IAT_Module_Info> gs_ModuleList;\n\nstruct IAT_Import_Information\n{\n    DWORD IATAddress;\n    char IATModuleName[256];\n    char IATFunctionName[256];\n};\n\nstatic std::list<IAT_Import_Information> listOfIATImports;\n\n\nBOOL SnapShotModules(DWORD dwPID)\n{\n    BOOL           bRet = TRUE;\n\n    // Get all modules for this process:\n    std::vector<HMODULE> hModules;\n    const HMODULE hSelf = GetModuleHandle(NULL);\n    {\n        DWORD nModules;\n        EnumProcessModules(GetCurrentProcess(), NULL, 0, &nModules);\n        hModules.resize(nModules);\n        EnumProcessModules(GetCurrentProcess(), &hModules[0], nModules, &nModules);\n    }\n\n    if (!hSelf)\n    {\n        printf(\"Invalid Process Handle  \n\");\n        return FALSE;\n    }\n\n    gs_ModuleList.clear();\n\n    IAT_Module_Info modulefullInfo = { 0 };\n    MODULEINFO modinfo = { 0 };\n    char moduleName[256] = { 0 };\n    char moduleFileName[1000] = { 0 };\n\n    char myProcessFilePath[1000] = { 0 };\n    GetModuleFileNameExA(GetCurrentProcess(), NULL, myProcessFilePath, 1000);\n    LPCSTR MyProcessFileName = PathFindFileName(myProcessFilePath);\n    for (auto hModule : hModules) {\n        if (hModule == hSelf)\n            continue;\n\n        GetModuleInformation(GetCurrentProcess(), hModule, &modinfo, sizeof(modinfo));\n        GetModuleBaseName(GetCurrentProcess(), hModule, moduleName, sizeof(moduleName) / sizeof(char));\n        GetModuleFileName(hModule, moduleFileName, sizeof(moduleFileName) / sizeof(char));\n        if (_strcmpi(moduleName, MyProcessFileName) == 0) continue;\n        strcpy(modulefullInfo.DllName, moduleName);\n        modulefullInfo.ImageSize = modinfo.SizeOfImage;\n        modulefullInfo.ImageBase = (DWORD)modinfo.lpBaseOfDll;\n        modulefullInfo.EntryPoint = (BYTE*)modinfo.EntryPoint;\n        strcpy(modulefullInfo.DllFileName, moduleFileName);\n        gs_ModuleList.push_back(modulefullInfo);\n    }\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*\nFunction : Retrieve API info by its addr and the module it belongs to\nParams   : pBuf points to the image mapped to our space*/\n/************************************************************************/\nvoid GetAPIInfo(DWORD ptrAPI, const IAT_Module_Info *iat_module_info, DWORD ptrAPIObfuscated = NULL)\n{\n    //try to load the dll into our space\n    HMODULE hDll = NULL;\n    if(iat_module_info)\n        hDll = LoadLibrary(iat_module_info->DllFileName);\n\n    if (NULL == hDll)\n        return;\n\n    //now ask for info from Export\n    PIMAGE_DOS_HEADER pDOSHDR = (PIMAGE_DOS_HEADER)hDll;\n    PIMAGE_NT_HEADERS pNTHDR = (PIMAGE_NT_HEADERS)((BYTE *)pDOSHDR + pDOSHDR->e_lfanew);\n    if (pNTHDR->OptionalHeader.NumberOfRvaAndSizes < IMAGE_DIRECTORY_ENTRY_EXPORT + 1)\n        return;\n\n    PIMAGE_EXPORT_DIRECTORY pExpDIR = (PIMAGE_EXPORT_DIRECTORY)\n        ((BYTE *)pDOSHDR\n            + pNTHDR->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n    DWORD dwFunctions = pExpDIR->NumberOfFunctions;\n    DWORD *ptrAddrFunc = (DWORD *)((BYTE *)pDOSHDR + pExpDIR->AddressOfFunctions);\n    DWORD i = 0;\n\n    //get index by address\n    for (i = 0; i < dwFunctions; i++)\n    {\n        if (ptrAPIObfuscated && ((DWORD)pDOSHDR + ptrAddrFunc[i]) == ptrAPIObfuscated)\n            break;\n        if (!ptrAPIObfuscated && ((DWORD)pDOSHDR + ptrAddrFunc[i]) == *(DWORD*)ptrAPI)\n            break;\n    }\n\n    //not match\n    if (i == dwFunctions)\n        return;\n\n    //get name and ordinal\n    DWORD dwNames = pExpDIR->NumberOfNames;\n    DWORD *pNames = (DWORD *)((BYTE *)pDOSHDR + pExpDIR->AddressOfNames);\n    WORD *pNameOrd = (WORD *)((BYTE *)pDOSHDR + pExpDIR->AddressOfNameOrdinals);\n    DWORD j = 0;\n    char *pszName = NULL;\n    SIZE_T nLen = 0;\n    for (j = 0; j < dwNames; j++)\n    {\n        if (pNameOrd[j] == i)\n        {\n            pszName = (char *)pDOSHDR + pNames[j];\n            nLen = strlen(pszName);\n            /*printf(\"%X\\t%04X\\t%s  \n\",\n                *(DWORD *)ptrAPI,\n                j,\n                pszName\n            );*/\n\n            //Save information\n            IAT_Import_Information iat_found = { 0 };\n            iat_found.IATAddress = ptrAPI;\n            strcpy(iat_found.IATFunctionName, pszName);\n            strcpy(iat_found.IATModuleName, iat_module_info->DllName);\n            listOfIATImports.push_back(iat_found);\n            if(ptrAPIObfuscated)\n                printf(\"Added Obfuscated %X %X, %s -> %s  \n\", ptrAPI, ptrAPIObfuscated, iat_module_info->DllName, pszName);\n            else\n                printf(\"Added %X %X, %s -> %s  \n\", ptrAPI, *(DWORD*)ptrAPI, iat_module_info->DllName, pszName);\n        }\n    }\n}\n\n/************************************************************************/\n/*\nFunction : rebuild Import Info according to IAT\nParams   : ptrIAT point to the page where IAT in\nppBuf [IN/OUT] is the memory space for the exe, may be updated\ndwImageSize is the exe's image size                                                                  */\n/************************************************************************/\nvoid FixImport(DWORD dwPID, DWORD ptrIAT, DWORD ptrIATEnd, DWORD dwImageSize)\n{\n    if (gs_ModuleList.size() == 0) {\n        printf(\"No Modules loaded, can't fix anything  \n\");\n        return;\n    }\n\n    //now verify every DWORD item is a valid FuncPtr with some dll.\n    //we need to snapshot the process.\n    std::list<IAT_Module_Info>::iterator it;\n    IAT_Module_Info iat_module_info;\n    printf(\"ptrIAT = %X ptrIATEnd = %X  \n\", ptrIAT, ptrIATEnd);\n\n    DWORD ptrIndex = ptrIAT;\n    DWORD dwModBase = NULL;  //利用局部性原理，减少比较\n    DWORD dwModSize = NULL;\n    DWORD dwModHit = NULL;\n    while (TRUE)\n    {\n        //thz should always continue, even if BadPtr or invalid funcptr\n        if (ptrIndex <= ptrIATEnd\n            && IsBadReadPtr((const void *)*(DWORD *)ptrIndex, sizeof(DWORD)))\n        {\n            ptrIndex += sizeof(DWORD);\n            continue;\n        }\n\n        //now we may end, be careful\n        if (ptrIndex > ptrIATEnd\n            && (NULL == *(DWORD*)ptrIndex)\n            && (NULL == *(DWORD*)(ptrIndex + sizeof(DWORD))))\n        {\n            break;\n        }\n\n        if (ptrIndex > ptrIATEnd\n            && IsBadReadPtr((const void *)*(DWORD *)ptrIndex, sizeof(DWORD))\n            )\n        {\n            ptrIndex += sizeof(DWORD);\n            continue;\n        }\n\n        //////////////////////////////////////////////////////////////////////////\n        //whether in a module range\n        dwModHit = NULL;\n\n        //局部性原理，减少遍历\n        if (*(DWORD *)ptrIndex >= dwModBase\n            && *(DWORD *)ptrIndex < dwModBase + dwModSize)\n        {\n            dwModHit = dwModBase;\n        }\n\n        //have to loop every module\n        if (dwModHit == NULL)\n        {\n            for (it = gs_ModuleList.begin(); it != gs_ModuleList.end(); it++)\n            {\n                iat_module_info = *it;\n                dwModBase = (DWORD)iat_module_info.ImageBase;\n                dwModSize = (DWORD)iat_module_info.ImageSize;\n\n                if (*(DWORD *)ptrIndex >= dwModBase\n                    && *(DWORD *)ptrIndex < dwModBase + dwModSize)\n                {\n                    //printf(\"ptrIndex %X %X, Mod: %X, Size: %X  \n\", *(DWORD *)ptrIndex, ptrIndex, dwModBase, dwModSize);\n                    //printf(\"Module: %s  \n\", iat_module_info.DllName);\n                    break;\n                }\n                memset(&iat_module_info, 0, sizeof(IAT_Module_Info));\n            }//end for(\n        }//end if(NULL == \n\n        if (iat_module_info.ImageBase == 0 && iat_module_info.ImageSize == 0) {\n            bool passDone = false;\n            bool Found = false;\n            IAT_Module_Info iat_module_info_temp;\n\n            DWORD deObfuscatedAddress = *(DWORD*)ptrIndex;\n            retryPass:\n            printf(\"Check = %X %X %X  \n\", deObfuscatedAddress, (BYTE)deObfuscatedAddress, *(BYTE*)deObfuscatedAddress);\n\n            for (it = gs_ModuleList.begin(); it != gs_ModuleList.end(); it++)\n            {\n                iat_module_info_temp = *it;\n                dwModBase = (DWORD)iat_module_info_temp.ImageBase;\n                dwModSize = (DWORD)iat_module_info_temp.ImageSize;\n\n                if (deObfuscatedAddress >= dwModBase\n                    && deObfuscatedAddress < dwModBase + dwModSize)\n                {\n                    //printf(\"ptrIndex %X %X, Mod: %X, Size: %X  \n\", deObfuscatedAddress, ptrIndex, dwModBase, dwModSize);\n                    //printf(\"Module: %s  \n\", iat_module_info.DllName);\n                    Found = true;\n                    break;\n                }\n            }\n            if (Found) {\n                printf(\"Found Check = %X  \n\", deObfuscatedAddress);\n                GetAPIInfo(ptrIndex, &iat_module_info_temp, deObfuscatedAddress);\n                ptrIndex += sizeof(DWORD);\n                continue;\n            } else if (!passDone) {\n                passDone = true;\n                if (*(BYTE*)deObfuscatedAddress == 0xE9) //JMP relative\n                    deObfuscatedAddress = (*(DWORD*)(deObfuscatedAddress + 1)) + deObfuscatedAddress + 5;\n                else if (*(BYTE*)deObfuscatedAddress == 0x68 && *(BYTE*)(deObfuscatedAddress + 5) == 0xC3) { //PUSH\n                    printf(\"PUSH = %X %X +5[%X]  \n\", deObfuscatedAddress, *(DWORD*)(deObfuscatedAddress + 1), *(BYTE*)(deObfuscatedAddress + 5));\n                    deObfuscatedAddress = *(DWORD*)(deObfuscatedAddress + 1);\n                } else if (*(BYTE*)deObfuscatedAddress == 0xA1 && *(BYTE*)(deObfuscatedAddress + 5) == 0xC3) { //A1 MOV EAX, [XXXXXX]\n                    printf(\"A1 = %X %X +5[%X]  \n\", deObfuscatedAddress, *(DWORD*)(deObfuscatedAddress + 1), *(BYTE*)(deObfuscatedAddress + 5));\n                    deObfuscatedAddress = *(DWORD*)(deObfuscatedAddress + 1);\n                } else if (*(BYTE*)deObfuscatedAddress == 0xFF && *(BYTE*)(deObfuscatedAddress + 1) == 0x35 && *(BYTE*)(deObfuscatedAddress + 6) == 0x58) { //push [XXXXXX]\n                    printf(\"PUSH2 = %X %X  \n\", deObfuscatedAddress, *(DWORD*)(deObfuscatedAddress + 2));\n                    deObfuscatedAddress = *(DWORD*)(deObfuscatedAddress + 2);\n                } else if ((BYTE)deObfuscatedAddress == 0xC8) { //enter (invalid opcode)\n                    printf(\"invalid 0xC8 = %X %X %X  \n\", ptrIndex, deObfuscatedAddress, (DWORD*)deObfuscatedAddress);\n                    deObfuscatedAddress = *(DWORD*)(ptrIndex + insn_len((void*)ptrIndex));\n                    printf(\"invalid 0xC8 = %X %X %X  \n\", ptrIndex, deObfuscatedAddress, (DWORD*)deObfuscatedAddress);\n                    passDone = false;\n                }\n                goto retryPass;\n            } else {\n                printf(\"not found import :(  \n\");\n                ptrIndex += sizeof(DWORD);\n                continue;\n            }\n        }\n\n        //now *ptrIndex in dwModBase\n        //now retrieve API info (Hint, name) from the module's export\n        //printf(\"ptrIndex %X %X, Mod: %X, Size: %X  \n\", *(DWORD *)ptrIndex, ptrIndex, dwModBase, dwModSize);\n        GetAPIInfo(ptrIndex, &iat_module_info);\n        ptrIndex += sizeof(DWORD);\n    }\n}\n\n/************************************************************************/\n/*\nFunction : Get AddressOfEntryPoint  (or Original Entry Point)\nParams   : lpAddr is the Base where the exe mapped into\nReturn   : OEP (RVA)             */\n/************************************************************************/\nDWORD GetOEP(LPVOID lpAddr)\n{\n    PIMAGE_DOS_HEADER pDOSHDR = (PIMAGE_DOS_HEADER)lpAddr;\n    PIMAGE_NT_HEADERS pNTHDR = (PIMAGE_NT_HEADERS)((unsigned char *)pDOSHDR + pDOSHDR->e_lfanew);\n    return pNTHDR->OptionalHeader.AddressOfEntryPoint;\n}\n\n/************************************************************************/\n/*\nFunction : Retrieve a process's Import Info only by IAT\nParam    : lpAddr is the address the exe mapped into (within our space)\nptrIATEnd [out] used to receive the 1st IAT we found (FF25 XXXX, FF15YYYY)\nReturn   : the beginning of the page where IAT in\nSearch for FF25 XXXX,  or FF15 yyyy\nHelloWorld.exe\n004001E0 > .  EA07D577      DD USER32.MessageBoxA\n004001E4      00000000      DD 00000000\n004001E8 >/$  6A 00         PUSH 0                                   ; /Style = MB_OK|MB_APPLMODAL\n004001EA  |.  6A 00         PUSH 0                                   ; |Title = NULL\n004001EC  |.  6A 00         PUSH 0                                   ; |Text = NULL\n004001EE  |.  6A 00         PUSH 0                                   ; |hOwner = NULL\n004001F0  |.  E8 01000000   CALL <JMP.&USER32.MessageBoxA>           ; \\MessageBoxA\n004001F5  \\.  C3            RETN\n004001F6   $- FF25 E0014000 JMP DWORD PTR DS:[<&USER32.MessageBoxA>] ;  USER32.MessageBoxA\nNotepad.exe\n0100740B   .  FF15 38130001      CALL DWORD PTR DS:[<&msvcrt.__set_app_ty>;  msvcrt.__set_app_type\nMSPaint.exe\n1000CA65    8B35 58D10110   MOV ESI,DWORD PTR DS:[<&KERNEL32.LCMapSt>; kernel32.LCMapStringW\n*/\n/************************************************************************/\n\n/*\nNeed to check all of these\n– 8B0D MOV ECX,[ADDRESS]\n– 8B15 MOV EDX,[ADDRESS]\n– 8B1D MOV EBX,[ADDRESS]\n– 8B25 MOV ESP,[ADDRESS]\n– 8B2D MOV EBP,[ADDRESS]\n– 8B35 MOV ESI,[ADDRESS]\n– 8B3D MOV EDI,[ADDRESS]\n– A1 MOV EAX,[ADDRESS]\n- FF15 CALL [ADDRESS]\n– FF25 JMP [ADDRESS]\n– FF35 PUSH [ADDRESS]\n*/\n\nDWORD SearchIAT(LPVOID lpAddr, DWORD dwImageSize, DWORD pImageBase, DWORD dwMaxIATImageSize, DWORD *ptrIATEnd)\n{\n    DWORD pImageSectionStart = 0;\n    DWORD instruction_length;\n    DWORD *ptrFuncAddr = NULL;     //like xxx in JMP DWORD PTR DS:[XXXX]\n    DWORD ptrFuncAddrHighest = NULL;\n    DWORD dwOEP = NULL;\n    BYTE *pCode = NULL;\n    DWORD i = NULL;\n    WORD  wJMP = 0x25FF;\n    WORD  wCALL = 0x15FF;\n\n    dwOEP = GetOEP(lpAddr);\n    i = dwOEP;\n    pCode = (BYTE *)((BYTE *)lpAddr + dwOEP);\n\n    // get the location of the module's IMAGE_NT_HEADERS structure\n    IMAGE_NT_HEADERS *pNtHdr = ImageNtHeader(lpAddr);\n    // section table immediately follows the IMAGE_NT_HEADERS\n    IMAGE_SECTION_HEADER *pSectionHdr = (IMAGE_SECTION_HEADER *)(pNtHdr + 1);\n\n    bool got = false;\n    for (int scn = 0; scn < pNtHdr->FileHeader.NumberOfSections; ++scn)\n    {\n        char *name = (char*)pSectionHdr->Name;\n        DWORD SectionStart = (DWORD)lpAddr + pSectionHdr->VirtualAddress;\n        DWORD SectionEnd = (DWORD)lpAddr + pSectionHdr->VirtualAddress + pSectionHdr->Misc.VirtualSize - 1;\n\n        if (got) {\n            pImageSectionStart = SectionStart;\n            break;\n        }\n\n        if (SectionStart == pImageBase + dwOEP && SectionEnd < dwImageSize) {\n            got = true;\n            //next one is imports.\n            ++pSectionHdr;\n            continue;\n        }\n        ++pSectionHdr;\n    }\n\n    if (!pImageSectionStart)\n        pImageSectionStart = dwImageSize;\n\n    printf(\"Found OEP at %X, ImageSize = %X,%X  \n\", dwOEP, dwImageSize, pImageSectionStart);\n\n    //search for FF 25 XXXX, FF 15 YYYY from OEP, had better use Disasm engine \n    //but we just do it simply\n    while (i < pImageSectionStart)\n    {\n        if (memcmp(pCode, &wJMP, sizeof(WORD))\n            && memcmp(pCode, &wCALL, sizeof(WORD)))\n        {\n            //\n            instruction_length = insn_len(pCode);\n            pCode += instruction_length;\n            i += instruction_length;\n            continue;\n        }\n\n        //check illegal, *ptrFuncAddr > pImageBase  && *ptrFuncAddr <= pImageBase + dwImageSize\n        ptrFuncAddr = (DWORD *)(pCode + sizeof(WORD));\n        if (*ptrFuncAddr < (DWORD)pImageBase || *ptrFuncAddr >= (DWORD)pImageBase + dwImageSize)\n        {\n            instruction_length = insn_len(pCode);\n            pCode += instruction_length;\n            i += instruction_length;\n            continue;\n        }\n\n        //need to fix relocation\n        *(DWORD *)ptrFuncAddr = (long)lpAddr + *(long *)ptrFuncAddr - (long)pImageBase;\n        //now found one item that may belongs to IAT\n        ptrFuncAddr = (DWORD *)*ptrFuncAddr;\n\n        if ((DWORD)ptrFuncAddr > ptrFuncAddrHighest) {\n            ptrFuncAddrHighest = (DWORD)ptrFuncAddr;\n            printf(\"highest = %X  \n\", ptrFuncAddrHighest);\n        }\n\n        //recheck illegal, \n        //for system dlls, what about user dlls? well, whatever, there must be system dlls\n        //what if we found IAT for system dlls, so we found the user dlls.\n        //What if the IAT tables are not continous????????\n        if (*ptrFuncAddr < dwMaxIATImageSize)\n        {\n            instruction_length = insn_len(pCode);\n            pCode += instruction_length;\n            i += instruction_length;\n            continue;\n        }\n        break;\n    }\n\n    //now it seems ptrFuncAddr points some item in IAT, \n    //make ptrFuncAddr point to the beginning of the page\n    //we use 0xFFFEFFFF, because ptrFuncAddr is the memory addr we allocated, not by loadlibrary\n    *ptrIATEnd = (DWORD)ptrFuncAddrHighest;\n    ptrFuncAddr = (DWORD*)(((DWORD)ptrFuncAddr & 0xFFFFF000)\n        + ((DWORD)lpAddr & 0x0FFF)\n        );\n    return (DWORD)ptrFuncAddr;\n\n    //return NULL;\n}\n\nunsigned long Get_Import_Address(char* DLL, char* Library, char* Import, int ordinal = -1)\n{\n    HMODULE mhLoadedDLL = NULL;\n    do\n    {\n        if (!DLL)\n            mhLoadedDLL = GetModuleHandle(NULL);\n        else\n            mhLoadedDLL = GetModuleHandle(DLL);\n        Sleep(100);\n    } while (!mhLoadedDLL);\n\n    MODULEINFO modinfo;\n    GetModuleInformation(GetCurrentProcess(), mhLoadedDLL, &modinfo, sizeof(MODULEINFO));\n    DWORD ModuleSize = (unsigned long)modinfo.SizeOfImage;\n\n    PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)mhLoadedDLL;\n    PIMAGE_NT_HEADERS NtHeader;\n    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;\n    UINT Index = 0;\n\n\n    NtHeader = (PIMAGE_NT_HEADERS)(((PBYTE)DosHeader) + DosHeader->e_lfanew);\n    if (NtHeader->Signature != IMAGE_NT_SIGNATURE)\n        return 0;\n\n    ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(((PBYTE)DosHeader) + NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\n\n    if (mhLoadedDLL) {\n        ULONG Sz;\n        ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToDataEx(mhLoadedDLL, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &Sz, nullptr);\n    }\n\n    __try {\n        //\n        // Iterate over import descriptors/DLLs.\n        //\n        for (Index = 0; (ImportDescriptor[Index].Characteristics != 0 || ImportDescriptor[Index].Name); Index++) {\n            PSTR dllName = (PSTR)(((PBYTE)DosHeader) + ImportDescriptor[Index].Name);\n\n            if (_strcmpi(dllName, Library) == 0) {\n                // This the DLL we are after.\n                PIMAGE_THUNK_DATA Thunk;\n                PIMAGE_THUNK_DATA OrigThunk;\n\n                Thunk = (PIMAGE_THUNK_DATA)(((PBYTE)DosHeader) + ImportDescriptor[Index].FirstThunk);\n                OrigThunk = (PIMAGE_THUNK_DATA)(((PBYTE)DosHeader) + ImportDescriptor[Index].OriginalFirstThunk);\n\n                //Reset\n                Thunk = (PIMAGE_THUNK_DATA)(((PBYTE)DosHeader) + ImportDescriptor[Index].FirstThunk);\n                OrigThunk = (PIMAGE_THUNK_DATA)(((PBYTE)DosHeader) + ImportDescriptor[Index].OriginalFirstThunk);\n\n                for (; OrigThunk->u1.Function != NULL; OrigThunk++, Thunk++)\n                {\n                    if (ordinal != -1) {\n                        if ((OrigThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) && IMAGE_ORDINAL(OrigThunk->u1.Ordinal) == ordinal) //send ordinal\n                            return (DWORD)Thunk; //Address of import returns.\n                    }\n\n                    if (OrigThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) { // Ordinal import - we can handle named imports only, so skip it.\n                        continue;\n                    }\n\n                    PIMAGE_IMPORT_BY_NAME importt = (PIMAGE_IMPORT_BY_NAME)(((PBYTE)DosHeader) + OrigThunk->u1.AddressOfData);\n\n                    if (_strcmpi(Import, (char*)importt->Name) == 0) {\n                        return (DWORD)Thunk; //Address of import returns.\n                    }\n                }\n\n                unsigned long ptrFuncsIndex = (unsigned long)ImportDescriptor[Index].FirstThunk + (DWORD)mhLoadedDLL;\n                DWORD impAddress = (DWORD)GetProcAddress(GetModuleHandle(Library), Import);\n\n                //First get all modules loaded, so you can find the maximum ImageBase+ImageSize for IAT Max Size calculation.\n                if (gs_ModuleList.size() == 0) {\n                    BOOL bRet = SnapShotModules((DWORD)GetCurrentProcess());\n                    if (!bRet)\n                    {\n                        printf(\"Failed to get Modules  \n\");\n                        return 0;\n                    }\n                }\n\n                DWORD dwMaxIATImageSize = 0x70000000;\n                if (gs_ModuleList.size() > 0) {\n                    auto max_it = std::max_element(gs_ModuleList.begin(), gs_ModuleList.end(), [](const IAT_Module_Info& l, const IAT_Module_Info& h) {\n                        return l.ImageBase < h.ImageBase;\n                    });\n\n                    if (max_it->ImageBase > 0)\n                        dwMaxIATImageSize = (DWORD)max_it->ImageBase + max_it->ImageSize;\n\n                    printf(\"Highest Imported DLL = %X %s  \n\", max_it->ImageBase, max_it->DllName);\n                }\n                //now we do more, retrieve the Page where IAT in\n                DWORD ptrIATEnd = NULL;\n                DWORD ptrIAT = SearchIAT(mhLoadedDLL, ModuleSize, NtHeader->OptionalHeader.ImageBase, dwMaxIATImageSize, &ptrIATEnd);\n\n                printf(\"Rebuilding IAT,Found IAT in page %X, IAT End %X  \n\", ptrIAT, ptrIATEnd);\n                if(listOfIATImports.size() == 0)\n                    FixImport((DWORD)GetCurrentProcess(), ptrIAT, ptrIATEnd, ModuleSize);\n\n                if (listOfIATImports.size() > 0) {\n                    auto match = std::find_if(listOfIATImports.cbegin(), listOfIATImports.cend(), [Library, Import](const IAT_Import_Information& s) {\n                        return _strcmpi(s.IATModuleName, Library) == 0 && _strcmpi(s.IATFunctionName, Import) == 0;\n                    });\n\n                    if (match != listOfIATImports.cend()) {\n                        printf(\"Found IAT = %X, %s %s  \n\", match->IATAddress, match->IATModuleName, match->IATFunctionName);\n                    }\n\n                    std::list<IAT_Import_Information>::iterator i;\n                    for (i = listOfIATImports.begin();\n                        i != listOfIATImports.end();\n                        i++)\n                    {\n                        printf(\"Module: %s Import: %s Address: %X  \n\", i->IATModuleName, i->IATFunctionName, i->IATAddress);\n                    }\n\n                } else {\n                    printf(\"Couldn't find module %s, import %s  \n\", Library, Import);\n                }\n\n            }\n        }\n    }\n    __except (1) {\n        printf(\"Exception hit parsing imports  \n\");\n    }\n    return 0;\n}\n\n```\nAnother include which is needed is x86_instruction_length.h can \nhttps://pastebin.com/raw/YMSxjPvL\n\nUsage:\n\n```\nDWORD GetTickCountx = Get_Import_Address(NULL, \"kernel32.dll\", \"GetTickCount\");\nif(GetTickCountx) {\n    if (!VirtualProtect((LPVOID)GetTickCountx , 4, new_rights, &old_rights))\n        return 0;\n    *(DWORD*)(GetTickCountx) = (DWORD)(NewTickCount);\n    VirtualProtect((LPVOID)GetTickCountx , 4, old_rights, &new_rights);\n}\n\n```\n\nhttps://github.com/fatrolls/IAT-Imports-Finder\n\n",
      "votes": "1",
      "user": "SSpoke",
      "time": "Jun 15, 2020 at 2:30",
      "is_accepted": true,
      "comments": []
    }
  ]
}