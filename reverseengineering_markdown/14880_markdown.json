{
  "title": "basic reversing question about local variable",
  "link": "https://reverseengineering.stackexchange.com/questions/14880/basic-reversing-question-about-local-variable",
  "content": "I do not understand the following:\n\nin a very simple dummy C function:\n\n```\nvoid vulnerable_function(char* string) { \n    char buffer[100];\n}\n\n```\nWhen I use gdb to disassemble it, I obtain:\n\n```\n0x08048464 <+0>:  push   %ebp\n0x08048465 <+1>:  mov    %esp,%ebp\n0x08048467 <+3>:  sub    $0x88,%esp\n\n```\nI really do not understand why the stack pointer is decremented by 0x88. \n\nI believed that it would be 0x64 instead of 0x88. Can you explain it please?\n\nThank you very much!\n\n",
  "votes": "8",
  "answers": 2,
  "views": "2k",
  "tags": [
    "disassembly",
    "x86"
  ],
  "user": "David Labay",
  "time": "Mar 11, 2017 at 22:01",
  "comments": [
    {
      "user": "Vido",
      "text": "can you add more info about your executable like file ./executable",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "There are several factors involved in how much space is allocated by the compiler for a function's stack frame on the process runtime stack:\n\nStack Frame Specification\n\nThe specification for the stack frame on x86 machines is given in Chapter 3: \"Low-Level System Information\" in the System V Application Binary Interface Intel386 Architecture Processor Supplement, Fourth Edition in the section titled \"Function Calling Sequence\".\n\nNote:\n\nHere are relevant excerpts:\n\nThe \"unspecified\" area in a stack frame is the space created for local variables and where arguments to the function are copied to. This space is managed by the compiler.\n\nHere is a diagram from the ABI:\n\n\nAlignment\n\nIt is the compiler that manages stack frames, and in order for a stack frame to be aligned the alignment of variables within the stack frame must also be known.   \n\nAlignment of variables depends on their type and the architecture of the CPU.\nThis is also specified in the ABI:\n\n\nThere are conventions that pertain specifically to the alignment of arrays, structures and unions:\n\nHowever, on i386 architecture systems, GCC aligns the stack to a 16-byte boundary by default:\n\nThis means that the compiler allocates 16 bytes of space on the stack frame for variables whose type sizes are less than 16 bytes. For example, even though an int is 4 bytes on an i386 system, the compiler would still allocate 16 bytes of space on the stack frame for it.\n\nLet us analyze how the compiler allocates space on a function's stack frame with 2 simple examples: a function with a char pointer local variable and a function with a 100-byte char array.\n\nA function called pointer_test with char pointer local variable:\n\n```\nvoid pointer_test(void) {\n    char *i = \"test\";\n}\n\n```\nAssembly code generated by gcc + as:\n\n```\nDump of assembler code for function pointer_test:\n   0x080483db <+0>:     push   %ebp\n   0x080483dc <+1>:     mov    %esp,%ebp\n   0x080483de <+3>:     sub    $0x10,%esp  <-- 16 bytes of space created for 4-byte pointer\n   0x080483e1 <+6>:     movl   $0x8048480,-0x4(%ebp)\n   0x080483e8 <+13>:    nop\n   0x080483e9 <+14>:    leave  \n   0x080483ea <+15>:    ret  \n\n```\nHere we see that 16 bytes of space were allocated for a 4-byte pointer.\n\nA function called char_array_test with a char array local variable:\n\n```\nvoid char_array_test(void) {\n    char buffer[100];\n}\n\n```\nAssembly code generated by gcc + as:\n\n```\nDump of assembler code for function char_array_test:\n   0x0804844b <+0>:     push   %ebp\n   0x0804844c <+1>:     mov    %esp,%ebp\n   0x0804844e <+3>:     sub    $0x78,%esp  <-- 120 bytes of space created for 100-byte array\n   0x08048451 <+6>:     mov    %gs:0x14,%eax\n   0x08048457 <+12>:    mov    %eax,-0xc(%ebp)\n   0x0804845a <+15>:    xor    %eax,%eax\n   0x0804845c <+17>:    nop\n   0x0804845d <+18>:    mov    -0xc(%ebp),%eax\n   0x08048460 <+21>:    xor    %gs:0x14,%eax\n   0x08048467 <+28>:    je     0x804846e <char_array_test+35>\n   0x08048469 <+30>:    call   0x8048310 <__stack_chk_fail@plt>\n   0x0804846e <+35>:    leave  \n   0x0804846f <+36>:    ret\n\n```\nHere we see that 120 bytes of space were allocated for a 100-byte array.    \n\nIn the case of void vulnerable_function(char *string), space in the stack frame must be allocated by gcc for a 4-byte pointer and a 100-byte array. \n\n0x10 bytes for string + 0x78 bytes for buffer[100] = 0x88\n\n\n\nCompiler Explorer is an interactive compiler that runs in your browser. Playing around with it is much faster than constantly recompiling code and disassembling it.\n\nThe System V Application Binary Interface Intel386 Architecture Processor Supplement, Fourth Edition\n\n Intel 386 and AMD x86-64 Options for GCC\n\ncdecl and x86 calling conventions discusses calling conventions in x86 compilers\n\nPoke-a-hole and friends is an\narticle that discusses how structures are padded in order to maintain alignment and how this changes across architectures.\n\nrelated SO questions\n\nStack allocation, padding, and alignment\n\nwhat is “stack alignment”?\n\n",
      "votes": "12",
      "user": "Community",
      "time": "May 23, 2017 at 12:37",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "As SYS_V correctly cites in his answer, the GCC documentation states that GCC will work to align the stack pointer to 16-byte boundaries by default.\n\nWe find some reasoning as to why this is done as well (NB: On the 64-bit architecture, 16-byte alignment is mandatory):\n\nNote, however, that this is mostly about the stack frame (boundary), not necessarily the individual objects on the stack. This frame alignment happens not inside the function, but at the call site where you will see something like this (note the extra subtraction from %esp):\n\n```\n sub    $0xc,%esp                # pad stack by 12 bytes\n push   %eax                     # push 4-byte argument\n call   vulnerable_function\n\n```\nNevertheless it makes sense to keep (some) objects aligned as well.\n\nIn your example, you encounter 0x88 (=136) bytes allocated for the 100-byte buffer while SYS_V got 0x78 (=120) for the same. Note that both these values are congruent 8 modulo 16. This is chosen because at this point, your stack frame already includes two 4-byte values: the return address and the saved frame pointer. With these combined, you end up 16-byte-aligned after the allocation.\n\n",
      "votes": "4",
      "user": "pesco",
      "time": "Aug 3, 2018 at 12:47",
      "is_accepted": false,
      "comments": []
    }
  ]
}