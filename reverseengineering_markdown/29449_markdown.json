{
  "title": "What does the instructions sequence call/cdqe/ret do?",
  "link": "https://reverseengineering.stackexchange.com/questions/29449/what-does-the-instructions-sequence-call-cdqe-ret-do",
  "content": "I'm trying to reverse a Linux module. In the ioctl routine, I have the following sequence of instructions (generated by objdump -M intel -d test.ko):\n\n```\n 3f9:   74 3b                   je     436 <device_ioctl+0x46>\n...\n 436:   e8 00 00 00 00          call   43b <device_ioctl+0x4b>\n 43b:   48 98                   cdqe   \n 43d:   c3                      ret\n\n```\nI'm not sure to understand what happens here after the jump is done.\n\nFirst, we have a call instruction. The opcode is E8 00 so it is a near call to the next instruction. The EIP register (which contain the address of the next instruction) is also pushed on the stack.\n\nThen, we continue with the cdqe instruction. It extends the sign of the EAX register into RAX. In other words, it does nothing. Just to mention, EAX/RAX register has not been modified from the beginning of the routine.\n\nFinally, the ret instruction is executed. It pops the stack into EIP which corresponds to the previous instruction and we continue the execution of the routine from that point.\n\nTherefore, cdqe is executed again (to do nothing) and the ret instruction is called again. This time, we leave the ioctl routine and return to the callee.\n\nAm I right saying this does nothing? If so, what is the point of that code?\n\nHere is the full routine:\n\n```\n00000000000003f0 <device_ioctl>:\n 3f0:   48 89 d7                mov    rdi,rdx\n 3f3:   81 fe 03 b0 fe ca       cmp    esi,0xcafeb003\n 3f9:   74 3b                   je     436 <device_ioctl+0x46>\n 3fb:   77 18                   ja     415 <device_ioctl+0x25>\n 3fd:   81 fe 01 b0 fe ca       cmp    esi,0xcafeb001\n 403:   74 39                   je     43e <device_ioctl+0x4e>\n 405:   81 fe 02 b0 fe ca       cmp    esi,0xcafeb002\n 40b:   75 39                   jne    446 <device_ioctl+0x56>\n 40d:   e8 00 00 00 00          call   412 <device_ioctl+0x22>\n 412:   48 98                   cdqe   \n 414:   c3                      ret    \n 415:   48 c7 c0 00 00 00 00    mov    rax,0x0\n 41c:   48 c7 c2 ff ff ff ff    mov    rdx,0xffffffffffffffff\n 423:   48 2d 00 00 00 00       sub    rax,0x0\n 429:   81 fe 04 b0 fe ca       cmp    esi,0xcafeb004\n 42f:   89 c0                   mov    eax,eax\n 431:   48 0f 45 c2             cmovne rax,rdx\n 435:   c3                      ret    \n 436:   e8 00 00 00 00          call   43b <device_ioctl+0x4b>\n 43b:   48 98                   cdqe   \n 43d:   c3                      ret    \n 43e:   e8 00 00 00 00          call   443 <device_ioctl+0x53>\n 443:   48 98                   cdqe   \n 445:   c3                      ret    \n 446:   48 83 c8 ff             or     rax,0xffffffffffffffff\n 44a:   c3                      ret    \n\n```\nThis is from the nightclub challenge of the pbctf 2021.\n\n",
  "votes": "1",
  "answers": 1,
  "views": "357",
  "tags": [
    "kernel",
    "assembly"
  ],
  "user": "Pierre",
  "time": "Oct 23, 2021 at 8:52",
  "comments": [],
  "answers_data": [
    {
      "content": "cdqe does this RAX ‚Üê sign-extend of EAX.\napplicable only in x64\nshown below is a demo of x86 cdq which instead of using rax uses eax,edx combo\nedx gets the sign extension  in x86\n\nfor cdqe register rax will become 0xffffffff<eax> or 0x00000000<eax>\n\n\n\nmaybe ctf is checking the sign\n\n",
      "votes": "1",
      "user": "blabb",
      "time": "Oct 23, 2021 at 10:49",
      "is_accepted": false,
      "comments": []
    }
  ]
}