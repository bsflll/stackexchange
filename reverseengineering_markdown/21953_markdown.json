{
  "title": "What is the purpose of consecutive ADC instructions to a single register?",
  "link": "https://reverseengineering.stackexchange.com/questions/21953/what-is-the-purpose-of-consecutive-adc-instructions-to-a-single-register",
  "content": "To clarify, I understand how ADC works. It's the same as a regular ADD but with an extra 1 if the Carry Flag was set.\n\nIts use in the snippet below makes perfect sense to me since an overflow is most likely going to occur, setting the CF flag, when adding two 64-bit values in a 32-bit context:\n\n```\nAssume EDX:EAX and EBX:ECX pairs hold two 64 bit values that are to be added together.\n\nadd     eax, ecx\nadc     edx, ebx\nmov     dword [ebp+Some64BitValue], eax\nmov     dword [ebp+Some64BitValue+4], edx\n\n```\nWhat I fail to understand the meaning of is when ADC is used consecutively on the same variable/register like this:\n\n```\nadd     eax, dword [esi]\nadc     eax, dword [esi+0x4]\nadc     eax, dword [esi+0x8]\nadc     eax, dword [esi+0x10]\n...\nadc     eax, 0\n\n```\nGenerally speaking what would be the purpose of doing this? What is meant to be of EAX?\n\n*update:\n\nsee my answer below\n\n",
  "votes": "3",
  "answers": 2,
  "views": "647",
  "tags": [
    "assembly",
    "x86",
    "math"
  ],
  "user": "Nux",
  "time": "Aug 22, 2019 at 13:52",
  "comments": [
    {
      "user": "Igor Skochinsky",
      "text": "can you post a bigger snippet? e.g. how eax  is initialized?",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "I found the answer to my question.\n\nEAX is arbitrary, as are the values added to it from [ESI].\n\nThe function I'm reversing is a calculating a 16-bit checksum after adding together data, in the manner you see above, and then folding the result in EAX to AX.\n\nI did some more research and found this article on Additive Checksums. The one I'm looking at is similar to The Internet Checksum described there.\n\nThe purpose of consecutive ADC instructions in this case looks like an optimisation made available only at the assembly level. The checksum is performing ones compliment addition multiple times. Another way to perform the same operations, only with ADD, would be to let the carry bits accumulate in the upper half of the register and then add them back to the lower half at the end.\n\n",
      "votes": "4",
      "user": "Nux",
      "time": "Aug 22, 2019 at 13:52",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "without resorting to inline assembly / seperate assembly module i was able to generate consecutive adc instruction using the intrinsic _addcarry_uxx (16,32,64)  (with full optimizations on /O1 switch in msvc cl.exe )\n\nrelevant code and its disassembly below\n\n```\n#include <stdio.h>\n#include <intrin.h>\n#define BUSIZ  16\n#define UNROLL 8\nunsigned int dat[BUSIZ] = \n{\n    0x10001337, 0xffffffff, 0x10001337 , 0xffffffff,\n    0x00001337, 0xdeadbeef, 0xbeadbed5 , 0xdad15dad,\n    0xba5eba11, 0xf001b055, 0xc001b055 , 0x501eb055,\n    0xba11ba75, 0xbadba115, 0xbed15bad , 0xdaff0d11\n};    \nint main (void) \n{\n    unsigned int chksum = 0;\n    unsigned char carry = 0;\n    for(int i=0; i< BUSIZ; i += UNROLL )\n    {\n        carry = _addcarry_u32(carry,chksum,dat[i+0],&chksum);\n        carry = _addcarry_u32(carry,chksum,dat[i+1],&chksum);\n        carry = _addcarry_u32(carry,chksum,dat[i+2],&chksum);\n        carry = _addcarry_u32(carry,chksum,dat[i+3],&chksum);        \n        carry = _addcarry_u32(carry,chksum,dat[i+4],&chksum);\n        carry = _addcarry_u32(carry,chksum,dat[i+5],&chksum);\n        carry = _addcarry_u32(carry,chksum,dat[i+6],&chksum);\n        carry = _addcarry_u32(carry,chksum,dat[i+7],&chksum);\n    }\n    printf(\"FINAL CHECKSUM = %8x  \n\" , chksum + carry );  \n    return 0;\n}\n\n```\nexecuted it prints out \n\n```\n:\\>addcarry.exe\nFINAL CHECKSUM = 616ba476\n\n```\npython script to chk veracity of result\n\n```\n:\\>cat chksum.py\ndat = [\n    0x10001337, 0xffffffff, 0x10001337 , 0xffffffff,\n    0x00001337, 0xdeadbeef, 0xbeadbed5 , 0xdad15dad,\n    0xba5eba11, 0xf001b055, 0xc001b055 , 0x501eb055,\n    0xba11ba75, 0xbadba115, 0xbed15bad , 0xdaff0d11\n]\nchksum33bit = 0\nfor i in range (0,16,1):\n    chksum33bit = chksum33bit + dat[i]\nchklow = chksum33bit & 0xffffffff\nchkhig = chksum33bit >> 32\nchkfin = chklow+chkhig\nprint (hex(chkfin))\n\n:\\>python chksum.py\n0x616ba476L\n\n```\ndisassembling we see compiler has generated consecutive adc instructions\n\n```\n:\\>cdb -c \"uf addcarry!main;q\" addcarry.exe | grep -B 31 quit\n0:000> cdb: Reading initial command 'uf addcarry!main;q'\naddcarry!main:\n01151029 33c9            xor     ecx,ecx\n0115102b b804901901      mov     eax,offset addcarry!dat+0x4 (01199004)\n01151030 8ad1            mov     dl,cl\n\naddcarry!main+0x9:\n01151032 80c2ff          add     dl,0FFh\n01151035 1348fc          adc     ecx,dword ptr [eax-4]\n01151038 1308            adc     ecx,dword ptr [eax]\n0115103a 134804          adc     ecx,dword ptr [eax+4]\n0115103d 134808          adc     ecx,dword ptr [eax+8]\n01151040 13480c          adc     ecx,dword ptr [eax+0Ch]\n01151043 134810          adc     ecx,dword ptr [eax+10h]\n01151046 134814          adc     ecx,dword ptr [eax+14h]\n01151049 134818          adc     ecx,dword ptr [eax+18h]\n0115104c 0f92c2          setb    dl\n0115104f 83c020          add     eax,20h\n01151052 3d44901901      cmp     eax,offset addcarry!__scrt_default_matherr (01199044)\n01151057 7cd9            jl      addcarry!main+0x9 (01151032)\n\naddcarry!main+0x30:\n01151059 0fb6c2          movzx   eax,dl\n0115105c 03c1            add     eax,ecx\n0115105e 50              push    eax\n0115105f 6890011901      push    offset addcarry!`string' (01190190)\n01151064 e805000000      call    addcarry!printf (0115106e)\n01151069 59              pop     ecx\n0115106a 59              pop     ecx\n0115106b 33c0            xor     eax,eax\n0115106d c3              ret\nquit:\n\n```\neven though i could generate several adc's\ni couldn't successfully generate \nconsecutive adc using c compiler\nso i looked around windows\\system32 directory if any of the binaries has consecutive adc's\nlocated one in imagehlp.dll\nand some googling later it appears it is RFC1071  IP Header Checksum\nprobably written using handwritten assembly (found some assembly codes for motorola , cray etc  in the link also here is a google group link that discusses the Implementation of ChkSum  there is also an old Dave Cutler authored ChkSum()  from a NT imagehelp toolkit sdk that was released by ms around 1993 )  \n\nbelow  is win7 sp1 32 bit imagehlp.dll adc sequence\n\n```\ngrep -obUaPs \"\\x13\\x46\\x04\\x13\\x46\\x08\" --include=*.dll *\n\nimagehlp.dll:17883:‼F♦‼F\nimagehlp.dll:17917:‼F♦‼F\nimagehlp.dll:17963:‼F♦‼F\nimagehlp.dll:18021:‼F♦‼F\n\nxxd -c 12 -g 3 -s 18021 -l 99 imagehlp.dll\n\n0004665: 134604 134608 13460c 134610  .F..F..F..F.\n0004671: 134614 134618 13461c 134620  .F..F..F..F\n000467d: 134624 134628 13462c 134630  .F$.F(.F,.F0\n0004689: 134634 134638 13463c 134640  .F4.F8.F<.F@\n0004695: 134644 134648 13464c 134650  .FD.FH.FL.FP\n00046a1: 134654 134658 13465c 134660  .FT.FX.F\\.F`\n00046ad: 134664 134668 13466c 134670  .Fd.Fh.Fl.Fp\n00046b9: 134674 134678 13467c 83d000  .Ft.Fx.F|...\n00046c5: 81c680                       ...\n\ndumpbin /headers imagehlp.dll | grep -i \"section header #1\" -A 5\n\nSECTION HEADER #1\n   .text name\n   23249 virtual size\n    1000 virtual address (41871000 to 41894248)\n   23400 size of raw data\n     600 file pointer to raw data (00000600 to 000239FF)\n\ncdb -c \"ln (imagehlp + 1000 + (0n18021-0x600));q\" -z imagehlp.dll | grep -i -A 1 reading\n\n0:000> cdb: Reading initial command 'ln (imagehlp + 1000 + (0n18021-0x600));q'\n\n(41874f7b)   imagehlp!ChkSum+0xea   |  (41875105)   imagehlp!_SEH_prolog4_GS\n\n```\nthere  may be several adc's because the compilation was not optimized is one of the reason \n\nassuming you have some code like this \n\n```\n#include <stdio.h>\n#include <windows.h>\n\nint main (void) {\n    DWORD64 a = 0x100002000;\n    DWORD64 b = 0x00000000ffffffff;\n    DWORD64 c = a + b;    \n    printf(\"%I64x  \n\" , a);\n    printf(\"%I64x  \n\" , b);\n    printf(\"%I64x  \n\" , c);\n    c = c + a;\n    printf(\"%I64x  \n\" , c);\n    c = c + b;\n    printf(\"%I64x  \n\" , c);\n    c = c + c;\n    printf(\"%I64x  \n\" , c);    \n    return 0;\n}\n\n```\nif you compile this without optimization\ndisassemble the function main and look for adc instructions\nyou will see several adc instructions including some that use the same register   \n\n```\ncl /Zi /EHsc /W4 /Od /nologo /analyze adc.cpp /link /release /nologo adc.cpp  \n\ncdb -c \"g adc!main;uf .;q\" adc.exe | grep -i \"adc \"\n000a102b 134dec          adc     ecx,dword ptr [ebp-14h]\n000a107c 1345f4          adc     eax,dword ptr [ebp-0Ch]\n000a10a3 134dec          adc     ecx,dword ptr [ebp-14h]\n000a10ca 1355fc          adc     edx,dword ptr [ebp-4]\n\n```\nbut if you optimize compiler is smart enough to remove all Adc instructions\n\n```\ncl /Zi /EHsc /W4 /Ox /nologo /analyze adc.cpp /link /release /nologo adc.cpp\n\ncdb -c \"g adc!main;uf .;q\" adc.exe | grep -i \"adc \"\n\nadc.exe\n100002000\nffffffff\n200001fff\n300003fff\n400003ffe\n800007ffc\n\n```\nthe code you have in question might be result of a subroutine that performs pure addition and returns the result as below \n\n```\n#include <stdio.h>\n#include <windows.h>\n#pragma optimize ( \"t\" , off)\nDWORD64  madd (DWORD64 a, DWORD64 b) \n{\n    DWORD64 c = 0;\n    c = a + b;  \n    c = c + a;    \n    c = c + b;\n    c = c + c;\n    return c;    \n}\n#pragma optimize ( \"t\" , on)\nint main (void) {\n    DWORD64 a = 0x100002000;\n    DWORD64 b = 0x00000000ffffffff;\n    printf(\"%I64x  \n\" , madd(a,b));    \n    return 0;\n}\n\n```\nhere is the disassembly of the functions that adds multiple64 bit values and returns the result\n\ndisassembly of function madd \n\n```\n0:000> uf adc!madd\nadc!madd [adc.cpp @ 6]:\n    6 00291000 55              push    ebp\n    6 00291001 8bec            mov     ebp,esp\n    6 00291003 51              push    ecx\n    6 00291004 51              push    ecx\n    7 00291005 0f57c0          xorps   xmm0,xmm0\n    7 00291008 660f1345f8      movlpd  qword ptr [ebp-8],xmm0\n    8 0029100d 8b4508          mov     eax,dword ptr [ebp+8]\n    8 00291010 034510          add     eax,dword ptr [ebp+10h]\n    8 00291013 8b4d0c          mov     ecx,dword ptr [ebp+0Ch]\n    8 00291016 134d14          adc     ecx,dword ptr [ebp+14h]\n    8 00291019 8945f8          mov     dword ptr [ebp-8],eax\n    8 0029101c 894dfc          mov     dword ptr [ebp-4],ecx\n    9 0029101f 8b45f8          mov     eax,dword ptr [ebp-8]\n    9 00291022 034508          add     eax,dword ptr [ebp+8]\n    9 00291025 8b4dfc          mov     ecx,dword ptr [ebp-4]\n    9 00291028 134d0c          adc     ecx,dword ptr [ebp+0Ch]\n    9 0029102b 8945f8          mov     dword ptr [ebp-8],eax\n    9 0029102e 894dfc          mov     dword ptr [ebp-4],ecx\n   10 00291031 8b45f8          mov     eax,dword ptr [ebp-8]\n   10 00291034 034510          add     eax,dword ptr [ebp+10h]\n   10 00291037 8b4dfc          mov     ecx,dword ptr [ebp-4]\n   10 0029103a 134d14          adc     ecx,dword ptr [ebp+14h]\n   10 0029103d 8945f8          mov     dword ptr [ebp-8],eax\n   10 00291040 894dfc          mov     dword ptr [ebp-4],ecx\n   11 00291043 8b45f8          mov     eax,dword ptr [ebp-8]\n   11 00291046 0345f8          add     eax,dword ptr [ebp-8]\n   11 00291049 8b4dfc          mov     ecx,dword ptr [ebp-4]\n   11 0029104c 134dfc          adc     ecx,dword ptr [ebp-4]\n   11 0029104f 8945f8          mov     dword ptr [ebp-8],eax\n   11 00291052 894dfc          mov     dword ptr [ebp-4],ecx\n   12 00291055 8b45f8          mov     eax,dword ptr [ebp-8]\n   12 00291058 8b55fc          mov     edx,dword ptr [ebp-4]\n   14 0029105b c9              leave\n   14 0029105c c3              ret\n\n```\nthe function uses the same register ecx for adding multiple carryovers\n\n```\n0:000> # adc*, adc!madd l 60\nadc!madd+0x16 [adc.cpp @ 8]:\n00291016 134d14          adc     ecx,dword ptr [ebp+14h]  \nadc!madd+0x28 [adc.cpp @ 9]:\n00291028 134d0c          adc     ecx,dword ptr [ebp+0Ch]\nadc!madd+0x3a [adc.cpp @ 10]:\n0029103a 134d14          adc     ecx,dword ptr [ebp+14h]\nadc!madd+0x4c [adc.cpp @ 11]:\n0029104c 134dfc          adc     ecx,dword ptr [ebp-4]\n0:000>\n\n```\n",
      "votes": "3",
      "user": "blabb",
      "time": "Aug 23, 2019 at 21:10",
      "is_accepted": false,
      "comments": []
    }
  ]
}