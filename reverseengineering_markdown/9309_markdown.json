{
  "title": "Mysterious bytecode (executable?) file from a chinese decibel meter whose manufacturer has been hacked &/or gone bankrupt",
  "link": "https://reverseengineering.stackexchange.com/questions/9309/mysterious-bytecode-executable-file-from-a-chinese-decibel-meter-whose-manufa",
  "content": "I bought a decibel meter off amazon recently (http://www.amazon.com/Sound-Measure-Tester-Pressure-Decibel/dp/B00CPKSE38/ref=sr_1_1?ie=UTF8&qid=1436376590&sr=8-1&keywords=wensn) which outputs db measurements to a microsd card. I opened the sd card's content on my computer and encountered four separate *.wsn files, two of which I created and the other two apparently made by the manufacturer in testing perhaps. Anyway, did a google search for the .wsn file extension and can't find anything but something called a \"whoopsie skin file\" which doesn't appear to be what I'm looking for. Can anyone help me find a way to parse this file? I imagine it simply contains a table of information with two columns (db level and time)\n\nHere's the link to a sample of the file. It is time series data for just a couple of seconds from the decibel meter.\nhttps://drive.google.com/file/d/0B0yWXI3LgLr4ME1DeUs4SDFMX1E/view?usp=sharing\n\nUpdate:\nThe db measurement device's manufacturer is \"wensn\", which clearly accounts for the file name extension. I've found two leads so far:\n\nbut both are for parsing usb streams of *.tmp files from the device, rather than the static wsn files. I'm guessing I could utilize this code to parse the wsn files, but I don't know how to do that yet. Honestly I'm in way over my head at this point.\n\nI first posted this question meta.stackexchange, you can find that discussion here. The expected output data is columnar, time and decibel level, as seems to be indicated here.\n\nUpdate 2:\nI think there may be a way to decode this file using the 'sigrok' utility, which is used to read all sorts of serial outputs from scientific sensors.\n\n",
  "votes": "5",
  "answers": 5,
  "views": "1k",
  "tags": [
    "executable",
    "byte-code"
  ],
  "user": "boulder_ruby",
  "time": "Mar 20, 2017 at 10:32",
  "comments": [
    {
      "user": "Carcigenicate",
      "text": "Out of curiosity, how do you know that it's been hacked?",
      "time": null
    },
    {
      "user": "boulder_ruby",
      "text": "I am not currently pursuing the amateur noise study project because the damned device cut off and the data was only for a few seconds, then all of a sudden the noise study was moot for other business reasons. I still have the equipment and may try to do a study again. I will mark the correct answer as the one that leads to me cracking the puzzle. Until then, this question appears to be helping a lot of people and that is good",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "This is a hex dump of your sample file:\n\n```\n00000000  1F DA 51 A0 19 5A 52 A0  19 DA 52 A0 28 5A 53 A0  ..Q..ZR...R.(ZS.\n00000010  28 DA 53 A0 24 5A 54 A0  1A DA 54 A0 2A 5A 55 A0  (.S.$ZT...T.*ZU.\n00000020  26 DA 55 A0 26 5A 56 A0  08 DA 56 A0 47 5A 57 A0  &.U.&ZV...V.GZW.\n00000030  35 DA 57 A0 32 5A 58 A0  3B DA 58 A0              5.W.2ZX.;.X.\n\n```\nAs you can see, the file clearly has a pattern where 4 bytes seem to repeat:\n- Byte one goes up and down, and might have to do with the sound level\n- Byte two alternates between DA and 5A - note DA is just a 5A with the highest bit set\n- Byte three seems to be slowly ascending, maybe a time indicator\n- Byte four is A0 and might be the high order byte of the time.\n\nHowever, without any information about the sound level that has been recorded, or some expected values from the raw bytes, every guess is quite hard to verify. It would be really helpful if you could use the software that comes with the device, open the file with it, and tell us whatever the software makes of that data.\n\nBtw, the german vendor Voelkner (they are reputable and i bought from them on several occasions) has a german/english PDF manual of the product, which refers to www.omnitronic.com for the newest version. That web site forwards to a shop that sold the product, doesn't have it in stock anymore, but still has a download page for manual and software. The product looks slightly different, but has the same overall layout and key positions, so there is reason to assume it's the same electronics in a slightly different plastic case, and the software might work for you and even be better than whatever came with your device - the amazon reviews says the software is in chinese and lacks a driver; the zip on \"my\" download page includes a \"Vista Driver\" folder and an installer that seems to support english.\n\n",
      "votes": "7",
      "user": "Guntram Blohm",
      "time": "Jul 8, 2015 at 21:47",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "This is the file in hex format (done with vi and :%!xxd; I added the column numbers  myself):\n\n```\n          0 1  2 3  4 5  6 7  8 9  a b  c d  e f\n0000000: 1fda 51a0 195a 52a0 19da 52a0 285a 53a0  ..Q..ZR...R.(ZS.\n0000010: 28da 53a0 245a 54a0 1ada 54a0 2a5a 55a0  (.S.$ZT...T.*ZU.\n0000020: 26da 55a0 265a 56a0 08da 56a0 475a 57a0  &.U.&ZV...V.GZW.\n0000030: 35da 57a0 325a 58a0 3bda 58a0 0a         5.W.2ZX.;.X..\n\n```\nAs you can see the bytes with odd indexes are all da, a0, 5a, a0, with a period of 8 bytes (half a line). This doesn't look like the data on the usb stream, so that link or the Python project are probably not going to help you much:\n\n\n\nFurthermore, there seems to be a counter in columns 2 and a: 51, 52, 53, ... The bytes in columns 6 and a are the same. The bytes in column e and 2 are also the same, but with 2 difference, showing us that this part is not very well aligned. A nicer alignment to further reverse engineer would be to shift column e to the leftmost position or so. \n\nYou could get a larger sample to see if da, a0 and 5a are constants or that they are part of the counter, or possibly something else. For example, it could also be that they are actually part of the measurement, but seem to be constant here because the sound level on the moment of measurement was constant.\n\nIn any case, it seems at this point that only columns 0, 4, 8 and c carry data. Once you have confirmed that hypothesis (by looking at more data), you could start generating sounds and see how the data you see relates to the sounds you generate.\n\nConsidering that the manufacturer uses its own name as an extension, it is unlikely this file has some common-used table format, so I can't give you more tips than this.\n\nA note about the hex editor. As said, I used vi with xxd (i.e. open the file in vi and then :%!xxd). However, there are plenty of hex editors, also for Windows. I don't know of any that allows you to shift the start column, which would be useful to check alignment.\n\n",
      "votes": "3",
      "user": null,
      "time": "Jul 8, 2015 at 21:51",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "Your file seems to go like:\n\n```\n51A0\n52A0\n52A0\n53A0\n53A0\n\n```\n_\n\n```\n52A0 = 20:02:36\n53A0 = 20:02:38 in dos time\n\n```\nIf its dos time it would make sense why every pattern(51A0, 52A0) is shown 2 times since dos time doesnt accept odd numbers as seconds. \n\nTheory 1:\n\nI dont think anything natural such as sound would go DA,5A,DA,5A,DA,5A,DA,5A,DA,5A.\n\nSo I assume that DA shows the lower part and 5A is the higher part. (DA=+0 and 5A=+1)\n\n```\n5A 52 A0 = 20:02:36\nDA 52 A0 = 20:02:37\n5A 53 A0 = 20:02:38\nDA 53 A0 = 20:02:39\n\n```\nI'm dont know alot about measuring sound but I can make assumptions based on the first byte too. But this maybe wrong since you didnt give  any information about the sound you captured.\n\n1st byte is Max: 0x47(71) Min: 0x8(8) on your file.\n\nOn the amazon page it says (30 ~ 130 Db)\n\n8 wouldnt fit those ranges so I assume the first byte is an offset.\n\n130-30=100 -> 0 > x > 100.\n\nEvery 4 byte has this information:\n\n```\nstruct Frame{\n  char SoundOffset;\n  char TimeOffset;\n  char DosTime[2];\n}\n\n```\nI wrote a sample code for your data.\n\n```\n#define _CRT_SECURE_NO_WARNINGS\n#include <Windows.h>\n#include <string>\n#include <iostream>  \n#include <fstream>\n#include <iostream>\n\nusing namespace std;\n\n\nstruct DosTime{\n    int hour, minute, second;\n    DosTime(char a1, char a2){\n        char y[2] = { a1, a2 };\n        INT16 * b = (INT16*)y;\n        second = 2 * (*b & 31);\n        minute = (*b & 2016) >> 5;\n        hour = (*b & 63488) >> 11;\n    }\n    DosTime(){\n        hour = 0;\n        minute = 0;\n        second = 0;\n    }\n};\nstruct Frame{\n    char SoundOffset;\n    char TimeOffset;\n    char DosTime[2];\n};\nstruct ConvertedFrame{\n    int soundDB;\n    DosTime time;\n    void print(){\n        cout << \"Sound Level: \" << soundDB << \" dB @ \";\n        cout.fill('0'); cout.width(2); cout << time.hour;\n        cout << \":\";\n        cout.fill('0'); cout.width(2); cout << time.minute;\n        cout << \":\";\n        cout.fill('0'); cout.width(2); cout << time.second;\n        cout << endl;\n    }\n};\nint main(int argc, char* argv[])\n{\n\n    int bytecount = 0;\n\n    ifstream inFile;\n    inFile.open(\"FG8U0235.wsn\", ios::in | ios::binary | ios::ate);\n    inFile.seekg(0, ios::end);\n    bytecount = inFile.tellg();\n    inFile.seekg(0, ios::beg);\n\n    char * buffer = new char[bytecount];\n    inFile.read(buffer, bytecount);\n\n    ConvertedFrame * frames = new ConvertedFrame[bytecount / 4];\n    for (int i = 0; i < bytecount; i += 4){\n        ConvertedFrame _con;\n        Frame f;\n        memcpy(&f, &buffer[i], 4);\n        DosTime _t = DosTime(f.DosTime[0], f.DosTime[1]);\n        if (f.TimeOffset == '\\xDA')\n            _t.second++;\n        _con.time = _t;\n        _con.soundDB = ((int)f.SoundOffset) + 30;\n        frames[i / 4] = _con;\n        _con.print();\n    }\n    system(\"pause\");\n    return 0;\n\n}\n\n```\nWhich outputs:\n\n```\nSound Level: 61 dB @ 20:02:35\nSound Level: 55 dB @ 20:02:36\nSound Level: 55 dB @ 20:02:37\nSound Level: 70 dB @ 20:02:36\nSound Level: 70 dB @ 20:02:39\nSound Level: 66 dB @ 20:02:40\nSound Level: 56 dB @ 20:02:41\nSound Level: 72 dB @ 20:02:42\nSound Level: 68 dB @ 20:02:43\nSound Level: 68 dB @ 20:02:44\nSound Level: 38 dB @ 20:02:45\nSound Level: 101 dB @ 20:02:46\nSound Level: 83 dB @ 20:02:47\nSound Level: 80 dB @ 20:02:48\nSound Level: 89 dB @ 20:02:49\n\n```\nTheory 2:\n\nOn the site you gave us (http://opensource.ebswift.com/RaspiMonitor/wensn/), there was this function (dB = (byte1 + ((byte2 & 3) * 256)) * 0.1 + 30) that made me think that maybe the 2nd byte is actually not the timeoffset but the 2nd byte for the dB.\n\nThis makes dB Float instead of Integer which would make much more sense. Also the output I got from the 2nd theory felt much better so I assume this is the correct answer.\n\n```\n#define _CRT_SECURE_NO_WARNINGS\n#include <Windows.h>\n#include <string>\n#include <fstream>\n#include <iostream>\n\nusing namespace std;\n\nstruct DosTime{\n    int hour, minute, second;\n    INT16 data;\n    DosTime(char a1, char a2){\n        char y[2] = { a1, a2 };\n        INT16 * b = (INT16*)y;\n        second = 2 * (*b & 31);\n        minute = (*b & 2016) >> 5;\n        hour = (*b & 63488) >> 11;\n        data = *b;\n    }\n    DosTime(){\n        hour = 0;\n        minute = 0;\n        second = 0;\n    }\n};\nstruct Frame{\n    char SoundOffset;\n    char precisionOffset;\n    char DosTime[2];\n};\nstruct ConvertedFrame{\n    float soundDB;\n    DosTime time;\n    void print(){\n        cout << \"Sound Level: \";\n        cout << soundDB;\n        if ((((int)soundDB) - soundDB) == 0) cout << \".0\";\n        cout << \" dB @ \";\n        cout.fill('0'); cout.width(2); cout << time.hour;\n        cout << \":\";\n        cout.fill('0'); cout.width(2); cout << time.minute;\n        cout << \":\";\n        cout.fill('0'); cout.width(2); cout << time.second;\n        cout << endl;\n    }\n};\nint main(int argc, char* argv[])\n{\n    int bytecount = 0;\n\n    ifstream inFile;\n    inFile.open(\"FG8U0235.wsn\", ios::in | ios::binary | ios::ate);\n    inFile.seekg(0, ios::end);\n    bytecount = inFile.tellg();\n    inFile.seekg(0, ios::beg);\n\n    char * buffer = new char[bytecount];\n    inFile.read(buffer, bytecount);\n\n\n    ConvertedFrame * frames = new ConvertedFrame[bytecount / 4];\n\n\n    INT16 lastTime = 0;\n    for (int i = 0; i < bytecount; i += 4){\n        ConvertedFrame _con;\n        Frame f;\n        memcpy(&f, &buffer[i], 4);\n        DosTime _t = DosTime(f.DosTime[0], f.DosTime[1]);\n        if (lastTime == _t.data) _t.second++;\n        lastTime = _t.data;\n        _con.time = _t;\n        _con.soundDB = (f.SoundOffset + ((f.precisionOffset & 3) * 256)) * 0.1 + 30;\n        frames[i / 4] = _con;\n        _con.print();\n    }\n    system(\"pause\");\n    return 0;\n\n}\n\n```\nOutput:\n\n```\nSound Level: 84.3 dB @ 20:02:34\nSound Level: 83.7 dB @ 20:02:36\nSound Level: 83.7 dB @ 20:02:37\nSound Level: 85.2 dB @ 20:02:38\nSound Level: 85.2 dB @ 20:02:39\nSound Level: 84.8 dB @ 20:02:40\nSound Level: 83.8 dB @ 20:02:41\nSound Level: 85.4 dB @ 20:02:42\nSound Level: 85.0 dB @ 20:02:43\nSound Level: 85.0 dB @ 20:02:44\nSound Level: 82.0 dB @ 20:02:45\nSound Level: 88.3 dB @ 20:02:46\nSound Level: 86.5 dB @ 20:02:47\nSound Level: 86.2 dB @ 20:02:48\nSound Level: 87.1 dB @ 20:02:49\n\n```\nNotes:\nTo find which one is the correct one you need to write dB into a paper or something and then compare with the output you get from both codes.\n\nAlso you need to do the cleanup of ConvertedFrame * frames and char * buffer if you use this code and want to prevent memory leaks. I wrote this code pretty fast @ 4 am just to test the theory.\n\n",
      "votes": "3",
      "user": "user2596732",
      "time": "Jul 16, 2015 at 8:04",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "I have buy a decibel meter Koolertron SL1361 from Amazon and it's produce files  *.wsn, but software don't work so I use this notes to understand.\nThe last theory 2 it's right, every sample data is 4 bytes long.\n\nAssuming that the 32 bit(four byte) is named bit31-0, here my decode:\n\nBit 31-24 & 17-16  Value in Db (10 bits), must be divide by 10 and after add 30 to obtain the correct value \nBit 22 filter mode 0=Fast 1=Slow\nBit 21 filter mode 0=A 1=C\nBit 12-8 & 23 = seconds \nBit 7-3  = hours\nbit 2-0 & 15-13 = minutes\n\nThey are coding in positive binary.\n\nEverything works.\n\n",
      "votes": "1",
      "user": "Giorgio Didone",
      "time": "Jan 25, 2017 at 17:54",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "Obvious and easy solution if you just can't get any documentation:\nDo you have any software that reads these files? Something that probably displays them in some useful, probably graphic format?\n\nIf so, reverse engineer the loading section of this program.\nString search in the program for \"wsn\" references to help zero in on where they are probably loaded..\n\n",
      "votes": "0",
      "user": "Sirmabus",
      "time": "Jul 9, 2015 at 15:39",
      "is_accepted": false,
      "comments": []
    }
  ]
}