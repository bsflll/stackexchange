{
  "title": "How could a CRC-15 CAN be transformed into 8 bytes in an embedded system?",
  "link": "https://reverseengineering.stackexchange.com/questions/33414/how-could-a-crc-15-can-be-transformed-into-8-bytes-in-an-embedded-system",
  "content": "I am analyzing calibration binary files of an embedded system (BMS) that likely uses a CRC-15 CAN checksum.\n\nFrom my firmware and bootloader file analysis, I have found a PECLookup table, which suggests that a CRC-15 CAN calculation is being performed somewhere. However, I do not see a direct 2-byte CRC-15 stored in the calibration binary file.\n\nInstead, the binary file ends with 8 extra bytes, which seem to be linked to a CRC checksum. I suspect these 8 bytes may be derived from the CRC-15 CAN in some way, but I haven't been able to determine the exact transformation.\n\nWhat I have observed so far:\n\nThe PECLookup table for CRC-15 CAN is present in the firmware and bootloader, so it is likely used in some form.\nI do not find a direct 2-byte CRC-15 in the file, but the last 8 bytes change systematically when I modify just 1 bit in the calibration file.\nThe 8 bytes doesn't seem to be a simple XOR with a fixed key.\nI tested various CRC-64 transformations on top of the CRC15, but none match the final 8 bytes.\nThe system processor is a TMS570 (ARM Cortex-R4, Big Endian).\nWhat I am looking for:\n\nIs there a known method in embedded systems where a CRC-15 CAN is expanded or transformed into a longer checksum (e.g., 8 bytes)?\nCould this be a linear transformation, a different CRC format, or another encoding method?\nHas anyone encountered a similar method in automotive/embedded checksum handling?\nAny insights into how such a transformation could work in an automotive or industrial embedded system would be greatly appreciated!\n\nAdditional observation In the BMS diagnostic software, a Config CRC (4 bytes) is displayed, which seems to be derived from the last 8 bytes of the calibration file. Specifically:\n\n```\nConfig_CRC[1] = byte[1] XOR byte[5]\nConfig_CRC[2] = byte[2] XOR byte[6]\nConfig_CRC[3] = byte[3] XOR byte[7]\nConfig_CRC[4] = byte[4] XOR byte[8]\n\n```\nI managed to locate the CRC15-CAN function and identified that this function is called twice within the bootloader file.\n\nHowever, I'm struggling to fully understand whatâ€™s happening. My C knowledge is quite basic, and since these functions call other functions, it makes the analysis more difficult.\n\nHere are the two functions that call the CRC15-CAN function:\n\n```\nint CRC_used1(undefined4 *param_1,uint param_2,uint param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 uVar4;\n  uint local_2c;\n  uint local_28;\n  undefined2 local_24;\n  uint auStack_22 [4];\n  \n  fun_called11(auStack_22,0,10);\n  local_2c = 0;\n  local_28 = 0;\n  iVar1 = fun_called12(param_3,(int)param_1,param_2,&local_2c,&local_28);\n  if (iVar1 == 0) {\n    uVar4 = fun_called13((int)auStack_22,local_2c & 0xffff,local_28 & 0xffff);\n    iVar2 = (int)uVar4;\n    iVar1 = iVar2;\n    if (iVar2 == 0) {\n      iVar1 = Calcul_CRC15((int)auStack_22,param_2 & 0xffff);\n      local_24 = (undefined2)iVar1;\n      iVar3 = fun_called14((int)&local_24,(int)auStack_22 + param_2,2);\n      iVar1 = DAT_000067d0;\n      if (iVar3 == 0) {\n        fun_called15(param_1,auStack_22,param_2);\n        iVar1 = iVar2;\n      }\n    }\n  }\n  return iVar1;\n}\n\n\nint CRC_used2(undefined4 *param_1,uint param_2,uint param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  uint local_2c [2];\n  undefined2 local_24;\n  uint auStack_22 [4];\n  \n  local_2c[0] = 0;\n  local_2c[1] = 0;\n  iVar1 = fun_called12(param_3,(int)param_1,param_2,local_2c,local_2c + 1);\n  if (iVar1 == 0) {\n    iVar1 = Calcul_CRC15((int)param_1,param_2 & 0xffff);\n    local_24 = (undefined2)iVar1;\n    fun_called11(auStack_22,0,10);\n    fun_called15(auStack_22,param_1,param_2);\n    fun_called15((undefined4 *)((int)auStack_22 + param_2),(undefined4 *)&local_24,2);\n    uVar2 = fun_called21((int)auStack_22,local_2c[0] & 0xffff,param_2 + 2 & 0xffff);\n    iVar1 = (int)uVar2;\n  }\n  return iVar1;\n}\n\n```\nDoes anyone have any insights on how I could progress further in understanding this?\n\nSince these functions are deeply nested and call many others, could this suggest that a more complex algorithm like Reed-Solomon or BCH code is being used internally? That might explain why so many layers of functions are involved.\n\nFor those interested, here's some information about the last 8 bytes of 2 different files with only one change bit :\nEvery calibration file has a size of 64 Ko and :\n\n```\nfile 1 :\n8 last bytes : 01 A4 2D 58 B8 C9 D4 28 \nConfig_CRC : B9 6D F9 70\n\nfile 2 :\n8 last bytes : CA A5 2A 2A 50 D1 23 FE\nConfig_CRC : 9A 74 09 D4\n\n```\n",
  "votes": "0",
  "answers": 0,
  "views": "35",
  "tags": [
    "assembly",
    "debugging",
    "ghidra",
    "crc",
    "checksum"
  ],
  "user": "Charles",
  "time": "Mar 24 at 8:25",
  "comments": [],
  "answers_data": []
}