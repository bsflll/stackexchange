{
  "title": "in / out instructions - how should I treat this?",
  "link": "https://reverseengineering.stackexchange.com/questions/5916/in-out-instructions-how-should-i-treat-this",
  "content": "I see a lot of in and out instruction in IDA. I know what those are supposed to do, but I do not know how to treat them and I'm making no advancements in understanding the code.\n\nShort example:\nFirst instructions of my current assignment are:\n\n```\nseg000:00000000                 mov     edx, 61666A1Fh\nseg000:00000005                 fincstp\nseg000:00000007                 fnstenv byte ptr [esp-0Ch]\nseg000:0000000B                 pop     esi             ; EIP\nseg000:0000000C                 sub     ecx, ecx\nseg000:0000000E                 mov     cl, 33h ; '3'\nseg000:00000010                 xor     [esi+12h], edx\nseg000:00000013                 add     edx, [esi+12h]  ; \nseg000:00000016                 xor     ecx, 0FFFFFF96h\nseg000:00000019                 test    [ecx+esi*8+957C08Fh], dl\nseg000:00000020                 push    eax             ; ??????\nseg000:00000021                 mov     bl, 0DEh ; 'Â¦'\nseg000:00000023                 in      al, dx\nseg000:00000024                 popa\nseg000:00000025                 loope   near ptr 0FFFFFFACh\n\n```\nI'm a bit lost at 05h-0Bh as it's the first time I encounter FPU instructions, but I think that ESI should point to the where EIP is pointing to. \n\nMy main question is regarding 23h.\n\n```\nin al, dx\n\n```\nShould load a in AL a byte from port 6A1Fh? Is this relevant in any way or is code like this supposed to make my work harder or hide something? Maybe it's encrypted and at some point some decrypting algorithm will kick in. Or maybe that shouldn't be viewed as code? \n\n",
  "votes": "3",
  "answers": 1,
  "views": "379",
  "tags": [
    "binary-analysis"
  ],
  "user": "user3002428",
  "time": "Jul 25, 2014 at 20:46",
  "comments": [
    {
      "user": "Jongware",
      "text": "Are you sure this is (32-bit) code? It seems a bit random to me -- as if disassembling data or 16-bit code. Can you add the actual opcode bytes in your listing, for verification?",
      "time": null
    },
    {
      "user": "Dmitry Janushkevich",
      "text": "Could you post the binary itself somewhere so we can have a look at it?",
      "time": null
    },
    {
      "user": "user3002428",
      "text": "This is what you are looking for? .686p .mmx .model flat seg000 segment byte public 'CODE' use32 Also, that's not CS it's EIP",
      "time": null
    },
    {
      "user": "Guntram Blohm",
      "text": "99% sure this isn't code. If your .686p .mmx .model flat seg000 segment byte public 'CODE' use32 was generated by IDA, then it's probable that ida wasn't initialized correctly when you started it - if you give an ARM object file to ida, and tell it it's 32 bit Intel code, it'll happily try to disassemble it as intel code, but generate nothing but garbage. This seems to be what has happened here. Posting the hex code, or the binary if it isn't too large, as others have suggested, might help someone recognize the format and provide further clues.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "This is self-modifying code.  The garbage instructions that you see will be altered dynamically, this way:\n\n```\nseg000:00000000                 mov     edx, 61666A1Fh\nseg000:00000005                 fincstp\nseg000:00000007                 fnstenv byte ptr [esp-0Ch]\nseg000:0000000B                 pop     esi             ; EIP\n\n```\nNow esi points to the location of the fincstp instruction (00000005).\n\n```\nseg000:0000000C                 sub     ecx, ecx\nseg000:0000000E                 mov     cl, 33h ; loop counter\nseg000:00000010                 xor     [esi+12h], edx\nseg000:00000013                 add     edx, [esi+12h]  ;sliding key\n\n```\nesi+12 (00000017) is being altered, turning this:\n\n```\nseg000:00000016                 xor     ecx, 0FFFFFF96h\nseg000:00000019                 test    [ecx+esi*8+957C08Fh], dl\n\n```\nin to this:\n\n```\nseg000:00000016                 sub     esi, 0FFFFFFFCh\nseg000:00000019                 loop    near ptr 00000010\n\n```\ni.e. esi = esi + 4, now it's 00000009 (and, then, 0x0000000d, 0x00000011, ...), and the loop continues via the value in ecx.\nIt's a shellcode-style decryptor.  More detailed descriptions of this technique can be found here and here.\n\n",
      "votes": "10",
      "user": "perror",
      "time": "Jul 22, 2014 at 21:24",
      "is_accepted": true,
      "comments": [
        {
          "user": "user3002428",
          "text": "I was thinking that EIP will point to 07h. Question: if esi+12 is 17h why is the modified code starting at 16h? I suppose that if I want to manually discover what XORing the instructions at 17h with 61666A1Fh does I should do the XORing myself and then see what are the new instructions. Those links are not working.",
          "time": null
        },
        {
          "user": "peter ferrie",
          "text": "The byte at 16h isn't being altered, it just happens to have the same opcode (0x83).  It's the parameters to it that are being altered.  I've fixed the links.",
          "time": null
        },
        {
          "user": "user3002428",
          "text": "Thanks :) Are there any tools that can make decrypting easier for me or the best way is to try to recreate the decryption loop in a C program (or python script) ?",
          "time": null
        },
        {
          "user": "Jason Geffner",
          "text": "Stepping through the code in a debugger will allow you to more easily decrypt it. If you can't load the given file directly into a debugger, you can copy the machine code and paste it into a file that can be loaded into a debugger, then set EIP to the beginning of the pasted code.",
          "time": null
        },
        {
          "user": "peter ferrie",
          "text": "as far as why EIP points to 05h and not 07h, it's because the FPU remembers the exact location of the FPU instruction, in case an exception occurs (for resuming execution if the problem can be fixed by the exception handler).",
          "time": null
        }
      ]
    }
  ]
}