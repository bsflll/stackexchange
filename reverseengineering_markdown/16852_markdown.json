{
  "title": "reverse checksum algorithm",
  "link": "https://reverseengineering.stackexchange.com/questions/16852/reverse-checksum-algorithm",
  "content": "I'm working on this pseudocode trying to find the correct input for the expected calculated value (i'm not sure if i can call it a checksum). I can't focus enough to generate the reverse algorithm, then any kind of help is appreciated.\n\nI may start with the value 2602618273338008543 in v20 and xor back on the random generated input but i think the end result would be too big to be xored to zero with a single byte.\n\nPS: I commented some lines that i suppose have no effect on the computation.\n\nA side question, why is the result checked against 2 values (loword(v20)==-922952045 && HIDWORD(v20) == -902699940 || v20 == 2602618273338008543i64) ? would the result be different when calculated in double words than with hiword/loword(dword)?\n\nThank you.\n\n```\n    v20 = 0i64;\n    // salt table\n    v28=\"a#+EJK45fe/efJWDSlesfGe03saHHFddfdq2gr%a3ß0jm2ÜcFEF!JKMÄrAfim+wqe=WD=?f3jDKefDJ§W?)JöSeAEFj_LIeJDF\"; // salt table\n    input = new byte[32] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n    for ( j = 0; j < 200; ++j )\n    {\n      v24 = (v20 + j) % 60 + 1; // 0x3c\n      v15 = input[7 * j % 15];\n      if ( v24 == 32 ) // 0x20\n        v15 = __PAIR__(v15, HIDWORD(v15));\n      if ( v24 == 31 ) // 0x1f\n      {\n        // v22 = v24 & 31; // 0x1f\n        // v11 = HIDWORD(v15);\n        // v8 = v15;\n        v1 = (unsigned __int64)(v15 << (v24 & 0x1F)) >> 32;\n        LODWORD(v15) = __PAIR__((unsigned int)v15, HIDWORD(v15)) << (v24 & 0x1F) >> 32;\n        HIDWORD(v15) = v1;\n      }\n      // v6 = v15;\n      v20 += v15;\n      v25 = (v20 ^ (unsigned __int64)j) % 62 + 2; // 0x3e + 2\n      v2 = (v20 - j) % 91;  // 0x5Bui64\n      LODWORD(v16) = *(int *)((char *)&v28 + v2);\n      HIDWORD(v16) = *(int *)((char *)&v29 + v2); // &v29=&v28-4\n      if ( v25 & 32 ) // 0x20\n        v16 = __PAIR__(v16, HIDWORD(v16));\n      if ( v25 & 31 ) // 0x1f\n      {\n        // v21 = v25 & 31; // 0x1f\n        // v9 = HIDWORD(v16);\n        // v10 = v16;\n        v3 = (unsigned __int64)(v16 << (v25 & 0x1F)) >> 32;\n        LODWORD(v16) = __PAIR__((unsigned int)v16, HIDWORD(v16)) << (v25 & 0x1F) >> 32;\n        HIDWORD(v16) = v3;\n      }\n      v7 = v16;\n      v20 ^= v16;\n    }\n    if ( (_DWORD)v20 == -922952045 && HIDWORD(v20) == -902699940 || v20 == 2602618273338008543i64 )\n      v23 = 1;\n  }\n\n```\nEdit:\n\nHere is a valid C++ code for the same algorithm.\n\n```\n#define LODWORD(_qw)    ((DWORD)(_qw))\n#define HIDWORD(_qw)    ((DWORD)(((_qw) >> 32) & 0xffffffff))\n\nuint64_t v22, v11, v6, v7, v9, v21, v20, v24, v15, v16, v25, v2, v3, vx = 0;\nconst char _v28[] = \"a#+EJK45fe/efJWDSlesfGe03saHHFddfdq2gr%a3ß0jm2ÜcFEF!JKMÄrAfim+wqe=WD=?f3jDKefDJ§W?)JöSeAEFj_LIeJDF\"; // salt table\nconst byte input[] = { 0x3B, 0x8F, 0x80, 0x01, 0x00, 0x00, 0x53, 0x54, 0x4F, 0x4C, 0x4C, 0x4D, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A };\n\nint j, v1, v8, v10;\n\nuint64_t QW_Swap(uint64_t v)\n{\n    uint64_t temp = v & 0xFFFFFFFF;  // extract the low\n    v >>= 32;  // shift right\n    v |= (temp << 32); // put the previous low in the high\n    return v;\n}\n\nvoid setLODWORD(uint64_t *_var, DWORD _v)\n{\n    *_var &= 0xFFFFFFFF00000000;\n    *_var |= (uint64_t)_v;\n}\n\nvoid setHIDWORD(uint64_t *_var, DWORD _v)\n{\n    *_var &= 0xFFFFFFFF;\n    *_var |= (uint64_t)_v << 32;\n}\n\nvoid atrCRC()\n{\n    v20 = 0;\n    v16 = 0;\n\n    byte * inp;\n    inp = (byte*)&input;\n    byte * v28;\n    v28 = (byte*)&_v28;\n\n    for (j = 0; j < 200; ++j)\n    {\n        v24 = (v20 + j) % 0x3C + 1; \n        v15 = *(uint64_t*)(inp+(7 * j % 15)); \n        if (v24 & 0x20)\n            v15 = QW_Swap(v15);\n        if (v24 & 0x1F)\n        {\n            v22 = v24 & 0x1F; \n            v11 = HIDWORD(v15);\n            v8 = v15; \n            v1 = (uint64_t)(v15 << (v24 & 0x1F)) >> 32; \n            setLODWORD(&v15, (QW_Swap(v15) << (v24 & 0x1F) >> 32));\n            setHIDWORD(&v15, v1);\n        }\n        v6 = v15;\n        v20 += v15;\n        v25 = (v20 ^ (uint64_t)j) % 0x3E + 2;\n        v2 = (v20 - j) % 0x5B;\n        setLODWORD(&v16, *(int *)((char *)(v28 + v2)));\n        setHIDWORD(&v16, *(int *)((char *)((v28 + v2) +4)));\n        if (v25 & 0x20)\n            v16 = QW_Swap(v16); \n        if (v25 & 0x1F)\n        {\n            v21 = v25 & 0x1F;\n            v9 = HIDWORD(v16); \n            v10 = v16;\n            v3 = (uint64_t)(v16 << (v25 & 0x1F)) >> 32;\n            setLODWORD(&v16, (QW_Swap(v16) << (v25 & 0x1F) >> 32));\n            setHIDWORD(&v16, v3);\n        }\n        v7 = v16;\n        v20 ^= v16;\n    }\n\n    /*\n    if (v20 == -922952045 && HIDWORD(v20) == -902699940 || v20 == 2602618273338008543i64)\n        v23 = 1;\n    */\n}\n\n```\nEDIT 2:\na bit simplified code\n\n```\n#define LODWORD(_qw)    ((DWORD)(_qw))\n#define HIDWORD(_qw)    ((DWORD)(((_qw) >> 32) & 0xffffffff))\n\nuint64_t v22, v20, v24, v15, v2, v3 = 0;\nconst char _v28[] = \"a#+EJK45fe/efJWDSlesfGe03saHHFddfdq2gr%a3ß0jm2ÜcFEF!JKMÄrAfim+wqe=WD=?f3jDKefDJ§W?)JöSeAEFj_LIeJDF\"; // salt table\nconst byte input[] = { 0x3B, 0x8F, 0x80, 0x01, 0x00, 0x00, 0x53, 0x54, 0x4F, 0x4C, 0x4C, 0x4D, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A };\n\nint j;\n\nuint64_t QW_Swap(uint64_t v)\n{\n    uint64_t temp = v & 0xFFFFFFFF;  // extract the low\n    v >>= 32;  // shift right\n    v |= (temp << 32); // put the previous low in the high\n    return v;\n}\n\nvoid setLODWORD(uint64_t *_var, DWORD _v)\n{\n    *_var &= 0xFFFFFFFF00000000;\n    *_var |= (uint64_t)_v;\n}\n\nvoid setHIDWORD(uint64_t *_var, DWORD _v)\n{\n    *_var &= 0xFFFFFFFF;\n    *_var |= (uint64_t)_v << 32;\n}\n\nvoid func(uint64_t x, uint64_t *var)\n{\n    byte v22;\n    int t;\n\n    if (x & 0x20)\n        *var = QW_Swap(*var);\n    if (x & 0x1F)\n    {\n        v22 = x & 0x1F;  \n        t = (uint64_t)(*var << v22) >> 32;\n        setLODWORD(var, (QW_Swap(*var) << v22 >> 32)); \n        setHIDWORD(var, t);\n    }\n}\n\nvoid atrCRC()\n{\n    v20 = 0;\n\n    byte * inp;\n    inp = (byte*)&input;\n    byte * v28;\n    v28 = (byte*)&_v28;\n\n    for (j = 0; j < 200; ++j)\n    {\n        v24 = (v20 + j) % 0x3C + 1; // v20 = ((v24-1)*0x3c)-j;\n        v15 = *(uint64_t*)(inp+(7 * j % 15)); // *(uint64_t*)(out[j*15%7]) = v15;\n\n        func(v24, &v15);\n\n        v20 += v15;\n        v24 = (v20 ^ (uint64_t)j) % 0x3E + 2;\n\n        v2 = (v20 - j) % 0x5B;\n        setLODWORD(&v15, *(int *)((char *)(v28 + v2)));\n        setHIDWORD(&v15, *(int *)((char *)((v28 + v2) +4))); \n\n        func(v24, &v15);\n\n        v20 ^= v15;\n    }\n}\n\n```\n",
  "votes": "2",
  "answers": 1,
  "views": "501",
  "tags": [
    "encryption"
  ],
  "user": "Kheireddine Saidi",
  "time": "Dec 2, 2017 at 19:43",
  "comments": [
    {
      "user": "w s",
      "text": "Did you try angr ( angr.io ) ? Symbolic execution is exactly built for such kind of things if these things are nnot cryptographically strong - and you can see here (vantagepoint.sg/blog/…) example for arm based license validation crackme.",
      "time": null
    },
    {
      "user": "Kheireddine Saidi",
      "text": "Thanks. No I didn't, and at first glance I doubt it would apply in my case, but i'll dig into it.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "I wouldn't call what you posted in your edit valid C++ code. It may compile, it may run, but although technically C code, it's the output of an automated decompiler and they tend to be a lot more complex and puzzling than genuine, human made code.\n\nWhen I'm handed a problem of creating the reverse algorithm of a part of a binary, I often follow these three steps:\n\nAnd in some more details:\n\nre-implement the algorithm itself as the first step. Doesn't really matter what language you use, as long as the code is clear and you have a good understanding of that language.\n\nThat way I get a deep understanding on how the algorithm works and have some intuition for it. Additionally, this makes it a lot easier to read and wrap my head around it. Doing it by yourself instead of relying on decompilers is a really good approach, especially when you haven't done that for a long time. My implementation will also come in handy later on when \n\nAfter I get the original algorithm right (this includes running my version and the original version on different inputs and matching the outputs), the second stage would probably be to look for any single piece that isn't invertible like cryptographic hash functions. If I find one of those and I can't find a way to circumvent the need for it, that's usually wraps that up.\n\nThird and final step would be to place the code side by side with an implementation that tries to invert the output back to the input, starting with only small slices of the entire algorithm. I would start by only inverting a small chunk of the algorithm, run a couple of different values through the end of my implementation of the original algorithm and build up on that as I go.\n\n",
      "votes": "1",
      "user": "NirIzr",
      "time": "Dec 2, 2017 at 8:35",
      "is_accepted": false,
      "comments": [
        {
          "user": "Kheireddine Saidi",
          "text": "thanks. yes what i meant by valid is that it's accepted by the compiler i just slightly modified the pseudocode. and yes i checked for different inputs while debugging and both programs gave same outputs on all stages of the algorithm. actually i doubt it could be reversed due to the  loss of bits while shifting (in func(uint64_t, *uint64_t)) I would appreciate you opinion, if it's the case what would be my options? bruteforcing a 32bytes array may take a while.",
          "time": null
        },
        {
          "user": "NirIzr",
          "text": "Actually, if you take a closer look I think you might be surprised... Although as I said it'll be clearer once you rewrite the code yourself.",
          "time": null
        },
        {
          "user": "Kheireddine Saidi",
          "text": "I'm trying, but what I see is (x << y) >> 32 (where x<32) is not reversible as it's a shift rather than a roll, correct me if i'm wrong. and v15 = *((uint64_t *)(v28 + v2)); is overwriten depending on the value of v2 which depends on v20 that depends on the previous value of v15. I maybe missing something",
          "time": null
        }
      ]
    }
  ]
}