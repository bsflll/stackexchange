{
  "title": "IDA Pro Debugging GDB SendDbgCommand",
  "link": "https://reverseengineering.stackexchange.com/questions/32247/ida-pro-debugging-gdb-senddbgcommand",
  "content": "I'm following this tutorial here https://www.triplefault.io/2017/07/loading-kernel-symbols-vmm-debugging.html to load kernel symbols with debugging.\n\nSetting up the debug environment with IDA Pro using gdb, works fine. But the python script that the author of the tutorial uses a command called SendDbgCommand to view gs registers and when attempting to run this script it fails with SendDbgCommand is not defined.\n\nI've tried defining the function like this:\n\n```\ndef SendDbgCommand(cmd):\n    \"\"\"Sends a command to the debugger and returns the output string.\n    An exception will be raised if the debugger is not running or the current debugger does not export\n    the 'SendDbgCommand' IDC command.\n    \"\"\"\n    s = Eval('SendDbgCommand(\"%s\");' % cmd)\n    if s.startswith(\"IDC_FAILURE\"):\n        raise Exception, \"Debugger command is available only when the debugger is active!\"\n    return s\n\n```\nThis throws the exception in the code, so I'm not really sure how to send a command to gdb using python is this feature removed? Any help is appreciated.\n\nSome information that might be useful:\n\n",
  "votes": "0",
  "answers": 1,
  "views": "144",
  "tags": [
    "ida",
    "debugging",
    "idapython",
    "python"
  ],
  "user": "Ballers",
  "time": "Sep 2, 2023 at 12:26",
  "comments": [],
  "answers_data": [
    {
      "content": "Here is updated code in case anyone ever runs across this issue in the future. The error was happening because idt_entry was missing the first for 0xFFFF some reason just appended the missing value and it works good now.\n\nCODE:\n\n```\nimport idaapi\nimport ida_dbg\nimport re\n\n# Constants for the IDT entry size and the number of entries\nIDT_ENTRY_SIZE = 16  # Each entry is 16 bytes\nNUM_IDT_ENTRIES = 256\n\n# Constants for interrupt types\nINTERRUPT_GATE = 0xE\nTRAP_GATE = 0xF\nPAGE_SIZE = 4096\n\n\ndef page_align(address):\n    '''\n        Aligns the 'address' on an architecture page boundary (0x1000).\n    ''' \n    return (address & ~(PAGE_SIZE - 1))\n\n\n\n\n    \ndef find_base_address(address, verbose = True):\n    '''\n        Walks memory backwards from the starting 'address' until a \n        valid PE header is located.\n    '''\n\n    # nt!_IMAGE_DOS_HEADER\n    '''\n        +0x000 e_magic          : Uint2B\n        +0x002 e_cblp           : Uint2B\n        +0x004 e_cp             : Uint2B\n        +0x006 e_crlc           : Uint2B\n        +0x008 e_cparhdr        : Uint2B\n        +0x00a e_minalloc       : Uint2B\n        +0x00c e_maxalloc       : Uint2B\n        +0x00e e_ss             : Uint2B\n        +0x010 e_sp             : Uint2B\n        +0x012 e_csum           : Uint2B\n        +0x014 e_ip             : Uint2B\n        +0x016 e_cs             : Uint2B\n        +0x018 e_lfarlc         : Uint2B\n        +0x01a e_ovno           : Uint2B\n        +0x01c e_res            : [4] Uint2B\n        +0x024 e_oemid          : Uint2B\n        +0x026 e_oeminfo        : Uint2B\n        +0x028 e_res2           : [10] Uint2B\n        +0x03c e_lfanew         : Int4B\n    '''\n    IMAGE_DOS_SIGNATURE = 0x5A4D # 'MZ'\n\n    # Relevant structure offsets.\n    OFFSET_IMAGE_DOS_HEADER_E_MAGIC = 0x0\n    OFFSET_IMAGE_DOS_HEADER_E_LFANEW = 0x3c\n    \n    # nt!_IMAGE_NT_HEADERS\n    '''\n       +0x000 Signature        : Uint4B\n       +0x004 FileHeader       : _IMAGE_FILE_HEADER\n       +0x018 OptionalHeader   : _IMAGE_OPTIONAL_HEADER64\n    '''\n    IMAGE_NT_SIGNATURE = 0x00004550 # 'PE00'\n    \n    # Relevant structure offsets.\n    OFFSET_IMAGE_NT_HEADERS_SIGNATURE = 0x0\n    \n    # Find the page aligned offset of the specified symbol's address by\n    # stripping off the page RVA.\n    DosHeader = page_align(address)\n    \n    if verbose:\n        print (\"  \nSearching for base address of symbol @ {} ({}).\".format(hex(address), hex(DosHeader)))\n        print (\"=\" * 100)\n    \n    while DosHeader != 0:\n        e_magic = read_dbg_word(DosHeader + OFFSET_IMAGE_DOS_HEADER_E_MAGIC)\n        \n        # If we can't read the page, it's most likely invalid (not \n        # mapped in). In the kernel most PE images (like ntoskrnl) \n        # are more or less guaranteed to have their PE header in \n        # the NonPagedPool. We skip invalid pages here.\n        if e_magic is not None:\n            if verbose:\n                print (\"{} --> {}\".format(hex(DosHeader), hex(e_magic)))\n                \n            # Do we have an 'MZ'?\n            if e_magic == IMAGE_DOS_SIGNATURE:\n                # Extract the e_lfanew.\n                e_lfanew = read_dbg_dword(DosHeader + OFFSET_IMAGE_DOS_HEADER_E_LFANEW)\n                \n                # Go to the (potential) IMAGE_NT_HEADERS at this location.\n                NtHeaders = DosHeader + e_lfanew\n            \n                # The IMAGE_NT_HEADERS should be on the same \n                # page as the IMAGE_DOS_HEADER. If this is not true, \n                # something's weird and we shouldn't read from this address.\n                if page_align(NtHeaders) == DosHeader:\n                    Signature = read_dbg_dword(NtHeaders + OFFSET_IMAGE_NT_HEADERS_SIGNATURE)\n                \n                    if verbose:\n                        print (\"\\t{} --> {}\".format(hex(NtHeaders), hex(Signature)))\n            \n                    # Do we have a 'PE00'?\n                    if Signature == IMAGE_NT_SIGNATURE:\n                        if verbose:\n                            print (\"\\t{} Base address located @ {}.\".format(\"^\" * 50, hex(DosHeader)))\n                        \n                        # At this point, it looks like we have both a valid \n                        # DOS and NT header. This should be the right base \n                        # address.\n                        return DosHeader        \n        \n        # Try another page.\n        DosHeader -= PAGE_SIZE\n    \n    # If we get to here... someone left this script running way too long.\n    return None\n\n\n\ndef read_idt_entry(address):\n    \"\"\"\n    Extracts the virtual address of the _KIDTENTRY64 at 'address'.\n    \"\"\"\n    \n    # nt!_KIDTENTRY64\n    '''\n    +0x000 OffsetLow        : Uint2B\n    +0x002 Selector         : Uint2B\n    +0x004 IstIndex         : Pos 0, 3 Bits\n    +0x004 Reserved0        : Pos 3, 5 Bits\n    +0x004 Type             : Pos 8, 5 Bits\n    +0x004 Dpl              : Pos 13, 2 Bits\n    +0x004 Present          : Pos 15, 1 Bit\n    +0x006 OffsetMiddle     : Uint2B\n    +0x008 OffsetHigh       : Uint4B\n    +0x00c Reserved1        : Uint4B\n    +0x000 Alignment        : Uint8B\n    '''\n    \n    # Relevant structure offsets.\n    OFFSET_KIDTENTRY64_OFFSETLOW = 0x0\n    OFFSET_KIDTENTRY64_OFFSETMIDDLE = 0x6\n    OFFSET_KIDTENTRY64_OFFSETHIGH = 0x8\n\n    # Read the data.\n    OffsetLow = read_dbg_word(address + OFFSET_KIDTENTRY64_OFFSETLOW)\n    OffsetMiddle = read_dbg_word(address + OFFSET_KIDTENTRY64_OFFSETMIDDLE)\n    OffsetHigh = read_dbg_word(address + OFFSET_KIDTENTRY64_OFFSETHIGH)\n    \n    # Failed to read some part of the offset.\n    if OffsetLow is None or OffsetMiddle is None or OffsetHigh is None:\n        return None\n    \n    # Build the 64-bit address representing this structure.\n    return (((OffsetHigh << 32) + (OffsetMiddle << 16) + OffsetLow) | 0xfffff00000000000)\n\ndef is_valid_idt_entry(entry):\n    \"\"\"\n    Check if the IDT entry represents an interrupt gate (0xE) or trap gate (0xF).\n    \"\"\"\n    gate_type = (entry[5] >> 8) & 0xF\n    return gate_type in (INTERRUPT_GATE, TRAP_GATE)\n\ndef extract_hex_number(idtr_str):\n    \"\"\"\n    Extract the hex number from the idtr_str.\n    \"\"\"\n    match = re.search(r'idtr base=([0-9a-fA-Fx]+)', idtr_str)\n    if match:\n        hex_value = match.group(1)\n        return hex_value\n    return None\n\ndef find_ntoskrnl_base():\n    \"\"\"\n    Find the base address of ntoskrnl.exe using the IDT.\n    \"\"\"\n    idt_base = None\n\n    # Get the IDT base address from GDB\n    idtr_result = send_dbg_command(\"r idtr\")\n    if idtr_result and isinstance(idtr_result, str) and len(idtr_result) > 0:\n        hex_base = extract_hex_number(idtr_result)\n        if hex_base:\n            idt_base = int(hex_base, 16)\n            print(\"idt base -> @ {}\".format(hex(idt_base)))\n\n    idt_entry = read_idt_entry(idt_base)\n\n    if idt_entry is None:\n        print(\"ERROR: Failed to extract KIDTENTRY64.\")\n        exit(-2)\n\n    print(\"KIDTENTRY64[0] @ {}\".format(hex(idt_entry)))\n\n    # Now, let's walk backward from KIDTENTRY64 to find ntoskrnl.exe base\n    real_base = find_base_address(idt_entry)\n\n    if real_base is not None:\n        print(\"FINALLY FOUND IT @ {}\".format(hex(real_base)))\n\n    return None\n\n# Main script\nntoskrnl_base = find_ntoskrnl_base()\n\nif ntoskrnl_base is not None:\n    print(f\"The base address of ntoskrnl.exe is: {ntoskrnl_base}\")\nelse:\n    print(\"Failed to find the base address of ntoskrnl.exe.\")\n\n```\n",
      "votes": "0",
      "user": "Ballers",
      "time": "Sep 2, 2023 at 15:55",
      "is_accepted": false,
      "comments": []
    }
  ]
}