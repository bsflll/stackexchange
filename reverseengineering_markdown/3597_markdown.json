{
  "title": "What is the meaning of this code generated by IDA Pro?",
  "link": "https://reverseengineering.stackexchange.com/questions/3597/what-is-the-meaning-of-this-code-generated-by-ida-pro",
  "content": "Test platform is Linux 32 bit.\n\nI use IDA Pro to disassembly the basename from coreutils 8.5\n compiled by gcc 4.6.3\n\nHere is a code snippet generated by IDA Pro\n\n```\n           call    _i686_get_pc_thunk_bx                                 \n           add     ebx, 292Eh\n           sub     esp, 18h\n           mov     eax, ds:(__dso_handle_ptr - 804DFF4h[ebx]\n           test    eax, eax\n           jz      short loc_804B6F8\n           mov     eax, [eax]\n\n     loc_804B6DB:\n           mov     [esp+1Ch+var_14], eax\n           mov     eax, [esp+1Ch+arg_0]\n           mov     dword [esp+1Ch+var_18], 0\n           mov     [esp+1Ch+var_1C], eax\n           call    __cxa_atexit\n           add     esp, 18h\n           pop     ebx\n           retn\n\n     loc_804B6F8:\n           xor     eax, eax\n           jmp     short loc_804B6DB\n\n```\nI don't understand this line:\n\n```\nmov     eax, ds:(__dso_handle_ptr - 804DFF4h[ebx]\n\n```\nand after searching the code, I can only find this:\n\n```\n        __dso_handle    dd 0\n\n```\nin the .data section.\n\nSo my questions are:\n\n",
  "votes": "3",
  "answers": 1,
  "views": "2k",
  "tags": [
    "ida",
    "disassembly",
    "assembly",
    "disassemblers",
    "nasm"
  ],
  "user": "lllllllllllll",
  "time": "Feb 7, 2014 at 21:12",
  "comments": [
    {
      "user": "0xC0000022L",
      "text": "You should really add more context!",
      "time": null
    },
    {
      "user": "PhoeniX",
      "text": "Can you please post at least the whole main of basename?",
      "time": null
    },
    {
      "user": "lllllllllllll",
      "text": "@ph0sec Thank you and I can modify the question later. But basically I modify my IDC scripts to directly generate nasm syntax asm, then this problem gone....",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "You are looking at binary that is compiled as position-independent code. The call    _i686_get_pc_thunk_bx and the following addition to ebx shows just that. If you take a look at the disassembly, you'll see that the address of the add ebx, 292Eh plus 0x292E will result in the first address of the GOT. That why in the next line, _dso_handle_ptr is addressed in such a \"funny\" way.\n\nIDA however is nice enough to show you this in the disassembly as you would normally only see 0xSOMEADDR[ebx]. \n\nIn terms of the second question: that line retrieves a global variable, puts it into eax and then checks if it is zero or not. So, you should not just \"delete\" that line since then the test eax, eax would use some old value of eax (which I am sure you will not like all that much).\n\n",
      "votes": "8",
      "user": "sqrtsben",
      "time": "Feb 6, 2014 at 23:13",
      "is_accepted": true,
      "comments": []
    }
  ]
}