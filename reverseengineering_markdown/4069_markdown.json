{
  "title": "IDA PRO Basics For Hex Rays How to fix address to struct which is dynamically calculated in if statement",
  "link": "https://reverseengineering.stackexchange.com/questions/4069/ida-pro-basics-for-hex-rays-how-to-fix-address-to-struct-which-is-dynamically-ca",
  "content": "I barely know any assembly and just started using IDA PRO a few months ago.\n\nI understand the code that Hex-Rays generates pretty well and I think I know why Hex-Ray's fails to create a struct of this math but I want to make hex-ray's generate better code for structures without using the hardcoded memory address in the lea instruction to avoid doing tons of manual work to get it to compile since it's over thousand of lines of C code. and why is screws up, but I don't know how to fix it so Hex-Ray's evaluates the hard-coded memory address into a struct.\n\nI couldn't use the T command on the assembly code which should offset that hardcoded memory address into the struct I created, since the hardcoded memory adress is computed with other another offset which is the struct maximum size.\n\nI made a bunch of images below to try to show off the multiple problems I'm experiencing. \n\nI know the problems are probably easy to solve but I lack the knowledge to figure it out not really any good resources for this either.\n\nHere is some Hex-Ray's code how it looks right now.\n\n```\nif ( *v320 && ChatCounter64Max > 0 )\n{\n  if ( !strcmp((364 * ChatCounter64Max + 0x431FC8), v320) && !strcmp((364 * ChatCounter64Max + 4398748), ChatText) )\n    return;\n  v320 = v377;\n}\nv321 = &ChatRelatedArray[ChatCounter64Max];\nv322 = &ChatRelatedArray[ChatCounter64Max];\nChatCounter64Max = ((ChatCounter64Max + 1) % -64);\n\n```\nAs you can see the ChatRelatedArray is the struct properly initializing a few lines below the if statement.\n\n\n\nHere is showing the structure location and how it looks like \n\n\n\nHere is how the bad locations look like, Those locations are not bad I just haven't figured out what they are used for they are probably some big array or struct. \n\n\n\nHere is how it looks like in assembly the problems\n\n\n\nHere is the assembly posted in Code not images.\n\n```\n.text:004186C7\n.text:004186C7 loc_4186C7:                             ; CODE XREF: ChatProcessor+3E6Bj\n.text:004186C7                 mov     al, [ebx]\n.text:004186C9                 mov     edx, ChatCounter64Max\n.text:004186CF                 test    al, al\n.text:004186D1                 jz      loc_418762\n.text:004186D7                 test    edx, edx\n.text:004186D9                 jle     loc_418762\n.text:004186DF                 lea     eax, [edx+edx*4]\n.text:004186E2                 mov     esi, ebx\n.text:004186E4                 lea     eax, [eax+eax*8]\n.text:004186E7                 lea     edi, [edx+eax*2]\n.text:004186EA                 shl     edi, 2\n.text:004186ED                 lea     eax, unk_431FC8[edi]\n.text:004186F3\n.text:004186F3 loc_4186F3:                             ; CODE XREF: ChatProcessor+3EC1j\n.text:004186F3                 mov     bl, [eax]\n.text:004186F5                 mov     cl, bl\n.text:004186F7                 cmp     bl, [esi]\n.text:004186F9                 jnz     short loc_418717\n.text:004186FB                 test    cl, cl\n.text:004186FD                 jz      short loc_418713\n.text:004186FF                 mov     bl, [eax+1]\n.text:00418702                 mov     cl, bl\n.text:00418704                 cmp     bl, [esi+1]\n.text:00418707                 jnz     short loc_418717\n.text:00418709                 add     eax, 2\n.text:0041870C                 add     esi, 2\n.text:0041870F                 test    cl, cl\n.text:00418711                 jnz     short loc_4186F3\n.text:00418713\n.text:00418713 loc_418713:                             ; CODE XREF: ChatProcessor+3EADj\n.text:00418713                 xor     eax, eax\n.text:00418715                 jmp     short loc_41871C\n.text:00418717 ; ---------------------------------------------------------------------------\n.text:00418717\n.text:00418717 loc_418717:                             ; CODE XREF: ChatProcessor+3EA9j\n.text:00418717                                         ; ChatProcessor+3EB7j\n.text:00418717                 sbb     eax, eax\n.text:00418719                 sbb     eax, 0FFFFFFFFh\n.text:0041871C\n.text:0041871C loc_41871C:                             ; CODE XREF: ChatProcessor+3EC5j\n.text:0041871C                 test    eax, eax\n.text:0041871E                 jnz     short loc_41875E\n.text:00418720                 mov     esi, [esp+16078h+ChatText]\n.text:00418727                 lea     eax, [edi+431E9Ch]\n.text:0041872D\n.text:0041872D loc_41872D:                             ; CODE XREF: ChatProcessor+3EFBj\n.text:0041872D                 mov     bl, [eax]\n.text:0041872F                 mov     cl, bl\n.text:00418731                 cmp     bl, [esi]\n.text:00418733                 jnz     short loc_418751\n.text:00418735                 test    cl, cl\n.text:00418737                 jz      short loc_41874D\n.text:00418739                 mov     bl, [eax+1]\n.text:0041873C                 mov     cl, bl\n.text:0041873E                 cmp     bl, [esi+1]\n.text:00418741                 jnz     short loc_418751\n.text:00418743                 add     eax, 2\n.text:00418746                 add     esi, 2\n.text:00418749                 test    cl, cl\n.text:0041874B                 jnz     short loc_41872D\n.text:0041874D\n.text:0041874D loc_41874D:                             ; CODE XREF: ChatProcessor+3EE7j\n.text:0041874D                 xor     eax, eax\n.text:0041874F                 jmp     short loc_418756\n.text:00418751 ; ---------------------------------------------------------------------------\n.text:00418751\n.text:00418751 loc_418751:                             ; CODE XREF: ChatProcessor+3EE3j\n.text:00418751                                         ; ChatProcessor+3EF1j\n.text:00418751                 sbb     eax, eax\n.text:00418753                 sbb     eax, 0FFFFFFFFh\n.text:00418756\n.text:00418756 loc_418756:                             ; CODE XREF: ChatProcessor+3EFFj\n.text:00418756                 test    eax, eax\n.text:00418758                 jz      loc_418EAD      ; jumptable 00418BB9 default case\n.text:0041875E\n.text:0041875E loc_41875E:                             ; CODE XREF: ChatProcessor+3ECEj\n.text:0041875E                 mov     ebx, [esp+16078h+var_16060]\n.text:00418762\n.text:00418762 loc_418762:                             ; CODE XREF: ChatProcessor+3E81j\n.text:00418762                                         ; ChatProcessor+3E89j\n.text:00418762                 lea     eax, [edx+edx*4]\n.text:00418765                 push    12Ch            ; Count\n.text:0041876A                 lea     ecx, [eax+eax*8]\n.text:0041876D                 lea     eax, [edx+ecx*2]\n.text:00418770                 mov     ecx, [esp+1607Ch+ChatText]\n.text:00418777                 push    ecx             ; Source\n.text:00418778                 lea     edi, ChatRelatedArray.PlayerName2[eax*4]\n.text:0041877F                 lea     eax, [edx+1]\n.text:00418782                 cdq\n.text:00418783                 xor     eax, edx\n.text:00418785                 push    edi             ; Dest\n.text:00418786                 sub     eax, edx\n.text:00418788                 and     eax, 3Fh\n.text:0041878B                 xor     eax, edx\n.text:0041878D                 sub     eax, edx\n.text:0041878F                 mov     ChatCounter64Max, eax\n.text:00418794                 call    _strncpy\n.text:00418799                 add     esp, 0Ch\n.text:0041879C                 lea     esi, [edi+12Ch]\n.text:004187A2                 push    20h             ; Count\n.text:004187A4                 push    ebx             ; Source\n.text:004187A5                 push    esi             ; Dest\n.text:004187A6                 mov     byte ptr [esi-1], 0\n.text:004187AA                 call    _strncpy\n.text:004187AF                 add     esp, 0Ch\n.text:004187B2                 add     edi, 14Ch\n.text:004187B8                 mov     byte ptr [esi+1Fh], 0\n.text:004187BC                 push    20h             ; Count\n.text:004187BE                 push    offset aEveryone ; \"(Everyone)\"\n.text:004187C3                 push    edi             ; Dest\n.text:004187C4                 call    _strncpy\n\n```\nThis is my other problem it doesn't seem to save even with evaluator / analyzer is off doesn't save to IDB database.\n\n\n\n",
  "votes": "3",
  "answers": 1,
  "views": "2k",
  "tags": [
    "ida",
    "assembly",
    "dynamic-analysis",
    "struct"
  ],
  "user": "SSpoke",
  "time": "Apr 15, 2014 at 1:40",
  "comments": [],
  "answers_data": [
    {
      "content": "Can you do this in a 2 pass methodology?\n\nFirst, generate whatever code HexRays is able to generate.\nSecondly, use your programming skill to write a program that will read the HexRays output file, recognise the fields you need calculated, do the calculation , replacing those fields, and then output the modified source.\n\nAutomation is your friend.\n\nOtherwise, hey, manually doing fixups is what I like about disassembly.  Learn to love it too.\n\n",
      "votes": "2",
      "user": "Paddywhacker",
      "time": "Apr 15, 2014 at 7:26",
      "is_accepted": false,
      "comments": [
        {
          "user": "SSpoke",
          "text": "Yes I want to find a automation script that creates structs for IDA PRO I know one should exist.. I found IDA Type REconstruction Plugin but it's only for C++ class structs my application  is written in C",
          "time": null
        },
        {
          "user": "SSpoke",
          "text": "Yes I love figuring out how the structs are made by looking at the memset lengths and new operator values. the reset is all guess work. Could you help me out from IDA... maybe my version is a bit old.. care to hook me up with a newer built? haha worth a shot.",
          "time": null
        },
        {
          "user": "Paddywhacker",
          "text": "IDA 6.1.0 is the one I see using the btdigg.org search engine.  I guess if you want the latest and greatest you will have to dig your hands deeply into your pockets.",
          "time": null
        },
        {
          "user": "Paddywhacker",
          "text": "You talk of a script.  I guess you could use a scripting language, but if I knew how to do it manually then I could write a C program, a filter, to input one text file and output the other.",
          "time": null
        },
        {
          "user": "Paddywhacker",
          "text": "Ouch.  Links from TPB are somewhat curated, the BTDIGG search results are totally wild.  Use with care.",
          "time": null
        }
      ]
    }
  ]
}