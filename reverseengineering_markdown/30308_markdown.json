{
  "title": "Decompilers points to non-existing virtual function",
  "link": "https://reverseengineering.stackexchange.com/questions/30308/decompilers-points-to-non-existing-virtual-function",
  "content": "As part of solving the Hidden password challenge, I found an condition calls a virtual function\n\n\n\nthe v14 points to v8 variable :\n\n\n\nand the functions in the program does not make sense for me, there is no two-args functions in binary program, does this bytes mean something such as signatures/evaluable code/etc..\n\n```\n  v8[0] = 0x28BF16683619A05BLL;\n  v8[1] = 0x4DD3CE3A2552E799LL;\n  v8[2] = 0xA5ED9BE182304449LL;\n  v8[3] = 0x6E27E1473B191037LL;\n  v8[4] = 0x6DA9EC4E7AC0DAECLL;\n  v8[5] = 0x8929723C31C59039LL;\n  v8[6] = 0xEA92AC15DE3C3F69LL;\n  v8[7] = 0x828DD2F713F6E8BELL;\n  v8[8] = 0xBB4D607B1C553C6FLL;\n  v8[9] = 0x7DC2D2F3EC43EF5BLL;\n  v8[10] = 0x4DAF64150084DC96LL;\n  v8[11] = 0xE1F1361E21C67AB9LL;\n  v8[12] = 0xA4B498C90BE95F82LL;\n  v8[13] = 0xB439B94451F266B5LL;\n  v8[14] = 0x2380C814A4F0145BLL;\n  v8[15] = 0x808581A5B7FB9D7ELL;\n  v8[16] = 0x589B2B23881C5633LL;\n  v8[17] = 0xBBAA188D8CDE35D8LL;\n  v8[18] = 0xF6F8FD3AEB6DD0D2LL;\n  v8[19] = 0x2FEAA6B6AE8530B8LL;\n  v8[20] = 0xB30EDC56B009E85FLL;\n  v8[21] = 0xFBD9E747FFC36C8FLL;\n  v8[22] = 0x18194F7045E8F66LL;\n  v8[23] = 0xC27B4D434FE8BEEALL;\n\n```\n```\ncode = [\n    0x28,0xBF,0x16,0x68,0x36,0x19,0xA0,0x5B,\n    0x4D,0xD3,0xCE,0x3A,0x25,0x52,0xE7,0x99,\n    0xA5,0xED,0x9B,0xE1,0x82,0x30,0x44,0x49,\n    0x6E,0x27,0xE1,0x47,0x3B,0x19,0x10,0x37,\n    0x6D,0xA9,0xEC,0x4E,0x7A,0xC0,0xDA,0xEC,\n    0x89,0x29,0x72,0x3C,0x31,0xC5,0x90,0x39,\n    0xEA,0x92,0xAC,0x15,0xDE,0x3C,0x3F,0x69,\n    0x82,0x8D,0xD2,0xF7,0x13,0xF6,0xE8,0xBE,\n    0xBB,0x4D,0x60,0x7B,0x1C,0x55,0x3C,0x6F,\n    0x7D,0xC2,0xD2,0xF3,0xEC,0x43,0xEF,0x5B,\n    0x4D,0xAF,0x64,0x15,0x00,0x84,0xDC,0x96,\n    0xE1,0xF1,0x36,0x1E,0x21,0xC6,0x7A,0xB9,\n    0xA4,0xB4,0x98,0xC9,0x0B,0xE9,0x5F,0x82,\n    0xB4,0x39,0xB9,0x44,0x51,0xF2,0x66,0xB5,\n    0x23,0x80,0xC8,0x14,0xA4,0xF0,0x14,0x5B,\n    0x80,0x85,0x81,0xA5,0xB7,0xFB,0x9D,0x7E,\n    0x58,0x9B,0x2B,0x23,0x88,0x1C,0x56,0x33,\n    0xBB,0xAA,0x18,0x8D,0x8C,0xDE,0x35,0xD8,\n    0xF6,0xF8,0xFD,0x3A,0xEB,0x6D,0xD0,0xD2,\n    0x2F,0xEA,0xA6,0xB6,0xAE,0x85,0x30,0xB8,\n    0xB3,0x0E,0xDC,0x56,0xB0,0x09,0xE8,0x5F,\n    0xFB,0xD9,0xE7,0x47,0xFF,0xC3,0x6C,0x8F,\n    0x18,0x19,0x4F,0x70,0x45,0xE8,0xF6,0x6,\n    0xC2,0x7B,0x4D,0x43,0x4F,0xE8,0xBE,0xEA,\n    0xcb,0x87,0xce,0xb3\n]\n\n```\nand the XOR part *((_BYTE *)v8 + (int)k) ^= v11; XOR with the key generated by other function\n\n```\nunsigned __int64 sub_1169()\n{\n  // qword_4040 -> 0x1\n  qword_4040 = 1103515245 * qword_4040 + 12345;\n  return ((unsigned __int64)qword_4040 >> 16) & 0x7FFF;\n}\n\n```\noutputs 0x41c6 and Xor'ing that key It won't give anything understandable and even useful\n\n```\ncode = [\n    0x28,0xBF,0x16,0x68,0x36,0x19,0xA0,0x5B,\n    0x4D,0xD3,0xCE,0x3A,0x25,0x52,0xE7,0x99,\n    0xA5,0xED,0x9B,0xE1,0x82,0x30,0x44,0x49,\n    0x6E,0x27,0xE1,0x47,0x3B,0x19,0x10,0x37,\n    0x6D,0xA9,0xEC,0x4E,0x7A,0xC0,0xDA,0xEC,\n    0x89,0x29,0x72,0x3C,0x31,0xC5,0x90,0x39,\n    0xEA,0x92,0xAC,0x15,0xDE,0x3C,0x3F,0x69,\n    0x82,0x8D,0xD2,0xF7,0x13,0xF6,0xE8,0xBE,\n    0xBB,0x4D,0x60,0x7B,0x1C,0x55,0x3C,0x6F,\n    0x7D,0xC2,0xD2,0xF3,0xEC,0x43,0xEF,0x5B,\n    0x4D,0xAF,0x64,0x15,0x00,0x84,0xDC,0x96,\n    0xE1,0xF1,0x36,0x1E,0x21,0xC6,0x7A,0xB9,\n    0xA4,0xB4,0x98,0xC9,0x0B,0xE9,0x5F,0x82,\n    0xB4,0x39,0xB9,0x44,0x51,0xF2,0x66,0xB5,\n    0x23,0x80,0xC8,0x14,0xA4,0xF0,0x14,0x5B,\n    0x80,0x85,0x81,0xA5,0xB7,0xFB,0x9D,0x7E,\n    0x58,0x9B,0x2B,0x23,0x88,0x1C,0x56,0x33,\n    0xBB,0xAA,0x18,0x8D,0x8C,0xDE,0x35,0xD8,\n    0xF6,0xF8,0xFD,0x3A,0xEB,0x6D,0xD0,0xD2,\n    0x2F,0xEA,0xA6,0xB6,0xAE,0x85,0x30,0xB8,\n    0xB3,0x0E,0xDC,0x56,0xB0,0x09,0xE8,0x5F,\n    0xFB,0xD9,0xE7,0x47,0xFF,0xC3,0x6C,0x8F,\n    0x18,0x19,0x4F,0x70,0x45,0xE8,0xF6,0x6,\n    0xC2,0x7B,0x4D,0x43,0x4F,0xE8,0xBE,0xEA,\n    0xcb,0x87,0xce,0xb3\n]\n\nkey = [0x41,0xc6]*98\n\ncode = \"\"\n\nfor i in range(196):\n    code+=chr(code[i]^key[i])\n\n```\nwhat is this line of code really does in this context :\n\n```\nif ( ((unsigned int (__fastcall *)(char *, size_t))v14)(a2[1], v5) )\n\n```\n",
  "votes": "0",
  "answers": 1,
  "views": "134",
  "tags": [
    "ida",
    "pointer",
    "vtables",
    "virtual-functions"
  ],
  "user": "IVs",
  "time": "Apr 22, 2022 at 20:49",
  "comments": [],
  "answers_data": [
    {
      "content": "sub_1169 is actually an LCG based random number generator. sub_1155 sets the seed value for this LCG. So sub_1155 is similar to srand and sub_1169 is rand\n\nBecause of this the xor key is not the same for every byte.\n\n```\nsrand(seed);\nfor ( k = 0; k <= 196; ++k )\n{\n  v9 = rand();\n  v8[k] ^= v9;\n}\n\n```\nNow\n\n```\nv14 = (int (__fastcall *)(char *, int))v8;\n\n```\nThis means we are assigning byte data pointed by v8 as function or code - specifically a function that takes a string and an int as a param and returns an int. Something like\n\n```\nbool verify_flag(char *flag, int len);\n\n```\nSo v8 is some sort of shellcode which is decoded in the xor fashion as above. Later that function is called to verify argv[1]\n\n```\nif ( v12(argv[1], v5) )\n  puts(\"Good password!\");\nelse\n  puts(\"Invalid password!\");\n\n```\nThe first step of getting the shellcode decoded correctly is to figure out the input that calculates some sort of \"checksum\" which when used as seed to srand will decode to perfect x86_64 code. This is the \"checksum\" logic.\n\n```\nseed = 0x7FFFFFFF;\nfor ( i = 0; ; ++i )\n{\n    v3 = i;\n    if ( v3 >= strlen(argv[1]) )\n    break;\n    seed += i * argv[1][i];\n}\n\n```\nAdditionally the binary sets up some mod based constraints that will help you figure out the correct checksum using z3.\n\n```\nfrom z3 import *\n# https://reverseengineering.stackexchange.com/questions/30303/z3-is-unable-to-predict-the-operand\nv7 = [123, 456, 789, 987, 654, 321]\nv6 = [92, 29, 380, 2, 497, 296]\narrl = 14\nargv1 = [BitVec(f'a{i}', 32) for i in range(arrl)]\n\nsolver = Solver()\nv18 = BitVecVal(0x7fffffff, 32)\n\nfor i in range(arrl):\n    solver.add(argv1[i] < 128)\n    solver.add(argv1[i] > 32)\n    v18 += i*argv1[i]\n\nfor i in range(6):\n    solver.add(URem(v18, v7[i]) == v6[i])\n\nprint(solver.check())\nprint(\"\".join(map(chr, [solver.model()[argv1[i]].as_long()\n      for i in range(arrl)])))\n\n```\nOnce you know an input that will produce the correct seed for srand such that rand generates the correct order of values for v8 shellcode to be decoded correctly.\n\nYou can then run and dump this decoded shellcode or xor it statically with correct rand values.\n\nThis shellcode similarly can be analysed with IDA and modelled with z3. Its a simple xor of 2 buffers and then compare with a static buffer.\nUnrelated to the answer, I have solved it with angr here\n\n",
      "votes": "0",
      "user": "sudhackar",
      "time": "Apr 22, 2022 at 23:27",
      "is_accepted": true,
      "comments": [
        {
          "user": "IVs",
          "text": "That's great, thank you, what was the seed number ?",
          "time": null
        }
      ]
    }
  ]
}