{
  "title": "Disassembling an MS-DOS EXE",
  "link": "https://reverseengineering.stackexchange.com/questions/14553/disassembling-an-ms-dos-exe",
  "content": "I've been disassembling an MS-DOS EXE and I've been using this link http://www.delorie.com/djgpp/doc/exe/ to make heads and tails of the binary.\n\nThe header seems to be an older version compared to the headers that precede the PE segment found in today's modern Windows executables.\n\nI've been using nasm's (Disassembler), but the program is not as complex as IDA Pro. Finding it hard to find main function entry point, especially with the disassembler engine working on an offset based logic to determine the decoding per instruction and due to the nature I'm also not familiar with the standard.\n\nI'm assuming the IP field in the MS-DOS could be the main function entry point of the executable and was hoping someone or somebody could confirm my speculations.\n\n",
  "votes": "3",
  "answers": 3,
  "views": "8k",
  "tags": [
    "disassembly",
    "x86",
    "executable",
    "dos-exe"
  ],
  "user": "Nocturnal",
  "time": "Feb 2, 2017 at 10:10",
  "comments": [],
  "answers_data": [
    {
      "content": "The entry point is calculated like this:\n\n```\n((header_paragraphs + cs) << 4) + ip\n\n```\nI wrote a MZ exe disassembler time ago, take a look.\n\n",
      "votes": "4",
      "user": "Nico01",
      "time": "Feb 2, 2017 at 12:27",
      "is_accepted": true,
      "comments": [
        {
          "user": "utahwithak",
          "text": "Why is it different in your code? github.com/Nico01/ded/blob/master/core.c#L267",
          "time": null
        },
        {
          "user": "Nico01",
          "text": "Because i didn't update the github repo with the new changes i made.",
          "time": null
        },
        {
          "user": "utahwithak",
          "text": "I figured as much. Doin a deep dive into this have used your tool; would love the latest. Cheers!",
          "time": null
        }
      ]
    },
    {
      "content": "I will explain here, in some detail, the formats for the old COM files, the MZ type of EXE files, and its later version, which served as a staging point for the NE, LE, LX and PE types of EXE files that were geared toward multi-tasking operating systems. There are actually two forms of MZ files. Your link, which I will expand on, only shows the earlier MZ format, not the later one.\n\nThe chief difference between the MZ and COM formats is that the former included an initial stack, initial entry point as you were asking about, and sufficient information to make the addressing more relative: the \"relocation table\", while the COM file was only relative to the extent supported by the 8086 segmented addressing model, having a fixed entry point within the segment the program was located on. There are missing links that show the gradual evolution from COM to old MZ format. I will say something about these, because of the strange things that can be done with the entry point to make COM and EXE more like each other.\n\nThe COM file is an actual program image, like binary, or BIN for short, or Intel HEX, Motorola SREC, which both use hexadecimal.\n\nThe COM format uses the segmented addressing model of the 80x86, which divides the address area into separate segments, that were originally meant to reflect the organization of source code into separate files or modules: effectively a two dimensional array of addresses, with an S axis for segments and an O axis for address offsets within a segment. In most of the older x86 CPU's it was linearized to a physical address: 10 S + O in hexadecimal (16 S + O in decimal). I will use hexadecimal consistently, here and below, sometimes prefixing them with \"0x\" for emphasis. The logical address (S,O) will be denoted S:O, with its flattened physical address being 10 S + O.\n\nThe difference between COM and BIN is that COM is assumed to be located at address 0100 (hexadecial) within whatever segment the operating system has provided for the program, when it is loaded, with address 0000-00ff reserved for the program segment prefix PSP, provided by the operating system. So, the entry point is 0000:0100.\n\nIn contrast, the older binary format mapped to fixed addresses if used with older microntrollers that don't support segmentation.\n\nThe old DOS EXE format, or \"MZ\" format is a direct descendant of COM that provides additional information on The Entry Point (CS:IP), The Stack Top (SS:SP), The Data Area (minimum and maximum extra paragraphs) and Relocations. The relocations are used to make segment addresses within the program relative so that they, too, can be mapped by the loader. If the loader maps a program starting at segment S0, then the actual logical addresses for the entry point and stack would, respectively, be relocated as (S0+CS):IP and (S0+SS):SP. Likewise, areas within the binary pointed to by the relocation table entries are tagged for relocation.\n\nThe old DOS MZ EXE files have the following format, which I've refined and expanded on from your link:\n\n```\n    At Size Description\n    00    2 The 2-byte signature of an EXE file.\n            00 1: 'M' (0x4d) for Microsoft.\n            01 1: 'Z' (0x5a) for Z/OS.\n            MZ = Mark Zbikowski\n    02    4 The program size 0x200*(Rem > 0? Quo - 1: Quo) + Rem\n            02 2: Rem The number of bytes in the last block.\n            04 2: Quo The number of blocks.\n    06    2 Number of relocation entries stored after the header. May be zero.\n    08    2 The header size, in 0x10-byte paragraphs.\n            The program's data begins just after the header and relocation entries (if any).\n            This field thus determines the appropriate file offset.\n            Note that some OS's and/or programs may fail if the header is not a multiple of 0x200 bytes.\n    0a    4 The data size range, in 0x10-byte paragraphs.\n            0a 2: The minimum required; i.e. BSS area = the area reserved for uninitialized static variables.\n            0c 2: The maximum required; i.e. the maximum required (normally set to ffff to hog up the entire OS's memory space).\n    0e    4 The relative stack location, SS:SP:\n            0e 2: SS, relative to the segment the program was loaded at.\n            10 2: SP\n    12    2 A 16-byte checksum (if used) ― should add up with the remaining 16-byte numerals in the file to yield 0.\n    14    4 The relative entry point, CS:IP:\n            14 2: IP\n            16 2: CS, relative to the segment the program was loaded at.\n    18    2 RB: The offset of the first relocation item, relative to the file's start.\n    1a    2 The overlay number; with 0, the normal value, meaning it's the main program.\n\n```\nFor this to make sense, the following constraints must hold\n\n```\n    0x1c ≤ RB ≤ RB + 4×Relocations ≤ Header Size ≤ Program Size ≤ File Size\n\n```\nThere's room for gaps between 0x1c and RB, between RB + 4×Relocations and the end of the header (identified by HeaderSize), between the end of the program image (identified by ProgramSize) and the rest of the file. The last gap, for instance, can be filled with debugger-related information, while the first gap is central in distinguishing between the earlier MZ and later MZ and its descendants: NE, LE, LX and PE.\n\nThe header thus locates and sizes itself, the relocation entries and the data & program image and the BSS & heap areas; and specifies the overlay number, the initial values of SS:SP and CS:IP (relative to the segment the program was loaded at); and validates it with a signature \"MZ\" and 8-bit checksum, which is normally set to 0 and not used. (The later EXE formats, like PE, use CRC checksums). The other 8086 segment registers, DS and ES, were set to CS upon loading the EXE file.\n\nWith the relocation table, the loader is now free to map it to any starting segment, S0. As already noted, the entry point, relocations and stack area are all relocation-relative: S0+⋯.\n\nFor clarity: the top of the program image ... the part that comes after the header ... is mapped as logical address 0000:0000, or (S0+0000):0000 after relocation, in contrast to COM files, where it is mapped to 0100 within whatever segment is current when the COM program is loaded.\n\nA later version of the MZ file included additional items after the header, as described here in PE extensions for MZ. The \"New Executable format\" was released as part of Windows 1.0 in 1985, and the multitasking MS-DOS 4.0 in 1986. It's used for the NE headers, and later also for the LE, LX and PE headers.\n\nIt took over the area from 1c-40 in the header and laid out the following format for it:\n\n```\n    At Size Description     \n    1c    8 Reserved \n    24    2 OEM identifier: typically zeroes\n    26    2 OEM info: typically, also, zeroes\n    28   20 Reserved \n    3c    4 SH: the starting address of the NE/LE/LX/PE header (if RB ≡ 0x40)\n\n```\nIn addition, the constraint RB = 40 (hex) holds. This time, the MZ header normally only points to a perfunctory stub program whose primary purpose is to say \"I don't run on DOS\". Thus, there are usually no relocation table entries. But, there's nothing that prevents one from adding in an old style DOS program. So, the later MZ format can be used to contain two programs: the one pointed to by the MZ header and the one, meant for multi-tasking operating systems, pointed to by the header located at SH. The start of that header will contain a signature, such as \"NE\", \"LE\", \"LX\" or \"PE\".\n\nThe SH-addressed header described in the Microsoft SDK article 65122 is for the \"NE\" format EXE files, while the Wikipedia reference Portable Executable (PE) discusses the \"PE\" format.\n\nThe earlier MZ-style EXE, like COM, also is also loaded on top of a PSP. The gap between COM and EXE can be bridged by making the entry point CS:IP = fff0:0100, which 16-bit math treats as -10:0100. Then fff0:0000 is the location of the PSP, while the logical address for the entry point (S0+fff0):0100, after relocation goes to the same physical address as does the logical address (S0+0000):0000 of the top of the program image. PKLite, discussed further below, did that.\n\nAn early example discussed here Wizardry 1981 is a COM file set up as a loader for an external binary file. In my reply, I laid out the parts of the programs contained in the two files, which provides enough detail to show it starting to do a \"jail-break\" out of the \"1 segment\" limit of COM files. The jail-break method, itself, was in regular use and looks like the beginnings of the evolution of EXE from COM.\n\nAnother early example of an EXE file, which is another missing link in the evolution, is the DEBUG.EXE program, itself, which has no relocations in the header but unpacks itself. It looks like it was developed at an early stage, when the transition from COM to EXE had just begun and may - itself - been a testing ground in which the earlier MZ format for EXE was developed. It uses simple run-length encoding compression and self-relocates.\n\nThis is its header\n\n```\n    0000: 4d 5a 9a 00 29 00 00 00 20 00 c5 00 ff ff a7 05\n    0010: 80 00 00 00 10 00 cf 04 1e 00 00 00 01 00 00 00\n          ⋯ [00's] ⋯\n    01f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n    0200: ⋯ Program Image ⋯\n\n```\nand how it parses\n\n```\n    00:     4d 5a           Signature: \"MZ\"\n    02:     9a 00 29 00     Program Size: 509a = 200 (29 - 1) + 9a\n    06:     00 00           Relocations: 00\n    08:     20 00           Header Size: 00200\n    0a:     c5 00 ff ff     Extra Data Range: 00c500 to ffff00 \n    0e:     a7 05 80 00     Stack Top: SS:SP = (S0+05a7):0080\n    12:     00 00           CheckSum: 0000: Unused\n    14:     10 00 cf 04     Entry Point: CS:IP = (S0+04cf):0010\n    18:     1e 00           Relocation Base (RB): 001e\n    1a:     00 00           Overlay: 0000, Main Program\n    1c:     01 00           (Gap) 0001\n    1e:                     Relocations (None)\n    1e:     ⋯               (Gap) 00's\n    200:    ⋯               Program Image\n\n```\nAs I read the actual program (after extraction), I can almost get a Spock or T'Mir style remote mind-meld or view of what's happening, and I see two people in a garage constantly vibing, but also bickering, with each other, having very animated interactions, trying to get things to work, with all sorts of contraptions, like disk controllers, monitors laying strewn about. Bill Gates is not the one doing the writing, but someone else who worked closely with him at the time.\n\nSome versions of PKLite will use the entry point CS:IP = fff0:0100, and have either a small relocation table or none at all, since they are both self-loading and self-relocating. An example of a program that was packed with PKLite is Vinyl Goddess From Mars.\n\nThis is its MZ header (in hexadecimal)\n\n```\n    00: 4d 5a b7 00 6e 00 01 00 0a 00 0b 14 ff ff ac 0d│MZ              │\n    10: 00 02 00 00 00 01 f0 ff 52 00 00 00 0e 21 50 4b│             !PK│\n    20: 4c 49 54 45 20 43 6f 70 72 2e 20 31 39 39 30 2d│LITE Copr. 1990-│\n    30: 39 32 20 50 4b 57 41 52 45 20 49 6e 63 2e 20 41│92 PKWARE Inc. A│\n    40: 6c 6c 20 52 69 67 68 74 73 20 52 65 73 65 72 76│ll Rights Reserv│\n    50: 65 64 07 00 00 00 84 01 c5 00 f3 05 a0 01 c1 0a│ed              │\n    60: ff ff b1 21 80 00 00 00 00 00 00 00 3e 00 00 00│                │\n    70: 01 00 fb 30 6a 72 00 00 00 00 00 00 00 00 00 00│                │\n    80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00│                │\n    90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00│                │\n\n```\nand what it parses to:\n\n```\n    00:     4d 5a           Signature: \"MZ\"\n    02,04:  b7 00 6e 00     Program Size: dab7 = 200*(6e - 1) + b7 = File Size\n    06:     01 00           Relocations: 0001\n    08:     0a 00           Header Size: 00a0\n    0a,0c:  0b 14 ff ff     Extra Data Range: 140b0 to ffff0\n    0e,10:  ac 0d 00 02     Stack Top: SS:SP = (S0+0dac):0200\n    12:     00 00           CheckSum: 0000, Unused\n    14,16:  00 01 f0 ff     Entry Point: CS:IP = fff0:0100\n    18:     52 00           Relocation Base: 0052\n    1a:     00 00           Overlay: 0000 = Main Program\n    1c:     ⋯               PKLite Info\n    52:     07 00 00 00     Relocation 0000:0007 - means add S0 to the word at (S0+0000):0007\n    56:     ⋯               PKLite Info\n    a0:     ⋯               Program Binary Image\n\n```\nThe program, itself, is self-loading, self-relocating, contains its own relocation table and unpacks to a size about 2 1/2 times larger.\n\nAn early example of an EXE program, which makes more normal use of the MZ format, is one of the EXE files for Jill Of The Jungle, by Epic Games.\n\nThis is part of header for the EXE file:\n\n```\n    00: 4d 5a 26 01 8c 01 3f 07 e0 01 00 00 ff ff 84 2f│MZ              │\n    10: e6 00 00 00 00 00 00 00 22 00 00 00 01 00 fb 20│                │\n    20: 72 6a 15 01 00 00 01 00 00 00 d6 00 00 00 db 00│rj              │\n\n```\nand what it parses into:\n\n```\n    00:     4d 5a           Signature: \"MZ\"\n    02,04:  26 01 8c 01     Program Size: 31726 = 200*(18c - 1) + 126 < File Size = 35850\n    06:     3f 07           Relocations: 073f\n    08:     e0 01           Header Size: 1e00\n    0a,0c:  00 00 ff ff     Extra Data Range: 00000 to ffff0\n    0e,10:  84 2f e6 00     Stack Top: SS:SP = (S0+2f84):00e6\n    12:     00 00           CheckSum: 0000, Unused\n    14,16:  00 00 00 00     Entry Point: CS:IP = (S0+0000):0000\n    18:     22 00           Relocation Base: 0022\n    1a:     00 00           Overlay: 0000 = Main Program\n    1c:     01 00 fb 20     (Gap)\n    20:     72 6a           (Gap: signature \"rj\")\n    22:     ⋯               Relocation Table (0000:0115, 0000:0001, 0000:00d6, 0000:00db, ⋯)\n    1d1e:   ⋯ 00's ⋯        (Gap)\n    1e00:   ⋯               Program Image\n    31726:  ⋯               (Debugger-Related Information)\n    35850:  End of file\n\n```\nHere: there is a gap between the end of program and end of file. It was mostly compiled with Turbo C and has a detailed manifest, for debugging, following the actual program. In particular, there's also enough information in it, and in the project files for the (now open-source) XARGON game, to show that both are using the same code base. I secretly decompiled it, which is why I'm able to do things like this Jill Of The Jungle: Secret Short-Cut. 3:55. and Jill Of The Jungle: The Hidden Secret. Jill Escapes The Game!, but haven't made it public-facing.\n\n",
      "votes": "1",
      "user": "Lydia Marie Williamson",
      "time": "Sep 1, 2024 at 5:20",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "The header IP of MSEXE file compiled by C/C++ point to the language runtime initial code that will call main function later. So if you wanna find out the main, you need trace it or read the crt code in clib or src file.\n\n",
      "votes": "0",
      "user": "0xC0000022L",
      "time": "Mar 8, 2017 at 8:50",
      "is_accepted": false,
      "comments": [
        {
          "user": "Nocturnal",
          "text": "If you noticed the tag for my post was DOS EXE and I didn't mention or bring up PE. DOS has 2 binary formats COM and MZ EXE, first being a completely flat file with no header and the later having a header for benefits of the executable surpassing the 64KiB executable size limit. Thus allowing for greater freedom in regards what the software can do, but with reliance on relocation feature that is handled by the loader. During the Load/Execute operation!",
          "time": null
        },
        {
          "user": "xxldao",
          "text": "Of couse I know you said is MSDOSEXE not a PE, the highlevel language have the same compiling pattern both EXE and PE.",
          "time": null
        }
      ]
    }
  ]
}