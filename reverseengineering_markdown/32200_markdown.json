{
  "title": "how to stop windbg when register value changes",
  "link": "https://reverseengineering.stackexchange.com/questions/32200/how-to-stop-windbg-when-register-value-changes",
  "content": "I'm using windbg to find the memory of a specific structure in windows. The way is to look at certain values stored in stack and registers in entry function. I notice that register ax holds that value when the program executes one instruction(So I have the address of that instruction). I assume that the value of ax is passed from the address of that structure and my job is to find the address of that instruction. The problem is that the assembly in IDA is very different from the assembly(use u command) in windbg. Thus, I'm unable to target the location from pseudocode in IDA and comparison between assembly in windbg and IDA.\n\n```\nassembly\n0000 function start(set break point)\n...\n...\nsome instructions without bp\n010f instruction A(where ax already holds the value. set break point)\n\n```\nOne very straight approach is to stop the machine when ax has the value I want. But there is no straight approach in windbg. Maybe like Thomas said there are other ways. So I try to use j and t command in windbg.\n\n```\nj(@ax=x) 'p';'r;r ax;r rip'\n\n```\nWith above command with bp, I can set conditional break point in certain address. But this infeasible since there are too many instructions and windbg has bp limits.\n\nIn documentation ,t command can execute many instructions and display values of registers. Since ax is not displayed in r command, I can track rax instead. How should I write my command in this form?\n\n```\nt [r] [= StartAddress] [Count] [\"Command\"] \n\n```\nThe StartAddress should be the entry function. But what about the count? I don't want to view thousands of output but it may not reach to instruction A if count is not big enough. How to solve this problem? Can I just use a big enough value and set bp at instruction A?\n\nUpdate:\nI managed to print all the instructions that have been executed since the entry function with ta command. But still too many instructions for me. I can only save the output to some files and find the location by string operation with C.\n\n",
  "votes": "0",
  "answers": 3,
  "views": "365",
  "tags": [
    "windows",
    "windbg"
  ],
  "user": "anonymous bear",
  "time": "Aug 25, 2023 at 6:55",
  "comments": [
    {
      "user": "Rolf Rolles",
      "text": "What you're asking for is not a capability of the x86 debug interface. Did you try looking at the code nearby to see where rax was assigned to?",
      "time": null
    },
    {
      "user": "anonymous bear",
      "text": "I did print instructions just excuted by t command but that's too many instructions. Although I know the rax's origin in nearby memory, the number of registers that I need to track is growing exponentially(if the instruction is mov then it's fine, the number won't change. But if it's add or and then I need to track one more registers). So I would like to have some commands to track them at least some locations that cause the value to change",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "or if you know the address and need to stop only when some artifact is equal to your target value you can use conditional breakpoints\n\nassuming you have the following code and want to break only when register ax contains 0x1337\n\n```\nint main (void)\n{\n    unsigned long a = 0;\n    unsigned char b =1;\n    while (a < 0xffffffff) {\n        a=a+b;\n    }\n    return a;\n}\n\n```\nstart debugger\n\n```\ncdb -c \"g loopy!main;uf .\" loopy.exe\n\n```\ndebugger stopped at main and disassembled the main function\n\n```\nMicrosoft (R) Windows Debugger Version 10.0.19041.685 AMD64\n\n0:000> cdb: Reading initial command 'g loopy!main;uf .'\nloopy!main:\n00000001`40001000 4883ec18        sub     rsp,18h\n00000001`40001004 c744240400000000 mov     dword ptr [rsp+4],0\n00000001`4000100c c6042401        mov     byte ptr [rsp],1\n\nloopy!main+0x10:\n00000001`40001010 837c2404ff      cmp     dword ptr [rsp+4],0FFFFFFFFh\n00000001`40001015 7312            jae     loopy!main+0x29 (00000001`40001029)\n\nloopy!main+0x17:\n00000001`40001017 0fb60424        movzx   eax,byte ptr [rsp]\n00000001`4000101b 8b4c2404        mov     ecx,dword ptr [rsp+4]\n00000001`4000101f 03c8            add     ecx,eax\n00000001`40001021 8bc1            mov     eax,ecx\n00000001`40001023 89442404        mov     dword ptr [rsp+4],eax  <<<< setting break here\n00000001`40001027 ebe7            jmp     loopy!main+0x10 (00000001`40001010)\n\nloopy!main+0x29:\n00000001`40001029 8b442404        mov     eax,dword ptr [rsp+4]\n00000001`4000102d 4883c418        add     rsp,18h\n00000001`40001031 c3              ret\n\n```\nsetting a conditional break to print only when register ax contains 0x1337\n\n```\n0:000> bp 00000001`40001023 \".if(@ax!=0x1337) {gc}.else {r @ax;dd @rsp+4 l1;gc}\"\n\n```\ncontinuing and result of conditional break point\n\n```\n0:000> g\n\nresult\n\nax=1337\n00000000`0014ff14  00001336\nax=1337\n00000000`0014ff14  00011336\nax=1337\n00000000`0014ff14  00021336\nax=1337\n00000000`0014ff14  00031336\n(408.2dcc): Control-C exception - code 40010005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\nKERNELBASE!CtrlRoutine+0x4c0f1:\n00007ffe`95fee971 0f1f440000      nop     dword ptr [rax+rax]\n0:001>\n\n```\n",
      "votes": "1",
      "user": "blabb",
      "time": "Aug 24, 2023 at 19:32",
      "is_accepted": true,
      "comments": [
        {
          "user": "anonymous bear",
          "text": "yeah, I found this quite handy if I know the address. But my situation is a little bit awkward. I know the range within the function but there are still several hundreds of instructions(with the method below). still too much work for me. Some debug tools do have break if certain registers change. Although this mechanism is relatively slow, it's quite useful in my case. Not sure why windbg doesn't implement this. The only method I think of is copy paste the whole output into a txt file and do some string operation with languages like c and python.",
          "time": null
        },
        {
          "user": "blabb",
          "text": ".logopen .logclose does the job of sending all the output to a text file",
          "time": null
        }
      ]
    },
    {
      "content": "disassembly at an arbitrary location\n\n```\n0:000> u .\nntdll!RtlpFlsAlloc+0x45:\ntrace from here \n00007ffe`988a4909 e8e2000000      call    ntdll!RTL_BINARY_ARRAY<RTLP_FLS_CALLBACK_ENTRY,8,4>::SlotAllocate (00007ffe`988a49f0)\n00007ffe`988a490e 8bd0            mov     edx,eax\n00007ffe`988a4910 83f8ff          cmp     eax,0FFFFFFFFh\n00007ffe`988a4913 0f8493da0400    je      ntdll!RtlpFlsAlloc+0x4dae8 (00007ffe`988f23ac)\n00007ffe`988a4919 8d7af0          lea     edi,[rdx-10h]\n00007ffe`988a491c 85ff            test    edi,edi\n00007ffe`988a491e 0f8492000000    je      ntdll!RtlpFlsAlloc+0xf2 (00007ffe`988a49b6)\nto here\n00007ffe`988a4924 81fff00f0000    cmp     edi,0FF0h\n\n```\nallow all 64 bit registers to be displayed\n\n```\n0:000> rm2\n0:000>\n\n```\nallow  register display after each instruction\n\n```\n0:000> .prompt_allow +reg\nAllow the following information to be displayed at the prompt:\n(Other settings can affect whether the information is actually displayed)\n   sym - Symbol for current instruction\n   dis - Disassembly of current instruction\n    ea - Effective address for current instruction\n   reg - Register state\n   src - Source info for current instruction\nDo not allow the following information to be displayed at the prompt:\n  None\n\n```\nTrace to address =. means from current address (rip)\nupto  00007ffe`988a4924\n\n```\n0:000> ta =. 00007ffe`988a4924\n\n\nrax=00000229c6dc8d50 rbx=0000000000000008 rcx=00007ffe9899d2f8\nrdx=0000000000000010 rsi=0000000000000001 rdi=0000000000000000\nrip=00007ffe988a49f0 rsp=00000061850eeaa8 rbp=00007ffe969ba840\n r8=0000000000000000  r9=0000000000000010 r10=0000000000000003\nr11=00000061850ee6b8 r12=00007ffe96987850 r13=ffffffffffffffff\nr14=00000061850eeb28 r15=00007ffe9899d2f0\niopl=0         nv up ei pl nz na po nc\nntdll!RTL_BINARY_ARRAY<RTLP_FLS_CALLBACK_ENTRY,8,4>::SlotAllocate:\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXcut off irrlevent traces XXXXXXXXXXXX \n\nntdll!RTL_BINARY_ARRAY<RTLP_FLS_CALLBACK_ENTRY,8,4>::SlotAllocate+0x64:\n00007ffe`988a4a54 c3              ret\nrax=0000000000000011 rbx=0000000000000008 rcx=0000000000000002\nrdx=0000000000000011 rsi=0000000000000001 rdi=0000000000000000\nrip=00007ffe988a490e rsp=00000061850eeab0 rbp=00007ffe969ba840\n r8=00000229c6dc8d40  r9=0000000000000010 r10=0000000000000003\nr11=00000061850ee6b8 r12=00007ffe96987850 r13=ffffffffffffffff\nr14=00000061850eeb28 r15=00007ffe9899d2f0\niopl=0         nv up ei pl nz na po nc\nntdll!RtlpFlsAlloc+0x4a:\n00007ffe`988a490e 8bd0            mov     edx,eax\nrax=0000000000000011 rbx=0000000000000008 rcx=0000000000000002\nrdx=0000000000000011 rsi=0000000000000001 rdi=0000000000000000\nrip=00007ffe988a4910 rsp=00000061850eeab0 rbp=00007ffe969ba840\n r8=00000229c6dc8d40  r9=0000000000000010 r10=0000000000000003\nr11=00000061850ee6b8 r12=00007ffe96987850 r13=ffffffffffffffff\nr14=00000061850eeb28 r15=00007ffe9899d2f0\niopl=0         nv up ei pl nz na po nc\nXXXXXXXXXXXXXXXXXXXXXXXXXXcut off irrlevent traces XXXXXXXXXXXX \nntdll!RtlpFlsAlloc+0x5a:\n00007ffe`988a491e 0f8492000000    je      ntdll!RtlpFlsAlloc+0xf2 (00007ffe`988a49b6) [br=0]\nrax=0000000000000011 rbx=0000000000000008 rcx=0000000000000002\nrdx=0000000000000011 rsi=0000000000000001 rdi=0000000000000001\nrip=00007ffe988a4924 rsp=00000061850eeab0 rbp=00007ffe969ba840\n r8=00000229c6dc8d40  r9=0000000000000010 r10=0000000000000003\nr11=00000061850ee6b8 r12=00007ffe96987850 r13=ffffffffffffffff\nr14=00000061850eeb28 r15=00007ffe9899d2f0\niopl=0         nv up ei pl nz na pe nc\ntraced till stop address\nntdll!RtlpFlsAlloc+0x60:\n00007ffe`988a4924 81fff00f0000    cmp     edi,0FF0h\n0:000>\n\n```\n",
      "votes": "1",
      "user": "blabb",
      "time": "Aug 24, 2023 at 18:47",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "well if you really need to trace each execution just looking for a value in some register and willing to spend the time you can run a script recursively on each instruction\n\nit is very time consuming and is equivalent to setting the trap flag on each instruction\n\nhere is how you do it\nusing the same example code in an earlier answer\n\n```\nint main (void)\n{\n    unsigned long a = 0;\n    unsigned char b =1;\n    while (a < 0xffffffff) {\n        a=a+b;\n    }\n    return a;\n}\n\n```\nwrite a script file loopy.wds with contents like this\n\n```\n.if (@eax == 0x1001) {} .else {t \"$<d:\\\\loopy.wds\"}\n\n```\nwhen reached the main function i save the current time\n\n```\n0:000> r $t1 = @$dbgtime\n0:000> ? @$t1\nEvaluate expression: 133374252215057636 = 01d9d72c`fd763ce4\n\n```\nand start single stepping using\n\n```\n0:000> t \"$<d:\\\\loopy.wds\"\n\n```\nit will keep on  tracing every instruction until the register eax holds 0x1001\n\n```\n0:000> .if (@eax == 0x1001) {} .else {t \"$<d:\\\\loopy.wds\"}\n0:000> .if (@eax == 0x1001) {} .else {t \"$<d:\\\\loopy.wds\"}\n0:000> .if (@eax == 0x1001) {} .else {t \"$<d:\\\\loopy.wds\"}\n0:000> .if (@eax == 0x1001) {} .else {t \"$<d:\\\\loopy.wds\"}\n0:000> .if (@eax == 0x1001) {} .else {t \"$<d:\\\\loopy.wds\"}\n0:000> .if (@eax == 0x1001) {} .else {t \"$<d:\\\\loopy.wds\"}\n0:000> .if (@eax == 0x1001) {} .else {t \"$<d:\\\\loopy.wds\"}\n\n```\nit will stop only when eax = 0x1001\n\n```\n0:000> .if (@eax == 0x1001) {} .else {t \"$<d:\\\\loopy.wds\"}\nloopy!main+0x27:\n00000001`40001027 ebe7            jmp     loopy!main+0x10 (00000001`40001010)\n0:000> ? @$t1\nEvaluate expression: 133374252215057636 = 01d9d72c`fd763ce4\n0:000> ? @$dbgtime\nEvaluate expression: 133374255572685217 = 01d9d72d`c59791a1\n0:000> ? @$dbgtime - @$t1\nEvaluate expression: 3563614608 = 00000000`d4687190\n0:000> r rax\nrax=0000000000001001\n0:000> dv\n              b = 0x01 ''\n              a = 0x1001\n0:000> .load kdexts\n\n0:000> 0: kd> !filetime 01d9d72c`fd763ce4\n0:000>  8/25/2023 13:50:21.505 (unknown)\n0:000> 0: kd> !filetime 01d9d72d`c59791a1\n0:000>  8/25/2023 13:55:57.268 (unknown)\n0:000> 0: kd> !filetime 00000000`d4687190\n0:000>  1/ 1/1601 05:35:56.361 (unknown)  <<<< \nit took about 5 minutes to trace until eax became 0x10001 from 0x0\n\n```\n",
      "votes": "1",
      "user": "blabb",
      "time": "Aug 25, 2023 at 9:03",
      "is_accepted": false,
      "comments": []
    }
  ]
}