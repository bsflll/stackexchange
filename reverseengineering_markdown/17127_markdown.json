{
  "title": "How to reverse engineer a Windows 10 UWP app?",
  "link": "https://reverseengineering.stackexchange.com/questions/17127/how-to-reverse-engineer-a-windows-10-uwp-app",
  "content": "I wanted to see what Microsoft are doing when you click \"Restart now\" button in their Settings -> Update window on Windows 10:\n\n\n\nSomehow the results are not the same what is available via InitiateSystemShutdownEx or InitiateShutdown WinAPIs, especially concerning installation of updates.\n\nSo I wanted to look into the code they use for that Restart button. Usually I would use Spy++ to look up a parent window's WndProc and then load the process in IDA Pro and put a breakpoint on it. Then trap a condition for the BM_CLICK message.\n\nIn this case though, the whole settings is a window of its own. The button does not appear in Spy++:\n\n\n\nAny ideas how do I proceed from there?\n\n",
  "votes": "35",
  "answers": 4,
  "views": "17k",
  "tags": [
    "ida",
    "debugging",
    "windows-10"
  ],
  "user": "c00000fd",
  "time": "Jan 5, 2018 at 22:54",
  "comments": [
    {
      "user": "dsasmblr",
      "text": "I'd love to see someone offer an approach to this. Maybe consider starting a bounty at this point to garner more interest from the heavy-hitters?",
      "time": null
    },
    {
      "user": "c00000fd",
      "text": "@dsasmblr: Here you go. Wiped out on the points. Hopefully someone can answer it.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "I have thought carefully before adding this as \"Another Answer\" rather than editing my existing answer that I posted above this morning.\n\nI feel that this answer deserves another post of its own as it's not just a simple continuation of the material posted in my answer above.\n\nI have spent over 2 hours on this post to avoid just cutting and pasting content from other sites.\nWhat I have focussed on rather, is on the point that I only include content in this post here, such that this answer  would still remain relevant even if the original websites (from where this content is taken from) would ever go down in the future.\n\nI am  trying to focus on the essentials that would enable us to hook and modify the code  in  UWP Apps, as asked by the OP.  \n\nDLL-Injection and Function-Hooking, work perfectly fine in UWP-Apps with most, if not all, injection and hooking techniques.\n\nA couple of main differences regarding Function Hooking and Dll Injection, between the UWP apps and the \"standard\" Win32 apps :\n\nFirst:\nThe Window, in which the UWP app renders its content, is not owned by the Apps\nexecutable.\nInstead “ApplicationFrameHost” does,and so you should not target the Window but rather the process itself.\nNote: Because of this, you cannot create new windows, like message boxes for example, when injected in a UWP-App.\n\nSecond:\nThe DLL you want to inject has to have “Read, Execute” as well as the “Read” permissions\nset for the “ALL APPLICATION PACKAGES”-Group.\nYou can set this via the properties tab of the DLL-file but the name may differ depending on\nyour system language.\n\nYou could also just use the following little code snippet  from\nStackOverflow (so don’t mind the “goto”s) to set the permissions programmatically.\n\nCode-Snippet\n\n```\nDWORD SetPermissions(std::wstring wstrFilePath) {\n    PACL pOldDACL = NULL, pNewDACL = NULL;\n    PSECURITY_DESCRIPTOR pSD = NULL;\n    EXPLICIT_ACCESS eaAccess;\n    SECURITY_INFORMATION siInfo = DACL_SECURITY_INFORMATION;\n    DWORD dwResult = ERROR_SUCCESS;\n    PSID pSID;\n    // Get a pointer to the existing DACL\n    dwResult = GetNamedSecurityInfo(wstrFilePath.c_str(), SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, & pOldDACL, NULL, & pSD);\n    if (dwResult != ERROR_SUCCESS)\n        goto Cleanup;\n    // Get the SID for ALL APPLICATION PACKAGES using its SID string\n    ConvertStringSidToSid(L\"S-1-15-2-1\", & pSID);\n    if (pSID == NULL)\n        goto Cleanup;\n    ZeroMemory( & eaAccess, sizeof(EXPLICIT_ACCESS));\n    eaAccess.grfAccessPermissions = GENERIC_READ | GENERIC_EXECUTE;\n    eaAccess.grfAccessMode = SET_ACCESS;\n    eaAccess.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;\n    eaAccess.Trustee.TrusteeForm = TRUSTEE_IS_SID;\n    eaAccess.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;\n    eaAccess.Trustee.ptstrName = (LPWSTR) pSID;\n    // Create a new ACL that merges the new ACE into the existing DACL\n    dwResult = SetEntriesInAcl(1, & eaAccess, pOldDACL, & pNewDACL);\n    if (ERROR_SUCCESS != dwResult)\n        goto Cleanup;\n    // Attach the new ACL as the object's DACL\n    dwResult = SetNamedSecurityInfo((LPWSTR) wstrFilePath.c_str(), SE_FILE_OBJECT, siInfo, NULL, NULL, pNewDACL, NULL);\n    if (ERROR_SUCCESS != dwResult)\n        goto Cleanup;\nCleanup:\n    if (pSD != NULL)\n        LocalFree((HLOCAL) pSD);\n    if (pNewDACL != NULL)\n        LocalFree((HLOCAL) pNewDACL);\n    return dwResult;\n}\n\n```\nAfterward, inject your DLL with your preferred injector/method, and your DLLs code will\nmagically function.\nSince UWP-Apps use the Win32 API under the hood, you can expect KernelBase.dll,\nKernel32.dll, ntdll.dll, and user32.dll to be loaded in them. You will also find d2d1.dll and\neither d3d11.dll or d3d12.dll (used in a handful of apps) loaded in all UWP apps, including\nthe new UWP calculator app.\n\nFor function hooking, as you might now expect, it works the same way it does for Win32 Programs.\n\nTaking control over the (hidden) “C:\\Program Files\\WindowsApps\\” directory :\nWithout taking control over the (hidden) “C:\\Program Files\\WindowsApps\\” directory, or\nwherever you might have it, you cannot access the files of UWP-Apps.\nBut you can just take\ncontrol of this, and any subdirectories and its files without any problems.  \n\nYou could also always just open up a shell as NT-Authority and access them that way.\nIf you just wanted to mod a simple config file or something you should be fine.\nHowever, some Apps, not all of them, check if their files were tampered with. But that’s\neasily circumvented.  \n\nAll you have to do is Hook the “CreateFileW“-Method in “KernelBase.dll“, monitor the file\naccess and then reroute those access requests to load your modified version from some\ndirectory you can access just fine.\n\nHere’s an example that does exactly what just described, using the previously mentioned MinHook library.  \n\nCode-Snippet :\n\n```\n#include <Windows.h>\n#include <atlbase.h>\n#include <Shlobj.h>\n#include <string>\n#include \"MinHook.h\"\n// Path to modified game files store in AppData\nstd::wstring MOD_FILES_PATH;\n// Path to the apps protected resources in WindowsApps\n// Don't use the full path name, just keep the Publisher.AppName part\nstd::wstring APP_LOCATION(L\"C:\\\\ProgramFiles\\\\WindowsApps\\\\Publisher.AppName\");\n// Sets a hook on the function at origAddress function and provides a trampoline to the original function\nBOOL setHook(LPVOID * origAddress, LPVOID * hookFunction, LPVOID * trampFunction);\n// Attaches a hook on a function given the name of the owning module and the name of the function\nBOOL attach(LPWSTR wstrModule, LPCSTR strFunction, LPVOID * hook, LPVOID * original);\n// Basic hook setup for CreateFileW\ntypedef HANDLE(WINAPI * PfnCreateFileW)(LPCWSTR lpFilename, DWORD dwAccess,\n    DWORD dwSharing, LPSECURITY_ATTRIBUTES saAttributes, DWORD dwCreation,\n    DWORD dwAttributes, HANDLE hTemplate);\nPfnCreateFileW pfnCreateFileW = NULL; // Will hold the trampoline to the original CreateFileW function\n// CreateFileW hook function\nHANDLE WINAPI HfnCreateFileW(LPCWSTR lpFilename, DWORD dwAccess, DWORD dwSharing, LPSECURITY_ATTRIBUTES saAttributes, DWORD dwCreation, DWORD dwAttributes, HANDLE hTemplate) {\n    std::wstring filePath(lpFilename);\n    // Check if the app is accessing protected resources\n    if (filePath.find(APP_LOCATION) != filePath.npos) {\n        std::wstring newPath(MOD_FILES_PATH);\n        // Windows provides the app the location of the WindowsApps directory, so the first half the file path will use back slashes\n        // After that, some apps will use back slashes while others use forward slashes so be aware of what the app uses\n        newPath += filePath.substr(filePath.find(L\"\\\\\", APP_LOCATION.size()) + 1,\n            filePath.size());\n        // Check if the file being accessed exists at the new path and reroute access to that file\n        // Don't reroute directories as bad things can happen such as directories being ghost locked\n        if (PathFileExists(newPath.c_str()) && !PathIsDirectory(newPath.c_str()))\n            return pfnCreateFileW(newPath.c_str(), dwAccess, dwSharing, saAttributes,\n                dwCreation, dwAttributes, hTemplate);\n    }\n    // Let the app load other files normally\n    return pfnCreateFileW(lpFilename, dwAccess, dwSharing, saAttributes,\n        dwCreation, dwAttributes, hTemplate);\n}\nBOOL Initialize() {\n    // Initialize MinHook\n    if (MH_Initialize() != MH_OK)\n        return FALSE;\n    // Get the path to the apps AppData folder\n    // When inside a UWP app, CSIDL_LOCAL_APPDATA returns the location of the apps AC folder in AppData\n    TCHAR szPath[MAX_PATH];\n    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, szPath))) {\n        // Get the path to the mod files folder\n        std::wstring appData(szPath);\n        appData = appData.substr(0, appData.rfind(L\"AC\")); // Get the base directory\n        appData += L\"LocalState\\\\ModFiles\\\\\"; // Get the location of any new files you want the app to use\n        MOD_FILES_PATH = appData;\n    } else\n        return FALSE;\n    // Attach a hook on CreateProcessW and return the status of the hook\n    BOOL hook = TRUE;\n    hook &= attach(L\"KernelBase.dll\", \"CreateFileW\", (LPVOID * ) & HfnCreateFileW,\n        (LPVOID * ) & pfnCreateFileW);\n    return hook;\n}\nBOOL Uninitialize() {\n    // Uninitialize MinHook\n    if (MH_Uninitialize() != MH_OK)\n        return FALSE; // This status will end up being ignored\n    return TRUE;\n}\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {\n    switch (ul_reason_for_call) {\n    case DLL_PROCESS_ATTACH:\n        return Initialize(); // If initialization failed, the DLL will detach\n        break;\n    case DLL_THREAD_ATTACH:\n        break;\n    case DLL_THREAD_DETACH:\n        break;\n    case DLL_PROCESS_DETACH:\n        Uninitialize(); // Return value doesn't matter when detaching\n        break;\n    }\n    return TRUE;\n}\nBOOL setHook(LPVOID * origAddress, LPVOID * hookFunction, LPVOID * trampFunction) {\n    if (MH_CreateHook(origAddress, hookFunction,\n            reinterpret_cast < LPVOID * > (trampFunction)) != MH_OK)\n        return FALSE;\n    if (MH_EnableHook(origAddress) != MH_OK)\n        return FALSE;\n    return TRUE;\n}\nBOOL attach(LPWSTR wstrModule, LPCSTR strFunction, LPVOID * hook, LPVOID * original) {\n    HMODULE hModule = GetModuleHandle(wstrModule);\n    if (hModule == NULL)\n        return FALSE;\n    FARPROC hFunction = GetProcAddress(hModule, strFunction);\n    if (hFunction == NULL)\n        return FALSE;\n    return setHook((LPVOID * ) hFunction, hook, original);\n}\n\n```\nA few more things:\nYou can’t just launch a UWP-App like a regular Win32 Program using CreateProcess.\nLuckily for us, M$ has provided us with the IApplicationActivationManager interface which\nlets developers launch UWP apps from regular Win32 programs.\n\nIf we want to do something to an App before it is launched, we can suspend it before that using the code below.\n\nCode Snippet :\n\n```\n// Gets the current application's UserModelId and PackageId from the registry\n// Substitute your own methods in place of these\nstd::wstring appName = GetApplicationUserModelId();\nstd::wstring appFullName = GetApplicationPackageId();\n\nHRESULT hResult = S_OK;\n\n// Create a new instance of IPackageDebugSettings\nATL::CComQIPtr debugSettings;\nhResult = debugSettings.CoCreateInstance(CLSID_PackageDebugSettings, NULL, CLSCTX_ALL);\nif(hResult != S_OK) return hResult;\n\n// Enable debugging\nhResult = debugSettings->EnableDebugging(appFullName.c_str(), NULL, NULL);\nif(hResult != S_OK) return hResult;\n\n// Launch the application using the function discussed above\nDWORD dwProcessId = 0;\nhResult = LaunchApplication(appName, &dwProcessId);\nif(hResult != S_OK) return hResult;\n\n/* Do more stuff after the app has been resumed */\n\n// Stop debugging the application so it can run as normal\nhResult = debugSettings->DisableDebugging(appFullName.c_str());\nif(hResult != S_OK) return hResult;\n\n```\nUsing the code above, your program will hang until the app is resumed as it is waiting on the app to reply back to the IApplicationActivationManager on its launch status. To resume the app, you can simply specify the path to your executable file when enabling debugging:\n\nCode Snippet:\n\n```\n// Enable Debugging with a custom debugger executable\nhResult = debugSettings->EnableDebugging(appFullName.c_str(), pathToExecutable.c_str(), NULL);\nif(hResult != S_OK) return hResult;\n\n```\nWindows will pass the process ID for the app process to the executable acting as the debugger using the command line argument -p followed by the process ID. From the debugger executable, you can do whatever you want to while the app is suspended such as injecting mods, and finally resume the app using NtResumeProcess.\n\n```\n#define IMPORT extern __declspec(dllimport)\n\nIMPORT int __argc;\nIMPORT char** __argv;\n//IMPORT wchar_t** __wargv;\n\n// Turning this into a normal Windows program so it's invisible when run\nint CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n    DWORD dwProcessId = 0;\n\n    // Process the arguments passed to the debugger\n    for (int i = 1; i < __argc; i += 2)\n    {\n        std::string arg(__argv[i]);\n        if (arg == \"-p\")\n            dwProcessId = atoi(__argv[i + 1]);\n    }\n\n    if(dwProcessId == 0)\n        return E_FAIL;\n\n    // Can do additional error checking to make sure the app is active and not tombstoned\n\n    ModLoader::InjectMods(dwProcessId);\n    ProcessUtils::ResumeProcess(dwProcessId); // Uses NtResumeProcess\n\n    return S_OK;\n}\n\n```\nImportant note: Call\n\n```\n// Initialize COM objects, only need to do this once per thread\nDWORD hresult = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\nif (!SUCCEEDED(hresult)) return hresult;\n\n```\nBefore you launch an App or do anything call this afterward:\n\n```\nCoUninitialize();\n\n```\nReferences:\n(1) Basic and Intermediate Techniques of UWP App Modding\n(2) Hacking and Modding Windows Universal Apps\n\nI sincerely hope that these two answers of mine would be helpful to anyone searching SE in future on the topics of UWP App hooking/modification.\n\n",
      "votes": "32",
      "user": "Paul",
      "time": "May 9, 2020 at 0:09",
      "is_accepted": true,
      "comments": [
        {
          "user": "barnaby-b",
          "text": "Great answer! I'll make sure to review the code examples and references - kudos.",
          "time": null
        },
        {
          "user": "c00000fd",
          "text": "Yes, thank you. This answer is closer to answering my original question. (Your other answer is about global hooks. Unfortunately in this case you won't be able to do much with them. I can as well find a click on the UWP app's window, i.e Windows.UI.Core.CoreWindow by trapping a mouse click event in its WndProc with IDA. Unfortunately, it's not easy to proceed further on from that point. Or how to get to this class that can help route the call further from a button click.)",
          "time": null
        },
        {
          "user": "c00000fd",
          "text": "I'll mark it as the answer so that you can receive the bounty for your work. I just want to point out that there's more to it left to be done. Can you contact me via email? I'll post an update here when I get it resolved.",
          "time": null
        },
        {
          "user": "TechLord",
          "text": "Thank you c00000fd ! Had been working overtime a lot these few days (working even this weekend) and hence did not have time to work on the actual \"Restart\" button in the Windows Update that you were mentioning. Hopefully in the next few days I will be able to create a solution for that exact \"Restart\" button issue and update it here. Will also email you as requested.  @barnaby-b - Thank you for the compliment!",
          "time": null
        },
        {
          "user": "dsasmblr",
          "text": "Awesome job, TechLord, and great feedback and attitude towards this whole thing, c00000fd! I hope to see you follow through with that Restart button solution, TechLord. Also, would quite enjoy an update from you as well once you get things pinned down, c00000fd. Thanks, both of you!",
          "time": null
        }
      ]
    },
    {
      "content": "As promised, I am back to post a more specific answer to the question that was asked by the OP.  \n\nDecided to write this as a separate answer as I believe that this content stands out on its own and would not properly fit in with either of the two answers that I posted above.\n\nAddressing his first issue :\n\nWell, the button does appear when using tools other than Spy++.\nI am pasting  screenshots of 2 tools with the help of which the properties of the RESTART button can be discovered.\n\nUsing the INSPECT TOOL that is a part of the Microsoft SDK :\n\n \n\nand also using the UI Spy Tool (Please note that many other tools can also be used) for this purpose ...\n\n\n\nNow we will see what code we BREAK ON when we click the RESTART button :\n\nFirstly, Run the System Settings Manager (SystemSettings.exe would be seen in the Task Manager).\n\"Attach\" to the SystemSettings.exe process with a debugger (I used the [excellent] x64dbg Debugger for this purpose).\nMake sure that you tick the Break on DLL Load in the Debugger Settings as shown below :\n\n \n\nNow we *click on the RESTART NOW button* (of the Windows Settings Window). We will break in the debugger as the \"SettingsHandlers_nt.dll\" gets loaded into the process.    \n\nThis is the main dll that handles the events (clicks etc) of the Settings Window. \n\n \n\n \n\nThis is a part of the Control Flow Graph that actually takes the  decision to \ngo for a restart :\n\n \n\nThe OP is right .\nThe actual Decision-Making Part for the  [Automatic] Restarts after Microsoft Updates is  handled by the MusUpdateHandlers.dll as can be seen below: \n\n\n\nand also here :\n\n\n\nI have added the last 2 screenshots as the OP had wanted to know what API are invoked when the system restarts after an UPDATE...\n\nI hope that this now concludes the answer to what @c00000fd wanted to know...\n\n",
      "votes": "22",
      "user": "TechLord",
      "time": "Feb 6, 2018 at 14:34",
      "is_accepted": false,
      "comments": [
        {
          "user": "Shayan",
          "text": "Hello TechLord, can you help with my question: reverseengineering.stackexchange.com/questions/23454/… Thanks very much :)",
          "time": null
        }
      ]
    },
    {
      "content": "I would suggest using the EventHook Library which is intended to hook global windows user events.This is available as a Nuget Package.\n\nThe Project Repo (named as Windows User Action Hook)  is available on Github and my fork can be accessed here. This is for the same Library (EventHook Library) that I mentioned above. You can visit the Github repo  if you want to get hold of the source code.\n\nFrom the Github Project's README page, just let me excerpt a few details :\n\nSupported Events : (These are the events that you can hook globally)\n\nUsage - Install by nuget \n\nSAMPLE CODE: \n\n```\nKeyboardWatcher.Start();  \nKeyboardWatcher.OnKeyInput += (s, e) =>  \n{  \n    Console.WriteLine(string.Format(\"Key {0} event of key {1}\", e.KeyData.EventType, e.KeyData.Keyname));  \n};  \n\nMouseWatcher.Start();  \nMouseWatcher.OnMouseInput += (s, e) =>  \n{  \n    Console.WriteLine(string.Format(\"Mouse event {0} at point {1},{2}\", e.Message.ToString(), e.Point.x, e.Point.y));    \n};  \n\nClipboardWatcher.Start();  \nClipboardWatcher.OnClipboardModified += (s, e) =>  \n{  \n    Console.WriteLine(string.Format(\"Clipboard updated with data '{0}' of format {1}\", e.Data, e.DataFormat.ToString()));  \n};  \n\nApplicationWatcher.Start();  \nApplicationWatcher.OnApplicationWindowChange += (s, e) =>  \n{  \n    Console.WriteLine(string.Format(\"Application window of '{0}' with the title '{1}' was {2}\", e.ApplicationData.AppName, e.ApplicationData.AppTitle, e.Event));    \n};  \n\nPrintWatcher.Start();  \nPrintWatcher.OnPrintEvent += (s, e) =>  \n{  \n    Console.WriteLine(string.Format(\"Printer '{0}' currently printing {1} pages.\", e.EventData.PrinterName, e.EventData.Pages));    \n};  \n\nConsole.Read();  \nKeyboardWatcher.Stop();  \nMouseWatcher.Stop();  \nClipboardWatcher.Stop();  \n\nApplicationWatcher.Stop();  \nPrintWatcher.Stop();  \n\n```\nSample Output (Screenshot) :\n\n\n\nI am sure that once you can see how we are able to globally hook various Windows User Events.\nIn your case, using this library, we'd be able to code a tiny C# program for example, which would hook the mouse-press event for the \"Restart Now\" button and thus allow us to take control of the subsequent events. \n\nSince this question was about hooking UWP Apps, I would like to give an example where this library was used to specifically hook UWP apps so that the code from that repo can be used as an example if required. \nPlease note that I am not excerpting anything directly from that repo as I only wanted to show that this library works very well with UWP Apps as well.  You can visit my fork of the Github Repo UWPHook here.\n\n",
      "votes": "9",
      "user": "TechLord",
      "time": "Jan 14, 2018 at 19:38",
      "is_accepted": false,
      "comments": []
    },
    {
      "content": "I searched in the System32 folder inside every file named SystemSettting*.* for the word Shutdown. I used Total Commander as it can search with multiple encodings such as ASCII and Unicode:\n\n\nThen builtin viewer showed a reference to InitiateSystemShutdownExW:\n.\n\nFrom MSDN:\n\n```\nBOOL WINAPI InitiateSystemShutdownEx(\n  _In_opt_ LPTSTR lpMachineName,\n  _In_opt_ LPTSTR lpMessage,\n  _In_     DWORD  dwTimeout,\n  _In_     BOOL   bForceAppsClosed,\n  _In_     BOOL   bRebootAfterShutdown,\n  _In_     DWORD  dwReason\n);\n\n```\nTo verify, a next step would be to set a breakpoint on this API using a tool like Ida Pro or API Monitor. \n\n",
      "votes": "5",
      "user": "Remko",
      "time": "Jan 9, 2018 at 18:50",
      "is_accepted": false,
      "comments": [
        {
          "user": "c00000fd",
          "text": "I'm not sure if SystemSettingsThresholdAdminFlowUI.dll is even mapped into C:\\Windows\\ImmersiveControlPanel\\SystemSettings.exe process at the time.",
          "time": null
        },
        {
          "user": "Remko",
          "text": "You can check that with e.g. Process Explorer but you could be right that it's calling this api in another way.",
          "time": null
        },
        {
          "user": "mrexodia",
          "text": "Do debug a UWP app you will have to use PLMDebug, you can use windbg or x64dbg for that.",
          "time": null
        },
        {
          "user": "c00000fd",
          "text": "@mrexodia: Well, yeah, obviously you need to use PLMDebug to turn off Process Lifetime Management on UWP app. In other words, so that it doesn't get suspended by the broker when it's in the background. But you don't debug with it, per se. It's not a debugger.",
          "time": null
        }
      ]
    }
  ]
}