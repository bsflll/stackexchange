{
  "title": "Debugging Win32.Upatre - why does Ollydbg fail to analyze this?",
  "link": "https://reverseengineering.stackexchange.com/questions/9182/debugging-win32-upatre-why-does-ollydbg-fail-to-analyze-this",
  "content": "So I've been looking at this thread - Where can I, as an individual, get malware samples to analyze?\nAnd grabbed myself a binary sample of Win32.Upatre from Halvar Flake's blog.\n\nI started analyzing the file in my VM (Win XP SP 3) and loaded up the malware in Olly.\nWhat I noticed is that the code looks encrypted - I searched for all the calls in the code and got this:\n\n\n\nWhich doesn't seem quite normal.\n\nSo I went ahead and started stepping from the EP hopefully landing on some decryption procedure -\n\n\n\nI'll briefly explain what I concluded from debugging this code:\n\nSo I went ahead jumping to 00401C80 to check what this is all about and found this code which kinda looks like junk code to me -\n\n\n\nI suspect because there are some instructions that just don't seem logic to me like:\n\n```\nMOV EAX, 64\nCMP EAX,3E8\n\n```\nBut I might be wrong.\n\nThe problem is that after at the end of the function a value is copied into ECX and then CALL ECX is called which eventually ends in memory access violation:\n\n\n\nNo matter what I do or how I play with the flags inside this function I get an access violation or the code exits.\n\nSOOOOOOOOO, my first thought was that I'm dealing with some kinda anti-debugging technique, so I tried to run the malware inside the VM and intercept some data from it -\n\n\n\nAnd it seems like it's running alright and even created a UDP socket, no access violation or something like that.\n\nI tried looking online for reports about this virus but I couldn't found any resources about how to bypass this obstacle.\n\nAnyone got an idea how I should approach this? why is Olly failing? How does this code knows that it's being debugged? It doesn't seem like it uses some kind of API for that (like IsDebuggerPresent).\n\nThanks for everyone in advance.\n\n",
  "votes": "1",
  "answers": 2,
  "views": "774",
  "tags": [
    "ollydbg",
    "malware",
    "obfuscation",
    "anti-debugging",
    "deobfuscation"
  ],
  "user": "FigureItOut",
  "time": "Jun 17, 2020 at 9:54",
  "comments": [
    {
      "user": "user2823000",
      "text": "Did you look at the Marion Marschalek's report on the same blog? It's the winning entry, and IIRC she's doing a fine job of explaining it all",
      "time": null
    },
    {
      "user": "FigureItOut",
      "text": "@Dillinur, yes I did :) and she did a great job indeed, but she doesn't go into details of how she unpacked it.",
      "time": null
    }
  ],
  "answers_data": [
    {
      "content": "About the \"??3@YAXPAX\" calls, it is called Name Mangling, take a look at this thread for more explanation.\n\n\"YAXPAX\" calls are actually the delete C++ operator.\n\nAbout the __set_app_type, __getmainargs, GetStartupInfo etc, those calls are generated by the compiler and usally called before the main function. They aren't part of the source code of the program you are willing to analyze, so you shouldn't have to analyze them.\n\nYour main seems to be located at 00401C80, as it is usually right before a call to exit. This is where you start analyzing things seriously.\n\nConcerning the anti-debug protection, there are few instructions that let me think there is something that catches the exception in the program :\n\n\ncmp [0], 0 is supposed to crash, so maybe there is some custom exception handlers installed somewhere. I would say to check for TLS callback functions, but I may be wrong. You should be able to pass the exception by pressing Shift+F7, break on NtContinue, read the CONTEXT structure and continue the execution of the program.\n\nHere is a listing of the most frequent anti debug tricks you may find - including the Thread Local Storage trick.\n\n",
      "votes": "3",
      "user": "Community",
      "time": "Apr 13, 2017 at 12:49",
      "is_accepted": true,
      "comments": []
    },
    {
      "content": "```\nimport base64\nimport zipfile\nimport os\nimport hashlib\ninfile = open(\"c:\\\\halvar\\\\halvfem.bin\",\"rb\")\noutfile = open(\"c:\\\\halvar\\\\halvfem.zip\",\"wb\")\nbase64.decode(infile,outfile)\ninfile.close()\noutfile.close()\nif (zipfile.is_zipfile(\"c:\\\\halvar\\\\halvfem.zip\")):\n    myzip = zipfile.ZipFile(\"c:\\\\halvar\\\\halvfem.zip\",'r')\n    myzip.extractall('c:\\\\halvar\\\\',myzip.namelist(),'infected')\n    os.rename(myzip.namelist()[0],\"halvar_challenge.exe\")\n    print hashlib.md5(open('c:\\\\halvar\\\\halvar_challenge.exe','rb').read()).hexdigest()\n\n```\nis this the file you are talking about\n\n```\nC:\\halvar>python decode.py\n172aed81c4fde1cf23f1615acedfad65\n\nC:\\halvar>f:\\odbg110\\OLLYDBG.EXE halvar_challenge.exe\n\n```\nthe exe is setting up a Structured Exception Handler prior to call ecx \nyou should follow the Exception handler may be several times \n\nhint check this function in msvcrt\n\n```\n77C2275C MSVCRT._JumpToContinuation    $  8BFF          MOV     EDI, EDI\n\n```\nif you followed them you should be able to see  0x89 imports being resolved with LoadLibrary and GetProcAddress \n\ni followed till CreateEvent before posting this\n\n```\n0013FD90   0040F520  /CALL to CreateEventA from halvar_c.0040F51D\n0013FD94   00000000  |pSecurity = NULL\n0013FD98   00000001  |ManualReset = TRUE\n0013FD9C   00000000  |InitiallySignaled = FALSE\n0013FDA0   0013FDCC  \\EventName = \"{AB8D393B-9177-440d-B3F8-1C1FE0CF9692}\"\n\n```\n",
      "votes": "1",
      "user": "blabb",
      "time": "Jun 20, 2015 at 10:30",
      "is_accepted": false,
      "comments": []
    }
  ]
}