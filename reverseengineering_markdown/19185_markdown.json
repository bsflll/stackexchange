{
  "title": "angr multiple reads same variable",
  "link": "https://reverseengineering.stackexchange.com/questions/19185/angr-multiple-reads-same-variable",
  "content": "I'm writing a script to solve a binary that asks for multiple strings like the following c code,\n\nMy problem I can't dump the 'second_pass, I just get \"first_pass\".\nprobably due of the use of the same variable to read input from. any help please\n\n```\n#include <stdio.h>\n\nint main()\n{\n    int i, lose = 1;\n    char first[20]=\"first_pass\", input[20];\n    scanf(\"%s\", input);\n    for(i=0; i < strlen(first); i++)\n    {\n        if(first[i] != input[i])\n            lose = 0;\n    }\n\n    if(lose)\n        printf(\"gg\");\n    else\n        printf(\"fail\");\n\n\n    char second[20]=\"second_pass\";\n    scanf(\"%s\", input);\n    for(i=0; i < strlen(second); i++)\n    {\n        //printf(\"%c = %c  \n\", second[i], input[i]);\n        if(second[i] != input[i])\n            lose = 0;\n    }\n\n    printf(\"  \n\");\n    if(lose)\n        printf(\"gg\");\n    else\n        printf(\"fail\");\n}\n\n```\nmy angr script \n\n```\nimport angr\nimport logging\n\n\n\nstart_at = 0x400550\n\nfail = (0x400681,0x400751)\nsuccess = (0x400680, 0x400740)\n\n\n\n\np = angr.Project(\"./a.out\", load_options={'auto_load_libs': False})\n\n\nstate = p.factory.blank_state(addr=addr_main)\n\npath = p.factory.path(state)\npathgroup = p.factory.path_group(path)\nprint \"Searching...\"\nfound_state = pathgroup.explore(find=success, avoid=fail)\n\nif found_state.found:\n    f = found_state.found[0].state\n\n    print \"Flag: %s\" % (f.posix.dumps(0)[0:20],)\n\n```\n",
  "votes": "3",
  "answers": 1,
  "views": "427",
  "tags": [
    "angr"
  ],
  "user": "soolidsnake",
  "time": "Aug 29, 2018 at 15:58",
  "comments": [],
  "answers_data": [
    {
      "content": "Since OP didn't specify the addresses referred to by the hardcoded offsets, I'm gonna assume his intention. I'm assuming the values in find match the two printf(\"gg\") statements and the two values in avoid match the two printf(\"fail\"); statements.\n\nFirst of all, I believe your program has two unintentional considerable bugs in it, preventing the intended solutions from being needed:\n\nI find your example code quite interesting because those are two relatively common security vulnerabilities.\n\nIgnoring the first logical bug above, I believe the issue is your configured success criteria; According to angr documentation (emphasis is mine):\n\nProviding a sequence of addresses in explorer's find, like you did, means either one is an acceptable success condition. Because you did not provide any num_find the default of 1 is assumed and execute returns with the first success found.\n\nObviously, this is the success criteria for the first password. That is forced upon angr because the avoid parameter you provided. If the avoid  condition is reached the current exploration path is terminated, preventing any additional exploration down that path. In your case, providing an avoid of the failure of the first password means any paths failing the first password will be immediately discarded. Therefore, intentionally or not - thanks to your avoid, no path is possible that does reach a success in the first password test.\n\nThere are several ways to properly solve this challenge and I'll go over them.\n\nOne might think a proper solution could be to increase num_find to more than one, allowing more than one found states to be reached before explorer returns. That, however, is a mistake. Because your example code does not makes sure passwords are actually identical strings because there's no length validation and the null terminator is not compared, it appears any string starting with \"first_pass\" should be considered a valid solution. Interestingly enough, this accidently allows more than one solution (and in reality, quite a lot), so increasing num_find to any computationally feasible value will yield additional solutions to the first password, never reaching the second one.\n\nbtw, to fix the erroneous password verification condition, you can either verify lengths match, use a string comparison function (such as strcmp and derivatives), or change the conditional from < to <= so it will include the null terminator.\n\nSince the two scenarios are completely independent of one another, you could run to executions. One for each password, setting a single find and avoid value for each, as well as setting the entry point for the second one. Splitting the two executions will effectively create a more simple set of constraints which should be executing faster. Of course, you can even run them in parallel to gain an additional performance advantage.\n\nAlthough your values of find and avoid may initially seem correct, we've discussed several reasons why in reality they fail to accurately describe your intention. A more accurate specification of those parameters will be setting avoid to both printf(\"fail\"); statements, as you did. However you'll need to remove the first printf(\"gg\") and only keep the second, as it won't be reached without passing both passwords (assuming the logical bug mentioned above is fixed).\n\n",
      "votes": "1",
      "user": "Community",
      "time": "Jun 17, 2020 at 9:54",
      "is_accepted": false,
      "comments": []
    }
  ]
}