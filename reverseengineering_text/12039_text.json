{
    "title": "Identify targets of a switch table in ARM",
    "link": "https://reverseengineering.stackexchange.com/questions/12039/identify-targets-of-a-switch-table-in-arm",
    "content": "I'm working on a disassembler for ARM Thumb2 (stripped) binaries. I can already recover the CFG of Basic Blocks (BB) that use direct jumps. My next goal is to handle indirect jumps. I'm currently working on identifying targets of switch statements which I'll discuss based on the following example:\n<pre><code>int main(int argc, char** argv){\n  int i = 0;\n  switch (argc) {\n    case 0: i++; break;\n    case 1: i+=2; break;\n    case 3: i+=3; break;\n    case 6: i+=6; break;\n    case 5: i+=8; break;\n    case 7: i+=10; break;\n    default: i+=87; break;\n  }\n  return i;\n}\n</code></pre>\nWhen compiling the above example using: \n\narm-linux-gnueabihf-gcc-4.8 -o3 -mthumb main.c -o main.out\n\nDisassembling <pre><code>main</code></pre> using <pre><code>objdump</code></pre> show that the switch table data words start at <pre><code>0x83d8</code></pre> as can be seen here:\n<pre><code>83bc:       b480            push    {r7}\n83be:       b085            sub     sp, #20\n83c0:       af00            add     r7, sp, #0\n83c2:       6078            str     r0, [r7, #4]\n83c4:       6039            str     r1, [r7, #0]\n83c6:       2300            movs    r3, #0\n83c8:       60fb            str     r3, [r7, #12]\n83ca:       687b            ldr     r3, [r7, #4]\n83cc:       2b07            cmp     r3, #7\n83ce:       d82b            bhi.n   8428 <main+0x6c>\n83d0:       a201            add     r2, pc, #4      ; (adr r2, 83d8 <main+0x1c>)\n83d2:       f852 f023       ldr.w   pc, [r2, r3, lsl #2]\n83d6:       bf00            nop\n83d8:       000083f9        .word   0x000083f9\n83dc:       00008401        .word   0x00008401\n83e0:       00008429        .word   0x00008429\n83e4:       00008409        .word   0x00008409\n83e8:       00008429        .word   0x00008429\n83ec:       00008419        .word   0x00008419\n83f0:       00008411        .word   0x00008411\n83f4:       00008421        .word   0x00008421\n83f8:       68fb            ldr     r3, [r7, #12]\n83fa:       3301            adds    r3, #1\n83fc:       60fb            str     r3, [r7, #12]\n83fe:       e017            b.n     8430 <main+0x74>\n8400:       68fb            ldr     r3, [r7, #12]\n8402:       3302            adds    r3, #2\n8404:       60fb            str     r3, [r7, #12]\n8406:       e013            b.n     8430 <main+0x74>\n8408:       68fb            ldr     r3, [r7, #12]\n840a:       3303            adds    r3, #3\n840c:       60fb            str     r3, [r7, #12]\n840e:       e00f            b.n     8430 <main+0x74>\n8410:       68fb            ldr     r3, [r7, #12]\n8412:       3306            adds    r3, #6\n8414:       60fb            str     r3, [r7, #12]\n8416:       e00b            b.n     8430 <main+0x74>\n8418:       68fb            ldr     r3, [r7, #12]\n841a:       3308            adds    r3, #8\n841c:       60fb            str     r3, [r7, #12]\n841e:       e007            b.n     8430 <main+0x74>\n8420:       68fb            ldr     r3, [r7, #12]\n8422:       330a            adds    r3, #10\n8424:       60fb            str     r3, [r7, #12]\n8426:       e003            b.n     8430 <main+0x74>\n8428:       68fb            ldr     r3, [r7, #12]\n842a:       3357            adds    r3, #87 ; 0x57\n842c:       60fb            str     r3, [r7, #12]\n842e:       bf00            nop\n8430:       68fb            ldr     r3, [r7, #12]\n8432:       4618            mov     r0, r3\n8434:       3714            adds    r7, #20\n8436:       46bd            mov     sp, r7\n8438:       f85d 7b04       ldr.w   r7, [sp], #4\n843c:       4770            bx      lr\n843e:       bf00            nop\n</code></pre>\nObservations:\n\nData words store the absolute target addresses of the switch table not  offsets. \nThe indirect branch is implemented using <pre><code>ldr.w   pc, [base, index, lsl #2]</code></pre>  where base (here r2) stores the address of the beginning of data words and index (here r3) is used to calculate the offset.\n\nQuestions:\n\nCan the aforementioned observations be generalized? in other words, can I assume the this is the (de-facto) standard way for (most) ARM compilers to implement switch statements?\nWhy are the addresses stored in data words odd? I can't see any mode switching between ARM/Thumb here. For example, the default case can be found at <pre><code>0x8428</code></pre> but the corresponding address is stored as <pre><code>0x00008429</code></pre>.\n",
    "votes": "3",
    "answers": 1,
    "views": "853",
    "tags": [
        "disassembly",
        "arm",
        "thumb2"
    ],
    "user": "Codoka",
    "time": "Feb 15, 2016 at 16:12",
    "comments": [],
    "answers_data": [
        {
            "content": "No, you can't assume that's how most ARM compilers will implement switch statements. For example, here's gcc 5.2.1 on that same code:\n<pre><code>cosimo:~ moyix$ arm-none-eabi-gcc-5.2.1 -o3 -mthumb -c x.c -o x.o\ncosimo:~ moyix$ arm-none-eabi-objdump -d x.o\n\nx.o:     file format elf32-littlearm\n\n\nDisassembly of section .text:\n\n00000000 <main>:\n   0:   b580        push    {r7, lr}\n   2:   b084        sub sp, #16\n   4:   af00        add r7, sp, #0\n   6:   6078        str r0, [r7, #4]\n   8:   6039        str r1, [r7, #0]\n   a:   2300        movs    r3, #0\n   c:   60fb        str r3, [r7, #12]\n   e:   687b        ldr r3, [r7, #4]\n  10:   2b07        cmp r3, #7\n  12:   d81d        bhi.n   50 <main+0x50>\n  14:   687b        ldr r3, [r7, #4]\n  16:   009a        lsls    r2, r3, #2\n  18:   4b13        ldr r3, [pc, #76]   ; (68 <main+0x68>)\n  1a:   18d3        adds    r3, r2, r3\n  1c:   681b        ldr r3, [r3, #0]\n  1e:   469f        mov pc, r3\n  20:   68fb        ldr r3, [r7, #12]\n  22:   3301        adds    r3, #1\n  24:   60fb        str r3, [r7, #12]\n  26:   e017        b.n 58 <main+0x58>\n  28:   68fb        ldr r3, [r7, #12]\n  2a:   3302        adds    r3, #2\n  2c:   60fb        str r3, [r7, #12]\n  2e:   e013        b.n 58 <main+0x58>\n  30:   68fb        ldr r3, [r7, #12]\n  32:   3303        adds    r3, #3\n  34:   60fb        str r3, [r7, #12]\n  36:   e00f        b.n 58 <main+0x58>\n  38:   68fb        ldr r3, [r7, #12]\n  3a:   3306        adds    r3, #6\n  3c:   60fb        str r3, [r7, #12]\n  3e:   e00b        b.n 58 <main+0x58>\n  40:   68fb        ldr r3, [r7, #12]\n  42:   3308        adds    r3, #8\n  44:   60fb        str r3, [r7, #12]\n  46:   e007        b.n 58 <main+0x58>\n  48:   68fb        ldr r3, [r7, #12]\n  4a:   330a        adds    r3, #10\n  4c:   60fb        str r3, [r7, #12]\n  4e:   e003        b.n 58 <main+0x58>\n  50:   68fb        ldr r3, [r7, #12]\n  52:   3357        adds    r3, #87 ; 0x57\n  54:   60fb        str r3, [r7, #12]\n  56:   46c0        nop         ; (mov r8, r8)\n  58:   68fb        ldr r3, [r7, #12]\n  5a:   0018        movs    r0, r3\n  5c:   46bd        mov sp, r7\n  5e:   b004        add sp, #16\n  60:   bc80        pop {r7}\n  62:   bc02        pop {r1}\n  64:   4708        bx  r1\n  66:   46c0        nop         ; (mov r8, r8)\n  68:   00000000    .word   0x00000000\n</code></pre>\nAnd there are more complex schemes possible, including things like binary search on the switch value to find the right case. In general you need to do a more complex analysis to recover switch statements. Some academic work exists on this topic, e.g.:\nhttp://www.cs.tufts.edu/~nr/cs257/archive/cristina-cifuentes/switch-proof.pdf\nAs to your second question, jumps using <pre><code>ldr pc</code></pre> must explicitly specify the mode. Since you compiled the code with <pre><code>-mthumb</code></pre>, you're in thumb mode, and to stay in thumb mode those addresses need to have bit 0 set to 1 (see note [a] on this page).\n",
            "votes": "2",
            "user": "Brendan Dolan-Gavitt",
            "time": "Feb 15, 2016 at 17:25",
            "is_accepted": true,
            "comments": []
        }
    ]
}