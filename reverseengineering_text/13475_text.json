{
    "title": "How can I determine if a piece of code is an encryption algorithm?",
    "link": "https://reverseengineering.stackexchange.com/questions/13475/how-can-i-determine-if-a-piece-of-code-is-an-encryption-algorithm",
    "content": "I am trying to reverse engineer a malware, and came across a piece of code that I suspect is an encryption/decryption procedure, however I do not know for sure. I can recognize that it extracts its payload from it's own <pre><code>.rsrc</code></pre> section.\n I scanned this algorithm with FindCrypt and IDAScope, Both plugins failed identifying it as a cryptographic algorithm.\nI am not familiar with cryptographic algorithms. What are some good indications of code being an encryption or decryption algorithm, and what indications rule it out?\nThe extraction algorithm is(generated by IDA):\n<pre><code>int __stdcall sub_9001320(int a1, unsigned int a2, int a3)\n{\n// a1 = a3 = 0x09003000\n// a2 = 0x7600\n\n\n\n  int result; // eax@2\n  char v4; // al@23\n  unsigned int l; // [sp+4h] [bp-4Ch]@33\n  unsigned int k; // [sp+10h] [bp-40h]@19\n  unsigned int v7; // [sp+14h] [bp-3Ch]@19\n  int v8; // [sp+18h] [bp-38h]@40\n  signed int j; // [sp+1Ch] [bp-34h]@13\n  unsigned int v10; // [sp+20h] [bp-30h]@5\n  unsigned int i; // [sp+24h] [bp-2Ch]@5\n  unsigned int v12; // [sp+28h] [bp-28h]@5\n  unsigned int v13; // [sp+2Ch] [bp-24h]@5\n  signed int v14; // [sp+30h] [bp-20h]@13\n  unsigned int v15; // [sp+34h] [bp-1Ch]@5\n  unsigned int v16; // [sp+38h] [bp-18h]@5\n  unsigned __int8 v17; // [sp+3Fh] [bp-11h]@5\n  signed int v18; // [sp+40h] [bp-10h]@5\n  _DWORD *lpAddress; // [sp+44h] [bp-Ch]@11\n  unsigned int v20; // [sp+48h] [bp-8h]@13\n  unsigned int v21; // [sp+4Ch] [bp-4h]@16\n\n  if ( a2 > 0xC )\n  {\n    if ( *(_DWORD *)a1 == 1083581807 )\n    {\n      v16 = sub_9001300(a1);\n      v18 = 12;\n      v17 = 0;\n      v15 = 9;\n      v12 = 256;\n      v13 = 256;\n      v10 = 8 * a2 - 96;\n      for ( i = 9; v10 >= i; v10 -= i )\n      {\n        if ( i != 12 && v13 == 1 << i )\n          ++i;\n        ++v13;\n      }\n      lpAddress = VirtualAlloc(0, 0xC000u, 0x1000u, 4u);\n      if ( lpAddress )\n      {\n        v20 = 0;\n        v14 = 256;\n        for ( j = 0; j <= 255; ++j )\n        {\n          lpAddress[3 * j] = 0;\n          lpAddress[3 * j + 2] = 0;\n          lpAddress[3 * j + 1] = 1;\n        }\n        v21 = 0;\n        while ( v21 < v16 && v12 < v13 )\n        {\n          v7 = 0;\n          for ( k = 0; k < v15; ++k )\n          {\n            if ( (1 << (7 - (v17 + 8 * v18) % 8)) & *(_BYTE *)(a1 + (v17 + 8 * v18) / 8) )\n              v7 |= 1 << k;\n            v4 = (v17 + 1) % 8;\n            v17 = (v17 + 1) % 8;\n            if ( !v4 )\n              ++v18;\n          }\n          if ( v7 > 0xFF )\n          {\n            if ( v20 < 0xF00 && v7 > v20 + 255 )\n              return 0;\n            if ( v21 + lpAddress[3 * v7 + 1] > v16 )\n              return 0;\n            for ( l = 0; l < lpAddress[3 * v7 + 1]; ++l )\n              *(_BYTE *)(a3 + l + v21) = *(_BYTE *)(a3 + l + lpAddress[3 * v7]);\n          }\n          else\n          {\n            *(_BYTE *)(v21 + a3) = v7;\n          }\n          if ( v20 == 3840 )\n          {\n            if ( (unsigned int)++v14 >> 12 )\n              v14 = 256;\n          }\n          if ( v20 >= 0xF00 )\n          {\n            v8 = v14 - 1;\n            if ( v14 == 256 )\n              v8 = 4095;\n          }\n          else\n          {\n            v8 = v20 + v14;\n          }\n          lpAddress[3 * v8] = v21;\n          lpAddress[3 * v8 + 1] = lpAddress[3 * v7 + 1] + 1;\n          lpAddress[3 * v8 + 2] = 0;\n          if ( v20 < 0xF00 )\n            ++v20;\n          v21 = v21 + lpAddress[3 * v8 + 1] - 1;\n          ++v12;\n          if ( v15 < 0xC && 1 << v15 == v12 )\n            ++v15;\n        }\n        if ( v21 >= v16 )\n        {\n          // sub_9001000 is only called onece and always return 0\n          if ( *(_DWORD *)(a1 + 8) == sub_9001000(a3, v16) )\n          {\n            VirtualFree(lpAddress, 0, 0x8000u);\n            result = 0;\n          }\n          else\n          {\n            result = 0;\n          }\n        }\n        else\n        {\n          result = 0;\n        }\n      }\n      else\n      {\n        result = 0;\n      }\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\n\n\nint __stdcall sub_9001300(int a1)\n{\n  int result; // eax@2\n\n  if ( *(_DWORD *)a1 == 1083581807 )\n    result = *(_DWORD *)(a1 + 4);\n  else\n    result = 0;\n  return result;\n}\n</code></pre>\nFile info:\n     file format pei-i386\n<pre><code>Sections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         00001000  09001000  09001000  00001000  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .rdata        00001000  09002000  09002000  00002000  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  2 .rsrc         00005000  09003000  09003000  00003000  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  3 .reloc        00001000  09008000  09008000  00008000  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n</code></pre>\n",
    "votes": "3",
    "answers": 1,
    "views": "604",
    "tags": [
        "malware",
        "unpacking",
        "encryption",
        "decryption",
        "encodings"
    ],
    "user": "JACK M",
    "time": "Sep 9, 2016 at 21:50",
    "comments": [
        {
            "user": "ebux",
            "text": "It seems to be a compression algorithm and not a cryptographic one.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "TL;DR: What we have here is probably not an encryption algorithm, it is more likely a decompression loop, by the look of it. It simply does not do anything that could be considered even remotely similar to encryption.\nEncryption algorithms are divided into two classes. First is a stream cipher. From wikipedia:\n\nA stream cipher is a symmetric key cipher where plaintext digits are combined with a pseudorandom cipher digit stream (keystream). In a stream cipher each plaintext digit is encrypted one at a time with the corresponding digit of the keystream, to give a digit of the ciphertext stream. Since encryption of each digit is dependent on the current state of the cipher, it is also known as state cipher. In practice, a digit is typically a bit and the combining operation an exclusive-or (XOR).\n\nSecond is a block cypher. From wikipedia:\n\nIn cryptography, a block cipher is a deterministic algorithm operating on fixed-length groups of bits, called blocks, with an unvarying transformation that is specified by a symmetric key. Block ciphers operate as important elementary components in the design of many cryptographic protocols, and are widely used to implement encryption of bulk data.\nThe modern design of block ciphers is based on the concept of an iterated product cipher. In his seminal 1949 publication, Communication Theory of Secrecy Systems, Claude Shannon analyzed product ciphers and suggested them as a means of effectively improving security by combining simple operations such as substitutions and permutations.1 Iterated product ciphers carry out encryption in multiple rounds, each of which uses a different subkey derived from the original key. One widespread implementation of such ciphers, named a Feistel network after Horst Feistel, is notably implemented in the DES cipher.2 Many other realizations of block ciphers, such as the AES, are classified as substitution-permutation networks.\n\nWhat we have here is probably not an encryption algorithm. It simply does not do anything that could be considered even remotely similar to encryption. Some of the things that are often found in encryption algorithms but are missing here (not a complete list but just the first few things I came up with):\n\nThere's no pseudo-random stream generated based on an internal state and seed like in stream ciphers\nno sequential character combination of generated stream with input buffer using a XOR (or any other operation).\nNo block structure - a sequence executed multiple times on each nicely chunked portion of the input message.\nno long and complex permutation (and no permutation table).\nNo multiple iterations of a permutation code common to block ciphers.\nno key sequence initialization (used in both stream and block ciphers).\nNot enough substitutions over either input message or stream/state.\n\nEncryption algorithms are usually long (and one might say ugly). Usually structured and meticulous on performing operations on all bytes in long repeated sequences. You'll often see multiple iterations of a fixed length performing a single or few operations.\nThis is more resembling a compression/decompression algorithm, as sequences of bytes are copied on certain conditions, while bytes are constructed into the decompressed buffer on others.\nLets go over the code and see:\n<pre><code>int __stdcall sub_9001320(int a1, unsigned int a2, int a3)\n{\n// a1 = a3 = 0x09003000\n// a2 = 0x7600\n\n  int result; // eax@2\n  char v4; // al@23\n  unsigned int l; // [sp+4h] [bp-4Ch]@33\n  unsigned int k; // [sp+10h] [bp-40h]@19\n  unsigned int v7; // [sp+14h] [bp-3Ch]@19\n  int v8; // [sp+18h] [bp-38h]@40\n  signed int j; // [sp+1Ch] [bp-34h]@13\n  unsigned int v10; // [sp+20h] [bp-30h]@5\n  unsigned int i; // [sp+24h] [bp-2Ch]@5\n  unsigned int v12; // [sp+28h] [bp-28h]@5\n  unsigned int v13; // [sp+2Ch] [bp-24h]@5\n  signed int v14; // [sp+30h] [bp-20h]@13\n  unsigned int v15; // [sp+34h] [bp-1Ch]@5\n  unsigned int v16; // [sp+38h] [bp-18h]@5\n  unsigned __int8 v17; // [sp+3Fh] [bp-11h]@5\n  signed int v18; // [sp+40h] [bp-10h]@5\n  _DWORD *lpAddress; // [sp+44h] [bp-Ch]@11\n  unsigned int v20; // [sp+48h] [bp-8h]@13\n  unsigned int v21; // [sp+4Ch] [bp-4h]@16\n</code></pre>\nFunction definiton\n<pre><code>  if ( a2 > 0xC )\n  {\n</code></pre>\nAssert a certain length is at least 96 bytes. Although there are some block ciphers accepting this as block size, it's not too common and most widely accepted block ciphers do not support this block size.\n<pre><code>    if ( *(_DWORD *)a1 == 1083581807 )\n    {\n</code></pre>\nAssert certain first bytes of buffer are fixed, this just looks odd without context.\n<pre><code>      v16 = sub_9001300(a1);\n</code></pre>\nSet <pre><code>v16</code></pre> to second dword of input buffer\n<pre><code>      v18 = 12;\n      v17 = 0;\n      v15 = 9;\n      v12 = 256;\n      v13 = 256;\n      v10 = 8 * a2 - 96;\n</code></pre>\nSome more variable initializations\n<pre><code>      for ( i = 9; v10 >= i; v10 -= i )\n      {\n        if ( i != 12 && v13 == 1 << i )\n          ++i;\n        ++v13;\n      }\n</code></pre>\nIncrease <pre><code>v13</code></pre> according to original length. Without going too much into specifics here, this doesn't look like any cipher seed/initialization.\n<pre><code>      lpAddress = VirtualAlloc(0, 0xC000u, 0x1000u, 4u);\n      if ( lpAddress )\n      {\n</code></pre>\nAllocate a hardcoded length buffer to work on as temporary data\n<pre><code>        v20 = 0;\n        v14 = 256;\n        for ( j = 0; j <= 255; ++j )\n        {\n          lpAddress[3 * j] = 0;\n          lpAddress[3 * j + 2] = 0;\n          lpAddress[3 * j + 1] = 1;\n        }\n</code></pre>\nInitialize said buffer, 2/3 with 0s, 1/3 with 1s. this is probably a boolean buffer.\n<pre><code>        v21 = 0;\n        while ( v21 < v16 && v12 < v13 )\n        {\n</code></pre>\nLoop <pre><code>v16</code></pre> times. remember <pre><code>v16</code></pre> is user supplied as the second dword in provided buffer. The second dword after the magic is probably a length.\n<pre><code>          v7 = 0;\n          for ( k = 0; k < v15; ++k )\n          {\n</code></pre>\nAnother loop, this time for 9 iterations. This means we have 9 iterations for each character in the guessed length parameter. Most block ciphers will have more iterations, and those won't be per character. Most stream ciphers will not process data but instead generate a stream of bytes to XOR with. We don't see a XOR here either.\n<pre><code>            if ( (1 << (7 - (v17 + 8 * v18) % 8)) & *(_BYTE *)(a1 + (v17 + 8 * v18) / 8) )\n              v7 |= 1 << k;\n</code></pre>\nBits are only added to <pre><code>v7</code></pre>, also not productive for any type of encryption algorithm.\n<pre><code>            v4 = (v17 + 1) % 8;\n            v17 = (v17 + 1) % 8;\n</code></pre>\nThese two are byte-sized counters.\n<pre><code>            if ( !v4 )\n              ++v18;\n          }\n</code></pre>\nIncrease another counter, used for determining how many bits in <pre><code>v7</code></pre> will be set. This entire loop decides which bits of <pre><code>v7</code></pre> will be set, depending on a fixed sequence and wether certain bits of the input buffer are\n<pre><code>          if ( v7 > 0xFF )\n          {\n            if ( v20 < 0xF00 && v7 > v20 + 255 )\n              return 0;\n            if ( v21 + lpAddress[3 * v7 + 1] > v16 )\n              return 0;\n            for ( l = 0; l < lpAddress[3 * v7 + 1]; ++l )\n              *(_BYTE *)(a3 + l + v21) = *(_BYTE *)(a3 + l + lpAddress[3 * v7]);\n          }\n</code></pre>\nIf <pre><code>v7</code></pre> is above 0xff do some sanity (and return on invalid state/data) and then copy a sequence of bytes until a null terminator is reached from a3 to a3, at offsets determined by the value of <pre><code>lpAddress</code></pre> at a specific offset determined by <pre><code>v7</code></pre>.\n<pre><code>          else\n          {\n            *(_BYTE *)(v21 + a3) = v7;\n          }\n</code></pre>\nif <pre><code>v7</code></pre> is below or equal to 255, simply assign it in specified location.\n<pre><code>          if ( v20 == 3840 )\n          {\n            if ( (unsigned int)++v14 >> 12 )\n              v14 = 256;\n          }\n          if ( v20 >= 0xF00 )\n          {\n            v8 = v14 - 1;\n            if ( v14 == 256 )\n              v8 = 4095;\n          }\n          else\n          {\n            v8 = v20 + v14;\n          }\n</code></pre>\nReset values of <pre><code>v8</code></pre> and <pre><code>v4</code></pre> based on values of offset variables, namely <pre><code>v20</code></pre> and themselves.\n<pre><code>          lpAddress[3 * v8] = v21;\n          lpAddress[3 * v8 + 1] = lpAddress[3 * v7 + 1] + 1;\n          lpAddress[3 * v8 + 2] = 0;\n</code></pre>\nSet a few other values in <pre><code>lpAddress</code></pre> based hardcoded values (0) and a copy of a single value.\n<pre><code>          if ( v20 < 0xF00 )\n            ++v20;\n          v21 = v21 + lpAddress[3 * v8 + 1] - 1;\n          ++v12;\n          if ( v15 < 0xC && 1 << v15 == v12 )\n            ++v15;\n        }\n</code></pre>\nSome more counter update based on input and reset of overflows.\n<pre><code>        if ( v21 >= v16 )\n        {\n          // sub_9001000 is only called onece and always return 0\n          if ( *(_DWORD *)(a1 + 8) == sub_9001000(a3, v16) )\n          {\n            VirtualFree(lpAddress, 0, 0x8000u);\n            result = 0;\n          }\n          else\n          {\n            result = 0;\n          }\n        }\n        else\n        {\n          result = 0;\n        }\n      }\n      else\n      {\n        result = 0;\n      }\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\n</code></pre>\nIn case of any invalid input, return 0\n<pre><code>int __stdcall sub_9001300(int a1)\n{\n  int result; // eax@2\n\n  if ( *(_DWORD *)a1 == 1083581807 )\n    result = *(_DWORD *)(a1 + 4);\n  else\n    result = 0;\n  return result;\n}\n</code></pre>\nAssert buffer starts with a hardcoded dword (which we already know is the case because of a previous if statement) and return the value in the second dword.\n",
            "votes": "11",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": [
                {
                    "user": "John Greene",
                    "text": "<span class=\"comment-copy\">Not even a modicum of P-box or S-box, much less rotate instruction sequence.</span>",
                    "time": null
                }
            ]
        }
    ]
}