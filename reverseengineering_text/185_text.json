{
    "title": "How do I add functionality to an existing binary executable?",
    "link": "https://reverseengineering.stackexchange.com/questions/185/how-do-i-add-functionality-to-an-existing-binary-executable",
    "content": "I want to add some functionality to an existing binary file. The binary file was created using <pre><code>gcc</code></pre>. \n\nDo I need to decompile the binary first, even though I sufficiently understand the functioning of the program ? \nHow should I go about adding the necessary code ?\nDo I need any tools to be able to do this ?\n",
    "votes": "48",
    "answers": 8,
    "views": "34k",
    "tags": [
        "linux",
        "c",
        "executable",
        "hll-mapping"
    ],
    "user": "asheeshr",
    "time": "Apr 5, 2013 at 13:25",
    "comments": [
        {
            "user": "Remko",
            "text": "for what platform eg windows, linux?\n",
            "time": null
        },
        {
            "user": "sw.",
            "text": "What is the functionality that you want to add? because depending on that there are different approaches. For example for automating a GUI you use a different technique that for example changing a database engine.\n",
            "time": null
        },
        {
            "user": "Ciro Santilli OurBigBook.com",
            "text": "stackoverflow.com/questions/4309771/…\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "There are several broad ways in which you could do this.\n\nDynamic instrumentation\nTools such as PIN, Valgrind, or DynamoRIO allow you to dynamically change the behavior of a program.  For instance, you can add calls to new functions at particular addresses, intercept library calls and change them, and much more.\nThe downside is that dynamic instrumentation often has high overhead.\nStatic instrumentation\nYou can also try to statically modify the program to add the desired behavior.  One challenge is that you often need to muck around with the executable file format.  Some tools, such as <pre><code>elfsh</code></pre> from the ERESI project exist for this, but I have found them buggy and difficult to use.\nAnother strategy for static instrumentation is to \"recompile\".  You can do this by decompiling the program, modifying the source code, and recompiling.  In theory, you could also use a tool like BAP to lift the program to IL, modify it, and then re-compile it using LLVM.  However, the current version is probably not mature enough for this.\nDynamic loading\nYou can use <pre><code>LD_PRELOAD</code></pre> to override functions that are going to be dynamically linked.  This is a nice option when you want to change the behavior of a library function.  Naturally, it does not work on statically linked binaries, or for static functions.\nBinary patching\nYou can often make simple changes to a binary using a hex-editor.  For instance, if there is a function call or branch you would like to skip, you can often replace it with <pre><code>nop</code></pre> instructions.  If you need to add a large amount of new code, you will probably need to use something like <pre><code>elfsh</code></pre> from the ERESI project to help you resize the binary.\n",
            "votes": "39",
            "user": "Ed McMan",
            "time": "Mar 23, 2013 at 15:47",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "Very often, you can change the behavior of a program by carefully hooking into it. Whether you can add the functionality you want this way depends on how the program is constructed. It helps if the program comes in the form of one main executable plus several libraries.\nYou can hook into any call that the program makes to shared libraries by linking your own library in first, with <pre><code>LD_PRELOAD</code></pre>. Write a library that defines a function <pre><code>foo</code></pre>, and set the environment variable <pre><code>LD_PRELOAD</code></pre> to the path to your compiled (<pre><code>.so</code></pre>) library when you start the program: then the program will call your <pre><code>foo</code></pre> instead of the one it intends. You can call the original <pre><code>foo</code></pre> function from your replacement by obtaining a pointer to it with <pre><code>dlsym()</code></pre>.\nHere are a few examples and tutorials:\n\nUsing LD_PRELOAD to override a function — a minimal source code example\nModifying a Dynamic Library Without Changing the Source Code\nThe magic of LD_PRELOAD for Userland Rootkits\nFun with LD_PRELOAD (a long and detailed presentation)\n\nSome examples of programs that use <pre><code>LD_PRELOAD</code></pre>:\n\nfakechroot, PlasticFS — rewrite the file names used by the program\nElectric Fence, Valgrind — detect bad heap usage by overriding <pre><code>malloc</code></pre>\nLibshape — limit the network bandwidth\nKGtk — use KDE dialog boxes in a Gtk program\n\nThe limitation of <pre><code>LD_PRELOAD</code></pre> is that you can only intercept function calls that are resolved at runtime (dynamic linking). If you want to intercept an internal call, you'll have to resort to heavier-weight techniques (modifying the executable on-disk, or in-memory with <pre><code>ptrace</code></pre>).\n",
            "votes": "18",
            "user": "Gilles 'SO- stop being evil'",
            "time": "Mar 23, 2013 at 14:53",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "I want to add some functionality to an existing binary file.\n\nSo in general these four bigger Questions apply to modifying an Executeable:\nThe first basic Question posed: \nIs the Program wary of Code Modifications (Self-Checking, Anti-Debug-Tricks, Copy protection, ...)?\nIf so: \nIs it even possible to remove/circumevent these protections (e.g. unpacking, if it is packed) easily\nIs it worth the time to do so?\nThe second Question is:\nCan you find out, which Compiler/Language was used to produce the executeable?\nMore Details are better, but most basic constructs (<pre><code>if</code></pre> and other control-structures) should map quite similarly over a variety of compilers.\nThis is related to a previous Question on the RE-Stackexchange.\nThe third Question is:\nHow is the user interface implemented (CLI, Win32-Window Controls, Custom, ...)?\nIf this is known:\nCan you figure out the mapping of common HLL-Constructs (Menues, Dropdown-Menues, Checkboxes, ...) in conjunction with the used Compiler/Language that you want to modify?\nThe fourth and biggest Question is:\nHow can you create the desired functionality in the Program?\nIn essence this can require quite a bit of reverse engineering, to find out how to best hook into the program without upsetting it.\nCentral Point: How can you utilize existing internal API's to reach your Goal, without breaking Stuff (like CRTL+Z, Versioning, Recovery features)?existing Datastructures (and how are they related?)\nexisting Functions (Parameters, Parameter-Format, ...)\nWhat does it do?What else can it do?What does it REALLY do?...\nexisting Processes (= How the program goes about internally, stepwise to implement similar features) What functions are called, in which order?Which Data-Structures are utilized?\nWhere is the Meat of the feature/program (the data, e.g. the main painting area, and how does it relate internally?)\nStuff to look out for (if it concerns the desired feature):JournalingRecovery FeaturesVersioning\nHow is Metadata handled (e.g. Shutter speed, f-Stops, ...), that is related to the desired Feature.\nExample projects:\nBuilding a new kind of painting tool into a graphics program (without plugin-API).\nExtending the plugin-API of a program.\nBuilding a plugin-API into a program without one.\nAdding a new save/export-format for files (if there is no way to convert the output-format into a desired format, or if crucial information is missing in the exported files).\nAdding a new import-format (if there is no way to convert the input-format into a importable-format or if some information is not correctly imported).\nExtending Mspaint with a colour search-and-replace tool (within a selection, or in the whole picture)Adding Proxy Support/Basic Proxy-Authentication to a Program.Adding (new) Command line switches to a program that expose new/existing Features.Adding a API for Remote Procedure-Calls to Manage the Operations of the Programm externally.Adding Scripting-Support to automate often repeated Operations (If there is no plugin-/scripting-API to begin with) or support batch processing.\nRegarding wrapped Code & Decompilers:\nI will not talk about wrapped Code in other Languages that is packaged with a VM / an Interpreter (Py2Exe, Java 2 Exe, ...), or uses an installed one (JVM, C#). There are pretty good Decompilers for some of those cases. After a successful decompilation it pretty much boils down to defeating the Code Obfuscation (if there is one).\nRegarding C/C++-Decompilers:\nI cannot talk about C/C++-Decompilers, though it would boil down to best-effort HLL-Remapping (for stuff the Decompiler did not get) and Code-Deobfuscation (if it was compiled without Symbols) provided there is no further Protection in the Executeable.\nReccommendation regarding HLL-mapping:\nIn essence a big part of this Question concerns \"HLL mapping\" (High level language mapping (in machine code)) of and the modification of these constructs in the corresponding machine code. \nI found an excellent downloadable starting course, that uses \"IDA Free\", on this Topic here (binary-auditing.com).\n",
            "votes": "7",
            "user": "Community",
            "time": "Apr 13, 2017 at 12:49",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "(Slightly outdated, but as that wasn't mentioned previously in this thread)\nLong ago, I spend months extending a software with only the binary.\n\nI used IDA for analysis and SoftICE for live debugging. Decompiling is not required if you can understand the target at opcode/bytecode level.\nThen, because it was an x86 PE binary, I used Tasm and Iczelion's Code Snippet Creator: It's not a famous tool anymore, but it allowed to use Tasm transparently and re-inject code, with PE transformations, etc...\nIt added code at EntryPoint, so I did my own patches manually, then jumped to original EntryPoint.\n\nA bit old-school now - I'd probably inject a DLL these days - but it certainly worked.\nAnd at least, it gives you full control via ASM, while keeping maintainability via automated patching.\n",
            "votes": "7",
            "user": "Ange",
            "time": "Mar 26, 2013 at 10:45",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "You do not need to decompile the binary. If you understand what changes you want to make, and those changes can be made by only modifying the binary file or its dependencies, then you can just make those modifications on disk or in memory. \nYou have a few choices on how to effect the modification itself. \nYou could use LD_PRELOAD to have the linker load a shared object before the binary runs. Then you don't need to modify the binary on disk at all. This is kind of what valgrind does, it loads as a shared object but then begins dynamic binary instrumentation. \nYou could use valgrind. Valgrind would allow you to dynamically re-write the program and modify its behavior arbitrarily. Valgrind is a dynamic binary instrumentation program that allows its tools to edit the program while it executes. If you just want to change program behavior this might work, but valgrind also incurs a global slowdown and if you wanted to patch and redistribute a program, it probably is not ideal. \nYou could also use tools like elfsh/eresi to insert new code into the program. Those tools should take care of the act of injecting your code with relation to stuff like the ELF program header. There is a concept of \"ELF infector\" that you could google for, where your injected code becomes the new program entry point, does something, then jumps to the old program entry point.\n",
            "votes": "6",
            "user": "Lizz",
            "time": "Apr 6, 2013 at 17:43",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "Doing that on Windows\nAlthough this question focuses on Linux, where personally I would go with the easy <pre><code>LD_PRELOAD</code></pre> method as outlined in other answers, Windows knows a similar mechanism that in fact has been abused in the more recent past (also see alternative approaches below). I used that method to \"crack\" one dongle system.\nEnter ...\nDLL placement (aka preloading, aka hijacking) attacks\nThe name has been given to the method fairly recently when it turned out that placing DLLs on remote shares and then navigating to shares in, say a media player, would result in the media player loading the remote DLL instead of a local version. This is by design. Changing it now would break hundreds if not thousands of applications.\nThis has been addressed by Microsoft in certain ways, although the only real solution is proper implementation on the application side. But then, many developers haven't even grasped NT security even though we have to deal with it ever since Windows 2000 became the first consumer OS based on the NT platform.\nWhat does it have to do with your described goal?\nAdding functionality doesn't necessarily imply that you patch the executable on-disk. You can also do it in memory.\nHow can you leverage it?\nWhenever an application uses a DLL, and you can tell the load order with Dependency Walker or under a debugger, you can pick one of the DLLs it imports and replace that (in its current location) or placing another DLL in a path that precedes the existing DLL in the load order.\nAn alternative method is to change the name of the imported DLLs. In rare cases (well known DLLs, for example) this is the only viable method to load an alternative DLL and may still fail for certain special cases.\nLimitations\nIf the used DLL exists in the first location in the DLL search order, you'll literally have to replace the file on disk, unless you rename the import as briefly mentioned above.\nImplementations\nA manual approach can be used for DLLs with only few exported symbols. The easiest would be to create a module definition file from the the DLL and from that create a DLL with only function forwarders. This way your placed DLL would get loaded already and would simply pass through the calls.\nHowever, this approach will fail with exported variables (as opposed to functions).\nHere's a simple Python script based on <pre><code>pefile</code></pre> which I wrote for another answer over at StackOverflow:\n<pre><code>import os\nimport sys\nimport re\n\ndef main(pename):\n    from pefile import PE\n    print \"Parsing %s\" % pename\n    pe = PE(pename)\n    modname = os.path.basename(pename)\n    libname = re.sub(r\"(?i)^.*?([^\\\\/]+)\\.(?:dll|exe|sys|ocx)$\", r\"\\1.lib\", modname)\n    defname = libname.replace(\".lib\", \".def\")\n    print \"Writing module definition file %s for %s\" % (defname, modname)\n    f = open(defname, \"w\") # want it to throw, no sophisticated error handling here\n    f.write(\"LIBRARY %s\n\n\" % modname)\n    f.write(\"EXPORTS\n\")\n    numexp = 0\n    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:\n        if exp.name:\n            numexp += 1\n            f.write(\"\\t%s\n\" % exp.name)\n    print \"Wrote %s with %d exports\" % (defname, numexp)\n    print \"\n\nUse this to create the export lib:\n\\tlib /def:%s /out:%s\" % (defname, libname)\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        sys.stderr.write(\"ERROR:\n\\tSyntax: fakelib <dllfile>\n\")\n        sys.exit(1)\n    sys.exit(main(sys.argv[1]))\n</code></pre>\nYou could adjust it to create function forwarders instead of a simple module definition with exported names.\nSo this way you can shuttle your code into the target application and go from there.\nAlternative approaches\nInstrumentation and hooking have been mentioned already. Detours is an often mentioned example of hooking with an inconvenient EULA for most practical purposes. Refer to the existing answers for this kind of approach.\nYou can also use the <pre><code>AppInit_DLL</code></pre> registry value to inject a DLL early on. Or you could write a little launcher with a debugger loop and use <pre><code>Image File Execution Options</code></pre> to have your target launch your debugger first. A debugger can also influence the DLL loading or simply intercept - conveniently - calls at the boundary between executable and DLLs.\nTrivia: this (<pre><code>Image File Execution Options</code></pre>) is how Process Explorer replaces Task Manager when you choose the option inside Process Explorer.\n\nYou'll notice how you can sort these approaches into the categories Ed McMan mentioned in his answer already. However, I'll leave that as an exercise to the reader :)\n",
            "votes": "6",
            "user": "Glorfindel",
            "time": "Jul 20, 2022 at 8:43",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "I did this with Notepad.exe on Windows. I wanted to add one top-menu item to open calc.exe just for fun (I know your question is tagged Linux and gcc compiler, but the idea is probably the same).\nSo I used Resource Hacker tool to add Calc menu and opened notepad.exe on Immunity Debugger looking for some space in the code where I could put my WinExec shellcode. Initially I didn't change the executable, I had to look at the program in memory to find some space where I could paste my assembly instructions without crashing notepad.\nOnce I found enough space (changing original code by eliminating some not required assembly instructions or even optimizing them) I opened notepad.exe on XVI Hex Editor and searched for the opcodes that was running on Immunity. I mean, the debugger was running some opcodes right? I just searched for a sequence of opcodes to be sure I was at the right piece of the software that I wanted to change and pacthed it with my shellcode (now this is not assembly code but the \"compiled\" assembly - machine code)\nAgain: I know your question is tagged Linux and gcc compiler, but maybe someone could point out some tools in Linux to achieve the same I did on Windows. The idea is probably the same.\n",
            "votes": "3",
            "user": "jyz",
            "time": "Mar 23, 2013 at 15:43",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "\"ptrace()\" was casually mentioned by Giles.   But I think it deserved a whole section by itself.   \"ptrace()\" is a system call API provided by OS (Linux and all UNIX have it, and so do Windows) to exert debug control over another process.   When you used PTRACE_ATTACH (as part of ptrace()) to attach to another process, the kernel will pause the CPU running that process completely, allowing you to make changes to ANY part of the process: CPU, any registers, any part of that process memory etc.   That is how dynamic inline hooking work.    (ptrace() attach, modify binary in-memory, and then ptrace() unattached).   As far as I know, all dynamic modification of another process has to use ptrace() - as that is the only mechanism provided by kernel to guarantee integrity via system call at this point.\nBut recently similar API like utrace() is popping up, and so\ninline hooking is also theoretically possible:\nhttp://landley.net/kdocs/ols/2007/ols2007v1-pages-215-224.pdf\nFor kernel hooking, there are many methods:   syscall, interrupt, and inline hooking.   This is for interrupt hooking:\nhttp://mammon.github.io/Text/linux_hooker.txt\nWhen the CPU is in STOP mode, basically you can do anything you like to the CPU/memory space/register - just make sure you restore back to its original state before returning to the original address where it stopped.\nAnd if you use library inject technique, you can implement any functionalities - calling remote libraries, remote shell etc:\nhttps://attack.mitre.org/techniques/T1055/001/\nhttps://stackoverflow.com/questions/24355344/inject-shared-library-into-a-process\nhttps://backtrace.io/blog/backtrace/elf-shared-library-injection-forensics/\n",
            "votes": "2",
            "user": "Peter Teoh",
            "time": "Dec 12, 2020 at 6:05",
            "is_accepted": false,
            "comments": []
        }
    ]
}