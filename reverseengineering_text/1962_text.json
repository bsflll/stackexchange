{
    "title": "On SPARC, what happens when a branch is placed in the branch-delay slot of another branch?",
    "link": "https://reverseengineering.stackexchange.com/questions/1962/on-sparc-what-happens-when-a-branch-is-placed-in-the-branch-delay-slot-of-anoth",
    "content": "Our team recently had to look at SPARC assembly specifications, the problem is that I do not have a SPARC processor to try things on it (I should set up a simulator or get one of these old Sparc station on my desk... I know).\nSomehow, the <pre><code>ba</code></pre> (branch always) instruction puzzled me because it is a delayed branch execution instruction. This mean that the instruction located just after the <pre><code>ba</code></pre> get executed before the jump occurs.\nOne of my colleague raised a very interesting question, what does occur in this case:\n<pre><code>0x804b38 ba 0x805a10\n0x804b3c ba 0x806844\n...\n0x805a10 add %r3, %r2, %r5\n...\n0x806844 sub %r3, %r5, %r2\n...\n</code></pre>\nOur guess, following the specifications, is that the run should behave like this:\n<pre><code>0x805a10 add %r3, %r2, %r5\n0x806844 sub %r3, %r5, %r2\n0x806848 ...\n</code></pre>\nWhich means that you can probably jump and pick up one instruction inside a block of others and run to the next <pre><code>ba</code></pre>... I wonder what the CFG would look like.\nWhatever, it was the \"simple\" case, what if we have dynamic jumps (the <pre><code>jmp</code></pre> instruction is like a <pre><code>ba</code></pre> but based on the address stored in the given register):\n<pre><code>0x804b38 jmp %r3\n0x804b3c jmp %r0\n...\n(%r3)    change %r0\n...\n</code></pre>\nWould it be a good way to mislead a static-analyzer ? Or, is there a way to have an easy computation to guess what it is doing ?\n",
    "votes": "4",
    "answers": 1,
    "views": "788",
    "tags": [
        "obfuscation",
        "binary-analysis",
        "sparc"
    ],
    "user": "perror",
    "time": "Apr 30, 2013 at 15:36",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "do you have more code, e.g. a full binary? I have a SPARC to try it on ;)\n",
            "time": null
        },
        {
            "user": "perror",
            "text": "Sorry, I just speculate based on the specifications... :-/ I need to get a sparc and a complete build chain quickly. I have to try.\n",
            "time": null
        },
        {
            "user": "Mellowcandle",
            "text": "@0xC0000022L I deleted my comment, I didn't read the question till the end...\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "I edited the whole example a little so that it would better match the question.\nMy SPARC assembly fu is weak, but what I did was write a little \"Hello world\" with a twist (or one could say with jumps/<pre><code>goto</code></pre>s) in C and use <pre><code>gcc -S</code></pre> to translate it to assembly. I have a SPARC on which I am running it, details:\n<pre><code>$ isainfo -v\n64-bit sparcv9 applications\n        vis2 vis\n32-bit sparc applications\n        vis2 vis v8plus div32 mul32\n</code></pre>\nNB: <pre><code>b</code></pre> is the same as <pre><code>jmp</code></pre>, it's just a different mnemonic for the same thing, really. One takes an immediate value (<pre><code>b</code></pre>), the other a register (<pre><code>jmp</code></pre>).\nIt turns out that what the link you gave is true for GCC:\n\nNotice that the last instruction executes before the jump takes place,\n  not after the subroutine returns. This first instruction after a jump\n  is called a delay slot. It is common practice to fill the delay slot\n  with a special operation that performs no task, called a no-operation,\n  or <pre><code>nop</code></pre>.\n\nReal life test\nI reckon we need to do this with and without debugger, because it's not clear whether it might behave differently under a debugger. So the code should output something readable so we can see what kind of effect our tinkering has ;)\nC code\n<pre><code>#include <stdio.h>\n\nint foo(int argc)\n{\n        switch(argc)\n        {\n        case 0:\n        case 1:\n                goto a1;\n        case 2:\n                return 3;\n        case 4:\n                goto a2;\n        case 5:\n                return -1;\n        default:\n                goto a4;\n        }\na1:     return 1;\na2:     return 2;\na4:     return 4;\n}\n\nint main(int argc, char** argv)\n{\n        printf(\"Hello world: %i\n\", foo(argc));\n        return foo(argc);\n}\n</code></pre>\nThis gives me plenty of branch instructions to play around with the idea raised in the question.\nAssembly created by <pre><code>gcc -S</code></pre>\nHere's the assembly before I tinkered with it:\n<pre><code>        .file   \"test.c\"\n        .section        \".text\"\n        .align 4\n        .global foo\n        .type   foo, #function\n        .proc   04\nfoo:\n        !#PROLOGUE# 0\n        save    %sp, -120, %sp\n        !#PROLOGUE# 1\n        st      %i0, [%fp+68]\n        ld      [%fp+68], %g1\n        cmp     %g1, 5\n        bgu     .LL11\n        nop\n        ld      [%fp+68], %g1\n        sll     %g1, 2, %i5\n        sethi   %hi(.LL12), %g1\n        or      %g1, %lo(.LL12), %g1\n        ld      [%i5+%g1], %g1\n        jmp     %g1\n         nop\n.LL6:\n        mov     3, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL9:\n        mov     -1, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL5:\n        mov     1, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL8:\n        mov     2, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL11:\n        mov     4, %g1\n        st      %g1, [%fp-20]\n.LL1:\n        ld      [%fp-20], %i0\n        ret\n        restore\n        .align 4\n        .align 4\n.LL12:\n        .word   .LL5\n        .word   .LL5\n        .word   .LL6\n        .word   .LL11\n        .word   .LL8\n        .word   .LL9\n        .size   foo, .-foo\n        .section        \".rodata\"\n        .align 8\n.LLC0:\n        .asciz  \"Hello world: %i\n\"\n        .section        \".text\"\n        .align 4\n        .global main\n        .type   main, #function\n        .proc   04\nmain:\n        !#PROLOGUE# 0\n        save    %sp, -112, %sp\n        !#PROLOGUE# 1\n        st      %i0, [%fp+68]\n        st      %i1, [%fp+72]\n        ld      [%fp+68], %o0\n        call    foo, 0\n         nop\n        mov     %o0, %o5\n        sethi   %hi(.LLC0), %g1\n        or      %g1, %lo(.LLC0), %o0\n        mov     %o5, %o1\n        call    printf, 0\n         nop\n        ld      [%fp+68], %o0\n        call    foo, 0\n         nop\n        mov     %o0, %g1\n        mov     %g1, %i0\n        ret\n        restore\n        .size   main, .-main\n        .ident  \"GCC: (GNU) 3.4.3 (csl-sol210-3_4-branch+sol_rpath)\"\n</code></pre>\nI'll concentrate on modifying the result of <pre><code>foo()</code></pre>, so I won't repeat all of the assembly code again but instead only bits and pieces.\nbtw: GCC created the extra indentation for the <pre><code>nop</code></pre> instructions, but it makes it easy to spot them, of course.\nSteps to get from C to executable with tinkering involved\nHere are the steps to get to the modified program.\n\nuse <pre><code>gcc -S test.c</code></pre> to get a <pre><code>test.s</code></pre> file\nmodify the <pre><code>test.s</code></pre>\nAssemble it with <pre><code>gas -o test.o test.s</code></pre>\nLink with GCC using <pre><code>gcc -o test test.o</code></pre>\n\nModifications to the assembly code\nFirst, I felt compelled to \"optimize\" the instructions in <pre><code>LL6</code></pre>, <pre><code>LL9</code></pre>, <pre><code>LL5</code></pre>, <pre><code>LL8</code></pre>, <pre><code>LL11</code></pre> and <pre><code>LL1</code></pre> like this:\n<pre><code>.LL6:\n        mov     3, %i0\n        b       .LL1\n         nop\n.LL9:\n        mov     -1, %i0\n        b       .LL1\n         nop\n.LL5:\n        mov     1, %i0\n        b       .LL1\n         nop\n.LL8:\n        mov     2, %i0\n        b       .LL1\n         nop\n.LL11:\n        mov     4, %i0\n.LL1:\n        ret\n        restore\n</code></pre>\nIt should be clear that if your colleague is right, we should be able to substitute the <pre><code>nop</code></pre> instructions for a <pre><code>mov ..., %i0</code></pre> to see something other than the expected value.\nI called my modified assembly file <pre><code>modified.s</code></pre> so as to not confuse myself ;)\nVerifying my \"optimizations\"\nFirst test is with my \"optimizations only\". I wrote a little test script:\n<pre><code>#!/usr/bin/env bash\nfor i in optimized test; do\n        echo -n \"$i: \"; ./$i\n        echo -n \"$i: \"; ./$i a1\n        echo -n \"$i: \"; ./$i a1 a2\n        echo -n \"$i: \"; ./$i a1 a2 a3\ndone\n</code></pre>\nThe binaries are called <pre><code>optimized</code></pre> (my \"optimizations\" from above) and <pre><code>test</code></pre> (plain assembly created by GCC from C code).\nResults:\n<pre><code>$ ./runtest\noptimized: Hello world: 1\noptimized: Hello world: 3\noptimized: Hello world: 4\noptimized: Hello world: 2\ntest: Hello world: 1\ntest: Hello world: 3\ntest: Hello world: 4\ntest: Hello world: 2\n</code></pre>\nSo my \"optimizations\" seem to be just fine. Now let's tinker a little.\nTinkering with the instructions which modify the program counter\nThe claim is that anything past a <pre><code>jmp</code></pre> (i.e. <pre><code>b</code></pre>) will get executed before the jump itself. We have several labels with jumps, so let's replace the <pre><code>nop</code></pre> in each with something that changes the value inside <pre><code>%i0</code></pre> and thus the return value of <pre><code>foo()</code></pre>.\nThe changes:\n<pre><code>.LL6:\n        mov     3, %i0\n        b       .LL1\n        mov     30, %i0\n.LL9:\n        mov     -1, %i0\n        b       .LL1\n        mov     42, %i0\n.LL5:\n        mov     1, %i0\n        b       .LL1\n        mov     10, %i0\n.LL8:\n        mov     2, %i0\n        b       .LL1\n        mov     20, %i0\n.LL11:\n        mov     4, %i0\n.LL1:\n        ret\n        restore\n</code></pre>\nSo except for return code <pre><code>-1</code></pre> (which becomes <pre><code>42</code></pre>) and <pre><code>4</code></pre> (which stays the same) everything should now return the original value times ten.\nLet's see the results (I added <pre><code>modified</code></pre> to the list of items in my <pre><code>for</code></pre> loop):\n<pre><code>$ ./runtest\noptimized: Hello world: 1\noptimized: Hello world: 3\noptimized: Hello world: 4\noptimized: Hello world: 2\ntest: Hello world: 1\ntest: Hello world: 3\ntest: Hello world: 4\ntest: Hello world: 2\nmodified: Hello world: 10\nmodified: Hello world: 30\nmodified: Hello world: 4\nmodified: Hello world: 20\n</code></pre>\nA change that is as close to your example as I can get it\n<pre><code>        mov     39, %i0\n        jmp     %g1\n        b       .LL11\n        b       .LL1\n.LL6:\n        mov     37, %i0\n        b       .LL1\n        mov     30, %i0\n[...]\n.LL11:\n        mov     4, %i0\n.LL1:\n        ret\n        restore\n</code></pre>\nAmending the test script, here's the output:\n<pre><code>$ ./runtest\noptimized: Hello world: 1\noptimized: Hello world: 3\noptimized: Hello world: 4\noptimized: Hello world: 2\ntest: Hello world: 1\ntest: Hello world: 3\ntest: Hello world: 4\ntest: Hello world: 2\nmodified: Hello world: 10\nmodified: Hello world: 30\nmodified: Hello world: 4\nmodified: Hello world: 20\nquestion: Hello world: 4\nquestion: Hello world: 4\nquestion: Hello world: 4\nquestion: Hello world: 4\n</code></pre>\nBaffling!\nResult\nYou can play tricks on the reverse engineer's mind with this - no doubt. I learned something new and that alone was worth it.\nHere's the situation\n<pre><code>jmp     %g1\nb       .LL11 ; <-- this is the branch taken\nb       .LL1\nmov     37, %i0 ; <-- but this gets executed first (at least in GDB)\n</code></pre>\nNow I don't know whether this is true for all SPARC machines, but certainly for the one I was using for my tests (specs at the top)\nConclusion\nYes, this can certainly be used to trick the unwitting reverse engineer and perhaps the disassembler (static analysis tool). It's basically an opaque predicate. I.e. the outcome is clear at compile time, but it looks like it's dynamic.\nIt's difficult to see how good different disassemblers cope, given that I only have IDA Pro and <pre><code>objdump</code></pre> available here. My educated guess would be that they cope the same as with other opaque predicates, i.e. sometimes they'll get fooled, sometimes they'll be surprisingly smart. So whether or not this is a suitable obfuscation method remains unsolved.\nBonus information\nAs opposed to prior to the edit, IDA seems to be mildly confused by the new code, watch this graph view:\n\nclick here for full size image (previous version)\nLittle GDB session\n<pre><code>0x106CC</code></pre> is the <pre><code>mov 39, %i0</code></pre> instruction, found via IDA.\n<pre><code>$ gdb -q ./question\n(no debugging symbols found)\n(gdb) b *0x106CC\nBreakpoint 1 at 0x106cc\n(gdb) run a1\nStarting program: /export/home/builder/test/question a1\n[New LWP 1]\n[New LWP 2]\n[LWP 2 exited]\n[New LWP 2]\n(no debugging symbols found)\n(no debugging symbols found)\n\nBreakpoint 1, 0x000106cc in foo ()\n(gdb) disp/i $pc\n1: x/i $pc\n0x106cc <foo+44>:       mov  0x27, %i0\n(gdb) si\n0x000106d0 in foo ()\n1: x/i $pc\n0x106d0 <foo+48>:       jmp  %g1\n0x106d4 <foo+52>:       b  0x1070c <foo+108>\n0x106d8 <foo+56>:       b  0x10710 <foo+112>\n0x106dc <foo+60>:       mov  0x25, %i0\n(gdb)\n0x000106d4 in foo ()\n1: x/i $pc\n0x106d4 <foo+52>:       b  0x1070c <foo+108>\n0x106d8 <foo+56>:       b  0x10710 <foo+112>\n0x106dc <foo+60>:       mov  0x25, %i0\n(gdb)\n0x000106dc in foo ()\n1: x/i $pc\n0x106dc <foo+60>:       mov  0x25, %i0\n(gdb)\n0x0001070c in foo ()\n1: x/i $pc\n0x1070c <foo+108>:      mov  4, %i0\n(gdb)\n0x00010710 in foo ()\n1: x/i $pc\n0x10710 <foo+112>:      ret\n0x10714 <foo+116>:      restore\n(gdb)\n</code></pre>\nSo according to GDB we are executing the <pre><code>mov 37, %i0</code></pre> before the branching. This seems to suggest to me that even when you chain multiple branch instructions, the first thing to be executed is whatever comes after the last one in the chain.\n",
            "votes": "8",
            "user": "perror",
            "time": "Apr 30, 2013 at 7:37",
            "is_accepted": true,
            "comments": [
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">@perror: concerning your edit (thanks!), have a <a href=\"http://userscripts.org/scripts/show/111973\" rel=\"nofollow noreferrer\">look at this user script</a>, I've been using it for a while now.</span>",
                    "time": null
                },
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">You compare this to an <i>opaque predicate</i>, but it only fuzz the structure of the CFG. I don't think it breaks the analyzer at a semantic level (except if you do not know what a <code>jmp</code> is suppose to do in SPARC). Or maybe I did miss something ?</span>",
                    "time": null
                }
            ]
        }
    ]
}