{
    "title": "What triggers RIP_EVENT?",
    "link": "https://reverseengineering.stackexchange.com/questions/31965/what-triggers-rip-event",
    "content": "The documentation for the Windows Debugger API mentions a debug event called RIP_EVENT. It offers little explanation of what a RIP_EVENT is, only stating that the structure \"contains the error that caused the RIP debug event.\" In my own debugger, I have never encountered this event, so I am uncertain how to handle it.\nThere are precious little resources online explaining what the event is. This blog is as confused as I am:\n\nI find very few documents about this event, only mentioned with words\nlike system error or internal error. So I decide to print a error\nmessage and skip it. As my project is not fully tested, I have never\nencountered such a situation.\n\nThe Writing A Debugger CodeProject claims the event \"occurs if your process being debugged dies unexpectedly.\" Similarly, this OALabs video states that the RIP_EVENT occurs if the process doesn't exit gracefully.\nThis seems to be the general consensus amongst the few resources I can find. The problem is, of all the ways I can conceive of to kill a process in unexpected fashion, none of them trigger a RIP_EVENT. Last Chance Exceptions trigger a DEBUG_EVENT, eventually followed by an EXIT_PROCESS_DEBUG_EVENT, instead. If anything, I would expect that terminating the process in Task Manager wouldn't be considered a \"graceful exit,\" but it too triggers an EXIT_PROCESS_DEBUG_EVENT, not a RIP_EVENT. This makes me wonder if the event is even associated with process termination at all, or if that's just a confident assumption based on the name \"RIP.\"\nI'm left to speculate why I've never seen this event before and in what scenario it could potentially arise:\n\nAssuming a RIP_EVENT does occur when the process dies somehow, does\nthe RIP_EVENT replace the EXIT_PROCESS_DEBUG_EVENT, or can I expect\nto receive both events?\nHow do popular debuggers like Visual Studio or WinDbg handle the\nRIP_EVENT? What is the correct way to handle one? Do I even need to\ndo anything if I receive one?\nDoes the \"RIP\" in RIP_EVENT refer to the instruction pointer in x64?\nWould that imply it is exclusive to x64 and never occurs for x86? Or\nperhaps it is for some other CPU architecture I don't care about?\nDoes it occur when connection is lost while debugging a remote\nprocess? This is another scenario I thought might cause it, but it'd\nbe difficult for me to test.\n\nUpdate: I began digging even further into this, because I wasn't satisfied with the guesses so far, and found something interesting. There is an export of USER32 called SetDebugErrorLevel. There is no official documentation for it that I can find, but if this source is to be believed, it would make a lot of sense.\n\nThe SetDebugErrorLevel function sets the minimum error level at which\nWindows will generate debugging events and pass them to a debugger.\nParameters\ndwLevel Specifies the minimum error level for debugging events. If an error is equal to or above this level, Windows generates a\ndebugging event. This parameter must be one of the following values:\nValue: 0\nMeaning: Does not report any errors. This value is the default error level.\nValue: SLE_ERROR\nMeaning: Reports only ERROR level debugging events.\nValue: SLE_MINORERROR\nMeaning: Reports only MINORERROR level and ERROR level debugging events.\nValue: SLE_WARNING\nMeaning: Reports WARNING level, MINORERROR level, and ERROR level debugging events.\n\nParticularly because the RIP_INFO structure contains a dwType field with these same values, I think it is likely that RIP_EVENT was intended to be thrown as a part of this mechanism. The thing is, SetDebugErrorLevel - although it exists in USER32 - does nothing. Looking at the disassembly reveals it simply returns immediately. Furthermore, these types were clearly intended to be specified in calls to SetLastErrorEx, though it too goes unused, as the documentation explains:\n\nCurrently, this function is identical to the SetLastError function.\nThe second parameter is ignored.\n\n...with the second, unused parameter being dwType, which was probably meant to take in the SLE_ERROR, SLE_MINORERROR, and SLE_WARNING types (with \"SLE\" standing for SetLastError.) From this, I infer that RIP_EVENT was probably intended to be thrown whenever SetLastErrorEx was used to set a new error level, but this feature has been abandoned. This is my best theory, but it is still only a guess, as the documentation never goes so far as to explicitly state this.\n",
    "votes": "2",
    "answers": 1,
    "views": "214",
    "tags": [
        "windows",
        "debugging",
        "x86"
    ],
    "user": "tomysshadow",
    "time": "Jun 14, 2023 at 3:17",
    "comments": [],
    "answers_data": [
        {
            "content": "AFAIK you're not supposed to handle it and I doubt you reasonably could. The sources you cite are right about what RIP means in this context.\nThis event occurs in response to a <pre><code>DBG_RIPEXCEPTION</code></pre> (== <pre><code>((NTSTATUS)0x40010007L)</code></pre>; see <pre><code>ntstatus.h</code></pre>). The message for this status code is \"Debugger received RIP exception.\" (not helpful ;)) and a corresponding Win32 error code exists by the name <pre><code>ERROR_DBG_RIPEXCEPTION</code></pre> (== <pre><code>695L</code></pre>; see <pre><code>winerror.h</code></pre>, same message text).\nArguably you could synthesize this event by calling <pre><code>RaiseException</code></pre> with the <pre><code>DBG_RIPEXCEPTION</code></pre> code. You could then play with passing different arguments and filling the data and seeing what carries over into the debugger.\nI, too, am not aware of anything that raises that specific code, but be it cosmic rays or anything else, it seems to signal the sudden and unexpected \"death\" of a process out of the ordinary.\n\n\nAssuming a RIP_EVENT does occur when the process dies somehow, does the RIP_EVENT replace the EXIT_PROCESS_DEBUG_EVENT, or can I expect to receive both events?\n\nFrom what I gather, you can expect both. They signify different circumstances, however. <pre><code>RIP_EVENT</code></pre> seems to be purely about the sudden and unexpected \"death\" of a process, not other ways of the process exiting (and the OS getting to clean up after it). One guess would be that this could get synthesized on the client in remote debugging scenarios.\n\nHow do popular debuggers like Visual Studio or WinDbg handle the RIP_EVENT?\n\nI think they don't. That event is supposed to be the exception to the exception, so to speak.\n\nWhat is the correct way to handle one? Do I even need to do anything if I receive one?\n\nAs noted above, I think you're not supposed to care about it. At most log it (to notify the user).\n\nDoes the \"RIP\" in RIP_EVENT refer to the instruction pointer in x64? Would that imply it is exclusive to x64 and never occurs for x86? Or perhaps it is for some other CPU architecture I don't care about?\n\nNope it's not about the instruction pointer in x64. It predates x64.\n\nDoes it occur when connection is lost while debugging a remote process? This is another scenario I thought might cause it, but it'd be difficult for me to test.\n\nSeems like we came to the same conclusion with this one.\nHowever, I'd like to offer another option: <pre><code>RIP_EVENT</code></pre> could be a remnant and no longer applicable to modern Windows. NT has a long history and it could well be something that was dropped along the way ... for all we know it could originate from something that relates to OS/2 and Microsoft's/IBM's collaboration before they parted ways. This is just a guess, too. But it would explain the absence of information. It could also be something that was introduced from the Win32s lineage (Windows 9x/Me) and subsequently dropped. Remember that NT 4.0 took up the desktop look&feel from Windows 95 at the time.\nUnless you're working for Microsoft and have access to internal documentation, source code history and some of the original developers, I don't think you'll get much more info than what you found already.\n",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "Jun 13, 2023 at 8:39",
            "is_accepted": true,
            "comments": []
        }
    ]
}