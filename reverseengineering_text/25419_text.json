{
    "title": "Attempting to reverse engineer an iOS OTA payload-like archival format",
    "link": "https://reverseengineering.stackexchange.com/questions/25419/attempting-to-reverse-engineer-an-ios-ota-payload-like-archival-format",
    "content": "Apple's announcement of macOS Big Sur had meant the release of the developer beta. In an attempt to create the appbundle from Apple's <pre><code>softwarecatalog</code></pre>, I attempted to study the contents of <pre><code>InstallAssistant.pkg</code></pre>. In the process, I found <pre><code>pbzx</code></pre> files in the <pre><code>payloadv2</code></pre> directory that mimic Format 3.0 used by iOS for its' OTA updates and the study of that format by Johnathan Levin and attempted to use his <pre><code>ota</code></pre> tool to extract it (which uses the following struct)\n<pre><code>#pragma pack(1)\nstruct entry\n{\n\n    unsigned int usually_0x210_or_0x110;\n    unsigned short  usually_0x00_00; //_00_00;\n    unsigned int  fileSize;\n    unsigned short whatever;\n    unsigned long long timestamp_likely;\n    unsigned short _usually_0x20;\n    unsigned short nameLen;\n    unsigned short uid;\n    unsigned short gid;\n    unsigned short perms;\n    char name[0];\n// Followed by file contents\n};\n\n#pragma pack()\n</code></pre>\nThere was no avail with <pre><code>ota</code></pre> so I resorted to use a slightly modified (in terms of memory improvements) version of his <pre><code>pbzx</code></pre> tool to extract the stream, to success using the bash command given below in the <pre><code>payloadv2</code></pre> directory\n<pre><code>rm *.ecc && find *.??? -exec bash -c \"./pbzx {} >> {}.unpbzx\" \\; && mkdir unpbzx && mv *.unpbzx unpbzx/</code></pre>\nAs a result I now have a directory full of <pre><code>.unpbzx</code></pre> files. Attempting to run <pre><code>ota</code></pre> (with <pre><code>pbzx</code></pre> support removed to eliminate the possibility of potential bugs there) on <pre><code>payload.000.unpbzx</code></pre> results in a Segmentation Fault, <pre><code>gdb</code></pre> returns\n<pre><code>Corrupt entry (0x31414159 at pos 30@0x10100001e).. skipping\n\nThread 2 received signal SIGSEGV, Segmentation fault.\n0x00000001000031b4 in processFile (FileName=0x7ffeefbff74e \"/Volumes/[redacted]/pbzx/payload.000.unpbzx\") at ota.c:423\n423                 while (ent->usually_0x210_or_0x110 != 0x210 && ent->usually_0x210_or_0x110 != 0x110)\n</code></pre>\nRunning it with alternative tools like <pre><code>ota2tar</code></pre> (with <pre><code>pbzx</code></pre> extraction code removed) and forks of <pre><code>ota</code></pre> like <pre><code>iOS-Utilities</code></pre> gave similar errors (out-of-bounds memory errors, etc.)\nIt appears that somehow this <pre><code>unpbzx</code></pre> file has a different header structure to the description of Format 3.0 on the iPhone Wiki\nOpening <pre><code>payload.000.unpbzx</code></pre> with Hex Fiend shows that the file format appears to be differing from the struct given above (singular entry highlighted)\n\nFiles seem to be listed with some form of delimiter <pre><code>YAA1</code></pre> in the beginning. Isolating individual entries gives results similar to the image given below (file name highlighted)\n\nMy knowledge of reverse engineering is admittedly limited so the best I could do is some psudocode about what the struct may look like\n<pre><code>struct entry\n{\n  uint8_t header; // 59414131 (0xYAA1) \n  uint32_t description; // 69005459 50314450 41545030 (iTYP1DPATP)\n  uint8_t padding; // 00\n  // fileNameLen undefined\n  char[fileNameLen] filename; // System/Library/Perl/Extras/5.28/Net/LDAP/Control\n  uint8_t uid; // 55494431 (or 0xUID1)\n  uint8_t padding2; // 00\n  uint8_t descr_end; // 474944 31004D4F 4432ED01 464C4734 00000800 4D544D54\n  // (descr_end includes GID, MOD and FLG values)\n  // file_contents\n}\n</code></pre>\nAs a last ditch attempt, I ran <pre><code>payload.000.unpbzx</code></pre> through 7zip and it identifies the file as a <pre><code>gzip</code></pre> stream\n<pre><code>Path = /Volumes/[redacted]/pbzx/payload.000.unpbzx\nType = gzip\nERRORS:\nThere are data after the end of archive\nOffset = 5636247\nPhysical Size = 98\nTail Size = 12327687\nHeaders Size = 10\nStreams = 1\n\nERROR: There is some data after the end of the payload data : payload.000\n\nSub items Errors: 1\nArchives with Errors: 1\nOpen Errors: 1\n</code></pre>\nBut <pre><code>gunzip</code></pre> does not recognize the format.\nAt this point, what would be the best way of interpreting this new archival structure and how do I proceed forward?\n(Note: Hex Fiend displays <pre><code>000.pbzx</code></pre> because I did actually name the files with the <pre><code>.pbzx</code></pre> extension even though that naming was incorrect and had modified it to <pre><code>.unpbzx</code></pre> for clarity in this question)\n",
    "votes": "2",
    "answers": 2,
    "views": "828",
    "tags": [
        "file-format",
        "ios",
        "osx"
    ],
    "user": "Kittywhiskers Van Gogh",
    "time": "Jun 29, 2020 at 11:53",
    "comments": [],
    "answers_data": [
        {
            "content": "<pre><code>YAA</code></pre> is possibly the signature of yaa archives, so try using the <pre><code>yaa</code></pre> utility on those files.\n",
            "votes": "1",
            "user": "Igor Skochinsky",
            "time": "Jun 29, 2020 at 19:32",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Kittywhiskers Van Gogh",
                    "text": "<span class=\"comment-copy\">Never heard of the <code>yaa</code> format before, searching for the magic number yielded nothing on Google. Some files seem to be extracted but eventually it reaches <code>YP1DPATP | Error 0x8704c800 | Invalid header | 96504 entries failed to extract</code>. Using the graphical utility, I get a more generic <code>Error 32 - Broken Pipe</code> (and attempting to run it on the non-concat'ed archive gives a familiar <code>Operation Not Permitted</code>). The article detailing use is <a href=\"https://developer.apple.com/forums/thread/133985\" rel=\"nofollow noreferrer\">only two weeks old</a>. <b>+1 for showing the way :)</b></span>",
                    "time": null
                }
            ]
        },
        {
            "content": "See: http://newosxbook.com/articles/OTA8.html\n(and prior episodes)\n<pre><code>#include <stdio.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <unistd.h>\n#define _GNU_SOURCE 1 \n#include <string.h>\n\n#include <sys/stat.h> // for mkdir\n#include <sys/mman.h> // for mmap\n\n#undef ntohl\n#undef ntohs\n\n\n\n#define RED     \"\\033[0;31m\"\n#define M0      \"\\e[0;30m\"\n#define CYAN    \"\\e[0;36m\"\n#define M1      \"\\e[0;31m\"\n#define GREY    \"\\e[0;37m\"\n#define M8      \"\\e[0;38m\"\n#define M9      \"\\e[0;39m\"\n#define GREEN   \"\\e[0;32m\"\n#define YELLOW  \"\\e[0;33m\"\n#define BLUE    \"\\e[0;34m\"\n#define PINK    \"\\e[0;35m\"\n#define NORMAL  \"\\e[0;0m\"\n\n#ifdef LINUX\ntypedef unsigned long uint64_t;\ntypedef unsigned short uint16_t;\nextern void *memmem (const void *__haystack, size_t __haystacklen,\n                     const void *__needle, size_t __needlelen);\n\n\n#endif\n/**\n *  Apple iOS OTA/PBZX expander/unpacker/lister/searcher - by Jonathan Levin,\n *\n *  http://NewOSXBook.com/\n *  \n *  Free for anyone (AISE) to use, modify, etc. I won't complain :-), but I'd appreciate a mention\n *\n * Changelog: 02/08/16 - Replaced alloca with malloc () (full OTAs with too many files would have popped stack..)\n *\n *            02/17/16 - Increased tolerance for corrupt OTA - can now seek to entry in a file\n *\n *            08/31/16 - Added search in OTA.\n * \n *            02/28/18 - It's been a while - and ota now does diff!\n *                       Also tidied up and made neater\n *\n *            12/03/18 - Added -S to search for string null terminated\n *\n *            The last OTA: (seriously, I'm done :-)\n *\n *        08/06/19 - Integrated @S1guza's symlink fix (Thanks, man!)\n *                       Added pbzx built-in so you don't have to use pbzx first\n *                       Added multiple file processing, compatible with shell expansion\n *                         Can now ota ...whatever... payload.0?? to iterate over all files!\n *                       Added -H to generate SHA-1 hashes for all ('*') or specific files in OTA\n *             (SHA-1 code taken from public domain, as was lzma)\n *\n *  To compile: now use attached makefile, since there are lzma dependencies\n *          Remember to add '-DLINUX' if on Linux\n *\n *\n */\ntypedef     unsigned int    uint32_t;\nuint64_t pos = 0;\n\n\n#ifndef NOSHA\n#include \"sha1.c\"\n#endif // NOSHA\n#pragma pack(1)\nstruct entry\n{\n \n unsigned int usually_0x210_or_0x110;\n unsigned short  usually_0x00_00; //_00_00;\n unsigned int  fileSize;\n unsigned short whatever;\n unsigned long long timestamp_likely;\n unsigned short _usually_0x20;\n unsigned short nameLen;\n unsigned short uid;\n unsigned short gid;\n unsigned short perms;\n char name[0];\n // Followed by file contents\n};\n\n#pragma pack()\n\nextern int ntohl(int);\nextern short ntohs(short);\nuint32_t    \nswap32(uint32_t arg)\n{\nreturn (ntohl(arg));\n}\n\nint g_list = 0;\nint g_verbose = 0;\nchar *g_extract = NULL;\nchar *g_search = NULL;\nchar *g_hash = NULL;\nint g_nullTerm = 0;\n\n\n\n// Since I now diff and use open->mmap(2) on several occasions, refactored \n// into its own function\n//\nvoid *mmapFile(char *FileName, uint64_t *FileSize)\n{\n\n    int fd = open (FileName, O_RDONLY);\n    if (fd < 0) { perror (FileName); exit(1);}\n\n    // 02/17/2016 - mmap\n    \n    struct stat stbuf;\n    int rc = fstat(fd, &stbuf);\n\n    char *mmapped =  mmap(NULL, // void *addr,\n                  stbuf.st_size ,   // size_t len, \n                  PROT_READ,        // int prot,\n                  MAP_PRIVATE,                //  int flags,\n                  fd,               // int fd, \n                  0);               // off_t offset);\n\n\n    if (mmapped == MAP_FAILED)  { perror (FileName); exit(1);}\n\n    if (FileSize) *FileSize = stbuf.st_size;\n\n    close (fd);\n    return (mmapped);\n}\n\n\nvoid hashFile (char *File, char *Name, uint32_t Size, short Perms, char *HashCriteria)\n{\n\n    if (!HashCriteria) return;\n\n    if ((HashCriteria[0] != '*') && ! strstr(Name, HashCriteria)) return ;\n    \n#define HASH_SIZE   20\n\n    uint8_t Message_Digest[SHA1HashSize];\n\n    doSHA1((void*)File, Size, Message_Digest);\n\n\n\n    int i = 0;\n    printf(\"%s (%d bytes): \", Name, Size);\n    for (i = 0; i < HASH_SIZE; i++)\n    {\n        printf(\"%02X\", Message_Digest[i]);\n    }\n\n    printf(\"\n\");\n\n}\n\nvoid \nextractFile (char *File, char *Name, uint32_t Size, short Perms, char *ExtractCriteria)\n{\n    // MAYBE extract file (depending if matches Criteria, or \"*\").\n    // You can modify this to include regexps, case sensitivity, what not. \n    // presently, it's just strstr()\n\n\n    if (!ExtractCriteria) return;\n    if ((ExtractCriteria[0] != '*') && ! strstr(Name, ExtractCriteria)) return;\n    \n\n    uint16_t type = Perms & S_IFMT;\n        Perms &= ~S_IFMT;\n        if(type != S_IFREG && type != S_IFLNK)\n        {\n            fprintf(stderr, \"Unknown file type: %o\n\", type);\n                // return;\n        }\n\n    // Ok. Extract . This is simple - just dump the file contents to its directory.\n    // What we need to do here is parse the '/' and mkdir(2), etc.\n    \n    char *dirSep = strchr (Name, '/');\n    while (dirSep)\n    {\n        *dirSep = '\\0';\n        mkdir(Name,0755);\n        *dirSep = '/';\n        dirSep+=1;\n        dirSep = strchr (dirSep, '/');\n    }\n\n    if(type == S_IFLNK) \n    {\n    /* @s1guza's support for symlinks! */\n    /* http://newosxbook.com/forum/viewtopic.php?f=3&t=19513 */\n        char *target = strndup(File, Size);\n        if(g_verbose) \n        {\n            fprintf(stderr, \"Symlinking %s to %s\n\", Name, target);\n        }\n        symlink(target, Name);\n        fchmodat(AT_FDCWD, Name, Perms, AT_SYMLINK_NOFOLLOW);\n        free(target);\n    }\n\n    else  {\n    // at this point we're out of '/'s\n    // go back to the last /, if any\n    \n    if (g_verbose)\n    {\n        fprintf(stderr, \"Dumping %d bytes to %s\n\", Size, Name);\n    }\n    int fd = open (Name, O_WRONLY| O_CREAT);\n    fchmod (fd, Perms);\n    write (fd, File, Size);\n    close (fd);\n\n    }\n\n} //  end extractFile\n\nvoid showPos()\n{\n    fprintf(stderr, \"POS is %lld\n\", pos);\n}\n\nstruct entry *getNextEnt (char *Mapping, uint64_t Size, uint64_t *Pos)\n{\n    // Return entry at Mapping[Pos],\n    // and advance Pos to point to next one\n\n    int pos = 0;\n    struct entry *ent =(struct entry *) (Mapping + *Pos );\n\n    if (*Pos > Size) return (NULL);\n    *Pos += sizeof(struct entry);\n    \n    uint32_t entsize = swap32(ent->fileSize);\n    uint32_t nameLen = ntohs(ent->nameLen);\n        // Get Name (immediately after the entry)\n        //char *name = malloc (nameLen+1);\n        // strncpy(name, Mapping+ *Pos , nameLen);\n        //name[nameLen] = '\\0';\n    //printf(\"NAME %p IS %s, Size: %d\n\", Mapping, name, entsize);\n    //free (name);\n    *Pos += nameLen;\n    *Pos += entsize;\n\n    return (ent);\n\n} // getNextEnt\n\n\nint doDiff (char *File1, char *File2, int Exists)\n{\n\n    // There are two ways to do diff:\n    // look at both files as archives, find diffs, then figure out diff'ing entry,\n    // or look at file internal entries individually, then compare each of them\n    // I chose the latter. This also (to some extent) survives file ordering\n\n    // Note I'm still mmap(2)ing BOTH files. This contributes to speed, but does\n    // have the impact of consuming lots o'RAM. That said, this is to be run on a \n    // Linux/MacOS, and not on an i-Device, so we should be ok.\n\n    uint64_t file1Size = 0;\n\n    char *file1Mapping = mmapFile(File1, &file1Size);\n    uint64_t file2Size = 0;\n    char *file2Mapping = mmapFile(File2, &file2Size);\n\n\n    uint64_t file1pos = 0;\n    uint64_t file2pos = 0;\n\n    struct entry *file1ent = getNextEnt (file1Mapping, file1Size, &file1pos);\n    struct entry *file2ent  = getNextEnt (file2Mapping,file2Size, &file2pos);\n\n    uint64_t lastFile1pos, lastFile2pos = 0;\n\n    while (file1ent && file2ent) {\n        \n        lastFile1pos = file1pos;\n        lastFile2pos = file2pos;\n\n        file1ent = getNextEnt (file1Mapping, file1Size, &file1pos);\n        file2ent = getNextEnt (file2Mapping,file2Size, &file2pos);\n        \n        char *ent1Name = file1ent->name;\n        char *ent2Name = file2ent->name;\n\n        // Because I'm lazy: skip last entry\n        if (file1pos > file1Size - 1000000) break;\n\n        int found = 1;\n\n        char *n1 = strndup(file1ent->name, ntohs(file1ent->nameLen));\n        if (strncmp(ent1Name, ent2Name, ntohs(file1ent->nameLen)))\n            {\n                // Stupid names aren't NULL terminated (AAPL don't read my comments,\n                // apparently), so we have to copy both names in:\n\n                // But that's the least of our problems: We don't know if n1 has been removed\n                // from n2, or n2 is a new addition:\n                uint64_t seekpos = file2pos;    \n                // seek n1 in file2:\n\n                found = 0;\n                int i = 0;\n\n                struct entry *seek2ent;\n                while (1) {\n                    seek2ent = getNextEnt (file2Mapping,file2Size, &seekpos);\n                    \n                    if (!seek2ent) { break; } // {printf(\"EOF\n\");break;}\n\n                    if (memcmp(seek2ent->name,file1ent->name, ntohs(seek2ent->nameLen)) == 0) {\n                \n                        found++; break;\n                    }\n                    else {\n/*\n                        i++;\n                        if (i < 200) {\n                        char *n2 = strndup(seek2ent->name, ntohs(seek2ent->nameLen));\n\n                        printf(\"check: %s(%d) != %s(%d) -- %d\n\",n2, ntohs(seek2ent->nameLen),n1, strlen(n1),\n                    memcmp(seek2ent->name,file1ent->name, ntohs(seek2ent->nameLen) ));\n                        free(n2);\n\n                        }\n*/\n                      }\n                } // end while\n                \n                if (!found) { \n                        printf(\"%s: In file1 but not file2\n\", n1);\n                        // rewind file2pos so we hit the entry again..\n                        file2pos = lastFile2pos;\n                        }\n                else {\n                        // Found it - align (all the rest to this point were not in file1)\n                        file2pos = seekpos;\n                    }\n\n\n            } // name mismatch\n\n        if (found) {\n            // Identical entries - check for diffs unless we're only doing existence checks\n\n            // if the sizes diff, obviously:\n            \n            if (!Exists) {\n            if (file1pos - lastFile1pos != file2pos - lastFile2pos)\n                { fprintf(stdout,\"%s (different sizes)\n\", n1); }\n            else\n                // if sizes are identical, maybe - but ignore timestamp!\n            if (memcmp (((unsigned char *)file1ent) + sizeof(struct entry), \n                    ((unsigned char *)file2ent) + sizeof(struct entry), file1pos - lastFile1pos - sizeof(struct entry)))\n            { fprintf(stdout,\"%s\n\", n1); }\n\n            }\n        free (n1);\n        }\n\n    } // end file1pos\n    return 0;\n    \n\n}\n\nvoid processFile(char *fileName);\n\nint \nmain(int argc ,char **argv)\n{\n\n    char *filename =\"p\";\n    int i = 0;\n\n    if (argc < 2) {\n        fprintf (stderr,\"Usage: %s [-v] [-l] [...] _filename[s]_ \nWhere: -l: list files in update payload\n\"\n                \"Where: [...] is one of:\n\"\n                \"       -e _file: extract file from update payload (use \\\"*\\\" for all files)\n\"\n                \"       -s _string _file: Look for occurences of _string_ in file\n\" \n                \"       -S _string _file: Look for occurences of _string_, NULL terminated in file\n\" \n                \"       -H [_file]: get hash digest of specific file (use \\\"*\\\" for all files)\n\"\n                \"       [-n] -d _file1 _file2: Point out differences between OTA _file1 and _file2\n\"\n                \"                              -n to only diff names\n\", argv[0]);\n        exit(10);\n        }\n    \n    int exists = 0;\n\n    for (i = 1;\n         (i < argc -1) && (argv[i][0] == '-');\n         i++)\n        {\n        // This is super quick/dirty. You might want to rewrite with getopt, etc..\n        \n        if (strcmp(argv[i], \"-n\") == 0) {\n                    exists++;\n            }\n        else\n        if (strcmp (argv[i] , \"-d\") == 0) { \n          // make sure we have argv[i+1] and argv[i+2]...\n\n          if (i != argc - 3)\n            {\n                fprintf(stderr,\"-d needs exactly two arguments - two OTA files to compare\n\");\n                exit(6);\n            }\n\n          // that the files exist...\n          if (access (argv[i+1], F_OK)) { fprintf(stderr,\"%s: not a file\n\", argv[i+1]); exit(11); }      \n          if (access (argv[i+2], F_OK)) { fprintf(stderr,\"%s: not a file\n\", argv[i+2]); exit(12); }      \n        \n          // then do diff\n          return ( doDiff (argv[i+1],argv[i+2], exists));\n    \n        }\n        else\n        if (strcmp (argv[i], \"-l\") == 0) { g_list++;} \n        else\n        if (strcmp (argv[i] , \"-v\") == 0) { g_verbose++;}\n#ifndef NOSHA\n        else\n        if (strcmp(argv[i], \"-H\") == 0) {\n            if (i == argc -1) { fprintf(stderr, \"-H: Option requires an argument (what to extract)\n\");\n                        exit(5); }\n\n            g_hash = argv[i+1]; i++;\n\n        }\n#endif\n        else\n        if (strcmp (argv[i], \"-e\") == 0) { \n            if (i == argc -1) { fprintf(stderr, \"-e: Option requires an argument (what to extract)\n\");\n                        exit(5); }\n\n            g_extract = argv[i+1]; i++;\n\n        }\n\n        // Added 08/31/16:\n        // and modified 12/01/2018\n        else\n        if ((strcmp (argv[i], \"-s\") == 0) || (strcmp (argv[i], \"-S\") == 0))  { \n            if (i == argc - 2) { fprintf(stderr, \"%s: Option requires an argument (search string)\n\", argv[i]);\n                        exit(5); }\n            g_search = argv[i+1];\n            if (argv[i][1] == 'S') g_nullTerm++;\n            i++;     \n            }\n        else {\n            fprintf(stderr,\"Unknown option: %s\n\", argv[i]);\n            return 1;\n            }\n\n        \n            \n\n        }\n    \n\n    // Another little fix if user forgot filename, rather than try to open\n    if (argv[argc-1][0] == '-') {\n        fprintf(stderr,\"Must supply filename\n\"); exit(5);\n    }\n\n    \n    // Loop over filenames:\n\n    for (; i < argc; i++) \n    {\n        if (strstr(argv[i],\".ecc\")) continue;\n         processFile(argv[i]);\n    }\n\n}\n\n#define PBZX_MAGIC  \"pbzx\"\n\n\nchar *doPBZX (char *pbzxData, int Size, int *ExtractedSize) {\n\n#ifndef NO_PBZX\n#define OUT_BUFSIZE     16*1024*1024 // Largest chunk I've seen is 8MB. This is double that.\nchar *  decompressXZChunk(char *buf, int size, char *Into, int *IntoSize);\n\n\n    \n    uint64_t length = 0, flags = 0;\n\n   \n    char *returned = malloc(OUT_BUFSIZE);\n    int returnedSize = OUT_BUFSIZE;\n    int available = returnedSize;\n\n    int pos = strlen(PBZX_MAGIC);\n    flags = *((uint64_t *) pbzxData + pos);\n\n    // read (fd, &flags, sizeof (uint64_t));\n    pos += sizeof(uint64_t);\n\n    flags = __builtin_bswap64(flags);\n\n\n   // fprintf(stderr,\"Flags: 0x%llx\n\", flags);\n\n    int i = 0;\n    int off = 0;\n\n    int warn = 0 ;\n    int skipChunk = 0;\n\n    \n    int rc = 0;\n    // 03/09/2016 - Fixed for single chunks (payload.0##) files, e.g. WatchOS\n    //              and for multiple chunks. AAPL changed flags on me..\n    //\n    // New OTAs use 0x800000 for more chunks, not 0x01000000.\n\n    // 08/06/2019 - dang it. it's not flags - it's uncomp chunk size.\n\n    uint64_t totalSize = 0;\n    uint64_t uncompLen = flags;\n    while (pos < Size){\n    i++;\n    //printf(\"FLAGS: %llx\n\", flags);\n    // rc= read (fd, &flags, sizeof (uint64_t)); // check retval..\n    flags = *((uint64_t *) (pbzxData +pos));\n    pos+= sizeof(uint64_t);\n    flags = __builtin_bswap64(flags);\n    //printf(\"FLAGS: %llx\n\", flags);\n\n    length = *((uint64_t *) (pbzxData +pos));\n    //rc = read (fd, &length, sizeof (uint64_t));\n    pos+= sizeof(uint64_t);\n    length = __builtin_bswap64(length);\n\n    skipChunk = 0; // (i < minChunk);\n    if (getenv(\"JDEBUG\") != NULL) fprintf(stderr,\"Chunk #%d (uncomp: %lld, comp length: %lld bytes) %s\n\",i, flags,length, skipChunk? \"(skipped)\":\"\");\n     \n    // Let's ignore the fact I'm allocating based on user input, etc..\n    //char *buf = malloc (length);\n    //int bytes = read (fd, buf, length);\n\n    char *buf = pbzxData + pos;\n    pos += length;\n// flags = *((uint64_t *) (pbzxData +pos));\n\n#if 0\n    // 6/18/2017 - Fix for WatchOS 4.x OTA wherein the chunks are bigger than what can be read in one operation\n    int bytes = length;\n    int totalBytes = bytes;\n    while (totalBytes < length) {\n        // could be partial read\n        bytes = read (fd, buf +totalBytes, length -totalBytes);\n        totalBytes +=bytes;\n        \n    }   \n#endif\n    \n\n   // We want the XZ header/footer if it's the payload, but prepare_payload doesn't have that, \n    // so just warn.\n    \n    if (memcmp(buf, \"\\xfd\"\"7zXZ\", 6))  { warn++; \n        fprintf (stderr, \"Warning: Can't find XZ header. Instead have 0x%x(?).. This is likely not XZ data.\n\",\n            (* (uint32_t *) buf ));\n\n        // Treat as uncompressed\n        // UNCOMMENT THIS to handle uncomp XZ too..\n        // write (1, buf, length);\n        \n        \n        }\n    else // if we have the header, we had better have a footer, too\n    {\n    if (strncmp(buf + length - 2, \"YZ\", 2)) { warn++; fprintf (stderr, \"Warning: Can't find XZ footer at 0x%llx (instead have %x). This is bad.\n\",\n        (length -2),\n        *((unsigned short *) (buf + length - 2))); \n        }\n//  if (1 && !skipChunk)\n    {\n    // Uncompress chunk\n\n\n    int chunkExpandedSize = available;\n    char *ptrTo = returned + (returnedSize - available);\n    decompressXZChunk(buf, length, returned + (returnedSize - available),&chunkExpandedSize);\n\n    //  printf(\"DECOMPRESSING to %p - %p\n\", ptrTo , ptrTo + chunkExpandedSize);\n    totalSize += chunkExpandedSize;\n    available -= chunkExpandedSize;\n    if (available < OUT_BUFSIZE)\n    {\n        returnedSize += 10 * OUT_BUFSIZE;\n        available +=  10 * OUT_BUFSIZE;\n        // Can't use realloc!\n        char *new = malloc(returnedSize);\n        \n        if (getenv(\"JDEBUG\") != NULL)printf(\"REALLOCING from %p to %p ,%x, AVAIL: %x\n\", returned,  new, returnedSize, available);\n        if (new) {\n         memcpy(new, returned, returnedSize - available);\n         free(returned);\n        returned = new;\n\n        }\n        else { fprintf(stderr,\"ERROR!\n\"); exit(1);}\n    \n    }\n      \n\n    }\n    warn = 0;\n\n    // free (buf);  // Not freeing anymore, @ryandesign :-)\n    }\n\n    }\n    //printf(\"Total size: %d\n\", totalSize);\n    *ExtractedSize = totalSize;\n    if (getenv(\"JDEBUG\") != NULL)\n    {\n    int f = open (\"/tmp/out1\", O_WRONLY |O_CREAT);\n    write (f, returned, totalSize);\n    close(f);\n    }\n    return (returned);\n\n#else\n    fprintf(stderr,\"Not compiled with PBZX support!\n\");\n    return (NULL);\n#endif\n} // pbzx\n\nvoid processFile(char *FileName)\n{\n    int color = (getenv(\"JCOLOR\")!= NULL);\n    fprintf(stderr, \"%sProcessing %s%s\n\", color ? RED: \"\", FileName, color ? NORMAL :\"\");\n\n    //unsigned char buf[4096];\n\n    uint64_t fileSize;\n\n    uint64_t mappedSize;\n    char *actualMmapped = mmapFile(FileName, &mappedSize);\n\n    fileSize = mappedSize;\n\n    if (actualMmapped == MAP_FAILED) { perror (FileName); return ;}\n\n\n\n    char *mmapped = actualMmapped;\n    char *extracted = NULL;\n    // File could be a PBZX :-)\n    if (memcmp(mmapped, PBZX_MAGIC, strlen(PBZX_MAGIC)) ==0)\n    {\n            // DO PBZX first!\n            int extractedSize = 0;\n            extracted = doPBZX (mmapped, mappedSize, &extractedSize);\n            mmapped = extracted;\n            fileSize = extractedSize;\n        \n    //  printf(\"EXTRACTED: %p, size: 0x%llx\n\",mmapped, fileSize);\n\n\n    }\n\n    int i = 0;\n\n    struct entry *ent = alloca (sizeof(struct entry));\n\n    pos = 0;\n    while(pos + 3*sizeof(struct entry) < fileSize) {\n\n    ent = (struct entry *) (mmapped + pos );\n    pos += sizeof(struct entry);\n\n    if ((ent->usually_0x210_or_0x110 != 0x210 && ent->usually_0x210_or_0x110 != 0x110 &&\n        ent->usually_0x210_or_0x110 != 0x310) || \n        ent->usually_0x00_00)\n    {\n        fprintf (stderr,\"Corrupt entry (0x%x at pos %llu@0x%llx).. skipping\n\", ent->usually_0x210_or_0x110,\n            pos, (uint64_t)(mmapped+pos));\n        int skipping = 1;\n\n        while (skipping)\n        {\n           ent = (struct entry *) (mmapped + pos ) ;\n           while (ent->usually_0x210_or_0x110 != 0x210 && ent->usually_0x210_or_0x110 != 0x110)\n           {\n             // #@$#$%$# POS ISN'T ALIGNED!\n             pos ++;\n            ent = (struct entry *) (mmapped + pos ) ;\n           }\n           // read rest of entry\n            int nl = ntohs(ent->nameLen);\n\n            if (ent->usually_0x00_00 || !nl) {\n        //   fprintf(stderr,\"False positive.. skipping %d\n\",pos);\n            pos+=1;\n            \n\n            }\n            else { skipping =0;\n               pos += sizeof(struct entry); }\n            if (pos > fileSize) return;\n        }\n\n    }\n\n    uint32_t    size = swap32(ent->fileSize);\n\n// fprintf(stdout,\" Here - ENT at pos %d: %x and 0 marker is %x namelen: %d, fileSize: %d\n\", pos, ent->usually_0x210_or_0x110, ent->usually_0x00_00, ntohs(ent->nameLen), size);\n\n    uint32_t    nameLen = ntohs(ent->nameLen);\n    // Get Name (immediately after the entry)\n    //\n    // 02/08/2016: Fixed this from alloca() - the Apple jumbo OTAs have so many files in them (THANKS GUYS!!)\n    // that this would exceed the stack limits (could solve with ulimit -s, or also by using\n    // a max buf size and reusing same buf, which would be a lot nicer)\n\n    \n    // Note to AAPL: Life would have been a lot nicer if the name would have been NULL terminated..\n    // What's another byte per every file in a huge file such as this?\n    // char *name = (char *) (mmapped+pos);\n\n    char *name = alloca (nameLen+1);\n\n    strncpy(name, mmapped+pos , nameLen);\n    name[nameLen] = '\\0';\n    //printf(\"NAME IS %s\n\", name);\n\n    pos += ntohs(ent->nameLen);\n    uint32_t    fileSize = swap32(ent->fileSize);\n    uint16_t    perms = ntohs(ent->perms);  \n\n\n    if (g_list){ \n    if (g_verbose) {\n    printf (\"Entry @0x%d: UID: %d GID: %d Mode: %o Size: %d (0x%x) Namelen: %d Name: \", i,\n                            ntohs(ent->uid), ntohs(ent->gid),\n                             perms, size, size,\n                              ntohs(ent->nameLen));\n    }\n    printf (\"%s\n\", name);}\n\n\n    // Get size (immediately after the name)\n    if (fileSize) \n        {\n            if (g_extract) { extractFile(mmapped +pos, name, fileSize, perms, g_extract);}\n            // Added  08/05/19 -  Hash\n            if (g_hash) { hashFile (mmapped +pos, name, fileSize, perms, g_hash); }\n\n    \n            // Added 08/31/16 - And I swear I should have this from the start.\n            // So darn simple and sooooo useful!\n\n            if (g_search){\n    \n                char *found = memmem (mmapped+pos, fileSize, g_search, strlen(g_search) + (g_nullTerm ? 1 : 0));\n                while (found != NULL)\n                {\n                int relOffset = found - mmapped - pos;\n                \n                fprintf(stdout, \"Found in Entry: %s, relative offset: 0x%x (Absolute: %lx)\",\n                    name,\n                    relOffset,\n                    found - mmapped);\n\n                // 12/01/18\n\n                if (g_verbose) {\n\n                fputc(':', stdout);\n                fputc(' ', stdout);\n                   char *begin = found;\n\n                   int i = 0 ;\n#define BACK_LIMIT -20\n#define FRONT_LIMIT 20\n                   while(begin[i] && i > BACK_LIMIT) { i--;}\n                   \n                   for (;begin +i < found; i++) { \n\n                    if (isprint(begin[i])) putc (begin[i], stdout); else putc ('.', stdout); }\n                   printf(\"%s%s%s\",RED, g_search, NORMAL);\n                   for (i+= strlen(g_search); begin[i] &&( i < FRONT_LIMIT); i++) { \n                    if (isprint(begin[i])) putc (begin[i], stdout); else putc ('.', stdout); }\n                                    \n                     \n\n                }\n                fprintf(stdout,\"\n\");\n\n                // keep looking..\n                 found = memmem (found + 1, fileSize - relOffset , g_search, strlen(g_search) +( g_nullTerm ? 1: 0));\n                } // end while\n                \n            } // end g_search\n\n            pos +=fileSize;\n        }\n\n\n\n    \n\n    } // Back to loop\n\n    if (extracted) { /*printf(\"FREEing %p\n\", extracted);*/ free (extracted);}\n    munmap(actualMmapped, mappedSize);\n\n\n    \n}\n\n\n</code></pre>\n",
            "votes": "0",
            "user": "Geoff Nixon",
            "time": "Sep 7, 2021 at 4:35",
            "is_accepted": false,
            "comments": []
        }
    ]
}