{
    "title": "Import Address Table in Process Hollowing",
    "link": "https://reverseengineering.stackexchange.com/questions/26712/import-address-table-in-process-hollowing",
    "content": "I know that the PE loader is the one that is responsible for assigning addresses in a PE Import Address Table, so why when we inject code using process hollowing we don't build the IAT?\nWe just copy all the sections and headers but we don't resolve the addresses in the IAT. I don't understand how it works, does the resolving happens after the injection or something?\n",
    "votes": "2",
    "answers": 1,
    "views": "417",
    "tags": [
        "pe",
        "injection",
        "process",
        "iat"
    ],
    "user": "shon",
    "time": "Jan 5, 2021 at 19:22",
    "comments": [],
    "answers_data": [
        {
            "content": "Obviously you should resolve the address in IAT.\nThis is a manually mapped dll code, you can take a look.\n<pre><code>#include <stdio.h>\n#include <Windows.h>\n#include <intrin.h>\n\ntypedef HMODULE(WINAPI* pLoadLibraryA)(LPCSTR);\ntypedef FARPROC(WINAPI* pGetProcAddress)(HMODULE, LPCSTR);\n\ntypedef BOOL(WINAPI* PDLL_MAIN)(HMODULE, DWORD, PVOID);\n\ntypedef struct _MANUAL_INJECT\n{\n    PVOID ImageBase;\n    PIMAGE_NT_HEADERS NtHeaders;\n    PIMAGE_BASE_RELOCATION BaseRelocation;\n    PIMAGE_IMPORT_DESCRIPTOR ImportDirectory;\n    pLoadLibraryA fnLoadLibraryA;\n    pGetProcAddress fnGetProcAddress;\n}MANUAL_INJECT, * PMANUAL_INJECT;\n\nDWORD WINAPI LoadDll(PVOID p)\n{\n    PMANUAL_INJECT ManualInject;\n\n    HMODULE hModule;\n    INT64 i, Function, count, delta;\n\n    PDWORD ptr;\n    PWORD list;\n\n    PIMAGE_BASE_RELOCATION pIBR;\n    PIMAGE_IMPORT_DESCRIPTOR pIID;\n    PIMAGE_IMPORT_BY_NAME pIBN;\n    PIMAGE_THUNK_DATA FirstThunk, OrigFirstThunk;\n\n    PDLL_MAIN EntryPoint;\n    VOID (*EntryPointNew)(VOID);\n\n    ManualInject = (PMANUAL_INJECT)p;\n\n    pIBR = ManualInject->BaseRelocation;\n    delta = (DWORD)((LPBYTE)ManualInject->ImageBase - ManualInject->NtHeaders->OptionalHeader.ImageBase); // Calculate the delta\n\n    // Relocate the image\n\n    while (pIBR->VirtualAddress)\n    {\n        if (pIBR->SizeOfBlock >= sizeof(IMAGE_BASE_RELOCATION))\n        {\n            count = (pIBR->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);\n            list = (PWORD)(pIBR + 1);\n\n            for (i = 0; i < count; i++)\n            {\n                if (list[i])\n                {\n                    ptr = (PDWORD)((LPBYTE)ManualInject->ImageBase + (pIBR->VirtualAddress + (list[i] & 0xFFF)));\n                    *ptr += delta;\n                }\n            }\n        }\n\n        pIBR = (PIMAGE_BASE_RELOCATION)((LPBYTE)pIBR + pIBR->SizeOfBlock);\n    }\n\n    pIID = ManualInject->ImportDirectory;\n\n    // Resolve DLL imports\n\n    while (pIID->Characteristics)\n    {\n        OrigFirstThunk = (PIMAGE_THUNK_DATA)((LPBYTE)ManualInject->ImageBase + pIID->OriginalFirstThunk);\n        FirstThunk = (PIMAGE_THUNK_DATA)((LPBYTE)ManualInject->ImageBase + pIID->FirstThunk);\n\n        hModule = ManualInject->fnLoadLibraryA((LPCSTR)ManualInject->ImageBase + pIID->Name);\n\n        if (!hModule)\n        {\n            return FALSE;\n        }\n\n        while (OrigFirstThunk->u1.AddressOfData)\n        {\n            if (OrigFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)\n            {\n                // Import by ordinal\n\n                Function = (INT64)ManualInject->fnGetProcAddress(hModule, (LPCSTR)(OrigFirstThunk->u1.Ordinal & 0xFFFF));\n\n                if (!Function)\n                {\n                    return FALSE;\n                }\n\n                FirstThunk->u1.Function = Function;\n            }\n\n            else\n            {\n                // Import by name\n\n                pIBN = (PIMAGE_IMPORT_BY_NAME)((LPBYTE)ManualInject->ImageBase + OrigFirstThunk->u1.AddressOfData);\n                Function = (INT64)ManualInject->fnGetProcAddress(hModule, (LPCSTR)pIBN->Name);\n\n                if (!Function)\n                {\n                    return FALSE;\n                }\n\n                FirstThunk->u1.Function = Function;\n            }\n\n            OrigFirstThunk++;\n            FirstThunk++;\n        }\n\n        pIID++;\n    }\n\n    if (ManualInject->NtHeaders->OptionalHeader.AddressOfEntryPoint)\n    {\n        EntryPoint = (PDLL_MAIN)((LPBYTE)ManualInject->ImageBase + ManualInject->NtHeaders->OptionalHeader.AddressOfEntryPoint);\n        EntryPointNew = (VOID(*)(VOID))((INT64)ManualInject->ImageBase + 0x2350);\n        __debugbreak();\n        //return EntryPoint((HMODULE)ManualInject->ImageBase, DLL_PROCESS_ATTACH, NULL); // Call the entry point\n        EntryPointNew();\n    }\n\n    return TRUE;\n}\n\nDWORD WINAPI LoadDllEnd()\n{\n    return 0;\n}\n\nint wmain(int argc, wchar_t* argv[])\n{\n    PIMAGE_DOS_HEADER pIDH;\n    PIMAGE_NT_HEADERS pINH;\n    PIMAGE_SECTION_HEADER pISH;\n\n    HANDLE hProcess, hThread, hFile;\n    PVOID buffer, image, mem;\n    DWORD i, FileSize, ProcessId, ExitCode, read;\n\n    MANUAL_INJECT ManualInject;\n\n    if (argc < 3)\n    {\n        printf(\"\nUsage: ManualInject [DLL name] [PID]\n\");\n        return -1;\n    }\n\n    printf(\"\nOpening the DLL.\n\");\n    hFile = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); // Open the DLL\n\n    if (hFile == INVALID_HANDLE_VALUE)\n    {\n        printf(\"\nError: Unable to open the DLL (%d)\n\", GetLastError());\n        return -1;\n    }\n\n    FileSize = GetFileSize(hFile, NULL);\n    buffer = VirtualAlloc(NULL, FileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n\n    if (!buffer)\n    {\n        printf(\"\nError: Unable to allocate memory for DLL data (%d)\n\", GetLastError());\n\n        CloseHandle(hFile);\n        return -1;\n    }\n\n    // Read the DLL\n\n    if (!ReadFile(hFile, buffer, FileSize, &read, NULL))\n    {\n        printf(\"\nError: Unable to read the DLL (%d)\n\", GetLastError());\n\n        VirtualFree(buffer, 0, MEM_RELEASE);\n        CloseHandle(hFile);\n\n        return -1;\n    }\n\n    CloseHandle(hFile);\n\n    pIDH = (PIMAGE_DOS_HEADER)buffer;\n\n    if (pIDH->e_magic != IMAGE_DOS_SIGNATURE)\n    {\n        printf(\"\nError: Invalid executable image.\n\");\n\n        VirtualFree(buffer, 0, MEM_RELEASE);\n        return -1;\n    }\n\n    pINH = (PIMAGE_NT_HEADERS)((LPBYTE)buffer + pIDH->e_lfanew);\n\n    if (pINH->Signature != IMAGE_NT_SIGNATURE)\n    {\n        printf(\"\nError: Invalid PE header.\n\");\n\n        VirtualFree(buffer, 0, MEM_RELEASE);\n        return -1;\n    }\n\n    if (!(pINH->FileHeader.Characteristics & IMAGE_FILE_DLL))\n    {\n        printf(\"\nError: The image is not DLL.\n\");\n\n        VirtualFree(buffer, 0, MEM_RELEASE);\n        return -1;\n    }\n\n    ProcessId = wcstoul(argv[2], NULL, 0);\n\n    printf(\"\nOpening target process.\n\");\n    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);\n\n    if (!hProcess)\n    {\n        printf(\"\nError: Unable to open target process (%d)\n\", GetLastError());\n\n        VirtualFree(buffer, 0, MEM_RELEASE);\n        CloseHandle(hProcess);\n\n        return -1;\n    }\n\n    printf(\"\nAllocating memory for the DLL.\n\");\n    image = VirtualAllocEx(hProcess, NULL, pINH->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Allocate memory for the DLL\n\n    if (!image)\n    {\n        printf(\"\nError: Unable to allocate memory for the DLL (%d)\n\", GetLastError());\n\n        VirtualFree(buffer, 0, MEM_RELEASE);\n        CloseHandle(hProcess);\n\n        return -1;\n    }\n\n    printf(\"[*]Remote Dll Base %llx\n\", image);\n\n    // Copy the header to target process\n\n    printf(\"\nCopying headers into target process.\n\");\n\n    if (!WriteProcessMemory(hProcess, image, buffer, pINH->OptionalHeader.SizeOfHeaders, NULL))\n    {\n        printf(\"\nError: Unable to copy headers to target process (%d)\n\", GetLastError());\n\n        VirtualFreeEx(hProcess, image, 0, MEM_RELEASE);\n        CloseHandle(hProcess);\n\n        VirtualFree(buffer, 0, MEM_RELEASE);\n        return -1;\n    }\n\n    pISH = (PIMAGE_SECTION_HEADER)(pINH + 1);\n\n    // Copy the DLL to target process\n\n    printf(\"\nCopying sections to target process.\n\");\n\n    for (i = 0; i < pINH->FileHeader.NumberOfSections; i++)\n    {\n        WriteProcessMemory(hProcess, (PVOID)((LPBYTE)image + pISH[i].VirtualAddress), (PVOID)((LPBYTE)buffer + pISH[i].PointerToRawData), pISH[i].SizeOfRawData, NULL);\n    }\n\n    printf(\"\nAllocating memory for the loader code.\n\");\n    mem = VirtualAllocEx(hProcess, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Allocate memory for the loader code\n\n    if (!mem)\n    {\n        printf(\"\nError: Unable to allocate memory for the loader code (%d)\n\", GetLastError());\n\n        VirtualFreeEx(hProcess, image, 0, MEM_RELEASE);\n        CloseHandle(hProcess);\n\n        VirtualFree(buffer, 0, MEM_RELEASE);\n        return -1;\n    }\n\n    memset(&ManualInject, 0, sizeof(MANUAL_INJECT));\n\n    ManualInject.ImageBase = image;\n    ManualInject.NtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)image + pIDH->e_lfanew);\n    ManualInject.BaseRelocation = (PIMAGE_BASE_RELOCATION)((LPBYTE)image + pINH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);\n    ManualInject.ImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((LPBYTE)image + pINH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\n    ManualInject.fnLoadLibraryA = LoadLibraryA;\n    ManualInject.fnGetProcAddress = GetProcAddress;\n\n    printf(\"\nWriting loader code to target process.\n\");\n    PVOID RemoteLoaderAddr = (PVOID)((PMANUAL_INJECT)mem + 1);\n\n    WriteProcessMemory(hProcess, mem, &ManualInject, sizeof(MANUAL_INJECT), NULL); // Write the loader information to target process\n    WriteProcessMemory(hProcess, RemoteLoaderAddr, LoadDll, (DWORD)LoadDllEnd - (DWORD)LoadDll, NULL); // Write the loader code to target process\n\n    printf(\"[*]Remote Loader %llx\n\", RemoteLoaderAddr);\n    system(\"pause\");\n    printf(\"\nExecuting loader code.\n\");\n    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteLoaderAddr, mem, 0, NULL); // Create a remote thread to execute the loader code\n\n    if (!hThread)\n    {\n        printf(\"\nError: Unable to execute loader code (%d)\n\", GetLastError());\n\n        VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);\n        VirtualFreeEx(hProcess, image, 0, MEM_RELEASE);\n\n        CloseHandle(hProcess);\n\n        VirtualFree(buffer, 0, MEM_RELEASE);\n        return -1;\n    }\n\n    WaitForSingleObject(hThread, INFINITE);\n    GetExitCodeThread(hThread, &ExitCode);\n\n    if (!ExitCode)\n    {\n        VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);\n        VirtualFreeEx(hProcess, image, 0, MEM_RELEASE);\n\n        CloseHandle(hThread);\n        CloseHandle(hProcess);\n\n        VirtualFree(buffer, 0, MEM_RELEASE);\n        return -1;\n    }\n\n    CloseHandle(hThread);\n    VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);\n\n    CloseHandle(hProcess);\n\n    printf(\"\nDLL injected at %#x\n\", image);\n\n    if (pINH->OptionalHeader.AddressOfEntryPoint)\n    {\n        printf(\"\nDLL entry point: %#x\n\", (PVOID)((LPBYTE)image + pINH->OptionalHeader.AddressOfEntryPoint));\n    }\n\n    VirtualFree(buffer, 0, MEM_RELEASE);\n    return 0;\n}\n</code></pre>\n",
            "votes": "1",
            "user": "Ox9A82",
            "time": "Jan 6, 2021 at 14:41",
            "is_accepted": false,
            "comments": []
        }
    ]
}