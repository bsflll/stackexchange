{
    "title": "How is data transferred from the process’ memory to the console screen?",
    "link": "https://reverseengineering.stackexchange.com/questions/18039/how-is-data-transferred-from-the-process-memory-to-the-console-screen",
    "content": "I am learning about how the call stack works by reverse engineering binaries using Radare2 (in a Linux environment). The ISA on the server (a P5 micro-architecture) I am analyzing binaries off of is x86 (Intel syntax). \nSay I want to print a very simple string to the console by compiling a C program named <pre><code>hello.c</code></pre> in to an executable:\n<pre><code>int main()\n{\n    printf(\"Hello world!\");\n\n    return (0);\n}\n</code></pre>\nHow does the CPU transfer the data containing the \"Hello world!\" string from the stack space reserved for the <pre><code>hello</code></pre> executable in memory to the console output?\n",
    "votes": "1",
    "answers": 1,
    "views": "268",
    "tags": [
        "x86",
        "memory",
        "stack"
    ],
    "user": "Darien Springer",
    "time": "May 10, 2018 at 7:01",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "what's an \"output sink\"?\n",
            "time": null
        },
        {
            "user": "Igor Skochinsky",
            "text": "BTW, please try to avoid editing questions in a way that invalidates existing answers.\n",
            "time": null
        },
        {
            "user": "Darien Springer",
            "text": "I don't know how I am supposed to correct the question when it apparently was faulty to begin with. I am not attempting to invalidate existing answers but I have no idea how I am otherwise supposed to get this question to get at least one upvote. If you have enough questions with 0 votes or less, you are prevented from asking more questions. So what would you have me do?\n",
            "time": null
        },
        {
            "user": "Igor Skochinsky",
            "text": "well, at least maybe explain what you mean by “output sink” and why you changed to it from the original title. I don’t think I’ve heard this term before.\n",
            "time": null
        },
        {
            "user": "Darien Springer",
            "text": "en.wikipedia.org/wiki/Sink_(computing)\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "To print to the terminal, a process started by the shell performs file I/O by making a <pre><code>write()</code></pre> system call using the already open <pre><code>stdout</code></pre> file descriptor inherited from the shell (the parent process).\n\nFor the process that manages this program, how is the data containing the \"Hello world!\" string transferred from the stack in memory to the child process of the shell?\n\n\nthis question is nonsense because the \"hello world\" process is the child process. The parent process is the shell, since the shell was the process that started the \"hello world\" process. When printing to the terminal (<pre><code>STDOUT</code></pre>), the child process is sending data to the parent process (the shell).\ntake a look at the binary and look at the disassembly of the <pre><code>main()</code></pre> function. The \"hello world\" string is hardcoded in the <pre><code>.rodata</code></pre> section of the binary. It is not written to the stack at any point. In <pre><code>main()</code></pre>, a pointer to its location is written to the stack as an argument to the  <pre><code>printf</code></pre> function. \nthe runtime stack of a process is a space in virtual memory whose use is managed by the compiler. The stack is written to and read from by the CPU, which executes the instructions generated by the compiler. The stack does not perform any sort of action or computation; this is the purpose of the CPU. You should read the Q&A here: How are variables stored in and retrieved from the program stack?. Note that if a programming language does not permit recursion, a stack is not even required.\n\nA shell is a special-purpose program designed to read commands typed by a user and execute appropriate programs in response to those commands. Such a program is sometimes known as a command interpreter.1\n\nWhen you type <pre><code>$ ./hello</code></pre>, the shell will read this command and proceed to call <pre><code>fork</code></pre> and <pre><code>exec</code></pre> to start a new process (I strongly urge you to read Differences between fork and exec). \nSince each process occupies its own space in virtual memory and is as a result isolated from every other process, the shell and the new process started by the shell must use services provided by the kernel in order to share data. The Linux I/O model provides one way for processes to communicate with each other using file descriptors:\n\nAll system calls for performing I/O refer to open files using a file descriptor, a (usually small) nonnegative integer. File descriptors are used to refer to all types of open files, including pipes, FIFOs, sockets, terminals, devices, and regular files. Each process has its own set of file descriptors. \nBy convention, most programs expect to be able to use the three standard file descriptors listed in Table 4-1. These three descriptors are opened on the program’s behalf by the shell, before the program is started. Or, more precisely, the program inherits copies of the shell’s file descriptors, and the shell normally operates with these three file descriptors always open. (In an interactive shell, these three file\n  descriptors normally refer to the terminal under which the shell is running.) If I/O redirections are specified on a command line, then the shell ensures that the file descriptors are suitably modified before starting the program.2\n\n\n\nThis means that if one wishes to print to the terminal, one must make a <pre><code>write()</code></pre> system call using the already open <pre><code>stdout</code></pre> file descriptor.\nHere is a simple example program to make things more clear:\n<pre><code>#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main(void) {\n        pid_t current_PID = getpid();\n        pid_t parent_PID = getppid();\n\n        printf(\"Current process ID: %d\n\", current_PID);\n        printf(\"Parent process ID: %d\n\", parent_PID);\n\n        return 0;\n}\n</code></pre>\nWe can retrieve the process ID of the shell via the <pre><code>echo $$</code></pre> command (<pre><code>bash</code></pre> is assumed to be the shell here).\n<pre><code>$ echo $$\n29760\n</code></pre>\nThen we compile and run the example program (which I simply called <pre><code>pid</code></pre>):\n<pre><code>$ ./pid \nCurrent process ID: 9071\nParent process ID: 29760\n</code></pre>\nThe parent process ID is that of the shell which started the <pre><code>pid</code></pre> process.\nTo see what is happening at the CPU level, here is disassembly of <pre><code>main()</code></pre> with comments explaining the relevant operations:\n<pre><code><main>:\npush   %ebp\nmov    %esp,%ebp\nand    $0xfffffff0,%esp\nsub    $0x20,%esp\ncall   8048340 <getpid@plt>  # libc wrapper around getpid() system call\nmov    %eax,0x18(%esp)       # write return value (PID) in register to stack\ncall   8048370 <getppid@plt> # libc wrapper around getppid() system call\nmov    %eax,0x1c(%esp)       # write return value (PPID) in register to stack\nmov    0x18(%esp),%eax       # read from stack, write to register\nmov    %eax,0x4(%esp)        # write register value to stack as 2nd arg to printf (PID)\nmovl   $0x8048560,(%esp)     # read format string from memory, write to stack as 1st arg to printf\ncall   8048330 <printf@plt>  # libc wrapper around write() system call\nmov    0x1c(%esp),%eax       # read PPID saved on stack, write to register\nmov    %eax,0x4(%esp)        # write PPID in register to stack as 2nd arg to printf\nmovl   $0x8048578,(%esp)     # read format string from memory, write to stack as 1st arg to printf\ncall   8048330 <printf@plt>  # libc wrapper around write() system call\nmov    $0x0,%eax\nleave  \nret    \n</code></pre>\nHere is the <pre><code>strace</code></pre> output for the example program:\n<pre><code>$ strace ./pid\nexecve(\"./pid\", [\"./pid\"], [/* 53 vars */]) = 0\n[ Process PID=10017 runs in 32 bit mode. ]\nbrk(0)                                  = 0x943d000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7793000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=155012, ...}) = 0\nmmap2(NULL, 155012, PROT_READ, MAP_PRIVATE, 3, 0) = 0xfffffffff776d000\nclose(3)                                = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/lib/i386-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0P\\234\\1\\0004\\0\\0\\0\"..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=1763068, ...}) = 0\nmmap2(NULL, 1772156, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xfffffffff75bc000\nmmap2(0xf7767000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1aa000) = 0xfffffffff7767000\nmmap2(0xf776a000, 10876, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xfffffffff776a000\nclose(3)                                = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff75bb000\nset_thread_area(0xffc17c00)             = 0\nmprotect(0xf7767000, 8192, PROT_READ)   = 0\nmprotect(0x8049000, 4096, PROT_READ)    = 0\nmprotect(0xf77b8000, 4096, PROT_READ)   = 0\nmunmap(0xf776d000, 155012)              = 0\ngetpid()                                = 10017\ngetppid()                               = 10014\nfstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 13), ...}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7792000\nwrite(1, \"Current process ID: 10017\n\", 26Current process ID: 10017\n) = 26\nwrite(1, \"Parent process ID: 10014\n\", 25Parent process ID: 10014\n) = 25\nexit_group(0)                           = ?\n+++ exited with 0 +++\n</code></pre>\nNote the <pre><code>execve()</code></pre> system call on the first line and the <pre><code>write()</code></pre> system calls at the bottom.\n\n\nThe Linux Programming Interface, 2.2 The Shell, pg. 24 \nThe Linux Programming Interface, 4.1 Overview, pg. 69\n",
            "votes": "2",
            "user": "julian",
            "time": "Apr 21, 2018 at 3:58",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Darien Springer",
                    "text": "<span class=\"comment-copy\">Edited question to clarify what I am asking. Does that make my question clearer?</span>",
                    "time": null
                },
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">@DarienSpringer It does not.</span>",
                    "time": null
                },
                {
                    "user": "Darien Springer",
                    "text": "<span class=\"comment-copy\">What is not clear?</span>",
                    "time": null
                },
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">@DarienSpringer The statement \"Does the stack directly transfer data from memory to the child process of the shell when a function is called to access some data in memory to print or return it to the console output? \" - Each process has its own stack space, so this does not make sense. Did you read anything I wrote?</span>",
                    "time": null
                },
                {
                    "user": "Darien Springer",
                    "text": "<span class=\"comment-copy\">Yes, I did read what you said. I have clarified my question.</span>",
                    "time": null
                }
            ]
        }
    ]
}