{
    "title": "Identify Jump Statements due to Switch/Case in IDA Pro",
    "link": "https://reverseengineering.stackexchange.com/questions/12317/identify-jump-statements-due-to-switch-case-in-ida-pro",
    "content": "I want to identify the jump statements due to switch/case in an IDA Pro disassembled binary. My ultimate goal is to read the jump table entries. I am also interested in function table/vtables. For switch/case, I see the jump statements as:\n\n<pre><code>jmp  ds:off_20B280CC[ebx*4]</code></pre>\n<pre><code>jmp  dword ptr ds:loc_6B2A825C[ecx*4]</code></pre> [Q: Is it due to switch/jump?]\n\nThe operand types of these jumps, as I see from <pre><code>GetOperandValue(inst.ea, 0)</code></pre>, are \"Memory Reference\" (type value 2). The jump statements like <pre><code>jb short loc_6B2A8154</code></pre> has operand type \"Immediate Near Address\" (type value 7). However, the jump statements like <pre><code>jmp ds:__imp_memset</code></pre> in the thunk functions to call imported functions also have the operand type \"Memory Reference\". \nIs there any way I can distinguish between jump statements for switch/case and thunk functions?\n",
    "votes": "4",
    "answers": 3,
    "views": "4k",
    "tags": [
        "disassembly",
        "idapython"
    ],
    "user": "ssultana",
    "time": "Apr 1, 2016 at 18:05",
    "comments": [],
    "answers_data": [
        {
            "content": "In many cases, IDA already knows that a jump is part of a jump-table and probably the result of a switch. When this is true, you can access it using IDAPython.\nThe relevant functions are <pre><code>get_switch_info_ex(ea)</code></pre> and <pre><code>get_switch_info_ex(ea)</code></pre>.\nLooking in IDAPython's documentation, we find:\n\ncalc_switch_cases(insn_ea, py_swi)\nGet information about a switch's cases.\nThe returned information can be used as follows:\n<pre><code>for idx in xrange(len(results.cases)):\n    cur_case = results.cases[idx]\n    for cidx in xrange(len(cur_case)):\n        print \"case: %d\" % cur_case[cidx]\n    print \"  goto 0x%x\" % results.targets[idx]\n</code></pre>\n@param insn_ea: address of the 'indirect jump' instruction @param si:\n  switch information\n@return: a structure with 2 members: 'cases', and 'targets'.\nReturns: cases_and_targets_t\n\nTo get the <pre><code>results</code></pre> variable from the example, we use the following code:\n<pre><code>si = idaapi.get_switch_info_ex(ea)\nresults = idaapi.calc_switch_cases(ea, si)\nif not results:\n    print \"No switch related jump at 0x{:X}\".format(ea)\n</code></pre>\nSo to check if an instruction is a switch or not, you can use the following function:\n<pre><code>def is_switch(ea):\n    si = idaapi.get_switch_info_ex(ea)\n    results = idaapi.calc_switch_cases(ea, si)\n    return bool(results)\n</code></pre>\nIf you wish to use it, I've written a basic wrapper class for IDA's switch in Sark. See here.\n",
            "votes": "3",
            "user": "tmr232",
            "time": "Sep 29, 2016 at 21:34",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "On the x86 architecture, jump statements due to switch/case statements often follow the pattern:\n<pre><code>jmp <offset> [<index-register> * 4]   ;; pointers are 4 bytes\n</code></pre>\nwhere <pre><code><index-register></code></pre> contains the value being switched on and the \"4\" is the scaling factor. Depending on your compiler may have good results searching for jump instructions with indexed memory operands.\nHowever the compiler is free to compile switch statements into cascades of <pre><code>cmp</code></pre> and <pre><code>jnz</code></pre> statements if it determines that doing so would produce more efficient code. For instance:\n<pre><code>switch (foo) {\ncase 1: do_something(); break;\ncase 10000: do_something_else(); break;\ncase 1000000: do_final_thing(); break;\n}\n</code></pre>\nwould be terribly inefficient implemented as a table lookup. Therefore, just looking for indexed memory operands won't necessarily find all switch/cases in your program.\nYou need also take into account that the compiler may write the switch differently. It is fully possible that it might determine that it is better to emit the sequence\n<pre><code>mov eax,table_offset[eax*4]\njmp eax\n</code></pre>\nor, as in old hand-rolled binaries adapted from hand-written assembler written for 8086 or 80286 real mode:\n<pre><code>shl eax,4\njmp table_offset[eax]\n</code></pre>\nTo cover all bases, you will be forced to use other techniques like backward slicing to determine the destinations of a compiled switch/case statement.\n",
            "votes": "0",
            "user": "John Källén",
            "time": "Apr 1, 2016 at 18:25",
            "is_accepted": false,
            "comments": [
                {
                    "user": "ssultana",
                    "text": "<span class=\"comment-copy\">Thanks for explaining other switch/case scenarios. I'll have to take care of those. However, I am taking figuring out the indexed memory operands for switch/case jumps as a first step. I am using IDA Python scripting to get the instruction types, operand types and values, etc. Using IDA Python, I still cannot distinguish between switch/case jumps to indexed memory references and other memory references due to thunk functions. Any pointer would be appreciated.</span>",
                    "time": null
                },
                {
                    "user": "John Källén",
                    "text": "<span class=\"comment-copy\">I'm not familiar with IDA but could you, after identifying the indirect jmp, then compare that its opcode startis with FF 24 85 / 8D / 95 / 9D etc. I.e mask out the <code>i</code> part of the <code>sib</code> byte of the indirect jump?</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "Similar to Sark's solution, minsc at https://github.com/arizvisa/ida-minsc provides a wrapper around the same <pre><code>switch_info_t</code></pre> that is fetched in IDAPython using the <pre><code>get_switch_info</code></pre> function from <pre><code>nalt.hpp</code></pre>. It is worth noting that these solutions use the disassembler exclusively (as opposed to the decompiler).\nDisclaimer: I'm the maintainer of the ida-minsc plugin.\nTo get to the minsc wrapper, the <pre><code>database.get.switch</code></pre> function is used to fetch a <pre><code>switch_t</code></pre>. The following python disassembles a branch instruction and then uses its address to get the \"switch\" identified by the disassembler. The <pre><code>switch_t</code></pre> that is returned contains 0x10 total cases and exposes numerous properties that can be used to extract information from the \"switch\". As per the question, the <pre><code>database.type.switch</code></pre> function can be used to detect if an address branches to a table used by the \"switch\" (or belongs to a handler) that was detected by the disassembler.\n<pre><code>Python>db.disasm()\n'277ef564: jmp ds:jpt_277EF564[eax*4]'\n\nPython>sw=db.get.switch()\nPython>sw\n<class 'switch_t{16}' at 0x277ef54f> default:0x277ef699 branch[8]:0x277ef6b3 indirect[16]:0x277ef6d3 register:%eax\n\nPython>db.t.switch()\nTrue\n</code></pre>\nThe <pre><code>switch_t.range</code></pre> property returns the entire range of cases for the switch that was determined by the disassembler. Similarly, the <pre><code>switch_t.cases</code></pre> property is used to return only the cases that do not dispatch to the \"default\" handler for the fetched \"switch\". Also, if one wants to create a breakpoint logging the case being dispatched to by the \"switch\", the <pre><code>switch_t.ea</code></pre> property can be combined with the <pre><code>switch_t.register</code></pre> property in order to identify the register needing to be captured.\n<pre><code># Return the full range of cases supported by the \"switch\".\nPython>sw.range\n(0x10000000, 0x10000001, 0x10000002, 0x10000003, 0x10000004, 0x10000005, 0x10000006, 0x10000007, 0x10000008, 0x10000009, 0x1000000a, 0x1000000b, 0x1000000c, 0x1000000d, 0x1000000e, 0x1000000f)\n\n# Return the cases of the \"switch\" that dispatch to a non-default case.\nPython>sw.cases\n(0x10000000, 0x10000001, 0x10000002, 0x10000003, 0x10000004, 0x10000005, 0x10000007, 0x10000008, 0x10000009, 0x1000000a, 0x1000000b, 0x1000000c, 0x1000000d, 0x1000000e, 0x1000000f)\n\n# Other properties that could be useful...\nPython>db.disasm(sw.ea)\n'277ef54f: add eax, 0F0000000h'\n\nPython>sw.register\n<class 'register_t' index=0 dtype=dt_dword name='eax' position=0+32>\n\nPython>database.up(sw.branch_ea)\n[ref_t(address=0x277ef564, access=access_t(r))]\n\nPython>[db.disasm(ea) for ea in database.up(sw.branch_ea)]\n['277ef564: jmp ds:jpt_277EF564[eax*4]']\n\n# Display operand information that might be used for filtering.\nPython>ea, = database.up(sw.branch_ea)\nPython>ins.type.branch(ea)\nTrue\n\nPython>instruction.ops_access(ea)\n(opref_t(address=0x277ef564, opnum=0, access=access_t(rx)))\n\nPython>ins.ops(ea)\n(SegmentOffsetBaseIndexScale(segment=%ds, offset=0x277ef6b3, base=None, index=%eax, scale=4))\n</code></pre>\nFor addresses being dispatched to by the \"switch\", the <pre><code>switch_t.handlers</code></pre> property can be used to return the address of each handler, with the <pre><code>switch_t.default</code></pre> property being responsible for returning the address of the \"default\" handler. To return the handler for a specific case, the <pre><code>switch_t.case()</code></pre> function can be used as in the following python.\n<pre><code># Return all of the available handlers used by the \"switch\".\nPython>sw.handlers\n(0x277ef67e, 0x277ef56b, 0x277ef644, 0x277ef685, 0x277ef699)\n\n# Return the default handler for the \"switch\".\nPython>sw.default\n0x277ef699\n\n# Return the handler for a specific case.\nPython>sw.case(0x10000000)\n0x277ef67e\n</code></pre>\nBy combining the handler-related properties, one can create a python dictionary for looking up the dispatcher for a specific case as in the following code. However, it is probably more useful to determine the number of cases that are implemented by each handler in order to distinguish what is actually worth reversing. This can be done by inverting the dictionary so that its key references the handler, with its value containing the list of cases being supported.\n<pre><code>Python>{case : sw.case(case) for case in sw.range}\n{0x10000000: 0x277ef67e, 0x10000001: 0x277ef67e, 0x10000002: 0x277ef67e, 0x10000003: 0x277ef67e, 0x10000004: 0x277ef67e, 0x10000005: 0x277ef67e, 0x10000006: 0x277ef699, 0x10000007: 0x277ef67e, 0x10000008: 0x277ef56b, 0x10000009: 0x277ef67e, 0x1000000a: 0x277ef67e, 0x1000000b: 0x277ef644, 0x1000000c: 0x277ef67e, 0x1000000d: 0x277ef67e, 0x1000000e: 0x277ef67e, 0x1000000f: 0x277ef685}\n\n# Invert the table of case<->handlers.\nPython>handlers={}\nPython>[ handlers.setdefault(sw.case(case), []).append(case) for case in sw.cases ]\n[None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]\n\nPython>handlers\n{0x277ef67e: [0x10000000, 0x10000001, 0x10000002, 0x10000003, 0x10000004, 0x10000005, 0x10000007, 0x10000009, 0x1000000a, 0x1000000c, 0x1000000d, 0x1000000e], 0x277ef699: [0x10000006], 0x277ef56b: [0x10000008], 0x277ef644: [0x1000000b], 0x277ef685: [0x1000000f]} \n</code></pre>\nThis dictionary can be used for operations such as notating the handler address with a descriptive name, color, etc. The following python produces a name following the format \"case(number1,number2,number3,...)\" and applies it as a label for each handler. Afterwards, the <pre><code>database.names</code></pre> namespace is used with the \"bounds\" matcher and <pre><code>function.chunk</code></pre> to list all the labels within the current function chunk...showing the labels we just applied.\n<pre><code># Assign a label to the address of each individual case.\nPython>for ea, cases in handlers.items():\nPython> db.name(ea, \"case({:s})\".format(','.join(hex(case) for case in sorted(cases))), listed=True)\nPython>\n\n# List all the labels within the current function chunk.\nPython>db.names.list(bounds=func.chunk())\n[322] 0x277ef53e : ^C* : jsvda_920\n[323] 0x277ef56b : ^C* : case(10000008)\n[324] 0x277ef644 : ^C* : case(1000000b)\n[325] 0x277ef67e : ^C* : case(10000000,10000001,10000002,10000003,10000004,10000005,10000007,10000009,1000000a,1000000c,1000000d,1000000e)\n[326] 0x277ef685 : ^C* : case(1000000f)\n[327] 0x277ef699 : ^C* : def_277EF564\n</code></pre>\nFor enumerating switches, the <pre><code>function.switches</code></pre> function can be used with an address belonging to a function. The next python combines this with the <pre><code>database.functions</code></pre> namespace to identify every function containing 1 or more switches within the database. After all of the candidate functions have been enumerated, the <pre><code>function.tag</code></pre> function is used to store the total number of cases that are handled by the switches within each function.\n<pre><code># Collect all functions that have at least one \"switch\" within its body.\nPython>functions_with_switches = {ea for ea in db.functions() if next(func.switches(ea), None) is not None}\nPython>functions_with_switches\nset([0x277bd6cd, 0x277d5b8f, 0x2780c071, 0x2780e8b1, 0x277a7833, 0x277beb74, 0x277fef38, 0x277ac0fb, 0x277a2ebd, 0x277ef53e])\n\n# Iterate through all functions and collect the number of \"switch\" statements detected by the disassembler.\nPython>for ea in functions_with_switches:\nPython> count = sum(len(sw.cases) for sw in func.switches(ea))\nPython> fn.tag(ea, 'switch.cases', count)\n</code></pre>\nOnce a function has been tagged and indexed with some value, <pre><code>database.functions</code></pre> can be used with the \"tagged\" matcher to narrow down the list of functions containing our previously identified switches. To query the index for the number of cases tagged to each function, the <pre><code>database.select</code></pre> function can also be used.\n<pre><code>Python>db.functions(tagged='switch.cases')\n[0x277a2ebd, 0x277a7833, 0x277ac0fb, 0x277bd6cd, 0x277beb74, 0x277d5b8f, 0x277ef53e, 0x277fef38, 0x2780c071, 0x2780e8b1]\n\nPython>db.functions.list(tagged='switch.cases')\n[0]  +0x02ebd : 0x277a2ebd..0x277a3331 : (1) Fvt* : __cdecl jsvda_919                                             : lvars:330 args:5 refs:4 exits:1\n[1]  +0x07833 : 0x277a7833..0x277a78ff : (1) Fv-* : __cdecl sub_277A7833                                          : lvars:010 args:4 refs:1 exits:1\n[2]  +0x0c0fb : 0x277ac0fb..0x277ac61b : (1) Fvt* : __cdecl sub_277AC0FB                                          : lvars:024 args:7 refs:1 exits:1\n[3]  +0x1d6cd : 0x277bd6cd..0x277bd82c : (1) Fvt* : __cdecl jsvda_950                                             : lvars:010 args:3 refs:5 exits:1\n[4]  +0x1eb74 : 0x277beb74..0x277beca6 : (1) F-t* : __cdecl sub_277BEB74                                          : lvars:008 args:4 refs:1 exits:1\n[5]  +0x35b8f : 0x277d5b8f..0x277d6059 : (1) FvT* : __cdecl JSVDA::204                                            : lvars:02c args:8 refs:2 exits:1\n[6]  +0x4f53e : 0x277ef53e..0x277ef6b3 : (1) Fvt* : __cdecl jsvda_920                                             : lvars:014 args:4 refs:3 exits:1\n[7]  +0x5ef38 : 0x277fef38..0x277ff219 : (1) Fvt* : __cdecl sub_277FEF38                                          : lvars:040 args:3 refs:1 exits:1\n[8]  +0x6c071 : 0x2780c071..0x2780c5cc : (1) FvT* : __cdecl JSVDA::object_6b3a6::getPathAttributeFromBucket_6c071 : lvars:024 args:5 refs:6 exits:1\n[9]  +0x6e8b1 : 0x2780e8b1..0x2780eabb : (1) F--* : __cdecl sub_2780E8B1                                          : lvars:00c args:4 refs:1 exits:1\n\nPython>for ea, res in db.select('switch.cases'):\nPython> print(res['switch.cases'], hex(ea), func.name(ea), sum(1 for blk in function.blocks(ea)))\nPython>\n11 277a2ebd jsvda_919 111\n8 277a7833 sub_277A7833 25\n10 277ac0fb sub_277AC0FB 136\n16 277bd6cd jsvda_950 47\n15 277beb74 sub_277BEB74 30\n9 277d5b8f JSVDA::204 116\n15 277ef53e jsvda_920 35\n13 277fef38 sub_277FEF38 76\n15 2780c071 JSVDA::object_6b3a6::getPathAttributeFromBucket_6c071 120\n11 2780e8b1 sub_2780E8B1 81\n</code></pre>\n",
            "votes": "0",
            "user": "Ali Rizvi-Santiago",
            "time": "Aug 15, 2024 at 20:07",
            "is_accepted": false,
            "comments": []
        }
    ]
}