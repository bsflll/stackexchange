{
    "title": "Calling original function that uses unconventional calling convention",
    "link": "https://reverseengineering.stackexchange.com/questions/16697/calling-original-function-that-uses-unconventional-calling-convention",
    "content": "I'm using MinHook to hook a static function with the following signature:\n<pre><code>float __usercall RadarManager::Add_Blip@<xmm0>(int position@<ecx>, int shape@<edx>, int colorId, float intensity@<xmm3>, bool isBracket, bool isSmall)\n</code></pre>\nI have confirmed that the register/stack usage is correct using IDA. I also have confirmed that I got the right address using Visual Studio to debug my code. It first goes to the trampoline generated by MinHook, executes the first few opcodes and then jumps to the original function skipping the bytes that were overwritten. \nI made my hook function completely empty, but the program still crashes on some other arbitrary address.\nMy hook function is as follows:\n<pre><code>float __declspec(naked) radarAddBlip(const Vector3 &position, int shape, int colorId, float intensity, bool isBracket, bool isSmall)\n{\n    __asm\n    {\n        call originalRadarManager_Add_Blip;\n\n        ret;\n    }\n}\n</code></pre>\nPrologue of function that is being hooked:\n<pre><code>.text : 1181F4C0                 push    ebp\n.text : 1181F4C1                 mov     ebp, esp\n.text : 1181F4C3                 and     esp, 0FFFFFFF8h\n.text : 1181F4C6                 sub     esp, 34h\n.text : 1181F4C9                 movss   xmm2, dword ptr[ecx + 4]\n.text : 1181F4CE                 movss   xmm1, dword ptr[ecx + 8]\n.text : 1181F4D3                 movss   dword ptr[esp + 34h + var_20], xmm3\n.text : 1181F4D9                 movss   xmm3, dword ptr[ecx]\n.text : 1181F4DD                 movaps  xmm0, xmm2\n.text : 1181F4E0                 mulss   xmm0, dword_11A6D7AC\n.text : 1181F4E8                 mulss   xmm2, dword_11A6D7BC\n.text : 1181F4F0                 movaps  xmm4, xmm3\n.text : 1181F4F3                 mulss   xmm4, dword_11A6D7A8\n.text : 1181F4FB                 mulss   xmm3, dword_11A6D7B8\n.text : 1181F503                 addss   xmm4, xmm0\n.text : 1181F507                 movaps  xmm0, xmm1\n.text : 1181F50A                 mulss   xmm0, dword_11A6D7B0\n.text : 1181F512                 mulss   xmm1, dword_11A6D7C0\n.text : 1181F51A                 addss   xmm3, xmm2\n.text : 1181F51E                 addss   xmm4, xmm0\n.text : 1181F522                 push    ebx\n.text : 1181F523                 push    esi\n.text : 1181F524                 mov     esi, edx\n.text : 1181F526                 addss   xmm3, xmm1\n.text : 1181F52A                 addss   xmm4, dword_11A6D7B4\n.text : 1181F532                 movss   xmm1, ds : dword_11A419F0\n.text : 1181F53A                 push    edi\n.text : 1181F53B                 mov[esp + 40h + var_14], esi\n.text : 1181F53F                 addss   xmm3, dword_11A6D7C4\n.text : 1181F547                 mulss   xmm4, xmm1\n.text : 1181F54B                 mulss   xmm3, xmm1\n.text : 1181F54F                 mulss   xmm1, ds : dword_11A3ED98\n.text : 1181F557                 movaps  xmm0, xmm3\n.text : 1181F55A                 mulss   xmm0, xmm3\n.text : 1181F55E                 movaps  xmm2, xmm4\n.text : 1181F561                 mulss   xmm2, xmm4\n.text : 1181F565                 movss[esp + 40h + var_30], xmm4\n.text : 1181F56B                 movss[esp + 40h + var_2C], xmm3\n.text : 1181F571                 addss   xmm2, xmm0\n.text : 1181F575                 movaps  xmm0, xmm1\n.text : 1181F578                 mulss   xmm0, xmm1\n.text : 1181F57C                 movss[esp + 40h + var_28], xmm1\n.text : 1181F582                 addss   xmm2, xmm0\n.text : 1181F586                 cvtps2pd xmm0, xmm2\n.text : 1181F589                 movss[esp + 40h + var_24], xmm2\n.text : 1181F58F                 call    _libm_sse2_sqrt_precise\n.text : 1181F594                 movss   xmm1, ds : dword_11A41A30\n.text : 1181F59C                 cvtsd2ss xmm0, xmm0\n.text : 1181F5A0                 comiss  xmm0, ds : dword_11A41E10\n.text : 1181F5A7                 jb      loc_1181F62E\n.text : 1181F5AD                 cmp     esi, 4\n.text : 1181F5B0                 jnz     short loc_1181F621\n.text : 1181F5B2                 movss   xmm0, [esp + 34h + var_18]\n.text : 1181F5B8                 addss   xmm0, ds : dword_11A41828\n.text : 1181F5C0                 cvtps2pd xmm0, xmm0\n.text : 1181F5C3                 call    _libm_sse2_sqrt_precise\n</code></pre>\nEpilogue of function being hooked:\n<pre><code>.text : 1181F7B7                 cmp[ebp + isBracket], 0\n.text : 1181F7BB                 jz      short loc_1181F7F8\n.text : 1181F7BD                 mov     esi, dword_11A5F400\n.text : 1181F7C3                 push    0\n.text : 1181F7C5                 push    dword ptr[esi + 0C4h]\n.text : 1181F7CB                 mov     ecx, esi\n.text : 1181F7CD                 call    sub_11822750\n.text : 1181F7D2                 lea     eax, [esp + 34h + var_4]\n.text : 1181F7D6                 push    eax\n.text : 1181F7D7                 mov     ecx, esi\n.text : 1181F7D9                 call    sub_11822330\n.text : 1181F7DE                 push    offset dword_11A6D8B0\n.text : 1181F7E3                 mov     ecx, esi\n.text : 1181F7E5                 call    sub_11822B00\n.text : 1181F7EA                 or edi, 0FF00h\n.text : 1181F7F0                 push    edi\n.text : 1181F7F1                 mov     ecx, esi\n.text : 1181F7F3                 call    sub_11822660\n.text : 1181F7F8\n.text : 1181F7F8 loc_1181F7F8 : ; CODE XREF : RadarManager__Add_Blip + 2FBj\n.text : 1181F7F8                 movss   xmm0, ds : dword_11A41A30\n.text : 1181F800                 pop     edi\n.text : 1181F801                 pop     esi\n.text : 1181F802                 pop     ebx\n.text : 1181F803                 mov     esp, ebp\n.text : 1181F805                 pop     ebp\n.text : 1181F806                 retn\n</code></pre>\nExample of original function being called (Left in some extra opcodes):\n<pre><code>.text : 11820270                 mov     eax, [ecx + 4]\n.text : 11820273                 mov     esi, [eax + edi * 4]\n.text : 11820276                 cmp     byte ptr[esi + 24h], 0\n.text : 1182027A                 jz      short loc_118202C8\n.text : 1182027C                 cmp     dword ptr[esi + 8], 0\n.text : 11820280                 jnz     short loc_118202C8\n.text : 11820282                 mov     eax, [esi + 4]\n.text : 11820285                 movss   xmm3, dword ptr[esi + 34h]; a4\n.text : 1182028A                 push    0; a5\n.text : 1182028C                 add     eax, 4\n.text : 1182028F                 push    0; a5\n.text : 11820291                 push    eax; a3\n.text : 11820292                 lea     ecx, [esi + 28h]; a1\n.text : 11820295                 mov     edx, 4; a2\n.text : 1182029A                 call    RadarManager__Add_Blip\n.text : 1182029F                 movaps  xmm1, xmm0\n.text : 118202A2                 xorps   xmm0, xmm0\n.text : 118202A5                 add     esp, 0Ch\n.text : 118202A8                 comiss  xmm0, xmm1\n.text : 118202AB                 ja      short loc_118202BA\n.text : 118202AD                 movss   xmm0, ds : dword_11A41A30\n.text : 118202B5                 comiss  xmm1, xmm0\n.text : 118202B8                 jbe     short loc_118202BD\n.text : 118202BA\n.text : 118202BA loc_118202BA : ; CODE XREF : RadarManager__Update + A8Bj\n.text : 118202BA                 movaps  xmm1, xmm0\n.text : 118202BD\n.text : 118202BD loc_118202BD : ; CODE XREF : RadarManager__Update + A98j\n.text : 118202BD                 mov     ecx, dword_11A679C4\n.text : 118202C3                 movss   dword ptr[esi + 34h], xmm1\n</code></pre>\nOpcodes that are copied to the trampoline (before the jmp)\n<pre><code>.text : 1181F4C0                 push    ebp\n.text : 1181F4C1                 mov     ebp, esp\n.text : 1181F4C3                 and     esp, 0FFFFFFF8h\n</code></pre>\nI've tried changing calling conventions, to making it __declspec(naked) and directly calling it and even manually editing the registry, but to no avail. I'm at the end of my rope and I can't even get it to work when it doesn't even do anything. \nTo summarize my question: How can I successfully call the original function through my hook function and doing something before calling the original? I'm not required to use MinHook, but so far it has been doing a good job.\n",
    "votes": "2",
    "answers": 0,
    "views": "516",
    "tags": [
        "windows",
        "x86",
        "c++",
        "function-hooking"
    ],
    "user": "Neijwiert",
    "time": "Nov 2, 2017 at 23:57",
    "comments": [
        {
            "user": "Samson",
            "text": "Have you tried using a debugger on the crash? (Ollydbg, x64dbg etc.) Might reveal some relevent details as to why. Maybe the compiler isn't calling it correctly (possibly because of a prologue on the hook function). I could be on the wrong track though, I'm on my mobile.\n",
            "time": null
        },
        {
            "user": "Neijwiert",
            "text": "I will post the information at the crash location asap. I forgot to turn on teamviewer on the PC I'm doing this at, so I can't take a look at it right now.\n",
            "time": null
        },
        {
            "user": "Neijwiert",
            "text": "@Samson could it be that it uses __vectorcall? I have never used this calling convention before and only just found out about its existence. But it seems that 'intensity' would then be passed on xmm0? I'm also not sure if I can use this convention. My environment must be using the visual studio 2012 xp build tools.\n",
            "time": null
        },
        {
            "user": "Willem Hengeveld",
            "text": "You have to pass a3, a5 and a6 on the stack,  you will have to re-push them before the call to the original function.\n",
            "time": null
        }
    ],
    "answers_data": []
}