{
    "title": "Which operators use sal, shl, sar or shr",
    "link": "https://reverseengineering.stackexchange.com/questions/20513/which-operators-use-sal-shl-sar-or-shr",
    "content": "Which operators in C language would result in assembly commands such as <pre><code>sal, shl, sar or shr</code></pre> for example?\n",
    "votes": "7",
    "answers": 2,
    "views": "6k",
    "tags": [
        "assembly",
        "c"
    ],
    "user": "PaHa",
    "time": "Jan 31, 2019 at 9:19",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "Hi and welcome to RE.SE. Given the role optimizers play during the transformation of source code to binary, this is a rather tough question which will be hard to answer unless you also provide details on the compiler (and version) you're interested in. Now my guess is also that these are the usual IA-32 mnemonics, but you may also want to indicate the ISA.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "First it should be noted that there are so many architectures out there, each with its own instruction set. Here I assume you mean x86 (and you should indeed tag the proper architecture as 0xC0000022L said above). Most parts of the below answer would apply to other architectures as well, but they may use different mnemonics or lack some mentioned instructions\n<pre><code>SAL</code></pre> and <pre><code>SHL</code></pre> are the same. They're simply aliases to the same opcode because shifting left always fill the vacant bits with 0s. In C <pre><code><<</code></pre> will do a shift left, and whether the shift instruction is printed as SAL or SHL depends on the compiler/disassembler\nOTOH there are 2 versions of right shift because you can fill the bits that were shifted out with zero (logical shift) or the high bit of the old value (arithmetic shift). <pre><code>SAR</code></pre> does an arithmetic shift and <pre><code>SHR</code></pre> does a logical shift. In C the operator for right shifting is <pre><code>>></code></pre>, but the rule depends on the signness of the type:\n\nA right shift on an unsigned type is always a logical shift, therefore <pre><code>SHR</code></pre> will be used\nA right shift on a signed type is implementation defined, i.e. the compiler can choose to do an arithmetic or a logical shift. However almost all modern compilers will do an arithmetic shift (<pre><code>SAR</code></pre>) on signed types (otherwise doing arithmetic shift would be too tricky/clumsy). Some compilers may have an option to select the right shift variant though\n\nPer the C99 standard, section 6.5.7:\n\nThe integer promotions are performed on each of the operands. The type of the result is that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.\nThe result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. If E1 has an unsigned type, the value of the result is E1 × 2E2, reduced modulo one more than the maximum value representable in the result type. If E1 has a signed type and nonnegative value, and E1 × 2E2 is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.\nThe result of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2E2. If E1 has a signed type and a negative value, the resulting value is implementation-defined.\n\n\nHowever there are a lot of other operations that can produce a shift instruction, and various cases that shift operators don't produce a shift instruction\nIt's less common to see <pre><code><</>></code></pre> that are not compiled to a shift instruction, but compilers may optimize <pre><code>x << 1</code></pre> to <pre><code>x += x</code></pre> and you'll see things like <pre><code>ADD eax, eax</code></pre> or <pre><code>LEA ecx, [eax + eax]</code></pre>. On x86 <pre><code>x << i</code></pre> with i ⩽ 3 can also be compiled to <pre><code>LEA eax, [eax*2ⁱ]</code></pre> instead of shift. Of course an output like <pre><code>MUL x, 2</code></pre> is also possible on a hypothetical architecture without shift, or where shift is slower than multiplication\nCompilers are also able to transform complex statements like <pre><code>(x << 1) + (x << 4) + (x << 13)</code></pre> into simpler ones such as a single multiplication by 8210, no more shifts.\nOr GCC recognizes <pre><code>(a ^ b) + (a & b) + (a & b)</code></pre> as well as its the inverse condition <pre><code>(a + b) - (a & b) - (a & b)</code></pre> and optimize them to <pre><code>a + b</code></pre> and <pre><code>a ^ b</code></pre> respectively, so it's possible (in the future) that they'll be able to convert the equivalents <pre><code>(a ^ b) + ((a & b) << 1)</code></pre> and <pre><code>(a + b) - ((a & b) << 1)</code></pre> into <pre><code>ADD</code></pre> and <pre><code>XOR</code></pre> without any shifts at all.\nSee them in action\nFor the other case there are various examples:\n\nMultiplication by a power of 2 is done by a left shift. On x86 there exists the more versatile <pre><code>LEA</code></pre> instruction, so for exponent ⩽ 8 the choice between <pre><code>LEA</code></pre> and <pre><code>SHL</code></pre> depends on the compiler. Array arithmetic also need a lot of multiplication, so a shift is also usually used\nMultiplication by many other constants can also be optimized to a series of ADD/SUB and shifts if that's faster than the <pre><code>MUL</code></pre> instruction itself. Again in x86 occasionally LEA is used instead of shifts\nDivision by a power of 2 is done by a right shift. For unsigned types it's a simple logical shift. For signed types it's an arithmetic shift followed by some other shifts and ADDs to correct the result (since division rounds towards zero, and arithmetic right shift rounds towards -inf)\nDivision by constants will be optimized into a multiplication by the corresponding multiplicative inverse, which may involve some shifts to round the result\nClang even emits an <pre><code>SHR</code></pre> for checking the high bits while doing a division by a non-constant if tuning for microarchitectures from Sandy Bridge onward\nBitfield accesses of course need to use a lot of shifts in architectures without efficient bitfield manipulation like x86. See demo\n...\n\nHere are some illustrations for the mul/div examples. You can easily see that <pre><code>x*15</code></pre> is replaced by <pre><code>x*16 - x</code></pre> and <pre><code>x*33</code></pre> is done by <pre><code>x*32 + x</code></pre>, i.e. <pre><code>(x << 4) - x</code></pre> and <pre><code>(x << 5) + x</code></pre>. Besides, <pre><code>x*8</code></pre> is optimized to <pre><code>lea eax, [0+rdi*8]</code></pre> or <pre><code>shl edi, 3</code></pre> depending on the compiler. The mnemonics <pre><code>SAL</code></pre> and <pre><code>SHL</code></pre> are also freely chosen by the compiler\nI've also put some non-x86 compilers for comparison, because they don't have <pre><code>LEA</code></pre> but may have other shift-related instructions or different shift capabilities beside the normal shift instructions. You can change between various x86 as well as non-x86 compilers to see the differences between their outputs. Another example that combines multiple things I've said above:\n<pre><code>struct bitfield {\n    int x: 10;\n    int y: 12;\n    int z: 10;\n};\n\nint f(bitfield b)\n{\n    int i = b.x*65;\n    int j = b.y/25;\n    int k = b.z/8;\n    return (i << j) + (k >> j);\n}\n</code></pre>\nThat compiles to\n<pre><code>f(bitfield):\n        mov     eax, edi\n        mov     edx, edi\n        sar     edi, 22\n        sal     eax, 10\n        sal     edx, 6\n        sar     eax, 20\n        sar     dx, 6\n        imul    ecx, eax, 5243\n        sar     ax, 15\n        sar     ecx, 17\n        sub     ecx, eax\n        movsx   eax, dx\n        mov     edx, eax\n        movsx   ecx, cx\n        sal     edx, 6\n        add     edx, eax\n        lea     eax, [rdi+7]\n        sal     edx, cl\n        test    di, di\n        cmovns  eax, edi\n        sar     ax, 3\n        cwde\n        sar     eax, cl\n        add     eax, edx\n        ret\n</code></pre>\nYou can open the Godbolt link to see which instruction corresponds to which line of code in color\nIn summary: Compilers nowadays are really smart and can output \"surprising\" results to a normal people. They can emit a shift instruction for pretty much any operators in C. With an optimizing compiler, all bets are off\nSee also\n\nAre the shift operators (<<, >>) arithmetic or logical in C?\nArithmetic bit-shift on a signed integer\nImplementation of logical right shift of negative numbers in c\nSigned right shift: which compiler use logical shift\nBitwise Shift Operators in MSVC\nBitwise shift in GCC\nShift operators - cppreference\n",
            "votes": "12",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<pre><code>int main (void){\n    unsigned int    uin =  0x1000;\n    signed int      sin = -0x1000;\n   return (uin<<8)+(uin>>8)+(sin<<8)+(sin>>8);   \n}\n</code></pre>\ncompiled and linked with \n<pre><code>cl /Zi /W4 /Od /analyze /nologo salsaar.cpp /link /release\n</code></pre>\ndisassembled\n<pre><code>:\\>cdb -c \"uf salsaar!main;q\" salsaar.exe | grep -A 20 Reading\n0:000> cdb: Reading initial command 'uf salsaar!main;q'\nsalsaar!main:\n01121000 55              push    ebp\n01121001 8bec            mov     ebp,esp\n01121003 83ec08          sub     esp,8\n01121006 c745fc00100000  mov     dword ptr [ebp-4],1000h\n0112100d c745f800f0ffff  mov     dword ptr [ebp-8],0FFFFF000h\n01121014 8b45fc          mov     eax,dword ptr [ebp-4]\n01121017 c1e008          shl     eax,8\n0112101a 8b4dfc          mov     ecx,dword ptr [ebp-4]\n0112101d c1e908          shr     ecx,8\n01121020 03c1            add     eax,ecx\n01121022 8b55f8          mov     edx,dword ptr [ebp-8]\n01121025 c1e208          shl     edx,8\n01121028 03c2            add     eax,edx\n0112102a 8b4df8          mov     ecx,dword ptr [ebp-8]\n0112102d c1f908          sar     ecx,8\n01121030 03c1            add     eax,ecx\n01121032 8be5            mov     esp,ebp\n01121034 5d              pop     ebp\n01121035 c3              ret\n</code></pre>\nnote shl and sal are both same (opcodes are same and work same ) shr and sar are not same due to signed unsigned diffferences\n",
            "votes": "4",
            "user": "blabb",
            "time": "Jan 30, 2019 at 18:50",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Nordwald",
                    "text": "<span class=\"comment-copy\">Also: Division and Multiplication through optimization: <a href=\"https://en.wikipedia.org/wiki/Multiplication_algorithm#Shift_and_add\" rel=\"nofollow noreferrer\">en.wikipedia.org/wiki/Multiplication_algorithm#Shift_and_add</a></span>",
                    "time": null
                },
                {
                    "user": "PaHa",
                    "text": "<span class=\"comment-copy\">I noticed that in my case 2*30 produced: shl  dword ptr [rbp-4], 1</span>",
                    "time": null
                }
            ]
        }
    ]
}