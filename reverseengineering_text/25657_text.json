{
    "title": "Recognize of data block",
    "link": "https://reverseengineering.stackexchange.com/questions/25657/recognize-of-data-block",
    "content": "Assembler code from data segment:\n<pre><code>.data:006A5038 dword_6A5038    dd 0\n.data:006A5038                   \n.data:006A503C ; char *off_6A503C\n.data:006A503C off_6A503C      dd offset aOption0\n.data:006A503C                                   \n.data:006A503C                                   \n.data:006A5040 dword_6A5040    dd 1              \n.data:006A5040                                   \n.data:006A5044                 dd offset aOption1\n.data:006A5048                 db    2\n.data:006A5049                 db    0\n.data:006A504A                 db    0\n.data:006A504B                 db    0\n.data:006A504C                 dd offset aOption2\n.data:006A5050                 db    3\n.data:006A5051                 db    0\n.data:006A5052                 db    0\n.data:006A5053                 db    0\n.data:006A5054                 dd offset aOption3\n.data:006A5058                 db    4\n\n..................................................\n.data:006A5294                 dd offset aOption4bh\n.data:006A5298                 db  4Ch ; L\n.data:006A5299                 db    0\n.data:006A529A                 db    0\n.data:006A529B                 db    0\n.data:006A529C                 dd offset aOption4ch \n.data:006A52A0                 db 0FFh\n.data:006A52A1                 db 0FFh\n.data:006A52A2                 db 0FFh\n.data:006A52A3                 db 0FFh\n</code></pre>\nAssembler code of code segment, it piece of code below is loop, and during this loop checks eax with value 0xffffffff for end of loop; every step of loop to do some opertion with compare this strings named \"options\". i.e. there is string, and string's  numeric indefiner, and for end of loop checks eax if 0xffffffff.\n<pre><code>.text:005334DF                 mov     eax, dword_6A5040[edi*8]\n.text:005334E6                 inc     edi\n.text:005334E7                 cmp     eax, 0FFFFFFFFh\n.text:005334EA                 jnz     loc_533433\n</code></pre>\nQuestion- how this data from data segment (strings and numeric indefiners) might look in high-level languages like c++? May be is it structures, how arranged this structures? It like global variables, because placed in data segment. Thanks in advance!\n",
    "votes": "0",
    "answers": 1,
    "views": "65",
    "tags": [
        "disassemblers"
    ],
    "user": "black4joss",
    "time": "Aug 11, 2020 at 18:24",
    "comments": [],
    "answers_data": [
        {
            "content": "<pre><code>.text:005334DF mov     eax, dword_6A5040[edi*8]\n</code></pre>\n\nedi is multiplied by 8\nedi is a 32 bit  register\nso by inferance edi can range from 0 to 0xffffffff\nso edi can be <pre><code>0*8 = 0,1*8 = 8,2*8=16,.....n*8 =8n,....</code></pre>\nor multiplication table of 8\n\narrays and pointers are represented in x86 assembly with square brackets\nthis <pre><code>6A5040[edi*8]</code></pre> denotes Array Access so\n<pre><code>.data:006A5040 dword_6A5040    dd 1  \n</code></pre>\nwill be the first member of array\nin a higher language this will look like\n<pre><code>*int eax = *(int *)6a5040*</code></pre>  or\n<pre><code>int eax = foo[i]</code></pre>\nwhere foo is an array of some type\nint foo[] = { {1,ptr} , {2,ptr} ,{3.ptr}, ...... ,{n ,ptr} };\ninc edi here index is increased  this will be like <pre><code>i++;</code></pre>\ncmp and jnz will map to a conditional  like\n<pre><code>if (eax != val) {do something}</code></pre>\nor\n<pre><code>while (eax!=val) {do something}\n</code></pre>\nputting all this together one can derive a higher levelcode that would yield similar work flowlike below\n<pre><code>#include <stdio.h> \ntypedef struct _FOO \n{\n    unsigned int a;\n    unsigned int *b;\n}Foo,*PFoo;\nunsigned int  mint[] = {0,1,2,3,4,5,6,7,8,0xffffffff};\nFoo myfoo[] = \n{ \n    {mint[ 0],&(mint[ 0])},\n    {mint[ 1],&(mint[ 1])},\n    {mint[ 2],&(mint[ 2])},\n    {mint[10],&(mint[10])} \n};\nint main (void) \n{\n    int i =0;    \n    while(myfoo[i].a != 0xffffffff)    \n    {\n        printf(\"%u\\t%p\n\",  myfoo[i].a, myfoo[i].b);\n        i++;\n    }\n    return 0;\n}\n</code></pre>\nand disassembly wouldbe like\n<pre><code>0:000> uf .\nfoo!main:\n013410a0 55              push    ebp\n013410a1 8bec            mov     ebp,esp\n013410a3 51              push    ecx\n013410a4 c745fc00000000  mov     dword ptr [ebp-4],0\n\nfoo!main+0xb:\n013410ab 8b45fc          mov     eax,dword ptr [ebp-4]\n013410ae 833cc5f8993801ff cmp     dword ptr foo!myfoo (013899f8)[eax*8],0FFFFFFFFh\n013410b6 742e            je      foo!main+0x46 (013410e6)\n\nfoo!main+0x18:\n013410b8 8b4dfc          mov     ecx,dword ptr [ebp-4]\n013410bb 8b14cdfc993801  mov     edx,dword ptr foo!myfoo+0x4 (013899fc)[ecx*8]\n013410c2 52              push    edx\n013410c3 8b45fc          mov     eax,dword ptr [ebp-4]\n013410c6 8b0cc5f8993801  mov     ecx,dword ptr foo!myfoo (013899f8)[eax*8]\n013410cd 51              push    ecx\n013410ce 6890013801      push    offset foo!__xt_z+0x4 (01380190)\n013410d3 e858000000      call    foo!printf (01341130)\n013410d8 83c40c          add     esp,0Ch\n013410db 8b55fc          mov     edx,dword ptr [ebp-4]\n013410de 83c201          add     edx,1\n013410e1 8955fc          mov     dword ptr [ebp-4],edx\n013410e4 ebc5            jmp     foo!main+0xb (013410ab)\n\nfoo!main+0x46:\n013410e6 33c0            xor     eax,eax\n013410e8 8be5            mov     esp,ebp\n013410ea 5d              pop     ebp\n013410eb c3              ret\n0:000>\n</code></pre>\n",
            "votes": "2",
            "user": "blabb",
            "time": "Aug 11, 2020 at 19:39",
            "is_accepted": true,
            "comments": [
                {
                    "user": "black4joss",
                    "text": "<span class=\"comment-copy\">Thank you very much!</span>",
                    "time": null
                }
            ]
        }
    ]
}