{
    "title": "Need help with reverse engineering camera-related information in a video game",
    "link": "https://reverseengineering.stackexchange.com/questions/18144/need-help-with-reverse-engineering-camera-related-information-in-a-video-game",
    "content": "I've posited a similar question over on the Game Development StackExchange, but I'm going to refine it, elaborate, and piecemeal a more R.E.-specific context with the hope that someone out there has experience with this!\nTo start, I'm looking to create a free-fly cam hack where I can move anywhere with forward orientation always being where my mouse is pointing.\nThe game I'm hacking (single-player-only) auto-moves the player after tasks are completed; there are no instructions bound to player movement with anything but rotation via mouse. This means I'm building in WASD functionality myself, in a sense. I've found an instruction to inject on which allows me to obtain the XYZ coordinates (which change when the game auto-moves the player) of the camera, as well as its rotation data. Thus, I have the following:\n\n\ncamX (Plane) -- Value is a float ranging from negative to positive\ncamY (Plane) -- Value is a float ranging from negative to positive\ncamZ (Up/Down) -- Value is a float ranging from negative to positive\ncamH (Horizontal/Yaw) -- Value is a float in degrees from +180 to -180\ncamV (Vertical/Pitch) -- Value is a float in degrees clamped to +89 to -89\n\n\nWith that information, I've written a script in Lua (for use in Cheat Engine) which allows me to bind directions (forward, backward, left, right, up, and down) to keys (W, A, S, D, Q, and E); however, those simply add/subtract to/from XYZ values along with a speed modifier, meaning if I'm facing forward and moving forward, everything is fine. Turning 180 degress with the mouse, though, effectively means back is forward, left is right, etc.\nWhat I'm looking to achieve is having those directional keys apply to wherever I'm aiming the mouse pointer. So, forward is always where I'm facing, etc.\nWhat I've done so far is some combination of the following:\n\nDownload flycam/freecam scripts from other games and replace relevant instructions/data/etc. with my own.\nAttempt to create my own based on various information I've gathered (example here) and general research of trigonometry and vector calculus as related to game development.\n\nIt seems that no matter how much I think I understand what's going on, I've yet to make this work.\nSomething I've gathered is that it would really behoove me to find where the game stores/references sin and cos information, such that I don't have to calculate those values on my own via something like math.cos()/math.sin() and possibly converting degrees/radians, etc. And even those manual calculations I've tried haven't worked out, so I'm not sure I fully grasp what I need to there.\nBearing all of the aforementioned in mind, here are my questions:\n\nQuestion 1: What do sin/cos values tend to look like, and at what point through a camera/coord-related subroutine might I expect to see\n  them (whether on the stack, in FPU/XMM registers, etc.)? I've gathered\n  that these should be close to where I'm dabbling either in memory or\n  within a subroutine, but I'm just not quite sure what I'm looking for.\nQuestion 2: Are there general approaches through reversing to identify the coordinate system of a game? In the case of the game I'm\n  hacking, it's developed in Unreal Engine 4, so I can simply look up\n  the engine's coordinate system; however, if I wanted to validate\n  such findings (possibly fleshing out if a game is using a custom\n  coordinate system instead of the in-built one) or discover anew when\n  dealing with a custom engine, how I might I do that? Are they values\n  that tend to reside in nearby memory addresses of avatar/camera data,\n  or possibly in registers/on the stack in camera-related subroutines?\nQuestion 3: If I know the coordinate system used in the game, as well as the XYZ and Pitch/Yaw camera values, is there a formulaic way\n  I can calculate sin/cos therewith to then use with a speed modifier to\n  successfully implement a freecam? This, in the event that I cannot find \n  sin/cos within the game to use within my script.\nQuestion 4: I only have a cursory understanding of the trig/calc I've looked up in trying to understand calculations as related to\n  sin/cos. Given a left-hand and right-hand coordinate system with Z\n  being up, along with XYZ, Pitch/Yaw data, and a speed modifier, could\n  someone possibly walk me through the necessary calculations for making\n  forward work in both coordinate systems no matter where the user\n  points the mouse? For example, what exactly the sin/cos values are\n  comprised of at any given time, how/why they matter, and why you would\n  add/sub/mul to appropriately modify XYZ, etc?\n\nApologies for the verbosity and if I'm unknowingly asking questions that require FAR more understanding to adequately answer, but I just wanted to be thorough in explaining my research and efforts up to this point.\nThank you for any guidance you can provide!\n",
    "votes": "2",
    "answers": 2,
    "views": "3k",
    "tags": [
        "assembly",
        "cheat-engine",
        "lua"
    ],
    "user": "dsasmblr",
    "time": "May 1, 2018 at 21:21",
    "comments": [
        {
            "user": "Jongware",
            "text": "Q4 could better be asked at Game Development (but it sounds very broad â€“ it's a wide topic, and there are tons of tutorials available on just that single topic). By the way, are you sure an engine as modern as UnReal would not use quaternions instead?\n",
            "time": null
        },
        {
            "user": "dsasmblr",
            "text": "Yeah, I just figured I would throw Q4 in the mix if someone here happened to be able to roll off an answer or personal recommendations of resources. And yes, I'm certain that--at least with Unreal Engine 4 (which this game is coded in)--quaternions aren't being used...well, at least based on my experience with modifying XYZ values in quaternion-based games I've futzed with in Unity, which tend to warp/distort if modifying just one. The great thing about Unity is, sans obfuscation, it's easy to hook Unity's quaternion method to discover XYZW values. But this whole flycam thing is new to me.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Question 3 & 4 Answer:\nTo move the camera/player in the direction you're facing you can use this function that works on eular angles.  The only addresses you need to find are your current view angles and 3d coordinates.\nYou use it to overwrite the player/camera 3d coordinates.  I do it inside of a GetaSyncKeyState call, so it acts when pressing NUMPAD_1.\nThis function assumes:\n\nX = pitch, Y = Yaw, Z = Roll\nthe Z of your 3D coordinates are the vertical plane\nAngles are in degrees\n\n<pre><code>#define PI 3.1415927f\n\nvec3 { float x,y,z; };\n\nvec3 Add(vec3 src, vec3 dst)\n{\n    vec3 sum;\n    sum.x = src.x + dst.x;\n    sum.y = src.y + dst.y;\n    sum.z = src.z + dst.z;\n    return sum;\n}\n\nfloat DegreeToRadian(float degree)\n{\n    return degree * (PI / 180);\n}\n\nvec3 DegreeToRadian(vec3 degrees)\n{\n    vec3 radians;\n    radians.x = degrees.x * (PI / 180);\n    radians.y = degrees.y * (PI / 180);\n    radians.z = degrees.z * (PI / 180);\n    return radians;\n}\n\nvoid MoveInCameraDirection(vec3 currAngle, vec3& src, float dist)\n{\n    vec3 d;\n\n    d.x = cosf(DegreeToRadian(currAngle.x - 90)) * dist;\n    d.y = sinf(DegreeToRadian(currAngle.x - 90)) * dist;\n    d.z = sinf(DegreeToRadian(currAngle.y)) * dist;\n\n    src = Add(src, d);\n}\n</code></pre>\nExample usage in GetAsyncKetState loop:\n<pre><code>while (1)\n{\n    if (GetAsyncKeyState(VK_NUMPAD1) & 1)\n    {\n        MoveInCameraDirection(localPlayer->angle, localPlayer->pos, 3);\n        Sleep(20);\n    }\n}\n</code></pre>\n\ncurrAngle = your current view angles\nsrc = your current position, passed as reference so the function can\nmodify it\ndist = distance you want to travel per execution, between 1 and 5 is\ngood\n\nCall the function when a key is pressed to fly around, move your mouse to aim your dude as usual. I have a working project with this in it that I inject and it works just fine.  Gravity takes control and you drop slightly per tick but you can also disable gravity client side and then you have full freedom.\n",
            "votes": "1",
            "user": "GuidedHacking",
            "time": "May 5, 2018 at 1:58",
            "is_accepted": false,
            "comments": [
                {
                    "user": "dsasmblr",
                    "text": "<span class=\"comment-copy\">Thanks for posting your solution! It'll be great to keep for future reference.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "After a lot of trial and error, and bits and pieces of the puzzle coming together from a lot of different sources and peoples' help, I'd like to answer my own questions to the extent I feel I'm able to. I hope this helps someone else down the road who runs into this issue.\n\nQuestion 1: What do sin/cos values tend to look like, and at what\n  point through a camera/coord-related subroutine might I expect to see\n  them (whether on the stack, in FPU/XMM registers, etc.)? I've gathered\n  that these should be close to where I'm dabbling either in memory or\n  within a subroutine, but I'm just not quite sure what I'm looking for.\n\nThese values will be the sin and cos of the camera's pitch (vertical movement) and yaw (horizontal movement). They will likely reside somewhere in nearby memory of your camera's pitch/yaw addresses, or within registers while pitch/yaw are being calculated within a subroutine. A game can represent pitch and yaw in either degrees or radians.\nExamples of pitch:\n<pre><code>Range in degrees: -89 to 89 (Example of a clamped range, to avoid flipping)</code></pre>\n<pre><code>Same range in radians: -1.55334 to 1.55334</code></pre>\nExamples of yaw:\n<pre><code>Range in degrees: -180 to 180 (Equaling 360 degrees total)</code></pre>\n<pre><code>Same range in radians: -3.14159 to 3.14159</code></pre>\nIf the game you're reversing has its values stored as degrees, depending on how you plan to calculate sin/cos, you may need to convert degrees to radians. Since Lua is what I used, its degrees-to-radians function is <pre><code>math.rad()</code></pre>. So, math.rad(180) would give us a conversion from 180 degrees to 3.14159 radians.\nWith this value, we can now utilize Lua's <pre><code>math.cos()</code></pre> and <pre><code>math.sin()</code></pre> functions. Suppose we are looking for the sin and cos of the camera's yaw while it's at 63 degrees. The values we would be looking for in memory, on the stack, or in registers are 0.4539 (cosine, or <pre><code>math.cos(63)</code></pre>) and 0.891007 (sine, or <pre><code>math.sin(63)</code></pre>), respectively.\nFrom a formulaic perspective, here's how we could set variables to give us sin and cos of a camera's yaw in Lua, provided we know the address the value is stored in:\n<pre><code>--Read and store value from camera yaw memory address\nlocal camYaw = readFloat(\"[cameraBase+1D0]\")</code></pre>\n<pre><code>--Convert yaw to radians, then calculate cosine\nlocal camYawCos = math.cos(math.rad(camYaw))</code></pre>\n<pre><code>--Convert yaw to radians, then calculate sine\nlocal camYawSin = math.sin(math.rad(camYaw))</code></pre>\nRemember, if the game you're reversing already has its values stored as radians, you don't have to worry about the step of converting degrees to radians!\nThe formulas above can help you figure out where certain values are residing by allowing you to calculate the values yourself, then simply look for them in memory, on the stack, or in registers.\n\nQuestion 2: Are there general approaches through reversing to identify\n  the coordinate system of a game?\n\nI'm still uncertain about this at the moment. You can figure it out by seeing how your calculations act once you've discovered XYZ Pitch/Yaw, but that's not quite the answer I'd like to know with this. I'll update this answer if/when I figure this out.\n\nQuestion 3: If I know the coordinate system used in the game, as well\n  as the XYZ and Pitch/Yaw camera values, is there a formulaic way I can\n  calculate sin/cos therewith to then use with a speed modifier to\n  successfully implement a freecam? This, in the event that I cannot\n  find sin/cos within the game to use within my script.\nQuestion 4: I only have a cursory understanding of the trig/calc I've\n  looked up in trying to understand calculations as related to sin/cos.\n  Given a left-hand and right-hand coordinate system with Z being up,\n  along with XYZ, Pitch/Yaw data, and a speed modifier, could someone\n  possibly walk me through the necessary calculations for making forward\n  work in both coordinate systems no matter where the user points the\n  mouse? For example, what exactly the sin/cos values are comprised of\n  at any given time, how/why they matter, and why you would add/sub/mul\n  to appropriately modify XYZ, etc?\n\nI'm going to tie both of these together with the script I ended up creating.\nFirst, credit where credit is due. I used SunBeam's Assassin's Creed: Origins script as an initial template. Also, I found examples from the fine individuals contributing to this post to be very illuminating along the way--as well as the answer here by GuidedHacking, and the answer by DMGregory where I initially posted my inquiry. Lastly, this colossal work by Frans Bouma on game camera reversing is a wonderful reference for anyone looking to broach this topic.\nNow, in a left-hand coordinate system, all you should need to plug into this script is the camera's XYZ coordinates, as well as the camera's pitch and yaw. You can change the speed modifier to whatever you would like. I have keys bound to make the camera move faster and slower, and I've also implemented strafing, so you can move diagonally as you rotate.\nThis is a Lua script, created to run in Cheat Engine. The top of the script uses a Cheat Engine function to allocate memory to store the speed modifier value within. I've commented everything copiously, so you should find it relatively easy to convert this to your high-level language of choice if need be!\n<pre><code>globalalloc(speedModifier,8) --Allocate 8 bytes memory\nspeedModifier:\ndd (float)2 --Store a float of 2\n\n{$lua} --Tells Cheat Engine to treat everything beneath as Lua\n\n[ENABLE] --Everything beneath this happens when this script is enabled\n\nfunction checkKeys(timer) --Check keys for input (check on a timer)\n\n--Speed modifier value, read from memory location we allocated earlier\nlocal speed = readFloat(\"speedModifier\")\n\n--Camera coordinates stored in variables\nlocal camx = readFloat(\"[camBase]+1A0\") -- Camera X\nlocal camy = readFloat(\"[camBase]+1A8\") -- Camera Y\nlocal camz = readFloat(\"[camBase]+1A4\") -- Camera Z\n\n--Mouse rotation in radians\n--Use math.rad() to convert from degrees if necessary\nlocal rotv = math.rad(readFloat(\"[camBase]+1D0\")) -- Vertical (Pitch)\nlocal roth = math.rad(readFloat(\"[camBase]+1D4\")) -- Horizontal (Yaw)\n\n--Sine and Cosine of Rotation Values\nlocal sinh = math.sin(roth) -- Sine of Horizontal (Yaw)\nlocal cosh = math.cos(roth) -- Cosine of Horizontal (Yaw)\nlocal sinv = math.sin(rotv) -- Sine of Vertical (Pitch)\nlocal cosv = math.cos(rotv) -- Cosine of Vertical (Pitch)\n\n  --Hotkey Setup\n  --[[\n        Button Mappings:\n\n        Y - Forward\n        G - Left\n        H - Backward\n        J - Right\n        T - Down\n        U - Up\n        C - Speed Up\n        Alt - Slow Down\n\n      --Key combinations for strafing are also defined\n      --Keys are oriented to where mouse is pointing\n  ]]\n\n  --Forward\n  if isKeyPressed(VK_Y) then\n    writeFloat(\"[camBase]+1A0\", camx + (cosh * speed))\n    writeFloat(\"[camBase]+1A8\", camy + (sinv * speed))\n    writeFloat(\"[camBase]+1A4\", camz + (sinh * speed))\n  end\n  --Left\n  if isKeyPressed(VK_G) then\n    writeFloat(\"[camBase]+1A0\", camx + (math.cos(roth - math.rad(90)) * speed))\n    writeFloat(\"[camBase]+1A4\", camz + (math.sin(roth - math.rad(90)) * speed))\n  end\n  --Back\n  if isKeyPressed(VK_H) then\n    writeFloat(\"[camBase]+1A0\", camx - (cosh * speed))\n    writeFloat(\"[camBase]+1A8\", camy - (sinv * speed))\n    writeFloat(\"[camBase]+1A4\", camz - (sinh * speed))\n  end\n  --Right\n  if isKeyPressed(VK_J) then\n    writeFloat(\"[camBase]+1A0\", camx - (math.cos(roth - math.rad(90)) * speed))\n    writeFloat(\"[camBase]+1A4\", camz - (math.sin(roth - math.rad(90)) * speed))\n  end\n  --Forward/Right\n  if isKeyPressed(VK_Y) and isKeyPressed(VK_J) then\n    writeFloat(\"[camBase]+1A0\", camx + (math.cos(roth + math.rad(45)) * speed))\n    writeFloat(\"[camBase]+1A8\", camy + (sinv * speed))\n    writeFloat(\"[camBase]+1A4\", camz + (math.sin(roth + math.rad(45)) * speed))\n  end\n  --Forward/Left\n  if isKeyPressed(VK_Y) and isKeyPressed(VK_G) then\n    writeFloat(\"[camBase]+1A0\", camx + (math.cos(roth - math.rad(45)) * speed))\n    writeFloat(\"[camBase]+1A8\", camy + (sinv * speed))\n    writeFloat(\"[camBase]+1A4\", camz + (math.sin(roth - math.rad(45)) * speed))\n  end\n  --Back/Left\n  if isKeyPressed(VK_H) and isKeyPressed(VK_J) then\n    writeFloat(\"[camBase]+1A0\", camx - (math.cos(roth - math.rad(45)) * speed))\n    writeFloat(\"[camBase]+1A8\", camy - (sinv * speed))\n    writeFloat(\"[camBase]+1A4\", camz - (math.sin(roth - math.rad(45)) * speed))\n  end\n  --Back/Right\n  if isKeyPressed(VK_H) and isKeyPressed(VK_G) then\n    writeFloat(\"[camBase]+1A0\", camx - (math.cos(roth + math.rad(45)) * speed))\n    writeFloat(\"[camBase]+1A8\", camy - (sinv * speed))\n    writeFloat(\"[camBase]+1A4\", camz - (math.sin(roth + math.rad(45)) * speed))\n  end\n  --Up\n  if isKeyPressed(VK_U) then\n   writeFloat(\"[camBase]+1A8\", camy + (speed * 0.5))\n  end\n  --Down\n  if isKeyPressed(VK_T) then\n   writeFloat(\"[camBase]+1A8\", camy - (speed * 0.5))\n  end\n\n  --Speed Modifiers\n  if isKeyPressed(VK_C) then --If C is pressed, increase speed; max of 100\n    if (speed < 100) then\n      writeFloat(\"speedModifier\", speed + 1)\n    end\n  elseif isKeyPressed(VK_MENU) then --If Alt is pressed, slow way down\n    writeFloat(\"speedModifier\", .3)\n  else --If nothing is pressed, normal speed\n    writeFloat(\"speedModifier\", 2)\n  end    \nend\n\nt=createTimer(nil)\ntimer_setInterval(t, 10)\ntimer_onTimer(t, checkKeys)\ntimer_setEnabled(t, true)\n\n[DISABLE] --Everything beneath this happens when the script is disabled\n\ntimer_setEnabled(t, false)\n</code></pre>\n",
            "votes": "1",
            "user": "dsasmblr",
            "time": "May 7, 2018 at 20:58",
            "is_accepted": true,
            "comments": []
        }
    ]
}