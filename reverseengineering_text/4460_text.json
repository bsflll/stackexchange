{
    "title": "Guessing CRC checksum algorithm",
    "link": "https://reverseengineering.stackexchange.com/questions/4460/guessing-crc-checksum-algorithm",
    "content": "I am trying to reverse engineer a 16 bit checksum algorithm of one relatively old (10 years) LAN game that is no longer supported nor has source code available. \nAs it seems, data packets don't have standard structure when it comes to placing checksum bytes:\n<pre><code>Example 1:\n\n1f456e01\n</code></pre>\nWhere first byte <pre><code>1f</code></pre> seems to repeat itself in each packet and I assume it doesn't take part in generating checksum. \nNext two bytes <pre><code>456e</code></pre> represent a checksum that presumably is a variation of <pre><code>CRC-CCITT</code></pre> with non-standard polynomial. \nLastly, <pre><code>01</code></pre> byte represents data.\nHere are few more examples of packets with various data values:\n<pre><code>1f466e02\n1f496e05\n1f4b6e07\n1f4c6e08\n</code></pre>\nI wish I could post more diverse values but these are only ones I've been able to capture so far.\nI tried fiddling with reveng to reverse engineer the polynomial with following command:\n<pre><code>reveng -w 16 -s 01456e 02466e 05496e\n</code></pre>\nHere the checksum bytes are relocated at the end, as reveng expects them in this format. But this gave no results.\nI have tried comparing these checksums to most if not all common crc algorithms using online calculators but none of them give even close outputs to those above.\nHonestly, I don't know where else to look.\nAny hints/help or anything at all is much appreciated.\nEDIT:\nI managed to capture some more samples, however they are slightly different in terms of structure:\nExample 1:\n<pre><code>0e ed76 00 312e362e37544553540000000000000000000000000000000000000000 00\n</code></pre>\nHere the first byte <pre><code>0E</code></pre> represents a sort of index, that I still think doesn't take part in generating checksum.\nThen comes two byte checksum <pre><code>ED76</code></pre> followed by <pre><code>00</code></pre> sort of separator (newline?) byte that I also think doesn't take part in computing checksum.\nAfterwards follows data sequence: <pre><code>312e362e37544553540000000000000000000000000000000000000000</code></pre> which finally is proceeded by <pre><code>00</code></pre> terminating character that I also think has nothing to do with checksum.\nI can manipulate with the data part of this sequence of bytes so here are some more examples:\n<pre><code>Example 2:\n\nHEX:    0E109D00414141414141414141414141414141414141414141414141414141414100\nASCII:  ....AAAAAAAAAAAAAAAAAAAAAAAAAAAAA.\n\nExample 3:\n\nHEX:    0E8DC300424242424242424242424242424242424242424242424242424242424200\nASCII:  ....BBBBBBBBBBBBBBBBBBBBBBBBBBBBB.\n\nExample 4:\n\nHEX:    0E403500313131313131313131313131313131313131313131313131313131313100\nASCII:  .@5.11111111111111111111111111111.\n\nExample 5:\n\nHEX:    0E34CF00353535353535353535353535353535353535353535353535353535353500\nASCII:  .4..55555555555555555555555555555.\n\nExample 6:\n\nHEX:    0E3E0C00313233343536373839304142434445464748494A4B4C4D4E4F5051525300\nASCII:  .>..1234567890ABCDEFGHIJKLMNOPQRS.\n</code></pre>\nEDIT 2:  More samples added, checksum bytes reversed to show the actual 16 bit int (little endian)\n<pre><code>Data         Checksum\n\n0x01         0x6E45  \n0x02         0x6E46\n0x03         0x6E47\n\n0x0001       0x3284\n\n0x0002       0x3285\n0x0003       0x3286\n0x0104       0x32A8\n0x0005       0x3288\n0x0903       0x33AF\n0x0106       0x32AA\n\n0x3600       0x0AAE          \n\n0xAD00       0x1A05          \n\n0xF300       0x230B \n0xF400       0x232C\n0xF500       0x234D\n0xF600       0x236E\n0xF700       0x238F \n0xF800       0x23B0 \n\n0xFE00       0x2476          \n0xA800       0x1960          \n\n0xE200       0x20DA\n0xE500       0x213D          \n0xEE00       0x2266\n\n0x7300       0x128B\n0x7600       0x12EE          \n0xF700       0x238F          \n\n0xB400       0x1AEC\n0xB800       0x1B70          \n0xBC00       0x1BF4\n\n0x015E00     0xF68B\n0x013D00     0xF24A\n0x011C00     0xEE09 \n</code></pre>\nEDIT 3: More samples that might make it easier to see the pattern:\n<pre><code>Checksum     Data (ASCII)\n\n3540         11111111111111111111111111111\n3561         11111111111111111111111111112\n3582         11111111111111111111111111113\n\n3981         11111111111111111111111111121\n39A2         11111111111111111111111111122\n\nc1a1         11111111111111111111111111211\n4DC1         11111111111111111111111112111\n\n5de1         11111111111111111111111121111\n7201         11111111111111111111111211111\n</code></pre>\nEDIT 4:\nThere was a typo in one of EDIT 3 samples - correct checksum for <pre><code>11111111111111111111111112111</code></pre> is <pre><code>4DC1</code></pre> instead of <pre><code>C10E</code></pre>. Edited original sample. Apologies to everyone who lost their time because of this.\nEDIT 5:\nIt turns out, the index byte does play a role in calculating checksum, here is one particular example proving it:\n<pre><code>INDEX   CHECKSUM    PAYLOAD\n\n0x2B    0x704E      0x7E\n0x3E    0x72C1      0x7E\n\nSame payload has different checksum for different indexes. (checksum bytes reversed to show the actual 16 bit int)\n</code></pre>\nSome more samples:\n<pre><code>INDEX   CHECKSUM    PAYLOAD\n\n0x3E    0x72C0      0x7D\n0x1F    0x6E45      0x01\n0x2B    0x704F      0x7F\n</code></pre>\nEpilogue\nPlease see the accepted answer for the exact algorithm. Special thanks to Edward, nrz and Guntram Blohm; solving this would take a lifetime without your help guys!\n",
    "votes": "9",
    "answers": 3,
    "views": "13k",
    "tags": [
        "deobfuscation",
        "decryption",
        "networking"
    ],
    "user": "astralmaster",
    "time": "May 30, 2014 at 21:22",
    "comments": [
        {
            "user": "Ange",
            "text": "can't you locate the routine, for example via memory read/write breeakpoint ?\n",
            "time": null
        },
        {
            "user": "astralmaster",
            "text": "Unfortunately a quick scan with PEID shows that the main executable is packed with ASProtect 1.2x - 1.3x. I could try unpacking it and then following your suggestion, but I thought somebody might've recognized the pattern in crc algorithm\n",
            "time": null
        },
        {
            "user": "Guntram Blohm",
            "text": "Are you sure your example when you change the 4th digit from the right, where the checksum is c10e, is correct? I have an idea, but that would need this checksum to be 4dc1. Maybe you were off by one byte/two hex digits when you copy/pasted that checksum?\n",
            "time": null
        },
        {
            "user": "SSpoke",
            "text": "looking at the packet it looks like a packet counter to make sure you don't inject packets not a checksum.\n",
            "time": null
        },
        {
            "user": "Edward",
            "text": "@astralmaster: in your Edit 2 data, is the first byte of each packet always 0x1f as with the originals?  That is, when you write \"0xBC00 0x1BF4\" I'm interpreting that as coming from a packet that was originally <pre><code>1f f4 1b bc 00</code></pre>.  Is that correct?\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Got it.  Here's how to calculate, using your first string as a simple example:\n<pre><code>1f456e01\n</code></pre>\nFirst, we rearrange the packet, omitting the checksum.\n<pre><code>1f 01\n</code></pre>\nThen prepend the values A3 02:\n<pre><code>a3 02 1f 01\n</code></pre>\nThen calculate the checksum by starting with a sum of 0, multiplying the sum by 33 (decimal) each time and adding the value of the next byte.\nHere it is in C with a few of your sample strings for illustrations.  Note that this assumes a little-endian machine (e.g. x86).\n<pre><code>#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n\nconst unsigned char s1[]= \"\\x0e\\x01\\x72\\x00\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x31\\x32\\x31\\x31\\x31\\x31\\x31\\x00\";\nconst unsigned char s2[]=\"\\x2b\\x4f\\x70\\x7f\";\nconst unsigned char s3[]=\"\\x1f\\x46\\x6e\\x02\";\n\nuint16_t verify(const unsigned char *pkt, size_t sz)\n{\n    uint16_t sum = 0xa3 * 33 + 2;\n    int i;\n    for (i=0; i < sz; ++i) {\n        if ((i != 1) && (i != 2))\n            sum = sum*33 + pkt[i];\n    }\n    return sum;\n}\n\nint main()\n{\n    printf(\"calculated %4.4x, actual %4.4x\n\", \n         verify(s1, sizeof(s1)-1), *(uint16_t *)(&s1[1]));\n    printf(\"calculated %4.4x, actual %4.4x\n\", \n         verify(s2, sizeof(s2)-1), *(uint16_t *)(&s2[1]));\n    printf(\"calculated %4.4x, actual %4.4x\n\", \n         verify(s3, sizeof(s3)-1), *(uint16_t *)(&s3[1]));\n    return 0;\n}\n</code></pre>\nHere's the output from that program:\n<pre><code>calculated 7201, actual 7201\ncalculated 704f, actual 704f\ncalculated 6e46, actual 6e46\n</code></pre>\nUpdate:\nI thought it might be useful to describe how I came about this answer so that it may help others in the future.  First, as other answers note, your packets that were identical except for a single bit were invaluable in determining the general checksum algorithm (multiplying by 33 and adding the next byte). \nWhat remained was to determine the starting position which could have included the first byte (the one you're calling the index byte) and/or the length.  When I compared two packets which were identical except for the index byte, and assuming a linear relationship also for these bytes, it was easy to determine that the index byte was \"next to\" the data bytes for calculation purposes.  \nWhen I did that, all of the complete packets among your samples differed from my calculated value (long packets all by the constant <pre><code>0xe905</code></pre> and short packets by <pre><code>0x6a45</code></pre>).  Since the checksum is only 2 bytes, I guessed that there might be a 2-byte initialization value and simply wrote a small program to try all combinations.  I chose one combination (A3 02) but in fact, there are exactly eight combinations that work -- all you need is something that ultimately evaluates to <pre><code>0x1505</code></pre> (5381 decimal).\n",
            "votes": "13",
            "user": "Edward",
            "time": "May 30, 2014 at 21:45",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Guntram Blohm",
                    "text": "<span class=\"comment-copy\">Good job! Beat me by 25 minutes.</span>",
                    "time": null
                },
                {
                    "user": "Edward",
                    "text": "<span class=\"comment-copy\">I've been staring at it for a while.  Puzzles are fun!</span>",
                    "time": null
                },
                {
                    "user": "astralmaster",
                    "text": "<span class=\"comment-copy\">Bullseye! Nice catch on that index byte mate! Indeed, puzzles are fun! The only thing that puzzles me now is that I can't upvote your answer more than once)))</span>",
                    "time": null
                },
                {
                    "user": "Edward",
                    "text": "<span class=\"comment-copy\">@astralmaster: The other answers are valuable, too, I think, in that they nicely explain the process by which one goes about such sleuthing.  I'll add a bit to my answer to explain how I came about this, in the hope that it might help the next person to reverse engineer unknown packets.</span>",
                    "time": null
                },
                {
                    "user": "Xcelled",
                    "text": "<span class=\"comment-copy\">I'd like to add that this algorithm is called <a href=\"http://www.cse.yorku.ca/~oz/hash.html\" rel=\"nofollow noreferrer\">DJB2</a>.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "I'd assume the first byte is a message type ID, the 2nd and 3rd bytes are checksum, and the rest is payload. As the game is probably an i386 game, the payload ought to be little-endian. Now, if we compare your first 4 examples, with bytes 2 and 3 written as a 16-bit-int, we have:\n<pre><code>1f 6e45 01\n1f 6e46 02\n1f 6e49 05\n1f 6e4b 07\n1f 6e4c 08\n</code></pre>\nin these cases the checksum is always 0x6E44 plus the payload byte. This looks like a simple checksum algorithm to me, not a crc algorithm.\n(Maybe your game's name could be abbreviated as E N or N E, which could explain why the programmer used 0x6E44 as seed for his checksum?)\nIn your example 2 and 3, the checksum difference is C38D-9D10=267C (9853 decimal) which is a lot more than is explained by a few byte-wise +1 additions, so the bytes probably get multiplied by something depending on their position. Which would mean the checksum is\n<pre><code>0x6E44+sum(byte[i]*weight[i])\n</code></pre>\nwhere i runs from 0 to the number of bytes.\nI'd start out with your version packet set to 11111, then 21111, then 31111, 41111, then 12111, 13111, 14111, then 11211, 11311, 11411, .... to see if\n\nincreasing a byte at a certain position always results in the same difference in checksum\nthose bytes have different weight, and find a pattern which byte position increases the checksum by how much, to get the <pre><code>weight</code></pre> values in above equation.\n\nEdit\nI have a program that almost works. As always, take it as an example of something quickly thrown together, not of good programming style. The last byte has a multiplier of 1; the multiplier for every other byte (n) is 33 (0x21) times the multiplier of (n+1).\n<pre><code>void chksum(char *s) {\n    int i, b, l, sum, fact;\n\n    if ((l=strlen(s))%2!=0) {\n        printf(\"not an even number of digits\n\");\n        exit(2);\n    }\n    l/=2;\n\n    if (l==1)                       { sum=0x6e44; }\n    else if (l==2 && s[0]<='2')         { sum=0x3283; }\n    else if (l==2 && s[0]>='3')         { sum=0x03B8; }\n    else if (l==31)                     { sum=0xd753; }\n    else            {\n        printf(\"unknown seed for %d bytes\n\", l);\n        exit(3);\n    }\n\n    fact=1;\n    for (i=l-1; i>=0; i--) {\n        sscanf(s+2*i, \"%02x\", &b);\n        sum+=b*fact; sum &=0xffff;\n        fact*=0x21;    fact&=0xffff;\n    }\n    printf(\"checksum is %04x\n\", sum);\n}\n\nvoid allsums() {\n    int i;\n    char *samples[]={\n        \"01\", \"02\", \"03\",\n        \"0001\", \"0002\", \"0003\", \"0104\", \"0005\", \"0903\", \"0106\",\n        \"3600\", \"ad00\", \"f300\", \"f400\", \"f500\", \"f600\", \"F700\", \"f800\",\n        \"fe00\", \"a800\", \"e200\", \"e500\",\n\n        \"00313131313131313131313131313131313131313131313131313131313100\",\n        \"00313131313131313131313131313131313131313131313131313131313200\",\n        \"00313131313131313131313131313131313131313131313131313131313300\",\n        \"00313131313131313131313131313131313131313131313131313131323100\",\n        \"00313131313131313131313131313131313131313131313131313131323200\",\n        \"00313131313131313131313131313131313131313131313131313132313100\",\n        \"00313131313131313131313131313131313131313131313131313231313100\",\n        \"00313131313131313131313131313131313131313131313131323131313100\",\n        \"00313131313131313131313131313131313131313131313132313131313100\",\n\n        \"00414141414141414141414141414141414141414141414141414141414100\",\n        \"00424242424242424242424242424242424242424242424242424242424200\",\n        \"00353535353535353535353535353535353535353535353532353535353500\",\n        \"00313233343536373839304142434445464748494A4B4C4D4E4F5051525300\",\n    };\n\n    for (i=0; i<sizeof(samples)/sizeof(char *); i++) {\n        printf(\"%s: \", samples[i]);\n        chksum(samples[i]);\n    }\n}\n\nint main(int argc, char **argv) {\n\n    if (argc==2) {\n        chksum(argv[1]);\n    } else if (argc==1) {\n        allsums();\n    } else {\n        printf(\"bad args\n\");\n        exit(1);\n    }\n}\n</code></pre>\nIt returns your checksums for most test strings; one of your checksums has probably been copy/pasted wrong (see my comment on your post), the last 2 don't seem to match, and what's really ugly is the initial checksum value depending on the length of the string. I'd assume it depends on the type byte (byte one in the packet, before the checksum) as well, so it would probably help if you could add that to your examples.\nEdit 2\nWhat @Edward said. Initialize the checksum to 0, and prepend A3 02 and the type byte to the string, then use the above algorithm.\n",
            "votes": "8",
            "user": "Guntram Blohm",
            "time": "May 30, 2014 at 21:03",
            "is_accepted": false,
            "comments": [
                {
                    "user": "astralmaster",
                    "text": "<span class=\"comment-copy\">Interesting! Thank you, Im trying these now</span>",
                    "time": null
                },
                {
                    "user": "astralmaster",
                    "text": "<span class=\"comment-copy\">Yes indeed, the index byte does take part in calculating checksum. Check my last edit in the original post</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "The checksum is very simple, as can be seen from the minimal difference in checksum between <pre><code>11111111111111111111111111111</code></pre> and <pre><code>11111111111111111111111111112</code></pre>, the difference is 0x21 (33 in decimal).\nThen, difference between <pre><code>11111111111111111111111111121</code></pre> and <pre><code>11111111111111111111111111111</code></pre> is 0x441, that is 0x21^2.\nThe checksum (I'll call it <pre><code>y</code></pre>) is clearly a linear function of the terms (bytes) of the payload (29 bytes, I'll call them <pre><code>x1</code></pre> ... <pre><code>x29</code></pre>), each byte having its' own coefficient (multiplier, beta, you name it, I'll call them <pre><code>b1</code></pre> ... <pre><code>b29</code></pre>) and then there is a constant term (I'll call it <pre><code>c</code></pre>), in the following form:\n\ny = b1*x1 + b2*x2 + b3*x3 + ... + b27*x27 + b28*x28 + b29*x29 + c\n\nWe know already that <pre><code>b29</code></pre> is 0x21, from the difference of checksums between payloads <pre><code>11111111111111111111111111111</code></pre> and <pre><code>11111111111111111111111111112</code></pre>. We also know that <pre><code>b28</code></pre> is 0x441, from the difference of checksums between payloads <pre><code>11111111111111111111111111121</code></pre> and <pre><code>11111111111111111111111111111</code></pre>. Let's assume that coefficients multiply by 0x21 when going through them in reverse order, that is, starting from <pre><code>b29</code></pre> (0x21), then <pre><code>b28</code></pre> (0x441), ... At some point there will be overflow for 16-bit integers, but that does not matter, we only need the lowest 16 bits.\nNow we have an idea of all coefficients <pre><code>b1</code></pre> ... <pre><code>b29</code></pre>. We only need to find out the constant <pre><code>c</code></pre>. Well, it's very easy, it's the difference between the correct checksum and the checksum computed with <pre><code>c</code></pre> = 0. For <pre><code>11111111111111111111111111111</code></pre> the checksum with <pre><code>c == 0</code></pre> is 0x5ded, so well subtract from 0x3540 (the correct checksum) the computed checksum 0x5ded to get the correct constant <pre><code>c</code></pre>. The value of <pre><code>c</code></pre> is therefore <pre><code>0x3540 - 0x5ded = -0x28ad</code></pre>.\nTo try this solution (these betas <pre><code>b1</code></pre> ... <pre><code>b29</code></pre> and this constant <pre><code>c</code></pre>) to all given samples I wrote a simple Common Lisp program, here's the code:\n\n(defparameter *ascii-checksum-data* (list (list \"11111111111111111111111111111\" #x3540)   ; OK.\n                                          (list \"11111111111111111111111111112\" #x3561)   ; OK.\n                                          (list \"11111111111111111111111111113\" #x3582)   ; OK.\n                                          (list \"11111111111111111111111111121\" #x3981)   ; OK.\n                                          (list \"11111111111111111111111111122\" #x39a2)   ; OK.\n                                          (list \"11111111111111111111111111211\" #xc1a1)   ; OK.\n                                          (list \"11111111111111111111111112111\" #xc10e)   ; does not match, produces 4dc1.\n                                          (list \"11111111111111111111111121111\" #x5de1)   ; OK!\n                                          (list \"11111111111111111111111211111\" #x7201)   ; OK.\n                                          (list \"1234567890ABCDEFGHIJKLMNOPQRS\" #x0c3e)   ; OK.\n                                          (list \"55555555555555555555555555555\" #xcf34)   ; OK.\n                                          (list \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" #x9d10)   ; OK.\n                                          (list \"BBBBBBBBBBBBBBBBBBBBBBBBBBBBB\" #xc38d))) ; ok.\n\n(defun ascii-to-numeric (my-string)\n  \"This function converts an ASCII string into a list of ASCII values.\"\n  (map 'list #'(lambda (x)\n                 (char-code (coerce x 'character)))\n       my-string))\n\n(defun compute-checksum (bytes-list)\n  \"This function computes the checksum for a given list of bytes.\"\n  (let\n    ((multiplier #x21)\n     (checksum 0))\n    (loop for i from (1- (length bytes-list)) downto 0\n          do (progn\n               (incf checksum (* multiplier (nth i bytes-list)))\n               (setf multiplier (* #x21 multiplier))))\n    (logand (+ checksum (- #x3540 #x5ded)) #xffff)))\n\n(defun compute-all-checksums (checksum-data)\n  \"This function computes and prints all checksums for a given list of lists of checksum data.\"\n  (format t \"~29a ~8x ~5x ~a~%\" \"payload\" \"computed\" \"given\" \"matches\")\n  (loop for checksum-list in checksum-data\n        do (let*\n             ((payload (first checksum-list))\n              (computed-checksum (compute-checksum (ascii-to-numeric payload)))\n              (given-checksum (second checksum-list))\n              (matches (if (eql computed-checksum given-checksum) \"Y\" \"N\")))\n             (format t \"~a ~8x ~5x ~a~%\" payload computed-checksum given-checksum matches))))\n\n(defun do-all ()\n  (compute-all-checksums *ascii-checksum-data*))\n\nCompiles at least with SBCL. Then running <pre><code>(do-all)</code></pre> in SBCL REPL produces the following:\n\npayload                       computed given matches\n11111111111111111111111111111     3540  3540 Y\n11111111111111111111111111112     3561  3561 Y\n11111111111111111111111111113     3582  3582 Y\n11111111111111111111111111121     3981  3981 Y\n11111111111111111111111111122     39A2  39A2 Y\n11111111111111111111111111211     C1A1  C1A1 Y\n11111111111111111111111112111     4DC1  C10E N\n11111111111111111111111121111     5DE1  5DE1 Y\n11111111111111111111111211111     7201  7201 Y\n1234567890ABCDEFGHIJKLMNOPQRS      C3E   C3E Y\n55555555555555555555555555555     CF34  CF34 Y\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAA     9D10  9D10 Y\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBB     C38D  C38D Y\n\nThe checksum of payload <pre><code>11111111111111111111111112111</code></pre> is the only one that doesn't match.\nAssuming that the checksum is anyway a linear function, there are two possibilities:\n\nThe coefficients are not correct, this is possible, because at the moment the system (a system of linear equations) is underdetermined. We have 30 unknowns (29 betas and 1 constant) and only 13 equations (13 samples, that is).\nThere is a typo in the given checksum of <pre><code>11111111111111111111111112111</code></pre>.\n\nIf you can produce a total of 30 samples (a fully determined system), all unknowns (29 betas and 1 constant) can be confirmed by solving a system of linear equations.\n",
            "votes": "7",
            "user": "nrz",
            "time": "May 31, 2014 at 3:23",
            "is_accepted": false,
            "comments": [
                {
                    "user": "astralmaster",
                    "text": "<span class=\"comment-copy\">Thank you for your time and help! I am checking these now, as you have correctly guessed, there was a typo in that checksum, the correct one is 4DC1 instead of C10E. I will apply this algorithm to various byte sequences and reply back shortly</span>",
                    "time": null
                }
            ]
        }
    ]
}