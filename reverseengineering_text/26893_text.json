{
    "title": "How to write these 4 example x86 assembly instructions in opcodes, according to the Intel docs?",
    "link": "https://reverseengineering.stackexchange.com/questions/26893/how-to-write-these-4-example-x86-assembly-instructions-in-opcodes-according-to",
    "content": "Okay so I have been studying Chapter 2 of Volume 2 of the Intel Manuals.\nI have as best an understanding as I can get of the ModR/M byte, the REX byte, the SIB byte, and the general instruction encoding (by just reading with no practice or practical tinkering yet). Now, from my understanding, the \"instruction\" encoding is different from the whole \"call\" encoding (as I would call it): that is, the instruction plus the operands. That took me days to realize, and I'm still not certain of it.\nSo I am going to try to apply my knowledge now on these 4 types of calls.\n<pre><code>opcode              instruction           operand encoding\n04 ib               ADD AL, imm8          I\nREX + 80 /0 ib      ADD r/m8*, imm8       MI\n00 /r               ADD r/m8, r8          MR\nREX.W + 03 /r       ADD r64, r/m64        RM\n</code></pre>\nFirst some background:\n\n<pre><code>ib</code></pre> is an unsigned byte\nimm[digit] is an immediate value\ncapital letters in the instruction are registers\nthe operand encoding letters are for referencing the lookup table in the docs, that's it.\nr/m[digit] means register or memory bytes\nr[digit] means only register bytes\n\nLooking at the \"Instruction Operand Encoding\" table, I see this:\n<pre><code>operand encoding    operand 1             operand 2\nRM                  ModRM:reg (r, w)      ModRM:r/m (r)\nMR                  ModRM:r/m (r, w)      ModRM:reg (r)\nMI                  ModRM:r/m (r, w)      imm8\nI                   AL/AX/EAX/RAX         imm8\n</code></pre>\n\nThe (r) means the operand is read.\nThe (w) means the operand is written to.\n\nSo I see those \"operand encoding\" strings like <pre><code>MR</code></pre>. That gives me <pre><code>00 /r</code></pre> from the example instructions. So we have two hex values, <pre><code>00</code></pre>, and then there's the <pre><code>/r</code></pre>. I have re-read it's meaning a dozen times but still don't know what it means.\nI have thought a lot about all of the above parts, but it just feels like something is missing. I can't piece it together to apply this knowledge yet.\nSo already I am lost. I just studied the ModRM, reg, and r/m stuff, but I don't know what they mean here. Going back and rereading.\nThe ModR/M byte is an addressing-form specifier byte. It is divided into 3 parts or \"fields\".\n\n\nThe mod field combines with the r/m field to form 32 possible values: eight registers and 24 addressing modes.\nThe reg/opcode field specifies either a register number or three more bits of opcode information. The purpose of the reg/opcode field is specified in the primary opcode.\nThe r/m field can specify a register as an operand or it can be combined with the mod field to encode an addressing mode.\n\n\nWe don't have to deal with the SIB codes in this question.\nThat doesn't really give me any actionable information. Then there are the rich tables of every value the ModR/M byte takes up in tables 2-1 through 2-3. I am not really sure how the columns and rows line up and what they mean yet.\nSo, I don't know how to write down those 4 examples of instructions into opcodes, even if I were to select registers or memory addresses for them at random.\nSkipping to section 3.1.1.1, I have studied all of the keywords there too.\n\n\nREX.W — Indicates the use of a REX prefix that affects operand size or instruction semantics.\n/digit — A digit between 0 and 7 indicates that the ModR/M byte of the instruction uses only the r/m (register or memory) operand. The reg field contains the digit that provides an extension to the instruction's opcode.\n/r — Indicates that the ModR/M byte of the instruction contains a register operand and an r/m operand.\n\n\nThose 3 are relevant for the instructions above.\nThen there is \"Table 3-1. Register Codes\", which I think shows you something about what the decimal/binary value is of each register, which is useful somewhere in this equation.\nThat's pretty much it on what I need to know. Everything else in this book seems to be the individual instruction details, or the advanced instruction info which I don't care about yet (like <pre><code>VEX</code></pre>).\nBut I've read this stuff about 5 times through so far and I still don't have a solid understanding of how to write 1 instruction call yet, for the goal of writing a machine code generator without using gcc/clang/llvm/etc..\nI see this image too, but don't know what to do with it entirely yet.\n\n\n\nHow do you write these 4 example x86 assembly instructions in opcodes, according to the Intel docs? How do I interpret the \"operand encoding\" values in the table above? Say we select some random registers or slots of memory that fit the instruction type constraints above, then how do you figure out how to write it down into hex code using the Intel Manuals?\n\nThis is somewhat helpful so far.\nThis too. But still not enough yet unfortunately.\nThis too.\n",
    "votes": "1",
    "answers": 1,
    "views": "1k",
    "tags": [
        "assembly",
        "x86",
        "binary"
    ],
    "user": "Lance Pollard",
    "time": "Jan 28, 2021 at 0:33",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "reverseengineering.stackexchange.com/a/3673/60 could be useful\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "This Answer is not a forward engineering answer like you seek\nbut a reverse engineereed answer\nthere exists many utilities,frameworks that can encode  the Mnemonic of Your choice\none of them is the keystone-engine (pip install keystone-engine for python binding)\nusing one of those utilities  we can encode  what we seek to understand\nand look at the encoded bytes and try to make sense of those\nib/r/modrm/sib/rex/lock theories\nshown below is a simple encoding of add r,imm8 variant using keystone\n<pre><code>from keystone import *\nfrom binascii import *\nprint( \"REGISTER_GROUP names are based on legends,epics&lores from arachnid yarn\")\nprint( \"ACCUMULATOR_REGISTER_GROUP  = [AL,AX,EAX,RAX]\")\nprint( \"BASE_REGISTER_GROUP         = [BL,BX,EBX,RBX]\")\nprint( \"COUNT_REGISTER_GROUP        = [CL,CX,ECX,RCX]\")\nprint( \"DATA_REGISTER_GROUP         = [DL,DX,EDX,RDX]\")\nprint( \"Mnemonic Add r,imm8\")\n\nCODE_R_IMM8 = [\nb\"add   al  ,0xff\",\nb\"add   bl  ,0xff\",\nb\"add   cl  ,0xff\",\nb\"add   dl  ,0xff\",\nb\"add   ax  ,0xff\",\nb\"add   bx  ,0xff\",\nb\"add   cx  ,0xff\",\nb\"add   dx  ,0xff\",\nb\"add   eax ,0xff\",\nb\"add   ebx ,0xff\",\nb\"add   ecx ,0xff\",\nb\"add   edx ,0xff\",\nb\"add   rax ,0xff\",\nb\"add   rbx ,0xff\",\nb\"add   rcx ,0xff\",\nb\"add   rdx ,0xff\"\n]\n\nfor i in range (0,len(CODE_R_IMM8),1):\n    print(\"%40s\" % CODE_R_IMM8[i],end=\"\\t\")\n    print(hexlify((Ks(KS_ARCH_X86,KS_MODE_64).asm(CODE_R_IMM8[i],0x10000000,as_bytes=True))[0]))\n</code></pre>\nexecuted\n<pre><code>:\\>python openc.py\nREGISTER_GROUP names are based on legends,epics&lores from arachnid yarn\nACCUMULATOR_REGISTER_GROUP  = [AL,AX,EAX,RAX]\nBASE_REGISTER_GROUP         = [BL,BX,EBX,RBX]\nCOUNT_REGISTER_GROUP        = [CL,CX,ECX,RCX]\nDATA_REGISTER_GROUP         = [DL,DX,EDX,RDX]\nMnemonic Add r,imm8\n                      b'add   al  ,0xff'        b'04ff'\n                      b'add   bl  ,0xff'        b'80c3ff'\n                      b'add   cl  ,0xff'        b'80c1ff'\n                      b'add   dl  ,0xff'        b'80c2ff'\n                      b'add   ax  ,0xff'        b'6605ff00'\n                      b'add   bx  ,0xff'        b'6681c3ff00'\n                      b'add   cx  ,0xff'        b'6681c1ff00'\n                      b'add   dx  ,0xff'        b'6681c2ff00'\n                      b'add   eax ,0xff'        b'05ff000000'\n                      b'add   ebx ,0xff'        b'81c3ff000000'\n                      b'add   ecx ,0xff'        b'81c1ff000000'\n                      b'add   edx ,0xff'        b'81c2ff000000'\n                      b'add   rax ,0xff'        b'4805ff000000'\n                      b'add   rbx ,0xff'        b'4881c3ff000000'\n                      b'add   rcx ,0xff'        b'4881c1ff000000'\n                      b'add   rdx ,0xff'        b'4881c2ff000000'\n</code></pre>\nyou can also refer to this site for explanation of each bytes in the encoded\nbytes of chosen memmonic\n",
            "votes": "1",
            "user": "blabb",
            "time": "Jan 28, 2021 at 5:53",
            "is_accepted": false,
            "comments": []
        }
    ]
}