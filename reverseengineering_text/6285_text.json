{
    "title": "How to recover information stored in .ctors section?",
    "link": "https://reverseengineering.stackexchange.com/questions/6285/how-to-recover-information-stored-in-ctors-section",
    "content": "Test is on x86, 32-bit Linux. I am using <pre><code>g++</code></pre> 4.6.3 and <pre><code>objdump</code></pre> 2.22\nHere is a simple C++ code I am working on:\n<pre><code>#include <iostream>\n\nusing namespace std;\n\nmain()\n{\n    cout << \"Hello World!\" << endl;\n    return 0;\n}\n</code></pre>\nWhen I compile it into assembly code using :\n<pre><code>gcc -S hello.cc\n</code></pre>\nI can find out a <pre><code>ctors</code></pre> section in the hello.s below:\n<pre><code>.section    .ctors,\"aw\",@progbits\n.align 4\n.long   _GLOBAL__sub_I_main\n.weakref    _ZL20__gthrw_pthread_oncePiPFvvE,pthread_once\n.weakref    _ZL27__gthrw_pthread_getspecificj,pthread_getspecific\n.weakref    _ZL27__gthrw_pthread_setspecificjPKv,pthread_setspecific\n.weakref    _ZL22__gthrw_pthread_createPmPK14pthread_attr_tPFPvS3_ES3_,pthread_create\n.weakref    _ZL20__gthrw_pthread_joinmPPv,pthread_join\n.weakref    _ZL21__gthrw_pthread_equalmm,pthread_equal\n.weakref    _ZL20__gthrw_pthread_selfv,pthread_self\n.weakref    _ZL22__gthrw_pthread_detachm,pthread_detach\n.weakref    _ZL22__gthrw_pthread_cancelm,pthread_cancel\n.weakref    _ZL19__gthrw_sched_yieldv,sched_yield\n.weakref    _ZL26__gthrw_pthread_mutex_lockP15pthread_mutex_t,pthread_mutex_lock\n.weakref    _ZL29__gthrw_pthread_mutex_trylockP15pthread_mutex_t,pthread_mutex_trylock\n.weakref    _ZL31__gthrw_pthread_mutex_timedlockP15pthread_mutex_tPK8timespec,pthread_mutex_timedlock\n.weakref    _ZL28__gthrw_pthread_mutex_unlockP15pthread_mutex_t,pthread_mutex_unlock\n.weakref    _ZL26__gthrw_pthread_mutex_initP15pthread_mutex_tPK19pthread_mutexattr_t,pthread_mutex_init\n.weakref    _ZL29__gthrw_pthread_mutex_destroyP15pthread_mutex_t,pthread_mutex_destroy\n.weakref    _ZL30__gthrw_pthread_cond_broadcastP14pthread_cond_t,pthread_cond_broadcast\n.weakref    _ZL27__gthrw_pthread_cond_signalP14pthread_cond_t,pthread_cond_signal\n.weakref    _ZL25__gthrw_pthread_cond_waitP14pthread_cond_tP15pthread_mutex_t,pthread_cond_wait\n.weakref    _ZL30__gthrw_pthread_cond_timedwaitP14pthread_cond_tP15pthread_mutex_tPK8timespec,pthread_cond_timedwait\n.weakref    _ZL28__gthrw_pthread_cond_destroyP14pthread_cond_t,pthread_cond_destroy\n.weakref    _ZL26__gthrw_pthread_key_createPjPFvPvE,pthread_key_create\n.weakref    _ZL26__gthrw_pthread_key_deletej,pthread_key_delete\n.weakref    _ZL30__gthrw_pthread_mutexattr_initP19pthread_mutexattr_t,pthread_mutexattr_init\n.weakref    _ZL33__gthrw_pthread_mutexattr_settypeP19pthread_mutexattr_ti,pthread_mutexattr_settype\n.weakref    _ZL33__gthrw_pthread_mutexattr_destroyP19pthread_mutexattr_t,pthread_mutexattr_destroy\n</code></pre>\nHowever, when I assembly the asm code, producing an exe file and use the <pre><code>objdump</code></pre> produce the <pre><code>ctors</code></pre> section's contain like this:\n<pre><code>objdump -Dr -j .ctors hellocpp\n</code></pre>\nAll I can get is like this:\n<pre><code>hellocpp:     file format elf32-i386\n\n\nDisassembly of section .ctors:\n\n08049efc <__CTOR_LIST__>:\n 8049efc:   ff                      (bad)  \n 8049efd:   ff                      (bad)  \n 8049efe:   ff                      (bad)  \n 8049eff:   ff 00                   incl   (%eax)\n\n08049f00 <__CTOR_END__>:\n 8049f00:   00 00                   add    %al,(%eax)\n ...\n</code></pre>\nCurrently I am trying to recover the content of some ELF binaries compiled from <pre><code>c++</code></pre> program..\nSo I am wondering if there is a way to get the content of <pre><code>ctors</code></pre> which equals to what <pre><code>g++</code></pre> produced?\nUpdate:\nThanks a lot for @Igor's help. But I am still trapped in looking for <pre><code>class's</code></pre> <pre><code>constructor</code></pre> and <pre><code>destructor</code></pre>  info from ELF binary.\nWhen evolving <pre><code>class</code></pre> definition, g++ would produce these info in the <pre><code>.ctors</code></pre> section:\n<pre><code>    .globl  _ZN8ComputerC1Ev\n    .set    _ZN8ComputerC1Ev,_ZN8ComputerC2Ev\n    .globl  _ZN8ComputerD1Ev\n    .set    _ZN8ComputerD1Ev,_ZN8ComputerD2Ev\n</code></pre>\nGenerally <pre><code>_ZN8ComputerC2Ev</code></pre> is the name of a class's constructor while <pre><code>_ZN8ComputerD2Ev</code></pre> is its  destructor.\nHowever, I just can not find corresponding info in the <pre><code>objdump</code></pre> dumped <pre><code>.ctors</code></pre> or <pre><code>.init_array</code></pre> sections.. I also tried <pre><code>.eh_frame</code></pre> and <pre><code>gcc_except_table</code></pre>, but the information dumped is massive.. I can not figure out the meaning of those information..\nCould anyone give me guide?\n",
    "votes": "7",
    "answers": 2,
    "views": "4k",
    "tags": [
        "disassembly",
        "x86",
        "c++",
        "elf"
    ],
    "user": "lllllllllllll",
    "time": "Jun 17, 2020 at 9:54",
    "comments": [],
    "answers_data": [
        {
            "content": "The <pre><code>.ctors</code></pre> section is a list of pointers terminated with -1 (0xFFFFFFFF), so it does not make sense to disassemble it. If you rearrange the bytes as data, you get:\n<pre><code>__CTOR_LIST__: .long 0xffffffff\n__CTOR_END__:  .long 0x00000000\n</code></pre>\nSo, for whatever reason, the resulting exe does not actually use the <pre><code>.ctors</code></pre> section. I suspect the linker instead placed the pointers into the new-style <pre><code>.init_array</code></pre> section. Note that it is, again, a list of pointers, and not code.\nEdit:\nThe <pre><code>.ctors</code></pre> or <pre><code>.init_array</code></pre> sections only contain so-called constructor functions - functions that need to be executed at startup, before the <pre><code>main()</code></pre> itself. These are usually compiler-generated functions that perform construction of global objects (such as <pre><code>cin</code></pre>, <pre><code>cout</code></pre> etc.), or other startup-related tasks. You can, in fact, add your own functions to that list using <pre><code>__attribute__((constructor))</code></pre>.\nWhat does not go there are general C++ class constructors - there is no need to execute those on startup. They will be called when and if you construct an object of a specific class - e.g. by declaring a variable or calling <pre><code>operator new</code></pre>.\n",
            "votes": "9",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": true,
            "comments": [
                {
                    "user": "lllllllllllll",
                    "text": "<span class=\"comment-copy\">Groovy! I dump the content of <code>.init_array</code> section and it contains the address of <code>_GLOBAL__sub_I_main</code> function!</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "As Igor stated, the <pre><code>.ctors</code></pre> section is a list of function pointers, ending with a sentinel value of <pre><code>0xffffffff</code></pre>. To see its contents, just do\n<pre><code>$ objdump -s -j.ctors bar.so\n</code></pre>\nBut your assembly file only contains weak symbols. Those are foreign functions in other libraries, and are invoked when their libraries are loaded at runtime.\nFor example, put this in a file <pre><code>bar.cpp</code></pre>:\n<pre><code>class Foo {\npublic:\n  int i;\n\n  Foo(int n) : i(n) {\n  }\n};\n\nFoo global_foo(123);\n</code></pre>\nCompile with\n<pre><code>$ g++ -shared -fPIC bar.cpp -obar.so\n</code></pre>\nThe contents of the <pre><code>.init_array</code></pre> section is\n<pre><code>$ objdump -s -j.init_array bar.so\n\nbar.so:     file format elf64-x86-64\n\nContents of section .init_array:\n 200820 ad060000 00000000                    ........        \n</code></pre>\nThere's a function pointer there, <pre><code>0xad060000 00000000</code></pre>. But you have to change its endianness, e.g. with Python:\n<pre><code>>>> import struct\n>>> import binascii\n>>> binascii.hexlify(struct.pack(\"<Q\", 0xad06000000000000))\n'00000000000006ad'\n</code></pre>\nNow list all symbols and grep for that address:\n<pre><code>$ objdump -C --syms bar.so | grep 00000000000006ad\n00000000000006ad l     F .text  0000000000000015\n  [... on above line ...] global constructors keyed to bar.cpp\n</code></pre>\nThe disassembly for it,\n<pre><code>$ objdump -C -d bar.so\n</code></pre>\nshows\n<pre><code>00000000000006ad <global constructors keyed to bar.cpp>:\n 6ad:   55                      push   %rbp\n 6ae:   48 89 e5                mov    %rsp,%rbp\n 6b1:   be ff ff 00 00          mov    $0xffff,%esi\n 6b6:   bf 01 00 00 00          mov    $0x1,%edi\n 6bb:   e8 ba ff ff ff          callq  67a <__static_initialization_and_destruction_0(int, int)>\n 6c0:   c9                      leaveq \n 6c1:   c3                      retq   \n</code></pre>\nwhich jumps to <pre><code>__static_initialization_and_destruction_0(int, int)</code></pre>:\n<pre><code>000000000000067a <__static_initialization_and_destruction_0(int, int)>:\n 67a:   55                      push   %rbp\n 67b:   48 89 e5                mov    %rsp,%rbp\n 67e:   48 83 ec 10             sub    $0x10,%rsp\n 682:   89 7d fc                mov    %edi,-0x4(%rbp)\n 685:   89 75 f8                mov    %esi,-0x8(%rbp)\n 688:   83 7d fc 01             cmpl   $0x1,-0x4(%rbp)\n 68c:   75 1d                   jne    6ab <__static_initialization_and_destruction_0(int, int)+0x31>\n 68e:   81 7d f8 ff ff 00 00    cmpl   $0xffff,-0x8(%rbp)\n 695:   75 14                   jne    6ab <__static_initialization_and_destruction_0(int, int)+0x31>\n 697:   be 7b 00 00 00          mov    $0x7b,%esi\n 69c:   48 8b 05 9d 03 20 00    mov    0x20039d(%rip),%rax        # 200a40 <_DYNAMIC+0x1e8>\n 6a3:   48 89 c7                mov    %rax,%rdi\n 6a6:   e8 f5 fe ff ff          callq  5a0 <Foo::Foo(int)@plt>\n 6ab:   c9                      leaveq \n 6ac:   c3                      retq   \n</code></pre>\nwhich puts 123 (<pre><code>0x7b</code></pre>) on the stack and calls <pre><code>Foo::Foo(int)</code></pre>.\n",
            "votes": "5",
            "user": "csl",
            "time": "Jun 3, 2016 at 9:02",
            "is_accepted": false,
            "comments": []
        }
    ]
}