{
    "title": "What symbol tables stay after a strip In ELF format?",
    "link": "https://reverseengineering.stackexchange.com/questions/2539/what-symbol-tables-stay-after-a-strip-in-elf-format",
    "content": "I am currently looking at the ELF format, and especially at stripped ELF executable program files.\nI know that, when stripped, the symbol table is removed, but some information are always needed to link against dynamic libraries. So, I guess that there are other symbols that are kept whatever the executable has been stripped or not. \nFor example, the dynamic symbol table seems to be always kept (actually this is part of my question). It contains all the names of functions coming from dynamic libraries that are used in the program.\nIndeed, taking a stripped binary and looking at the output of <pre><code>readelf</code></pre> on it will give you the following output:\n<pre><code>Symbol table '.dynsym' contains 5 entries:\n Num:    Value          Size Type    Bind   Vis      Ndx Name\n 0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n 1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)\n 2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)\n 3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__\n 4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND perror@GLIBC_2.2.5 (2)\n</code></pre>\nMy question is, what are all the symbol tables that the system always need to keep inside the executable file, even after a strip (and what are they used for) ?\nAnother part of my question, would also be about how to use these dynamic symbols. Because, they are all pointing to zero and not to a valid address. You do we identify, as <pre><code>objdump</code></pre> does, their respective links to the code stored in the PLT. For example, in the following dump I got from <pre><code>objdump -D</code></pre>, we can see that the section <pre><code>.plt</code></pre> is split, I assume that this is thanks to symbols, into subsections corresponding to each dynamic function, I would like to know if this is coming from another symbol table that I do not know or if <pre><code>objdump</code></pre> rebuild this information (and, then, I would like to know how):\n<pre><code>Disassembly of section .plt:\n\n0000000000400400 <puts@plt-0x10>:\n400400:       ff 35 6a 05 20 00       pushq  0x20056a(%rip)\n400406:       ff 25 6c 05 20 00       jmpq   *0x20056c(%rip)\n40040c:       0f 1f 40 00             nopl   0x0(%rax)\n\n0000000000400410 <puts@plt>:\n400410:       ff 25 6a 05 20 00       jmpq   *0x20056a(%rip)\n400416:       68 00 00 00 00          pushq  $0x0\n40041b:       e9 e0 ff ff ff          jmpq   400400 <puts@plt-0x10>\n\n0000000000400420 <__libc_start_main@plt>:\n400420:       ff 25 62 05 20 00       jmpq   *0x200562(%rip)\n400426:       68 01 00 00 00          pushq  $0x1\n40042b:       e9 d0 ff ff ff          jmpq   400400 <puts@plt-0x10>\n\n0000000000400430 <__gmon_start__@plt>:\n400430:       ff 25 5a 05 20 00       jmpq   *0x20055a(%rip)\n400436:       68 02 00 00 00          pushq  $0x2\n40043b:       e9 c0 ff ff ff          jmpq   400400 <puts@plt-0x10>\n\n0000000000400440 <perror@plt>:\n400440:       ff 25 52 05 20 00       jmpq   *0x200552(%rip)\n400446:       68 03 00 00 00          pushq  $0x3\n40044b:       e9 b0 ff ff ff          jmpq   400400 <puts@plt-0x10>\n</code></pre>\nEdit: Thanks to Igor's comment, I found the different offsets allowing to rebuild the information in <pre><code>.rela.plt</code></pre> (but, what is <pre><code>.rela.dyn</code></pre> used for ?).\n<pre><code>Relocation section '.rela.dyn' at offset 0x368 contains 1 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000600960  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0\n\nRelocation section '.rela.plt' at offset 0x380 contains 4 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000600980  000100000007 R_X86_64_JUMP_SLO 0000000000000000 puts + 0\n000000600988  000200000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main + 0\n000000600990  000300000007 R_X86_64_JUMP_SLO 0000000000000000 __gmon_start__ + 0\n000000600998  000400000007 R_X86_64_JUMP_SLO 0000000000000000 perror + 0\n</code></pre>\n",
    "votes": "29",
    "answers": 1,
    "views": "27k",
    "tags": [
        "elf",
        "dynamic-linking"
    ],
    "user": "perror",
    "time": "Jul 26, 2013 at 17:44",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "Print the relocations too.\n",
            "time": null
        },
        {
            "user": "perror",
            "text": "Ah, I didn't notice it first ! I guess you are meaning <pre><code>.rela.dyn</code></pre> and <pre><code>.rela.plt</code></pre>.\n",
            "time": null
        },
        {
            "user": "Ditmar Wendt",
            "text": ".rela.dyn may be related to dynamic linking -- you'd be interested in section 4/5 here uclibc.org/docs/SysV-ABI.pdf\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "To answer to this question, we have first to rephrase it a bit. The real question can be stated like this: \n\nWhat are the symbols that cannot be removed from an ELF binary file ?\n\nIndeed, <pre><code>strip</code></pre> removes quite a bit of information from the ELF file, but it could do a bit more (see the option <pre><code>--strip-unneeded</code></pre> from <pre><code>strip</code></pre> or the program <pre><code>sstrip</code></pre> for more about this). So, my original question was more about what symbols can be assumed to be in the executable file whatever modifications have been made on the ELF file.\nIn fact, there is only one type of symbols that you need to keep whatever happen, we call it dynamic symbols (as opposed at static symbols). They are a bit different from the static ones because we never know in advance where they will be pointing to in memory. Indeed, as they are supposed to point to external binary objects (libraries, plugin), the binary blob is dynamically loaded in memory while the process is running and we cannot predict at what address it will be located.\nIf the static symbols are stored in the <pre><code>.symbtab</code></pre> section, the dynamic ones have their own section called <pre><code>.dynsym</code></pre>. They are kept separate to ease the operation of relocation (the operation that will give a precise address to each dynamic symbol). The relocation operation also relies on two extra tables which are namely: \n\n<pre><code>.rela.dyn</code></pre> : Relocation for dynamically linked objects (data or procedures), if PLT is not used.\n<pre><code>.rela.plt</code></pre> : List of elements in the PLT (Procedure Linkage Table), which are liable to the relocation during the dynamic linking (if PLT is used).\n\nSomehow, put all together, <pre><code>.dynsym</code></pre>, <pre><code>.rela.dyn</code></pre> and <pre><code>.rela.plt</code></pre> will allow to patch the initial memory (i.e. as mapped in the ELF binary), in order for the dynamic symbols to point to the right object (data or procedure).\nJust to illustrate a bit more the process of relocation of dynamic symbols, I built examples in i386 and amd64 architectures.\ni386\n<pre><code>Symbol table '.dynsym' contains 6 entries:\n   Num:    Value  Size Type    Bind   Vis      Ndx Name\n     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND perror@GLIBC_2.0 (2)\n     2: 00000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.0 (2)\n     3: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__\n     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)\n     5: 080484fc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used\n\n\nRelocation section '.rel.dyn' at offset 0x28c contains 1 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n08049714  00000306 R_386_GLOB_DAT    00000000   __gmon_start__\n\nRelocation section '.rel.plt' at offset 0x294 contains 4 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n08049724  00000107 R_386_JUMP_SLOT   00000000   perror\n08049728  00000207 R_386_JUMP_SLOT   00000000   puts\n0804972c  00000307 R_386_JUMP_SLOT   00000000   __gmon_start__\n08049730  00000407 R_386_JUMP_SLOT   00000000   __libc_start_main\n</code></pre>\namd64\n<pre><code>Symbol table '.dynsym' contains 5 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)\n     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)\n     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__\n     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND perror@GLIBC_2.2.5 (2)\n\n\n\nRelocation section '.rela.dyn' at offset 0x368 contains 1 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000600960  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0\n\nRelocation section '.rela.plt' at offset 0x380 contains 4 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000600980  000100000007 R_X86_64_JUMP_SLOT 0000000000000000 puts + 0\n000000600988  000200000007 R_X86_64_JUMP_SLOT 0000000000000000 __libc_start_main + 0\n000000600990  000300000007 R_X86_64_JUMP_SLOT 0000000000000000 __gmon_start__ + 0\n000000600998  000400000007 R_X86_64_JUMP_SLOT 0000000000000000 perror + 0\n</code></pre>\nA few interesting web pages and articles about dynamic linking:\n\nPLT and GOT - the key to code sharing and dynamic libraries;\nStripping shared libraries;\nRedirecting functions in shared ELF libraries;\nThe Art Of ELF: Analysis and Exploitations;\nGlobal Offset Tables;\n",
            "votes": "24",
            "user": "0xC0000022L",
            "time": "Aug 14, 2013 at 19:54",
            "is_accepted": true,
            "comments": [
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">Thanks for the writeup. But, strictly speaking, isn't this dependent on whether you link to anything at all? I realize that with GCC you have to go through hoops to achieve this, but it's still possible. For all I know you could create an ELF file that will literally only use <code>syscall</code> instead of external libraries of any kind. Wouldn't that imply that you can leave out more of the functions you say have to be \"always\" in?</span>",
                    "time": null
                },
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">Yes, you are right. But, in fact, even if you have no call to libc functions in your code, you will get the <code>__libc_start_main</code> function and all the usual framework. To achieve what you want, you need to pass the option <code>-nostdlib</code> to the compiler. Then, you will get a raw ELF binary with no external call to <code>libc</code>.</span>",
                    "time": null
                },
                {
                    "user": "sheltond",
                    "text": "<span class=\"comment-copy\">You said in your answer about the dynamic symbol table \"they are supposed to point to external binary objects\". However, they can also define the positions of functions or data in your file which are exported for use by code that you link to or which links to you. Usually this is seen in dynamic libraries, but you can also see it in top-level executables - for example a lot of C++ programs will redefine \"operator new\" and \"operator delete\", and these will appear in the dynamic symbol table, overriding the ones provided by the standard C++ library.</span>",
                    "time": null
                },
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">@sheltond: You are right. In fact, I do not manipulate C++ binaries a lot in my daily usage, so I tend to forget about their specificities, but, yes, they obviously do such things, I agree.</span>",
                    "time": null
                }
            ]
        }
    ]
}