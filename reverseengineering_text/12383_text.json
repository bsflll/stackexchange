{
    "title": "Can a keygen be created for this protection algorithm? [closed]",
    "link": "https://reverseengineering.stackexchange.com/questions/12383/can-a-keygen-be-created-for-this-protection-algorithm",
    "content": "Closed. This question is off-topic. It is not currently accepting answers.\n                                \n                            \n\n\n\n\n\n\n\n\n\n\n\n Questions asking for help reverse-engineering a specific system are off-topic unless they demonstrate an understanding of the concepts involved and clearly identify a specific problem.\n\n\nClosed 9 years ago.\n\n\n\n\n\n\n\n                        Improve this question\n                    \n\n\n\nI reverse engineered a program protection algorithm and got the result in this source file I wrote, but I would know this type of protection.\nPlease tell me what is the type of this protection ? And is there any ability to create a keygen of this algorithm ?\n<pre><code>#include <stdio.h>\n#include <string.h>\n\nchar* transformStrip = \"123456789ABCDEFGHIJKLMNPQRSTUVWXYZ\";\n\nchar* myusername = \"MYUSERNAME\";\nchar* myserial   = \"MYSERIAL33222222222222222\";\n\n//OK\nint TransformChar(char c)\n{\n    for(int i=0;i<0x22;i++)\n    {\n        if(transformStrip[i] == c)\n            return i;\n    }\n    return 0;\n}\n\n//OK\nbool MagicCalculator1(char* magicBuffer, int number)\n{\n    int a = 0;\n    //int rez = 0;\n    for (int i=0;i<0x20;i++)\n    {\n        int rez = (unsigned char)magicBuffer[i];\n        rez *= number;\n        rez += a;\n        magicBuffer[i] = (unsigned char)rez;\n        if(rez >= 0x100)\n        {\n            a = rez;\n            if(a < 0)\n                a += 0xFF;\n            a >>= 8;\n        }else\n            a = 0;\n    }\n    return (bool)a;\n}\n\nbool MagicCalculator2(char* magicBuffer, int position)\n{\n    int a = 0;\n    for (int i=0;i<0x20;i++)\n    {\n        int rez = magicBuffer[i];\n        a += rez;\n        rez = position + a;\n        magicBuffer[i] = (char) rez;\n        position = 0;\n        if(rez >= 0x100)\n        {\n            a = rez;\n        }else\n            a = 0;\n\n    }\n    return (bool)a;\n}\n\n// sizeof(magicBuffer) = 0x20\n// OK\nint SerialMagicGenerator(char* serial, char* magicBuffer, int number)\n{\n    int serialLength = strlen(serial);\n    if (serialLength <= 0)\n        return 0;\n\n    for(int i=0;i<serialLength;i++)\n    {\n        char c = serial[i];\n        if (c != '\\x20' && c != '\\x2D')\n        {\n            int pos = TransformChar(c);\n            if (MagicCalculator1(magicBuffer, number))\n                return -1;\n            if (MagicCalculator2(magicBuffer, pos))\n                return -1;\n        }\n    }\n    return 0;\n}\n\nunsigned short MagicValidator(char* combinedBuffer, int number)\n{\n    int c = 0;\n    if(number)\n    {\n        for(int i=0;i<number;i++)\n        {\n            int rez = ((unsigned char) combinedBuffer[i]) << 8;\n            c ^= rez;\n            for(int j=0;j<8;j++)\n            {\n                if(c & 0x8000)\n                {\n                    c += c;\n                    c ^= 0x1021;\n                }else\n                    c <<= 1;\n            }\n        }\n    }\n    unsigned short s = (unsigned short) ( ((c & 0xFF) << 8) | ((c & 0xFF00) >> 8) );\n    return s;\n}\n\nbool UsernameMagicVerifier(char* randomizedUsername, char* magicBuffer)\n{\n    char combinedBuffer[0x20];\n    memset(combinedBuffer, 0, 0x20);\n    memcpy(combinedBuffer, randomizedUsername, 0x10);\n    memcpy(combinedBuffer + 0x10, magicBuffer, 0x10);\n    unsigned short mustHaveValue = (unsigned short) (MagicValidator(combinedBuffer, 0x1E) & 0x7FFF);\n    unsigned short foundValue =    (unsigned short) ((*(unsigned short*) (magicBuffer + 0xE)) & 0x7FFF);\n    return (mustHaveValue == foundValue);\n}\n\nbool FinalizerVerifier(void*a, void*b)\n{\n    //assuming this always returns true\n    return true;\n}\n\nchar RandomizedUsernameBuffer[0x10];\n\nchar* RandomizeUsername(char* username)\n{\n    memset(RandomizedUsernameBuffer, 0, 0x10);\n    int usernameLength = strlen(username);\n    if(usernameLength >= 1)\n    {\n        if(usernameLength < 0x10)\n        {\n            int size = (usernameLength >> 2) * 4;\n            memcpy(RandomizedUsernameBuffer, username, size);\n            memcpy(RandomizedUsernameBuffer + size, username + size, usernameLength & 3);\n            if( usernameLength + 1 < 0x10 )\n            {\n                char* ptr;\n                ptr = RandomizedUsernameBuffer + size + (usernameLength & 3) + 1;\n                for(int i=0;ptr<RandomizedUsernameBuffer+0x10;ptr++)\n                {\n                    if( username[i] != '\\0')\n                    {\n                        *ptr = username[i];\n                        i++;\n                    }else\n                        i = 0;\n                }\n            }\n        }\n    }\n    return RandomizedUsernameBuffer;\n}\n\nbool SerialChecker(char* username, char* serial)\n{\n    char magicBuffer[0x20];\n    memset(magicBuffer, 0, 0x20);\n    char* randomizedUsername = RandomizeUsername(username);\n    SerialMagicGenerator(serial, magicBuffer, 0x22);\n    if ( UsernameMagicVerifier(randomizedUsername, magicBuffer) )\n    {\n        return FinalizerVerifier(/*?*/NULL, /*?*/NULL);\n    }\n    return false;\n}\n\nint main()\n{\n    SerialChecker(myusername, myserial);\n    return 0;\n}\n</code></pre>\n",
    "votes": "-1",
    "answers": 1,
    "views": "256",
    "tags": [
        "c",
        "crackme",
        "protection"
    ],
    "user": "Etor Madiv",
    "time": "9 years ago",
    "comments": [],
    "answers_data": [
        {
            "content": "Short, slightly snarky answer: yes, there must be a way to make a keygen. If there wasn't, the creators of the software themselves wouldn't be able to create keys to sell.\nLonger answer: If the software vendor wants the encryption to be non-identifiable for people who have reversed the decryption part, they need to use some assymetric key algorithm, where the public key is embedded into the software, and the private key stays with the vendor. There are well-known algorithms, and corresponding libraries, to do that, like RSA. However, those are not used in your program, once because they are too big, and also because they contain lookup tables which make them easily identifiable.\nFrom a first glance at your algorithm, there's nothing much happening that's too difficult to reverse. Your <pre><code>RandomizeUserName</code></pre> just seems to shuffle the bits of the user name in the same way that the keygen would; your <pre><code>MagicCalculator</code></pre> functions seem to check if the serial number is well-formed, for some definition of well-formed. Then, <pre><code>MagicValidator</code></pre> calculates what looks like a 16-bit CRC on the 16 bytes username + 14 first bytes of the serial, then compares that to bytes 15/16 of the serial.\nSo, a keygen would have to:\n- perform the same calculation on a username that your <pre><code>RandomizeUserName</code></pre> does\n- invent 14 bytes of serial\n- generate the CRC from the randomized user name + serial, and put it into bytes 15/16\n- append 16 more bytes to the serial in a way that <pre><code>MagicCalculator1</code></pre> and 2 are satisfied (return 0), choose any bytes you want to achieve this\n- undo <pre><code>SerialMagicGenerator</code></pre> to get a serial that includes blanks and dashes just like <pre><code>SerialMagicGenerator</code></pre> does.\nSo, with a bit of experimenting and trial-and-error, it should be very well possible to make a key generator for this.\n\nSide note:\nI pondered for a while if it is morally ok to help someone with what\n  is clearly a precursor to software theft. Assuming, in the first\n  place, that the OP hasn't tried to invent a protection algorithm\n  himself, and opened this question to check how \"strong\" his protection\n  is. Unfortunately, even now in 2016, there seem to be lots of\n  programmers - and college spits out more of them every year - who\n  think that \"shuffle a few bits around, pepper with some self-invented\n  maths, and compile to machine language\" makes whatever they want to\n  achieve hard to crack. Of course, we of RE.SE all know it doesn't.\nIn this case, the OP obviously isn't too experienced in reversing, or\n  he wouldn't have asked the question; still, he arrived at a point\n  where he's obviously 1-2 hours away from a working keygen. In\n  answering the question the way I did, i hope to make it obvious that\n  all the bit-shuffling in the \"protection\" algorithm won't help much.\n  If you want to prevent people from creating key generators for your software, use asymmetric encryption, and make sure your private key\n  doesn't get leaked, and if only one future \"software protection\n  coder\" reads this example and learns from it, then my answer will have\n  served its purpose.\n",
            "votes": "4",
            "user": "user2823000",
            "time": "Apr 9, 2016 at 12:11",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Etor Madiv",
                    "text": "<span class=\"comment-copy\">Should I create an algorithm that bruteforce a serial that meet the conditions ? Or is there a way reverse the whole algorithm ?</span>",
                    "time": null
                }
            ]
        }
    ]
}