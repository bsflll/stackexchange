{
    "title": "Tracing odd variant of call analysis failed",
    "link": "https://reverseengineering.stackexchange.com/questions/31476/tracing-odd-variant-of-call-analysis-failed",
    "content": "Disclaimer before I get flogged: I'm playing with a commercial app, for which I have a license, for my own education because building toy C apps has run out of challenge (and I know whats inside).\nThat said, I opened up a .so, the contents of which I know nothing about, and got the dreaded <pre><code>33AB0: call analysis failed</code></pre>. Looking at that line, it's a <pre><code>call</code></pre> to a function, which is an <pre><code>extern</code></pre>. So I know even less about it than the library im looking at. Weirdly that same <pre><code>call</code></pre> happens multiple times before the line causing the error, and it seems IDA is ok with those invokes. It looks like this:\n<pre><code>.text:00033A1C                 mov     dword ptr [esp+18h], 0\n.text:00033A24                 mov     dword ptr [esp+14h], 0\n.text:00033A2C                 mov     [esp+10h], eax\n.text:00033A30                 mov     dword ptr [esp+0Ch], (offset aFmt+1) ; \"fmt\"\n.text:00033A38                 mov     dword ptr [esp+8], 1\n.text:00033A40                 mov     dword ptr [esp+4], offset unk_51988\n.text:00033A48                 mov     dword ptr [esp], 3\n.text:00033A4F                 call    log_dispatch\n.text:00033A54                 jmp     loc_33786\n.text:00033A54 ; ---------------------------------------------------------------------------\n.text:00033A59                 align 10h\n.text:00033A60\n.text:00033A60 loc_33A60:                              ; CODE XREF: ff_init_entry+136↑j\n.text:00033A60                 call    get_sw_date\n.text:00033A65                 mov     dword ptr [esp+8], offset byte_52420\n.text:00033A6D                 mov     [esp+4], eax\n.text:00033A71                 mov     dword ptr [esp], offset aSoftwareVersio \n.text:00033A78                 call    lfmt\n.text:00033A7D                 mov     dword ptr [esp+18h], 0\n.text:00033A85                 mov     dword ptr [esp+14h], 0\n.text:00033A8D                 mov     [esp+10h], eax\n.text:00033A91                 mov     dword ptr [esp+0Ch], (offset aFmt+1) ; \"fmt\"\n.text:00033A99                 mov     dword ptr [esp+8], 1\n.text:00033AA1                 mov     dword ptr [esp+4], offset unk_519E8\n.text:00033AA9                 mov     dword ptr [esp], 3\n.text:00033AB0                 call    log_dispatch    <---- CALL ANALYSIS FAILED\n.text:00033AB5                 jmp     loc_337BC\n.text:00033ABA ; ---------------------------------------------------------------------------\n.text:00033ABA\n.text:00033ABA loc_33ABA:                              ; CODE XREF: ff_init_entry+366↑j\n.text:00033ABA                 mov     dword ptr [esp+4], 1F2h\n.text:00033AC2                 mov     dword ptr [esp], offset aSoftwareDat \n.text:00033AC9                 call    lfmt\n.text:00033ACE                 mov     dword ptr [esp+18h], 0\n.text:00033AD6                 mov     dword ptr [esp+14h], 0\n.text:00033ADE                 mov     [esp+10h], eax\n.text:00033AE2                 mov     dword ptr [esp+0Ch], (offset aFmt+1) ; \"fmt\"\n.text:00033AEA                 mov     dword ptr [esp+8], 1\n.text:00033AF2                 mov     dword ptr [esp+4], offset unk_519A0\n.text:00033AFA                 mov     dword ptr [esp], 3\n.text:00033B01                 call    log_dispatch\n.text:00033B06                 jmp     loc_339EC\n</code></pre>\nSeems obvious it's doing some logging, and IDA believes <pre><code>log_dispatch</code></pre> is <pre><code>int __cdecl log_dispatch(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);</code></pre>, which also seems plausible to me.. How would I go about hunting this down? The answer is appreciated, but the path to find it myself is what I'm endeavoring to learn here..\nUPDATED: In digging more, I found some oddness up in the PLT:\n<pre><code>.plt:00013FA0 ; =============== S U B R O U T I N E =======================================\n.plt:00013FA0\n.plt:00013FA0 ; Attributes: thunk\n.plt:00013FA0\n.plt:00013FA0 ; _DWORD __cdecl std::string::reserve(std::string *__hidden this, unsigned int)\n.plt:00013FA0 __ZNSs7reserveEj proc near              ; CODE XREF: std::operator+<char>(char const*,std::string const&)+41↓p\n.plt:00013FA0                 jmp     ds:off_4F018    ; PIC mode\n.plt:00013FA0 __ZNSs7reserveEj endp\n.plt:00013FA0\n.plt:00013FA6 ; ---------------------------------------------------------------------------\n.plt:00013FA6                 push    18h\n.plt:00013FAB                 jmp     sub_13F60\n.plt:00013FB0\n.plt:00013FB0 ; =============== S U B R O U T I N E =======================================\n</code></pre>\nThe <pre><code>push</code></pre> and <pre><code>jmp</code></pre> outside the subroutine seems strange, though it seems to be the case with every entry in the PLT.. Not sure if this should be a hint to me, but messing with loading options on handling the PLT doesn't seem to change it..\n",
    "votes": "2",
    "answers": 0,
    "views": "91",
    "tags": [
        "ida",
        "disassembly",
        "calling-conventions"
    ],
    "user": "XeroxDucati",
    "time": "Jan 25, 2023 at 21:18",
    "comments": [],
    "answers_data": []
}