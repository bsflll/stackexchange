{
    "title": "Partially correctly decoded strings from pkware zip with known plaintext",
    "link": "https://reverseengineering.stackexchange.com/questions/22000/partially-correctly-decoded-strings-from-pkware-zip-with-known-plaintext",
    "content": "I have a password-protected zip file, where the paths and filenames of each file are encrypted using PKWARE encryption.\nThe password is known and correct, and so is the encryption algorithm.\nI also have sample plaintext, and an application (32-bit closed-source, optimized, no debug symbols) that can correctly decrypt the files.\nBelow is a sample of the partially decrypted file names, alongside some fully decrypted file names.\n\nBelow is a sample of the fully decrypted files, generated by the closed-source program.\n\nAs you can observe, for the majority of the files, the file names can be correctly decrypted. However, for a small set, I get partially decoded file names, and mojibake for the rest.\nSo my question is, why is this happening and what should I do to rectify it? I am confused because I was expecting 100% rubbish if my decryption implementation was wrong. Partially correct output was not really what I expected.\nNote that each file name is independently decrypted, in other words, the decryption of the next file does not depend on the decryption of the previous file.\nThe decryption implementation is more or less the same as that is described here:\n<pre><code>static uint32_t keys[3];\n\n// CRC32_table is from zlib\nuint32_t compute_crc32(uint32_t crc, char c) {\n    return CRC32_table[(crc ^ c) & 0xff] ^ (crc >> 8);\n}\n\nvoid init_keys(const std::string& password) {\n    keys = { 0x12345678, 0x23456789, 0x34567890 };\n    for (size_t i = 0; i < password.size(); ++i)\n        key_update(keys, password[i]);\n}\n\nvoid update_keys(char c) {\n    keys[0] = compute_crc32(keys[0], c);\n    keys[1] = keys[1] + (keys[0] & 0xff);\n    keys[1] = (keys[1] * 0x8088405) + 1;\n    keys[2] = compute_crc32(keys[2], keys[1] >> 24);\n}\n\nchar decrypt_byte() {\n    uint16_t temp = (keys[2] & 0xffff) | 2;\n    return char(((temp * (temp ^ 1))>> 8) & 0xff);\n}\n\nstd::string decrypt(const std::string& password,\n                    const std::string& input) {\n    init_keys(password);\n    auto ret = std::string(input.size(), '\\0');\n    for (int i = 0; i < input.size(); ++i) {\n        char c = input[i] ^ decrypt_byte();\n        update_keys(c);\n        ret[i] = c;\n    }\n    return ret;\n}\n</code></pre>\nNote that the files are still correctly decrypted and unzipped, it is only the file names that are scrambled.\n",
    "votes": "2",
    "answers": 1,
    "views": "130",
    "tags": [
        "windows",
        "decryption",
        "decompress"
    ],
    "user": "user3105833",
    "time": "Aug 29, 2019 at 12:47",
    "comments": [],
    "answers_data": [
        {
            "content": "Afaik the standard ZIP format does not encrypt filenames but only the files' content. So it seems that this software implemented a custom ZIP extension for encrypting filenames based on the same algorithm. It looks like you've got it very close, so now you just need to step through the code in the original binary and your algorithm working on the same data and see where the discrepancy occurs.\n",
            "votes": "1",
            "user": "Igor Skochinsky",
            "time": "Aug 29, 2019 at 19:20",
            "is_accepted": false,
            "comments": [
                {
                    "user": "user3105833",
                    "text": "<span class=\"comment-copy\">Thanks for the response. I have loaded the binary into Ghidra and examined the disassembled routines involved in the decryption of the strings. It is very close, pretty much identical to my current implementation with some optimizations. I will edit my question once I organize the disassembled code a bit. And yes, it is a custom format based on Zip. It can be unzipped normally if the password is supplied; the only difference is that all filenames will remain encrypted.</span>",
                    "time": null
                },
                {
                    "user": "user3105833",
                    "text": "<span class=\"comment-copy\">After further reverse engineering, I realize that the input string itself was different at very strange, specific places. This question no longer has value, but I lack reputation to do anything meaningful.</span>",
                    "time": null
                }
            ]
        }
    ]
}