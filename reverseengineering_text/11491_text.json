{
    "title": "Manual Segmentation of Objects in non-Intel Firmware",
    "link": "https://reverseengineering.stackexchange.com/questions/11491/manual-segmentation-of-objects-in-non-intel-firmware",
    "content": "I am currently working on reversing a firmware file for the older TMS320C5 16-bit microprocessor. I'm using IDA pro to do so and I need to manually create segments for each object contained in the file. I'm asking for a step-by-step procedure to do so. Below is more information on why/what.\nThe TMS320C5, like many other processors, access an internal cache, called the \"Fast Memory\" which is a single 64K page. It loads this memory from the contents of an outside, bigger and slower memory.\nThe firmware file contains a memory image, which is written directly to the slow memory of the device. It operates using a multi-tasking RTOS. Each tasks/process is stored at different locations in the binary file and do not appear to be in any particular order. From my understanding, each task within the file is preceded by 4 words, one of them indicating the base address where the current task will be loaded in fast memory. In some cases, 2 or 3 tasks can be loaded at the same base address in fast memory.\nIt seems that each branch/call instruction within a task uses a direct address within the current page (see figure 3). So they are not relative to the PC (Program Counter) or the contents of some other register. \nOf course, I'd now like that branching and calling instructions be aligned with the proper functions and sections within their segment. While I do not have a strong grasp on segmentation in IDA, I read some other thread such as How to deal with code that change its address among different execution, IDA segmentation problem and Segments in IDA. How to overcome NONAME problem, but none offer a complete solution to what I need, as I do not believe CS/DS and other Intel segments apply here. I could not find any really useful in the IDA PRO book either.\nSo far, it seems I have accomplish 50% of what I need by doing the following:\n\nCreating a new selector using the Selector subview: View > Open Subviews > Selectors.\nRight-click in the subview, select Add Selector.\nCreated some examples as per figure 1 below.\nUsing the command-line and SetSegmentAttr function, I've change the selector of one of the segment: SetSegmentAttr(ScreenEA(), SEGATTR_SEL, 1)\n\nAs an example, there is a task within the firmware which starts at linear address 0xCAEFD. This tasks is loaded at 0x2C00 in fast memory. As such, I'd like to create a segment containing this task and for which the base address is 0x2C00. While I changed the segment of the block using the procedure above, the offset starts at 0x9EF02 (see figure 2). I expected it to starts at 0x0.\nFigure 1: \n\nFigure 2:\n\nI suspect I somewhat need to change the offset somehow. I'm aware of the Move Segment option, but it seems it \"physically\" change the segment to the address, which I do not want since some tasks share the same base address in fast memory (or are close to each other and will overwrite another task). What are the steps I need to complete in order to isolate each task into its own segment so that branches and calls align? For example, in figure 3, I would like IDA to link the <pre><code>BCND 2C1Dh, geq</code></pre> to the corresponding 0x2C1D location within the segment, rather than the corresponding linear address.\nFigure 3:\n\nThanks for any help\n",
    "votes": "4",
    "answers": 1,
    "views": "457",
    "tags": [
        "ida",
        "disassembly",
        "firmware",
        "segmentation"
    ],
    "user": "InfectedPacket",
    "time": "Apr 13, 2017 at 12:49",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "this may be of help, especially the examples.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Not an answer, really, but too long for a comment; also, i know the x86 architecture well, but have no idea about the TMS320C5, so please take this with a grain of salt.\nI'm afraid that what you're trying to do doesn't match well with how IDA segmentation works, which basically stems from the 80x86 way of doing things. Which means that segment registers contain the upper 16 bit of the 20 bit address, offsets contain the lower 16 bit; and to calculate the physical address, you'd do <pre><code>segment<<4 | offset</code></pre>.\nThat means that an address like, say, <pre><code>1234:0020</code></pre> is equivalent to <pre><code>1236:0000</code></pre> - both map to the physical address of <pre><code>12360</code></pre>. Now if your binary gets loaded at segment <pre><code>1234</code></pre> - physical address <pre><code>12340</code></pre> - there is no \"intrinsic\" way of telling what the offset of <pre><code>12360</code></pre> is; it could be <pre><code>0020</code></pre> within the <pre><code>1234</code></pre> segment, or <pre><code>0000</code></pre> in the <pre><code>1236</code></pre> segment. IDA segmentation will just tell the disassembler that a new segment starts at the <pre><code>12360</code></pre> physical address, so if the <pre><code>ds</code></pre> register is set to that segment, then <pre><code>ds:0</code></pre> accesses the variable that<pre><code>s defined at that</code></pre>12360` address.\nThis is different to your processor insofar that code will never be swapped in or out, code regions never overlap in physical memory, and offsets within segments always start at <pre><code>0000</code></pre>. Even if, in pathological cases, the metainfo .EXE file states to load a segment to offset <pre><code>0200</code></pre>, the loader will generate a new segment, fill the first 0x200 bytes with <pre><code>00</code></pre>, and load the contents from the .EXE file behind this zero'd out block.\nWhat IDA can't do - as far as i know - is something like \"make <pre><code>0000-CAEFD</code></pre> one segment; then start another segment at <pre><code>C82FD</code></pre> in which the address <pre><code>CAEFD</code></pre> has an offset of <pre><code>2C00</code></pre>, because that would make the meaning of the file part between <pre><code>C82FD</code></pre> and <pre><code>CAEFD</code></pre> ambigous, you wouldn't know which segment it belongs to.\nIn your case, when you said the base address should be <pre><code>2C00</code></pre>, you told IDA that address <pre><code>2C00</code></pre> in the file should equal address <pre><code>0000</code></pre> in the segment. This is why it was showing offset <pre><code>9EF02</code></pre>; if <pre><code>2C00</code></pre> (file position) corresponds to <pre><code>0000</code></pre> (segment start), then <pre><code>CAEFD-2C00=9EF02</code></pre> (file position) corresponds to <pre><code>9EF02</code></pre> (position within segment). Try using <pre><code>9EF02</code></pre> as segment start; the byte at <pre><code>CAEFD</code></pre> is <pre><code>2C00</code></pre> bytes into that segment so it has an offset of <pre><code>2C00</code></pre>.\nIf that doesn't work for you, i'd do the following:\n\nIf the size of my original firmware isn't a multiple of 64K, append <pre><code>\\0</code></pre> bytes until it is.\nWhen i identify a task and the offset it should be executed at, append as many <pre><code>0</code></pre> bytes as are needed to reach the start address of that task, copy the task itself, and append more <pre><code>\\0</code></pre> bytes to reach a multiple of 64K again.\n\nDoing this, you'll get a file that has one big block that contains the original firmware, and multiple 64-KB-blocks that contain just one task and a bunch of zeroes each.\nNow, when you load that file, define one segment for the first big block, and one segment for each of the appended 64 KB chunks. That way, you can have one segment per task; segments are easy to define since each of them starts at a multiple of <pre><code>10000</code></pre> and all but the first are exactly <pre><code>10000</code></pre> bytes in size, and you have a 1:1 relation between <pre><code>file byte</code></pre> and <pre><code>memory byte</code></pre> which should make IDA happy.\n",
            "votes": "3",
            "user": "Guntram Blohm",
            "time": "Dec 10, 2015 at 8:36",
            "is_accepted": true,
            "comments": [
                {
                    "user": "InfectedPacket",
                    "text": "<span class=\"comment-copy\">Hello. So I finally made it happen. I noticed that the firmware appears to be a live snapshot of the memory, as such, I noticed heap management blocks reoccurring around each 1K. Each block contained a value indicating where exactly in the page the next instruction was. Combined with your proposition and IDAPython I was able to cut the file using these blocks. I wrote an empty 64K page, then using this \"bookmark\" and the file.seek(), I wrote the blocks in the 64k file. Everything aligns perfectly now. Thanks!</span>",
                    "time": null
                }
            ]
        }
    ]
}