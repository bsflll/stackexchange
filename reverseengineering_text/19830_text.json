{
    "title": "What is the purpose of these instructions before the main preamble?",
    "link": "https://reverseengineering.stackexchange.com/questions/19830/gcc-adds-code-involving-ecx-in-main",
    "content": "I wrote a small C program below:\n<pre><code>#include <stdlib.h>\nint sub(int x, int y){\n  return 2*x+y;\n}\n\nint main(int argc, char ** argv){\n  int a;\n  a = atoi(argv[1]);\n  return sub(argc,a);\n}\n</code></pre>\nCompiled with gcc 5.4.0 and target 32 bit x86. I got the following in disassembly:\n<pre><code>0804841b <main>:\n 804841b: 8d 4c 24 04           lea    0x4(%esp),%ecx\n 804841f: 83 e4 f0              and    $0xfffffff0,%esp\n 8048422: ff 71 fc              pushl  -0x4(%ecx)\n 8048425: 55                    push   %ebp\n 8048426: 89 e5                 mov    %esp,%ebp\n 8048428: 53                    push   %ebx\n 8048429: 51                    push   %ecx\n 804842a: 83 ec 10              sub    $0x10,%esp\n 804842d: 89 cb                 mov    %ecx,%ebx\n....\n</code></pre>\nWhat are the first three instructions before <pre><code>push %ebp</code></pre> doing? I haven't seen those in older gcc compiled binaries.\n",
    "votes": "10",
    "answers": 2,
    "views": "6k",
    "tags": [
        "disassembly",
        "x86",
        "gcc"
    ],
    "user": "Evan Carroll",
    "time": "Apr 17, 2017 at 1:08",
    "comments": [],
    "answers_data": [
        {
            "content": "What the Instructions Are Doing\n\nWhat are the first three instructions before <pre><code>push %ebp</code></pre> doing?\n\nNamely,\n<pre><code> 804841b: 8d 4c 24 04           lea    0x4(%esp),%ecx      <-  1\n 804841f: 83 e4 f0              and    $0xfffffff0,%esp    <-  2\n 8048422: ff 71 fc              pushl  -0x4(%ecx)          <-  3\n</code></pre>\nThis is easy to see if <pre><code>gdb</code></pre> (or some other debugger) is used to step through the code.\n\n\n<pre><code>804841b: 8d 4c 24 04           lea    0x4(%esp),%ecx</code></pre>\n\n\nAt this point in the process, the memory address in register <pre><code>$esp</code></pre> is <pre><code>0xffffd13c</code></pre>, so <pre><code>4(%esp)</code></pre> = <pre><code>$esp+4</code></pre> = <pre><code>0xffffd140</code></pre>:\n<pre><code>>>> x/x $esp+4\n0xffffd140: 0x01\n</code></pre>\nThis means that the <pre><code>lea</code></pre> instruction loads the effective address of <pre><code>0x4(%esp)</code></pre>, <pre><code>0xffffd140</code></pre>, into <pre><code>$ecx</code></pre>.\n\n\n\n<pre><code>804841f: 83 e4 f0              and    $0xfffffff0,%esp</code></pre>\n\n\nNext, the value in <pre><code>$esp</code></pre>, <pre><code>0xffffd13c</code></pre>, is ANDed with <pre><code>0xfffffff0</code></pre>:\n<pre><code>0xffffd13c:            11111111111111111101000100111100\n0xfffffff0:       AND  11111111111111111111111111110000\n                  -------------------------------------\n                       11111111111111111101000100110000\n</code></pre>\nThis results in the value <pre><code>0xffffd130</code></pre>, which is stored in <pre><code>$esp</code></pre>. This is equivalent to \n<pre><code>0xffffd13c</code></pre> - <pre><code>0x0c</code></pre> = <pre><code>0xffffd130</code></pre>.\nThis has the effect of creating 12 bytes of space on the process runtime stack. On a side note, the value -16 would be represented as <pre><code>0xfffffff0</code></pre>, so we could think of \n<pre><code>and $0xfffffff0,%esp</code></pre>\nas\n<pre><code>and $-16,%esp</code></pre>\nThis is done to keep the stack aligned to a 16-byte boundary, since the next instruction (see 3) decrements the stack pointer by 4 and then saves a value to the stack.\n\n\n\n<pre><code>8048422: ff 71 fc              pushl  -0x4(%ecx)</code></pre>\n\n\nAs a result of <pre><code>lea 0x4(%esp),%ecx</code></pre> from earlier, the value in <pre><code>$ecx</code></pre> is equivalent to what had been <pre><code>$esp+4</code></pre> (that is, <pre><code>0xffffd140</code></pre>). As a result,\n<pre><code>-0x4(%ecx)</code></pre> = <pre><code>0xffffd140</code></pre> - 4 = <pre><code>0xffffd13c</code></pre>.\nThis was the value of <pre><code>$esp</code></pre> at the beginning of <pre><code>main()</code></pre>. This value is now saved on the process runtime stack via a <pre><code>pushl</code></pre> instruction. \n\nsummary:\n<pre><code> lea    0x4(%esp),%ecx         // load 0xffffd140 into $ecx\n and    $0xfffffff0,%esp       // subtract 0x0c (decimal 12) from $esp\n pushl  -0x4(%ecx)             // decrement $esp by 4, save 0xffffd13c on stack\n</code></pre>\n\nThe Purpose of these Instructions\n\nWhat is the purpose of these instructions before the main preamble?\n\nA clue about the purpose of these instructions is the fact that they are executed prior to the conventional function prologue:\n<pre><code>8048425: 55                    push   %ebp\n8048426: 89 e5                 mov    %esp,%ebp\n</code></pre>\nAccording to the System V Application Binary Interface Intel386 Architecture Processor Supplment, Fourth Edition, after the execution of the function prologue <pre><code>$ebp+4</code></pre> is the location on the runtime stack of the return address. \n\nThe address saved on the stack at <pre><code>$ebp+4</code></pre> by the instruction \n<pre><code>8048422: ff 71 fc              pushl  -0x4(%ecx)</code></pre>\nis <pre><code>0xffffd13c</code></pre>. This is a pointer to <pre><code>0xf7e12637</code></pre>, the address of offset 247 in <pre><code>__libc_start_main()</code></pre>:\n<pre><code>>>> x/x $ecx-4\n0xffffd13c: 0xf7e12637\n>>> x/x 0xf7e12637\n0xf7e12637 <__libc_start_main+247>: 0x8310c483\n</code></pre>\nThis indicates that the return address of <pre><code>main()</code></pre> is in function <pre><code>__libc_start_main()</code></pre>. \nAs for <pre><code>$ecx</code></pre>, this register simply holds the value of <pre><code>argc</code></pre>:\n<pre><code>>>> x/x $ecx\n0xffffd140: 0x00000001\n</code></pre>\nNote that since variable <pre><code>a</code></pre> is never used, the compiler optimizes out the call to <pre><code>atoi</code></pre>.  \nSo to answer the question directly, the instructions in <pre><code>main()</code></pre> prior to the prologue pass an argument to <pre><code>main()</code></pre> (the value of <pre><code>argc</code></pre>) and save the return address of <pre><code>main()</code></pre> on the runtime stack.\nThe C Runtime Environment and Linux Process Anatomy\nNaturally, the next question is \"What is <pre><code>__libc_start_main</code></pre>?\" According to Linux Standard Base PDA Specification 3.0RC1:\n\nThe <pre><code>__libc_start_main()</code></pre> function shall initialize the process, call the main function with appropriate arguments, and handle the return from <pre><code>main()</code></pre>.\n\nSo where does <pre><code>__libc_start_main()</code></pre> come from? The short answer is that it is a function in the shared object <pre><code>/lib/i386-linux-gnu/libc-2.23.so</code></pre> which is dynamically linked into the executable ELF binary:\n<pre><code> $ ldd [binary_name]\n    linux-gate.so.1 =>  (0xf7764000)\n    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7586000)\n    /lib/ld-linux.so.2 (0x56640000)\n</code></pre>\nIn addition to <pre><code>__libc_start_main()</code></pre>, the function <pre><code>__gmon_start__</code></pre>, also part of process initialization, is dynamically linked to the executable ELF binary as well:\n<pre><code>$ readelf --dyn-syms [binary_name]\n\nSymbol table '.dynsym' contains 5 entries:\n   Num:    Value  Size Type    Bind   Vis      Ndx Name\n     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (2)\n     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__\n     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (3)\n     4: 0804851c     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used\n</code></pre>\nHere is the complete picture, from Linux x86 Program Start Up or - How the heck do we get to main()? by Patrick Horgan:\n\nOn a final note, if the return address of <pre><code>main()</code></pre> of <pre><code>0xf7e12637</code></pre> is examined more closely, we see that this address lies outside of the <pre><code>text</code></pre> segment as well as the runtime stack. This address, located in <pre><code>__libc_start_main()</code></pre>, is actually located in the memory-mapped segment in virtual memory, as shown by this diagram from Gustavo Duarte's article Anatomy of a Program in Memory:\n",
            "votes": "19",
            "user": "sudhackar",
            "time": "Aug 4, 2018 at 8:39",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "What does this do?\nThese three statements serve to move the stackframe of <pre><code>main</code></pre>, beginning with its return address, to the next 16-byte-aligned address.\n<pre><code>lea    0x4(%esp),%ecx    # save address of arguments\nand    $0xfffffff0,%esp  # align stack\npushl  -0x4(%ecx)        # move return address\n...                      # continue normal preamble\n</code></pre>\nAt the same time, the arguments to <pre><code>main</code></pre> (<pre><code>argc</code></pre> and <pre><code>argv</code></pre>) are not moved, so a pointer to them is saved in <pre><code>%ecx</code></pre>.\nRecall the layout of the stack upon entering <pre><code>main</code></pre>:\n<pre><code>%esp+8:  argv (a pointer to an array of pointers)\n%esp+4:  argc (a 32-bit integer)\n%esp+0:  return address (from call)\n</code></pre>\nThe arguments sit right above the return address, so <pre><code>%esp+4</code></pre> is saved to <pre><code>%ecx</code></pre> before the stack pointer is adjusted.\nNext, <pre><code>%ecx</code></pre> also serves as our pointer to locate the original return address, <pre><code>-4(%ecx)</code></pre>, which we push to our new stack frame.\nAfter the rest of the preamble, the stack will look like this:\n<pre><code>%ecx+4:  argv pointer\n%ecx+0:  argc\n%ecx-4:  original return address\n         ...\n%esp+4:  copy of return address\n%esp+0:  saved base pointer\n</code></pre>\nIn your code, you can also see that <pre><code>%ecx</code></pre> is pushed onto the stack (i.e. saved as a local variable) after the preamble; it will be restored from there at the end of the function which will look like this:\n<pre><code>...\nmov    -0x8(%ebp),%ecx   # load pointer to argc\nleave                    # unwind stack frame, pop %ebp\nlea    -0x4(%ecx),%esp   # restore original stack pointer\nret                      # jump out, using the original return address!\n</code></pre>\nWhy is all this done at all?\nModern processors like data aligned to 16-byte boundaries for various reasons; some operations may take significant performance hits otherwise, others might not work at all.\nAdjusting the <pre><code>main</code></pre> stack frame once allows the rest of the code to run without further adjustment as long as care is taken to always allocate stack in multiples of 16 bytes before a call. That is why you will often see something like this:\n<pre><code>sub    $0xc,%esp    # pad stack by 12 bytes\npush   %eax         # push 4-byte argument\ncall   puts\n</code></pre>\nNB: The x86-64 ABI makes the 16-byte stack alignment mandatory. Incidentally this means that you will not find a frame adjustment on <pre><code>main</code></pre> in 64-bit code - the stack is already aligned.\n",
            "votes": "7",
            "user": "pesco",
            "time": "Aug 3, 2018 at 15:36",
            "is_accepted": false,
            "comments": [
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">Welcome! Based on what you have written so far, I look forward to reading your future posts.</span>",
                    "time": null
                },
                {
                    "user": "pesco",
                    "text": "<span class=\"comment-copy\">Thanks! I came here to look this up and afterwards felt that, while your answer is quite elaborate, it was missing a few details. Since as a new user I couldn't comment, I took a shot at my own. Hope you don't mind! :)</span>",
                    "time": null
                },
                {
                    "user": "Evan Carroll",
                    "text": "<span class=\"comment-copy\">I like this better than @SYS_V's answer (no offense to SYS_V). I don't believe SYS_V's answer address \"what is the purpose\". It does a great job of explaining what the instructions do. The answer seems to be very very simple. Above and beyond the obvious alignment-optimization \"At the same time, the arguments to main (argc and argv) are not moved, so a pointer to them is saved in %ecx.\" Beautiful. Thanks a ton.</span>",
                    "time": null
                }
            ]
        }
    ]
}