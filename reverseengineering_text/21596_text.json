{
    "title": "Reconstructing struct/union-based IPC protocol wire format",
    "link": "https://reverseengineering.stackexchange.com/questions/21596/reconstructing-struct-union-based-ipc-protocol-wire-format",
    "content": "I'm embarking on my first reverse-engineering adventure. I think I've picked a rather dense piece of steak to start out with.\nI have three C programs which communicate together using an unknown IPC protocol over TCP sockets.\n\nA Linux armel binary that might be described as the \"target\".\nA Linux x86 binary that provides a \"shell\" or REPL that translates text commands on stdin to IPC I/O against the target. This is a tiny 50KB binary (probably because it was compiled with <pre><code>-O3</code></pre> and then stripped ;D).\nA second Linux armel binary that presents a frontend/UI to the target and incorporates additional IPC-related functionality not found in the REPL.\n\nMy first goal is to understand the fundamentals of the IPC wire format by disassembling the shell/REPL control program. The smallness of the control program is encouraging.\nWith this done, I want to dive into the additional IPC-related functionality only available in the frontend program, which is somewhat bigger (and has noise in the form of UI code).\nI have a very hopeful starting environment: I've gotten the two armel programs running in QEMU (the target, easily enough; the control program, after much effort). The x86 binary trivially runs on my host computer.\nI've also put together a shaky but functional hamster dance of scripts that route the traffic between the two armel programs (incidentally running in separate QEMU VMs, for operational simplicity!) in such a way that I can intercept the traffic at any time.\nAnd so it is that I... take one look at the protocol and have no idea how to proceed:\n\n21:37:21.839965  UI->target   08 00 00 00  01 00 00 01  00 00 00 00  03 00 00 00   .... .... .... ....\n                 UI->target   01 00 00 00                                          .... \n\n21:37:21.892845  target->UI   04 00 00 00  01 00 00 01  00 00 00 00  3a 03 00 00   .... .... .... :...\n\n21:37:21.930144  UI->target   08 00 00 00  06 00 00 01  00 00 00 00  6c 70 70 61   .... .... .... lppa\n                 UI->target   00 00 00 00                                          ....\n\n21:37:21.991124  target->UI   d0 02 00 00  06 00 00 01  00 00 00 00                .... .... ....\n\nI incidentally know what \"lppa\" means - but this small fragment was taken from a 4,000-line protocol dump that clearly shows that the other bytes change in important ways, but I don't have the experience to discern patterns or significance from the changes.\nThe only thing I immediately twigged about was the suspicion that I was looking at C structs dumped straight onto a network. For what this program was and did, that makes a lot of sense (it's for all intents and purposes an internal IPC protocol that doesn't, well, need to be particularly resilient).\nSo, I fired up Ghidra, which I learned about a little while back. Finally, IDA Pro has some competition :)\nI spent some time ambling aimlessly around inside the decompiler, and fairly quickly found the following interesting function that does both <pre><code>recv()</code></pre> and <pre><code>send()</code></pre>.\nBut the way this function works is both really interesting and really confusing.\nI've highlighted some lines below that refer to <pre><code>buffer_length</code></pre> which are really messing with my head.\nWhen I first saw the code around <pre><code>buffer_length</code></pre> I happened to be looking at the second <pre><code>send()</code></pre> call, so it felt natural to rename that variable to describe \"length\".\nBut then I looked at the first <pre><code>send()</code></pre> and found that <pre><code>buf</code></pre> was being pointed to... yeah no that doesn't work.\nSo I now wonder if this might actually a union. YAY.\n(See below for the struct definition)\n\nuint maybe_perform_ipc(astruct *something_struct) {\n\n    char *buf;\n    uint return_code;\n    ssize_t bytecount;\n    size_t message_length;\n\n    bytecount = 0;\n    return_code = 0x30040000;\n    something_struct->only_used_once_and_set_to_256 = 0x100;\n    message_length = 12;\n    buf = (char *)&something_struct->buffer_length;\n\n    while (\n        message_length > 0 &&\n        (bytecount = send(something_struct->socket, buf, message_length, MSG_NOSIGNAL)) > 0\n    ) {\n        message_length -= bytecount;\n        buf += bytecount;\n    }\n\n    if (bytecount > -1) {\n\n        if (something_struct->buffer_length != 0) {\n            message_length = something_struct->buffer_length;\n            buf = (char *)something_struct->buffer;\n            while (\n                message_length > 0 &&\n                (bytecount = send(something_struct->socket, buf, message_length, MSG_NOSIGNAL)) > 0\n            ) {\n                message_length -= bytecount;\n                buf += bytecount;\n            }\n            if (bytecount buf = (char *)&something_struct->buffer_length;\n\n        while (\n            message_length > 0 &&\n            (bytecount = recv(something_struct->socket, buf, message_length, 0)) > 0\n        ) {\n            message_length -= bytecount;\n            buf = buf + bytecount;\n        }\n\n        if (bytecount > -1 && message_length maybe_status_code == 0) {\n\n                my_free_then_realloc((astruct_4 *)something_struct, something_struct->buffer_length);\n\n                if (something_struct->buffer_length != 0) {\n\n                    message_length = something_struct->buffer_length;\n                    buf = (char *)something_struct->buffer;\n\n                    while (\n                        message_length > 0 &&\n                        (bytecount = recv(something_struct->socket, buf, message_length, 0)) > 0\n                    ) {\n                        message_length -= bytecount;\n                        buf = buf + bytecount;\n                    }\n\n                    if (bytecount maybe_status_code | 0x30060000;\n\n            }\n\n        }\n\n    }\n    return return_code;\n}\n\n\noffset  length  type           name\n0x0     0x4      int           maybe_signature \n0x4     0x1      undefined  \n0x5     0x1      undefined  \n0x6     0x1      undefined  \n0x7     0x1      undefined  \n0x8     0x1      undefined  \n0x9     0x1      undefined  \n0xa     0x1      undefined  \n0xb     0x1      undefined  \n0xc     0x4      int           socket \n0x10    0x4      uint          buffer_length \n0x14    0x2      undefined2    maybe_function_code \n0x16    0x2      undefined2    only_used_once_and_set_to_256 \n0x18    0x2      ushort        maybe_status_code \n0x1a    0x1      undefined  \n0x1b    0x1      undefined  \n0x1c    0x4      uint  \n0x20    0x4      void *        buffer \n0x24    0x4      undefined4    maybe_pid \n\nI couldn't figure out how to make Ghidra export the above as a struct so I've just dumped it here as Ghidra presented it, since it's quite readable as it is (and I have no idea how I'd rewrite this as a C struct myself, actually :/).\nLooking at <pre><code>buffer_length</code></pre>, if I understand how unions work properly, a function code and a status code (guess-identified from elsewhere) would be kind of exactly the kind of thing you'd want to dump out of a C struct into a network packet.\nALSO, if you go back and look at the code where it sets <pre><code>message_length</code></pre> to 12, the range from <pre><code>buffer_length</code></pre> extends down to the two <pre><code>undefined</code></pre>s currently underneath <pre><code>maybe_status_code</code></pre>.\nI unfortunately don't know how to tell Ghidra \"go and find me where these two definitions are used!\" from the struct editor, and I don't know how to tell Ghidra \"search in decompiled code\" for <pre><code>field_0x1a</code></pre> and <pre><code>field_0x1b</code></pre>, so these two remain mysteries for now. (I also tried to turn the range into a sub-struct, but then it disappeared in the struct editor.)\nAnyway, my point, and my question is...\nWhat direction should I head in so I can make progress with this dissection and get enough context to make sense of what I'm seeing?\nStatic analysis is proving really cool and interesting, but only because I can decompile to C. Ghidra doesn't provide debugger integration :'(, so I can't fire the shell program up and watch it tick away unless I want to stare at assembly in GDB.\nWhich I'm not at all unwilling to do, I just find asm really disorientating. I must admit I've been trying to pick it up for about... wow, I think it's been 15 years now, heh. (All the tutorials I've yet found are either really regimented (to the point I can't piece the details together), assume I'm a vegetable (...8086? uhh....), or try and teach me to juggle by handling me 6 balls to start with.)\nIt's very late so I'll leave this question here for now, and possibly add to it / clarify details a little later on.\nOne key point: the program I'm reverse engineering is proprietary but its status is \"quietly floating around on the internet if you know what rock to look under\", so I could share more details privately (incidentally my email is in my bio).\n",
    "votes": "1",
    "answers": 0,
    "views": "308",
    "tags": [
        "c",
        "static-analysis",
        "dynamic-analysis",
        "protocol"
    ],
    "user": "i336_",
    "time": "Jul 1, 2019 at 17:13",
    "comments": [
        {
            "user": "eric.m",
            "text": "I think the trick about those <pre><code>undefined</code></pre> is alignment. The variable at <pre><code>0x1C</code></pre> is an integer, so it is uses 4-byte alignment; since <pre><code>maybe_status_code </code></pre> is a short (only 2 bytes), 2 bytes of padding have to be added to align the next variable. So maybe fields <pre><code>0x1A</code></pre> and <pre><code>0x1B</code></pre> don't do anything at all.\n",
            "time": null
        },
        {
            "user": "eric.m",
            "text": "About the mesage length thing, I think the code is sending the data from <pre><code>buffer_length</code></pre> to <pre><code>maybe_status_code</code></pre> as some kind of signature; after all, the receiving code must know how many bytes the buffer has, the function code, etc\n",
            "time": null
        }
    ],
    "answers_data": []
}