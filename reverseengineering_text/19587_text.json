{
    "title": "Converting Assembly x64 code to C",
    "link": "https://reverseengineering.stackexchange.com/questions/19587/converting-assembly-x64-code-to-c",
    "content": "I have the following code:\n<pre><code>0000000000400526 <main>:\n  400526:   55                      push   rbp\n  400527:   48 89 e5                mov    rbp,rsp\n  40052a:   48 83 ec 20             sub    rsp,0x20\n  40052e:   89 7d ec                mov    DWORD PTR [rbp-0x14],edi\n  400531:   48 89 75 e0             mov    QWORD PTR [rbp-0x20],rsi\n  400535:   c7 45 f4 4d 3c 2b 1a    mov    DWORD PTR [rbp-0xc],0x1a2b3c4d\n  40053c:   48 8d 45 f4             lea    rax,[rbp-0xc]\n  400540:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax\n  400544:   c7 45 f0 00 00 00 00    mov    DWORD PTR [rbp-0x10],0x0\n  40054b:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  40054f:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400552:   0f be c0                movsx  eax,al\n  400555:   c1 e0 18                shl    eax,0x18\n  400558:   89 c2                   mov    edx,eax\n  40055a:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  40055e:   48 83 c0 01             add    rax,0x1\n  400562:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400565:   0f be c0                movsx  eax,al\n  400568:   c1 e0 10                shl    eax,0x10\n  40056b:   09 c2                   or     edx,eax\n  40056d:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  400571:   48 83 c0 02             add    rax,0x2\n  400575:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400578:   0f be c0                movsx  eax,al\n  40057b:   c1 e0 08                shl    eax,0x8\n  40057e:   09 c2                   or     edx,eax\n  400580:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  400584:   48 83 c0 03             add    rax,0x3\n  400588:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  40058b:   0f be c0                movsx  eax,al\n  40058e:   09 d0                   or     eax,edx\n  400590:   89 45 f0                mov    DWORD PTR [rbp-0x10],eax\n  400593:   8b 55 f0                mov    edx,DWORD PTR [rbp-0x10]\n  400596:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]\n  400599:   89 c6                   mov    esi,eax\n  40059b:   bf 44 06 40 00          mov    edi,0x400644 ; \"a = %#x\nb = %#x\n\"\n  4005a0:   b8 00 00 00 00          mov    eax,0x0\n  4005a5:   e8 56 fe ff ff          call   400400 <printf@plt>\n  4005aa:   b8 00 00 00 00          mov    eax,0x0\n  4005af:   c9                      leave\n  4005b0:   c3                      ret\n  4005b1:   66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]\n  4005b8:   00 00 00\n  4005bb:   0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]\n</code></pre>\nThis is a segment of x64 assembly code, and I would like to rewrite this code into C. I've been reading Assembly books all day, and I'm still having some difficulty. I just want to understand what this code is doing. From messing around, I think that it performs some operations on an int (that's why I think the DWORD is there) and a long (that's why the QWORD is there). I think that this is true because I recompiled C code with those data structures and those words appeared in the Assembly equivalent, but I could be wrong.\nAny help is appreciated in decoding this code.'\n\nFor Amigag: second segment of code\n<pre><code>0000000000400966 <my_tolower>:\n  400966:   55                      push   rbp\n  400967:   48 89 e5                mov    rbp,rsp\n  40096a:   48 89 7d f8             mov    QWORD PTR [rbp-0x8],rdi\n  40096e:   eb 2d                   jmp    40099d <my_tolower+0x37>\n  400970:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  400974:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400977:   3c 40                   cmp    al,0x40\n  400979:   7e 1d                   jle    400998 <my_tolower+0x32>\n  40097b:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  40097f:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400982:   3c 5a                   cmp    al,0x5a\n  400984:   7f 12                   jg     400998 <my_tolower+0x32>\n  400986:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  40098a:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  40098d:   83 c0 20                add    eax,0x20\n  400990:   89 c2                   mov    edx,eax\n  400992:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  400996:   88 10                   mov    BYTE PTR [rax],dl\n  400998:   48 83 45 f8 01          add    QWORD PTR [rbp-0x8],0x1\n  40099d:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  4009a1:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  4009a4:   84 c0                   test   al,al\n  4009a6:   75 c8                   jne    400970 <my_tolower+0xa>\n  4009a8:   90                      nop\n  4009a9:   5d                      pop    rbp\n  4009aa:   c3                      ret    \n  4009ab:   0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]\n</code></pre>\n",
    "votes": "2",
    "answers": 1,
    "views": "2k",
    "tags": [
        "disassembly",
        "assembly",
        "decompilation",
        "x86-64"
    ],
    "user": "Joey",
    "time": "Oct 10, 2018 at 0:57",
    "comments": [],
    "answers_data": [
        {
            "content": "I believe the best tool for rewriting assembly to C is IDA Graph View, which is toggled with space.\nIt let you see the function as Basic Blocks, connected by control flow instructions. In this specific function, I cannot spot any jumps so you will see one long block.\nThe first thing you usually see in a function is the function prologue which sets up the stack frame.\n<pre><code>  400526:   55                      push   rbp\n  400527:   48 89 e5                mov    rbp,rsp\n  40052a:   48 83 ec 20             sub    rsp,0x20\n</code></pre>\nsecond, as 64 bit calling convention suggests, the first parameters are passed by registers, other are passed on the stack.\nThe used registers are os-dependent (see table 5 at Agner Fog calling conventions).\nYou an see that the function probably gets 2 parameters (edi for 32 bit variable for <pre><code>argc</code></pre> and 64 bit for <pre><code>argv</code></pre>)\nYou can see that a \"magic\" value (<pre><code>0x1a2b3c4</code></pre>) is saved in a local variable and a pointer to it is created. Note that when it's saved, it is stored as little-endian, which means the order of bytes is reversed.\n<pre><code>  400535:   c7 45 f4 4d 3c 2b 1a    mov    DWORD PTR [rbp-0xc],0x1a2b3c4d\n  40053c:   48 8d 45 f4             lea    rax,[rbp-0xc]\n  400540:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax\n</code></pre>\nAnd his first byte is read to eax as a signed byte and multiplied by <pre><code>2^0x18 (=2^24)</code></pre>.\nThe fact that it's signed doesn't affect anything in this case, because the sign bit is always off (as <pre><code>0x1a</code></pre>, <pre><code>0x2b</code></pre>, <pre><code>0x3c</code></pre> and <pre><code>0x4d</code></pre> are all below 128)\n<pre><code>  40054f:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400552:   0f be c0                movsx  eax,al\n  400555:   c1 e0 18                shl    eax,0x18\n</code></pre>\nAnd in a similar way, a value is calculated using next bytes, multiplied by 0x10 (=16), 8 and 1 (implicitly) respectively. results are stored in edi, and <pre><code>or</code></pre>ed with the previous value.\nWe can conclude that our function is something like that:\n<pre><code>void main(int argc, char *argv[])\n{\n     int calculated_value;  // represents the use of edi to store the result\n     int magic_value = 0x1A2B3C4D;  // note that although i am using int, i mean uint32_t, a variable that has 4 bytes - a DWORD.\n     char *magic_ptr = (char *) &magic_value;  // the values are read byte-by-byte, or char-by-char\n     calculated_value = magic_ptr[0] << 24;\n     calculated_value |= magic_ptr[1] << 16;\n     calculated_value |= magic_ptr[2] << 8;\n     calculated_value |= magic_ptr[3];  // note that at the last or, the result is saved at eax as edi will soon be used to pass the first parameter to printf\n\n     printf(\"a = %#x\nb = %#x\n\", magic_value, calculated_value);\n}\n</code></pre>\nSo, what we can see is that the magic value is read back to a variable, while saving the little-endianness, which means we will get the reversed byte order if the <pre><code>magic_value</code></pre>.\nThus, we can expect the output to be:\n\na = 0x1a2b3c4d\n  b = 0x4d3c2b1a\n\n\nAlso, as a general note, this code have could utilize loops to perform the read.\n<pre><code>void main(int argc, char *argv[])\n{\n     int i;\n     int calculated_value = 0;  // represents the use of edi to store the result\n     int magic_value = 0x1A2B3C4D;  // note that although i am using int, i mean uint32_t, a variable that has 4 bytes - a DWORD.\n     char *magic_ptr = (char *) &magic_value;  // the values are read byte-by-byte, or char-by-char\n     for(int i = 0; i < 4; i++)\n     {\n         calculated_value <<= 8;\n         calculated_value = magic_ptr[i];\n     }\n     printf(\"a = %#x\nb = %#x\n\", magic_value, calculated_value);\n}\n</code></pre>\n\nEDIT: As to your second code.\nHere we can see jumps, so I created a graph view of the code. it makes reading it much easier.\nA bit of info on the graph: a green line means that the jump happens if a condition is met. A red line means that the jump happens if the condition is false. A blue line means that the jump is unconditional, it will always jump.\nLet's go through it and see what happens.\n\nThe first thing we get to see after the function prologue is a single parameter is saved at <pre><code>rbp-0x8</code></pre>.\nOn the block of <pre><code>0x40099d</code></pre> we can see that the input is probably <pre><code>char *ptr</code></pre>, it dereference the pointer and read it's value.\nFrom the <pre><code>test al, al</code></pre> we can assume that the value is a string (and not just binary data, it is probably related to user input) and we stop once we have read the null terminator (<pre><code>\\x00</code></pre> = 0).\nThe next block we will check is <pre><code>0x400970</code></pre>. All it does is checking if the char pointed by <pre><code>rbp-0x8</code></pre> is smaller or equal to <pre><code>0x40</code></pre> (<pre><code>0x40</code></pre> is ascii for '@', <pre><code>0x41</code></pre> is 'A'). If it is, it <pre><code>continue</code></pre>s (the single-line block at <pre><code>0x400998</code></pre>).\nSo far, our function is something like:\n<pre><code>void my_tolower(char *str)\n{\n    while(str[i] != '\\x00')\n    {\n        if(str[i] < 'A')  // as opposed to <= '@'. I can't remember I saw a code ever caring about '@'.\n        {\n            str += 1;  // skipping the current character\n            continue;\n        }\n        // unknown code for now\n    }\n}\n</code></pre>\nLooking at <pre><code>0x40097b</code></pre>, we can see a similar code, but it checks the character is smaller than <pre><code>0x5A</code></pre> (=ascii of <pre><code>Z</code></pre>). so we can write those conditions in a single if:\n<pre><code>if(str[i] < 'A' || str[i] > 'Z')\n</code></pre>\nLast block (<pre><code>0x400986</code></pre>). We now know that str[i] contains an upper-case letter.\nThe code takes the character and add <pre><code>0x20</code></pre> to it. <pre><code>0x20</code></pre> is ascii for <pre><code></code></pre> (space) and (<pre><code>a</code></pre> - <pre><code>A</code></pre>). It saves the result back to the string and continues.\n<pre><code>  400992:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  400996:   88 10                   mov    BYTE PTR [rax],dl\n</code></pre>\nLooking at <pre><code>0x4009a8</code></pre>, no result is passed to <pre><code>rax</code></pre>, that means the function probably doesn't return a value.\nSo, out functions look something like that:\n<pre><code>void my_tolower(char *str)\n{\n    while(str[i] != '\\x00')\n    {\n        if(str[i] < 'A' || str[i] > 'Z')  // as opposed to <= '@'. I can't remember I saw a code ever caring about '@'.\n        {\n            continue;\n        }\n        str[i] = str[i] + 'a' - 'A';\n        str += 1;\n    }\n}\n</code></pre>\nWe could also rewrite the function to show the single block that increments the pointer, which i believe is how the original code looked like. it makes more sense logically that we change the string if a condition was met, not if a condition is not met.\n<pre><code>void my_tolower(char *str)  // name was taken from 4009a6 and the first line of function\n{\n    while(str[i] != '\\x00')\n    {\n        if(str[i] >= 'A' && str[i] <= 'Z')  // as opposed to <= '@'. I can't remember I saw a code ever caring about '@'.\n        {\n            str[i] = str[i] + 'a' - 'A';\n        }\n        str += 1;  // this is the block at 400998, that always happen\n    }\n}\n</code></pre>\n",
            "votes": "7",
            "user": null,
            "time": "Oct 11, 2018 at 4:41",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Joey",
                    "text": "<span class=\"comment-copy\">Thank you so much!! There is just one last segment of code that I'm having trouble deciphering. I've accepted your answer, though. I added it to the original post to see if you can help me? I do not have IDA Graph View (though, I saw it as a suggested application earlier) as it is pay-per-download, and I plan on using Assembly again.</span>",
                    "time": null
                },
                {
                    "user": "user22970",
                    "text": "<span class=\"comment-copy\">@stackofhay42 i've edited the answer</span>",
                    "time": null
                }
            ]
        }
    ]
}