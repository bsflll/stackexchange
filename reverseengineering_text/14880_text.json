{
    "title": "basic reversing question about local variable",
    "link": "https://reverseengineering.stackexchange.com/questions/14880/basic-reversing-question-about-local-variable",
    "content": "I do not understand the following:\nin a very simple dummy C function:\n<pre><code>void vulnerable_function(char* string) { \n    char buffer[100];\n}\n</code></pre>\nWhen I use <pre><code>gdb</code></pre> to disassemble it, I obtain:\n<pre><code>0x08048464 <+0>:  push   %ebp\n0x08048465 <+1>:  mov    %esp,%ebp\n0x08048467 <+3>:  sub    $0x88,%esp\n</code></pre>\nI really do not understand why the stack pointer is decremented by 0x88. \nI believed that it would be <pre><code>0x64</code></pre> instead of <pre><code>0x88</code></pre>. Can you explain it please?\nThank you very much!\n",
    "votes": "8",
    "answers": 2,
    "views": "2k",
    "tags": [
        "disassembly",
        "x86"
    ],
    "user": "David Labay",
    "time": "Mar 11, 2017 at 22:01",
    "comments": [
        {
            "user": "Vido",
            "text": "can you add more info about your executable like <pre><code>file ./executable</code></pre>\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "There are several factors involved in how much space is allocated by the compiler for a function's stack frame on the process runtime stack:\n\nspace required for saving copies of arguments to the function in the stack frame\nspace required for storing local variables in the stack frame\nStack alignment to a 16-byte boundary (GCC default for i386 architecture)\n\nBackground\nThe i386 ABI\nStack Frame Specification\nThe specification for the stack frame on x86 machines is given in Chapter 3: \"Low-Level System Information\" in the System V Application Binary Interface Intel386 Architecture Processor Supplement, Fourth Edition in the section titled \"Function Calling Sequence\".\nNote:\n\nWithin this specification, the term halfword refers to a 16-bit object, the term word refers to a 32-bit object, and the term doubleword refers to a 64-bit object.\n\nHere are relevant excerpts:\n\n\nThe stack is word aligned.  Although the architecture does not require any \n  alignment of the stack, software convention and the operating system requires that the stack be aligned on a word boundary.\n\n\nAn argument’s size is increased, if necessary, to make it a multiple of words. This may require tail padding, depending on the size of the argument.\n\n\nOther areas depend on the compiler and the code being compiled.  The standard calling sequence does not define a maximum stack frame size, nor does\n  it restrict how a language system uses the ‘‘unspecified’’ area of the standard stack frame.\n\n\nThe \"unspecified\" area in a stack frame is the space created for local variables and where arguments to the function are copied to. This space is managed by the compiler.\nHere is a diagram from the ABI:\n\nAlignment\nIt is the compiler that manages stack frames, and in order for a stack frame to be aligned the alignment of variables within the stack frame must also be known.   \nAlignment of variables depends on their type and the architecture of the CPU.\nThis is also specified in the ABI:\n\nThere are conventions that pertain specifically to the alignment of arrays, structures and unions:\n\nAggregates (structures and arrays) and unions assume the alignment of their most strictly aligned component.  The size of any object, including aggregates and unions, is always a multiple of the object’s alignment.  An array uses the same alignment as its elements.  Structure and union objects can require padding to meet size and alignment constraints.  The contents of any padding is undefined. \n\nHowever, on i386 architecture systems, GCC aligns the stack to a 16-byte boundary by default:\n\n<pre><code>-mpreferred-stack-boundary=num</code></pre>\n     Attempt to keep the stack boundary aligned to a 2 raised to num byte boundary. If <pre><code>-mpreferred-stack-boundary</code></pre> is not specified, the default is 4 (16 bytes or 128 bits). \n\nThis means that the compiler allocates 16 bytes of space on the stack frame for variables whose type sizes are less than 16 bytes. For example, even though an <pre><code>int</code></pre> is 4 bytes on an i386 system, the compiler would still allocate 16 bytes of space on the stack frame for it.\nThe stack frame for vulnerable_function()\nLet us analyze how the compiler allocates space on a function's stack frame with 2 simple examples: a function with a <pre><code>char</code></pre> pointer local variable and a function with a 100-byte <pre><code>char</code></pre> array.\nA function called <pre><code>pointer_test</code></pre> with <pre><code>char</code></pre> pointer local variable:\n<pre><code>void pointer_test(void) {\n    char *i = \"test\";\n}\n</code></pre>\nAssembly code generated by <pre><code>gcc</code></pre> + <pre><code>as</code></pre>:\n<pre><code>Dump of assembler code for function pointer_test:\n   0x080483db <+0>:     push   %ebp\n   0x080483dc <+1>:     mov    %esp,%ebp\n   0x080483de <+3>:     sub    $0x10,%esp  <-- 16 bytes of space created for 4-byte pointer\n   0x080483e1 <+6>:     movl   $0x8048480,-0x4(%ebp)\n   0x080483e8 <+13>:    nop\n   0x080483e9 <+14>:    leave  \n   0x080483ea <+15>:    ret  \n</code></pre>\nHere we see that 16 bytes of space were allocated for a 4-byte pointer.\nA function called <pre><code>char_array_test</code></pre> with a char array local variable:\n<pre><code>void char_array_test(void) {\n    char buffer[100];\n}\n</code></pre>\nAssembly code generated by <pre><code>gcc</code></pre> + <pre><code>as</code></pre>:\n<pre><code>Dump of assembler code for function char_array_test:\n   0x0804844b <+0>:     push   %ebp\n   0x0804844c <+1>:     mov    %esp,%ebp\n   0x0804844e <+3>:     sub    $0x78,%esp  <-- 120 bytes of space created for 100-byte array\n   0x08048451 <+6>:     mov    %gs:0x14,%eax\n   0x08048457 <+12>:    mov    %eax,-0xc(%ebp)\n   0x0804845a <+15>:    xor    %eax,%eax\n   0x0804845c <+17>:    nop\n   0x0804845d <+18>:    mov    -0xc(%ebp),%eax\n   0x08048460 <+21>:    xor    %gs:0x14,%eax\n   0x08048467 <+28>:    je     0x804846e <char_array_test+35>\n   0x08048469 <+30>:    call   0x8048310 <__stack_chk_fail@plt>\n   0x0804846e <+35>:    leave  \n   0x0804846f <+36>:    ret\n</code></pre>\nHere we see that 120 bytes of space were allocated for a 100-byte array.    \nIn the case of <pre><code>void vulnerable_function(char *string)</code></pre>, space in the stack frame must be allocated by <pre><code>gcc</code></pre> for a 4-byte pointer and a 100-byte array. \n\nAs we observed above in <pre><code>pointer_test()</code></pre>, since <pre><code>gcc</code></pre> aligns allocated space to 16-byte boundaries by default,  16 bytes of space are also allocated on the stack frame for the 4-byte pointer<pre><code>char *string</code></pre>, the argument to the function.\nWe observed above in <pre><code>char_array_test()</code></pre> that <pre><code>gcc</code></pre> allocates 120 bytes of space for a 100 byte array (120 is not a multiple of 16, so this is not aligned with a 16-byte boundary. I do not know why the compiler does this). Likewise, the compiler allocates 120 bytes of space for <pre><code>char buffer[100]</code></pre> in <pre><code>vulnerable_function()</code></pre>. \n\n0x10 bytes for <pre><code>string</code></pre> + 0x78 bytes for <pre><code>buffer[100]</code></pre> = 0x88\n\n\nResources\nCompiler Explorer is an interactive compiler that runs in your browser. Playing around with it is much faster than constantly recompiling code and disassembling it.\nThe System V Application Binary Interface Intel386 Architecture Processor Supplement, Fourth Edition\n Intel 386 and AMD x86-64 Options for GCC\n<pre><code>cdecl</code></pre> and x86 calling conventions discusses calling conventions in x86 compilers\nPoke-a-hole and friends is an\narticle that discusses how structures are padded in order to maintain alignment and how this changes across architectures.\nrelated SO questions\nStack allocation, padding, and alignment\nwhat is “stack alignment”?\n",
            "votes": "12",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "As SYS_V correctly cites in his answer, the GCC documentation states that GCC will work to align the stack pointer to 16-byte boundaries by default.\n\n<pre><code>-mpreferred-stack-boundary=num</code></pre>\nAttempt to keep the stack boundary aligned to a 2 raised to num byte\n  boundary. If <pre><code>-mpreferred-stack-boundary</code></pre> is not specified,\n  the default is 4 (16 bytes or 128 bits).\n\nWe find some reasoning as to why this is done as well (NB: On the 64-bit architecture, 16-byte alignment is mandatory):\n\n[A different value] leads to wrong code when functions compiled with 16 byte stack alignment (such as functions from a standard library) are called with misaligned stack. In this case, SSE instructions may lead to misaligned memory access traps [and] variable arguments are handled incorrectly for 16 byte aligned objects [...] You must build all modules [with the same value]. This includes the system libraries and startup modules.\n\nNote, however, that this is mostly about the stack frame (boundary), not necessarily the individual objects on the stack. This frame alignment happens not inside the function, but at the call site where you will see something like this (note the extra subtraction from <pre><code>%esp</code></pre>):\n<pre><code> sub    $0xc,%esp                # pad stack by 12 bytes\n push   %eax                     # push 4-byte argument\n call   vulnerable_function\n</code></pre>\nNevertheless it makes sense to keep (some) objects aligned as well.\nIn your example, you encounter 0x88 (=136) bytes allocated for the 100-byte buffer while SYS_V got 0x78 (=120) for the same. Note that both these values are congruent 8 modulo 16. This is chosen because at this point, your stack frame already includes two 4-byte values: the return address and the saved frame pointer. With these combined, you end up 16-byte-aligned after the allocation.\n",
            "votes": "4",
            "user": "pesco",
            "time": "Aug 3, 2018 at 12:47",
            "is_accepted": false,
            "comments": []
        }
    ]
}