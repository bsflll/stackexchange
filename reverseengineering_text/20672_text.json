{
    "title": "Identify ldfld reference in .NET when parsing GetILAsByteArray",
    "link": "https://reverseengineering.stackexchange.com/questions/20672/identify-ldfld-reference-in-net-when-parsing-getilasbytearray",
    "content": "I was experimenting with idea of decompiling a PowerShell cmdlet using reflection. \nWhile I got some basics seem to work, how do I resolve the value in OperandField, for example ldfld cmd in this case if decompiled correctly may look like this:\n<pre><code>ldfld      string[] Microsoft.PowerShell.Commands.GetAclCommand::path\n</code></pre>\nWhere as currently I am just displaying as \"ldfld\"\nThis is parsed in this section of code:\n<pre><code>{ $_ -eq \"InlineBrTarget\" -or\n                  $_ -eq \"InlineField\" -or\n                  $_ -eq \"InlineI\" -or\n                  $_ -eq \"InlineSig\" -or\n                  $_ -eq \"InlineString\" -or\n                  $_ -eq \"InlineTok\" -or\n                  $_ -eq \"InlineType\" -or \n                  $_ -eq \"ShortInlineR\" }\n                {\n                    $count = [BitConverter]::ToInt32($Ilbytes,$offset+1)\n                    $offset += 4\n                }\n</code></pre>\nThe full script here:\n<pre><code># command to decompile\n$cmd = \"Get-Acl\"\n\n$cmdInfo = Get-Command -CommandType Cmdlet -Name $cmd\n\n$methods = $cmdInfo.ImplementingType.UnderlyingSystemType.GetMethods()\n\n$opCodeDictionary = @{}\nForEach ($field in [System.Reflection.Emit.OpCodes].GetFields())\n{\n    $fieldValue = $field.GetValue($null)\n    $opCodeDictionary.Add($fieldValue.Value,$fieldValue)\n}\nForEach ($method in $Methods)\n{\n    Write-Host \".method \" -NoNewline\n    if ($method.IsPublic) \n    { \n        Write-Host \"public \" -NoNewline \n    }\n\n    if ($method.IsPrivate) \n    {\n        Write-Host \"private \" -NoNewline\n    }\n\n    if ($method.IsHideBySig) \n    {\n        Write-Host \"hidebysig \" -NoNewline\n    }\n\n    if ($method.IsSpecialName) \n    {\n        Write-Host \"specialname \" -NoNewline\n    }\n\n\n    if ($method.GetParameters() -ne $null)\n    {\n        Write-Host $method.GetParameters()[0]\n    }\n    else\n    {\n         \"$($method.ReturnType.Name) $($method.Name)\"\n    }\n    Write-Host \"{\"\n    $methodBody = $method.GetMethodBody()\n    if ($methodBody -ne $null)\n    {\n        $ilBytes = $methodBody.GetILAsByteArray()\n        $offset = 0\n\n        while ($offset -lt $ilBytes.Length)\n        {\n          Write-Host (\"IL_{0:x4}: \" -f $offset) -NoNewline\n          [System.Int16]$code = $ilBytes[$offset++];\n          if ($code -eq 0xfe)\n          {\n             [System.Int16]$code = $ilBytes[$offset++] -bor 0xfe00\n          }\n\n          $opCode = $opCodeDictionary[[System.Int16]$code]\n\n          Write-Host $opCode.Name -NoNewline\n          switch ($opCode.Name)\n          {\n            { $_ -eq \"call\" -or\n              $_ -eq \"callvirt\" }\n              {\n                Write-Host \" \" -NoNewline\n              }\n            default { \n                Write-Host \n                }\n          } \n          switch ($opCode.OperandType)\n          {\n                \"InlineMethod\"\n                {\n                     $metaDataToken = [BitConverter]::ToInt32($ilBytes,$offset)\n                     $genericMethodArguments = $null\n                     if ($method.IsGenericMethod -eq $true)\n                     {\n                         $genericMethodArguments = $method.GetGenericArguments()\n                     }\n\n                    ($method.Module.ResolveMethod(\n                       $metaDataToken,\n                       $method.DeclaringType.GetGenericArguments(),\n                       $genericMethodArguments)).Name \n\n                    $offset += 4\n                 }\n\n                \"InlineNone\"\n                {\n                }\n\n                { $_ -eq \"ShortInlineBrTarget\" -or\n                  $_ -eq \"ShortInlineI\" -or\n                  $_ -eq \"ShortInlineVar\" }\n                {\n                    $offset++\n                }      \n\n                \"InlineVar\"\n                {\n                    $offset += 2\n                }\n\n                { $_ -eq \"InlineBrTarget\" -or\n                  $_ -eq \"InlineField\" -or\n                  $_ -eq \"InlineI\" -or\n                  $_ -eq \"InlineSig\" -or\n                  $_ -eq \"InlineString\" -or\n                  $_ -eq \"InlineTok\" -or\n                  $_ -eq \"InlineType\" -or \n                  $_ -eq \"ShortInlineR\" }\n                {\n                    $count = [BitConverter]::ToInt32($Ilbytes,$offset+1)\n                    $offset += 4\n                }\n\n                { $_ -eq \"InlineI8\" -or\n                  $_ -eq \"InlineR\"\n                }\n                {\n                    $offset += 8\n                }\n\n                \"InlineSwitch\"\n                {\n                    $count = [BitConverter]::ToInt32($Ilbytes,$offset+1)\n                    $offset += 4 * $count\n                }\n\n            default \n               { throw \"$($opCode.OperandType) not implemented\" }\n\n            }\n        }\n    }\n\n    Write-Host \"} // end of method $($method.DeclaringType.ToString())::$($method.Name)\"\n    Write-Host \n}\n</code></pre>\n",
    "votes": "1",
    "answers": 1,
    "views": "132",
    "tags": [
        ".net"
    ],
    "user": "chentiangemalc",
    "time": "Feb 20, 2019 at 21:14",
    "comments": [],
    "answers_data": [
        {
            "content": "This can be resolved using ResolveField method, fixed example. Note this example still has limitation in that it is failing to resolve fields where I need to specify genericTypeArguments and genericMethodArguments to resolvefield.\n<pre><code>$fieldReference = [BitConverter]::ToInt32($Ilbytes,$offset)\n                    try\n                    {\n                        $field = $method.Module.ResolveField($fieldReference)\n                        Write-Host \"$($field.FieldType) $($field.ReflectedType.ToString())::$($field.Name)\"\n                    }\n                    catch\n                    {\n                        Write-Host (\"<Unresolved reference 0x{0:x}>\" -f $fieldReference)\n                    }\n                    $offset += 4\n</code></pre>\nUpdated within script:\n<pre><code># command to decompile\n$cmd = \"Get-Acl\"\n\n$cmdInfo = Get-Command -CommandType Cmdlet -Name $cmd\n\n$methods = $cmdInfo.ImplementingType.UnderlyingSystemType.GetMethods()\n\n$opCodeDictionary = @{}\nForEach ($field in [System.Reflection.Emit.OpCodes].GetFields())\n{\n    $fieldValue = $field.GetValue($null)\n    $opCodeDictionary.Add($fieldValue.Value,$fieldValue)\n}\nForEach ($method in $Methods)\n{\n    Write-Host \".method \" -NoNewline\n    if ($method.IsPublic) \n    { \n        Write-Host \"public \" -NoNewline \n    }\n\n    if ($method.IsPrivate) \n    {\n        Write-Host \"private \" -NoNewline\n    }\n\n    if ($method.IsHideBySig) \n    {\n        Write-Host \"hidebysig \" -NoNewline\n    }\n\n    if ($method.IsSpecialName) \n    {\n        Write-Host \"specialname \" -NoNewline\n    }\n\n\n    if ($method.GetParameters() -ne $null)\n    {\n        Write-Host $method.GetParameters()[0]\n    }\n    else\n    {\n         \"$($method.ReturnType.Name) $($method.Name)\"\n    }\n    Write-Host \"{\"\n    $methodBody = $method.GetMethodBody()\n\n    if ($methodBody -ne $null)\n    {\n        Write-Host \".maxstack $($methodBody.MaxStackSize)\"\n        if ($methodBody.LocalVariables -ne $null)\n        {\n            Write-Host \".locals \" -NoNewline\n            if ($methodBody.InitLocals -eq $True)\n            {\n                Write-Host \"init \" -NoNewline\n            }\n\n            Write-Host \"(\" -NoNewLine\n            ForEach ($local in $methodBody.LocalVariables)\n            {\n                if ($local.LocalIndex -eq 0)\n                {\n                    Write-Host \"$($local.LocalType) V_$($local.LocalIndex)\" -NoNewline\n                }\n                else\n                {\n                    Write-Host \",`n`t$($local.LocalType) V_$($local.LocalIndex)\"\n                }\n            }\n\n            Write-Host \")\"\n        }\n        $ilBytes = $methodBody.GetILAsByteArray()\n        $offset = 0\n\n        while ($offset -lt $ilBytes.Length)\n        {\n          Write-Host (\"IL_{0:x4}: \" -f $offset) -NoNewline\n          [System.Int16]$code = $ilBytes[$offset++];\n          if ($code -eq 0xfe)\n          {\n             [System.Int16]$code = $ilBytes[$offset++] -bor 0xfe00\n          }\n\n          $opCode = $opCodeDictionary[[System.Int16]$code]\n\n          Write-Host \"$($opCode.Name) \" -NoNewline\n\n          switch ($opCode.OperandType)\n          {\n                \"InlineMethod\"\n                {\n                     $metaDataToken = [BitConverter]::ToInt32($ilBytes,$offset)\n                     $genericMethodArguments = $null\n                     if ($method.IsGenericMethod -eq $true)\n                     {\n                         $genericMethodArguments = $method.GetGenericArguments()\n                     }\n\n                    ($method.Module.ResolveMethod(\n                       $metaDataToken,\n                       $method.DeclaringType.GetGenericArguments(),\n                       $genericMethodArguments)).Name \n\n                    $offset += 4\n                 }\n\n                \"InlineNone\"\n                {\n                }\n\n                { $_ -eq \"ShortInlineBrTarget\" -or\n                  $_ -eq \"ShortInlineI\" -or\n                  $_ -eq \"ShortInlineVar\" }\n                {\n                    $offset++\n                }      \n\n                \"InlineVar\"\n                {\n                    $offset += 2\n                }\n\n                \"InlineString\"\n                {\n                    $stringReference = [BitConverter]::ToInt32($Ilbytes,$offset)\n                    try\n                    {\n                        $stringInfo = $method.Module.ResolveString($stringReference)\n                        Write-Host \"`\"$stringInfo`\"\"\n                    }\n                    catch\n                    {\n                        Write-Host (\"<Unresolved reference 0x{0:x}>\" -f $fieldReference)\n                    }\n                    $offset += 4\n                }\n\n                \"InlineType\"\n                {\n                    $typeReference = [BitConverter]::ToInt32($Ilbytes,$offset)\n                    try\n                    {\n                        $typeInfo = $method.Module.ResolveType($typeReference)\n                        Write-Host \"$($typeInfo.BaseType.ToString())::$($typeInfo.Name)\"\n                    }\n                    catch\n                    {\n                        Write-Host (\"<Unresolved reference 0x{0:x}>\" -f $fieldReference)\n                    }\n                    $offset += 4\n                }\n\n                { $_ -eq \"InlineBrTarget\" -or\n                  $_ -eq \"InlineField\" -or\n                  $_ -eq \"InlineI\" -or\n                  $_ -eq \"InlineSig\" -or\n                  $_ -eq \"InlineTok\" -or\n                  $_ -eq \"ShortInlineR\" }\n                {\n                    $fieldReference = [BitConverter]::ToInt32($Ilbytes,$offset)\n                    try\n                    {\n                        $field = $method.Module.ResolveField($fieldReference)\n                        Write-Host \"$($field.FieldType) $($field.ReflectedType.ToString())::$($field.Name)\"\n                    }\n                    catch\n                    {\n                        Write-Host (\"<Unresolved reference 0x{0:x}>\" -f $fieldReference)\n                    }\n                    $offset += 4\n                }\n\n                { $_ -eq \"InlineI8\" -or\n                  $_ -eq \"InlineR\"\n                }\n                {\n                    $offset += 8\n                }\n\n                \"InlineSwitch\"\n                {\n                    $count = [BitConverter]::ToInt32($Ilbytes,$offset+1)\n                    $offset += 4 * $count\n                }\n\n            default \n               { throw \"$($opCode.OperandType) not implemented\" }\n\n            }\n\n            Write-Host \"\" \n        }\n    }\n\n    Write-Host \"} // end of method $($method.DeclaringType.ToString())::$($method.Name)\"\n    Write-Host \n}\n</code></pre>\n",
            "votes": "1",
            "user": "chentiangemalc",
            "time": "Feb 21, 2019 at 1:11",
            "is_accepted": false,
            "comments": []
        }
    ]
}