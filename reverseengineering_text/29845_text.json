{
    "title": "How to import macro as enum into IDA Pro?",
    "link": "https://reverseengineering.stackexchange.com/questions/29845/how-to-import-macro-as-enum-into-ida-pro",
    "content": "Is there any tools can auto generate enum type by macro?\nFor example, NTSTATUS in Windows defined as\n<pre><code>#define STATUS_ILLEGAL_INSTRUCTION       ((NTSTATUS)0xC000001DL)   \n#define STATUS_INVALID_LOCK_SEQUENCE     ((NTSTATUS)0xC000001EL)\n#define STATUS_INVALID_VIEW_SIZE         ((NTSTATUS)0xC000001FL)\n#define STATUS_INVALID_FILE_FOR_SECTION  ((NTSTATUS)0xC0000020L)\n#define STATUS_ALREADY_COMMITTED         ((NTSTATUS)0xC0000021L)\n#define STATUS_ACCESS_DENIED             ((NTSTATUS)0xC0000022L)\n...\n</code></pre>\nI want to import it into IDA Pro as enum, How can I do it?\n",
    "votes": "2",
    "answers": 2,
    "views": "985",
    "tags": [
        "ida"
    ],
    "user": "Ox9A82",
    "time": "Jan 11, 2022 at 11:15",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "Hmm, the real question is if you doing this yourself. Parsing for the status codes or something like IOCTLs in the WDK using regular expressions is fairly simple. You won't even need something that can understand more complex C statements. However, IDA may just as well have already what you want.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "IDA may already have what you need. Otherwise parsing the WDK headers would be the way to go. I did this a very long time ago, but could not dig up the IDC files. Depending on the sample you look at, something like DriverBuddy may also come in handy.\nConsider the following snippet from ntdll.dll:\n<pre><code>call    RtlFreeHeap\ntest    edi, edi\njns     short loc_18001A2EA\ncmp     edi, 0C0000022h\njz      short ReturnStatus\ncmp     edi, 0C0000043h\njz      short ReturnStatus\n</code></pre>\nClearly <pre><code>0C0000022h</code></pre> and <pre><code>0C0000043h</code></pre> are <pre><code>NTSTATUS</code></pre> values. You can use the \"Use standard symbolic constant\" menu item from the context menu (right click on any such value):\n\n... and ideally you will already be presented with one or several usable choices:\n\n... scrolling to the right within the dialog will also show which type lib introduced the constant(s):\n\nIf nothing pops up it's usually a good idea to add them yourself via File + Load file + FLIRT signature file, which should make the appropriate enums and structs available in your database:\n\nThe shown library modules would be the most appropriate for your purpose, it seems. However, if you wanted to outright add the complete enum (technically you will receive a copy of what in IDA lingo is a \"standard enum\"), you could do that from the enum subview (by default: Shift+F10). The subview, will be headed by a helpful reminder of the keyboard shortcuts:\n<pre><code>; Ins/Del/Ctrl-E: create/delete/edit enumeration types\n; N/Ctrl-N      : create/edit a symbolic constant\n; U             : delete a symbolic constant\n; ; or :        : set a comment for the current item\n</code></pre>\nAnd so after hitting Ins you should see the following dialog:\n\nSince you have symbol names, pick option (2), if you knew the enum name you could also use (1).\n\nFrom the opening dialog we could search for <pre><code>STATUS_ACCESS_DENIED</code></pre> by typing it while the dialog is open. The search term will be helpfully shown below the list (highlighted). Once you found the constant/symbol name you were looking for, simply double click it or select it and press the OK button.\nThe result should show as a collapsed enum in the enum subview:\n<pre><code>; [COLLAPSED ENUM MACRO_STATUS. PRESS CTRL-NUMPAD+ TO EXPAND]\n</code></pre>\nSo there you have it, had you known the name <pre><code>MACRO_STATUS</code></pre> up front, you could have added the enum by its own name instead of the name of a contained symbol.\nThe resulting copy of the enum can now be freely amended by you.\nIf you wanted to do something like this with IDC you would use something like add_enum() and add_enum_member():\n<pre><code>id = add_enum(-1, \"MACRO_STATUS\", 0x1100000)\nadd_enum_member(id,\"STATUS_ACCESS_DENIED\",  0XFFFFFFFFC0000022, -1);\n</code></pre>\nAnd if you're wondering about the odd leading <pre><code>0XFFFFFFFF</code></pre> that's because the underlying type of <pre><code>NTSTATUS</code></pre> is <pre><code>LONG</code></pre> and therefore 32-bit signed. I was using a 64-bit IDB for this. If you use a 32-bit one you can simply get rid of the leading <pre><code>FFFFFFFF</code></pre> (but not the <pre><code>0X</code></pre>).\nAfter you have the enum added, you should be presented with a submenu from \"Use standard symbolic constant\" and inside of it you should see the appropriate symbol, which after selecting it will give us:\n\n<pre><code>call    RtlFreeHeap\ntest    edi, edi\njns     short loc_18001A2EA\ncmp     edi, STATUS_ACCESS_DENIED\njz      short ReturnStatus\ncmp     edi, STATUS_SHARING_VIOLATION\njz      short ReturnStatus\n</code></pre>\n",
            "votes": "2",
            "user": "0xC0000022L",
            "time": "Jan 17, 2022 at 9:34",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "I don't know how proper this method is or\nwhat dangers lurk by using these hacks but I have sometimes used the\n<pre><code>ida -> file -> load file ->parse c header file (ctrl+f9) \n</code></pre>\nto get the job done in free versions (5 and 7)\nsuppose you have are analyzing a binary whose source is\n<pre><code>#include <stdio.h>\n#include <stdlib.h>\nint main (int argc,char* argv[] ){\n    if(argc == 2)   {\n        int res = 0;\n        int nts = atoi(argv[1]);\n        switch (nts)        {\n            case 1:\n                res = 0xC000001DL;\n                break;\n            case 2:\n                res = 0xC000001EL;\n                break;\n            case 3:\n                res = 0xC000001FL;\n                break;\n            case 4:\n                res = 0xC0000020L;\n                break;\n            case 5:\n                res = 0xC0000021L;\n                break;\n            case 6:\n                res = 0xC0000022L;\n                break;\n            default:\n                res = 0xffffffff;\n                break;              \n        }\n        printf(\"you asked %d i give %08x\n\" , nts, res);\n        return 0;\n    }\n}\n</code></pre>\nwhose main disassembled will look like (ida free 7)\n<pre><code>text:000000014000106C loc_14000106C:                          ; jumptable 000000014000106A case 1\n.text:000000014000106C                 mov     [rsp+38h+var_18], 0C000001Dh\n.text:0000000140001074                 jmp     short loc_1400010B0\n.text:0000000140001076 ; ---------------------------------------------------------------------------\n.text:0000000140001076\n.text:0000000140001076 loc_140001076:                          ; jumptable 000000014000106A case 2\n.text:0000000140001076                 mov     [rsp+38h+var_18], 0C000001Eh\n.text:000000014000107E                 jmp     short loc_1400010B0\n.text:0000000140001080 ; ---------------------------------------------------------------------------\n.text:0000000140001080\n.text:0000000140001080 loc_140001080:                          ; jumptable 000000014000106A case 3\n.text:0000000140001080                 mov     [rsp+38h+var_18], 0C000001Fh\n.text:0000000140001088                 jmp     short loc_1400010B0\n.text:000000014000108A ; ---------------------------------------------------------------------------\n.text:000000014000108A\n.text:000000014000108A loc_14000108A:                          ; jumptable 000000014000106A case 4\n.text:000000014000108A                 mov     [rsp+38h+var_18], 0C0000020h\n.text:0000000140001092                 jmp     short loc_1400010B0\n.text:0000000140001094 ; ---------------------------------------------------------------------------\n.text:0000000140001094\n.text:0000000140001094 loc_140001094:                          ; jumptable 000000014000106A case 5\n.text:0000000140001094                 mov     [rsp+38h+var_18], 0C0000021h\n.text:000000014000109C                 jmp     short loc_1400010B0\n.text:000000014000109E ; ---------------------------------------------------------------------------\n.text:000000014000109E\n.text:000000014000109E loc_14000109E:                          ; jumptable 000000014000106A case 6\n.text:000000014000109E                 mov     [rsp+38h+var_18], 0C0000022h\n.text:00000001400010A6                 jmp     short loc_1400010B0\n.text:00000001400010A8 ; ---------------------------------------------------------------------------\n.text:00000001400010A8\n.text:00000001400010A8 def_14000106A:                          ; jumptable 000000014000106A default case\n.text:00000001400010A8                 mov     [rsp+38h+var_18], 0FFFFFFFFh\n.text:00000001400010B0\n.text:00000001400010B0 loc_1400010B0:\n</code></pre>\nyou can simply make a dummy header file stuff them into an enum and use parse header after some notepad++ magic (column editing to remove #define regex substitute = etc)\n:>cat tpass.h\n<pre><code>enum  some_crap\n{\nSTATUS_ILLEGAL_WHATSIT       =((NTSTATUS)0xC000001DL),\nSTATUS_INVALID_LOCKIT    =((NTSTATUS)0xC000001EL),\nSTATUS_INVALID_VIEWIT        = ((NTSTATUS)0xC000001FL),\nSTATUS_INVALID_FILEIT  =((NTSTATUS)0xC0000020L),\nSTATUS_ALREADY_COMMITIT        =((NTSTATUS)0xC0000021L),\nSTATUS_ACCESS_DENYIT  =           ((NTSTATUS)0xC0000022L)\n};\n:\\>\n</code></pre>\nuse ctrl+f9 and parse it you will get compiled successfully\n<pre><code>\ntst\\tpass.h: successfully compiled\nCaching 'Local Types'... ok\nCaching 'Names'... ok\n</code></pre>\nsee gif for further details\n",
            "votes": "1",
            "user": "blabb",
            "time": "Jan 17, 2022 at 13:10",
            "is_accepted": false,
            "comments": []
        }
    ]
}