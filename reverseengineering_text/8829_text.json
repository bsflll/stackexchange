{
    "title": "Cross debugging for ARM / MIPS ELF with QEMU/toolchain",
    "link": "https://reverseengineering.stackexchange.com/questions/8829/cross-debugging-for-arm-mips-elf-with-qemu-toolchain",
    "content": "as i'm new about cross-debugging and cross-compilation i need some help because i feel so confused. I have a MIPS elf file, [myelf][1] .You can see bellow the output of <pre><code>file myelf</code></pre>:\n<pre><code>myelf: ELF 32-bit LSB executable, MIPS, MIPS-I version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, BuildID[sha1]=0xc89c3571514c7ec1afc74a189a9c2d24e276ec4c, with unknown capability 0xf41 = 0x756e6700, with unknown capability 0x70100 = 0x1040000  stripped\n</code></pre>\nI just want to run and debug the program. So i don't need a cross compiler right ? As i don't have MIPS hardware (i have an INTEL microprocessor), i need an emulator. I've chosen to use QEMU. According to this site, i downloaded the following kernel image and initrds: \n<pre><code>debian_squeeze_mips_standard.qcow2\n\nvmlinux-2.6.32-5-4kc-malta\n</code></pre>\nThen i've run the specified command for a 32 bit (because the elf informations) MIPS system.\n<pre><code>qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append \"root=/dev/sda1 console=tty0\"\n</code></pre>\nSo far, i have the emulator running in one shell and the command uname -a gives me:\n<pre><code>Linux debian-mips 2.6.32-5-4kc-malta #1 Tue Sep 24 00:02:22 UTC 2013 mips GNU/Linux\n</code></pre>\nThere are only the very basics commands/tools on the emulator. I've read that gdb can debug on a remote target (here the MIPS-emulator) from an host machine which is my x86_64. And to be honest i have no idea about what i should do now. I first tried to install gdb itself on the the qemu emulator.When i run gdb my elf i can see that gdb was automatically configured as mips-linux-gnu.\n<pre><code>root@debian-mips:~# gdb myelf \nGNU gdb (GDB) 7.0.1-debian\nCopyright (C) 2009 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"mips-linux-gnu\".\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>...\nReading symbols from /root/myelf...(no debugging symbols found)...done.\n</code></pre>\nThe info files gives me the right informations (i disassembled the elf with IDA so i can confirm).\n<pre><code>(gdb) info files \nSymbols from \"/root/myelf\".\nLocal exec file:\n    `/root/myelf', file type elf32-tradlittlemips.\n    Entry point: 0x400670\n    0x00400154 - 0x00400161 is .interp\n    0x00400164 - 0x00400184 is .note.ABI-tag\n    0x00400184 - 0x0040019c is .reginfo\n    0x0040019c - 0x004001c0 is .note.gnu.build-id\n    0x004001c0 - 0x00400298 is .dynamic\n    0x00400298 - 0x0040033c is .hash\n    0x0040033c - 0x0040049c is .dynsym\n    0x0040049c - 0x0040057b is .dynstr\n    0x0040057c - 0x004005a8 is .gnu.version\n    0x004005a8 - 0x004005d8 is .gnu.version_r\n    0x004005d8 - 0x00400668 is .init\n    0x00400670 - 0x00400b00 is .text\n    0x00400b00 - 0x00400ba0 is .MIPS.stubs\n    0x00400ba0 - 0x00400bec is .fini\n    0x00400bec - 0x00400c2c is .rodata\n    0x00400c2c - 0x00400c30 is .eh_frame\n    0x00410c30 - 0x00410c3c is .ctors\n    0x00410c3c - 0x00410c44 is .dtors\n    0x00410c44 - 0x00410c48 is .jcr\n    0x00410c50 - 0x00410e00 is .data\n    0x00410e00 - 0x00410e04 is .rld_map\n    0x00410e10 - 0x00410e6c is .got\n    0x00410e6c - 0x00410e70 is .sdata\n    0x00410e70 - 0x00410e80 is .bss\n</code></pre>\nBut when i want to run the program nothing is happening:\n<pre><code>(gdb) r\nStarting program: /root/myelf \n</code></pre>\nI waited about 10 mins and nothing happened. (Normally the program should print a string \"Usage : ./myelf password\" as i didn't give any arguments). \nThen i tried with gdbserver on the emulator and a gdb configured for a mipsel processor on the host machine but it didn't work.. \nI may do something wrong or stupid because i'm quite confused. If anybody can tell me what's wrong in my process or if someone tried to run myelf file, I would know how he did in order to be able to run any program on different machine.\nThank you, have a good day!\n",
    "votes": "31",
    "answers": 4,
    "views": "45k",
    "tags": [
        "debugging",
        "gdb",
        "elf",
        "mips",
        "qemu"
    ],
    "user": "creuchmeuch",
    "time": "Dec 4, 2017 at 21:59",
    "comments": [],
    "answers_data": [
        {
            "content": "Get Ready for an Adventure!\nYou need a few things for your quest!  Let's start at the beginning.\nQEMU and GDB\nQEMU is an emulator for various architectures.  Generally, it's used to emulate an entire PC (i.e. to run a virtual machine).  However, for debugging a single program this is not necessary.  On Linux, you can use QEMU User-Space emulation.\n<pre><code>$ sudo apt-get install qemu qemu-user qemu-user-static\n</code></pre>\nAdditionally, the GDB which is installed by default for Ubuntu and similar operating systems does not know anything about other architectures.  Luckily, there is a <pre><code>gdb-multiarch</code></pre> packages which does!\n<pre><code>$ sudo apt-get install gdb-multiarch\n</code></pre>\nFinally, Linux generally relies on the shebang (<pre><code>#!</code></pre>) at the top of shell scripts to inform it what interpreter to use.  For binary files, there is no such standard.  In order to fill this void, the <pre><code>binfmt</code></pre> package can be used to look at what type a file is, and automatically invoke the correct interpreter.  In our case, it will see that you're trying to run a little-endian MIPS (<pre><code>mipsel</code></pre>) binary and invoke <pre><code>qemu-mipsel</code></pre>.\n<pre><code>$ sudo apt-get install 'binfmt*'\n</code></pre>\nRunning Statically-Linked Binaries\nFor a statically-linked MIPSEL binary, this is normally all that would be necessary.  However, the one you linked to relies on external libraries.  If it were statically linked, you could run it now.  You can create an example binary to demonstrate this:\n<pre><code>$ echo 'int main() {puts(\"Hello world!\");}' > hello.c\n$ mipsel-linux-gnu-gcc -xc -static -o mipsel-test hello.c\n$ file mipsel-test\na.out: ELF 32-bit LSB executable, MIPS, MIPS-I version 1 (SYSV), statically linked, for GNU/Linux 2.6.18, BuildID[sha1]=2556cc80429de1ab3116278ac10832d72bd7ebab, not stripped\n$ ./mipsel-test\nHello world!\n</code></pre>\nLibraries\nSince your chosen binary is dynamically linked, you will need to install libraries like <pre><code>libc.so</code></pre> and <pre><code>ld.so</code></pre> for the appropriate architecture.  We also need to tell <pre><code>binfmt</code></pre> where to find them.\nUbuntu provides cross-architecture packages for ARM and AArch64.  For example:\n<pre><code>$ sudo apt-get install libc6-armhf-armel-cross\n</code></pre>\nUbuntu (if older than Ubuntu 16.04 / Xenial)\nUbuntu 14.04 and does not provide packages for MIPS.  Luckily, Debian (which Ubuntu is based off of) does provide packages, and these packages are compatible with Ubuntu.  Un-luckily, Debian does not support little-endian MIPS (mipsel).  Lucky us once again, as a different Debian derivative, Embedded Debian (emdebian) does provide those packages. \nYou can add both repositories to your Ubuntu or other Debian-based distro with the command below.  If you were only working with ARM or AArch64, you don't need to do this.\n<pre><code>$ sudo apt-get install debian-keyring\n$ sudo apt-get install debian-archive-keyring\n$ sudo apt-get install emdebian-archive-keyring\n$ sudo tee /etc/apt/sources.list.d/emdebian.list << EOF\ndeb http://mirrors.mit.edu/debian squeeze main\ndeb http://www.emdebian.org/debian squeeze main\nEOF\n$ sudo apt-get update\n</code></pre>\n\nClean Up\n\nWhen you are done installing the packages (see below), I highly recommend removing the file <pre><code>emdebian.list</code></pre> which we created earlier.  While the Emdebian packages are compatible, <pre><code>apt</code></pre> does weird things and may elect to use a <pre><code>Debian</code></pre> package instead of the one your distro is supposed to.  If you need to install more packages later, you can just add it again.\n<pre><code>$ sudo rm /etc/apt/sources.list.d/emdebian.list\n$ sudo apt-get update\n</code></pre>\nInstalling the libraries\nNow we can install packages!  The package which includes all of the <pre><code>mipsel</code></pre> libraries you need to run the binary you selected is\n<pre><code>$ sudo apt-get install libc6-mipsel-cross      # For MIPS-EL\n$ sudo apt-get install libc6-armhf-armel-cross # For ARM\n</code></pre>\nIf you want to build programs like the sample above, you'll need a cross-compiler.\n<pre><code>$ sudo apt-get install gcc-4.4-mipsel-linux-gnu # For MIPS-EL on Ubuntu 14.04\n$ sudo apt-get install gcc-mipsel-linux-gnu     # For MIPS-EL on Ubuntu 16.04\n$ sudo apt-get install gcc-arm-linux-gnueabihf  # For ARM\n</code></pre>\nVery finally, we need to tell <pre><code>binfmt</code></pre> where the libraries are for <pre><code>mipsel</code></pre> binaries.\n<pre><code>$ sudo mkdir /etc/qemu-binfmt\n$ sudo ln -s /usr/mipsel-linux-gnu /etc/qemu-binfmt/mipsel # MIPSEL\n$ sudo ln -s /usr/arm-linux-gnueabihf /etc/qemu-binfmt/arm # ARM\n</code></pre>\nNow you can run the binary on your system*!\n<pre><code>$ ./myelf\nUsage: ./crackme password\n</code></pre>\nDebugging\nThis is the whole point, right?\nstrace\nThe quickest thing to do is to be able to run <pre><code>strace</code></pre> on the binary.  You can do this with:\n<pre><code>$ qemu-mipsel -strace ./myelf\n12825 brk(NULL) = 0x00411000\n12825 mmap(NULL,4096,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0) = 0x767ca000\n...\n12825 ptrace(0,0,0,0,0,0) = -1 errno=89 (Function not implemented)\nqemu: Unsupported syscall: 4026\n</code></pre>\nYou should've seen from running the binary, and from <pre><code>strace</code></pre>, that this binary attempts to call <pre><code>ptrace</code></pre> on itself.  This is one of the limitations of <pre><code>qemu-user</code></pre>, is that <pre><code>ptrace</code></pre> is not supported.  If the binary needs to ptrace itself, you will need to build a full QEMU system image.  I generally use the ones available here.  Running QEMU is outside the scope of this answer, but the page I linked to has useful command-lines.\nYou can easily remove the <pre><code>ptrace</code></pre> call from the binary (it's anti-debugging stuff), and it runs fine.  However, I think this is part of the crackme :P.\n<pre><code>$./myelf\nKO\n$ sed -i 's|ptrace|isnanl|' myelf\n$ ./myelf\nUsage: ./crackme password\n</code></pre>\nQEMU GDB Stub\nIn order to debug the binary with GDB, you need to launch <pre><code>qemu-mips</code></pre> so that it exposes a GDB stub, and connect from GDB.\n<pre><code>$ qemu-mipsel -g 12345 ./a.out &\n$ gdb-multiarch ./a.out\n(gdb) set arch mips\nThe target architecture is assumed to be mips\n(gdb) set endian little\nThe target is assumed to be little endian\n(gdb) target remote localhost:12345\nRemote debugging using localhost:12345\n0x00400280 in _ftext ()\n(gdb) x/i $pc\n  => 0x767cb880    move   $t9, $ra\n</code></pre>\nYou can now debug as you normally would.  Note that since you're running inside of <pre><code>qemu-user</code></pre>, some commands my not work as expected.  In particular, <pre><code>info proc maps</code></pre> doesn't work.  You may want to take a look at my pwndbg project, which works around some of these limitations.\n",
            "votes": "55",
            "user": "gsgx",
            "time": "May 23, 2016 at 9:16",
            "is_accepted": false,
            "comments": [
                {
                    "user": "creuchmeuch",
                    "text": "<span class=\"comment-copy\">Hello! First of all thank you for your so complete answer! I installed binfmt by: sudo apt-get install binfmt-support.I removed my cross-compiler so i didn't test the statically-linked Binaries.. I then followed every step but when i wanted to tell to binfmt where are the librairies for mipsel binaries. I realized  i didn't have the /etc/qemu-binfmt/ folder. I just have /etc/qemu with a target-x86_64.conf file. So i created /etc/qemu-binfmt/mipsel directories. But when i try to run ./myelf i got:  /lib/ld.so.1: No such file or directory I m lost the problem is from the linking ? or binfmt ?</span>",
                    "time": null
                },
                {
                    "user": "creuchmeuch",
                    "text": "<span class=\"comment-copy\">Sorry for the double comment i wanted to precise that after creating the  /etc/qemu-binfmt/mipsel directories i've execute the following command : sudo ln -s /usr/mipsel-linux-gnu /etc/qemu-binfmt/mipsel . Thanks in advance, i will test for a statically-linked binaries waiting your answer.</span>",
                    "time": null
                },
                {
                    "user": "creuchmeuch",
                    "text": "<span class=\"comment-copy\">Even if i couldn't fix the problem above. I success to run myelf thanks to qemu-mipsel -g 12345 -L /usr/mipsel-linux-gnu ./myelf &amp; . But i have a warning: Unable to find dynamic linker breakpoint function. GDB will be unable to debug shared library initializers and track explicitly loaded dynamic code. Going step by step into the programm, i find the instructions different comparing the instructions by disassembling the elf file with IDA.. Anyway thanks for your help.</span>",
                    "time": null
                },
                {
                    "user": "Zach Riggle",
                    "text": "<span class=\"comment-copy\">The /etc/qemu-binfmt directory does not exist by default.  I've added a comment to that effect.</span>",
                    "time": null
                },
                {
                    "user": "Neon Flash",
                    "text": "<span class=\"comment-copy\">@ZachRiggle When I try to install gcc-4.4-mipsel-linux-gnu on Ubuntu 14.04 using the steps mentioned above, I get an error for the dependency, cpp-4.4-mipsel-linux-gnu. And when I try to install cpp-4.4-mipsel-linux-gnu, it has a dependency on lipgmp3c2 which is not available in Ubuntu repository. How can I install the cross compile tool chain for MIPS on Ubuntu 14.04? Thanks.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "You can try to connect remote gdbserver using radare2 tool, with a following line:\n<pre><code>r2 -a mips gdb://[address]\n</code></pre>\n",
            "votes": "4",
            "user": "Anton Kochkov",
            "time": "Aug 1, 2016 at 15:19",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<pre><code>qemu-system-mips</code></pre> full system emulation with Buildroot\nThis method simulate the entire MIPS CPU and can overcome limitations mentioned with userland emulation at: https://reverseengineering.stackexchange.com/a/8917/12321\nThis script fullys automate everything that is automatable for you: https://github.com/cirosantilli/linux-kernel-module-cheat/tree/1d197f35ee177c6ab3e6a2f518292b8dc4e53431#gdbserver\nBuildroot downloads and compiles the entire target filesystem for us, uncluding <pre><code>gdbserver</code></pre>, and also the host QEMU and <pre><code>gdb</code></pre>. Major steps covered below.\nThe \"only\" things that are now left now are to:\n\ncross compile / install all libraries at the correct version for the executable. stdlib is already cross compiled, but you can still have version mismatch problems with it...\nensure that the dynamic loader is configured correctly. TODO: does Buildroot support customizing it, or can it be patched on the executable itself?\n\nto ensure that you are able to run the executable.\nBut note that those steps are also required for the userland method.\nThe major steps done by my script are:\n\nEnable <pre><code>gdbserver</code></pre> for on the Buildroot configuration:\n<pre><code>BR2_DEBUG_3=y\nBR2_ENABLE_DEBUG=y\nBR2_OPTIMIZE_0=y\nBR2_PACKAGE_GDB=y\nBR2_PTHREAD_DEBUG=y\n</code></pre>\nUse <pre><code>BR2_ROOTFS_OVERLAY</code></pre> on the Buildroot configuration to place the executable in the filesystem.\nForward a host port to the QEMU target with the command line options (here <pre><code>45455</code></pre> to <pre><code>45455</code></pre>):\n<pre><code>-net user,hostfwd=tcp::45455-:45455\n</code></pre>\nLaunch <pre><code>gdbserver</code></pre> on target:\n<pre><code>gdbserver :45455 myexec\n</code></pre>\nLaunch the cross compiled GDB from host and point it to the cross compiled executable and the forwarded port:\n<pre><code>buildroot/output/host/usr/bin/mips64-linux-gdb \\\n  -ex 'target remote localhost:45455' \\\n  -ex 'tb main' \\\n  -ex 'c' \\\n  buildroot/output/build/mypackage-1.0.0/myexec\n</code></pre>\n\nMinimal working user mode example\nAs a quicker and dirtier alternative to full system, you might get away with user mode as described in detail at: https://stackoverflow.com/questions/20590155/how-to-single-step-arm-assembly-in-gdb-on-qemu/51310791#51310791\n",
            "votes": "2",
            "user": "Ciro Santilli OurBigBook.com",
            "time": "Oct 19, 2018 at 17:17",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "I want just to add a quick receipt about <pre><code>qemu-user</code></pre> and <pre><code>ptrace</code></pre>.\n\nStart <pre><code>qemu-binfmt</code></pre> service on the host to register qemu-user binaries.\nUse <pre><code>buildah</code></pre> to create amd64 container.\nInstall latest qemu inside this amd64 container, kernel will use them instead of host.\nBuild some toolchain inside amd64 container.\nUse regular <pre><code>strace</code></pre> to trace your binaries.\n\nFor example:\n<pre><code>buildah copy 2f64fe2cdbfd /tmp/readdir32.c /tmp/\nbuildah run --cap-add=CAP_SYS_PTRACE 2f64fe2cdbfd -- sh -c \"mips-unknown-linux-gnu-gcc /tmp/readdir32.c -o /tmp/readdir32 && LD_PRELOAD='/usr/mips-unknown-linux-gnu/lib/libc.so.6' strace -v /tmp/readdir32\"\n</code></pre>\n\nwrite(1, \"errno 89 Function not implemente\"...\n\nWorks perfect.\nFull examples are here. Please be aware - test images are not completed, I am still fighting with mips.\n",
            "votes": "1",
            "user": "puchu",
            "time": "Jan 6, 2020 at 12:53",
            "is_accepted": false,
            "comments": []
        }
    ]
}