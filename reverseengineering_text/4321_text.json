{
    "title": "How to edit an executable's \".data\" segment?",
    "link": "https://reverseengineering.stackexchange.com/questions/4321/how-to-edit-an-executables-data-segment",
    "content": "This is a question related to another question I asked a few days ago; I recommend you to give a quick read to it here because it can contain useful information.\nAnyway, I have two static classes inside my target executable (<pre><code>ECX</code></pre> register always spotted inside classes' methods), and it clearly looks like the first one contains the second one:\n<pre><code>.data:0190BD08 CFG_DB db ; DATA XREF: sub_40FFF0:loc_410049o\n// 4 Bytes\n.data:0190BD0C CFG_DB_TABLE<struct CFG_ENTRY[500], unsigned int> db ; DATA XREF: sub_A3DDD0+2Co\n// 30 Bytes\n.data:0190BD3C dword_190BD3C dd ? ; int dword_190BD3C[] DATA XREF: sub_5F5F70+B2r\n\nWith sub_40FFF0:loc_410049o =\n    CFG_DB_TABLE_Reset((int)&CFG_DB);\n</code></pre>\nHere is the <pre><code>Virtual Function Table</code></pre> of the first one:\n<pre><code>.rdata:0137A1F0 dd offset CFG_DB\n.rdata:0137A1F4 ??_7CFG_DB@@6B@ dd offset CFG_DB_Constructor\n.rdata:0137A1F4     ; DATA XREF: CFG_DB_CreateInstance+8o\n.rdata:0137A1F8 dd offset nullsub_008EF050\n.rdata:0137A1FC dd offset sub_8EAB30\n.rdata:0137A200 dd offset sub_8EF060\n.rdata:0137A204 dd offset CFG_DB_TABLE_Reset\n.rdata:0137A208 dd offset CFG_DB_ParseData\n.rdata:0137A20C dd offset CFG_DB_ReadFile\n</code></pre>\nAnd the <pre><code>Virtual Function Table</code></pre> of the second one:\n<pre><code>.rdata:0137A1D4 dd offset CFG_DB_TABLE\n.rdata:0137A1D8 ??_7?$CFG_DB_TABLE@UCFG_ENTRY@@$0BPE@I@@6B@ dd offset CFG_DB_TABLE_Constructor\n.rdata:0137A1D8     ; DATA XREF: CFG_DB_TABLE_Destructor+1Do\n.rdata:0137A1D8     ; DATA XREF: CFG_DB_TABLE_CreateInstance+38o\n.rdata:0137A1DC dd offset nullsub_008EF050\n.rdata:0137A1E0 dd offset sub_8EAB30\n.rdata:0137A1E4 dd offset sub_8EF060\n.rdata:0137A1E8 dd offset CFG_DB_TABLE_Reset\n.rdata:0137A1EC dd offset CFG_DB_ParseData\n</code></pre>\nIn pseudo-code all this should look like this:\n<pre><code>static CFG_DB cfgDB;\n\nclass CFG_DB\n{\n    int memoryAddress;\n    static CFG_DB_TABLE _DBTable;\n    // more data?\n};\n\nstruct CFG_DB_TABLE\n{\n    int memoryAddress;\n    CFG_ENTRY cfgEntries[500];\n    int       filledSlotsCount;\n    // more data...\n};\n</code></pre>\nAll I want to do is to increase the size of <pre><code>CFG_ENTRY</code></pre> structure's array located in <pre><code>CFG_DB_TABLE</code></pre> from <pre><code>500</code></pre> to <pre><code>1000</code></pre>. Knowing the size of <pre><code>CFG_ENTRY</code></pre> structure (it's <pre><code>996</code></pre> bytes), it appears to be a quite simple task to do. Becaose of the fact that the <pre><code>filledSlotsCount</code></pre> (referenced by many times in the code) is placed at the end of the struct I can proceed using two different approchaes:\n\nIncreasing the size of the existing <pre><code>cfgEntries</code></pre> to <pre><code>1000</code></pre> and increasing also every pointer reference to <pre><code>filledSlotsCount</code></pre> and other variables by 996*500.\nAppending a <pre><code>CFG_ENTRY newCfgEntries[1000]</code></pre> to the end of the structure and setting every pointer reference to <pre><code>cfgEntries</code></pre> by sizeof(CFG_DB_TABLE)-(996*1000). This one seems to be the simpler one.\n\nSo, for example, using the first approach, this small piece of <pre><code>CFG_DB_ParseData</code></pre>'s code:\n<pre><code>while (true)\n{\n    currentFilledSlotsCount = *(_DWORD *)(pointerToCFG_DB_TABLE + 498004);\n\n    if ( currentFilledSlotsCount >= 500 )\n        break;\n\n    *(_DWORD *)(pointerToCFG_DB_TABLE + 498004) = currentFilledSlotsCount + 1;\n\n    if (!CFG_DB_ParseEntry((void *)(pointerToCFG_DB_TABLE + 996 * currentFilledSlotsCount + 4), v5) )\n    {\n</code></pre>\nBecomes:\n<pre><code>while (true)\n{\n    currentFilledSlotsCount = *(_DWORD *)(pointerToCFG_DB_TABLE + 996004);\n\n    if ( currentFilledSlotsCount >= 1000 )\n        break;\n\n    *(_DWORD *)(pointerToCFG_DB_TABLE + 996004) = currentFilledSlotsCount + 1;\n\n    if (!CFG_DB_ParseEntry((void *)(pointerToCFG_DB_TABLE + 996 * currentFilledSlotsCount + 4), v5) )\n    {\n</code></pre>\nAnd the code of method <pre><code>CFG_DB_TABLE_CreateInstance</code></pre> becomes:\n<pre><code>int __thiscall CFG_DB_TABLE_CreateInstance(int this)\n{\n    int v1; // esi@1\n    int v2; // [sp+18h] [bp-28h]@1\n\n    v1 = this;\n    v2 = this;\n\n    *(_DWORD *)this = &CFG_DB_TABLE<CFG_ENTRY_500_unsigned_int>::_vftable_;\n    unknown_libname_2672((void *)(this + 4), 996, 1000, sub_8EECA0, sub_8EEA00);\n</code></pre>\nNow... doing these modifications I avoided memory overlapping/overwriting into the classes themselves, but I still have to deal with the <pre><code>.data segment</code></pre> itself, right? In fact I think I have to extend its size by 996*500 and, as suggested by other users that helped me out in my previous question, I should also move:\n<pre><code>.data:0190BD08 CFG_DB db\n.data:0190BD0C CFG_DB_TABLE<struct CFG_ENTRY[500], unsigned int> db\n</code></pre>\nTo the bottom of the <pre><code>.data segment</code></pre>, right? Otherwise the memory of those static classes risks to run over the memory of static instances that are located after them in the segment.\nMy questions are quite simple:\n1) How can it be possible that the size of the static <pre><code>CFG_DB_TABLE</code></pre> is only 30 bytes in the <pre><code>.data segment</code></pre> (data:0190BD3C - data:0190BD0C) if it contains <pre><code>4+996*500*4=498008</code></pre> bytes minimum (but probably even more because I saw some pointer references starting from it like <pre><code>this+502036</code></pre>)? Am I missing something very important in my calculations?\n2) How can I move extend the size of the <pre><code>.data segment</code></pre> by 996*500? Do I have to manually edit the PE header values?\n3) If this is really necessary... how can I move my static data references concerning <pre><code>CFG_DB</code></pre> and <pre><code>CFG_DB_TABLE</code></pre> instances from the middle to the bottom of the <pre><code>.data segment</code></pre> itself? Is there any tool out there that can do this also taking care of rewriting every reference to them?\n",
    "votes": "3",
    "answers": 1,
    "views": "5k",
    "tags": [
        "assembly",
        "decompilation",
        "debugging",
        "memory"
    ],
    "user": "Zarathos",
    "time": "Apr 13, 2017 at 12:49",
    "comments": [
        {
            "user": "Chris Eagle",
            "text": "Maybe an off the wall question, but what is the layout of a CFG_ENTRY? Does an individual entry really require 996 bytes? What is the largest single entry? If no entry is larger than say 498 bytes, perhaps it is possible to modify CFG_ENTRY to cut its size in half effectively doubling the capacity of your existing CFG_DB_TABLE table.\n",
            "time": null
        },
        {
            "user": "Zarathos",
            "text": "In fact yes, every single chunk of data is being modified for every CFG_ENTRY as soon as the routing for parsing the CFG file starts. The last DWORD [992 to 996] looks like a counter. It starts from 0 for the first entry and, for the last one, is 499. Even if the data on the middle is not being used... it would be a real hell to modify the structure.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "There are many confusing things in your first question. With 2nd & 3rd question, I think the answer is absolutely possible but it requires many works (manually). You could use some PE Tools (PE Editor tools - Lord PE is a good example) to resize the section and modify the data in the section (in binary Hex mode). And to validate all the references of your old structure pointer, you can use some disassembly tools like IDA, OllyDbg to find the position of all the references and modify it in hex mode.\nIn brief, I summary my solution as follow:\n\nUse PE Editor (Lord PE) to resize the .data section and any sections\nyou will modify (turn on the Write Flag in these sections).\nIn some case PE Editor not update the PE Header, so you must do it\nmanually to get a valid image (that can load in memory and run).\nUsing OllyDbg to edit, modify binary data in memory (with disassembly support :)) to change your data structure and all references so it will be easier to trace, debug. After\nall your modifying, you should dump and fix IAT (like unpacking PE\nfiles). In some case, your modifying not work in OllyDbg, you should use a Hex Editor or Lord PE (again) to add binary data manually.\n\nThis is not difficult but requires hardworking and careful, Good luck!\n",
            "votes": "1",
            "user": "tuantm",
            "time": "Jun 9, 2014 at 3:00",
            "is_accepted": false,
            "comments": []
        }
    ]
}