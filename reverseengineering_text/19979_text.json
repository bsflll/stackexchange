{
    "title": "What does fs and gs registers provide in Linux?",
    "link": "https://reverseengineering.stackexchange.com/questions/19979/what-does-fs-and-gs-registers-provide-in-linux",
    "content": "In a 64 bit ELF binary I found it mainly uses <pre><code>fs</code></pre> register to get some values. How can I know which value it wants to access? I'm familiar with that NT kernel uses <pre><code>fs</code></pre> and <pre><code>gs</code></pre> register for TEB structure in 32 bit and 64 bit OS respectively. \nHere are two examples:\n1.\n<pre><code>mov rax, fs:28h\nmov [rsp+88], rax\n</code></pre>\n2.\n<pre><code>sub_a proc near\nmov rax, fs:0\nadd rax, 44h\nretn\nsub_a endp\n</code></pre>\n",
    "votes": "4",
    "answers": 1,
    "views": "7k",
    "tags": [
        "assembly",
        "x86",
        "linux"
    ],
    "user": "Biswapriyo",
    "time": "Nov 27, 2018 at 5:09",
    "comments": [],
    "answers_data": [
        {
            "content": "The <pre><code>gs</code></pre>/<pre><code>fs</code></pre> segment can be used for thread local storage similar to what you have encountered in Windows. Variable specific to a thread such as <pre><code>errno</code></pre>, stack canary etc are usually stored here in Linux. \nAccording to this, your first example is to save canary to the stack from <pre><code>fs:0x28</code></pre>. You can see some hacks here and read more here\nCanary check from an example binary \n<pre><code>$ tail x.c \n\n#include <stdio.h>\n\nint main(int argc, char **argv)\n{\n    char s[32];\n    scanf(\"%s\", s);\n    return 0;\n}\n\n$ gcc -no-pie -fno-pic x.c -o z64   \n$ gcc -m32 -no-pie -fno-pic x.c -o z32   \n$ r2 -AA z32 -qc \"pdf @ sym.main\"     \n            ;-- main:\n┌ (fcn) sym.main 86\n....\n│           0x080484bf      65a114000000   mov eax, dword gs:[0x14]    ; [0x14:4]=-1 ; 20\n│           0x080484c5      8945f4         mov dword [local_ch], eax\n│           0x080484c8      31c0           xor eax, eax\n....\n│           0x080484e3      8b55f4         mov edx, dword [local_ch]\n│           0x080484e6      653315140000.  xor edx, dword gs:[0x14]\n│       ┌─< 0x080484ed      7405           je 0x80484f4\n│       │   0x080484ef      e85cfeffff     call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void)\n....\n$ r2 -AA z64 -qc \"pdf @ sym.main\"\n            ;-- main:\n┌ (fcn) sym.main 79\n....\n│           0x00400586      64488b042528.  mov rax, qword fs:[0x28]    ; [0x28:8]=-1 ; '(' ; 40\n│           0x0040058f      488945f8       mov qword [local_8h], rax\n│           0x00400593      31c0           xor eax, eax\n....\n│           0x004005b0      488b55f8       mov rdx, qword [local_8h]\n│           0x004005b4      644833142528.  xor rdx, qword fs:[0x28]\n│       ┌─< 0x004005bd      7405           je 0x4005c4\n│       │   0x004005bf      e8acfeffff     call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void)\n....\n</code></pre>\nAlso for your second request, yes that is <pre><code>pthread_t</code></pre> at offset 0 in <pre><code>fs</code></pre>/<pre><code>gs</code></pre>.\n<pre><code>$ tail -n 30 x.c\n\n#ifdef __x86_64__\n#define val_t     uint64_t\n#define INSN_READ    \"movq %%fs:0, %0;\"\n#define FMT          \"Found val: %#lx\n\"\n\n#elif __i386__\n#define val_t     uint32_t\n#define INSN_READ    \"movl %%gs:0, %0;\"\n#define FMT          \"Found val: %#x\n\"\n#endif\n\nval_t read_val()\n{\n    val_t val = 0;\n\n    __asm__(INSN_READ\n        : \"=r\"(val)\n        :\n        :);\n\n    return val;\n}\nint main(int argc, char **argv)\n{\n    printf(FMT, read_val());\n    printf(FMT, (val_t)pthread_self());\n    return 0;\n}\n\n$ gcc -no-pie -fno-pic x.c -o zm64\n$ gcc -m32 -no-pie -fno-pic x.c -o zm32\n\n$ ./zm32 \nFound val: 0xf7f800c0\nFound val: 0xf7f800c0\n\n$ ./zm64 \nFound val: 0x7fd50119f4c0\nFound val: 0x7fd50119f4c0\n</code></pre>\nI tried to look for your second snippet in my <pre><code>libc</code></pre> but couldn't find it. SO can't answer for sure what it contains at <pre><code>0x44</code></pre>. While debugging I only got 0s at that offset.\n<pre><code>  $ r2 /lib/x86_64-linux-gnu/libc.so.6\n   -- There is only one binary, and we are all just reversing pieces of it.\n  [0x00021cb0]> /x `!rasm2 -a x86.as -b 64 \"mov rax, fs:[0]\"`\n  Searching 9 bytes in [0x0-0x1e6aa0]\n  hits: 7\n  Searching 9 bytes in [0x3e7620-0x3f0ae0]\n  hits: 0\n  0x000e18c9 hit0_0 64488b042500000000\n  0x000e1d8a hit0_1 64488b042500000000\n  0x00105cff hit0_2 64488b042500000000\n  0x00105e50 hit0_3 64488b042500000000\n  0x00105f21 hit0_4 64488b042500000000\n  0x00106865 hit0_5 64488b042500000000\n  0x0014a18a hit0_6 64488b042500000000\n  [0x00021cb0]> pd10 @@ hit0_*\n              ;-- hit0_0:\n              0x000e18c9      64488b042500.  mov rax, qword fs:[0]\n              0x000e18d2      31db           xor ebx, ebx\n              0x000e18d4      48c744241800.  mov qword [rsp + 0x18], 0\n              0x000e18dd      4c8b25849530.  mov r12, qword [0x003eae68] ; [0x3eae68:8]=0\n              0x000e18e4      48890424       mov qword [rsp], rax\n              0x000e18e8      488d442450     lea rax, [rsp + 0x50]       ; \"@\" ; 'P'\n              0x000e18ed      4889442430     mov qword [rsp + 0x30], rax\n              0x000e18f2      488d442460     lea rax, [rsp + 0x60]       ; '`'\n              0x000e18f7      4889442420     mov qword [rsp + 0x20], rax\n              0x000e18fc      488d442458     lea rax, [rsp + 0x58]       ; \"@\" ; 'X'\n              ;-- hit0_1:\n              0x000e1d8a      64488b042500.  mov rax, qword fs:[0]\n              0x000e1d93      31db           xor ebx, ebx\n              0x000e1d95      48c744242800.  mov qword [rsp + 0x28], 0\n              0x000e1d9e      4c8b25c39030.  mov r12, qword [0x003eae68] ; [0x3eae68:8]=0\n              0x000e1da5      4889442410     mov qword [rsp + 0x10], rax\n              0x000e1daa      488d442460     lea rax, [rsp + 0x60]       ; '`'\n              0x000e1daf      4889442440     mov qword [rsp + 0x40], rax\n              0x000e1db4      488d442470     lea rax, [rsp + 0x70]       ; 'p'\n              0x000e1db9      4889442430     mov qword [rsp + 0x30], rax\n              0x000e1dbe      488d442468     lea rax, [rsp + 0x68]       ; 'h'\n              ;-- hit0_2:\n              0x00105cff      64488b042500.  mov rax, qword fs:[0]\n              0x00105d08      488b1d41512e.  mov rbx, qword [0x003eae50] ; [0x3eae50:8]=0\n              0x00105d0f      4c8b2d52512e.  mov r13, qword [0x003eae68] ; [0x3eae68:8]=0\n              0x00105d16      4c8d3c18       lea r15, [rax + rbx]\n              0x00105d1a      48898560feff.  mov qword [rbp - 0x1a0], rax\n              0x00105d21      4c89e7         mov rdi, r12\n              0x00105d24      e807060600     call sym._dl_mcount_wrapper_check\n              0x00105d29      488b8560feff.  mov rax, qword [rbp - 0x1a0]\n              0x00105d30      4883ec08       sub rsp, 8\n              0x00105d34      498b4e08       mov rcx, qword [r14 + 8]    ; sym.__resp ; [0x8:8]=0\n              ;-- hit0_3:\n              0x00105e50      64488b042500.  mov rax, qword fs:[0]\n              0x00105e59      4c8b2d08502e.  mov r13, qword [0x003eae68] ; [0x3eae68:8]=0\n              0x00105e60      4c8dbd98feff.  lea r15, [rbp - 0x168]\n              0x00105e67      488b1de24f2e.  mov rbx, qword [0x003eae50] ; [0x3eae50:8]=0\n              0x00105e6e      48c78598feff.  mov qword [rbp - 0x168], 0\n              0x00105e79      48898560feff.  mov qword [rbp - 0x1a0], rax\n              0x00105e80      4c01e8         add rax, r13                ; 'o'\n              0x00105e83      48898508feff.  mov qword [rbp - 0x1f8], rax\n              0x00105e8a      660f1f440000   nop word [rax + rax]\n              0x00105e90      4c89e7         mov rdi, r12\n              ;-- hit0_4:\n              0x00105f21      64488b042500.  mov rax, qword fs:[0]\n              0x00105f2a      4c8b2d374f2e.  mov r13, qword [0x003eae68] ; [0x3eae68:8]=0\n              0x00105f31      4c8dbd98feff.  lea r15, [rbp - 0x168]\n              0x00105f38      488b1d114f2e.  mov rbx, qword [0x003eae50] ; [0x3eae50:8]=0\n              0x00105f3f      48c78598feff.  mov qword [rbp - 0x168], 0\n              0x00105f4a      48898560feff.  mov qword [rbp - 0x1a0], rax\n              0x00105f51      4c01e8         add rax, r13                ; 'o'\n              0x00105f54      48898508feff.  mov qword [rbp - 0x1f8], rax\n              0x00105f5b      0f1f440000     nop dword [rax + rax]\n              0x00105f60      4c89e7         mov rdi, r12\n              ;-- hit0_5:\n              0x00106865      64488b042500.  mov rax, qword fs:[0]\n              0x0010686e      488db5c0feff.  lea rsi, [rbp - 0x140]\n              0x00106875      4c8b0dd4452e.  mov r9, qword [0x003eae50]  ; [0x3eae50:8]=0\n              0x0010687c      488b8d20feff.  mov rcx, qword [rbp - 0x1e0]\n              0x00106883      ba00010000     mov edx, 0x100\n              0x00106888      4885ff         test rdi, rdi\n              0x0010688b      490f44fd       cmove rdi, r13\n              0x0010688f      4901c1         add r9, rax                 ; '#'\n              0x00106892      480305cf452e.  add rax, qword [0x003eae68]\n              0x00106899      4989c0         mov r8, rax\n              ;-- hit0_6:\n              0x0014a18a      64488b042500.  mov rax, qword fs:[0]\n              0x0014a193      4c89fb         mov rbx, r15\n              0x0014a196      4889442440     mov qword [rsp + 0x40], rax\n              0x0014a19b      488d442460     lea rax, [rsp + 0x60]       ; '`'\n              0x0014a1a0      4889442408     mov qword [rsp + 8], rax\n              0x0014a1a5      488b4500       mov rax, qword [rbp]\n              0x0014a1a9      488b7c2458     mov rdi, qword [rsp + 0x58] ; [0x58:8]=64 ; 'X'\n              0x0014a1ae      4889442410     mov qword [rsp + 0x10], rax\n              0x0014a1b3      488b03         mov rax, qword [rbx]\n              0x0014a1b6      4889442418     mov qword [rsp + 0x18], rax\n  [0x00021cb0]> \n</code></pre>\n",
            "votes": "10",
            "user": "0xC0000022L",
            "time": "Nov 28, 2018 at 8:26",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Biswapriyo",
                    "text": "<span class=\"comment-copy\">Thank you for the full answer. One side-question. I've not found the definition of pthread structure to get the variable at <code>rax + 0x44</code>.</span>",
                    "time": null
                },
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">@Biswapriyo I added a link. The definition of that type ought to be in <code>sys/types.h</code> (e.g. in <code>/usr/include/x86_64-linux-gnu/sys/types.h</code>) ... which in turn includes <code>pthreadtypes.h</code> (e.g. <code>/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h</code>) which has <code>typedef unsigned long int pthread_t;</code>. But mind that this is system/architecture-specific.</span>",
                    "time": null
                },
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">@Biswapriyo did you actually head to the files I pointed out? There is an interesting comment just above the definition of <code>pthread_t</code> which I gave you above ...</span>",
                    "time": null
                },
                {
                    "user": "Biswapriyo",
                    "text": "<span class=\"comment-copy\">I found the answer. The <code>rax+0x40</code> is the offset of <code>errno</code> (4 bytes takes <code>rax+0x44</code>). There may be some relation between <code>pthread</code> and <code>errno</code>.</span>",
                    "time": null
                },
                {
                    "user": "FERcsI",
                    "text": "<span class=\"comment-copy\">@Biswapriyo, Where did you find this info? I need rax+0x3c, but do not find also, what you succeeded</span>",
                    "time": null
                }
            ]
        }
    ]
}