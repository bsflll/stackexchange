{
    "title": "Does anyone recognize this keyboard encoding scheme?",
    "link": "https://reverseengineering.stackexchange.com/questions/8293/does-anyone-recognize-this-keyboard-encoding-scheme",
    "content": "I am finalizing the reverse-engineering of a linux driver for the Perixx MX-2000 IIB mouse. One of the features the mouse has is arbitrary button mapping. I can assign a button to produce various keys or mouse buttons. I have recorded a few button assignments available in the Windows driver, and figured out a few myself, but there doesn't seem to be a discernible (to me) pattern to map the whole address space.\nThe keys behave like this: Two bytes control a particular mouse button. I have learned a few keys and modifiers, and will post below. Setting the mouse button to the hex value gives me keyboard output when clicked. \nkeyboard output | hex value\na | <pre><code>0x0400</code></pre>\nb | <pre><code>0x0500</code></pre>\nc | <pre><code>0x0600</code></pre>\n...\nz | <pre><code>0x1D00</code></pre>\n1 | <pre><code>0x1E00</code></pre>\n2 | <pre><code>0x1F00</code></pre>\n...\n9 | <pre><code>0x2600</code></pre>\n0 | <pre><code>0x2700</code></pre>\nreturn | <pre><code>0x2800</code></pre>\nesc | <pre><code>0x2900</code></pre>\nbackspace | <pre><code>0x2A00</code></pre>\ntab | <pre><code>0x2B00</code></pre>\nspace | <pre><code>0x2C00</code></pre>\n...\nVolume Up | <pre><code>0x8000</code></pre> (XF86AudioRaiseVolume)\nVolume Down | <pre><code>0x8100</code></pre> (XF86AudioLowerVolume)\n...  \nI've mapped through <pre><code>0x8A00</code></pre> but will spare you the whole table. The interesting things are that thing like XF86 commands appear pretty early, like in <pre><code>0x6F00</code></pre> is XF86AudioMicMute, or <pre><code>0x6600</code></pre> is the power off key.\nAs for the least significant byte, part of that is modifiers, applied as a mask. Ctl is <pre><code>(1 << 0)</code></pre>, shift is <pre><code>(1 << 1)</code></pre>, alt is <pre><code>(1 << 2)</code></pre> and super/meta/windows is <pre><code>(1<<3)</code></pre>. So this way, shift+a (capital A) is <pre><code>0x0402</code></pre>. Ctl+Alt+a would be <pre><code>0x0405</code></pre>. All four modifiers give you <pre><code>0x0F</code></pre> for the least sig. byte. Playing around with the high nybble of the LSB, say with values like <pre><code>0x0440</code></pre> gives me more keys, like XF86Mute. So it seems the address space is massive.\nOn top of this, there are some keys from the windows driver that presented as an entirely different scheme.\nOutput | hex value\naMouse Scroll up | <pre><code>0x0143</code></pre>\nMouse Scroll down | <pre><code>0xFF43</code></pre>\nWWW Search | <pre><code>0x2122</code></pre>\nWWW Back | <pre><code>0x2422</code></pre>\nWWW Forward | <pre><code>0x2522</code></pre>\nEmail | <pre><code>0x8A21</code></pre>\nInternet Expl Back | <pre><code>0x8842</code></pre> (presents as mouse button 8 in X11)\nIE Forward | <pre><code>0x9042</code></pre> (mouse button 9)\nCalculator | <pre><code>0x9221</code></pre>\nMy Computer | <pre><code>0x9421</code></pre>\nMute | <pre><code>0xE220</code></pre>\nVolume Up | <pre><code>0xE920</code></pre>\nVolume Down | <pre><code>0xEA20</code></pre> \nAnd a few mouse buttons:\noutput | hex\nLeft Click | <pre><code>0x8142</code></pre>\nRight Click | <pre><code>0x8242</code></pre>\nWheel Click | <pre><code>0x8442</code></pre> \nand finally, these are internal mouse commands. They don't register any events on my linux machine, but do change things in the mouse's internal settings\naction | hex\nCycle DPI setting | <pre><code>0x034A</code></pre>\nDPI increase | <pre><code>0x014A</code></pre>\nDPI decrease | <pre><code>0x004A</code></pre>\nCycle mouse profile | <pre><code>0x074A</code></pre>\nProfile Up | <pre><code>0x054A</code></pre>\nProfile Down | <pre><code>0x044A</code></pre> \nAnd finally there is a special set that looks like <pre><code>0x0a88</code></pre> that point internally to macro memory.\nI can't find any encoding schemes or keyboard mappings that might match this. Alphabetical keys? And If you notice, volume up is both <pre><code>0x8000</code></pre> and <pre><code>0xE920</code></pre> while vol down is both <pre><code>0x8100</code></pre> and <pre><code>0xEA20</code></pre>. So somewhat of a light at the end of the tunnel that there is a consistent distance between those. \nBut really, I can't figure out a standard mapping this matches. Or any way to figure out all the keys without manually fiddling with the memory and looping through <pre><code>0x0000</code></pre> to <pre><code>0xFFFF</code></pre> and clicking with <pre><code>xev</code></pre> each time.\nThoughts? is any of this familiar? or other patterns spotted?\nedit: All key information I've mapped so far is in this gist including <pre><code>0x0000</code></pre> through <pre><code>0xFF00</code></pre> (leaving LSByte <pre><code>0x00</code></pre>). So there is still a massive address space left. And it still makes no sense to me with the extra keys from the windows driver like <pre><code>0x9421</code></pre> = XF86Explorer\n",
    "votes": "4",
    "answers": 1,
    "views": "334",
    "tags": [
        "encodings",
        "driver"
    ],
    "user": "Dan P",
    "time": "Feb 5, 2019 at 9:06",
    "comments": [],
    "answers_data": [
        {
            "content": "Those are 16-bit USB keyboard/Keypad scan codes. Please see Keyboard Scan Code Specification for details. Appendix C contains the complete mapping\n",
            "votes": "3",
            "user": "Lorem Ipsum",
            "time": "Feb 22, 2015 at 21:24",
            "is_accepted": true,
            "comments": []
        }
    ]
}