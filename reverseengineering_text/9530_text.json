{
    "title": "Detection of OllyDbg - INT3? [closed]",
    "link": "https://reverseengineering.stackexchange.com/questions/9530/detection-of-ollydbg-int3",
    "content": "Closed. This question needs details or clarity. It is not currently accepting answers.\n                                \n                            \n\n\n\n\n\n\n\n\n\n\n\nWant to improve this question? Add details and clarify the problem by editing this post.\n\n\nClosed 9 years ago.\n\n\n\n\n\n\n\n                        Improve this question\n                    \n\n\n\nI am trying to catch anti debugging routines, and I don't quite understand what INT3 does, and I have read that it can be used to detect debuggers and mask calls.  The program eventually sends me into a nonsensical loop if I am stepping, and if I am running, it will notify me that a debugger has been found.  \n<pre><code>77BE0000   8B4424 04        MOV EAX,DWORD PTR SS:[ESP+4]\n77BE0004   CC               INT3\n77BE0005   C2 0400          RETN 4\n77BE0008 > CC               INT3\n77BE0009   90               NOP\n77BE000A   C3               RETN\n77BE000B   90               NOP\n77BE000C > CC               INT3\n77BE000D   C3               RETN\n</code></pre>\nI think INT3 might be something going on here.  Since my intel instruction set reference (http://faydoc.tripod.com/cpu/index_i.htm) says this has something to do with a debugger interrupt.  I also read something about how these can be used to mask debugger detection from reverse engineers.\nAm I barking up the wrong tree or is there something in this line of code questionable?\n",
    "votes": "2",
    "answers": 1,
    "views": "3k",
    "tags": [
        "disassembly",
        "anti-debugging"
    ],
    "user": "Chemistpp",
    "time": "9 years ago",
    "comments": [],
    "answers_data": [
        {
            "content": "This technique uses the fact that when the interrupt instructions INT3 (breakpoint) and INT1 \n(single-step) are stepped thru inside a debugger, by default, the exception handler will not be \ninvoked since debuggers typically handle the exceptions generated by these interrupts. Thus, \na packer can set flags inside the exception handler, and if these flags are not set after the INT \ninstruction, it means that the process is being debugged. Additionally, kernel32!DebugBreak() \ninternally invokes an INT3 and some packers use the said API instead. \nReference\n",
            "votes": "4",
            "user": "RCECoder",
            "time": "Aug 2, 2015 at 11:09",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Chemistpp",
                    "text": "<span class=\"comment-copy\">Thank you very much for the link!  If you have any other tips or data regarding catching non-trivial anti-debugging code, I'd love to read it.  I'm still reading all the info (as this links out to several others), hopefully I get to the part it discusses circumventing it.</span>",
                    "time": null
                }
            ]
        }
    ]
}