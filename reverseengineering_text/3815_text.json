{
    "title": "Reversing ELF 64-bit LSB executable, x86-64 ,gdb",
    "link": "https://reverseengineering.stackexchange.com/questions/3815/reversing-elf-64-bit-lsb-executable-x86-64-gdb",
    "content": "I'm a newbie and just got into RE.\nI got a ELF 64-bit LSB executable, x86-64. I'm trying to reverse it.\nFirst I tried to set a break point on line 1 using\n<pre><code>gdb ./filename\nbreak 1\n</code></pre>\nThe gdb says\n<pre><code>No symbol table is loaded.  Use the \"file\" command.\n</code></pre>\nOKie so gave out file command\n<pre><code>(gdb) file filename\nReading symbols from /media/Disk/filename...(no debugging symbols found)...done.\n</code></pre>\nHow could a set a break point to see the execution..?\n",
    "votes": "28",
    "answers": 1,
    "views": "113k",
    "tags": [
        "gdb",
        "elf",
        "x86-64"
    ],
    "user": "nkg",
    "time": "Mar 7, 2014 at 6:55",
    "comments": [],
    "answers_data": [
        {
            "content": "Getting the entrypoint\nIf you have no useful symbol, you first need to find the entrypoint of the executable. There are several ways to do it (depending on the tools you have or the tools you like the best):\n\nUsing <pre><code>readelf</code></pre>\n<pre><code>$> readelf -h /bin/ls\nELF Header:\nMagic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \nClass:                             ELF64\nData:                              2's complement, little endian\nVersion:                           1 (current)\nOS/ABI:                            UNIX - System V\nABI Version:                       0\nType:                              EXEC (Executable file)\nMachine:                           Advanced Micro Devices X86-64\nVersion:                           0x1\nEntry point address:               0x40489c\nStart of program headers:          64 (bytes into file)\nStart of section headers:          108264 (bytes into file)\nFlags:                             0x0\nSize of this header:               64 (bytes)\nSize of program headers:           56 (bytes)\nNumber of program headers:         9\nSize of section headers:           64 (bytes)\nNumber of section headers:         27\nSection header string table index: 26\n</code></pre>\nSo, the entrypoint address is <pre><code>0x40489c</code></pre>.\nUsing <pre><code>objdump</code></pre>\n<pre><code>$> objdump -f /bin/ls\n\n/bin/ls:     file format elf64-x86-64\narchitecture: i386:x86-64, flags 0x00000112:\nEXEC_P, HAS_SYMS, D_PAGED\nstart address 0x000000000040489c\n</code></pre>\nAgain, the entrypoint is <pre><code>0x000000000040489c</code></pre>.\nUsing <pre><code>gdb</code></pre>\n<pre><code>$> gdb /bin/ls\nGNU gdb (GDB) 7.6.2 (Debian 7.6.2-1)\n...\nReading symbols from /bin/ls...(no debugging symbols found)...done.\n(gdb) info files\nSymbols from \"/bin/ls\".\nLocal exec file:\n    `/bin/ls', file type elf64-x86-64.\n    Entry point: 0x40489c\n    0x0000000000400238 - 0x0000000000400254 is .interp\n    0x0000000000400254 - 0x0000000000400274 is .note.ABI-tag\n    0x0000000000400274 - 0x0000000000400298 is .note.gnu.build-id\n    0x0000000000400298 - 0x0000000000400300 is .gnu.hash\n    0x0000000000400300 - 0x0000000000400f18 is .dynsym\n    0x0000000000400f18 - 0x00000000004014ab is .dynstr\n    0x00000000004014ac - 0x00000000004015ae is .gnu.version\n    0x00000000004015b0 - 0x0000000000401640 is .gnu.version_r\n    0x0000000000401640 - 0x00000000004016e8 is .rela.dyn\n    0x00000000004016e8 - 0x0000000000402168 is .rela.plt\n    0x0000000000402168 - 0x0000000000402182 is .init\n    0x0000000000402190 - 0x00000000004028a0 is .plt\n    0x00000000004028a0 - 0x0000000000411f0a is .text\n    0x0000000000411f0c - 0x0000000000411f15 is .fini\n    0x0000000000411f20 - 0x000000000041701c is .rodata\n    0x000000000041701c - 0x0000000000417748 is .eh_frame_hdr\n    ...\n</code></pre>\nEntrypoint is still <pre><code>0x40489c</code></pre>.\n\nLocating the <pre><code>main</code></pre> procedure\nOnce the entrypoint is known, you can set a breakpoint on it and start looking for the <pre><code>main</code></pre> procedure. Because, you have to know that all the programs will start by a <pre><code>_start()</code></pre> procedure in charge of initializing the memory for the process and loading the dynamic libraries. In fact, this first procedure is a convention in the Unix World.\nWhat exactly does this initialization procedure is quite tedious to follow and, most of the time, of no interest at all to understand your program. The <pre><code>main()</code></pre> procedure will only start after all the memory is set-up and ready to go. \nLets see how to do that (I assume that the executable has been compile with <pre><code>gcc</code></pre>):\n<pre><code>(gdb) break *0x40489c\nBreakpoint 1 at 0x40489c\n(gdb) run\nStarting program: /bin/ls \nwarning: Could not load shared library symbols for linux-vdso.so.1.\n\nBreakpoint 1, 0x000000000040489c in ?? ()\n</code></pre>\nOkay, so we stopped at the very beginning of the executable. At this time, nothing is ready, everything need to be set-up. Let see what are the first steps of the executable:\n<pre><code>(gdb) disas 0x40489c,+50\nDump of assembler code from 0x40489c to 0x4048ce:\n=> 0x000000000040489c:  xor    %ebp,%ebp\n   0x000000000040489e:  mov    %rdx,%r9\n   0x00000000004048a1:  pop    %rsi\n   0x00000000004048a2:  mov    %rsp,%rdx\n   0x00000000004048a5:  and    $0xfffffffffffffff0,%rsp\n   0x00000000004048a9:  push   %rax\n   0x00000000004048aa:  push   %rsp\n   0x00000000004048ab:  mov    $0x411ee0,%r8\n   0x00000000004048b2:  mov    $0x411e50,%rcx\n   0x00000000004048b9:  mov    $0x4028c0,%rdi\n   0x00000000004048c0:  callq  0x4024f0 <__libc_start_main@plt>\n   0x00000000004048c5:  hlt    \n   0x00000000004048c6:  nopw   %cs:0x0(%rax,%rax,1)\nEnd of assembler dump.\n</code></pre>\nWhat follow the <pre><code>hlt</code></pre> is just rubbish obtained because of the linear sweep performed by <pre><code>gdb</code></pre>. So, just ignore it. What is relevant is the fact that we are calling <pre><code>__libc_start_main()</code></pre> (I won't comment on the <pre><code>@plt</code></pre> because it would drag us out of the scope of the question). \nIn fact, the procedure <pre><code>__libc_start_main()</code></pre> initialize the memory for a process running with the <pre><code>libc</code></pre> dynamic library. And, once done, jump to the procedure located in <pre><code>%rdi</code></pre> (which usually is the <pre><code>main()</code></pre> procedure). See the following picture to have a global view of what does the <pre><code>__libc_start_main()</code></pre> procedure [1]\n\nSo, indeed, the address of the <pre><code>main()</code></pre> procedure is at <pre><code>0x4028c0</code></pre>. Let disassemble a few instructions at this address:\n<pre><code>(gdb) x /10i 0x4028c0\n   0x4028c0:    push   %r15\n   0x4028c2:    push   %r14\n   0x4028c4:    push   %r13\n   0x4028c6:    push   %r12\n   0x4028c8:    push   %rbp\n   0x4028c9:    mov    %rsi,%rbp\n   0x4028cc:    push   %rbx\n   0x4028cd:    mov    %edi,%ebx\n   0x4028cf:    sub    $0x388,%rsp\n   0x4028d6:    mov    (%rsi),%rdi\n   ...\n</code></pre>\nAnd, if you look at it, this is indeed the <pre><code>main()</code></pre> procedure. So, this where to really start the analysis.\nWords of warning\nEven if this way of looking for the <pre><code>main()</code></pre> procedure will work in most the cases. You have to know that we strongly rely on the following hypothesis:\n\nPrograms written in pure assembly language and compiled with <pre><code>gcc -nostdlib</code></pre> (or directly with <pre><code>gas</code></pre> or <pre><code>nasm</code></pre>) won't have a first call to <pre><code>__libc_start_main()</code></pre> and will start straight from the entrypoint. Therefore, for these programs, the <pre><code>_start()</code></pre> procedure is the <pre><code>main()</code></pre> procedure. In fact, it is important to understand that the <pre><code>main()</code></pre> procedure is just a convention introduced by the C language as the first function (written by the programmer) to be run in the program. Of course, you can find this convention replicated in many other languages such as Java, C++, and others. But, all these languages derive from C.\nWe also strongly rely on a knowledge on the way <pre><code>__libc_start_main()</code></pre> works. And, how this procedure has been designed by the <pre><code>gcc</code></pre> team. So, if the program you are analyzing has been compiled with another compiler, you may have to investigate a bit further about this compiler and how it perform the set-up of the memory before running the <pre><code>main()</code></pre> procedure.\n\nAnyway, you should now be able to track down a program with no symbol at all if you read this answer carefully.\nFinally, you can find an excellent summary about the starting of an executable by reading \"Linux x86 Program Start Up or - How the heck do we get to <pre><code>main()</code></pre>?\" by Patrick Horgan.\n",
            "votes": "60",
            "user": "perror",
            "time": "Jun 27, 2018 at 9:00",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Revolucion for Monica",
                    "text": "<span class=\"comment-copy\">Thanks for your answer, <i>Monsieur</i>. I followed your steps but when running I always have a zsh:1: permission denied. It seems similar to launch gdb over non compiled .o files. Do I need to compile it first?</span>",
                    "time": null
                }
            ]
        }
    ]
}