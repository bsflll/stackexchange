{
    "title": "COM interface methods",
    "link": "https://reverseengineering.stackexchange.com/questions/2822/com-interface-methods",
    "content": "I'm reversing malware and it uses COM, which I evidently don't know. My question is how to find out what method is called using ppv (and objectstublessclient?)\n<pre><code>push    offset ppv      ; Address of pointer variable that receives the interface pointer requested in riid\npush    offset IShellWindows \npush    7              \npush    0               \npush    offset rclsid   \ncall    ds:_CoCreateInstance\n\nmov     ebx, eax\nmov     eax, num4\nmovsx   edx, num8\nadd     eax, edx\nsub     eax, 0Ch\ncmp     ebx, eax        ; S_OK, operation successful\njnz     exit\n\nlea     eax, [ebp+var_C]    ;?\npush    eax\nmov     eax, ppv\npush    eax\nmov     edi, [eax]\ncall    dword ptr [edi+1Ch] ; ObjectStublessClient7\n</code></pre>\nI guessed that the last called function is objectStublessClient7 given that there are three methods(queryinterface etc) and then objectStublessClient's (and code looks like it). (Is that right?)\nAccording to this Microsoft article:\n\nObjectStubless simply calls into ObjectStublessClient, passing the method index (from ecx) as a parameter. Finally, ObjectStublessClient teases out the format strings from the vtable and jumps to NdrClientCall2. Like NdrStubCall2, this RPCRT4.DLL routine performs the interpretive marshaling and unmarshaling just as if a compiled proxy and stub were in use. \n\nWhat does ObjectStublessClient actually do in simple words? Calls a method by its index? If so, then in my case it will be OnActivate of IShellWindows interface? It looks like the arguments don't match (does the first one look like <pre><code>this</code></pre>?)\n",
    "votes": "17",
    "answers": 1,
    "views": "5k",
    "tags": [
        "disassembly",
        "windows",
        "com"
    ],
    "user": "astrophonic",
    "time": "May 21, 2018 at 9:29",
    "comments": [],
    "answers_data": [
        {
            "content": "The traditional way to determine the function pointed to by <pre><code>[edi+1Ch]</code></pre> is as follows:\nFind the Interface Definition Language (IDL) file for the given interface. In your case, the interface is <pre><code>IShellWindows</code></pre>. According to the documentation for <pre><code>IShellWindows</code></pre>, its interface is defined in IDL file <pre><code>Exdisp.idl</code></pre>. That IDL file is included in the Windows SDK (downloadable for free), and will be installed to a location such as <pre><code>C:\\Program Files\\Microsoft SDKs\\Windows\\v7.1A\\Include\\Exdisp.idl</code></pre>. You can open that <pre><code>Exdisp.idl</code></pre> file with a text editor to see the Interface Definition of <pre><code>IShellWindows</code></pre>:\n<pre><code>[\n    uuid(85CB6900-4D95-11CF-960C-0080C7F4EE85),     // IID_IShellWindows\n    helpstring(\"Definition of interface IShellWindows\"),\n    oleautomation,\n    dual,\n    odl,\n]\ninterface IShellWindows : IDispatch\n{\n    //Properties\n    [propget, helpstring(\"Get count of open Shell windows\")]\n    HRESULT Count([out, retval] long *Count);\n\n    //Methods\n    [id(0), helpstring(\"Return the shell window for the given index\")]\n    HRESULT Item([in,optional] VARIANT index, [out, retval]IDispatch **Folder);\n\n    [id(-4), helpstring(\"Enumerates the figures\")]\n    HRESULT _NewEnum([out, retval] IUnknown **ppunk);\n\n    // Some private hidden members to allow shell windows to add and\n    // remove themself from the list.  We mark them hidden to keep\n    // random VB apps from trying to Register...\n    [helpstring(\"Register a window with the list\"), hidden]\n    HRESULT Register([in] IDispatch *pid,\n                     [in] long hwnd,\n                     [in] int swClass,\n                     [out]long *plCookie);\n\n    [helpstring(\"Register a pending open with the list\"), hidden]\n    HRESULT RegisterPending([in] long lThreadId,\n                     [in] VARIANT* pvarloc,     // will hold pidl that is being opened.\n                     [in] VARIANT* pvarlocRoot, // Optional root pidl\n                     [in] int swClass,\n                     [out]long *plCookie);\n\n    [helpstring(\"Remove a window from the list\"), hidden]\n    HRESULT Revoke([in]long lCookie);\n    // As an optimization, each window notifies the new location\n    // only when\n    //  (1) it's being deactivated\n    //  (2) getFullName is called (we overload it to force update)\n    [helpstring(\"Notifies the new location\"), hidden]\n    HRESULT OnNavigate([in]long lCookie, [in] VARIANT* pvarLoc);\n    [helpstring(\"Notifies the activation\"), hidden]\n    HRESULT OnActivated([in]long lCookie, [in] VARIANT_BOOL fActive);\n    [helpstring(\"Find the window based on the location\"), hidden]\n    HRESULT FindWindowSW([in] VARIANT* pvarLoc,\n                         [in] VARIANT* pvarLocRoot, /* unused */\n                         [in] int swClass,\n                         [out] long * phwnd,\n                         [in] int swfwOptions,\n                         [out,retval] IDispatch** ppdispOut);\n    [helpstring(\"Notifies on creation and frame name set\"), hidden]\n    HRESULT OnCreated([in]long lCookie,[in] IUnknown *punk);\n\n    [helpstring(\"Used by IExplore to register different processes\"), hidden]\n    HRESULT ProcessAttachDetach([in] VARIANT_BOOL fAttach);\n}\n</code></pre>\nWe can see that the <pre><code>IShellWindows</code></pre> interface has the following vtable entries:\n<pre><code>- Count()\n- Item()\n- _NewEnum()\n- Register()\n- RegisterPending()\n- Revoke()\n- OnNavigate()\n- OnActivated()\n- FindWindowSW()\n- OnCreated()\n- ProcessAttachDetach()\n</code></pre>\nHowever, you can also see in the IDL that the <pre><code>IShellWindows</code></pre> interface inherits from <pre><code>IDispatch</code></pre>. <pre><code>IDispatch</code></pre> has the following vtable entries (from <pre><code>OAIdl.idl</code></pre>):\n<pre><code>- GetTypeInfoCount()\n- GetTypeInfo()\n- GetIDsOfNames()\n- Invoke()\n</code></pre>\nThe IDL for <pre><code>IDispatch</code></pre> in <pre><code>OAIdl.idl</code></pre> also specifies that <pre><code>IDispatch</code></pre> inherits from <pre><code>IUnknown</code></pre>. <pre><code>IUnknown</code></pre> has the following vtable entries (from <pre><code>Unknwn.idl</code></pre>):\n<pre><code>- QueryInterface()\n- AddRef()\n- Release()\n</code></pre>\nSo now we know that <pre><code>IShellWindows</code></pre> inherits from <pre><code>IDispatch</code></pre>, which inherits from <pre><code>IUnknown</code></pre>. As such, the full layout of the vtable for <pre><code>IShellWindows</code></pre> is as follows:\n<pre><code>*ppv+00h = QueryInterface()\n*ppv+04h = AddRef()\n*ppv+08h = Release()\n*ppv+0Ch = GetTypeInfoCount()\n*ppv+10h = GetTypeInfo()\n*ppv+14h = GetIDsOfNames()\n*ppv+18h = Invoke()\n*ppv+1Ch = Count()\n*ppv+20h = Item()\n*ppv+24h = _NewEnum()\n*ppv+28h = Register()\n...\n</code></pre>\nLooking back at your code, we see a call to <pre><code>*ppv+1Ch</code></pre>, which we see from our constructed vtable above is a call to the function <pre><code>IShellWindows::Count()</code></pre>, and <pre><code>&var_C</code></pre> is the pointer to <pre><code>IShellWindows::Count()</code></pre>'s <pre><code>[out, retval]  long *Count</code></pre> parameter.\n\nThe dynamic way to determine the function pointed to by <pre><code>[edi+1Ch]</code></pre> is as follows:\nRun your code above in a debugger, set a breakpoint on <pre><code>call    dword ptr [edi+1Ch]</code></pre>, and see what function that instruction calls.\n\nThe easiest way to determine the function pointed to by <pre><code>[edi+1Ch]</code></pre> is as follows:\nUse COMView (wayback machine link to COMView) to inspect the <pre><code>IShellWindows</code></pre> interface:\n\nYou can see in the screenshot above that the function at vtable offset 28 (1Ch) is <pre><code>Count()</code></pre>.\n",
            "votes": "21",
            "user": "Remko",
            "time": "May 24, 2018 at 20:31",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Jason Geffner",
                    "text": "<span class=\"comment-copy\">I forgot to mention, you also might be able to tell IDA to interpret ppv as an IShellWindows* variable, in which case IDA will show you that [ppv+1C] is a call to IShellWindows::Count().</span>",
                    "time": null
                },
                {
                    "user": "Rolf Rolles",
                    "text": "<span class=\"comment-copy\">Good answer!  As Jason stated in his comment, once you know the type name for some variable, IDA will often know about it if it's a standard Windows COM type.  In this case, you'd go to the ppv variable in the data section (highlight that token and press enter) and then press 'y' to enter the type IShellWindows *.  From there, IDA's parameter-tracking algorithms will pick up many of the references and automatically and fill them in for you.  (Those algorithms aren't perfect -- they can't be due to mathematical impossibility issues involved -- so you may still have to fill some in manually).</span>",
                    "time": null
                },
                {
                    "user": "Nuzzolilo",
                    "text": "<span class=\"comment-copy\">ComView doesn't seem to run. Can someone confirm if this works?</span>",
                    "time": null
                }
            ]
        }
    ]
}