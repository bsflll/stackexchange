{
    "title": "Calling MessageBoxW x64 confused about pointer",
    "link": "https://reverseengineering.stackexchange.com/questions/26366/calling-messageboxw-x64-confused-about-pointer",
    "content": "OK, I am very new to x64dbg. I used to use OllyDbg a lot and I'm having some problems with this.\nI just made a customized version of MS-PAINT for practice by changing a few things like the default palette, etc.\nI want to add a MessageBoxW to the help button in the corner. I successfully located the method. In ollydbg, I could simply type push, push, push and then call MessageBoxW, but it doesn't work with this. Maybe it's not imported? But I searched for references and found a MessageBoxW, but it looks like this: call qword ptr ds:[0x00000000FF467880] and that ptr is automatically evaluated to MessageBoxW. However, when I copy that code myself it's not working. Why can't I simply type call MessageBoxW????\nI know this might seem amateurish, but I am doing this to try to learn how to use this debugger better. I hope you understand I don't have much experience. Thanks!\n",
    "votes": "0",
    "answers": 1,
    "views": "375",
    "tags": [
        "ollydbg",
        "x64dbg",
        "patching",
        "x86-64",
        "calling-conventions"
    ],
    "user": "Synaps3",
    "time": "Nov 24, 2020 at 22:40",
    "comments": [
        {
            "user": "Paweł Łukasik",
            "text": "\"However, when I copy that code myself it's not working\" and this not working has any manifestation? No crashes? Or anything? If you debug this, do you see this code being executed?\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "First make sure you are using correct calling convention, in 64-bit Windows most APIs expect parameters via registers not push.\nAn example of calling convention for 64-bit Windows:\n<pre><code>lea r9d, uType         ; uType\nlea r8, Caption        ; Caption    \nlea rdx, Text          ; Text\nmov rcx, hWnd          ; hWnd\nCall cs:MessageBoxW \n</code></pre>\nThis is covered in more detailed in x64 Calling Convention\nIf the call instruction uses relative addresses you will need to adjust when relocating the code.\nAs an example (These addresses will vary in MS Paint)\nAt 00007FF72599A000 import table starts\nAt 00007FF72599AFA0 entry for MessageBox:\n<pre><code>; int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)\nextrn MessageBoxW:qword ;\n</code></pre>\nAt 00007FF7258CA6A2 message box is called:\n<pre><code>Call cs:MessageBoxW ( bytes FF 15 F8 08 0D 00 )\n</code></pre>\nAT 00007FF7258CA6A2 message box is called:\n<pre><code>Call cs:MessageBoxW ( bytes FF 15 09 5F 0A 00 )\n</code></pre>\nYou can see from these bytes changes that the in this case the address is relative, so will need to be adjusted if relocating the code. Reading the processor documentation can explain the different call options, for example from amd64 Architecture Programming Manual\nNEAR CALLS\nPushes the offset of the next instruction onto the stack and branches to the target address, which\ncontains the first instruction of the called procedure. The target operand can specify a register, a\nmemory location, or a label. A procedure accessed by a near CALL is located in the same code\nsegment as the CALL instruction.\nIf the CALL target is specified by a register or memory location, then a 16-, 32-, or 64-bit rIP is read\nfrom the operand, depending on the operand size. A 16- or 32-bit rIP is zero-extended to 64 bits.\nIf the CALL target is specified by a displacement, the signed displacement is added to the rIP (of the\nfollowing instruction), and the result is truncated to 16, 32, or 64 bits, depending on the operand size.\nThe signed displacement is 16 or 32 bits, depending on the operand size.\nIn all cases, the rIP of the instruction after the CALL is pushed on the stack, and the size of the stack\npush (16, 32, or 64 bits) depends on the operand size of the CALL instruction.\nFor near calls in 64-bit mode, the operand size defaults to 64 bits. The E8 opcode results in\nRIP = RIP + 32-bit signed displacement and the FF /2 opcode results in RIP = 64-bit offset from\nregister or memory. No prefix is available to encode a 32-bit operand size in 64-bit mode.\nAt the end of the called procedure, RET is used to return control to the instruction following the\noriginal CALL. When RET is executed, the rIP is popped off the stack, which returns control to the\ninstruction after the CALL.\nCALL rel16off ( E8 iw ) Near call with the target specified by a 16-bit relative\ndisplacement.\nCALL rel32off ( E8 id ) Near call with the target specified by a 32-bit relative\ndisplacement.\nCALL reg/mem16 ( FF /2 ) Near call with the target specified by reg/mem16.\nCALL reg/mem32 ( FF /2 ) Near call with the target specified by reg/mem32. (There\nis no prefix for encoding this in 64-bit mode.)\nCALL reg/mem64 (FF /2) Near call with the target specified by reg/mem64.\nFAR CALLS\nPushes procedure linking information onto the stack and branches to the target address, which contains\nthe first instruction of the called procedure. The operand specifies a target selector and offset.\nThe instruction can specify the target directly, by including the far pointer in the immediate and\ndisplacement fields of the instruction, or indirectly, by referencing a far pointer in memory. In 64-bit\nmode, only indirect far calls are allowed; executing a direct far call (opcode 9A) generates an\nundefined opcode exception. For both direct and indirect far calls, if the CALL (Far) operand-size is\n16 bits, the instruction's operand is a 16-bit offset followed by a 16-bit selector. If the operand-size is\n32 or 64 bits, the operand is a 32-bit offset followed by a 16-bit selector.\nThe target selector used by the instruction can be a code selector in all modes. Additionally, the target\nselector can reference a call gate in protected mode, or a task gate or TSS selector in legacy protected\nmode.\n• Target is a code selector—The CS:rIP of the next instruction is pushed to the stack, using operandsize stack pushes. Then code is executed from the target CS:rIP. In this case, the target offset can\nonly be a 16- or 32-bit value, depending on operand-size, and is zero-extended to 64 bits. No CPL\nchange is allowed.\n• Target is a call gate—The call gate specifies the actual target code segment and offset. Call gates\nallow calls to the same or more privileged code. If the target segment is at the same CPL as the\ncurrent code segment, the CS:rIP of the next instruction is pushed to the stack.\nIf the CALL (Far) changes privilege level, then a stack-switch occurs, using an inner-level stack\npointer from the TSS. The CS:rIP of the next instruction is pushed to the new stack. If the mode is\nlegacy mode and the param-count field in the call gate is non-zero, then up to 31 operands are\ncopied from the caller's stack to the new stack. Finally, the caller's SS:rSP is pushed to the new\nstack.\nWhen calling through a call gate, the stack pushes are 16-, 32-, or 64-bits, depending on the size of\nthe call gate. The size of the target rIP is also 16, 32, or 64 bits, depending on the size of the call\ngate. If the target rIP is less than 64 bits, it is zero-extended to 64 bits. Long mode only allows 64-\nbit call gates that must point to 64-bit code segments.\n• Target is a task gate or a TSS—If the mode is legacy protected mode, then a task switch occurs.\nSee “Hardware Task-Management in Legacy Mode” in volume 2 for details about task switches.\nHardware task switches are not supported in long mode.\nCALL FAR pntr16:16 (9A cd) Far call direct, with the target specified by a far pointer\ncontained in the instruction. (Invalid in 64-bit mode.)\nCALL FAR pntr16:32 ( 9A cp ) Far call direct, with the target specified by a far pointer\ncontained in the instruction. (Invalid in 64-bit mode.)\nCALL FAR mem16:16 ( FF /3 ) Far call indirect, with the target specified by a far pointer\nin memory.\nCALL FAR mem16:32 (FF /3) Far call indirect, with the target specified by a far pointer\nin memory\nFurther info can be found in Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4\n",
            "votes": "1",
            "user": "chentiangemalc",
            "time": "Nov 26, 2020 at 0:03",
            "is_accepted": false,
            "comments": []
        }
    ]
}