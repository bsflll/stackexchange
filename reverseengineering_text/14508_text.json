{
    "title": "Cannot locate a variable on the stack",
    "link": "https://reverseengineering.stackexchange.com/questions/14508/cannot-locate-a-variable-on-the-stack",
    "content": "I am unable to locate a variable on the stack. I'm using Fedora 25 x64 but with a 32 bit program, btw.\nC program:\n<pre><code>#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n\nchar* text1 = \"AAAAAAAAAAAAA\";\nint target;\nchar* text2 = \"BBBBBBBBBBBBB\";\nvoid vuln(char *string)\n{\n\n  printf(string);\n\n  if(target) {\n      printf(\"you have modified the target :)\n\");\n  }\n}\n\nint main(int argc, char **argv)\n{\n  vuln(argv[1]);\n  printf(\"Program name: %s\", argv[0]);\n}\n</code></pre>\n/*After stepping into main and doing x/500wx $esp to examine the stack in gdb, here's a piece:\n<pre><code>0xffffcc00: 0x00000000  0x00000000  0x00000000  0xf7fe0ca0\n0xffffcc10: 0xf7df12af  0xf7fd765f  0x00000000  0x00000000\n0xffffcc20: 0x00000000  0x00000000  0x00000000  0x0d696910\n0xffffcc30: 0x00000000  0x00000000  0xf7fe0b79  0xf7de1ef0\n0xffffcc40: 0x00000961  0xf7fd13d8  0x7c96f087  0xf7fe1399\n0xffffcc50: 0x00000001  0x00000004  0xf7deb534  0x00000961\n0xffffcc60: 0xf7deb604  0xf7fd13d8  0xffffccbc  0xffffccb8\n0xffffcc70: 0x00000003  0x00000000  0xf7ffcfcc  0xf7fd764c\n0xffffcc80: 0xf7deb534  0x7c96f087  0xf7deb604  0xf7de1f12\n0xffffcc90: 0x03e4b784  0xffffccb8  0xffffcd48  0x00000961\n0xffffcca0: 0x00000000  0x00000000  0x00000000  0x00000000\n0xffffccb0: 0x00000000  0x00000000  0x00000000  0x00000000\n(gdb) print &text1\n$2 = (char **) 0x804a01c <text1>\n(gdb) print text1\n$3 = 0x8048544 'A' <repeats 13 times>\n(gdb) \n</code></pre>\nAs you can see, my text1 variable's address is in the <pre><code>0x804</code></pre> area, whereas my stack is in <pre><code>0xffffcc</code></pre> area which is why I am completely lost. You can probably see what I'm trying to do, but I'm trying to locate 0x414141's followed by the target, followed by 0x42424242's but there are no 41s or 42s anywhere in the stack area near esp. I am currently educating myself on format string vulnerabilities, but at this point, I can't even locate the variables on the stack. Is there something I'm missing? Thanks.\n",
    "votes": "4",
    "answers": 2,
    "views": "513",
    "tags": [
        "strings",
        "vulnerability-analysis"
    ],
    "user": "the_endian",
    "time": "Jan 27, 2017 at 5:25",
    "comments": [],
    "answers_data": [
        {
            "content": "The reason the you are unable to locate <pre><code>text1</code></pre> on the program runtime stack is that during runtime <pre><code>text1</code></pre> is in the <pre><code>data</code></pre> segment of the process running in virtual memory, not the stack. In order for a reference to <pre><code>text1</code></pre> to be written to the stack <pre><code>text1</code></pre> must be passed as an argument to a function which is called.\nWhen a function is called and a new stack frame is created on the runtime stack for that function, memory is allocated on the stack for any local variables declared in that function as well.  However, <pre><code>text1</code></pre>, <pre><code>text2</code></pre> and <pre><code>target</code></pre> are global variables declared outside of any function. A direct consequence of this is that memory will not be allocated for  <pre><code>text1</code></pre>, <pre><code>text2</code></pre> and <pre><code>target</code></pre> on the stack. Instead, <pre><code>text1</code></pre> and <pre><code>text2</code></pre> will be in the process's <pre><code>data</code></pre> segment and <pre><code>target</code></pre> will be in the <pre><code>bss</code></pre> segment. In order to understand why, familiarity with the ELF and the System V Application Binary Interface is essential.\nx86 Linux Process Layout in Virtual Memory\nFor some context, here is a diagram of a process's layout in virtual memory on an x86 Linux system from Gustavo Duarte's article titled \"Anatomy of a Program in Memory\":\n\nA look at this diagram will help clarify the significance of the memory addresses you are seeing. On an x86 Linux system, the stack is high in virtual memory and grows downward. This is why when the stack is examined one sees memory addresses such as <pre><code>0xffffcc10</code></pre> and <pre><code>0xffffccb0</code></pre>. The location in virtual memory of global variables <pre><code>text1</code></pre>, <pre><code>text2</code></pre> and <pre><code>target</code></pre> will be more proximate to the program entry point since the <pre><code>data</code></pre> and <pre><code>bss</code></pre> segments are adjacent to the <pre><code>text</code></pre> segment, which is low in memory. In light of this, a  memory address of <pre><code>0x804a01c</code></pre> for <pre><code>text1</code></pre> makes sense.\nELF and the System V ABI\nFrom Section 4 (Object Files) of the ABI:\n\nAn executable file holds a program suitable for execution; the file specifies how the function <pre><code>exec</code></pre> creates a program's process image.\n\nand\n\nCreated by an assembler and link editor, object files are binary representations of programs intended to execute directly on a processor.\n\nOnce the program is compiled, assembled and linked, it is essentially a description of what it will look like as a process. This means that an executable binary can be statically analyzed to get an idea of how things will look when the program is running. When the binary constructed from the source code provided above is analyzed it is observed that the values <pre><code>text1</code></pre> and <pre><code>text2</code></pre> are in the <pre><code>.rodata</code></pre> section:\n<pre><code>$ readelf -x .rodata <ELF BINARY NAME>\n\nHex dump of section '.rodata':\n  0x08048538 03000000 01000200 41414141 41414141 ........AAAAAAAA\n  0x08048548 41414141 41004242 42424242 42424242 AAAAA.BBBBBBBBBB\n  0x08048558 42424200 796f7520 68617665 206d6f64 BBB.you have mod\n  0x08048568 69666965 64207468 65207461 72676574 ified the target\n  0x08048578 203a2900 50726f67 72616d20 6e616d65  :).Program name\n  0x08048588 3a202573 00                         : %s.\n</code></pre>\nAccording to the ABI (4-19), the <pre><code>.rodata</code></pre> section holds read-only data that typically contributes to a non-writable segment in the process image. Examples of non-writable process image segments are the <pre><code>text</code></pre> and <pre><code>data</code></pre> segments mentioned above. The implication of this is that <pre><code>text1</code></pre> and <pre><code>text2</code></pre> will be located near where the program instructions are, namely the <pre><code>text</code></pre> segment, when the program is loaded into memory. The instruction memory addresses will look much more similar to the memory addresses of <pre><code>text1</code></pre> and <pre><code>text2</code></pre> than memory addresses on the stack.\nThe <pre><code>target</code></pre> variable is an uninitialized global variable, so its data will be held in the <pre><code>bss</code></pre> segment.\nArguments to Functions are Written to the Stack\nIf you want pointers to these variables to appear on the runtime stack they must be passed as arguments to a function that is called at some point throughout the course of process execution, as a function's arguments are typically written to the stack in the caller's argument build area, as seen in the diagram below. \nStack layout with multiple frames (from CSAPP):\n\nFor example, instead of passing <pre><code>argv[1]</code></pre> as an argument to the <pre><code>vuln</code></pre> function, the global variable <pre><code>text1</code></pre> can be passed instead. A pointer to <pre><code>text1</code></pre> would then be saved on the stack prior to <pre><code>vuln</code></pre> being called.\nAlternatively, instead of hardcoding 'A' as a value for a global variable, you can pass an arbitrary number of 'A's (or any other ASCII characters) as an argument on the command line when executing your program in the shell. This will result in whatever values you pass being stored in <pre><code>argv[1]</code></pre> which is the argument to <pre><code>vuln</code></pre>.\nIt should be noted that due to their global scope, <pre><code>text1</code></pre>, <pre><code>text2</code></pre> and <pre><code>data</code></pre> can be referenced in any function without being passed as an argument, but in the context of format string vulnerabilities and <pre><code>printf</code></pre>\nthat is not particularly useful to know.\nFor More Information\nFor more information on how <pre><code>printf</code></pre> behaves in a x86 Linux environment, one can take a look at the  answer to the following question on stackoverflow in which a user is calling <pre><code>printf</code></pre> in a non-standard fashion: \"ELF32 binary, little endian or not?\"\nSection 3.7 (titled \"Procedures\") in \"Computer Systems: A Programmer's Perspective\" covers function calls and the stack on an assembly level and has several helpful diagrams.\n",
            "votes": "7",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "Where in main are you when you dump the stack? Those variables are global initialised variables, they won't be on the stack until they are pushed there before the function call. Until then they will be in the bss or data section of your program.\nPrint the disassembly of main and you should see a reference to your string being pushed onto the stack just before the call to your function.\nThis could be a push op or a mov op btw, depending what your compiler settings are.\n",
            "votes": "-1",
            "user": "Unlogic",
            "time": "Jan 27, 2017 at 7:24",
            "is_accepted": false,
            "comments": []
        }
    ]
}