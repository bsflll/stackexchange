{
    "title": "Decoding the wire protocol (over RS232) for custom hardware <-> windows application?",
    "link": "https://reverseengineering.stackexchange.com/questions/3846/decoding-the-wire-protocol-over-rs232-for-custom-hardware-windows-applicat",
    "content": "Background\nI have a hardware device with an RS232 port, and a Windows (XP) application that it talks to. No OS-level drivers beyond basic serial, so all the decoding is done in the app.\nI have the ability to capture bidirectional wire traffic and generally snoop on the serial port (good ol' Sysinternals Portmon to logfile, with some perl post-processing (parsing out <pre><code>IRP_MJ_(READ|WRITE)</code></pre> events) to get raw byte dumps).\nFrom this I've gotten the basic wire protocol details (baud rate, settings, etc)\nMessages appear to be in the format <pre><code>{ $body }\n</code></pre>, where sent commands are usually a single byte or 2 in the body, responses are much more complex.\nThey span several messages, and appear to have additional structure, something like:\n\nHeader (<pre><code>{IDCOMPLIANCE ...}</code></pre>)\nMetadata? (<pre><code>{SA...}</code></pre>)\nData[+] ({<pre><code>DL20...</code></pre>})\nEnd of Data Indicator (<pre><code>{TE5186}</code></pre>)\n\nActual example follows:\n<pre><code>> {C}\\x0D\n< {IDCOMPLIANCE\\x20\\x20\\x20\\x20\\x20\\x20D245}\n{SA001FD8BL0001C061BC}\n{DL20I000000V80050300DE076A0012000400AF002400FF030300DE0700000000010003000000B883}\n{DL20I000020VFF140200DE070900010001000D000100FF0C0200DE076E006E000300A5075904C953}\n{DL20I000040VFF0B0200DE07120111010700DE11E406FF0A0200DE070401030105008D12640B3B0C}\n{DL20I000060VFF090200DE07F400F400050046112F0AFF080200DE076C016C0107003419950D7181}\n{DL20I000080VFF070200DE0753015101060063172A0CFF060200DE07D400D3000A00BE0DF504877D}\n{DL20I0000A0VFF050200DE07F200F200040047117309FF040200DE071601150107000414F10C292B}\n{DL20I0000C0VFF030200DE07D400D4000500260FC108FF020200DE07B900B90006004C0D26083825}\n{DL20I0000E0VFF010200DE07B601B60107001E21F718FF1F0100DE0710010C010900B913150DE89C}\n{DL20I000100VFF1E0100DE0785017F010900531A2F0EFF1D0100DE071B01180108001C146D0CE542}\n{DL20I000120VFF1C0100DE077E007B0005009C092107FF090100DE0754000100020008000100A748}\n{DL20I000140V0000000000000000000000000000000000000000000000000000000000000000D71C}\n{DL20I000160V0000000000000000000000000000000000000000000000000000000000000000725F}\n{DL20I000180V000000000000000000000000000000000000000000000000000000000000000010A5}\n{DL20I0001A0V00000000000000000000000000000000000000000000000000000000000000004CC1}\n{TE5186}\n</code></pre>\nI also have access to the controlling application which I can get to log certain data (which may or may not be quite what it's talking over the wire) to friendly formats like CSV etc.\nQuestion\nGiven my progress so far is mostly matching up CSV outputs with wire dumps, is there any value in trying to investigate the actual application more...invasively?\nI have very little experience with asm, windows binaries, and windows debugging, but it seems like it might be possible to poke around in the binary either statically or while it's running, and look for where the decoding happens.\nIf I can find that, I can hopefully scrabble up enough asm to understand how it's being generated/parsed, and map that to what I see it actually sending.\nThe problem is actually finding those [de]coding routines with my limited knowledge.\nTwo approaches suggest themselves to me:\n\nRun inside a debugger, figure out how to set a breakpoint on serial port read/write, and step through from there looking for decoding logic.\nLoad into a decompiler, and either (a) trace calls around serial read/writes, or (b) look for known strings that appear in the output CSVs, and work backwards to the code that's using them.\n\n[Note that I'm doing this in a VMWare VM on a Mac, in case that matters for anything]\nI've currently been playing around with OllyDbg for windows, and the demo version of Hopper Decompiler, which is affordable if it'll be of use.\nIDA or Hex-Rays would be nice, but is a bit out of my budget unless there's something there (like, a 'Decode Mystery Protocol' button) that would justify it.\nSo,\n\nDoes anyone recognise the format described above? \nAre there better tools for RS232 (actually via USB-serial adapter) sniffing? I found USBpcap (hxxp://desowin.org/usbpcap/) which can generate wireshark traces, but digging though it for the actual serial data was tedious, and capture isn't realtime.\nWhat would people suggest my next moves be (keep hacking at black-box csv/wire-data, decompile, or debug?)\nIf debug, is ollydbg capable of breakpointing on serial port read (and where might I find n00b-level docs on how to do so?)\nIf decompile, what approach should I take (forward from port read, or back from csv/strings? Again, pointers to how to do that would be great.)\nIf black-box, any inspiration as to the structure of the <pre><code>{DL20...}</code></pre> messages in particular?\n\nI suspect it breaks down something like:\n\n<pre><code>DL20</code></pre> - not sure what the 20 indicates. Length of some kind?\n<pre><code>I000020</code></pre> - clearly some sort of index/address\n<pre><code>V</code></pre> - Marker for 'vector'/array data to follow?\n<pre><code>FF140200DE070900010001000D000100</code></pre> Entry #1\n<pre><code>FF0C0200DE076E006E000300A5075904</code></pre> Entry #2\n\nEach entry contains a date (dd/mm/yy, probably in a weird format like 'fractional number of fortnights since first summer solstice following the Fall of Rome'), and a bunch of integer and fractional (fixed point rather than float, probably)\nSome fields are I think 16 bit, and little-endian (Entry#2 last 4 bytes is 0x0459 which matches observed data)\n\n<pre><code>C953</code></pre> - Not sure, maybe checksum or CRC? Tried a few obvious standards taht don't match it though, and might be over the whole packet or just the data.\n\n\n[Apologies for the broken links, need more rep to add >2 apparently]\n",
    "votes": "5",
    "answers": 2,
    "views": "2k",
    "tags": [
        "ollydbg",
        "encodings",
        "serial-communication",
        "hopper"
    ],
    "user": "Shabble",
    "time": "Mar 11, 2014 at 1:38",
    "comments": [],
    "answers_data": [
        {
            "content": "My guess:\n<pre><code>DL20I000000V80050300DE076A0012000400AF002400FF030300DE0700000000010003000000B883\n^^  ^      ^                                                                ^^^^\n||  Addr   Data                                                            CRC16\n|` Length\n` Data tag\n</code></pre>\n\nD for data\nL20 for 0x20 or 32 hex bytes, or 64 hex digits\nI000000 the address (note it increases by 0x20 per row, supporting both L20 as length and I as address)\nV the data, size matching L\nAnd a 16-bit CRC or checksum, supported by the final rows which are \"all 0\" except each with a unique checksum, suggesting the address is part of the formula.\n\nIt looks vaguely like a flash file format for programming PROMs or microcontrollers.  IHEX doesn't have letters.  SREC is similar to what you have.\n",
            "votes": "6",
            "user": "Ben Jackson",
            "time": "Mar 11, 2014 at 7:30",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "Netzob is a tool expressly built for this purpose.  I have nothing to do with the creation of the tool, and it does still have bugs in my experience, but it's very useful for this kind of reverse engineering of protocols.\n",
            "votes": "1",
            "user": "masterX244",
            "time": "Aug 2, 2022 at 15:03",
            "is_accepted": false,
            "comments": []
        }
    ]
}