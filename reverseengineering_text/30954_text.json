{
    "title": "How to investigate in a program of type /SUBSYSTEM:NATIVE that crashes with the RtlFreeAnsiString API?",
    "link": "https://reverseengineering.stackexchange.com/questions/30954/how-to-investigate-in-a-program-of-type-subsystemnative-that-crashes-with-the",
    "content": "I compiled a very simple example of an application of type <pre><code>/SUBSYSTEM:NATIVE</code></pre> writing \"hello world\".\nIt is launched thanks to the \"BootExecute\" key. The program works without errors.\nThen I compiled a more complex example: NDK Cli. The source code was written in 2006 for Windows 32bit. I compiled it with VS2022 for Windows 64bit. The executable program is generated without error and with \"level 4\" for warnings.\nBut the <pre><code>RtlFreeAnsiString</code></pre> API crashes the program that ends abruptly. Then the windows desktop is displayed normally.\nWith Procmon (during boot), the stack shows that the last call before the end of the program is <pre><code>RtlFreeAnsiString</code></pre>.\nProcmon also provides the source code line through the PDB file.\nThe program ends abruptly after the <pre><code>RtlFreeAnsiString</code></pre> API.\n<pre><code>0   FLTMGR.SYS  FltGetFileNameInformation + 0x1e54  0xfffff8046c1b6d34  X:\\windows\\System32\\drivers\\FLTMGR.SYS\n1   FLTMGR.SYS  FltGetFileNameInformation + 0x1906  0xfffff8046c1b67e6  X:\\windows\\System32\\drivers\\FLTMGR.SYS\n2   FLTMGR.SYS  FltGetFileNameInformation + 0x992   0xfffff8046c1b5872  X:\\windows\\System32\\drivers\\FLTMGR.SYS\n3   FLTMGR.SYS  FltGetFileNameInformation + 0x71b   0xfffff8046c1b55fb  X:\\windows\\System32\\drivers\\FLTMGR.SYS\n4   ntoskrnl.exe    IofCallDriver + 0x55    0xfffff80470a2eab5  X:\\windows\\system32\ntoskrnl.exe\n5   ntoskrnl.exe    IoBuildDeviceIoControlRequest + 0x67e   0xfffff80470ae3b9e  X:\\windows\\system32\ntoskrnl.exe\n6   ntoskrnl.exe    KeInvalidateRangeAllCachesNoIpi + 0x7ab4    0xfffff80470a21444  X:\\windows\\system32\ntoskrnl.exe\n7   ntoskrnl.exe    PfFileInfoNotify + 0x2964   0xfffff80470a7dc14  X:\\windows\\system32\ntoskrnl.exe\n8   ntoskrnl.exe    MmProbeAndLockPages + 0x314b    0xfffff80470a5323b  X:\\windows\\system32\ntoskrnl.exe\n9   ntoskrnl.exe    setjmpex + 0x4545   0xfffff80470c216f5  X:\\windows\\system32\ntoskrnl.exe\n10  ntdll.dll   LdrRscIsTypeExist + 0x2a8   0x7ffd4a616188  X:\\Windows\\System32\ntdll.dll\n11  ntdll.dll   RtlGetExtendedContextLength2 + 0x3dc    0x7ffd4a61682c  X:\\Windows\\System32\ntdll.dll\n12  ntdll.dll   RtlWalkFrameChain + 0x2a    0x7ffd4a65f3fa  X:\\Windows\\System32\ntdll.dll\n13  ntdll.dll   RtlCaptureStackBackTrace + 0x42 0x7ffd4a65f372  X:\\Windows\\System32\ntdll.dll\n14  ntdll.dll   _misaligned_access + 0x741  0x7ffd4a6f4eb1  X:\\Windows\\System32\ntdll.dll\n15  ntdll.dll   _misaligned_access + 0xac65 0x7ffd4a6ff3d5  X:\\Windows\\System32\ntdll.dll\n16  ntdll.dll   RtlGetCurrentServiceSessionId + 0xbcf   0x7ffd4a60817f  X:\\Windows\\System32\ntdll.dll\n17  ntdll.dll   RtlFreeHeap + 0x51  0x7ffd4a607511  X:\\Windows\\System32\ntdll.dll\n18  ntdll.dll   RtlFreeAnsiString + 0x17    0x7ffd4a661fb7  X:\\Windows\\System32\ntdll.dll\n19  native_64.exe   GetFullPath + 0x19a, C:\\MesData\\informatique\\2022\native_64\native_64_2\\shell.c(63) 0x7ff7ee2245ba  X:\\Windows\\System32\native_64.exe\n20  native_64.exe   RtlCliSetCurrentDirectory + 0x98, C:\\MesData\\informatique\\2022\native_64\native_64_2\\file.c(99) 0x7ff7ee221628  X:\\Windows\\System32\native_64.exe\n21  native_64.exe   RtlClipProcessMessage + 0x22c, C:\\MesData\\informatique\\2022\native_64\native_64_2\\main.c(161)   0x7ff7ee2225cc  X:\\Windows\\System32\native_64.exe\n22  native_64.exe   NtProcessStartup + 0x91, C:\\MesData\\informatique\\2022\native_64\native_64_2\\main.c(489) 0x7ff7ee222d11  X:\\Windows\\System32\native_64.exe\n23  ntdll.dll   RtlUserThreadStart + 0x43   0x7ffd4a5e4873  X:\\Windows\\System32\ntdll.dll\n</code></pre>\nIn the few functions used during the error from the \"main\", I checked that there is no \"cast\".\nI modified this source code to create a \"test command\" that does this:\n<pre><code>ANSI_STRING as;\nRtlInitAnsiString(&as, \"pb RtlFreeAnsiString\");\nRtlFreeAnsiString(&as);\n\nThis program does not work in a hyperV VM because the keyboard is not \"recognized\".\nI can use WinDbg with a kernel debugger session with 2 PCs.\n</code></pre>\nHow to identify the origin of the error with Windbg?\nToday, some additional information.\nMy last test : I commented on the lines containing RtlFreeAnsiString with \"//\". It is now the RtlFreeUnicodeString function that triggers the end of the program.\nTo be able to compile/link this program, I was forced to produce with \"dumpbin.exe\" the file ntdll.lib.\nBecause the one provided by VS2022 is incomplete: it does not contain the NtDisplayString function, for example.\nIn addition I use the \"include\" files of 2006 (from NDK CLI) because I do not find the right include files for various functions used.\nI also replaced the use of the GetProcessHeap function (not to be confused with GetProcessHeaps with a 's' at the end of the name) with the creation and use of a new \"heap\".\n//DirectoryInfo = RtlAllocateHeap(GetProcessHeap(), 0, 4096);\n2 questions:\nSo could the parameters passed to the functions of ntdll.dll W11 not be the right ones?\nCan the porting from 32bit to 64bit be incriminated?\nI don't know where to look or how to look.\nThank you for your ideas\nI finally understood the origin of the anomalies related to the deallaction on the heap. I had never questioned the writing of the source code. The name of the author, the quality of the writing, the little compilation error when switching to 64bit, all this pushed me not to know where to look.\nBut by dint of searching, and rereading the definition of the APIs, I ended up finding that the RtlInitAnsiString and RtlInitUnicodeString functions do not give rise to a buffer release by the RtlFreeAnsiString and RtlFreeUnicodeString functions.\nAfter this fix, the simple commands of the program work well.\nIt remains to correct some minor anomalies, such as the use of a memory address in the kernel, hard-coded, and valid only in 32bit.\nUndocumented structures also generate errors. I don't think I could find a 64bit equivalent.\nVarious sites describing these undocumented APIs haven't helped me yet.\nThat's it, everything works pretty well for me now.\n",
    "votes": "2",
    "answers": 1,
    "views": "87",
    "tags": [
        "windows",
        "windbg"
    ],
    "user": "NoelBlanc",
    "time": "Oct 7, 2022 at 6:28",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "Maybe you should put the solution into an answer.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "I used code written by distinguished programmers. The 32bit version of the code works very well.\nI assumed that porting to 64bit could cause the anomaly.\nBefore implementing Windbg kernel mode, I read and reread the API documentation.\nAnd the API documentation doesn't say you have to release the buffer.\nThe bug in the 64bit version comes from the following write:\nRtlInitAnsiString(buffer, ...)\n...\nRtlFreeAnsiString(..,buffer,...)\nDitto for RtlInitUnicodeString and RtlFreeUnicodeString.\nThere you go. Resolved.\n",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "Nov 11, 2022 at 10:27",
            "is_accepted": false,
            "comments": []
        }
    ]
}