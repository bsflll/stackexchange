{
    "title": "Decompilers points to non-existing virtual function",
    "link": "https://reverseengineering.stackexchange.com/questions/30308/decompilers-points-to-non-existing-virtual-function",
    "content": "As part of solving the Hidden password challenge, I found an condition calls a virtual function\n\nthe <pre><code>v14</code></pre> points to <pre><code>v8</code></pre> variable :\n\nand the functions in the program does not make sense for me, there is no two-args functions in binary program, does this bytes mean something such as signatures/evaluable code/etc..\n<pre><code>  v8[0] = 0x28BF16683619A05BLL;\n  v8[1] = 0x4DD3CE3A2552E799LL;\n  v8[2] = 0xA5ED9BE182304449LL;\n  v8[3] = 0x6E27E1473B191037LL;\n  v8[4] = 0x6DA9EC4E7AC0DAECLL;\n  v8[5] = 0x8929723C31C59039LL;\n  v8[6] = 0xEA92AC15DE3C3F69LL;\n  v8[7] = 0x828DD2F713F6E8BELL;\n  v8[8] = 0xBB4D607B1C553C6FLL;\n  v8[9] = 0x7DC2D2F3EC43EF5BLL;\n  v8[10] = 0x4DAF64150084DC96LL;\n  v8[11] = 0xE1F1361E21C67AB9LL;\n  v8[12] = 0xA4B498C90BE95F82LL;\n  v8[13] = 0xB439B94451F266B5LL;\n  v8[14] = 0x2380C814A4F0145BLL;\n  v8[15] = 0x808581A5B7FB9D7ELL;\n  v8[16] = 0x589B2B23881C5633LL;\n  v8[17] = 0xBBAA188D8CDE35D8LL;\n  v8[18] = 0xF6F8FD3AEB6DD0D2LL;\n  v8[19] = 0x2FEAA6B6AE8530B8LL;\n  v8[20] = 0xB30EDC56B009E85FLL;\n  v8[21] = 0xFBD9E747FFC36C8FLL;\n  v8[22] = 0x18194F7045E8F66LL;\n  v8[23] = 0xC27B4D434FE8BEEALL;\n</code></pre>\n<pre><code>code = [\n    0x28,0xBF,0x16,0x68,0x36,0x19,0xA0,0x5B,\n    0x4D,0xD3,0xCE,0x3A,0x25,0x52,0xE7,0x99,\n    0xA5,0xED,0x9B,0xE1,0x82,0x30,0x44,0x49,\n    0x6E,0x27,0xE1,0x47,0x3B,0x19,0x10,0x37,\n    0x6D,0xA9,0xEC,0x4E,0x7A,0xC0,0xDA,0xEC,\n    0x89,0x29,0x72,0x3C,0x31,0xC5,0x90,0x39,\n    0xEA,0x92,0xAC,0x15,0xDE,0x3C,0x3F,0x69,\n    0x82,0x8D,0xD2,0xF7,0x13,0xF6,0xE8,0xBE,\n    0xBB,0x4D,0x60,0x7B,0x1C,0x55,0x3C,0x6F,\n    0x7D,0xC2,0xD2,0xF3,0xEC,0x43,0xEF,0x5B,\n    0x4D,0xAF,0x64,0x15,0x00,0x84,0xDC,0x96,\n    0xE1,0xF1,0x36,0x1E,0x21,0xC6,0x7A,0xB9,\n    0xA4,0xB4,0x98,0xC9,0x0B,0xE9,0x5F,0x82,\n    0xB4,0x39,0xB9,0x44,0x51,0xF2,0x66,0xB5,\n    0x23,0x80,0xC8,0x14,0xA4,0xF0,0x14,0x5B,\n    0x80,0x85,0x81,0xA5,0xB7,0xFB,0x9D,0x7E,\n    0x58,0x9B,0x2B,0x23,0x88,0x1C,0x56,0x33,\n    0xBB,0xAA,0x18,0x8D,0x8C,0xDE,0x35,0xD8,\n    0xF6,0xF8,0xFD,0x3A,0xEB,0x6D,0xD0,0xD2,\n    0x2F,0xEA,0xA6,0xB6,0xAE,0x85,0x30,0xB8,\n    0xB3,0x0E,0xDC,0x56,0xB0,0x09,0xE8,0x5F,\n    0xFB,0xD9,0xE7,0x47,0xFF,0xC3,0x6C,0x8F,\n    0x18,0x19,0x4F,0x70,0x45,0xE8,0xF6,0x6,\n    0xC2,0x7B,0x4D,0x43,0x4F,0xE8,0xBE,0xEA,\n    0xcb,0x87,0xce,0xb3\n]\n</code></pre>\nand the XOR part <pre><code>*((_BYTE *)v8 + (int)k) ^= v11;</code></pre> XOR with the key generated by other function\n<pre><code>unsigned __int64 sub_1169()\n{\n  // qword_4040 -> 0x1\n  qword_4040 = 1103515245 * qword_4040 + 12345;\n  return ((unsigned __int64)qword_4040 >> 16) & 0x7FFF;\n}\n</code></pre>\noutputs <pre><code>0x41c6</code></pre> and Xor'ing that key It won't give anything understandable and even useful\n<pre><code>code = [\n    0x28,0xBF,0x16,0x68,0x36,0x19,0xA0,0x5B,\n    0x4D,0xD3,0xCE,0x3A,0x25,0x52,0xE7,0x99,\n    0xA5,0xED,0x9B,0xE1,0x82,0x30,0x44,0x49,\n    0x6E,0x27,0xE1,0x47,0x3B,0x19,0x10,0x37,\n    0x6D,0xA9,0xEC,0x4E,0x7A,0xC0,0xDA,0xEC,\n    0x89,0x29,0x72,0x3C,0x31,0xC5,0x90,0x39,\n    0xEA,0x92,0xAC,0x15,0xDE,0x3C,0x3F,0x69,\n    0x82,0x8D,0xD2,0xF7,0x13,0xF6,0xE8,0xBE,\n    0xBB,0x4D,0x60,0x7B,0x1C,0x55,0x3C,0x6F,\n    0x7D,0xC2,0xD2,0xF3,0xEC,0x43,0xEF,0x5B,\n    0x4D,0xAF,0x64,0x15,0x00,0x84,0xDC,0x96,\n    0xE1,0xF1,0x36,0x1E,0x21,0xC6,0x7A,0xB9,\n    0xA4,0xB4,0x98,0xC9,0x0B,0xE9,0x5F,0x82,\n    0xB4,0x39,0xB9,0x44,0x51,0xF2,0x66,0xB5,\n    0x23,0x80,0xC8,0x14,0xA4,0xF0,0x14,0x5B,\n    0x80,0x85,0x81,0xA5,0xB7,0xFB,0x9D,0x7E,\n    0x58,0x9B,0x2B,0x23,0x88,0x1C,0x56,0x33,\n    0xBB,0xAA,0x18,0x8D,0x8C,0xDE,0x35,0xD8,\n    0xF6,0xF8,0xFD,0x3A,0xEB,0x6D,0xD0,0xD2,\n    0x2F,0xEA,0xA6,0xB6,0xAE,0x85,0x30,0xB8,\n    0xB3,0x0E,0xDC,0x56,0xB0,0x09,0xE8,0x5F,\n    0xFB,0xD9,0xE7,0x47,0xFF,0xC3,0x6C,0x8F,\n    0x18,0x19,0x4F,0x70,0x45,0xE8,0xF6,0x6,\n    0xC2,0x7B,0x4D,0x43,0x4F,0xE8,0xBE,0xEA,\n    0xcb,0x87,0xce,0xb3\n]\n\nkey = [0x41,0xc6]*98\n\ncode = \"\"\n\nfor i in range(196):\n    code+=chr(code[i]^key[i])\n</code></pre>\nwhat is this line of code really does in this context :\n<pre><code>if ( ((unsigned int (__fastcall *)(char *, size_t))v14)(a2[1], v5) )\n</code></pre>\n",
    "votes": "0",
    "answers": 1,
    "views": "134",
    "tags": [
        "ida",
        "pointer",
        "vtables",
        "virtual-functions"
    ],
    "user": "IVs",
    "time": "Apr 22, 2022 at 20:49",
    "comments": [],
    "answers_data": [
        {
            "content": "<pre><code>sub_1169</code></pre> is actually an LCG based random number generator. <pre><code>sub_1155</code></pre> sets the seed value for this LCG. So <pre><code>sub_1155</code></pre> is similar to <pre><code>srand</code></pre> and <pre><code>sub_1169</code></pre> is <pre><code>rand</code></pre>\nBecause of this the xor key is not the same for every byte.\n<pre><code>srand(seed);\nfor ( k = 0; k <= 196; ++k )\n{\n  v9 = rand();\n  v8[k] ^= v9;\n}\n</code></pre>\nNow\n<pre><code>v14 = (int (__fastcall *)(char *, int))v8;\n</code></pre>\nThis means we are assigning byte data pointed by <pre><code>v8</code></pre> as function or code - specifically a function that takes a string and an int as a param and returns an int. Something like\n<pre><code>bool verify_flag(char *flag, int len);\n</code></pre>\nSo <pre><code>v8</code></pre> is some sort of shellcode which is decoded in the xor fashion as above. Later that function is called to verify <pre><code>argv[1]</code></pre>\n<pre><code>if ( v12(argv[1], v5) )\n  puts(\"Good password!\");\nelse\n  puts(\"Invalid password!\");\n</code></pre>\nThe first step of getting the shellcode decoded correctly is to figure out the input that calculates some sort of \"checksum\" which when used as seed to <pre><code>srand</code></pre> will decode to perfect x86_64 code. This is the \"checksum\" logic.\n<pre><code>seed = 0x7FFFFFFF;\nfor ( i = 0; ; ++i )\n{\n    v3 = i;\n    if ( v3 >= strlen(argv[1]) )\n    break;\n    seed += i * argv[1][i];\n}\n</code></pre>\nAdditionally the binary sets up some <pre><code>mod</code></pre> based constraints that will help you figure out the correct checksum using z3.\n<pre><code>from z3 import *\n# https://reverseengineering.stackexchange.com/questions/30303/z3-is-unable-to-predict-the-operand\nv7 = [123, 456, 789, 987, 654, 321]\nv6 = [92, 29, 380, 2, 497, 296]\narrl = 14\nargv1 = [BitVec(f'a{i}', 32) for i in range(arrl)]\n\nsolver = Solver()\nv18 = BitVecVal(0x7fffffff, 32)\n\nfor i in range(arrl):\n    solver.add(argv1[i] < 128)\n    solver.add(argv1[i] > 32)\n    v18 += i*argv1[i]\n\nfor i in range(6):\n    solver.add(URem(v18, v7[i]) == v6[i])\n\nprint(solver.check())\nprint(\"\".join(map(chr, [solver.model()[argv1[i]].as_long()\n      for i in range(arrl)])))\n</code></pre>\nOnce you know an input that will produce the correct seed for <pre><code>srand</code></pre> such that <pre><code>rand</code></pre> generates the correct order of values for <pre><code>v8</code></pre> shellcode to be decoded correctly.\nYou can then run and dump this decoded shellcode or xor it statically with correct <pre><code>rand</code></pre> values.\nThis shellcode similarly can be analysed with IDA and modelled with z3. Its a simple xor of 2 buffers and then compare with a static buffer.\nUnrelated to the answer, I have solved it with angr here\n",
            "votes": "0",
            "user": "sudhackar",
            "time": "Apr 22, 2022 at 23:27",
            "is_accepted": true,
            "comments": [
                {
                    "user": "IVs",
                    "text": "<span class=\"comment-copy\">That's great, thank you, what was the seed number ?</span>",
                    "time": null
                }
            ]
        }
    ]
}