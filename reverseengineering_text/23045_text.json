{
    "title": "Reverse old win32 app to find encryption vulnerability",
    "link": "https://reverseengineering.stackexchange.com/questions/23045/reverse-old-win32-app-to-find-encryption-vulnerability",
    "content": "I’m trying to reverse engineer an old win32 application used on SCADA and ICS (Industrial Control Systems). This app has a silly encryption function to protect the user password to prevent unauthorized access. I’m pretty sure this encryption is easy to reverse as its maximum size is 10 chars. It’s probably doing some ROT with XOR, but instead of trying to guess what it does, I’m trying to reverse the software with Ghidra and take a look at the encryption function.\nThe problem is that I couldn’t find any suspicious function on the dlls that the app imports. So I’m trying to look for strings on the dialog box that encrypts the password. However all dialogs of this program are stored on a resource section of a dll (it seems that they provided different dlls for different languages). When I open this dll on Ghidra I can see the strings, but I can’t find which function calls them. Using ResEdit I managed to get the IDs of the dialog box and of the strings, but how can I match these IDs with the functions that call them? Is there a way to do it with static analysis only or will I need to use OllyDbg? Also, to make it worse, the dlls that contains the strings and dialog boxes isn’t listed in the import section of the main .exe neither on any import section of any of the imported dlls. I managed to actually find the function of the main .exe that dynamically imports the resource dll. I guess this would make it harder to find the match with static analysis only right? Any hints? Thanks!\n",
    "votes": "3",
    "answers": 1,
    "views": "553",
    "tags": [
        "windows",
        "ghidra",
        "pe-resources"
    ],
    "user": "Thiago Alves",
    "time": "Jan 18, 2020 at 18:17",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "I would like to offer a different approach as well, which would not involve classic RCE. Since you seem to be able to run the binary, you may use a tool like WinSpy (on GitHub) or Spy++ (included with Visual Studio) to look up the control IDs of the running application and match them to what you see during static analysis with Ghidra. Also understand that it's well possible to build blobs in memory which are understood as dialog resources and so on. Therefore it needn't be in the resource section at all ...\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "To work this out you need to understand how resources are loaded via Windows APIs. A number of APIs in kernel32.dll are commonly used such as:\nA number of APIs in Kernel32.dll are used for example:\n\nLoadLibrary \nLoadLibraryEx\nGetModuleHandle\nFindResource\nFindResourceEx\nLockResource\nFreeResource\nSizeofResource\n\nAnd for dialogs/windows additional APIs are used in user32.dll, such as:\n\nRegisterClassEx\nDialogBoxParam\nLoadAccelerators\nLoadIcon\nLoadImage\nLoadMenu\nLoadCursor\nLoadString\n\nA simple LoadString API in 32-bit code may look something like this where 101 is the string ID.\n<pre><code>        mov     DWORD PTR _stringID$[ebp], 101            ; string ID\n        mov     DWORD PTR _pBuf$[ebp], 0\n        push    0\n        lea     eax, DWORD PTR _pBuf$[ebp]                ; put location to store result in eax\n        push    eax\n        mov     ecx, DWORD PTR _stringID$[ebp]            ; string ID = 101\n        push    ecx\n        mov     edx, DWORD PTR _hInstance$[ebp]           ; hInstance\n        push    edx\n        call    DWORD PTR __imp__LoadStringW@16\n        mov     DWORD PTR _len$[ebp], eax                 ; eax holds length of string\n</code></pre>\nIn 64-bit code may look something like this:\n<pre><code>mov     DWORD PTR stringID$[rsp], 101       ; string ID\nmov     QWORD PTR pBuf$[rsp], 0\nxor     r9d, r9d\nlea     r8, QWORD PTR pBuf$[rsp]            ; put location to store result in r8\nmov     edx, DWORD PTR stringID$[rsp]       ; string ID = 101\nmov     rcx, QWORD PTR hInstance$[rsp]      ; hInstance\ncall    QWORD PTR __imp_LoadStringW\nmov     DWORD PTR len$[rsp], eax            ; length of returned string in EAX\n</code></pre>\nUsing FindResource in 32-bit may look something like this:\n<pre><code>push    0\npush    10         ; resource type ( 10 = RCDATA section)\npush    100        ; 100 = resource ID\n    mov     eax, DWORD PTR _hInstance$[ebp]    ; hInstance to module containing resource in EAX\n                push    eax\n                call    DWORD PTR __imp__FindResourceExA@16\n                mov     DWORD PTR _rc$[ebp], eax  ; handle to the specified resource's information block returned in EAX\n                mov     ecx, DWORD PTR _rc$[ebp]  ; specify resource information block handle in ECX\n                push    ecx\n                mov     edx, DWORD PTR _hInstance$[ebp] ; hInstance module with resource\n                push    edx\n                call    DWORD PTR __imp__LoadResource@8\n                mov     DWORD PTR _rcData$[ebp], eax  ; hGlobal Handle returned in EAX\n                mov     eax, DWORD PTR _rcData$[ebp]  ; specify hGlobal handle in EAX\n                push    eax\n                call    DWORD PTR __imp__LockResource@4 \n                mov     DWORD PTR _data$[ebp], eax ; If the loaded resource is available, the return value in EAX is a pointer to the first byte of the resource\n                mov     ecx, DWORD PTR _rc$[ebp]  ; resource information block handle\n                push    ecx\n                mov     edx, DWORD PTR _hInstance$[ebp] ; hInstance module with resource\n                push    edx\n                call    DWORD PTR __imp__SizeofResource@8 \n                mov     DWORD PTR _size$[ebp], eax ; EAX contains size of resource in bytes\n</code></pre>\nFindResource in 64-bit\n<pre><code>xor     r9d, r9d\n        mov     r8d, 10    ; resource type = 10 = RCDATA\n        mov     edx, 100   ; resource ID = 100                    \n        mov     rcx, QWORD PTR hInstance$[rsp] ; hInstance to module containing resource\n        call    QWORD PTR __imp_FindResourceExA\n        mov     QWORD PTR rc$[rsp], rax ; handle to the specified resource's information block returned in RAX\n        mov     rdx, QWORD PTR rc$[rsp] ; specify handle to resource information block in RDX\n        mov     rcx, QWORD PTR hInstance$[rsp] ; specify hInstance in RCX\n        call    QWORD PTR __imp_LoadResource\n        mov     QWORD PTR rcData$[rsp], rax ; HGLOBAL returned in RAX\n        mov     rcx, QWORD PTR rcData$[rsp] ; specify HGLOBAL in RCX\n        call    QWORD PTR __imp_LockResource\n        mov     QWORD PTR data$[rsp], rax  ; If the loaded resource is available, the return value in RAX is a pointer to the first byte of the resource\n        mov     rdx, QWORD PTR rc$[rsp]   ; handle to the specified resource's information block\n        mov     rcx, QWORD PTR hInstance$[rsp] ; hInstance for module containing resource\n        call    QWORD PTR __imp_SizeofResource\n        mov     DWORD PTR size$[rsp], eax ; size of data in bytes returned in EAX\n</code></pre>\n",
            "votes": "2",
            "user": "chentiangemalc",
            "time": "Jan 22, 2020 at 23:53",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">IIRC some functions take the resource ID directly and don’t require the resource to be loaded first, e.g. CreateDialog.</span>",
                    "time": null
                }
            ]
        }
    ]
}