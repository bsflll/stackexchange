{
    "title": "Why does tif.get_func_details sometimes only starts to work after decompiling the function?",
    "link": "https://reverseengineering.stackexchange.com/questions/30793/why-does-tif-get-func-details-sometimes-only-starts-to-work-after-decompiling-th",
    "content": "I am going through a huge executable and am fetching information about functions arguments this way:\n<pre><code>tif, funcdata = ida_typeinf.tinfo_t(), ida_typeinf.func_type_data_t()\n\nassert ida_nalt.get_tinfo(tif, ea)\nassert tif.get_func_details(funcdata)\n</code></pre>\nHowever, sometimes the <pre><code>get_func_details</code></pre> method fails (returns <pre><code>False</code></pre>) for seemingly no reason.\nIf I then manually go to that ea, in pseudocode view, and then rerun the above code for that ea, <pre><code>get_func_details</code></pre> returns <pre><code>True</code></pre> and everything works fine again.\nIt looks as if it's some \"not actually loaded to memory\" or \"need to initialize something, first\" kind of issue.\nI have worked around the problem by simply checking the return value of <pre><code>get_func_details</code></pre> and if False, then I call <pre><code>idaapi.decompile(ea)</code></pre> to make it \"refresh\" memory and rerun my function that obtains funcdata and that seems to work.\nThe question is:\n\nWhy does this actually happen?\nWhat is the correct way to prevent this?\n\nI don't want to resort to decompiling functions because it's slow and seems to be an overkill.\nNote: the executable has around 200k functions and out of the 5k+ functions that I have analyzed this way, only a single one required me to decompile it to make it work, so I highly doubt that the decompiling part is actually required here\n",
    "votes": "1",
    "answers": 1,
    "views": "175",
    "tags": [
        "ida",
        "idapython"
    ],
    "user": "overflo",
    "time": "Aug 19, 2022 at 13:32",
    "comments": [],
    "answers_data": [
        {
            "content": "IDA needs to decompile the function to work out the function details. If a function gets decompiled the first time, the details are stored in the database. They are updated later when you use the \"set function type\" operation.\nSo, you can't avoid to decompile the functions if you require information that is generated by exactly that decompilation.\n",
            "votes": "1",
            "user": "Michael Karcher",
            "time": "Aug 19, 2022 at 7:33",
            "is_accepted": false,
            "comments": [
                {
                    "user": "overflo",
                    "text": "<span class=\"comment-copy\">Out of the 5k+ functions that I have touched this way, in a newly loaded executable, only a single one required opening it in the decompiler. I highly doubt that the decompiler is actually required for using IDA functions that work with the disassembler part of IDA</span>",
                    "time": null
                },
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">@overflo so there must be something different about this function. What is it?</span>",
                    "time": null
                },
                {
                    "user": "Michael Karcher",
                    "text": "<span class=\"comment-copy\">I suspect that the function that needs to be decompiled doesn't call any known library functions, so the simple data flow analysis and type propagation of IDA won't guess the function signature, and only Hex-Rays is smart enough to guess a signature.</span>",
                    "time": null
                }
            ]
        }
    ]
}