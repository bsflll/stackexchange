{
    "title": "Unpack Billion 5102 firmware",
    "link": "https://reverseengineering.stackexchange.com/questions/2557/unpack-billion-5102-firmware",
    "content": "I'm trying to unpack this firmware image but I'm getting some issues understanding the structure.\nFirst of all I have one image which I called firmware.bin, and the file command shows me that it's a LIF file:\n<pre><code>firmware.bin: lif file\n</code></pre>\nAfter that I analyze it with binwalk:\n<pre><code>DECIMAL     HEX         DESCRIPTION\n-------------------------------------------------------------------------------------------------------\n84992       0x14C00     ZynOS header, header size: 48 bytes, rom image type: ROMBIN, uncompressed size: 65616, compressed size: 16606, uncompressed checksum: 0xBA2A, compressed checksum: 0x913E, flags: 0xE0, uncompressed checksum is valid, the binary is compressed, compressed checksum is valid, memory map table address: 0x0\n85043       0x14C33     LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 65616 bytes\n128002      0x1F402     GIF image data, version 8\"9a\", 200 x 50\n136194      0x21402     GIF image data, version 8\"7a\", 153 x 55\n349184      0x55400     ZynOS header, header size: 48 bytes, rom image type: ROMBIN, uncompressed size: 3113824, compressed size: 733298, uncompressed checksum: 0x3B9C, compressed checksum: 0xBBBA, flags: 0xE0, uncompressed checksum is valid, the binary is compressed, compressed checksum is valid, memory map table address: 0x0\n349235      0x55433     LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 3113824 bytes\n</code></pre>\nAs you can see there are 2 LZMA, 2 ZynOS (LZMA also once cut) and 2 images. Once I extract the LZMA I uncompress it and the first one is a single binary, but the second one is another LZMA file with 127 files in it, and each one of those files have a lot of new files inside.\n\nI guess that I'm not following the correct steps to unpack it, so I'm wondering how could I get the main filesystem clean?.\n",
    "votes": "8",
    "answers": 1,
    "views": "3k",
    "tags": [
        "firmware",
        "unpacking",
        "mips"
    ],
    "user": "Nucklear",
    "time": "Jun 4, 2014 at 9:10",
    "comments": [
        {
            "user": "Dmitry Janushkevich",
            "text": "To follow up on this and other ZyNOS questions here, my firmware tool has now been completed. github.com/dev-zzo/router-tools/blob/master/zynos.py It can both unpack and pack back firmware images; I've tested on BiPAC5102SAv27023_UE0B1C_3325 image to make sure it can process it. Have fun!\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "The output from the file utility, as you've probably guessed, is a false positive. The beginning of the firmware.bin file contains what looks to be a basic header (note the \"SIG\" string near the beginning of the file), and a bunch of MIPS executable code, which is likely the bootloader:\n<pre><code>DECIMAL         HEX             DESCRIPTION\n-------------------------------------------------------------------------------------------------------------------\n196             0xC4            MIPS instructions, function epilogue\n284             0x11C           MIPS instructions, function epilogue\n372             0x174           MIPS instructions, function epilogue\n388             0x184           MIPS instructions, function epilogue\n416             0x1A0           MIPS instructions, function epilogue\n424             0x1A8           MIPS instructions, function prologue\n592             0x250           MIPS instructions, function epilogue\n712             0x2C8           MIPS instructions, function epilogue\n720             0x2D0           MIPS instructions, function prologue\n832             0x340           MIPS instructions, function epilogue\n840             0x348           MIPS instructions, function prologue\n912             0x390           MIPS instructions, function epilogue\n920             0x398           MIPS instructions, function prologue\n976             0x3D0           MIPS instructions, function epilogue\n984             0x3D8           MIPS instructions, function epilogue\n1084            0x43C           MIPS instructions, function epilogue\n1192            0x4A8           MIPS instructions, function epilogue\n1264            0x4F0           MIPS instructions, function epilogue\n...\n</code></pre>\nRunning strings on the firmware.bin binary seems backup this hypothesis, with many references to checksum and decompression errors:\n<pre><code>checksum error! (cal=%04X, should=%04X)\n     signature error!\n     (Compressed)\nstart: %p\n     unmatched objtype between memMapTab and image!\n     Length: %X, Checksum: %04X\n     Version: %s, \n     Compressed Length: %X, Checksum: %04X\nmemMapTab Checksum Error! (cal=%04X, should=%04X)\nmemMapTab Checksum Error!\n%3d: %s(%s), start=%p, len=%X\n%s Section:\nmemMapTab: %d entries, start = %p, checksum = %04X\n$USER Section:\nsignature error!\nROMIO image start at %p\ncode length: %X\ncode version: %s\ncode start: %p\nDecompressed image Error!\nDecompressed image Checksum Error! (cal=%04X, should=%04X)\nROM length(%X) > RAM length (%X)!\nCan't find %s in $ROM section.\nCan't find %s in $RAM section.\nRasCode\n</code></pre>\nA quick examination of the strings in the two decompressed LZMA files you found shows that the smaller one (at offset 0x14C33) appears to contain some debug interface code, likely designed to be accessed via the device's UART:\n<pre><code>                        UART INTERNAL  LOOPBACK TEST\n                        UART EXTERNAL  LOOPBACK TEST\nERROR\n======= HTP Command Listing =======\n< press any key to continue >\n macPHYCtrl.value=\n                        MAC INTERNAL LOOPBACK TEST \n                        MAC EXTERNAL LOOPBACK TEST \n                        MAC INTERNAL LOOPBACK \n                        MAC EXTERNAL LOOPBACK \n LanIntLoopBack ...\nTx Path Full, Drop packet:%d\n0x%08x\ntx descrip %d:\nrx descrip %d:\n%02X \n%08X: \n< Press any key to Continue, ESC to Quit >\n0123456789abcdefghijklmnopqrstuvwxyz\n0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\n<NULL>\n) Register Dump *****\n***** ATM SAR Module: VC(\nReset&Identify reg   = \nTraffic Sched. TB reg= \nTX Data ctrl/stat reg= \nRX Data ctrl/stat reg= \nLast IRQ Status reg  = \nIRQ Queue Entry len  = \nVC IRQ Mask register = \nTX Data Current descr= \nRX Data Current descr= \nTX Traffic PCR       = \nTX Traffic MBS/Type  = \nTX Total Data Count  = \nVC IRQ CC Mask reg   = \nTX CC Current descr  = \nTX CC Total Count    = \nRX Miss Cell Count   = \n***** ATM SAR Module: Common Register Dump *****\n</code></pre>\nThe second larger file (at offset 0x55433) appears to contain the ThreadX RTOS, by Green Hills:\n<pre><code>RTA231CV Reserved String\nanonymous\nwww.huawei.com\n1000\ntc-e4f6ed2f5b87<\nMSFT 5.07\nuser<\nMSFT 5.07\nLXT972\n\"AC101L\nCIP101\nRTL8201\nCAC201\njjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\njjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\njjjjjjjj\njjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\njjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\njjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\njjjjjjjj\njjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\nSystem Timer Thread\nCopyright (c) 1996-2000 Express Logic Inc. * ThreadX R3900/Green Hills Version G3.0f.3.0b *\n</code></pre>\nIf you aren't familiar with RTOS's, they typically are just one big kernel with no concept of user space vs kernel space or what you would think of as a normal file system, although they will contain things like images and HTML files for this device's Web interface (see here for an example of how these types of files are stored/accessed in some VxWorks systems). \nI'd say that you already pretty much have this firmware extracted into its basic parts. To further analyze the bootloader or the two extracted LZMA files, you will need to start disassembling those files, which entails determining the memory address where they are loaded at boot time, identifying code/data sections, looking for possible symbol tables, identifying common functions, and probably writing some scripts to help with all of the above.\n",
            "votes": "8",
            "user": "devttys0",
            "time": "Jul 31, 2013 at 15:45",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Nucklear",
                    "text": "<span class=\"comment-copy\">Wow, this was exactly what I need, thank you so much, awesome as always. Just one more question, Is there a guide to identify headers? I'm pretty new in this field (In fact I started after reading your work on WAG120N) and sometimes is hard to detect false positives or strange FS/files. Regards.</span>",
                    "time": null
                },
                {
                    "user": "devttys0",
                    "text": "<span class=\"comment-copy\">It varies based on the file you are looking at, but generally file/firmware headers consist of 2-4 \"magic\" bytes, followed by some structured data which usually includes things like file size, creation date, checksum(s), and possibly a human-readable ASCII description. It is often useful to interpret each offset as various data types (big/little endian longs, shorts, date codes, etc) to identify these fields in an unknown header (I use binwalk's -C option, but any good hex editor will have this capability as well).</span>",
                    "time": null
                },
                {
                    "user": "Nucklear",
                    "text": "<span class=\"comment-copy\">Yes, I understand that, but once identified those headers how could I identify what FS/File it is with almost 0 experience? Is there any resources to compare headers and identify it? I see in your blog that you sometimes say \"Oh this is a LZMA header\" or even a \"weird LZMA header\" how do you identify that headers without previous knowledge? Regards.</span>",
                    "time": null
                },
                {
                    "user": "devttys0",
                    "text": "<span class=\"comment-copy\">I would start by looking at the entropy of the data, which can give you a good idea if it's encrypted, compressed or neither. If, for example, it looks compressed, I would then start comparing the beginning of the header to known common compression types (lzma, zlib, etc). Failing that, you will probably need to reverse the code responsible for accessing/decompressing that data.</span>",
                    "time": null
                }
            ]
        }
    ]
}