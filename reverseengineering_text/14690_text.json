{
    "title": "Modifying address found through IDA",
    "link": "https://reverseengineering.stackexchange.com/questions/14690/modifying-address-found-through-ida",
    "content": "I'm trying to inject code into a small game I wrote to keep the health up forever, I want to do this by injecting code into the game that would set the health to <pre><code>10</code></pre> before each <pre><code>render()</code></pre> call, causing the game to in essence never end. \n\nFor my project I wrote a small sample game in C++, which I then compiled, and decompiled in IDA. \nI managed to to find the address in which the <pre><code>health</code></pre> is being stored (<pre><code>0x0000000140005034</code></pre>), and the main loop address (<pre><code>0x000000014000107D</code></pre>), however I can't seem to figure out how I'd go from a static address in IDA, to an actual address when spawning the process in another C++ program.\nCould anyone give me a hint on how I could achieve this?\nHere's the code I'm trying to use to inject code into my application:\n<pre><code>#include <iostream>\n#include <Windows.h>\n\n#include \"config.h\"\n\nSTARTUPINFO info = {sizeof(info)};\nPROCESS_INFORMATION process;\n\n\nvoid injectCodeIntoProccess()\n{\n    // Stuck here, no idea how I could modify my game's code on every loop iteration.\n}\n\n\nvoid main()\n{\n    if (CreateProcess(EXECUTABLE_PATH, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &info, &process)) {\n        injectCodeIntoProccess();\n        WaitForSingleObject(process.hProcess, INFINITE);\n    } else {\n        std::cerr << \"Error whilst creating process.\" << std::endl;\n        exit(1);\n    }\n}\n</code></pre>\nHere's the code I used for my game:\n<pre><code>#include <iostream>\n#include <Windows.h>\n\n\n// Health variable\n// Address (as found in IDA): .data:0x0000000140005034\nint health = 10;\n\n\n// Render the game\n//\n// In real world scenario's this would be a 3d world or something\n// but we're using 'Health: *..' as the game itself.\nvoid render()\n{\n    std::cout << \"Health: \";\n    for (int i = 0; i < health; i++) std::cout << \"*\";\n    std::cout << std::endl;\n}\n\n\n// Gets input from the user\n//\n// If the user presses a spacebar, increase the health\n// by one otherwise, decrease the health by one.\nvoid input()\n{\n    if (GetKeyState(VK_SPACE) < 0) {\n        health++;\n    } else {\n        health--;\n    }\n}\n\n\n// Simple game\n//\n// If the player reaches 0 health game over.\n// This is checked every 500ms\nint main()\n{\n    while (health > 0) \n    {\n        input();\n        render();\n        Sleep(500);\n    }\n\n    return 0;\n}\n</code></pre>\n",
    "votes": "4",
    "answers": 1,
    "views": "2k",
    "tags": [
        "ida",
        "c++",
        "memory",
        "injection"
    ],
    "user": "Paradoxis",
    "time": "May 22, 2017 at 18:04",
    "comments": [
        {
            "user": "JavaMan",
            "text": "if your ultimate goal is just to play the game yourself, consider using Cheat Engine to freeze the health count. There is no need write your own hacking code\n",
            "time": null
        },
        {
            "user": "Paradoxis",
            "text": "@JavaMan the whole goal of the project is to learn how to do it, I want to help build mods for another game but I need to understand the basics first. I could simply change the code to never decrease the health and recompile it if I really wanted to.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "how I'd go from a static address in IDA, to an actual address ... in another C++ program\n\nWhen executable file is loaded in IDA, it is loaded with the preferred image base taken from executable's header. It can be viewed, for example, through menu <pre><code>Edit -> Segments -> Rebase program...</code></pre>. Value there is an image base.\nAnother way taken from here: go to <pre><code>File -> Script command...</code></pre> or press <pre><code>Shift+F2</code></pre>, select Python as scripting language, type\n<pre><code>print \"%x\" % (idaapi.get_imagebase())\n</code></pre>\nas script body and press <pre><code>Run</code></pre>. You will see current image base in the Output Window.\nEither way you will know image base assigned by IDA. In your example it's most likely <pre><code>0x0000000140000000</code></pre>. Now you can subtract it from the variable address you already know to get variable's offset in the executable (say, we're dealing with <pre><code>health</code></pre> variable stored at <pre><code>0x0000000140005034</code></pre>):\n<pre><code>0x0000000140005034 - 0x0000000140000000 = 0x5034\n</code></pre>\nNow you have to find image base of the target module in another process. In your example it's the image base of the executable itself, not DLL. Process of obtaining the exe image base may be found at stackoverflow through this link.\nThe code is posted below:\n<pre><code>#include <windows.h>\n\n#include <Psapi.h>\n\n#include <algorithm>\n#include <exception>\n#include <iostream>\n#include <string>\n#include <vector>\n\n// Linking Psapi.lib\n#pragma comment(lib, \"Psapi.lib\")\n\nstruct close_on_exit\n{\n    close_on_exit(HANDLE ptr)\n        : ptr_(ptr)\n    { };\n\n    ~close_on_exit()\n    {\n        if (ptr_)\n        {\n            ::CloseHandle(ptr_);\n            ptr_ = nullptr;\n        }\n    }\n\nprivate:\n    HANDLE ptr_;\n};\n\nint main()\n{\n    //\n    // code of creating process here\n    //\n\n    DWORD id = process.dwProcessId;  // obtained from PROCESS_INFORMATION structure\n\n    HANDLE process_handle = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, id);\n    close_on_exit free_ptr(process_handle);  // auto release memory on exception\n\n    if (NULL == process_handle)\n    {\n        throw std::exception(\"OpenProcess failed\");\n    }\n\n    DWORD bytes_requested = 0;\n    if (::EnumProcessModules(process_handle, NULL, 0, &bytes_requested) == 0)\n    {\n        throw std::exception(\"EnumProcessModules failed\");\n    }\n\n    // Retrieve module handles into array with appropriate size.\n    std::vector<HMODULE> module_handles(bytes_requested / sizeof(HMODULE));\n    if (::EnumProcessModules(process_handle, module_handles.data(), bytes_requested, &bytes_requested))\n    {\n        char module_name[MAX_PATH];\n\n        for (auto ci = module_handles.begin(); ci != module_handles.end(); ++ci)\n        {\n            if (::GetModuleFileNameExA(process_handle, *ci, module_name, sizeof(module_name)))\n            {\n                MODULEINFO module_info = { 0 };\n                if (false == ::GetModuleInformation(process_handle, *ci, &module_info, sizeof(module_info)))\n                {\n                    throw std::exception(\"GetModuleInformation failed\");\n                }\n\n                const std::string exe_ending = \".exe\";\n                std::string current_module = module_name;\n\n                // Make lower case of module name if it is something like \"EXE\".\n                std::transform(current_module.begin(), current_module.end(), current_module.begin(), ::tolower);\n\n                if (std::equal(exe_ending.rbegin(), exe_ending.rend(), current_module.rbegin()))\n                {\n                    std::cout << \"Process: \" << current_module << std::endl;\n                    std::cout << \" id: \" << id << std::endl;\n                    std::cout << \" image base: 0x\" << std::hex <<\n                        reinterpret_cast<uintptr_t>(module_info.lpBaseOfDll) << std::endl;\n\n                    break;\n                }\n            }\n            else\n            {\n                throw std::exception(\"GetModuleFileNameExA failed\");\n            }\n        }\n    }\n\n    return 0;\n}\n</code></pre>\nThen you should just add the offset to this image base and get address of the variable in the real process.\nIMO, injection is unnecessary for solving your issue. You may now use functions like <pre><code>ReadProcessMemory</code></pre> & <pre><code>WriteProcessMemory</code></pre> without injecting into process with interval less than <pre><code>500</code></pre> - this way you will update health from the external application more frequently than it will be updated from the game itself.\nAnother variant is to modify the code (not the variable itself) of your game in runtime. For this you should create your process suspended (or suspend it in runtime). You may learn address of the instruction which updates variable's state the same way as you learned the variable's address. Then you may modify it to the instruction which always sets the variable to some predefined value.\nFor example, code of health decreasing looks like this on my machine (debug x64):\n<pre><code>000000013FD32ACE 8B 05 2C 25 01 00    mov eax,dword ptr [health (013FD45000h)]  \n000000013FD32AD4 FF C8                dec eax  \n</code></pre>\nYou may modify it like this with the help of already mentioned <pre><code>WriteProcessMemory</code></pre> function:\n<pre><code>000000013FD32ACE B8 10 00 00 00           mov eax,10\n000000013FD32AD3 90                       nop\n000000013FD32AD4 90                       nop\n000000013FD32AD5 90                       nop\n</code></pre>\nIf you still want to play with code injection, here are tutorials on this topic:\nThree Ways to Inject Your Code into Another Process\nDLL Injection and function interception tutorial\n",
            "votes": "2",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": true,
            "comments": []
        }
    ]
}