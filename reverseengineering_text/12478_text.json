{
    "title": "Pointer arithmetic in C generated by ida / hexrays decompiler",
    "link": "https://reverseengineering.stackexchange.com/questions/12478/pointer-arithmetic-in-c-generated-by-ida-hexrays-decompiler",
    "content": "Please help me understand the following function lines. The loop body does some floating point arithmetic, but why does it cast float pointers to <pre><code>char *</code></pre>, and back?\n<pre><code>if ( CG.blockLength >= 4 )  \n{  \n    nrLevel = (char *)xTime - (char *)scratch;  \n    v8 = &scratch[CG.blockLength];  \n    v9 = xFreq + 1;  \n    v10 = outBuf + 2;  \n    v7 = 0;  \n    do  \n    {  \n      *(v9 - 1) = xTime[v7];  \n      v7 += 4;  \n      v9 += 4;  \n      *v8 = *(v10 - 2);  \n      v8 += 4;  \n      *(v9 - 4) = *(float *)((char *)v9 + nrLevel - 16);  \n      v10 += 4;  \n      *(v8 - 3) = *(float *)((char *)v9 + (char *)outBuf - (char *)xFreq - 16);  \n      *(v9 - 3) = *(float *)((char *)v10 + (char *)xTime - (char *)outBuf - 16);  \n      *(v8 - 2) = *(v10 - 4);  \n      *(v9 - 2) = xTime[v7 - 1];  \n      *(v8 - 1) = *(v10 - 3);  \n    }  \n    while ( v7 < L - 3 );  \n  }  \n  if ( v7 < L )  \n  {  \n    v11 = &xFreq[v7];  \n    v12 = &xFreq[v7 + L];  \n    v13 = L - v7;  \n    do  \n    {  \n      v14 = *(float *)((char *)v11 + (char *)xTime - (char *)xFreq);  \n      ++v11;  \n      *(v11 - 1) = v14;  \n      ++v12;  \n      --v13;  \n      *(v12 - 1) = *(float *)((char *)v11 + (char *)outBuf - (char *)xFreq - 4);  \n    }  \n    while ( v13 );  \n  }  \n</code></pre>\n\nFull function are here for quick reference \n<pre><code>int __cdecl NR_Proc(_NoiseReduction *Q, AudioSignal2_ *signal)  \n{  \n  float *scratch; // ecx@1  \n  float *v3; // edx@1  \n  float *xTime; // ebx@1  \n  int v5; // esi@1  \n  int v7; // edi@5  \n  float *v8; // ecx@6  \n  float *v9; // eax@6  \n  float *v10; // edx@6  \n  float *v11; // eax@9  \n  float *v12; // edx@9  \n  int v13; // ecx@9  \n  double v14; // st7@10  \n  double v15; // st7@14  \n  float *v16; // eax@14  \n  double v17; // st6@14  \n  double v18; // rt0@15  \n  float *v19; // ecx@16  \n  double v20; // rt1@16  \n  double v21; // st6@16  \n  double v22; // st7@16  \n  bool v23; // zf@16  \n  double v24; // st7@18  \n  double v25; // st6@18  \n  double v26; // st5@18  \n  double v27; // st4@18  \n  double v28; // st3@18  \n  int v29; // ecx@19  \n  unsigned int v30; // edx@19  \n  float *v31; // edi@19  \n  double v32; // st2@21  \n  double v33; // st7@21  \n  double v34; // rtt@21  \n  double v35; // st2@21  \n  double v36; // st6@21  \n  double v37; // rt0@23  \n  double v38; // st2@23  \n  double v39; // st4@23  \n  double v40; // st5@23  \n  double v41; // st2@23  \n  double v42; // rt0@23  \n  double v43; // st2@23  \n  double v44; // rt1@23  \n  double v45; // st2@23  \n  double v46; // rtt@23  \n  double v47; // rt0@24  \n  double v48; // st2@24  \n  double v49; // rtt@24  \n  double v50; // rt0@25  \n  double v51; // st2@25  \n  double v52; // st7@25  \n  double v53; // st2@26  \n  double v54; // st6@26  \n  double v55; // rt2@26  \n  double v56; // st2@26  \n  double v57; // st7@26  \n  double v58; // rtt@28  \n  double v59; // rtt@29  \n  double v60; // rt1@30  \n  double v61; // st2@30  \n  double v62; // st6@30  \n  double v63; // st2@31  \n  double v64; // st7@31  \n  double v65; // rtt@31  \n  double v66; // st2@31  \n  double v67; // st6@31  \n  double v68; // rt0@33  \n  double v69; // st2@33  \n  double v70; // st4@33  \n  double v71; // st5@33  \n  double v72; // st2@33  \n  double v73; // rt0@33  \n  double v74; // st2@33  \n  double v75; // rt1@33  \n  double v76; // st2@33  \n  double v77; // rtt@33  \n  double v78; // rt0@34  \n  double v79; // st2@34  \n  double v80; // rtt@34  \n  double v81; // rt0@35  \n  double v82; // st2@35  \n  double v83; // st7@35  \n  double v84; // st2@36  \n  double v85; // st6@36  \n  double v86; // rt2@36  \n  double v87; // st2@36  \n  double v88; // rtt@38  \n  double v89; // rtt@39  \n  double v90; // st1@40  \n  double v91; // rt1@40  \n  double v92; // st2@40  \n  float *v93; // ecx@42  \n  int v94; // edx@42  \n  double v95; // rt2@43  \n  double v96; // st3@43  \n  double v97; // rt0@43  \n  double v98; // st2@45  \n  double v99; // st7@45  \n  double v100; // rt2@45  \n  double v101; // st2@45  \n  double v102; // st6@45  \n  double v103; // rtt@47  \n  double v104; // st2@47  \n  double v105; // st4@47  \n  double v106; // st5@47  \n  double v107; // st2@47  \n  double v108; // rtt@47  \n  double v109; // st2@47  \n  double v110; // rt0@47  \n  double v111; // st2@47  \n  double v112; // rt2@47  \n  double v113; // rtt@48  \n  double v114; // st2@48  \n  double v115; // rt2@48  \n  double v116; // st1@49  \n  double v117; // rtt@49  \n  double v118; // st2@49  \n  double v119; // st7@49  \n  int v120; // edx@51  \n  int v121; // edi@51  \n  int v122; // ecx@52  \n  unsigned int v123; // edx@52  \n  int v124; // eax@52  \n  int v125; // eax@56  \n  int v126; // edx@56  \n  double v127; // st7@57  \n  int v128; // edx@59  \n  double v129; // st7@59  \n  int v130; // edi@60  \n  int v131; // ecx@60  \n  float v132; // ST18_4@61  \n  double v133; // ST30_8@61  \n  double v134; // st1@61  \n  bool v135; // c0@61  \n  bool v136; // c3@61  \n  double v137; // st1@61  \n  float v138; // ST30_4@63  \n  float v139; // ST30_4@63  \n  float v140; // ST18_4@63  \n  double v141; // ST30_8@63  \n  double v142; // st1@63  \n  bool v143; // c0@63  \n  bool v144; // c3@63  \n  double v145; // st1@63  \n  float v146; // ST30_4@65  \n  float v147; // ST30_4@65  \n  float v148; // ST18_4@65  \n  double v149; // ST30_8@65  \n  double v150; // st1@65  \n  bool v151; // c0@65  \n  bool v152; // c3@65  \n  double v153; // st1@65  \n  float v154; // ST30_4@67  \n  float v155; // ST30_4@67  \n  float v156; // ST18_4@67  \n  double v157; // ST30_8@67  \n  double v158; // st1@67  \n  bool v159; // c0@67  \n  bool v160; // c3@67  \n  double v161; // st1@67  \n  float v162; // ST30_4@69  \n  float v163; // ST30_4@69  \n  int v164; // edi@71  \n  int v165; // ecx@71  \n  int v166; // esi@71  \n  float v167; // ST18_4@72  \n  double v168; // ST30_8@72  \n  double v169; // st1@72  \n  bool v170; // c0@72  \n  bool v171; // c3@72  \n  double v172; // st1@72  \n  float v173; // ST4C_4@74  \n  float v174; // ST4C_4@74  \n  int v175; // edx@75  \n  int v176; // esi@75  \n  int v177; // ecx@76  \n  unsigned int v178; // edx@76  \n  int v179; // eax@76  \n  int v180; // eax@80  \n  int v181; // edx@80  \n  double v182; // st7@81  \n  float EXi; // [sp+10h] [bp-3Ch]@21 MAPDST  \n  float y2; // [sp+14h] [bp-38h]@20 MAPDST  \n  double y2j; // [sp+14h] [bp-38h]@61 MAPDST  \n  int L; // [sp+20h] [bp-2Ch]@5  \n  float *outBuf; // [sp+24h] [bp-28h]@3  \n  float *N; // [sp+28h] [bp-24h]@1  \n  int i; // [sp+2Ch] [bp-20h]@18  \n  int nrLevel; // [sp+38h] [bp-14h]@6 MAPDST  \n  float *G; // [sp+3Ch] [bp-10h]@1  \n  float *xFreq; // [sp+40h] [bp-Ch]@1  \n  int bufLength; // [sp+44h] [bp-8h]@1  \n  int v218; // [sp+48h] [bp-4h]@60  \n\n  scratch = CG.Scratch;  \n  v3 = Q->G;  \n  xTime = Q->xTime;  \n  v5 = CG.ERB_Length;  \n  ++Q->count;  \n  xFreq = scratch;  \n  G = v3;  \n  N = Q->N;  \n  bufLength = v5;  \n  if ( !(Q->Enabled & 0x10000000) )  \n    return -5;  \n  outBuf = signal->buffer;  \n  if ( !signal->buffer )  \n    return -1;  \n  v7 = 0;  \n  L = CG.blockLength;  \n  if ( CG.blockLength >= 4 )  \n  {  \n    nrLevel = (char *)xTime - (char *)scratch;  \n    v8 = &scratch[CG.blockLength];  \n    v9 = xFreq + 1;  \n    v10 = outBuf + 2;  \n    v7 = 0;  \n    do  \n    {  \n      *(v9 - 1) = xTime[v7];  \n      v7 += 4;  \n      v9 += 4;  \n      *v8 = *(v10 - 2);  \n      v8 += 4;  \n      *(v9 - 4) = *(float *)((char *)v9 + nrLevel - 16);  \n      v10 += 4;  \n      *(v8 - 3) = *(float *)((char *)v9 + (char *)outBuf - (char *)xFreq - 16);  \n      *(v9 - 3) = *(float *)((char *)v10 + (char *)xTime - (char *)outBuf - 16);  \n      *(v8 - 2) = *(v10 - 4);  \n      *(v9 - 2) = xTime[v7 - 1];  \n      *(v8 - 1) = *(v10 - 3);  \n    }  \n    while ( v7 < L - 3 );  \n  }  \n  if ( v7 < L )  \n  {  \n    v11 = &xFreq[v7];  \n    v12 = &xFreq[v7 + L];  \n    v13 = L - v7;  \n    do  \n    {  \n      v14 = *(float *)((char *)v11 + (char *)xTime - (char *)xFreq);  \n      ++v11;  \n      *(v11 - 1) = v14;  \n      ++v12;  \n      --v13;  \n      *(v12 - 1) = *(float *)((char *)v11 + (char *)outBuf - (char *)xFreq - 4);  \n    }  \n    while ( v13 );  \n  }  \n  WindowFft(xFreq, L);  \n  AmpSpectrum(xFreq, xTime);  \n  if ( Q->count < 20 && signal->Silence )  \n  {  \n    if ( v5 > 0 )  \n    {  \n      v15 = 1.0;  \n      v16 = N;  \n      v17 = 0.5;  \n      nrLevel = v5;  \n      while ( 1 )  \n      {  \n        v19 = (float *)((char *)v16 + (char *)xTime - (char *)N);  \n        v20 = v17;  \n        v21 = v15;  \n        v22 = v20;  \n        *(float *)((char *)v19 + (char *)G - (char *)xTime) = v21;  \n        ++v16;  \n        v23 = nrLevel-- == 1;  \n        *(v16 - 1) = *v19 * v20 + *(v16 - 1) * v20;  \n        if ( v23 )  \n          break;  \n        v18 = v21;  \n        v17 = v22;  \n        v15 = v18;  \n      }  \n    }  \n  }  \n  else  \n  {  \n    v24 = 0.94999999;  \n    v25 = 0.050000001;  \n    i = 0;  \n    v26 = 0.99800003;  \n    v27 = 0.0020000001;  \n    v28 = 0.99980003;  \n    if ( v5 >= 4 )  \n    {  \n      v29 = (int)(N + 1);  \n      v30 = ((unsigned int)(v5 - 4) >> 2) + 1;  \n      v31 = xTime + 3;  \n      i = 4 * v30;  \n      do  \n      {  \n        y2 = *(v31 - 3);  \n        if ( *(float *)(v29 - 4) <= (double)y2 )  \n        {  \n          if ( Q->count >= 2000 )  \n          {  \n            v47 = y2;  \n            EXi = 0.99980003;  \n            y2 = 0.00019999999;  \n            v48 = v24;  \n            v33 = v47;  \n            v49 = v48;  \n            v35 = v25;  \n            v36 = v49;  \n          }  \n          else  \n          {  \n            v37 = y2;  \n            EXi = v26;  \n            v38 = v27;  \n            v39 = v26;  \n            y2 = v38;  \n            v40 = v38;  \n            v41 = v24;  \n            v33 = v37;  \n            v42 = v41;  \n            v43 = v25;  \n            v36 = v42;  \n            v44 = v43;  \n            v45 = v40;  \n            v26 = v39;  \n            v46 = v45;  \n            v35 = v44;  \n            v27 = v46;  \n          }  \n        }  \n        else  \n        {  \n          v32 = v24;  \n          v33 = y2;  \n          EXi = v32;  \n          v34 = v32;  \n          v35 = v25;  \n          v36 = v34;  \n          y2 = v35;  \n        }  \n        v50 = v35;  \n        v51 = v33 * y2 + *(float *)(v29 - 4) * EXi;  \n        v52 = v50;  \n        *(float *)(v29 - 4) = v51;  \n        y2 = *(float *)(v29 + (char *)xTime - (char *)N);  \n        if ( *(float *)v29 <= (double)y2 )  \n        {  \n          if ( Q->count >= 2000 )  \n          {  \n            v59 = y2;  \n            EXi = 0.99980003;  \n            y2 = 0.00019999999;  \n            v56 = v52;  \n            v57 = v36;  \n            v54 = v59;  \n          }  \n          else  \n          {  \n            v58 = y2;  \n            EXi = v26;  \n            y2 = v27;  \n            v56 = v52;  \n            v57 = v36;  \n            v54 = v58;  \n          }  \n        }  \n        else  \n        {  \n          v53 = v36;  \n          v54 = y2;  \n          EXi = v53;  \n          v55 = v53;  \n          v56 = v52;  \n          v57 = v55;  \n          y2 = v56;  \n        }  \n        v60 = v56;  \n        v61 = v54 * y2 + *(float *)v29 * EXi;  \n        v62 = v60;  \n        *(float *)v29 = v61;  \n        y2 = *(v31 - 1);  \n        if ( *(float *)(v29 + 4) <= (double)y2 )  \n        {  \n          if ( Q->count >= 2000 )  \n          {  \n            v78 = y2;  \n            EXi = 0.99980003;  \n            y2 = 0.00019999999;  \n            v79 = v57;  \n            v64 = v78;  \n            v80 = v79;  \n            v66 = v62;  \n            v67 = v80;  \n          }  \n          else  \n          {  \n            v68 = y2;  \n            EXi = v26;  \n            v69 = v27;  \n            v70 = v26;  \n            y2 = v69;  \n            v71 = v69;  \n            v72 = v57;  \n            v64 = v68;  \n            v73 = v72;  \n            v74 = v62;  \n            v67 = v73;  \n            v75 = v74;  \n            v76 = v71;  \n            v26 = v70;  \n            v77 = v76;  \n            v66 = v75;  \n            v27 = v77;  \n          }  \n        }  \n        else  \n        {  \n          v63 = v57;  \n          v64 = y2;  \n          EXi = v63;  \n          v65 = v63;  \n          v66 = v62;  \n          v67 = v65;  \n          y2 = v66;  \n        }  \n        v81 = v66;  \n        v82 = v64 * y2 + EXi * *(float *)(v29 + 4);  \n        v83 = v81;  \n        *(float *)(v29 + 4) = v82;  \n        y2 = *v31;  \n        if ( *(float *)(v29 + 8) <= (double)y2 )  \n        {  \n          if ( Q->count >= 2000 )  \n          {  \n            v89 = y2;  \n            EXi = 0.99980003;  \n            y2 = 0.00019999999;  \n            v87 = v83;  \n            v24 = v67;  \n            v85 = v89;  \n          }  \n          else  \n          {  \n            v88 = y2;  \n            EXi = v26;  \n            y2 = v27;  \n            v87 = v83;  \n            v24 = v67;  \n            v85 = v88;  \n          }  \n        }  \n        else  \n        {  \n          v84 = v67;  \n          v85 = y2;  \n          EXi = v84;  \n          v86 = v84;  \n          v87 = v83;  \n          v24 = v86;  \n          y2 = v87;  \n        }  \n        v90 = *(float *)(v29 + 8);  \n        v29 += 16;  \n        v31 += 4;  \n        --v30;  \n        v91 = v87;  \n        v92 = v85 * y2 + v90 * EXi;  \n        v25 = v91;  \n        *(float *)(v29 - 8) = v92;  \n      }  \n      while ( v30 );  \n    }  \n    if ( i < v5 )  \n    {  \n      v93 = &N[i];  \n      v94 = v5 - i;  \n      while ( 1 )  \n      {  \n        y2 = *(float *)((char *)v93 + (char *)xTime - (char *)N);  \n        if ( *v93 <= (double)y2 )  \n        {  \n          if ( Q->count >= 2000 )  \n          {  \n            v113 = y2;  \n            EXi = v28;  \n            y2 = 0.00019999999;  \n            v114 = v24;  \n            v99 = v113;  \n            v115 = v114;  \n            v101 = v25;  \n            v102 = v115;  \n          }  \n          else  \n          {  \n            v103 = y2;  \n            EXi = v26;  \n            v104 = v27;  \n            v105 = v26;  \n            y2 = v104;  \n            v106 = v104;  \n            v107 = v24;  \n            v99 = v103;  \n            v108 = v107;  \n            v109 = v25;  \n            v102 = v108;  \n            v110 = v109;  \n            v111 = v106;  \n            v26 = v105;  \n            v112 = v111;  \n            v101 = v110;  \n            v27 = v112;  \n          }  \n        }  \n        else  \n        {  \n          v98 = v24;  \n          v99 = y2;  \n          EXi = v98;  \n          v100 = v98;  \n          v101 = v25;  \n          v102 = v100;  \n          y2 = v101;  \n        }  \n        v116 = *v93;  \n        ++v93;  \n        --v94;  \n        v117 = v101;  \n        v118 = v99 * y2 + v116 * EXi;  \n        v119 = v117;  \n        *(v93 - 1) = v118;  \n        if ( !v94 )  \n          break;  \n        v95 = v28;  \n        v96 = v119;  \n        v24 = v102;  \n        v97 = v96;  \n        v28 = v95;  \n        v25 = v97;  \n      }  \n    }  \n  }  \n  if ( Q->Enabled & 0x2000000 )  \n  {  \n    v128 = 0;  \n    v129 = CG.dbTable[Q->nrLeveldB];  \n    if ( v5 >= 4 )  \n    {  \n      v130 = (int)(N + 2);  \n      v218 = (char *)N - (char *)G;  \n      v131 = (int)(G + 1);  \n      nrLevel = (char *)xTime - (char *)N;  \n      do  \n      {  \n        EXi = xTime[v128];  \n        v132 = *(float *)(v130 - 8) * 8.0;  \n        v133 = EXi - v132;  \n        v134 = EXi * v129;  \n        y2j = v134;  \n        v135 = v133 < v134;  \n        v136 = v133 == v134;  \n        v137 = v133;  \n        if ( v135 || v136 )  \n          v137 = y2j;  \n        v138 = v137;  \n        v139 = v138 / (EXi + 1.0 + 2.0);  \n        *(float *)(v131 - 4) = v139 * 0.300000011920929 + *(float *)(v131 - 4) * 0.699999988079071;  \n        EXi = *(float *)(nrLevel + v131 + v218);  \n        v140 = *(float *)(v131 + v218) * 8.0;  \n        v141 = EXi - v140;  \n        v142 = EXi * v129;  \n        y2j = v142;  \n        v143 = v141 < v142;  \n        v144 = v141 == v142;  \n        v145 = v141;  \n        if ( v143 || v144 )  \n          v145 = y2j;  \n        v146 = v145;  \n        v147 = v146 / (EXi + 1.0 + 2.0);  \n        *(float *)v131 = v147 * 0.300000011920929 + *(float *)v131 * 0.699999988079071;  \n        EXi = *(float *)(v130 + nrLevel);  \n        v148 = *(float *)v130 * 8.0;  \n        v149 = EXi - v148;  \n        v150 = EXi * v129;  \n        y2j = v150;  \n        v151 = v149 < v150;  \n        v152 = v149 == v150;  \n        v153 = v149;  \n        if ( v151 || v152 )  \n          v153 = y2j;  \n        v154 = v153;  \n        v155 = v154 / (EXi + 1.0 + 2.0);  \n        *(float *)(v131 + 4) = v155 * 0.300000011920929 + *(float *)(v131 + 4) * 0.699999988079071;  \n        EXi = xTime[v128 + 3];  \n        v156 = *(float *)(v130 + 4) * 8.0;  \n        v157 = EXi - v156;  \n        v158 = EXi * v129;  \n        y2j = v158;  \n        v159 = v157 < v158;  \n        v160 = v157 == v158;  \n        v161 = v157;  \n        if ( v159 || v160 )  \n          v161 = y2j;  \n        v162 = v161;  \n        v5 = bufLength;  \n        v128 += 4;  \n        v131 += 16;  \n        v130 += 16;  \n        v163 = v162 / (EXi + 1.0 + 2.0);  \n        *(float *)(v131 - 8) = v163 * 0.300000011920929 + *(float *)(v131 - 8) * 0.699999988079071;  \n      }  \n      while ( v128 < bufLength - 3 );  \n    }  \n    if ( v128 < v5 )  \n    {  \n      v164 = (char *)N - (char *)G;  \n      v165 = (int)&G[v128];  \n      v166 = v5 - v128;  \n      do  \n      {  \n        EXi = *(float *)(v165 + v164 + (char *)xTime - (char *)N);  \n        v167 = *(float *)(v165 + v164) * 8.0;  \n        v168 = EXi - v167;  \n        v169 = EXi * v129;  \n        y2j = v169;  \n        v170 = v168 < v169;  \n        v171 = v168 == v169;  \n        v172 = v168;  \n        if ( v170 || v171 )  \n          v172 = y2j;  \n        v173 = v172;  \n        v165 += 4;  \n        --v166;  \n        v174 = v173 / (EXi + 1.0 + 2.0);  \n        *(float *)(v165 - 4) = v174 * 0.300000011920929 + *(float *)(v165 - 4) * 0.699999988079071;  \n      }  \n      while ( v166 );  \n    }  \n    FreqSmooth(G, xFreq, 0.5);  \n    v175 = L;  \n    v176 = 0;  \n    if ( L >= 4 )  \n    {  \n      v177 = (int)(outBuf + 3);  \n      v178 = ((unsigned int)(L - 4) >> 2) + 1;  \n      v179 = (int)(xTime + 1);  \n      v176 = 4 * v178;  \n      do  \n      {  \n        v179 += 16;  \n        *(float *)(v179 - 20) = *(float *)(v177 - 12);  \n        v177 += 16;  \n        --v178;  \n        *(float *)(v179 - 16) = *(float *)(v179 + (char *)outBuf - (char *)xTime - 16);  \n        *(float *)(v179 - 12) = *(float *)(v177 - 20);  \n        *(float *)(v179 - 8) = *(float *)(v177 - 16);  \n      }  \n      while ( v178 );  \n      v175 = L;  \n    }  \n    if ( v176 < v175 )  \n    {  \n      v180 = (int)&xTime[v176];  \n      v181 = v175 - v176;  \n      do  \n      {  \n        v182 = *(float *)((char *)outBuf - (char *)xTime + v180);  \n        v180 += 4;  \n        --v181;  \n        *(float *)(v180 - 4) = v182;  \n      }  \n      while ( v181 );  \n    }  \n    Reconstruct(xFreq, outBuf, Q->by);  \n    return 0;  \n  }  \n  v120 = L;  \n  v121 = 0;  \n  if ( L >= 4 )  \n  {  \n    v122 = (int)(outBuf + 3);  \n    v123 = ((unsigned int)(L - 4) >> 2) + 1;  \n    v124 = (int)(xTime + 1);  \n    v121 = 4 * v123;  \n    do  \n    {  \n      v124 += 16;  \n      *(float *)(v124 - 20) = *(float *)(v122 - 12);  \n      v122 += 16;  \n      --v123;  \n      *(float *)(v124 - 16) = *(float *)((char *)outBuf - (char *)xTime + v124 - 16);  \n      *(float *)(v124 - 12) = *(float *)(v122 - 20);  \n      *(float *)(v124 - 8) = *(float *)(v122 - 16);  \n    }  \n    while ( v123 );  \n    v120 = L;  \n  }  \n  if ( v121 >= v120 )  \n    return 0;  \n  v125 = (int)&xTime[v121];  \n  v126 = v120 - v121;  \n  do  \n  {  \n    v127 = *(float *)(v125 + (char *)outBuf - (char *)xTime);  \n    v125 += 4;  \n    --v126;  \n    *(float *)(v125 - 4) = v127;  \n  }  \n  while ( v126 );  \n  return 0;  \n}  \n</code></pre>\n",
    "votes": "1",
    "answers": 1,
    "views": "908",
    "tags": [
        "ida",
        "decompiler",
        "float"
    ],
    "user": "Arun",
    "time": "Apr 19, 2016 at 19:32",
    "comments": [],
    "answers_data": [
        {
            "content": "These casts are done to make the pointer arithmetic that's happening more clear.\nWhen you add an integer to a pointer, the integer internally gets multiplied by the size of the object the pointer is pointing to, so when <pre><code>fp</code></pre> is a float pointer, assuming 4 byte floats, <pre><code>fp+1</code></pre> will point to a memory location 4 bytes behind <pre><code>fp</code></pre>. And in the same way, pointer subtraction divides the byte difference by the object type, so with <pre><code>fp1</code></pre> and <pre><code>fp2</code></pre> being float pointers, something like\n<pre><code>fp1=&array[3];\nfp2=&array[7];\nprintf(\"%d\n\", fp2-fp1);\n</code></pre>\nyou'll get a result of 4, not 16, even though there are 16 bytes between both addresses. (Which is the reason why pointer subtraction works with the same pointer type only, and is undefined behaviour if both pointers don't point into the same array).\nNow look at an expression like\n<pre><code>*(float *)((char *)v9 + (char *)outBuf - (char *)xFreq - 16);\n</code></pre>\nWith <pre><code>v9</code></pre>, <pre><code>outBuf</code></pre>, and <pre><code>xFreq</code></pre> declared <pre><code>float *</code></pre>, this is identical to \n<pre><code>*(v9 + outBuf - xFreq - 4)\n</code></pre>\nor even\n<pre><code>v9[outBuf-xFreq-4].\n</code></pre>\nBut, as ida can only guess the data types, there is a certain chance it guesses wrong, and you might want to change them later. But if you do that, the meaning of the expression changes as well, as the integer part of the expression gets scaled differently. To avoid that, when working with pointer arithmetic, ida casts all pointers to <pre><code>char *</code></pre> first, does its arithmetic, then casts the result back to what the pointer is supposed to be pointing to.\nThis also helps you match the assembler with the original source, because it avoids turning a <pre><code>sub XXX, 16</code></pre> assembly instruction into a <pre><code>XXX - 4</code></pre> C expression.\n",
            "votes": "2",
            "user": "Guntram Blohm",
            "time": "Apr 19, 2016 at 8:20",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Arun",
                    "text": "<span class=\"comment-copy\">I have pdb file of above program still ida don't use the name of local variable in case you want to have ida data base let me know  .thanx Guntram Blohm for your explanation</span>",
                    "time": null
                }
            ]
        }
    ]
}