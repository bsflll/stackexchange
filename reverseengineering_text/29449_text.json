{
    "title": "What does the instructions sequence call/cdqe/ret do?",
    "link": "https://reverseengineering.stackexchange.com/questions/29449/what-does-the-instructions-sequence-call-cdqe-ret-do",
    "content": "I'm trying to reverse a Linux module. In the <pre><code>ioctl</code></pre> routine, I have the following sequence of instructions (generated by <pre><code>objdump -M intel -d test.ko</code></pre>):\n<pre><code> 3f9:   74 3b                   je     436 <device_ioctl+0x46>\n...\n 436:   e8 00 00 00 00          call   43b <device_ioctl+0x4b>\n 43b:   48 98                   cdqe   \n 43d:   c3                      ret\n</code></pre>\nI'm not sure to understand what happens here after the jump is done.\nFirst, we have a <pre><code>call</code></pre> instruction. The opcode is <pre><code>E8 00</code></pre> so it is a near call to the next instruction. The EIP register (which contain the address of the next instruction) is also pushed on the stack.\nThen, we continue with the <pre><code>cdqe</code></pre> instruction. It extends the sign of the EAX register into RAX. In other words, it does nothing. Just to mention, EAX/RAX register has not been modified from the beginning of the routine.\nFinally, the <pre><code>ret</code></pre> instruction is executed. It pops the stack into EIP which corresponds to the previous instruction and we continue the execution of the routine from that point.\nTherefore, <pre><code>cdqe</code></pre> is executed again (to do nothing) and the <pre><code>ret</code></pre> instruction is called again. This time, we leave the <pre><code>ioctl</code></pre> routine and return to the callee.\nAm I right saying this does nothing? If so, what is the point of that code?\n\nHere is the full routine:\n<pre><code>00000000000003f0 <device_ioctl>:\n 3f0:   48 89 d7                mov    rdi,rdx\n 3f3:   81 fe 03 b0 fe ca       cmp    esi,0xcafeb003\n 3f9:   74 3b                   je     436 <device_ioctl+0x46>\n 3fb:   77 18                   ja     415 <device_ioctl+0x25>\n 3fd:   81 fe 01 b0 fe ca       cmp    esi,0xcafeb001\n 403:   74 39                   je     43e <device_ioctl+0x4e>\n 405:   81 fe 02 b0 fe ca       cmp    esi,0xcafeb002\n 40b:   75 39                   jne    446 <device_ioctl+0x56>\n 40d:   e8 00 00 00 00          call   412 <device_ioctl+0x22>\n 412:   48 98                   cdqe   \n 414:   c3                      ret    \n 415:   48 c7 c0 00 00 00 00    mov    rax,0x0\n 41c:   48 c7 c2 ff ff ff ff    mov    rdx,0xffffffffffffffff\n 423:   48 2d 00 00 00 00       sub    rax,0x0\n 429:   81 fe 04 b0 fe ca       cmp    esi,0xcafeb004\n 42f:   89 c0                   mov    eax,eax\n 431:   48 0f 45 c2             cmovne rax,rdx\n 435:   c3                      ret    \n 436:   e8 00 00 00 00          call   43b <device_ioctl+0x4b>\n 43b:   48 98                   cdqe   \n 43d:   c3                      ret    \n 43e:   e8 00 00 00 00          call   443 <device_ioctl+0x53>\n 443:   48 98                   cdqe   \n 445:   c3                      ret    \n 446:   48 83 c8 ff             or     rax,0xffffffffffffffff\n 44a:   c3                      ret    \n</code></pre>\nThis is from the nightclub challenge of the pbctf 2021.\n",
    "votes": "1",
    "answers": 1,
    "views": "357",
    "tags": [
        "kernel",
        "assembly"
    ],
    "user": "Pierre",
    "time": "Oct 23, 2021 at 8:52",
    "comments": [],
    "answers_data": [
        {
            "content": "cdqe does this RAX ‚Üê sign-extend of EAX.\napplicable only in x64\nshown below is a demo of x86 cdq which instead of using rax uses eax,edx combo\nedx gets the sign extension  in x86\nfor cdqe register rax will become <pre><code>0xffffffff<eax> or 0x00000000<eax></code></pre>\n\nmaybe ctf is checking the sign\n",
            "votes": "1",
            "user": "blabb",
            "time": "Oct 23, 2021 at 10:49",
            "is_accepted": false,
            "comments": []
        }
    ]
}