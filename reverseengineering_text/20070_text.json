{
    "title": "Problems with extracting firmware",
    "link": "https://reverseengineering.stackexchange.com/questions/20070/problems-with-extracting-firmware",
    "content": "I am currently trying to reverse-engineer the firmware of an E-Cigarette but I cannot find any clues with the common tools. Heres everything I found so far.\n\nBinwalk doesnt recognize anything even with <pre><code>-E</code></pre> or <pre><code>-A</code></pre>.\nEntropy = 7.611435 bits per byte.\nOptimum compression would reduce the size of this 80896 byte file by 4 percent.\nChi square distribution for 80896 samples is 99630.01, and randomly\nwould exceed this value less than 0.01 percent of the times.\nArithmetic mean value of data bytes is 117.2996 (127.5 = random).\nMonte Carlo value for Pi is 3.078178312 (error 2.02 percent).\nSerial correlation coefficient is 0.107920 (totally uncorrelated = 0.0).\n\nIs it possible that this file is encrypted or compressed?\nHere is a visualization of the entropy:\n\nAnd here is the graph of the entropy:\n\nHere is a download of the Firmware.\nhttps://www.file-upload.net/download-13422170/HW718V40_20171008.firmware.html\n",
    "votes": "4",
    "answers": 1,
    "views": "730",
    "tags": [
        "firmware",
        "firmware-analysis"
    ],
    "user": "Cubzer",
    "time": "Dec 7, 2018 at 11:44",
    "comments": [
        {
            "user": "julian",
            "text": "Can you share a link to the file? If not, can you post the entropy plot generated by <pre><code>binwalk -E <your file></code></pre> ? The distribution of higher-entropy data is not as uniform as what I would expect from compressed or encrypted data. Furthermore, there are sizable low entropy regions. What are the results of running <pre><code>strings -n 9 <your file></code></pre> ? Have you looked at a hex dump of the first few hundred bytes?\n",
            "time": null
        },
        {
            "user": "Cubzer",
            "text": "Hi I added the download to my question. I looked at the hexdump of the file and tried to disassemble it with radare2 and different flavours but nothing helpful came out of it. Im not at home so i unfortunatly cant provide you with a entropy Plot. The ASCII strings in the hexdump are also nothing that makes sense to me but maybe you find something. Thanks for the help.\n",
            "time": null
        },
        {
            "user": "eggyal",
            "text": "Wouldn’t it be wise to first identify the processor, and from that (hopefully) the instruction set?\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "TL;DR\nYes the file is encrypted, it is a simple XOR cipher with a key length of 0x800 bytes.\nPython script for getting decrypted firmware:\n<pre><code>import struct\n\nFILENAME = \"HW718V40_20171008.firmware\"\n\ndef xor_cipher(data, key):\n    import sys\n    from itertools import cycle\n    if (sys.version_info > (3, 0)):\n        return bytes(a ^ b for a, b in zip(data, cycle(key)))\n    else:\n        return bytes(bytearray(a ^ b for a, b in zip(bytearray(data), cycle(bytearray(key)))))\n\nkey = struct.pack('<I', 0x00001AE7) * 8 + struct.pack('<I', 0x000026EF) \\\n* 8 + struct.pack('<I', 0x0000565C) * 8 + struct.pack('<I',\n    0x00001109) * 8 + struct.pack('<I', 0x00005618) * 8 \\\n+ struct.pack('<I', 0x000077D6) * 8 + struct.pack('<I', 0x00000F45) \\\n* 8 + struct.pack('<I', 0x000024AE) * 8 + struct.pack('<I',\n    0x00001C42) * 8 + struct.pack('<I', 0x00006D4C) * 8 \\\n+ struct.pack('<I', 0x0000754E) * 8 + struct.pack('<I', 0x0000449C) \\\n* 8 + struct.pack('<I', 0x000056A2) * 8 + struct.pack('<I',\n    0x00003EED) * 8 + struct.pack('<I', 0x0000106C) * 8 \\\n+ struct.pack('<I', 0x00000C7D) * 8 + struct.pack('<I', 0x0000578C) \\\n* 8 + struct.pack('<I', 0x000045CB) * 8 + struct.pack('<I',\n    0x0000253C) * 8 + struct.pack('<I', 0x00007F0F) * 8 \\\n+ struct.pack('<I', 0x00006513) * 8 + struct.pack('<I', 0x000004C0) \\\n* 8 + struct.pack('<I', 0x00006BFF) * 8 + struct.pack('<I',\n    0x0000711C) * 8 + struct.pack('<I', 0x00004829) * 8 \\\n+ struct.pack('<I', 0x00000B03) * 8 + struct.pack('<I', 0x000038E2) \\\n* 8 + struct.pack('<I', 0x000020AC) * 8 + struct.pack('<I',\n    0x00005708) * 8 + struct.pack('<I', 0x000064FA) * 8 \\\n+ struct.pack('<I', 0x00007984) * 8 + struct.pack('<I', 0x00004C79) \\\n* 8 + struct.pack('<I', 0x00007ED1) * 8 + struct.pack('<I',\n    0x00000F4F) * 8 + struct.pack('<I', 0x00002BB2) * 8 \\\n+ struct.pack('<I', 0x00005FA3) * 8 + struct.pack('<I', 0x00001073) \\\n* 8 + struct.pack('<I', 0x00002046) * 8 + struct.pack('<I',\n    0x00003175) * 8 + struct.pack('<I', 0x000005A5) * 8 \\\n+ struct.pack('<I', 0x000054CF) * 8 + struct.pack('<I', 0x00001B4E) \\\n* 8 + struct.pack('<I', 0x0000264E) * 8 + struct.pack('<I',\n    0x00003A88) * 8 + struct.pack('<I', 0x00002C1A) * 8 \\\n+ struct.pack('<I', 0x000022D6) * 8 + struct.pack('<I', 0x000019C0) \\\n* 8 + struct.pack('<I', 0x00002B57) * 8 + struct.pack('<I',\n    0x00003C82) * 8 + struct.pack('<I', 0x00007C61) * 8 \\\n+ struct.pack('<I', 0x0000530F) * 8 + struct.pack('<I', 0x00007AD2) \\\n* 8 + struct.pack('<I', 0x00007414) * 8 + struct.pack('<I',\n    0x00001ADD) * 8 + struct.pack('<I', 0xD6ADBCEF) * 8 \\\n+ struct.pack('<I', 0x00003E66) * 8 + struct.pack('<I', 0x000061DD) \\\n* 8 + struct.pack('<I', 0x00002330) * 8 + struct.pack('<I',\n    0xDEADBEEF) * 8 + struct.pack('<I', 0x0000475D) * 8 \\\n+ struct.pack('<I', 0x00002A4F) * 8 + struct.pack('<I', 0x00001F15) \\\n* 8 + struct.pack('<I', 0x00001162) * 8 + struct.pack('<I',\n    0xE3ADBEEF) * 8\n\nbuf = open(FILENAME, \"rb\").read()\nxbuf = xor_cipher(buf, key)\nopen(FILENAME + \".out\", \"wb\").write(xbuf)\n</code></pre>\nWalk-through\nLooking at the header of the firmware, we can make some guess (all values stored in Little-endian):\n<pre><code>Offset(h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n\n00000000  04 83 57 48 9C 3B 01 00 C8 CF 28 00 00 1E 2B 6A  .ƒWHœ;..ÈÏ(...+j\n00000010  47 00 0B 00 80 01 00 00 E4 CF 28 00 38 FE 28 00  G...€...äÏ(.8þ(.\n</code></pre>\n\n0x48578304 : Maybe a signature\n0x00013B9C : Almost the length of the firmware file length (originally 0x13C00)\n\nIf we look further in the firmware hexdump and assume we are dealing with a CORTEX device or something similar, at offset 0x20 we could think that there is a vector table:\n<pre><code>Offset(h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n\n00000020  CF 36 00 20 3E 1B 00 08 F2 D5 00 08 A4 D5 00 08  Ï6. >...òÕ..¤Õ..\n00000030  A2 D5 00 08 A0 D5 00 08 BE D5 00 08 EF 26 00 00  ¢Õ.. Õ..¾Õ..ï&..\n</code></pre>\n\n0x200036CF : Initial SP Value\n0x08001B3E : Reset Vector\n0x0800D5F2 : NMI Vector\n0x0800D5A4 : Hard Fault\n0x0800D5A2 : Memory Management Fault\n0x0800D5A0 : Bus Fault\n0x0800D5BE : Usage Fault\n0x000026EF : RESERVED\n0x0000565C : RESERVED\n0x0000565C : RESERVED\n0x0000565C : RESERVED\n\nHere we can notice few problems:\n\nWhy the Initial SP Value is not aligned? \nWhy the reserved vector are not NULL?\n\nAt this point, grepping the sequence of bytes <pre><code>EF 26 00 00</code></pre> end up in an interesting place:\n<pre><code>Offset(h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n\n00012000  E7 1A 00 00 E7 1A 00 00 E7 1A 00 00 E7 1A 00 00  ç...ç...ç...ç...\n00012010  E7 1A 00 00 E7 1A 00 00 E7 1A 00 00 E7 1A 00 00  ç...ç...ç...ç...\n00012020  EF 26 00 00 EF 26 00 00 EF 26 00 00 EF 26 00 00  ï&..ï&..ï&..ï&.. << 0x000026EF REPEATED 4 TIMES\n00012030  EF 26 00 00 EF 26 00 00 EF 26 00 00 EF 26 00 00  ï&..ï&..ï&..ï&.. << 0x000026EF REPEATED 4 TIMES\n00012040  5C 56 00 00 5C 56 00 00 5C 56 00 00 5C 56 00 00  \\V..\\V..\\V..\\V..\n00012050  5C 56 00 00 5C 56 00 00 5C 56 00 00 5C 56 00 00  \\V..\\V..\\V..\\V..\n00012060  09 11 00 00 09 11 00 00 09 11 00 00 09 11 00 00  ................\n00012070  09 11 00 00 09 11 00 00 09 11 00 00 09 11 00 00  ................\n00012080  18 56 00 00 18 56 00 00 18 56 00 00 18 56 00 00  .V...V...V...V..\n00012090  18 56 00 00 18 56 00 00 18 56 00 00 18 56 00 00  .V...V...V...V..\n</code></pre>\nWe can see that the value 0x000026EF is repeated 8 times, and we have the value 0x0000565C (the other reserved vector) repeated 8 times, and some others values are repeated too.\nThere is a big chance that we are inside some ZERO pages and it is a simple XOR cipher which is applied on the whole file.\nMaybe the XOR cipher key is in the following form:\n\nkey[0] repeated 8 times\nkey[1] repeated 8 times\nkey[2] repeated 8 times\n...\nkey[63] repeated 8 times\n\nBy looking at all the offset where are stored the value the 0x000026EF, we can compute the delta between them, we can make a guess that the key length is 0x800 bytes.\nHopefully we can find 3 version of the firmware on the internet:\n\nf553e034ba70138c270dac03e7dcda6f : <pre><code>HW718V38_20170216.firmware</code></pre>\n7440def1011f50749ff7f1ca8f7bcced : <pre><code>HW718V39_20170221.firmware</code></pre>\n0850c80192dcad7a0ce9a5446fb97f16 : <pre><code>HW718V40_20171008.firmware</code></pre>\n\nIn order to extract the full key, we split each firmware file in block of 0x800 bytes chuncks, and compute the number of occurence of every 0x04 bytes repeated every 0x20 bytes.\nWith this we are able to extract the full key, some adjustments were required using the previous method:\n\nkeys[34] = 0x2BB2\nkeys[38] = 0x3175\nkeys[54] = 0xD6ADBCEF             # 4 bytes key ... wat !?\nkeys[58] = 0xDEADBEEF             # 4 bytes key ... wat !?\nkeys[60] = 0x2A4F\nkeys[62] = 0x1162\nkeys[63] = 0xE3ADBEEF             # 4 bytes key ... wat !?\n\nThe last step is now to know the exact value for the loading address, by starting to disassemble the firmware with a processor ARM little-endian at a loading address 0x08000000 and file offset 0x20, we can find an interesting disassembly:\n<pre><code>ROM:0800B854                 LDR             R1, =0xE000ED08\nROM:0800B856                 LDR             R0, =0x8003C00\nROM:0800F458                 STR             R0, [R1]\n</code></pre>\n0xE000ED08 is the Vector Table Offset Register and the value 0x8003C00 is written inside it.\nNow we can reaload our firmware with an ARM processor in little-endian at the loading address 0x8003C00 and file offset 0x20 and we can start working on the reverse engineering.\n",
            "votes": "6",
            "user": "w4kfu",
            "time": "Oct 26, 2019 at 7:32",
            "is_accepted": true,
            "comments": []
        }
    ]
}