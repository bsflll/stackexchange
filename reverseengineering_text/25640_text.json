{
    "title": "Why can't you edit pseudo code?",
    "link": "https://reverseengineering.stackexchange.com/questions/25640/why-cant-you-edit-pseudo-code",
    "content": "Dabbler in re here, so potentially a stupid question...\nI know ida, binary ninja, and ghidra are really powerful at generating pseudo code.\nFrom everything I've read pseudo code can't be edited in realtime but can be edited as assembly, I was just wondering why you couldn't do a similar process to the one below?\n\ndecompile exe to fake code\n\nmake code template for compiling in c or c++\n\nload fake code into template\n\ncompile basic template and stop at assembly code generation\n\ncopy assembly from halfway compiled c++ exe\n\nauto replace halfway compiled code as assembly to ida assembly code\n\n\nAlternatively,\n\ndecompile exe to fake code\n\nmake code template for compiling in c or c++\n\nload fake code into template\n\ncompile basic template and stop at assembly code generation\n\nload the function into ida or such with pdb\n\ngenerate fake code for your template exe\n\ngo to the function and get the assembly from there to copy and replace\n\n\nI know this method wouldn't be fast... but I am surprised no one has tried a method like this as far as I'm aware? Am I just missing something obvious?\n",
    "votes": "3",
    "answers": 3,
    "views": "9k",
    "tags": [
        "ida",
        "ghidra"
    ],
    "user": "Spyindabox",
    "time": "Aug 13, 2020 at 13:33",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "Hi and welcome to RE.SE! IDA creates no pseudo-code. IDA is a pure disassembler. To get anything like pseudo-code you'll have to shell out twice the amount you pay for IDA itself for the Hex-Rays plugin (single architecture, for further architectures discounts apply) or you have to build and install something like the RetDec plugin.\n",
            "time": null
        },
        {
            "user": "Heath Mitchell",
            "text": "I'm working on this, which currently is just a proof of concept but shows that it's possible: reddit.com/r/ghidra/comments/sbqnwf/â€¦\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "From everything I've read pseudo code can't be edited in realtime but can be edited as assembly\n\nThis is not entirely correct. Quite the opposite even: Decompilers cannot be perfect (the compilation step looses too much information). Hence they need some help by a human (the reverse engineer). Giving this help is, at least in my opinion, the most important step during reverse engineering: get data types right. Sure, renaming variables helps a lot with readability, but the decompiler doesn't really need it. Changing the type of a variable or function though, feeds information back into the decompiler, which then can run another pass and improve the result. This result can then again further be improved by the human. If I would need to name the most important step during static binary reverse engineering, I would call out this cycle: decompile, re-type, repeat.\nNow that we got this out of the way, I'll try to address the suggested steps you propose: I am not entirely sure I understand what you mean but I think a huge problem arises in step 2/4:\n\nmake code template for compiling in c or c++\n\ncode generated by a decompiler is not really C/C++ code. Formally, it only qualifies as pseudo-code that has a C-like syntax. The differences between valid C and \"decompiler C\" depends on your decompiler of course (Hex-Rays, Binary Ninja, Ghidra), but to give a simple examples (there are more, many of which are far more serious): If Ghidra's decompiler is not sure what data type a given variable is, it will assign the \"type\" <pre><code>undefined</code></pre>. This is not a valid data type in C of course, and hence cannot be compiled into an executable (i.e. step 4 fails).\n",
            "votes": "8",
            "user": "0xC0000022L",
            "time": "Aug 10, 2020 at 9:07",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "@born brings up some great points, but I do think it's definitely worth saying there's not much inherently impossible about the whole idea. Compiling and grabbing assembly is likely not the best bet, though.\nPassing the entire thing off as impossible is just not right. IDA clearly has potential in the area; Select psuedocode and click \"Copy to Assembly\". It'll generate comments in the assembly that map it to where the psuedocode functions come from.\nHere's a comparison of the three different relevant phases of a program; source, psuedocode, and ASM:\nSource (<pre><code>clang -w -o test</code></pre>) :\n<pre><code>int main(void)\n{\n  printf(\"hello world\");\n}\n</code></pre>\nNote the incorrect, but functional, use of <pre><code>printf(\"string\")</code></pre> instead of <pre><code>printf(\"%s\", \"string\")</code></pre>. This is another debate, but it'll screw up decompilation\nDecompilation By IDA (psuedocode):\n<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  printf(\"hello world\", argv, envp);\n  return 0;\n}\n</code></pre>\nThis is just wrong. printf won't accept those values, it's expecting 0 extra arguments due to a lack of formatting \"%s\" strings in \"hello world\". A simple mistake has screwed up the psuedocode output.\nDisassembly by IDA (note some of these instructions might not be right)\n<pre><code>push    rbp\nmov     rbp, rsp\nsub     rsp, 10h\n; 2:   printf(\"hello world\", argv, envp);\nlea     rdi, aHelloWorld ; \"hello world\"\nmov     al, 0\ncall    _printf\n; 3:   return 0;\nxor     ecx, ecx\nmov     [rbp+var_4], eax\nmov     eax, ecx\nadd     rsp, 10h\npop     rbp\nretn\n</code></pre>\nLet's say you wanted to edit the string:\nSure, just edit the place it references. Oh, but you want one longer than 11 characters, so you'll need to find somewhere unused and map the string pointer to that address instead. That's complicated.\nThe entire executable section of the program is 12 instructions long, too. You have almost no space to change anything, and adding stuff is an entirely different ballgame.\nLikely Reasons it hasn't been done\n\nOne huge hangup is how unreliable psuedocode can be at times. Compare Hopper psuedocode to IDA/Ghidra's sometime for a great example. It's an educated guess, not a reliable one. Some don't even create variables, and trying to compile Hopper psuedocode is a waste of time.\nMost people needing to patch a binary want or need to patch the assembly. ASM works differently than C, and when you're patching, you need to be thinking more about how the assembly works than the C code that was used to create it.\nMost of the decompilers I know of are already fairly bad at patching assembly alone. An extremely basic hex editor does a much better job. IDA will give you a headache trying to patch more than 4 bytes\n\nI don't think it's anywhere near impossible though. Not by compiling for sure. But what you could try, is something like these:\n\nTrack how the decompiler was able to map <x assembly> to <y psuedocode>, and whenever <y psuedocode> is changed, create binary patches for the <x assembly> that created it.\n\nThis is arguably the \"best\" way to do it and will take a long time to write.\n\n\nReplace a function call with a branch to your own code elsewhere (assuming space can be found). \"Cheat Engine\" (it's been a while since I've used windows, sorry) had something like this if I remember correctly. Maybe use a compiler to generate that function, then.\n\nThis is the lazy way to do it, and might end up taking even more work making decompiler output compilable. Only IDA/Ghidra decompilation is close enough to be feasible. I've done this manually before.\n\n\n\nBoth of these require an understanding of assembly to verify the patches were correct; A wrong one will grind your program to a halt, and no tool doing this will be reliably correct.\n#2 still has flaws. I've spent 2+ hours perfecting decompilation/disassembly on a single function; everything in memory properly named, manually defined every struct, etc. Even with perfect decompilation, it still needs work to be compiled.\nMaybe you could do that work yourself in some complex script. This is a problem I'd recommend revisiting when you're experienced; it's a really interesting topic, and IDAPython might make it almost feasible.\n",
            "votes": "0",
            "user": "kat",
            "time": "Aug 13, 2020 at 9:18",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "for editing in every owning pseudo code do think psychology corelations of it and then you get the human meaning for those who didnt change indetity based on it\nonly for who didnt read\nbut if code is not accessible (no pseudo code) you can make a dictionary of character to binary and to its functions on the cpu that have high performance on java or python(slow)\n",
            "votes": "-6",
            "user": "Noam lima",
            "time": "Aug 10, 2020 at 20:03",
            "is_accepted": false,
            "comments": []
        }
    ]
}