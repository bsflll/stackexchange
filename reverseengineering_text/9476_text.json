{
    "title": "Reverse Engineering Firmware",
    "link": "https://reverseengineering.stackexchange.com/questions/9476/reverse-engineering-firmware",
    "content": "I have a HEX file with a firmware for Attiny45. What I want to do is to extract some kind of formula that is coded inside it. I have done some research (mostly to find out that \"it is not possible\", etc, etc) but I decided I could give it a try since other parts of my research showed me that most of the people that ask this type of question barely knows what a HEX file is.\nThe objective of this post is not to came up with a brightly C code from the HEX file but rather build solid knowledge about the subject. I'm aware that the compiler, doing its job, can make my own job harder but there is some kind of structure (maybe primitive) that needs to be followed for the CPU to be able to execute the code.\nSo, I sat on my desk and coded a little Python tool to help me in the process. It loads the HEX file, and I interactively can add information to it. Here is what I've got so far:\nThe first line of the HEX file, says:\n<pre><code>: 02 0000 04 0000 FA\n</code></pre>\nWhich was decoded by the tool to:\n<pre><code>:       --> MARK\n02      --> RECORD LENGTH\n0000    --> LOAD OFFSET\n04      --> RECORD TYPE (EXTENDED LINEAR ADDRESS RECORD)\n0000    --> DATA\nFA      --> CHECKSUM\n</code></pre>\nSeems that this line serves the propose of telling that the initial address on which code should be put is <pre><code>0x0000</code></pre>.\nSecond, the next line says:\n<pre><code>: 20 0000 00 34C0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF50C07EEE7EB9 51\n</code></pre>\nThe tool decoded it to:\n<pre><code>:    --> MARK\n20   --> LENGHT OF THE RECORD\n0000 --> OFFSET\n00   --> RECORD TYPE (00 -> DATA RECORD) 34C0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF50C07EEE7EB9 (ACTUAL DATA)\n51   --> CHECKSUM\n</code></pre>\nHere is where the fun and the questions starts.\n\nI could not find anywhere the memory map of the ATTiny45. I thought it should be somewhere in the data sheet or the instruction set manual. From what I could figure out, at <pre><code>0x0000</code></pre> lives the interrupt vector (page 49, data sheet) and the first one is the reset vector. So, AVR being little endian and instructions being 16bits-wide, I can decode that the reset vector contains the value <pre><code>0xC034</code></pre>. Using the instruction set, I figure out that <pre><code>0xC034</code></pre> is:\n<pre><code>rjump 0x034\n</code></pre>\nIs this correct?\nContinuing with this line of thinking, the same line pointed before shows that some of the interrupt vectors have values <pre><code>0xFFFF</code></pre>, which causes me surprise but does not seem to be a problem since probably these will be disabled. The only other vector that have a working value is <pre><code>USI_OVF_ISR</code></pre>, which is equal to <pre><code>0xC050</code></pre>. So, according to the ideas presented before, this says that <pre><code>USI_OVF_ISR</code></pre> has the instruction:\n<pre><code>rjump 0x050\n</code></pre>\nIs this also correct?\nIf the reset vector points to <pre><code>0x034</code></pre>, this says that the program will begin running at <pre><code>0x034</code></pre>. The next line\n<pre><code>: 20 0020 00 7FE77FB9B89A089570EE7EB95FB9B89A08957EEE7EB9B898089570EE7EB9B898 22\n</code></pre>\nShows that <pre><code>0x034</code></pre> is <pre><code>0xB898</code></pre> and that is the first instruction that will be executed.\nIs this correct?\n",
    "votes": "3",
    "answers": 1,
    "views": "830",
    "tags": [
        "firmware",
        "hex"
    ],
    "user": "daniel.franzini",
    "time": "Jul 28, 2015 at 12:46",
    "comments": [],
    "answers_data": [
        {
            "content": "Seems to be almost correct, since the data sheet says in chapter 8.1, Resetting the AVR:\n\nThe instruction placed at the Reset Vector must be a RJMP – Relative\n  Jump – instruction to the reset handling routine\n\nHowever, page 202 - instruction set summary - explains <pre><code>RJMP</code></pre> like this:\n<pre><code>RJMP    k    Relative Jump PC   PC + k  + 1        \n</code></pre>\nWhich would imply that <pre><code>RJMP</code></pre> at address <pre><code>PC=0</code></pre> with a <pre><code>k=0x34</code></pre> jumps to address <pre><code>0x35</code></pre>.\nUnfortunately, the data sheet doesn't seem to have an opcode table to confirtm that <pre><code>C0</code></pre> is indeed a <pre><code>RJMP</code></pre>.\nAlso, Chapter 5.1 says\n\nThe ATtiny25/45/85 contains \n  2/4/8K bytes On-chip In-System Reprogrammable Flash memory for program storage. Since all AVR instructions are 16 or 32 bits \n  wide, the Flash is organized as 1024/2048/4096 x 16.\n\nand Chapter 9 shows a table (page 48) that has examples of <pre><code>RJMP</code></pre> instructions which, though they need 2 bytes, are packed into one address each. Starting at offset 0, and with 15 reset vectors that are 16 bits wide each, the program starts at address <pre><code>0x0F</code></pre>. So the address space seems to be divided into 16-bit chunks per address, not 8-bit bytes, which would mean you have to double your addresses to get the appropriate byte index in your hex array.\nSeems incorrect to me, since PC is <pre><code>0D</code></pre> (at offset <pre><code>1A</code></pre> in your hex bytes) and <pre><code>r=50</code></pre>, so the <pre><code>RJMP</code></pre> should jump to <pre><code>0D+50+1</code></pre>=<pre><code>5E</code></pre>, or offset <pre><code>BC</code></pre> (<pre><code>2*0x5E</code></pre>) in your hex bytes.\nAccording to my assumption that addresses denote 16-bit words, and adding the <pre><code>+1</code></pre> from the opcode tab, you should probably look at <pre><code>0x35*2=0x6A</code></pre> to find the first instruction to be executed.\n",
            "votes": "2",
            "user": "Guntram Blohm",
            "time": "Jul 28, 2015 at 22:54",
            "is_accepted": false,
            "comments": []
        }
    ]
}