{
    "title": "Access to CPU registers in GMM space",
    "link": "https://reverseengineering.stackexchange.com/questions/31151/access-to-cpu-registers-in-gmm-space",
    "content": "AMD's BIOS and Kernel Developerâ€™s Guide (BKDG) documents GMM registers and access to them:\n\nGMMxXXXXX: GPU memory mapped registers; XXXXX specifies the hexadecimal byte address offset (this may be 2 to 5 digits) from the base address register; The base address for this space is specified by D1F0x18 [Graphics Memory Mapped Registers Base Address].\n\n<pre><code>D1F0x18</code></pre> has the following structure (I also add a column with values that I get):\n\n\n\n\nBits\nMy value\nDescription\n\n\n\n\n31:18\n0x3c08\nBaseAddr[31:18]: base address.\n\n\n17:16\n0\nBaseAddr[17:16]: base address.\n\n\n15:4\n0\nBaseAddr[15:4]: base address.\n\n\n3\n0\nprefetchable. 0=Non-prefetchable memory region.\n\n\n2:1\n0\nbase address register type. 00b=32-bit BAR. 10b=64-bit BAR.\n\n\n0\n0\nmemory space type. 0=Memory mapped base address.\n\n\n\n\nHow to properly access registers in the GMM space?\nThere are three base address fields in the <pre><code>D1F0x18</code></pre> register, and the guide doesn't explain any further how to compile the base address. I tried to read memory (in Linux with <pre><code>root</code></pre> privileges) at the following memory offsets, but all of them return me <pre><code>Segmentation fault</code></pre> error.\n<pre><code>printf(\"%02x\n\", (unsigned)*(unsigned char*)0x3c08); // Base address itself\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0x4378); // 0x3c08+0x770 (GMMx770)\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0x4381); // 0x3c08+0x770+3\n\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0x3c080000); // Base address appended with zeroes\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0x3c080770); // plus GMMx770 offset\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0x3c080773); // plus size of the GMMx770\n\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0xf0200000); // 0x3c08 shifted left by 2 bits (so that to align 31:18 field to 16 bits)\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0xf0200770); // plus GMMx770 offset\nprintf(\"%02x\n\", (unsigned)*(unsigned char*)0xf0200773); // plus size GMMx770 offset\n\n</code></pre>\nEdit\nThere is a source code of the Coreboot project available on the Internet. There are clear footprints that they implement access to the GMM space, but I couldn't extract the method from their code either. The code gives some clues:\n\nIt looks, like they use the base address as is, i.e. it is <pre><code>0x3c080000</code></pre> in my case.\nThey set bits 0 and 1 in <pre><code>D1F0x04</code></pre> so that apparently to enable access to the device's memory area (I have both of these bits set by default).\nThey read memory with <pre><code>__readfsdword</code></pre>. Because I am on GCC, I redefined this function as follows, but still get the <pre><code>Segmentation fault</code></pre>:\n\n<pre><code>unsigned long __readfsdword(const unsigned long Offset)\n{\n    unsigned long value;\n    __asm__ __volatile__(\"movl %%fs:%a[Offset], %k[value]\" : [value] \"=r\" (value) : [Offset] \"ir\" (Offset));\n    return value;\n}\n</code></pre>\n",
    "votes": "2",
    "answers": 0,
    "views": "57",
    "tags": [
        "firmware",
        "hardware",
        "register"
    ],
    "user": "Hweaker",
    "time": "Nov 20, 2022 at 4:07",
    "comments": [],
    "answers_data": []
}