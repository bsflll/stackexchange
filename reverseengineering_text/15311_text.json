{
    "title": "Running a binary identified as an ARM excutable by binwalk --disasm",
    "link": "https://reverseengineering.stackexchange.com/questions/15311/running-a-binary-identified-as-an-arm-excutable-by-binwalk-disasm",
    "content": "I have a Philips 10FF2 picture frame I'm trying to reverse engineer. In the firmware download from the Philips website (http://download.p4c.philips.com/files/1/10ff2cme_00/10ff2cme_00_fus_aen.zip) I can find a file called <pre><code>UBLDM350.bin</code></pre> which when analyzed with <pre><code>binwalk --disasm</code></pre> gives me:\n<pre><code>DECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n0             0x0             ARM executable code, 32-bit, little endian, at least 984 valid instructions\n</code></pre>\nMy question is how do I get more information on this file? I tried running it with qemu-arm but that fails:\n<pre><code>walterheck@walter-toshiba:~/projects/pictureframe/PHILIPS.10FF2M$ qemu-arm ./UBLDM350.BIN \nError while loading ./UBLDM350.BIN: Permission denied\n</code></pre>\nRunning <pre><code>strings</code></pre> on it gives me garbage and only a few readable things:\n<pre><code>(null)\n0123456789abcdef0123456789ABCDEF\n...fail(%d)\nNANDReadPage error(%d)\nError block(%d)\nMagic switch failure(0x%X)\nBad block found(block=%d)\nMove done.\nStart boot from NAND\nVer = %s\nUBLN1.05\n</code></pre>\nI'm looking for help on what to try next.\n",
    "votes": "6",
    "answers": 3,
    "views": "5k",
    "tags": [
        "binary-analysis",
        "firmware",
        "arm"
    ],
    "user": "Walter Heck",
    "time": "May 7, 2017 at 14:47",
    "comments": [],
    "answers_data": [
        {
            "content": "Obstacles\nOne of the difficulties associated with analyzing firmware is that firmware binaries do not usually have a standard format and do not segregate code and data in a standard manner like ELF or PE binaries do. The absence of clearly identifiable partitions within firmware binaries that allow for fast and accurate identification and differentiation between code and data is problematic for disassembly, since a disassembler such as Capstone (which is used to identify  to identify the CPU architecture by <pre><code>binwalk</code></pre> when the <pre><code>--disasm</code></pre> argument is used) or Radare2 will disassemble data (such as ASCII strings) as opcodes and operands.\nIt appears that this is the case with <pre><code>UBLDM350.BIN</code></pre>. If <pre><code>binwalk -A</code></pre> is executed, we see that ARM code is detected fairly uniformly from offset 0x130 to offset 0x4224, a range of 16628 bytes:\n<pre><code>$ binwalk -A UBLDM350.BIN\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n304           0x130           ARM instructions, function prologue\n792           0x318           ARM instructions, function prologue\n1396          0x574           ARM instructions, function prologue\n8008          0x1F48          ARM instructions, function prologue\n9380          0x24A4          ARM instructions, function prologue\n9880          0x2698          ARM instructions, function prologue\n9908          0x26B4          ARM instructions, function prologue\n10024         0x2728          ARM instructions, function prologue\n10320         0x2850          ARM instructions, function prologue\n13036         0x32EC          ARM instructions, function prologue\n13080         0x3318          ARM instructions, function prologue\n13196         0x338C          ARM instructions, function prologue\n13548         0x34EC          ARM instructions, function prologue\n15912         0x3E28          ARM instructions, function prologue\n16872         0x41E8          ARM instructions, function prologue\n16932         0x4224          ARM instructions, function prologue\n</code></pre>\nHowever, when <pre><code>binwalk --disasm --verbose</code></pre> is run to print the disassembled instructions, the memory address range of the disassembled code is much less than this (<pre><code>0x00</code></pre> to <pre><code>0xF5C</code></pre> = 3932 bytes):\n<pre><code>$ binwalk --disasm --verbose UBLDM350.BIN\n\nScan Time:     2017-05-07 10:56:43\nTarget File:   /home/c/firmware/Philips/10FF2cme_pictureframe/PHILIPS.10FF2M/UBLDM350/UBLDM350.BIN\nMD5 Checksum:  15b2dac3ce98d3308d9c6cf47e74eba7\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n0             0x0             ARM executable code, 32-bit, little endian, at least 984 valid instructions\n0             0x0             ldr r0, [pc, #0x124]\n4             0x4             mcr p15, #0, r0, c9, c1, #0\n8             0x8             mov r0, r0\n12            0xC             mrs r0, apsr\n16            0x10            bic r0, r0, #0x1f\n20            0x14            orr r0, r0, #0x11\n24            0x18            msr cpsr_fc, r0\n28            0x1C            ldr sp, [pc, #0xf4]\n32            0x20            ldr r0, [pc, #0xf4]\n36            0x24            add sp, sp, r0\n40            0x28            mrs r0, apsr\n\n< snip >\n\n3888          0xF30           lsl ip, ip, #0x16\n3892          0xF34           lsr ip, ip, #0x16\n3896          0xF38           strh ip, [sp, #0x16]\n3900          0xF3C           ldrh ip, [sp, #0x14]\n3904          0xF40           ldr r0, [sp, #4]\n3908          0xF44           ldrb r1, [ip, r0]\n3912          0xF48           ldrb r2, [sp, #0x16]\n3916          0xF4C           eor r1, r2, r1\n3920          0xF50           strb r1, [ip, r0]\n3924          0xF54           mov r0, #0\n3928          0xF58           add sp, sp, #0x1c\n3932          0xF5C           bx lr\n</code></pre>\nWhy is this? A broken instruction causes Capstone to cease disassembly following offset <pre><code>0xF5C</code></pre>:\n\nBy default, Capstone stops disassembling when it encounters a broken instruction. Most of the time, the reason is that this is data mixed inside the input, and it is understandable that Capstone does not understand this \"weird\" code.\nTypically, you are recommended to dertermine yourself where the next code is, and then continue disassembling from that place.1\n\n\nAbove we see that there are indeed invalid instructions following the instruction at offset <pre><code>0xF5C</code></pre>.\nSome of the following data is disassembled as code:\n<pre><code>00001ba0  bf f9 0a 1c 02 e0 d3 17  02 f0 92 fc 19 1c 10 1c  |................|\n00001bb0  70 bc 04 bc 10 47 c0 46  30 31 32 33 34 35 36 37  |p....G.F01234567|\n00001bc0  38 39 61 62 63 64 65 66  30 31 32 33 34 35 36 37  |89abcdef01234567|\n00001bd0  38 39 41 42 43 44 45 46  00 00 00 00 04 d0 4d e2  |89ABCDEF......M.|\n00001be0  00 c0 a0 e3 00 c0 8d e5  00 c0 9d e5 2a 00 5c e3  |............*.\\.|\n</code></pre>\n\nDirect execution of the binary likely fails due to the fact that there is no header that provides the kernel program loader the information required to create a process image in memory, such as the entry point and binary layout information.\nOptions\n1. Unicorn\nAn option for further investigation could be using the Unicorn engine to dynamically analyze successfully disassembled code. See this Q&A for more information:\nUnicorn and QEMU: Example use cases to understand the differences\n2. Device processor identification\nIf you have direct access to the hardware, it may prove useful to identify the exact processor/microcontroller, since this will allow you to locate the technical reference manual and datasheet, which will describe in detail the memory layout and instruction set architecture of the device. Knowledge of memory layout will aid in the analysis of the firmware binary.\n3. Hex dump analysis\nAnalysis of a hex dump may allow you to manually identify non-code portions of the firmware. Portions with code only can be sliced out and disassembled by Capstone, r2, or some other disassembler.\n4. Visualization\nVisualization of the firmware binary using <pre><code>binwalk -E</code></pre> can give an insight into the overall structure of the binary. An entropy plot allows for fast identification of compressed or regions of contiguous null bytes. binvis.io is a useful source for binary visualization as well.\nSee also:\nApproach to extract useful information from binary file\n\n1. SKIPDATA mode\n",
            "votes": "7",
            "user": "julian",
            "time": "May 7, 2017 at 18:17",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Walter Heck",
                    "text": "<span class=\"comment-copy\">Took me a while to get back to this project. I'm fiddling around with some of your suggestions now. As for option 2: I do indeed have access to the hardware itself. The central chip seems to be a DMSoc from TI identified by TMS320DM350ZWK. This seems to have been released later as TMS320DM355, of which a datasheet is here: <a href=\"http://www.ti.com/lit/ds/symlink/tms320dm355.pdf\" rel=\"nofollow noreferrer\">ti.com/lit/ds/symlink/tms320dm355.pdf</a>.</span>",
                    "time": null
                },
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">@WalterHeck according to the data sheet, the device uses an <a href=\"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0198e/Cacheeja.html\" rel=\"nofollow noreferrer\">ARM926EJ-S processor</a></span>",
                    "time": null
                }
            ]
        },
        {
            "content": "To add to SYS_V's good answer, this 'weird' mixing of code and data is actually very common with ARM code.\nARM instructions are fixed sizes (4 bytes on ARM, 2 bytes for THUMB) and have insufficient space to encode an 32 bit immediate value.  Instead, ARM compilers usually do two things -\n\nthey place 32 bit immediate constants straight after the instructions for the function in which the constants are needed, and\nthey use PC-relative load instructions in the function to put these constants into registers.\n\nIn SYS_V's disassembly, the instructions at addresses <pre><code>0x00000F08</code></pre> and <pre><code>0x00000F28</code></pre> are both PC relative loads. (Though the disassembler is being helpful here and displaying the calculated addresses <pre><code>0x00000FF8</code></pre> and <pre><code>0x00000FFC</code></pre> rather than showing <pre><code>[PC,offset]</code></pre>.)\nThe disassembler is further being helpful and annotating the disassembly in red at the side showing the values of the immediate constants that will be loaded.  In this case the values loaded are <pre><code>0x01E100D4</code></pre> and <pre><code>0x01E100DC</code></pre> respectively.\nIt's usual to see the immediate constants stored after the function in order of the addresses of the functions that access them.  So, in this case, the function ends with the instruction at <pre><code>0x00000F5C</code></pre> and the immediate constants would appear to span the address range <pre><code>0x00000F60</code></pre> to <pre><code>0x00000FFF</code></pre> and I would usually expect the following function to begin at address <pre><code>0x00001000</code></pre>.\nKnowing this it would be possible for a disassembler to identify this pattern and automatically skip the associated data.\n",
            "votes": "4",
            "user": "Ian Cook",
            "time": "May 8, 2017 at 6:53",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "It seems you have a raw firmware file and not a user-mode executable. <pre><code>qemu-arm</code></pre> only supports user-mode ARM Linux ELF executables. You could in theory try the full-system emulator (<pre><code>qemu-system-arm</code></pre>), but don't expect it to work unless QEMU explicitly supports the underlying hardware. It may be also possible to use the QEMU-based Unicorn emulator which is somewhat more flexible but you would need to write some code to load your file and start emulation; there's no convenient ready to use program.\n",
            "votes": "3",
            "user": "Igor Skochinsky",
            "time": "May 8, 2017 at 8:12",
            "is_accepted": false,
            "comments": []
        }
    ]
}