{
    "title": "How to simplify a function \"calling itself's reference\"",
    "link": "https://reverseengineering.stackexchange.com/questions/26862/how-to-simplify-a-function-calling-itselfs-reference",
    "content": "I encounter often a function calling itself (in the pseudo code) such as:\n<pre><code>result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))lambda)(lambda);\n</code></pre>\n\nSince the disassembly is <pre><code>call qword ptr [rax]</code></pre>, can't this be simplified into <pre><code>result = lambda();</code></pre> if I translate the pseudo code in c ?\nWhy in the pseudo code the function is having itself as argument ?\nWhat is happening when there is a call such as <pre><code>lambda + 8i64</code></pre> ?\n\nHere a more complete context:\n<pre><code>__int64 __fastcall CR_maybeParseWithLambda(_QWORD *a1, __int64 newPtr, __int64 positionOrCounter)\n{\n  volatile signed __int32 *lambda; // rdi\n  __int64 result; // rax\n\n  lambda = (volatile signed __int32 *)a1[1];\n  if ( lambda )\n  {\n    result = (unsigned int)_InterlockedExchangeAdd(lambda + 2, 0xFFFFFFFF);\n    if ( (_DWORD)result == 1 )\n    {\n      result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))lambda)(lambda);\n      if ( _InterlockedExchangeAdd(lambda + 3, 0xFFFFFFFF) == 1 )\n        result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)lambda + 8i64))(lambda);\n      a1[1] = positionOrCounter;\n      *a1 = newPtr;\n    }\n    else\n    {\n      a1[1] = positionOrCounter;\n      *a1 = newPtr;\n    }\n  }\n  else\n  {\n    a1[1] = positionOrCounter;\n    *a1 = newPtr;\n  }\n  return result;\n}\n</code></pre>\nThe disassembly:\n<pre><code>.text:0000000180005F70 ; __int64 __fastcall CR_maybeParseWithLambda(_QWORD *a1, __int64 newPtr, __int64 positionOrCounter)\n.text:0000000180005F70 CR_maybeParseWithLambda proc near       ; CODE XREF: sub_180005B10+10F↑p\n.text:0000000180005F70                                         ; sub_180005B10+14A↑p ...\n.text:0000000180005F70\n.text:0000000180005F70 arg_0           = qword ptr  8\n.text:0000000180005F70 arg_8           = qword ptr  10h\n.text:0000000180005F70 arg_10          = qword ptr  18h\n.text:0000000180005F70 arg_18          = qword ptr  20h\n.text:0000000180005F70\n.text:0000000180005F70                 mov     [rsp+arg_8], rbx\n.text:0000000180005F75                 mov     [rsp+arg_10], rbp\n.text:0000000180005F7A                 mov     [rsp+arg_18], rsi\n.text:0000000180005F7F                 push    rdi\n.text:0000000180005F80                 sub     rsp, 20h\n.text:0000000180005F84                 mov     rdi, [rcx+8]\n.text:0000000180005F88                 mov     rsi, r8\n.text:0000000180005F8B                 mov     rbp, rdx\n.text:0000000180005F8E                 mov     rbx, rcx\n.text:0000000180005F91                 test    rdi, rdi\n.text:0000000180005F94                 jz      short loc_180005FF3\n.text:0000000180005F96\n.text:0000000180005F96 loc_180005F96:                          ; DATA XREF: .rdata:0000000180401E74↓o\n.text:0000000180005F96                                         ; .rdata:0000000180401E84↓o ...\n.text:0000000180005F96                 mov     [rsp+28h+arg_0], r14\n.text:0000000180005F9B                 or      r14d, 0FFFFFFFFh\n.text:0000000180005F9F                 mov     eax, r14d\n.text:0000000180005FA2                 lock xadd [rdi+8], eax\n.text:0000000180005FA7                 cmp     eax, 1\n.text:0000000180005FAA                 jnz     short loc_180005FEA\n.text:0000000180005FAC                 mov     rax, [rdi]\n.text:0000000180005FAF                 mov     rcx, rdi\n.text:0000000180005FB2                 call    qword ptr [rax]\n.text:0000000180005FB4                 lock xadd [rdi+0Ch], r14d\n.text:0000000180005FBA                 cmp     r14d, 1\n.text:0000000180005FBE                 jnz     short loc_180005FC9\n.text:0000000180005FC0                 mov     rax, [rdi]\n.text:0000000180005FC3                 mov     rcx, rdi\n.text:0000000180005FC6                 call    qword ptr [rax+8]\n.text:0000000180005FC9\n.text:0000000180005FC9 loc_180005FC9:                          ; CODE XREF: CR_maybeParseWithLambda+4E↑j\n.text:0000000180005FC9                 mov     [rbx+8], rsi\n.text:0000000180005FCD                 mov     [rbx], rbp\n.text:0000000180005FD0\n.text:0000000180005FD0 loc_180005FD0:                          ; CODE XREF: CR_maybeParseWithLambda+81↓j\n.text:0000000180005FD0                 mov     r14, [rsp+28h+arg_0]\n.text:0000000180005FD5\n.text:0000000180005FD5 loc_180005FD5:                          ; CODE XREF: CR_maybeParseWithLambda+8A↓j\n.text:0000000180005FD5                                         ; DATA XREF: .pdata:0000000180483888↓o ...\n.text:0000000180005FD5                 mov     rbx, [rsp+28h+arg_8]\n.text:0000000180005FDA                 mov     rbp, [rsp+28h+arg_10]\n.text:0000000180005FDF                 mov     rsi, [rsp+28h+arg_18]\n.text:0000000180005FE4                 add     rsp, 20h\n.text:0000000180005FE8                 pop     rdi\n.text:0000000180005FE9                 retn\n</code></pre>\n",
    "votes": "0",
    "answers": 1,
    "views": "159",
    "tags": [
        "ida",
        "disassembly",
        "assembly",
        "c",
        "static-analysis"
    ],
    "user": "Soleil",
    "time": "Jan 24, 2021 at 22:54",
    "comments": [],
    "answers_data": [
        {
            "content": "It's not calling itself; you're overlooking the <pre><code>*</code></pre> dereferences at the beginning of the call expression. As in:\n<pre><code>result = (**(__int64 (__fastcall ***)(volatile signed __int32 *))lambda)(lambda);</code></pre>\nNotice the two <pre><code>**</code></pre> inside of the first parenthesis? It's dereferencing the address held in the variable named <pre><code>lambda</code></pre>, which the assembly makes clear:\n<pre><code>.text:0000000180005FAC    mov     rax, [rdi]      ; dereference #1\n.text:0000000180005FAF    mov     rcx, rdi\n.text:0000000180005FB2    call    qword ptr [rax] ; dereference #2\n</code></pre>\nThis is a call to a virtual function. <pre><code>#1</code></pre> loads the VTable pointer out of the object; <pre><code>#2</code></pre> calls the function pointer at <pre><code>+0</code></pre> into the VTable.\nIn general, this is always going to look nasty in the decompilation before you have created a structure type for <pre><code>lambda</code></pre>, and a second type for its VTable. Once you do that, it will show you something pretty like this (taken from my ComRAT IDB):\n<pre><code>if ( v9 )\n{\n  if ( !_InterlockedDecrement(&v9->_Uses) )\n  {\n    v9->_Destroy(v9);\n    if ( !_InterlockedDecrement(&v9->_Weaks) )\n      v9->_Delete_this(v9);\n  }\n}\n</code></pre>\n",
            "votes": "3",
            "user": "Rolf Rolles",
            "time": "Jan 25, 2021 at 8:57",
            "is_accepted": false,
            "comments": []
        }
    ]
}