{
    "title": "How to reverse engineer a USB sump pump controller that is not designed to connect to a computer",
    "link": "https://reverseengineering.stackexchange.com/questions/32218/how-to-reverse-engineer-a-usb-sump-pump-controller-that-is-not-designed-to-conne",
    "content": "I have a sump pump monitor / controller that is USB-enabled. The USB port on the side is designed to hook to a WiFi module or a once-promised, now-canceled, never-produced Z-wave module (which is what I wanted to purchase, but alas, cannot). I do not want to use the WiFi module, because it requires their cloud service, and I keep my IoT network blocked from internet access. So, instead, I'd like to connect a Raspberry Pi to its USB port in order to monitor the pump's status.\nThis device was not designed to connect to a computer. There are no drivers for it for any OS, at least none that are publicly available. I have at my disposal MacbookPros (running macOS 10.15), Raspberry Pis, Parallels Desktop Windows VMs, and VirtualBox Ubuntu and RHEL VMs. I can buy the WiFi module if I have to, but I'd prefer not to spend $150 on something I'm going to toss in the bin.\nHow do I go about reverse-engineering the protocol this uses to connect to the WiFi and now-canceled Z-wave modules so that I can write my own monitoring software to run on an RPi?\nEDIT based on comments:\nTook it apart and took a couple photos of the circuit board. Apologies, I should have known to do this in the first place. Now, I'm far from a circuit board expert, but I don't think there's any software on this thing. I count no ROM chips, one IC, a couple of resistor packs, a couple heat-sinked transistors, three relays, a handful of capacitors, resistors, and transistors, and what appears to be a very simple, dumb 1200-8-N-1 serial data interface presented as a USB port. I don't think this thing is a USB host. I think it's a device. (There is nothing on the backside of the board except six LEDs and a momentary switch.)\nFull circuit board\n\nUSB connection to board\n\nEDIT 2: Not actually USB?\nI need to put an oscilloscope on this, I think (which means getting one), but I no longer believe it's even USB. I think they're just using USB connectors and cables because they're cheap, readily available, and better-understood in the 2010s+, than serial cables. But I'm fairly certain they're just implementing plain ole' RS232 over these USB connectors and cables. And, if I'm correct, then the pump controller board pictured above only transmits data and cannot receive any data.\nEDIT 3: Captured some serial data, but cannot yet interpret\nHaving confirmed that the output must be RS232 serial and not, actually, USB, I set out to capturing and interpreting it, neither of which has been an easy task.\nThe first step was getting the right cable or, rather, making the right cable. Essentially, I needed to first convert the pump output to a serial port, but I couldn't use a USB-to-serial adapter for that. Those adapters are meant to plug into a USB-A host port on a computer and present a serial port that other devices can be plugged into. Such an adapter expects the USB side to be an actual USB port, which this was not. So, instead, I had to make a serial-USB-plug-to-serial-DB9-female adapter cable by myself. After some experimentation with a multimeter, I determined that the USB black (common) wire needed to connect to the serial yellow (ground, pin 5) wire and that the USB green (data+) wire needed to connect to the serial brown (transmit, pin 2) wire. The USB white (data-) wire was not used, and the USB red (5V+) wire was energized, but was not needed for the serial jack. All unused wires were individually heat shrunk on the ends and then the aforementioned wires soldered and heat shrunk together. This resulted in the following cable (testing working before soldering and heat shrinking):\n\n\nNext, I connected the female DB9 to the male DB9 of the Cable Matters USB-C-to-serial adapter 201060-3 and then plugged that into my MacBook Pro running macOS 13.5. Using a fantastic macOS app called Serial, I was able to confirm that this cable worked with the pump controller when configured in 1200-8-N-1 mode, and that I received 12 bytes every ~1 second from the controller. Furthermore, I could confirm that the bytes were relatively stable but changed when I did things like trigger the pump, unplug the controller to rely on battery power, silenced alarms, etc. However, I needed something more advanced for analyzing this data, and for that, I first I had to install the Prolific Driver in order to expose the port at <pre><code>/dev/tty.PL2303G-USBtoUART1410</code></pre>.\nMy plan was to continuously log data while also triggering events/states of the controller to see how the data changed, so I wrote this Python program to do that. The following states/events can happen on the controller, and I expect at least some of these to affect the serial output:\n\nBattery is charging\nBattery is not charging\nAC power is on\nAC power is off\nPump has been triggered / is running\nPump has stopped / is not running\nFuse removed/blown\nFuse replaced\nBattery disconnected\nBattery re-connected\nAn alarm condition has been temporarily silenced\nAn alarm condition has been reset\nThe test/reset button has been pressed to test the pump during no alarm condition\n\nThe approach I thought wisest was to capture baseline data without any events / abnormal state to use as a baseline.\nThis was the first batch of baseline data I captured (a 3-minute capture). The bytes were consistently <pre><code>00 67 66 66 63 fb ab bf 9f 9f eb e5</code></pre> for 67 seconds before fluctuating between that and <pre><code>00 67 66 66 ec fb ab bf 9f 9f eb e5</code></pre> for a few seconds before settling on the latter for the remaining 2 minutes. My first instinct was that the two bytes that changed and/or the immediately-adjacent bytes represented the battery voltage (it's a 12-volt deep cycle AGM battery), but I couldn't figure out how that was encoded, if that was the case.\nI then got sidetracked for a few days and it just sat there. I came back today to collect more data. I collected five minutes of baseline data without any events, and this time the data did not change a single time but also was a bit different from the first collection: <pre><code>00 67 b3 ac ec fb ab bf 9f 9f eb e5</code></pre>.\nSo it seems that bytes 0 and 1 (<pre><code>00 67</code></pre>) are either a header or only change with state changes and that bytes 5-11 (<pre><code>fb ab bf 9f 9f eb e5</code></pre>) also only change with state changes (with perhaps 11 or 10-11 being footer bytes). This again makes me wonder if bytes 2-4 are somehow an encoded battery voltage.\nNext I collected five minutes of data with some state changes, and here is the raw data with integer arrays for each packet. Notable moments:\n<pre><code>...\n3.808    STATE   00 67 b3 ac ec fb ab bf 9f 9f eb e5 (00000000 01100111 10110011 10101100 11101100 11111011 10101011 10111111 10011111 10011111 11101011 11100101)\n4.823    STATE   00 67 b3 ac ec fb ab bf 9f 9f eb e5 (00000000 01100111 10110011 10101100 11101100 11111011 10101011 10111111 10011111 10011111 11101011 11100101)\n5.784    EVENT   AC power off\n5.838    STATE   00 67 b3 ac ec fb ab bf 9b 9f eb e5 (00000000 01100111 10110011 10101100 11101100 11111011 10101011 10111111 10011011 10011111 11101011 11100101)\n6.853    STATE   00 67 b3 ac ec fb ab bf 9b 9f eb e5 (00000000 01100111 10110011 10101100 11101100 11111011 10101011 10111111 10011011 10011111 11101011 11100101)\n...\n41.353    STATE   00 67 b3 ec ec fb ab bf 9b 9f eb e5 (00000000 01100111 10110011 11101100 11101100 11111011 10101011 10111111 10011011 10011111 11101011 11100101)\n42.368    STATE   00 67 b3 ec ec fb ab bf 9b 9f eb e5 (00000000 01100111 10110011 11101100 11101100 11111011 10101011 10111111 10011011 10011111 11101011 11100101)\n42.470    EVENT   AC power on\n43.383    STATE   00 67 b3 ec ec fb ab bf 9f 9f eb e5 (00000000 01100111 10110011 11101100 11101100 11111011 10101011 10111111 10011111 10011111 11101011 11100101)\n44.398    STATE   00 67 b3 ec ec fb ab bf 9f 9f eb e5 (00000000 01100111 10110011 11101100 11101100 11111011 10101011 10111111 10011111 10011111 11101011 11100101)\n...\n55.563    STATE   00 67 b3 ac ec fb ab bf 9f 9f eb e5 (00000000 01100111 10110011 10101100 11101100 11111011 10101011 10111111 10011111 10011111 11101011 11100101)\n56.578    STATE   00 67 b3 ec ec fb ab bf 9f 9f eb e5 (00000000 01100111 10110011 11101100 11101100 11111011 10101011 10111111 10011111 10011111 11101011 11100101)\n57.593    STATE   00 67 b3 ac ec fb ab bf 9f 9f eb e5 (00000000 01100111 10110011 10101100 11101100 11111011 10101011 10111111 10011111 10011111 11101011 11100101)\n58.608    STATE   00 67 b3 ec ec fb ab bf 9f 9f eb e5 (00000000 01100111 10110011 11101100 11101100 11111011 10101011 10111111 10011111 10011111 11101011 11100101)\n59.623    STATE   00 67 b3 ac ec fb ab bf 9f 9f eb e5 (00000000 01100111 10110011 10101100 11101100 11111011 10101011 10111111 10011111 10011111 11101011 11100101)\n...\n188.537    STATE   00 67 b3 ec f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 11101100 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n188.568    EVENT   pump turned on\n189.552    STATE   00 67 b3 6c f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 01101100 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n190.567    STATE   00 67 b3 6c f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 01101100 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n191.582    STATE   00 67 b3 ec f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 11101100 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n192.597    STATE   00 67 b3 ec f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 11101100 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n193.612    STATE   00 67 b3 f6 bf bf 9b bf 9f 9d eb e5 (00000000 01100111 10110011 11110110 10111111 10111111 10011011 10111111 10011111 10011101 11101011 11100101)\n194.627    STATE   00 67 b3 16 f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 00010110 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n...\n201.732    STATE   00 67 b3 56 f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 01010110 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n...\n207.826    STATE   00 67 b3 96 f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 10010110 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n...\n213.917    STATE   00 67 b3 d6 f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 11010110 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n...\n220.009    STATE   00 67 b3 f6 f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 11110110 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n220.296    EVENT   pump turned off\n221.024    STATE   00 67 b3 2c f6 fb db bf 9f 9d eb e5 (00000000 01100111 10110011 00101100 11110110 11111011 11011011 10111111 10011111 10011101 11101011 11100101)\n222.039    STATE   00 67 b3 ac ec fb cb bf 9f 9d eb e5 (00000000 01100111 10110011 10101100 11101100 11111011 11001011 10111111 10011111 10011101 11101011 11100101)\n223.054    STATE   00 67 b3 6c f6 fb cb bf 9f 9d eb e5 (00000000 01100111 10110011 01101100 11110110 11111011 11001011 10111111 10011111 10011101 11101011 11100101)\n... [many different bytes] ...\n237.267    STATE   00 67 b3 ec ec fb cb bf 9f 9d eb e5 (00000000 01100111 10110011 11101100 11101100 11111011 11001011 10111111 10011111 10011101 11101011 11100101)\n238.282    STATE   00 67 b3 56 f6 fb db bf 9f 9f eb e5 (00000000 01100111 10110011 01010110 11110110 11111011 11011011 10111111 10011111 10011111 11101011 11100101)\n238.302    EVENT   reset pressed\n239.297    STATE   00 67 b3 56 f6 fb db bf 9f 9f eb e5 (00000000 01100111 10110011 01010110 11110110 11111011 11011011 10111111 10011111 10011111 11101011 11100101)\n240.312    STATE   00 67 b3 96 f6 fb db bf 9f 9f eb e5 (00000000 01100111 10110011 10010110 11110110 11111011 11011011 10111111 10011111 10011111 11101011 11100101)\n241.328    STATE   00 67 b3 6c f6 fb db bf 9f 9f eb e5 (00000000 01100111 10110011 01101100 11110110 11111011 11011011 10111111 10011111 10011111 11101011 11100101)\n... [many different bytes, during which the battery charging light remained on] ...\n</code></pre>\nByte 8 appears to be <pre><code>9f</code></pre> when AC power is on and <pre><code>9b</code></pre> when it is off and was not affected by the pump running. Byte 9 was <pre><code>9f</code></pre> until the pump turned on and then changed to <pre><code>9d</code></pre> when it turned on. But it remained <pre><code>9d</code></pre> after the pump turned off until I pressed the reset button to clear the pump-activated alarm, at which point it reverted to <pre><code>9f</code></pre>. Byte 7 remained <pre><code>bf</code></pre> the entire time. Once the pump activated, bytes 2-6 underwent several changes up until I exited the session. So maybe these five bytes are somehow the battery voltage?\nWill do more capturing and come back with more analysis.\nEDIT 4: More data capturing\nThis time I messed with the fuse and battery backup in another capture session (raw data). Note that, when I started this session, the battery-charging LED was still illuminated.\nRemoving the fuse triggered a couple interesting changes. On the unit, the fuse LED and the battery LED illuminated (which I think explains two flags' changing as detailed below). In addition to bytes 2-6 continuing to change (probably because the battery is charging), this is the first time byte 1 has changed since I started this endeavor (so it is not a header byte, but byte 0 <pre><code>00</code></pre> almost certainly is), and it went through several values (so it is not a flag). Byte 8 changed from <pre><code>9f</code></pre> to <pre><code>97</code></pre> (previously it changed from <pre><code>9f</code></pre> to <pre><code>9b</code></pre> and back when AC power was cycled on and then off), so this is probably bitwise flag of some type. Also, byte 9 changed from <pre><code>9f</code></pre> to <pre><code>8f</code></pre> (previously it changed to <pre><code>9d</code></pre> when the pump turned on and remained <pre><code>9d</code></pre> until reset). These two bytes remained <pre><code>97</code></pre> and <pre><code>8f</code></pre> after the fuse was replaced and until reset was pressed, at which point they reverted to <pre><code>9f 9f</code></pre>. I should be able to look at these in binary and figure out what bits are what. Byte 1 went back to <pre><code>67</code></pre> after the fuse was replaced, before reset was pressed.\nWhen I disconnected the battery cable, things got interesting again. Only the battery LED illuminated. Byte 1 started changing again. Bytes 8 and 9 (again with two flags changing) changed from <pre><code>9f 9f</code></pre> to <pre><code>95 8f</code></pre> and remained that way until the battery was reconnected, then they changed to <pre><code>97 8f</code></pre> and remained that way until I pressed reset, then back to <pre><code>9f 9f</code></pre> (I ended the capture session prematurely). So bytes 8 and 9 are some combination of flags about the instantaneous state of certain objects as well as the the state of latched alarms. Should be fun to figure out...\nEDIT 5: More analysis\nAfter analyzing the above data and some more capturing (I'll detail here if asked, I've determined the following (byte:bit where byte is 0-based left-to-right and bit is 0-based right-to-left):\n\n0 is always <pre><code>0x00</code></pre> no matter what I do\n7 is always <pre><code>0xbf</code></pre> no matter what I do\n8:1 indicates whether the battery water level sensor is connected/good (1) or disconnected/low (0) ... resetting silences the beeping alarm but does not affect this or any other bits ... reconnecting the sensor immediately restores this bit without a reset ... on an AGM battery, this sensor is merely hooked to the battery + terminal and isn't really useful except as described in two bullet points ... when 0, the water level sensor LED is illuminated\n8:2 indicates whether the AC power is on (1) or off (0) ... resetting silences the beeping alarm but does not affect this or any other bits ... restoring AC power immediately restores this bit without a reset ... the AC power LED reflects the state of this bit\n8:3 indicates whether the fuse is installed/good (1) or removed/blown (0) ... resetting does not silence the continuous alarm but does reset the bit to 1 for exactly one packet, then the bit goes back to 0 ... reinstalling the fuse ends the continuous alarm and triggers a beeping alarm but does not restore the bit until reset is pressed ... when 0, both the battery LED and the fuse LED are illuminated until reset\n8:3 + 8:1 both flipping to 0 indicates that the battery has been disconnected, and follows the same alarm and resetting rule as above ... this probably wouldn't work to determine this if the battery was not AGM and the battery water level sensor was actually used ... I can't find a determinate bit that indicates just the battery status\n9:1 indicates whether the backup pump is running or has run recently without a reset (0) or not running or not recently run (1) ... when the pump stops running, beeping continues and this bit is not restored to 1 until reset is pressed ... there does not appear to be a bit anywhere that indicates whether the pump is actually running in that instant (except that I don't yet understand bytes 1-7)\n9:4 indicates whether a critical continuous alarm has been activated (not whether the continuous alarm is currently sounding) (0) or not (1) ... I think (because it flips to 0 for both fuse removal and batter disconnection) ... resetting resets this bit to 0\n10 is always <pre><code>0xeb</code></pre> no matter what I do\n11 is always <pre><code>0xe5</code></pre> no matter what I do\n",
    "votes": "1",
    "answers": 0,
    "views": "178",
    "tags": [
        "protocol",
        "usb",
        "macos"
    ],
    "user": "Nick Williams",
    "time": "Sep 5, 2023 at 22:10",
    "comments": [
        {
            "user": "Robert",
            "text": "The first problem that you face is that the USB port was designed to work with the pump as master, thus it expects a USB client device to connect, not a computer (USB master). An easiest approach would be trying to use an USB Ethernet connector, because of the Wifi support this might work. As you don't know what USB client devices are supported you can only try existing devices and see how far you get or alternatively use a computer like Raspberry which is capable of simulating different USB client devices.\n",
            "time": null
        },
        {
            "user": "Nick Williams",
            "text": "Is the thought that the pump would acquire an IP address (via DHCP) once the USB Ethernet adapter is connected to a network? Or that I could then plug a computer into that ethernet port and use it as a console?\n",
            "time": null
        },
        {
            "user": "Robert",
            "text": "An Ethernet adapter would allow communication at all. So you could connect it to an old router that is only connected to the pump and your PC. It think you will find a \"console\" as this would require an open telnet or sh connection but you could scan the system for available services that could be used to access the pump. But as the pump is designed to be integrated into a Wifi system you should not find open services, otherwise the pump would always be vulnerable to attacks when connected using the official Wifi adatzer.\n",
            "time": null
        },
        {
            "user": "Nick Williams",
            "text": "I'm not sure I understand what you're saying.  That aside ... we don't actually know that the pump controller is operating as USB Host, do we? It could be operating as USB Client (a dumb provider of I/O, essentially) and the WiFi and Z-wave modules are the USB Hosts with all the smarts, couldn't it? How would one determine this?\n",
            "time": null
        },
        {
            "user": "Robert",
            "text": "Everything is possible, but usually manufacturer prefer the simple and cheap solutions. Why should a vendor implement a custom system that provides Wifi to the pump if you can simply use an existing cheap USB to Wifi chip you simply build the Wifi system around? An own Wifi system that acts as USB host would also have the problem of Power supply. Before USB PD it was only the USB host which provides power to the bus and the clients (if they don't have an own power supply). An USB client (pump) to my knowledge was not designed to supply to a host (Wifi !module).\n",
            "time": null
        }
    ],
    "answers_data": []
}