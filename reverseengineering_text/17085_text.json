{
    "title": "Flare-ON#3: Problem understanding some parts in the program",
    "link": "https://reverseengineering.stackexchange.com/questions/17085/flare-on3-problem-understanding-some-parts-in-the-program",
    "content": "I was trying the flare on challenge. When trying the challenge#3 I got into some trouble and could not solve it. After looking into solutions wrote by other I now do know how the program works, but i have confusion in the following line.\n<pre><code>mov     ecx, offset loc_40107C\nadd     ecx, 79h\nmov     eax, offset loc_40107C\nmov     dl, [ebp+buf]\n</code></pre>\nThe solution that I am reading states that this instruction is moving the address into the <pre><code>ecx</code></pre> register and is used in combination with <pre><code>eax</code></pre> register to replace some values in that same location. The loop that does this is:\n<pre><code>loc_401039:\nmov     bl, [eax]\nxor     bl, dl\nadd     bl, 22h\nmov     [eax], bl\ninc     eax\ncmp     eax, ecx\njl      short loc_401039\n</code></pre>\nBut when i try and enter the location 40107C it seems the location has following instructions:\n<pre><code>icebp\npush    es\nsbb     dword ptr [esi], 1F99C4F0h\nles     edx, [ecx+1D81061Ch]\nout     6, al           ; DMA controller, 8237A-5.\n                        ; channel 3 base address\n                        ; (also sets current address)\nand     dword ptr [edx-11h], 0F2638106h\npush    es\n...\n</code></pre>\nShould not the location be empty or have some other values than assembly instructions since the location is being used for storing value, Or have I misunderstood something here, Can someone please clarify ?\nThe solution I was reading : https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/Flare-On%202017/Challenge%20%233%20solution.pdf\n",
    "votes": "5",
    "answers": 2,
    "views": "355",
    "tags": [
        "ida",
        "disassembly",
        "assembly",
        "binary-analysis",
        "x86"
    ],
    "user": "Nishan Maharjan",
    "time": "Dec 31, 2017 at 5:22",
    "comments": [
        {
            "user": "blabb",
            "text": "the disassembly will lead to code like this buf[i] = (buf[i] ^ (char *)0x40107c[i] ) + 0x22\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Should not the location be empty or have some other values than assembly instructions...?\n\nThe answer is \"no\". As the author stated in the write-up, this binary is self-modifying:\n\nAt this stage you may have correctly assumed the sample modifies these\n  instructions in order to properly reach <pre><code>0x401101</code></pre>.\n  ...\n  Another indication of self-modifying code is found in the sample’s PE headers.\n  The <pre><code>.text</code></pre> section, where the program’s entry point resides, is\n  writeable.\n\nAny try to disassemble the bytes from <pre><code>0x40107C</code></pre> to <pre><code>0x40107C+0x79</code></pre> will cause with wrong and non-sense assembly instructions. Thus, we should understand the function which manipulated this bytes. \nUnderstanding the modifying function\nAs you noticed already, this is the code which responsible for modifying the bytes in this range:\n<pre><code>loc_401039:\nmov     bl, [eax]\nxor     bl, dl\nadd     bl, 22h\nmov     [eax], bl\ninc     eax\ncmp     eax, ecx\njl      short loc_401039\n</code></pre>\nLet's use pseudo-code to understand how it works:\n<pre><code>start_addr = 0x0x40107c\nend_addr = 0x40107c + 0x79 = 0x4010f5\nkey = 0x??\n\nfor addr in range(start_addr, end_addr+1):\n    # setByte (address, new_value); getByte (address)\n    setByte(addr, (getByte(addr)^key)+0x22)\n</code></pre>\nSo, each byte in this range is XOR'd with some key and then <pre><code>0x22</code></pre> is added to the result.\n\nDemonstrating\nSpoiler Alert!\nThe next part contains spoilers regarding the answer\nThe write-up you attached contains a solution for the right key that you should use in the XOR operation to modify the bytes. I'll use this key in the following example.\nThe key is (hover to see it):\n\n 0xa2\n\nLet's try to decrypt this bytes by ourselves. I'll use radare2 for this but you can use any other solution you'd like to.\nFirst, let's make a copy of this challenge since we are going to edit the binary:\n<pre><code>$ cp greek_to_me.exe modified_greek_to_me.exe\n</code></pre>\nAnd now open the binary with radare2 in write-mode:\n<pre><code>$ r2 -w modified_greek_to_me.exe\n[0x00401000]>\n</code></pre>\nLet's seek to <pre><code>0x40107c</code></pre> and see how it looks like before we modify the bytes there:\n<pre><code>[0x00401000]> s 0x40107c\n[0x0040107c]> pd 10\n            0x0040107c      33e1           xor esp, ecx\n            0x0040107e      c49911068116   les ebx, [ecx + 0x16810611]\n            0x00401084      f0             invalid\n            0x00401085      329fc4911706   xor bl, byte [edi + 0x61791c4]\n            0x0040108b      8114f0068115.  adc dword [eax + esi*8], 0xf1158106\n            0x00401092      c4911a06811b   les edx, [ecx + 0x1b81061a]\n        ╭─< 0x00401098      e206           loop 0x4010a0\n        │   0x0040109a      8118f2068119   sbb dword [eax], 0x198106f2\n        ╰─> 0x004010a0      f1             int1\n            0x004010a1      06             push es\n</code></pre>\nI printed 10 op-codes in this address. As you can see, the instructions make no sense because in their current state they should not be disassembled.\nThis is how the <pre><code>0x79</code></pre> bytes from this address look like in hex:\n<pre><code>[0x0040107c]> px 0x79\n- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF\n0x0040107c  33e1 c499 1106 8116 f032 9fc4 9117 0681  3........2......\n0x0040108c  14f0 0681 15f1 c491 1a06 811b e206 8118  ................\n0x0040109c  f206 8119 f106 811e f0c4 991f c491 1c06  ................\n0x004010ac  811d e606 8162 ef06 8163 f206 8160 e3c4  .....b...c...`..\n0x004010bc  9961 0681 66bc 0681 67e6 0681 64e8 0681  .a..f...g...d...\n0x004010cc  659d 0681 6af2 c499 6b06 8168 a906 8169  e...j...k..h...i\n0x004010dc  ef06 816e ee06 816f ae06 816c e306 816d  ...n...o.\n</code></pre>\nNow we want to XOR <pre><code>0x79</code></pre> bytes from <pre><code>0x40107c</code></pre> and then add <pre><code>0x22</code></pre> to each byte. We can easily do it using radare2.\nFirst, we should define the block size that we want to manipulate, in our case it's 0x79:\n<pre><code>[0x0040107c]> b?\n|Usage: b[f] [arg]\nGet/Set block size\n| b        display current block size\n| b 33     set block size to 33\n...\n...\n[0x0040107c]> b 0x79\n</code></pre>\nAdding <pre><code>?</code></pre> to radare2 command will show help about the command and its subcommands\nNow, let's XOR the bytes from <pre><code>0x40107c</code></pre> to <pre><code>0x40107c + block_size</code></pre> and then add <pre><code>0x22</code></pre> to each one of them:\n<pre><code>[0x0040107c]> wo?\n|Usage: wo[asmdxoArl24] [hexpairs] @ addr[!bsize]\n...\n| woa [val]                     +=  addition (f.ex: woa 0102)\n...\n| wox [val]                     ^=  xor  (f.ex: wox 0x90)\n[0x0040107c]> wox 0xa2\n[0x0040107c]> woa 0x22\n</code></pre>\nAnd now our bytes are modified. Let's see how they look like in hex-mode:\n<pre><code>[0x0040107c]> px 0x79\n- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF\n0x0040107c  b365 885d d5c6 45d6 74b2 5f88 55d7 c645  .e.]..E.t._.U..E\n0x0040108c  d874 c645 d975 8855 dac6 45db 62c6 45dc  .t.E.u.U..E.b.E.\n0x0040109c  72c6 45dd 75c6 45de 7488 5ddf 8855 e0c6  r.E.u.E.t.]..U..\n0x004010ac  45e1 66c6 45e2 6fc6 45e3 72c6 45e4 6388  E.f.E.o.E.r.E.c.\n0x004010bc  5de5 c645 e640 c645 e766 c645 e86c c645  ]..E.@.E.f.E.l.E\n0x004010cc  e961 c645 ea72 885d ebc6 45ec 2dc6 45ed  .a.E.r.]..E.-.E.\n0x004010dc  6fc6 45ee 6ec6 45ef 2ec6 45f0 63c6 45f1  o.E.n.E...E.c.E.\n0x004010ec  6fc6 45f2 6dc6 45f3 00                   o.E.m.E..\n</code></pre>\nAnd let's disassemble it and see if now the assembly makes any sense:\n<pre><code>[0x0040107c]> pD 0x79\n            0x0040107c      b365           mov bl, 0x65                ; 'e' ; 101\n            0x0040107e      885dd5         mov byte [ebp - 0x2b], bl\n            0x00401081      c645d674       mov byte [ebp - 0x2a], 0x74 ; 't' ; 116\n            0x00401085      b25f           mov dl, 0x5f                ; '_' ; 95\n            0x00401087      8855d7         mov byte [ebp - 0x29], dl\n            0x0040108a      c645d874       mov byte [ebp - 0x28], 0x74 ; 't' ; 116\n            0x0040108e      c645d975       mov byte [ebp - 0x27], 0x75 ; 'u' ; 117\n            0x00401092      8855da         mov byte [ebp - 0x26], dl\n            0x00401095      c645db62       mov byte [ebp - 0x25], 0x62 ; 'b' ; 98\n            0x00401099      c645dc72       mov byte [ebp - 0x24], 0x72 ; 'r' ; 114\n            0x0040109d      c645dd75       mov byte [ebp - 0x23], 0x75 ; 'u' ; 117\n            0x004010a1      c645de74       mov byte [ebp - 0x22], 0x74 ; 't' ; 116\n            0x004010a5      885ddf         mov byte [ebp - 0x21], bl\n            0x004010a8      8855e0         mov byte [ebp - 0x20], dl\n            0x004010ab      c645e166       mov byte [ebp - 0x1f], 0x66 ; 'f' ; 102\n            0x004010af      c645e26f       mov byte [ebp - 0x1e], 0x6f ; 'o' ; 111\n            0x004010b3      c645e372       mov byte [ebp - 0x1d], 0x72 ; 'r' ; 114\n            0x004010b7      c645e463       mov byte [ebp - 0x1c], 0x63 ; 'c' ; 99\n            0x004010bb      885de5         mov byte [ebp - 0x1b], bl\n            0x004010be      c645e640       mov byte [ebp - 0x1a], 0x40 ; '@' ; 64\n            0x004010c2      c645e766       mov byte [ebp - 0x19], 0x66 ; 'f' ; 102\n            0x004010c6      c645e86c       mov byte [ebp - 0x18], 0x6c ; 'l' ; 108\n            0x004010ca      c645e961       mov byte [ebp - 0x17], 0x61 ; 'a' ; 97\n            0x004010ce      c645ea72       mov byte [ebp - 0x16], 0x72 ; 'r' ; 114\n            0x004010d2      885deb         mov byte [ebp - 0x15], bl\n            0x004010d5      c645ec2d       mov byte [ebp - 0x14], 0x2d ; '-' ; 45\n            0x004010d9      c645ed6f       mov byte [ebp - 0x13], 0x6f ; 'o' ; 111\n            0x004010dd      c645ee6e       mov byte [ebp - 0x12], 0x6e ; 'n' ; 110\n            0x004010e1      c645ef2e       mov byte [ebp - 0x11], 0x2e ; '.' ; 46\n            0x004010e5      c645f063       mov byte [ebp - 0x10], 0x63 ; 'c' ; 99\n            0x004010e9      c645f16f       mov byte [ebp - 0xf], 0x6f  ; 'o' ; 111\n            0x004010ed      c645f26d       mov byte [ebp - 0xe], 0x6d  ; 'm' ; 109\n            0x004010f1      c645f300       mov byte [ebp - 0xd], 0\n</code></pre>\nIndeed, now we are able to see all these <pre><code>mov</code></pre> instructions which build the flag :)\n",
            "votes": "7",
            "user": "Megabeets",
            "time": "Dec 31, 2017 at 19:56",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "From the above code <pre><code>ecx</code></pre> stores the address of the end of the buffer (<pre><code>loc_40107C</code></pre> + 0x79). <pre><code>eax</code></pre> points to the beginning and then in is checked if <pre><code>eax</code></pre> has reached the end of the buffer by comparing <pre><code>eax</code></pre> with <pre><code>ecx</code></pre>.\nAs for the buffer at <pre><code>0x40107C</code></pre> it probably shouldn't be empty as the values are modified in the loop. The code that you pasted should be treated as data so it should be viewed as <pre><code>0xF1, 0x06, 0x81, 0x1e, 0xf0, 0xc4, 0x99, 0x1f...</code></pre>.\nNow, there's something under <pre><code>[ebp+buf]</code></pre> that when used on this buffer and adding <pre><code>0x22</code></pre> gives some meaningful code.\n",
            "votes": "2",
            "user": "Megabeets",
            "time": "Dec 31, 2017 at 8:45",
            "is_accepted": false,
            "comments": []
        }
    ]
}