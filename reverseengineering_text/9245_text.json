{
    "title": "reversing bytcode - trying to work decompiling expression",
    "link": "https://reverseengineering.stackexchange.com/questions/9245/reversing-bytcode-trying-to-work-decompiling-expression",
    "content": "I'm trying to reverse engineer a proprietary scripting \"compiled bytecode\" So I can recover source codes of contractor who has gone.\nWhile I worked out the majority of it, I'm trying to work out how to translate expressions back into code. Wondering if anyone may have some ideas from the patterns below the sort of logic that might be used to rebuild the equations. In particular how operators may be applied back to the components of the expression.\nSpecifically I'm trying to work out how to decompile these two expressions:\n<pre><code>A = B * C+D/E-F\nA = B * (C+D)/E-F\n</code></pre>\nOperation Codes ,this was worked out from examples provided below\n<pre><code>22 04 >\n2B 04 <\n32 04 *\n01 04 +\n17 04 /\n55 04 -\n25 00 AND\n27 00 OR\n26 04 end of statement\n</code></pre>\nType of assignment:\n<pre><code>3D 40 xx xx       = Variable xx xx \n3D 45 xx xx xx xx = 4 byte number\n4B xx             = One byte value\n48 xx             = One byte value\n38 40 xx xx       = Assign result to variable xx xx\n</code></pre>\nIn this example the variables are:\n<pre><code>A = 00 00\nB = 00 04\nC = 00 08\nD = 00 0C\nE = 00 10\nF = 00 14\n</code></pre>\nExample:\nA = 10*20+30/40-50/2\n<pre><code>4B AF       ; 175 \n38 40 00 00 ; Assign result to A\n</code></pre>\nA = 10*B+30/40-50/2\n<pre><code>48 0A       ; 10\n3D 40 00 04 ; B \n32 04       ; *\n48 00       ; 0\n01 04       ; +\n48 19       ; 25\n55 04       ; -\n38 40 00 00 ; assign result to A\n</code></pre>\nA = B+C\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n01 04       ; +\n38 40 00 00 ; assign result to A\n</code></pre>\nA = B*C\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n32 04       ; *\n38 40 00 00 ; assign result to A\n</code></pre>\nA = B-C\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n55 04       ; -\n38 40 00 00 ; Assign result to A\n</code></pre>\nA = B/C\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n17 04       ; / \n38 40 00 00 ; Assign result to A\n</code></pre>\nA = B*C+D-E/F\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n32 04       ; *\n3D 40 00 0C ; D\n01 04       ; +\n3D 40 00 10 ; E\n3D 40 00 14 ; F\n17 04       ; /\n55 04       ; -\n38 40 00 00 ; Assign result to A\n</code></pre>\nA = B*C+D/E-F\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n32 04       ; *\n3D 40 00 0C ; D\n3D 40 00 10 ; E\n17 04       ; / \n01 04       ; +\n3D 40 00 14 ; F\n55 04       ; -\n38 40 00 00 ; Assign result to A\n</code></pre>\nA = B*(C+D)/E-F\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n3D 40 00 0C ; D\n01 04       ; +\n32 04       ; *\n3D 40 00 10 ; E\n17 04       ; /\n3D 40 00 14 ; F\n55 04       ; -\n38 40 00 00 ; Assign result to A\n</code></pre>\nA = B+C * D\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C \n3D 40 00 0C ; D\n32 04       ; * \n01 04       ; +\n38 40 00 00 ; assign result to A\n</code></pre>\nA=(B+C) * D\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n01 04       ; +\n3D 40 00 0C ; D\n32 04       ; *\n38 40 00 00 ; assign result to A\n</code></pre>\nA=B+C+D * E\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n01 04       ; +\n3D 40 00 0C ; D\n3D 40 00 10 ; E\n32 04       ; *\n01 04       ; +\n38 40 00 00 ; assign result to A\n</code></pre>\nA=(B+C+D) * E\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n01 04       ; +\n3D 40 00 0C ; D\n01 04       ; +\n3D 40 00 10 ; E\n32 04       ; *\n38 40 00 00 ; assign result to A\n</code></pre>\nA=A+B * C+D+E * F\n<pre><code>3D 40 00 00 ; A\n3D 40 00 04 ; B\n3D 40 00 08 ; C\n32 04       ; *\n01 04       ; +\n3D 40 00 0C ; D\n01 04       ; +\n3D 40 00 10 ; E\n3D 40 00 14 ; F\n32 04       ; *\n01 04       ; +\n38 40 00 00 ; Assign result to A\n</code></pre>\nA=(A+B) * (C+D)+E * F\n<pre><code>3D 40 00 00 ; A\n3D 40 00 04 ; B\n01 04       ; + \n3D 40 00 08 ; C\n3D 40 00 0C ; D\n01 04       ; +   \n32 04       ; *\n3D 40 00 10 ; E\n3D 40 00 14 ; F\n32 04       ; *\n01 04       ; +\n38 40 00 00 ; Assign result to A\n</code></pre>\nA=A+B+(C * D)+E\n<pre><code>3D 40 00 00 ; A\n3D 40 00 04 ; B\n01 04       ; +\n3D 40 00 08 ; C\n3D 40 00 0C ; D\n32 04       ; *\n01 04       ; +\n3D 40 00 10 ; E\n01 04       ; + \n38 40 00 00 ; assign result to A\n</code></pre>\nA=A+B+(C* D *E)+F\n<pre><code>3D 40 00 00 ; A\n3D 40 00 04 ; B\n01 04       ; +\n3D 40 00 08 ; C\n3D 40 00 0C ; D\n32 04       ; *\n3D 40 00 10 ; E\n32 04       ; *\n01 04       ; +\n3D 40 00 14 ; F\n01 04       ; +\n38 40 00 00 ; assign result to A\n</code></pre>\nA=B-C\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n55 04       ; -\n38 40 00 00 ; assign result to A\n</code></pre>\nA=B*C+D-E/F\n<pre><code>3D 40 00 04 ; B\n3D 40 00 08 ; C\n32 04       ; *\n3D 40 00 0C ; D\n01 04       ; +\n3D 40 00 10 ; E\n3D 40 00 14 ; F\n17 04       ; -\n55 04       ; /\n38 40 00 00 ; Assign result to A\n</code></pre>\nBoolean Expressions\n512 < A\n<pre><code>3D 45 00 00 02 00 ; 512\n3D 40 00 00       ; variable A\n2B 04             ; <\n26 00             ; end of expression\n00 7E             ; ?\n</code></pre>\na>B and b128 or d>1024 or e>128\n<pre><code>3D 40 00 00 ; A\n3D 40 00 04 ; B\n22 04       ; >\n25 00       ; AND\n00 CC       ;\n3D 40 00 04 ; B\n3D 40 00 08 ; C\n2B 04       ; <\n25 00       ; AND\n00 CC       ;\n3D 40 00 08 ; C\n4B 80       ; 128\n22 04       ; >\n27 00       ; OR \n00 E8       ;\n3D 40 00 0C ; D \n3D 45 00 00 04 00 ; 1024\n22 04       ; >\n27 00       ; OR \n00 E8       ; \n3D 40 00 10 ; E\n4B 80       ; 128\n22 04       ; >\n26 00       ; end of expression\n01 14       ; ?\n</code></pre>\n",
    "votes": "1",
    "answers": 1,
    "views": "114",
    "tags": [
        "file-format"
    ],
    "user": "chentiangemalc",
    "time": "Jun 29, 2015 at 0:06",
    "comments": [
        {
            "user": "Jongware",
            "text": "Your notation is stack based Polish notation â€“ \"postfix\". The form you want to convert it to is called \"infix\". Adding those two together, you may want to read the answers in Converting from postfix to infix.\n",
            "time": null
        },
        {
            "user": "Rakholiya Jenish",
            "text": "Isn't your example for <pre><code>A=B*C+D-E/F</code></pre> incorrect? It should have been <pre><code>B C * D + E F / -</code></pre> instead of <pre><code>B C * D + E F - /</code></pre>\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Thanks to response from Jongware who correctly identified this as reverse polish notation, which needed to be converted to \"infix\"\nTested on some samples\nOriginal:\n1) A=B * C+D-E/F\n2) A=B * C+D/E-F\n3) A=B * (C+D)/E-F\nDecompiled:\n1) A=(((B * C)+D)-(E/F))\n2) A=(((B * C)+(D/E))-F)\n3) A=(((B* (C+D))/E)-F)\nIf this helps anyone else this is the prototype processing code in C#, which I've verified works correctly. This code needs further improvement, but it does work for this scenario described.\n<pre><code>    // instruction is a byte[] array containing the code to decode\n    Stack<string> stack = new Stack<string>();\n    string op;\n    byte[] bit32=new byte[4];\n    string result;\n\n    for (int i = 0; i < instruction.Length;i++ )\n    {\n        op=\"\";\n        switch (instruction[i])\n        {\n            case 0x22:\n                op=\">\";\n                i++;\n                break;\n            case 0x2B:\n                op=\"<\";\n                i++;\n                break;\n            case 0x32:\n                op=\"*\";\n                i++;\n                break;\n        case 0x01:\n            op=\"+\";\n            i++;\n            break;\n        case 0x17:\n            op=\"/\";\n            i++;\n            break;\n        case 0x55:\n            op=\"-\";\n            i++;\n            break;\n        case 0x38:\n            i++;\n\n            if (instruction[i]==0x40)\n            {\n                // builds the final result, and adds it to textboxDecompiledText\n                i++;\n                result = string.Format(\"{0}={1}\", string.Format(\"S{0:X2}{1:X2}\", instruction[i], instruction[i + 1]),\n                stack.Pop());\n\n                i++;\n\n                textBoxDecompiled.Text += result;\n                break;\n\n            }\n            break;\n        case 0x4B: // 1 byte integer\n        case 0x48:\n            i++;\n            stack.Push(((int)instruction[i]).ToString());\n            break;\n        case 0x3D:\n            i++;\n            switch (instruction[i])\n            {\n                case 0x40: // variable\n                    i++;\n                    string currentVariable= string.Format(\"S{0:X2}{1:X2}\", instruction[i], instruction[i + 1]);\n                    stack.Push(currentVariable);\n                    i += 1;\n                    break;\n                case 0x45: // 4 byte integer\n                    i++;\n                    Buffer.BlockCopy(instruction,i,bit32,0,4);\n                    Array.Reverse(bit32);\n                    int bit32result = BitConverter.ToInt32(instruction, 0);\n                    stack.Push(bit32result.ToString());\n                    i+=3;\n                    break;\n\n\n            }\n            break;\n\n    }\n\n    // check if we have an operator\n    if (!string.IsNullOrEmpty(op))\n    {\n        if (stack.Count >= 2)\n        {\n            string op2 = stack.Pop();\n            string op1 = stack.Pop();\n            stack.Push(string.Format(\"({0}{1}{2})\", op1, op, op2));\n        }\n        else\n        {\n            // something wrong here!\n            throw new InvalidOperationException();\n        }\n    }\n}\n</code></pre>\n",
            "votes": "2",
            "user": "chentiangemalc",
            "time": "Jun 29, 2015 at 8:08",
            "is_accepted": true,
            "comments": []
        }
    ]
}