{
    "title": "Adding section. Error starting the application (0xc000007b)",
    "link": "https://reverseengineering.stackexchange.com/questions/16234/adding-section-error-starting-the-application-0xc000007b",
    "content": "I added a section to this executable\nexternal link to download the executable it is winmine from windows xp\nusing cff explorer\nthe only modification done to the executable is adding a section \ni have not editied the executable manually or otherwise \ncff explorer successfully adds the section     \nbut if i execute the resulting executable     \nI get an error :   \n\n\"Error starting the application (0xc000007b) ...\"\n\ni would like to understand why the modified application is crashing\n",
    "votes": "4",
    "answers": 2,
    "views": "825",
    "tags": [
        "pe",
        "section"
    ],
    "user": "alex-rudenkiy",
    "time": "Sep 6, 2017 at 15:38",
    "comments": [
        {
            "user": "Samson",
            "text": "In the characteristics column, what is the number\n",
            "time": null
        },
        {
            "user": "Samson",
            "text": "Also, have you made any other modifications to the program? what steps did you take? Because I can add a section without getting that error, and I can get that error if i deliberately corrupt the Optional Header. Which means to me that you might have made a mistake when editing the program.\n",
            "time": null
        },
        {
            "user": "alex-rudenkiy",
            "text": "@Samson E00000E0\n",
            "time": null
        },
        {
            "user": "alex-rudenkiy",
            "text": "@Samson Honestly speaking, I did not edit anything else. I just added a section (empty space) and everything, more than anything\n",
            "time": null
        },
        {
            "user": "Samson",
            "text": "Strange that you didnt edit anything else and got an issue. Could you send the edited problematic executable?\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "blabb's answer may be right as far as it relates to what's wrong in the edited binary, but the suggestion to use a kernel debugger to find the problematic stack is way off course.\nFor this demonstration I use Windows XP rather than 7 like you. The effects are pretty much the same except that the NTSTATUS on XP is <pre><code>0xC0000135</code></pre> rather than <pre><code>0xC000007B</code></pre>.\nWe open WinDbg and execute the binary:\n<pre><code>Microsoft (R) Windows Debugger Version 6.12.0002.633 X86\nCopyright (c) Microsoft Corporation. All rights reserved.\n\nCommandLine: \"C:\\Documents and Settings\\Administrator\\My Documents\\Downloads\\Winmine - XP - копия.exe\"\nSymbol search path is: *** Invalid ***\n****************************************************************************\n* Symbol loading may be unreliable without a symbol search path.           *\n* Use .symfix to have the debugger choose a symbol path.                   *\n* After setting your symbol path, use .reload to refresh symbol locations. *\n****************************************************************************\nExecutable search path is: \nModLoad: 01000000 01021000   winmine.exe\nModLoad: 7c900000 7c9b2000   ntdll.dll\nModLoad: 7c800000 7c8f6000   C:\\WINDOWS\\system32\\kernel32.dll\n</code></pre>\nA message box pops up:\n\nWe don't dismiss the message box. Instead we break in WinDbg:\n<pre><code>Break-in sent, waiting 30 seconds...\nWARNING: Break-in timed out, suspending.\n         This is usually caused by another thread holding the loader lock\n(b58.e64): Wake debugger - code 80000007 (first chance)\neax=c0000135 ebx=00000000 ecx=00000a2b edx=00090608 esi=7ffdfc00 edi=c0000135\neip=7c90e514 esp=0006f6f0 ebp=0006f7d4 iopl=0         nv up ei pl nz na po cy\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000203\n*** ERROR: Symbol file could not be found.  Defaulted to export symbols for ntdll.dll - \nntdll!KiFastSystemCallRet:\n7c90e514 c3              ret\n</code></pre>\nYes, it actually takes these 30 seconds.\nLet's look at the stack:\n<pre><code>0:000> ~* k\n\n.  0  Id: b58.e64 Suspend: 1 Teb: 7ffdf000 Unfrozen\nChildEBP RetAddr  \nWARNING: Stack unwind information not available. Following frames may be wrong.\n0006f7d4 7c91c880 ntdll!KiFastSystemCallRet\n0006fa34 7c9246f2 ntdll!LdrDisableThreadCalloutsForDll+0xce\n0006fa78 7c92469b ntdll!sprintf+0x13e\n0006fa98 7c9247d5 ntdll!sprintf+0xe7\n0006fb14 7c920244 ntdll!sprintf+0x221\n0006fc94 7c91fad7 ntdll!RtlInitMemoryStream+0x2e8\n0006fd1c 7c90e457 ntdll!RtlLookupElementGenericTable+0x80\n00000000 00000000 ntdll!KiUserApcDispatcher+0x7\n\n   1  Id: b58.324 Suspend: 1 Teb: 7ffde000 Unfrozen\nChildEBP RetAddr  \nWARNING: Stack unwind information not available. Following frames may be wrong.\n0028fc98 7c901046 ntdll!KiFastSystemCallRet\n0028fd18 7c90e457 ntdll!RtlEnterCriticalSection+0x46\n00000000 00000000 ntdll!KiUserApcDispatcher+0x7\n</code></pre>\nThe second thread is probably used to communicate with CSRSS to display the message or something like that and it's not really interesting. The first thread is what's important, and its symbols are all messed up.\nLet's fix that:\n<pre><code>0:000> lm\nstart    end        module name\n01000000 01021000   winmine    (deferred)             \n7c800000 7c8f6000   kernel32   (deferred)             \n7c900000 7c9b2000   ntdll      (export symbols)       C:\\WINDOWS\\system32\ntdll.dll\n0:000> .symfix+\n0:000> .reload /f\nReloading current modules\n...\n0:000> lm\nstart    end        module name\n01000000 01021000   winmine    (pdb symbols)          C:\\Documents and Settings\\Administrator\\Desktop\\debugger_x86\\sym\\winmine.pdb\\3B7D84751\\winmine.pdb\n7c800000 7c8f6000   kernel32   (pdb symbols)          C:\\Documents and Settings\\Administrator\\Desktop\\debugger_x86\\sym\\kernel32.pdb\\A02FC3EC19B4474FB75641AF4C5B031C2\\kernel32.pdb\n7c900000 7c9b2000   ntdll      (pdb symbols)          C:\\Documents and Settings\\Administrator\\Desktop\\debugger_x86\\sym\ntdll.pdb\\CEFC0863B1F84130A11E0F54180CD21A2\ntdll.pdb\n0:000> k\nChildEBP RetAddr  \n0006f6ec 7c90d9ca ntdll!KiFastSystemCallRet\n0006f6f0 7c9423a9 ntdll!NtRaiseHardError+0xc\n0006f7d4 7c91c880 ntdll!LdrpMapDll+0x1b8\n0006fa34 7c9246f2 ntdll!LdrpLoadImportModule+0x174\n0006fa78 7c92469b ntdll!LdrpHandleOneNewFormatImportDescriptor+0x53\n0006fa98 7c9247d5 ntdll!LdrpHandleNewFormatImportDescriptors+0x20\n0006fb14 7c920244 ntdll!LdrpWalkImportDescriptor+0x19e\n0006fc94 7c91fad7 ntdll!LdrpInitializeProcess+0xe1c\n0006fd1c 7c90e457 ntdll!_LdrpInitialize+0x183\n00000000 00000000 ntdll!KiUserApcDispatcher+0x7\n</code></pre>\nYou get pretty much the same stack blabb got, without any kernel debugging. Amazing, even if I say so myself.\nBy the way, the second thread's stack is still uninteresting:\n<pre><code>0:000> ~1 k\nChildEBP RetAddr  \n0028fc0c 7c90df5a ntdll!KiFastSystemCallRet\n0028fc10 7c919b23 ntdll!NtWaitForSingleObject+0xc\n0028fc98 7c901046 ntdll!RtlpWaitForCriticalSection+0x132\n0028fca0 7c924d2d ntdll!RtlEnterCriticalSection+0x46\n0028fd18 7c90e457 ntdll!_LdrpInitialize+0xf0\n00000000 00000000 ntdll!KiUserApcDispatcher+0x7\n</code></pre>\nWe can look at the parameters to these functions and see the problem in the bound import table:\n<pre><code>0:000> kb\nChildEBP RetAddr  Args to Child              \n0006f6ec 7c90d9ca 7c9423a9 c0000135 00000002 ntdll!KiFastSystemCallRet\n0006f6f0 7c9423a9 c0000135 00000002 00000003 ntdll!NtRaiseHardError+0xc\n0006f7d4 7c91c880 00020498 7ffdfc00 00000000 ntdll!LdrpMapDll+0x1b8\n0006fa34 7c9246f2 00020498 010002ab 01000000 ntdll!LdrpLoadImportModule+0x174\n0006fa78 7c92469b 7ffd6000 00020498 00191ee0 ntdll!LdrpHandleOneNewFormatImportDescriptor+0x53\n0006fa98 7c9247d5 7ffd6000 00020498 00191ee0 ntdll!LdrpHandleNewFormatImportDescriptors+0x20\n0006fb14 7c920244 00020498 00191ee0 7ffdf000 ntdll!LdrpWalkImportDescriptor+0x19e\n0006fc94 7c91fad7 0006fd30 7c900000 0006fce0 ntdll!LdrpInitializeProcess+0xe1c\n0006fd1c 7c90e457 0006fd30 7c900000 00000000 ntdll!_LdrpInitialize+0x183\n00000000 00000000 00000000 00000000 00000000 ntdll!KiUserApcDispatcher+0x7\n0:000> du 7ffdfc00 \n7ffdfc00  \"NEL32.dll\"\n0:000> db 010002ab\n010002ab  4e 45 4c 33 32 2e 64 6c-6c 00 47 44 49 33 32 2e  NEL32.dll.GDI32.\n010002bb  64 6c 6c 00 55 53 45 52-33 32 2e 64 6c 6c 00 53  dll.USER32.dll.S\n010002cb  48 45 4c 4c 33 32 2e 64-6c 6c 00 57 49 4e 4d 4d  HELL32.dll.WINMM\n010002db  2e 64 6c 6c 00 43 4f 4d-43 54 4c 33 32 2e 64 6c  .dll.COMCTL32.dl\n010002eb  6c 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  l...............\n010002fb  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0100030b  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0100031b  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n</code></pre>\nIf you want to trace through the loading process rather than only see the stack after the fail you can do that too with the user mode debugger.\nLet's dismiss the message box, and tell WinDbg to break at process creation instead of at the so-called initial breakpoint which happens only after the static imports have been resolved:\n<pre><code>0:000> sxe cpr\n0:000> .restart\nCommandLine: \"C:\\Documents and Settings\\Administrator\\My Documents\\Downloads\\Winmine - XP - копия.exe\"\nSymbol search path is: srv*\nExecutable search path is: \neax=01003e21 ebx=7ffd4000 ecx=7c910060 edx=7c90e920 esi=0078c60c edi=00ecf554\neip=7c810735 esp=0006fffc ebp=7c91005d iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000200\n7c810735 ??              ???\n0:000> lm\nstart    end        module name\n01000000 01021000   winmine    (deferred)             \n0:000> k\nChildEBP RetAddr  \nWARNING: Frame IP not in any known module. Following frames may be wrong.\n0006fff8 00000000 0x7c810735\n</code></pre>\nOMG what is this?! Only <pre><code>winmine</code></pre> loaded? But we know the <pre><code>ntdll</code></pre> is mapped into every Win32 process right from the start.\nWell, <pre><code>ntdll</code></pre> is actually mapped, but the debugger still didn't get a debug event about it. That's how early we're in the process initialization process.\nWe can wait for this event by using <pre><code>sxe ld ntdll</code></pre> (or <pre><code>sxe ld</code></pre>), or we can force WinDbg to be made aware <pre><code>ntdll</code></pre>. Then we can put breakpoints on <pre><code>ntdll!LdrpHandleOneNewFormatImportDescriptor</code></pre> etc.:\n<pre><code>0:000> sxe ld ntdll\n0:000> g\nModLoad: 7c900000 7c9b2000   ntdll.dll\neax=01003e21 ebx=7ffd4000 ecx=7c910060 edx=7c90e920 esi=0078c60c edi=00ecf554\neip=7c810735 esp=0006fffc ebp=7c91005d iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000200\n7c810735 ??              ???\n0:000> lm\nstart    end        module name\n01000000 01021000   winmine    (deferred)             \n7c900000 7c9b2000   ntdll      (deferred)             \n0:000> .symfix+\n0:000> .reload /f\nReloading current modules\n..\n0:000> bu ntdll!LdrpHandleOneNewFormatImportDescriptor\n0:000> bl\n 0 e 7c9246ad     0001 (0001)  0:**** ntdll!LdrpHandleOneNewFormatImportDescriptor\n0:000> g\nBreakpoint 0 hit\neax=0006faac ebx=7ffd4000 ecx=000000b4 edx=0000415c esi=01000248 edi=00000001\neip=7c9246ad esp=0006fa7c ebp=0006fa98 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nntdll!LdrpHandleOneNewFormatImportDescriptor:\n7c9246ad 8bff            mov     edi,edi\n</code></pre>\nThere's absolutely no need for kernel debugging here.\nEverything we need is available from user mode.\n",
            "votes": "5",
            "user": "conio",
            "time": "Sep 7, 2017 at 3:38",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "your exe is having bound import table address at 0x248 (at the end of last section ) and cff explorer is overwriting those entries (BOUND IMPORT From kernel32.dll with timestamp \n<pre><code>5.1.2600.0  3B7DFE0E (18th August 2001)     926,720     Windows XP \n</code></pre>\nthat is why it is crashing\n<pre><code>dumpbin /headers Winmine_test.exe | grep -i bound\n             248 [      A8] RVA [size] of Bound Import Directory\n</code></pre>\noriginal exe  the bound import modname is @ offset 0x48 from start which is msvcrt.dll\n<pre><code>C:\\wdscr\\cfftest>xxd -s 0x248 -g4 -l 0xa8 \"W\n0000248: 0efe7d3b 48000000 0efe7d3b 53000000\n0000258: 0efe7d3b 60000000 0efe7d3b 6d000000\n0000268: 0efe7d3b 77000000 0ffe7d3b 82000000\n0000278: 13fe7d3b 8e000000 32fe7d3b 98000000\n0000288: 00000000 00000000 6d737663 72742e64\n</code></pre>\nbut in cff explorer edited exe the bound import table is corrupted \n<pre><code>xxd -s 0x248 -g 4 -l 0xa8 Winmine_test.exe\n0000248: 2e746573 **74000000** 00100000 00000200  .test...........\n0000258: 00100000 00d40100 00000000 00000000  ................\n0000268: 00000000 200000e0 0ffe7d3b 82000000  .... .....};....\n0000278: 13fe7d3b 8e000000 32fe7d3b 98000000  ..};....2.};....\n0000288: 00000000 00000000 6d737663 72742e64  ........msvcrt.d\n0000298: 6c6c0041 44564150 4933322e 646c6c00  ll.ADVAPI32.dll.\n00002a8: 4b45524e 454c3332 2e646c6c 00474449  KERNEL32.dll.GDI\n00002b8: 33322e64 6c6c0055 53455233 322e646c  32.dll.USER32.dl\n00002c8: 6c005348 454c4c33 322e646c 6c005749  l.SHELL32.dll.WI\n00002d8: 4e4d4d2e 646c6c00 434f4d43 544c3332  NMM.dll.COMCTL32\n00002e8: 2e646c6c 00000000                    .dll....\n</code></pre>\nthe bound import table module name is given as offset so the first offset is 0x74\n<pre><code>0000248: 2e746573 74000000\n</code></pre>\nso 248+74 = 0x2bc \nand the loader is trying to load thus ll.dll and failing \n6c6c0055 53455233 322e646c  32.d**ll.**USER32.dl\nyou cant trap this with a user mode debugger because the initialisation code \nis run before debugger gets a chance to attach \nif you are running this exe in a vm connected to a kernel debugger you can watch the bound import failing if you set a break on \n<pre><code>ntdll!LdrpHandleOneNewFormatImportDescriptor\n</code></pre>\nalso you can enable gflag +sls  (show loader snaps ) in the context to get the loader snap spewing out that winmine is bound to ll.dll and then trying to walk the imports in the non existant dll\n<pre><code>kd> r\neax=0006fa6c ebx=7ffdd000 ecx=000000b4 edx=0000415c esi=00191ec0 edi=010002bc\neip=7c91d025 esp=0006fa38 ebp=0006fa78 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!LdrpLoadImportModule:\n001b:7c91d025 8bff            mov     edi,edi\n\n\nkd> kb\n # ChildEBP RetAddr  Args to Child              \n00 0006fa34 7c91e4cb 00020498 010002bc 01000000 ntdll!LdrpLoadImportModule\n01 0006fa78 7c91e474 7ffdd000 00020498 00191ec0 ntdll!LdrpHandleOneNewFormatImportDescriptor+0x53\n02 0006fa98 7c91e5ae 7ffdd000 00020498 00191ec0 ntdll!LdrpHandleNewFormatImportDescriptors+0x20\n03 0006fb14 7c921e25 00020498 00191ec0 7ffdf000 ntdll!LdrpWalkImportDescriptor+0x19e\n04 0006fc94 7c92108f 0006fd30 7c900000 0006fce0 ntdll!LdrpInitializeProcess+0xe02\n05 0006fd1c 7c90e437 0006fd30 7c900000 00000000 ntdll!_LdrpInitialize+0x183\n06 00000000 00000000 00000000 00000000 00000000 ntdll!KiUserApcDispatcher+0x7\n\n\nkd> .fnent .\nDebugger function entry 039b6c60 for:\n(7c91d025)   ntdll!LdrpLoadImportModule   |  (7c91d1a1)   ntdll!LdrpInitSecurityCookie\nExact matches:\n    ntdll!LdrpLoadImportModule (<no parameter info>)\n\nOffStart:  0001d025\nProcSize:  0x23a\nPrologue:  0x29\nParams:    0n5 (0x14 bytes)\nLocals:    0n141 (0x234 bytes)\nNon-FPO\n\nkd> dd esp l6\n0006fa38  7c91e4cb 00020498 010002bc 01000000\n0006fa48  0006fa6c 0006fa77\n\n\n\nkd> db 20498\n00020498  43 00 3a 00 5c 00 44 00-6f 00 63 00 75 00 6d 00  C.:.\\.D.o.c.u.m.\n000204a8  65 00 6e 00 74 00 73 00-20 00 61 00 6e 00 64 00  e.n.t.s. .a.n.d.\n000204b8  20 00 53 00 65 00 74 00-74 00 69 00 6e 00 67 00   .S.e.t.t.i.n.g.\n000204c8  73 00 5c 00 61 00 64 00-6d 00 69 00 6e 00 5c 00  s.\\.a.d.m.i.n.\\.\n000204d8  44 00 65 00 73 00 6b 00-74 00 6f 00 70 00 5c 00  D.e.s.k.t.o.p.\\.\n000204e8  63 00 66 00 66 00 74 00-65 00 73 00 74 00 3b 00  c.f.f.t.e.s.t.;.\n000204f8  43 00 3a 00 5c 00 57 00-49 00 4e 00 44 00 4f 00  C.:.\\.W.I.N.D.O.\n00020508  57 00 53 00 5c 00 73 00-79 00 73 00 74 00 65 00  W.S.\\.s.y.s.t.e.\n\n\n\nkd> db 10002bc\n010002bc  6c 6c 00 55 53 45 52 33-32 2e 64 6c 6c 00 53 48  ll.USER32.dll.SH\n010002cc  45 4c 4c 33 32 2e 64 6c-6c 00 57 49 4e 4d 4d 2e  ELL32.dll.WINMM.\n010002dc  64 6c 6c 00 43 4f 4d 43-54 4c 33 32 2e 64 6c 6c  dll.COMCTL32.dll\n010002ec  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n010002fc  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0100030c  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0100031c  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0100032c  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n\n\nkd> db 10002bc-74\n01000248  2e 74 65 73 74 00 00 00-00 10 00 00 00 00 02 00  .test...........\n01000258  00 10 00 00 00 d4 01 00-00 00 00 00 00 00 00 00  ................\n01000268  00 00 00 00 20 00 00 e0-0f fe 7d 3b 82 00 00 00  .... .....};....\n01000278  13 fe 7d 3b 8e 00 00 00-32 fe 7d 3b 98 00 00 00  ..};....2.};....\n01000288  00 00 00 00 00 00 00 00-6d 73 76 63 72 74 2e 64  ........msvcrt.d\n01000298  6c 6c 00 41 44 56 41 50-49 33 32 2e 64 6c 6c 00  ll.ADVAPI32.dll.\n010002a8  4b 45 52 4e 45 4c 33 32-2e 64 6c 6c 00 47 44 49  KERNEL32.dll.GDI\n010002b8  33 32 2e 64 6c 6c 00 55-53 45 52 33 32 2e 64 6c  32.dll.USER32.dl\n</code></pre>\n",
            "votes": "3",
            "user": "blabb",
            "time": "Sep 6, 2017 at 9:28",
            "is_accepted": false,
            "comments": [
                {
                    "user": "conio",
                    "text": "<span class=\"comment-copy\">Kernel debugging is completely unnecessary. All of this can be done using WinDbg as a user debugger.</span>",
                    "time": null
                }
            ]
        }
    ]
}