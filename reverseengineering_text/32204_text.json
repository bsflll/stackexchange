{
    "title": "How can I tell ghidra what structure an address register points to?",
    "link": "https://reverseengineering.stackexchange.com/questions/32204/how-can-i-tell-ghidra-what-structure-an-address-register-points-to",
    "content": "I am reversing a raw bare-metal binary firmware for a tricore processor (TC1762/TC1766).\nIn many functions i'm currently reversing there is access to offsets of the address stored in the a0 register. Therefore a0 points to a definable stucture, that i analysed an defined in the Data Type Manager.\nExamples of access:\nReading from the structure:\n<pre><code>result = functionCall(*(int *)(a0 + 0x1478),1);\n</code></pre>\nWriting to the structure:\n<pre><code>*(undefined4 *)(a0 + 0x147c) = timeOfLastRequest;\n</code></pre>\nThe structure I setup to use:\n\nNow I want to tell ghidra, to handle a0 as a pointer to this struct. If a0 was just a pointer variable this would work as intented and would make \"a0 + 0x1478\" something like instanceOfCounter->currentNumber.\nTrying to set a type to a0 will result in an UnsupportedOperationException:\nDatabase supports global memory variables only\njava.lang.UnsupportedOperationException: Database supports global memory variables only\nI am sure there is a way to do this correctly since it would improve the readability of the disassembly so much and would just feel right. I just can't find a way to do this.\nI understand that the context, that a0 points to this struct is probably limited, so this might need to be assigned only for the context of a defined function or something.\nAppreciate any hint\n",
    "votes": "1",
    "answers": 1,
    "views": "619",
    "tags": [
        "disassembly",
        "ghidra",
        "firmware-analysis",
        "register",
        "type-reconstruction"
    ],
    "user": "user103675",
    "time": "Aug 24, 2023 at 12:58",
    "comments": [],
    "answers_data": [
        {
            "content": "In Windows Assuming code as below is compiled without debugging info (no PDB)  and loaded in ghidra.\ndisabled analysis on loading.\nfollowed label entry to find the address of function main\nwent to main (0x140001000) and hit D to Disassemble and hit F to create a Function\n<pre><code>#include <windows.h>\n#include <winternl.h>\n#include <stdio.h>\nint main(void)\n{\n    PPEB mypeb = (PPEB)__readgsqword(0x60);\n    PRTL_USER_PROCESS_PARAMETERS proparm = mypeb->ProcessParameters;\n    printf(\"%S\n\", proparm->ImagePathName.Buffer);\n}\n</code></pre>\nthe decompiled function main would look as below with fuzzy pointer arithmetics and ugly casts\n<pre><code>   undefined8\nFUN_140001000(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  longlong unaff_GS_OFFSET;\n  \n  FUN_1400010a0((longlong)&DAT_1400132e0,\n                *(undefined8 *)(*(longlong *)(*(longlong *)(unaff_GS_OFFSET + 0x60) + 0x20) + 0x68),\n                param_3,param_4);\n  return 0;\n}\n</code></pre>\nthere are three pointer arithmetic\n\n(unaff_GS_OFFSET + 0x60)\n(unaff_GS_OFFSET + 0x60) + 0x20)\n(unaff_GS_OFFSET + 0x60) + 0x20) + 0x68)\n\nso there must be three unknown structs/artifacts/something/anything...\nlets start making this ugliness go away by adding structures\nIn DataTypeManager Select the binary -> right click ->new ->structure\n\ncreate a new structure name it as unknown_struct_1 for now\nunder Description add a comment <pre><code>using only offset 0x60</code></pre>\nenter 0x100 arbitrarily as size\ncreate 2 more structs the same way unknown_struct_2\nusing offset 0x20 only\nunknown_struct_3\nusing offset 0x68 only\nedit unknown_struct_1 go to offset 0x60 and embed a pointer to unknown_struct_2 and give a Name say \"Needs Name 1\"\nedit unknown_struct_2 go to offset 0x20 and embed a pointer to unknown_struct_3 and give a Name say \"Needs Name 2\"\nafter this select the longlong type of GS_OFFSET right click and retype the variable as pointer to unknown_struct_1\nthe decompilation will improve to\n<pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  FUN_1400010a0((longlong)&DAT_1400132e0,\n                *(undefined8 *)&unaff_GS_OFFSET->NeedsName_1->NeedsName2->field_0x68,param_3,param_4\n               );\n  return 0;\n}\n</code></pre>\nnow following 1400132e0 you get a tell tale sign of printf format string\n<pre><code>                        DAT_1400132e0                                   XREF[1]:     FUN_140001000:140001029(*)  \n   1400132e0 25                     ??         25h    %\n   1400132e1 53                     ??         53h    S\n   1400132e2 0a                     ??         0Ah\n</code></pre>\ncreate a terminated c string at that address right click -> data -> terminatedcstring\n<pre><code>                         s_%S_1400132e0                                  XREF[1]:     FUN_140001000:140001029(*)  \n   1400132e0 25 53 0a 00            ds         \"%S\n\"\n   1400132e4 00                     ??         00h\n</code></pre>\nthe decompilation will further improve to\n<pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  FUN_1400010a0((longlong)\"%S\n\",\n                *(undefined8 *)&unaff_GS_OFFSET->NeedsName_1->NeedsName2->field_0x68,param_3,param_4\n               );\n  return 0;\n}\n</code></pre>\nchange the function signature of 0x1400010a0 to int __cdecl printf(char * formtstring,...) a vararg function\nyou will have a still better decompilation\n<pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  printf(\"%S\n\",*(undefined8 *)&unaff_GS_OFFSET->NeedsName_1->NeedsName2->field_0x68);\n  return 0;\n}\n</code></pre>\n\nthe format string is %S so it must be printing a wide string (wchar_t *) or probably the buffer in a UNICODE_STRING structure\nlets now go to the unknown_struct_3 at offset 0x68 embed a UNICODE_STRING * and give it a name\n\nnow the decompilation is almost nearer to the final shape\n<pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  printf(\"%S\n\",unaff_GS_OFFSET->NeedsName_1->NeedsName2->Some_wide_string);\n  return 0;\n</code></pre>\nnow after further reverse engineering  you can infer unaff_GS_OFFSET is pointer to _TEB ->\nwhose 0ffset 0x60 Contains pointer to _PEB (Process Environemnt Block) ->\nwhose offset 0x20 contains a pointer to RTL_USER_PROCESS_PARAMETER ->\nwhose offset 0x68 contains a pointer to Unicode_string  ImagePathName  ->\nwhose offset 0x8 contains a pointer to wchar_t\nso we need to shift the UNICODE_STRING * to 0x60 as UNICODE_STRING struct  so that the member Buffer a wchar_t* will be  at offset 0x68.\n<pre><code>0:000> dt ntdll!_TEB ProcessEnvironmentBlock->ProcessParameters->ImagePathName.Buffer\n   +0x060 ProcessEnvironmentBlock                                          :\n      +0x020 ProcessParameters                                                :\n         +0x060 ImagePathName                                                    :\n            +0x008 Buffer                                                           : Ptr64 Wchar\n0:000>\n</code></pre>\njust rename the unknowns and need names\n\nand you have a clean decompilation after changing the function signature of main to int main (void)\n<pre><code>int main(void)\n\n{\n  TEB *MyTeb;\n  \n  printf(\"%S\n\",(MyTeb->ProcessEnvironmentBlock->ProcessParameters->ImagePathName).Buffer);\n  return 0;\n}\n</code></pre>\n",
            "votes": "2",
            "user": "blabb",
            "time": "Aug 25, 2023 at 17:42",
            "is_accepted": false,
            "comments": [
                {
                    "user": "user103675",
                    "text": "<span class=\"comment-copy\">This is a great description of a nice workflow including the definition and assigning of structures. I think I am so far aware of how this works. My requirement is, that I need to assign a defined struct to a register used directly (a0 in this case). Its not a variable on stack or heap or alike.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">You mean you dont want to have a clean decompilation but  disassembly showing. [foo+ blah.bar] instead of [rbp+0x68]. No ghidra doesnt do it at the moment <a href=\"https://github.com/NationalSecurityAgency/ghidra/issues/2303\" rel=\"nofollow noreferrer\">there is an open issue in github iirc requesting such a feature</a></span>",
                    "time": null
                }
            ]
        }
    ]
}