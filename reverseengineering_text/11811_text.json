{
    "title": "How to organize vtables in IDA Pro?",
    "link": "https://reverseengineering.stackexchange.com/questions/11811/how-to-organize-vtables-in-ida-pro",
    "content": "I am using IDA Pro to disassemble a C++ behemoth with 1600+ classes, many of them having pure virtual methods.\nSome classes also are made up of multiple base classes, in hierarchies 5+ levels deep.\nIda PRO supports making structures of pointers, to handle vtables, but some of the final classes can have multiple different vtables in the same \"slot\", due to heavy polymorphism, so how you organize the vtables? How you tell IDA that in this method, or that method, what vtable is actually being refered to?\n",
    "votes": "23",
    "answers": 1,
    "views": "21k",
    "tags": [
        "ida",
        "c++",
        "hexrays"
    ],
    "user": "speeder",
    "time": "Jan 20, 2016 at 18:29",
    "comments": [
        {
            "user": "Jongware",
            "text": "Funny enough I solved this once for a class heavy executable by writing my own disassembler. At its current state it can gather class members and functions from several DLLs. But not a general solution: the code relies extremely on the particular compiler the code was written with.\n",
            "time": null
        },
        {
            "user": "speeder",
            "text": "Why I was downvoted?\n",
            "time": null
        },
        {
            "user": "sudhackar",
            "text": "Athough this question is quite old try using HexRaysPyTools for hexrays\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "This depends on the compiler originally used as each creates slightly different layouts. You can find tutorials for most compilers on the net, I'm going to focus MSVC as that's the one I have experience with, and since it provides a hidden compiler switch printing how classes will be layouted in memory which I'm going to use for illustration.\nAs you might have already guessed, you have to recreate C++ classes with C structs. This is possible but bothersome, especially if you have as many classes as you said. Some tips to make it less annoying:\n\nFocus the ones you're interested in.\nStart with the \"base-most\" classes, e.g. the ones at the top of the hierarchy tree. If you mess up something there, fixing it can be expensive later on:; imagine adding a forgotten member to something like a smart pointer base class which is inherited by hundreds of classes, and now you have to adjust all of those.\nYou may want to define the <pre><code>struct</code></pre>s with C like code in the Local Types subview first and not in the Structures subview. The following samples can be pasted as local types.\nIf you're unsure about reversing a struct, a constructor typically spoils the vftable and the layout of some members; a function calling it may yield the total size of the object by reserving enough bytes for it.\n\n\n\nIDA 7.0 helps you a lot by automatically recognizing and marking RTTI data (if available) which spoils the class hierarchy and vftables, but it incorrectly marks which vftable belongs to which base class in case of multiple inheritance, an issue the IDA6 script it is based on didn't have. I rewrote it in IDAPython for 7.0 to fix this and other MSVC related issues, it can also automatically create the structs as explained below.\nIDA 7.2 has even better support for automatically detecting and recreating C++ structures, but the following answer was written with 7.0 in mind and using 7.2 naming.\n\n\nDepending on how fancy your polymorphism is, your C structs have to be more or less fancy aswell. So let's start with the simple cases first and work our way to the more complicated ones.\n\nNo inheritance (base class)\nThe simplest case does not use any inheritance at all, only some members and (pure) virtual methods to start with:\n<pre><code>class Animal {\n    int _age;\n    Animal() { _age = 0; }\n    int getAge() { return _age; }\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() = 0;\n};\n</code></pre>\nMSVC layout:\n<pre><code>class Animal    size(8):\n        +---\n 0      | {vfptr} // pointer to the vftable (s. below)\n 4      | _age    // members of Animal\n        +---\n\nAnimal::$vftable@:\n        | &Animal_meta    // ignore meta for our examples\n        |  0              // the (pure) virtual method follow\n 0      | &Animal::setAge    \n 1      | &Animal::makeSound\n</code></pre>\nIDA representation:\n<pre><code>struct Animal;\nstruct Animal_vtbl {\n  void (__thiscall *setAge)(Animal *this, int value);\n  void (__thiscall *makeSound)(Animal *this);\n};\nstruct Animal_mbrs {\n  int _age;\n};\nstruct Animal {\n  Animal_vtbl *__vftable;\n  Animal_mbrs __members;\n};\n</code></pre>\n\n\nForward declare the class struct to use it in the <pre><code>this</code></pre> parameter of the vftable.\nMSVC uses the <pre><code>__thiscall</code></pre> calling convention by default to create class methods. It implicitly passes a pointer to the class instance in the <pre><code>ecx</code></pre> register besides all other parameters.\nIt is not required to provide names for the parameters.\n<pre><code>makeSound</code></pre> will be a <pre><code>purecall</code></pre>, and <pre><code>setAge</code></pre> will be a typical unknown sub modifying our member.\nPlace members in a separate structure for inheritance (s. below).\n\n\n\nSingle inheritance\nLet's quickly breed a <pre><code>Dog</code></pre> inheriting from <pre><code>Animal</code></pre>, implement the <pre><code>makeSound</code></pre> method, and add a new virtual method to set the fur color:\n<pre><code>class Dog : public Animal {\n    int _furColor;\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() { cout << \"Woof Woof\"; }\n    virtual void setFurColor(int color) { _furColor = color; }\n};\n</code></pre>\nMSVC layout: The <pre><code>Animal</code></pre> base class is simply embedded inside the <pre><code>Dog</code></pre> class. The embedded <pre><code>Animal</code></pre> vftable also grabs all the virtual <pre><code>Dog</code></pre> methods and adds them at its end. The members of <pre><code>Dog</code></pre> appear behind <pre><code>Animal</code></pre>s members:\n<pre><code>class Dog       size(12):\n        +---\n 0      | +--- (base class Animal)\n 0      | | {vfptr}\n 4      | | _age\n        | +---\n 8      | _furColor\n        +---\n\nDog::$vftable@:\n        | &Dog_meta\n        |  0\n 0      | &Dog::setAge\n 1      | &Dog::makeSound\n 2      | &Dog::setFurColor // Added behind the Animal methods!\n</code></pre>\nIDA representation: Leaving <pre><code>Animal</code></pre> structures untouched, we add the following:\n<pre><code>struct Dog;\nstruct Dog_vtbl : Animal_vtbl {\n  void (__thiscall *setFurColor)(Dog *this, int color);\n};\nstruct Dog_mbrs : Animal_mbrs {\n  int _furColor;\n};\nstruct Dog {\n  Dog_vtbl *__vftable;\n  Dog_mbrs __members;\n};\n</code></pre>\n\n\nReuse the <pre><code>Animal</code></pre> vftable by letting the <pre><code>Dog</code></pre> vftable inherit from it (inheriting a struct in IDA simply means prepending it), then add the <pre><code>Dog</code></pre> specific virtual functions.\nThe same thing happens with the members, which is why I separated them earlier.\n\n\n\nMultiple inheritance\nThis requires a bit of mind-mangling. For this, we make it possible to kill our dog (sorry if that's cruel to you, I'm bad at creating happy examples):\n<pre><code>class Killable {\n    bool _isDead;\n    virtual void kill() { makeDeathSound(); _isDead = true; }\n    virtual void makeDeathSound() = 0;\n};\n\nclass Dog : public Animal, public Killable {\n    int _furColor;\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() { cout << \"Woof Woof\"; }\n    virtual void setFurColor(int color) { _furColor = color; }\n    virtual void makeDeathSound() { cout << \"I'll call WWF, bark-blerg\"; }\n};\n</code></pre>\nMSVC layout: As with the <pre><code>Animal</code></pre> base class, it embeds the second <pre><code>Killable</code></pre> base class into the <pre><code>Dog</code></pre> class aswell, and keeps <pre><code>Dog</code></pre>s members separate. While <pre><code>Dog</code></pre>-specific virtual methods are still merged with the <pre><code>Animal</code></pre> vftable (aka the first base class), <pre><code>Killable</code></pre> related ones are in a separate <pre><code>Killable</code></pre>-related vftable, so we now have:\n<pre><code>class Dog       size(20):\n        +---\n 0      | +--- (base class Animal)\n 0      | | {vfptr}\n 4      | | _age\n        | +---\n 8      | +--- (base class Killable)\n 8      | | {vfptr}\n12      | | _isDead\n        | | <alignment member> (size=3) // since _isDead is a 1-byte bool\n        | +---\n16      | _furColor\n        +---\n\nDog::$vftable@Animal@:\n        | &Dog_meta\n        |  0\n 0      | &Dog::setAge\n 1      | &Dog::makeSound\n 2      | &Dog::setFurColor // Dog methods still merged with Animal!\n\nDog::$vftable@Killable@: // All the Killable-related methods in here\n        | -8 // offset for `this` pointer in Killable methods to get a Dog pointer\n 0      | &Killable::kill\n 1      | &Dog::makeDeathSound\n</code></pre>\nIDA representation: We keep a <pre><code>Dog</code></pre>-specific vftable at the start which reuses the <pre><code>Animal</code></pre> vftable internally, as the <pre><code>Dog</code></pre> virtual methods are still appended to <pre><code>Animal</code></pre>s vftable. Then <pre><code>Animal</code></pre>s members follow as usual. Now, the untouched <pre><code>Killable</code></pre> structs follow, since nothing gets merged into them. At the end, our <pre><code>Dog</code></pre> members follow. If you compare this to the offsets MSVC printed, it makes sense:\n<pre><code>struct Killable;\nstruct Killable_vtbl {\n    void (__thiscall *kill)(Killable *this);\n    void (__thiscall *makeDeathSound)(Killable *this);\n};\nstruct Killable_mbrs {\n    bool _isDead;\n};\nstruct Killable {\n  Killable_vtbl* __vftable;\n  Killable_mbrs __members;\n};\n\nstruct Dog;\nstruct Dog_vtbl : Animal_vtbl {\n  void (__thiscall *setFurColor)(Dog *this, int color);\n};\nstruct Dog_mbrs { // No more base Animal members as they're split up now!\n  int _furColor; \n};\nstruct Dog {\n  Dog_vtbl *__vftable; // Still contains animal methods.\n  Animal_mbrs __members_Animal; // Animal members come here separately.\n  Killable_vtbl *__vftable_Killable;\n  Killable_mbrs __members_Killable;\n  Dog_mbrs __members;\n};\n</code></pre>\n\nIDA 7.2 uses slightly different naming for vftables participating in multiple inheritance. I find it bothersome to deal with manually, so we won't use it here.\n\nLet's see how this looks like in the <pre><code>Dog::ctor</code></pre> pseudocode:\n<pre><code>Dog *__thiscall Dog::ctor(Dog *this)\n{\n  j_Animal::ctor((Animal *)this);\n  j_Killable::ctor((Killable *)&this->__vftable_Killable);\n  this->__vftable = (Dog_vftable *)&Dog::`vftable';\n  this->__vftable_Killable = (Killable_vftable *)&Dog::`vftable';\n  return this;\n}\n</code></pre>\nAs typical for constructors, the base class constructors are called first. Then, the vftables required for <pre><code>Dog</code></pre> are set. But something doesn't make sense: Why is <pre><code>Dog::vftable</code></pre> assigned to our <pre><code>__vftable_Killable</code></pre>? Well, I used IDA 7.0's naming here, and what I previously mentioned is that it doesn't mark which vftable maps to which base class anymore (unlike the script). With the IDA 6.0 or my IDAPython script, it would say:\n<pre><code>Dog *__thiscall Dog::ctor(Dog *this)\n{\n  j_Animal::ctor((Animal *)this);\n  j_Killable::ctor((Killable *)&this->__vftable_Killable);\n  this->__vftable = (Dog_vftable *)&Dog::`vftable for Animal';\n  this->__vftable_Killable = (Killable_vftable *)&Dog::`vftable for Killable';\n  return this;\n}\n</code></pre>\nNow the names aren't the same and make more sense, so don't get busted by this IDA 7 annoyance, double click the names to check where they'll actually lead.\n\nI do not recommend setting the actual type of the vftables to their locations / names: You get nothing out of it, it just makes the disassembly output messy.\n\n\nBonus: Classes inherited from classes using multiple inheritance (wew)\nThis one kept me a little baffled for some time, maybe because it's not covered in most tutorials on the net on which I so rely on, or maybe because I'm just dumb. Let's inherit from <pre><code>Dog</code></pre> with our <pre><code>Terrier</code></pre> class.\n<pre><code>class Terrier : public Dog {\n    int _annoyanceLevel;\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() { cout << \"Bark Bark not Woof Woof\"; }\n    virtual void annoy() { _annoyanceLevel++; }\n};\n</code></pre>\nMSVC layout: It doesn't seem too special. The <pre><code>Animal</code></pre> vftable still merges the new virtual methods of our <pre><code>Terrier</code></pre>, and everything else has its separate vftable:\n<pre><code>class Terrier   size(24):\n        +---\n 0      | +--- (base class Dog)\n 0      | | +--- (base class Animal)\n 0      | | | {vfptr}\n 4      | | | _age\n        | | +---\n 8      | | +--- (base class Killable)\n 8      | | | {vfptr}\n12      | | | _isDead\n        | | | <alignment member> (size=3)\n        | | +---\n16      | | _furColor\n        | +---\n20      | _annoyanceLevel\n        +---\n\nTerrier::$vftable@Animal@:\n        | &Terrier_meta\n        |  0\n 0      | &Terrier::setAge\n 1      | &Terrier::makeSound\n 2      | &Dog::setFurColor\n 3      | &Terrier::annoy // Animal even takes the Terrier methods (greedy!)\n\nTerrier::$vftable@Killable@:\n        | -8\n 0      | &Killable::kill\n 1      | &Dog::makeDeathSound\n</code></pre>\nIDA representation: It's pretty similar to our first <pre><code>Dog</code></pre> struct creation, just that we need to respect the second base class of <pre><code>Dog</code></pre> aswell.\n<pre><code>struct Terrier_vtbl : Dog_vtbl {\n  void (__thiscall *annoy)(Terrier *this);\n};\nstruct Terrier_mbrs : Dog_mbrs {\n  int _annoyanceLevel;\n};\nstruct Terrier {\n  Terrier_vtbl *__vftable;\n  Animal_mbrs __members_Animal;\n  Killable_vtbl *__vftable_Killable;\n  Killable_mbrs __members_Killable;\n  Terrier_mbrs __members;\n};\n</code></pre>\n",
            "votes": "39",
            "user": "Ray",
            "time": "Mar 16, 2023 at 10:35",
            "is_accepted": false,
            "comments": [
                {
                    "user": "savram",
                    "text": "<span class=\"comment-copy\">Is \"__thiscall\" necessary to work?</span>",
                    "time": null
                },
                {
                    "user": "Trass3r",
                    "text": "<span class=\"comment-copy\">For reference here's what 7.2+ generates: <a href=\"https://www.hex-rays.com/products/ida/support/idadoc/1691.shtml\" rel=\"nofollow noreferrer\">hex-rays.com/products/ida/support/idadoc/1691.shtml</a></span>",
                    "time": null
                }
            ]
        }
    ]
}