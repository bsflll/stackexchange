{
    "title": "Meaning of Flags in ELF Section header?",
    "link": "https://reverseengineering.stackexchange.com/questions/21460/meaning-of-flags-in-elf-section-header",
    "content": "Given this classic <pre><code>helloworld.c</code></pre> example,\n<pre><code>#include <stdio.h>\n\nint main() {\n    printf(\"Hello world!\n\");\n}\n</code></pre>\nIn below <pre><code>sections</code></pre> output, the value for <pre><code>Flags</code></pre> presents a couple of different values, e.g. <pre><code>A</code></pre>, <pre><code>AI</code></pre>, <pre><code>AX</code></pre>, <pre><code>WA</code></pre>, etc.\nFrom man elf, I understand <pre><code>A</code></pre> probably corresponds to <pre><code>SHF_ALLOC</code></pre>, <pre><code>W</code></pre> for <pre><code>SHF_WRITE</code></pre>, <pre><code>X</code></pre> for <pre><code>SHF_EXECINSTR</code></pre>. But how about <pre><code>AI</code></pre>? \nIs the correspondence between  those long and short forms documented?\n<pre><code>$ readelf -S helloworld\n\nThere are 34 section headers, starting at offset 0x2188:\n\nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .interp           PROGBITS         0000000000000238  00000238\n       000000000000001c  0000000000000000   A       0     0     1\n  [ 2] .note.ABI-tag     NOTE             0000000000000254  00000254\n       0000000000000020  0000000000000000   A       0     0     4\n  [ 3] .note.gnu.build-i NOTE             0000000000000274  00000274\n       0000000000000024  0000000000000000   A       0     0     4\n  [ 4] .gnu.hash         GNU_HASH         0000000000000298  00000298\n       000000000000001c  0000000000000000   A       5     0     8\n  [ 5] .dynsym           DYNSYM           00000000000002b8  000002b8\n       00000000000000a8  0000000000000018   A       6     1     8\n  [ 6] .dynstr           STRTAB           0000000000000360  00000360\n       0000000000000082  0000000000000000   A       0     0     1\n  [ 7] .gnu.version      VERSYM           00000000000003e2  000003e2\n       000000000000000e  0000000000000002   A       5     0     2\n  [ 8] .gnu.version_r    VERNEED          00000000000003f0  000003f0\n       0000000000000020  0000000000000000   A       6     1     8\n  [ 9] .rela.dyn         RELA             0000000000000410  00000410\n       00000000000000c0  0000000000000018   A       5     0     8\n  [10] .rela.plt         RELA             00000000000004d0  000004d0\n       0000000000000018  0000000000000018  AI       5    22     8\n  [11] .init             PROGBITS         00000000000004e8  000004e8\n       0000000000000017  0000000000000000  AX       0     0     4\n  [12] .plt              PROGBITS         0000000000000500  00000500\n       0000000000000020  0000000000000010  AX       0     0     16\n  [13] .plt.got          PROGBITS         0000000000000520  00000520\n       0000000000000008  0000000000000008  AX       0     0     8\n  [14] .text             PROGBITS         0000000000000530  00000530\n       00000000000001a2  0000000000000000  AX       0     0     16\n  [15] .fini             PROGBITS         00000000000006d4  000006d4\n       0000000000000009  0000000000000000  AX       0     0     4\n  [16] .rodata           PROGBITS         00000000000006e0  000006e0\n       0000000000000011  0000000000000000   A       0     0     4\n  [17] .eh_frame_hdr     PROGBITS         00000000000006f4  000006f4\n       000000000000003c  0000000000000000   A       0     0     4\n  [18] .eh_frame         PROGBITS         0000000000000730  00000730\n       0000000000000108  0000000000000000   A       0     0     8\n  [19] .init_array       INIT_ARRAY       0000000000200db8  00000db8\n       0000000000000008  0000000000000008  WA       0     0     8\n  [20] .fini_array       FINI_ARRAY       0000000000200dc0  00000dc0\n       0000000000000008  0000000000000008  WA       0     0     8\n  [21] .dynamic          DYNAMIC          0000000000200dc8  00000dc8\n       00000000000001f0  0000000000000010  WA       6     0     8\n  [22] .got              PROGBITS         0000000000200fb8  00000fb8\n       0000000000000048  0000000000000008  WA       0     0     8\n  [23] .data             PROGBITS         0000000000201000  00001000\n       0000000000000010  0000000000000000  WA       0     0     8\n  [24] .bss              NOBITS           0000000000201010  00001010\n       0000000000000008  0000000000000000  WA       0     0     1\n\nMore following...\n</code></pre>\n\nLet's dump the section header table in binary to see what's actually stored in place of the <pre><code>Flags</code></pre>,\n<pre><code>hexdump -v -s 0x2188 -n 768 -e '4/1 \"%02x\" \" \" 4/1 \"%02x\" \" \" 8/1 \"%02x\" \" \" 48/1 \"%02x\" \"\n\"' helloworld</code></pre>\n\nAs per <pre><code>Elf64_Shdr</code></pre> struct, the 3rd column in the following output is\n  the binary form of flags(<pre><code>sh_flags</code></pre>).\n\n<pre><code>00000000 00000000 0000000000000000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1b000000 01000000 0200000000000000 380200000000000038020000000000001c00000000000000000000000000000001000000000000000000000000000000\n23000000 07000000 0200000000000000 540200000000000054020000000000002000000000000000000000000000000004000000000000000000000000000000\n31000000 07000000 0200000000000000 740200000000000074020000000000002400000000000000000000000000000004000000000000000000000000000000\n44000000 f6ffff6f 0200000000000000 980200000000000098020000000000001c00000000000000050000000000000008000000000000000000000000000000\n4e000000 0b000000 0200000000000000 b802000000000000b802000000000000a800000000000000060000000100000008000000000000001800000000000000\n56000000 03000000 0200000000000000 600300000000000060030000000000008200000000000000000000000000000001000000000000000000000000000000\n5e000000 ffffff6f 0200000000000000 e203000000000000e2030000000000000e00000000000000050000000000000002000000000000000200000000000000\n6b000000 feffff6f 0200000000000000 f003000000000000f0030000000000002000000000000000060000000100000008000000000000000000000000000000\n7a000000 04000000 0200000000000000 10040000000000001004000000000000c000000000000000050000000000000008000000000000001800000000000000\n84000000 04000000 4200000000000000 d004000000000000d0040000000000001800000000000000050000001600000008000000000000001800000000000000\n8e000000 01000000 0600000000000000 e804000000000000e8040000000000001700000000000000000000000000000004000000000000000000000000000000\n</code></pre>\n\nAs a combination of above two outputs, the following correspondence between the flag's binary form and the literal form is observed.\n<pre><code>02 = 0000 0010 = A\n42 = 0100 0010 = AI\n06 = 0000 0110 = AX\n</code></pre>\nAre these correspondences documented?\n",
    "votes": "6",
    "answers": 2,
    "views": "5k",
    "tags": [
        "elf"
    ],
    "user": "Jiaming",
    "time": "Jun 11, 2019 at 10:51",
    "comments": [],
    "answers_data": [
        {
            "content": "The flag abbreviation of the letter \"I\" stands for <pre><code>SHF_INFO_LINK</code></pre>.\nSince <pre><code>readelf</code></pre> is open-source you can access its code to verify this. This will also show you the full list of Flag possibilities:\n<pre><code>...\n\nswitch (flag)\n        {\n        case SHF_WRITE:     *p = 'W'; break;\n        case SHF_ALLOC:     *p = 'A'; break;\n        case SHF_EXECINSTR:     *p = 'X'; break;\n        case SHF_MERGE:     *p = 'M'; break;\n        case SHF_STRINGS:       *p = 'S'; break;\n        case SHF_INFO_LINK:     *p = 'I'; break;\n        case SHF_LINK_ORDER:    *p = 'L'; break;\n        case SHF_OS_NONCONFORMING:  *p = 'O'; break;\n        case SHF_GROUP:     *p = 'G'; break;\n        case SHF_TLS:       *p = 'T'; break;\n        case SHF_EXCLUDE:       *p = 'E'; break;\n        case SHF_COMPRESSED:    *p = 'C'; break;\n        case SHF_GNU_MBIND:     *p = 'D'; break;\n\n...\n</code></pre>\nThe relevant lines on Github can be found in the following link.\n",
            "votes": "8",
            "user": "Megabeets",
            "time": "Jun 11, 2019 at 13:10",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "From the readelf output for section headers:\nKey to Flags:\nW (write), A (alloc), X (execute), M (merge), S (strings)\nI (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\nO (extra OS processing required) o (OS specific), p (processor specific)\n",
            "votes": "2",
            "user": "rizwan",
            "time": "Aug 11, 2020 at 18:31",
            "is_accepted": false,
            "comments": []
        }
    ]
}