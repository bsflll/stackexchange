{
    "title": "Why is there no call to strcpy in assembly?",
    "link": "https://reverseengineering.stackexchange.com/questions/23538/why-is-there-no-call-to-strcpy-in-assembly",
    "content": "I try to better understand assembly and currently playing around with some compiled c snippets.\nI have the following snippet:\n<pre><code>#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char b[] = \" a nice nice long string\";\n\n    char c[100];\n    strcpy(c, b);\n    printf(\"Hello World %s\n\", c);\n    strcpy(c, \" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n}\n</code></pre>\nAfter compiling it with <pre><code>gcc hello_world.c -o hello_world</code></pre> and opening it in gdb the assembly code of the main function looks like this:\n<pre><code>   0x00000000000006fa <+0>:     push   rbp\n   0x00000000000006fb <+1>:     mov    rbp,rsp\n   0x00000000000006fe <+4>:     sub    rsp,0x90\n   0x0000000000000705 <+11>:    mov    rax,QWORD PTR fs:0x28\n   0x000000000000070e <+20>:    mov    QWORD PTR [rbp-0x8],rax\n   0x0000000000000712 <+24>:    xor    eax,eax\n   0x0000000000000714 <+26>:    movabs rax,0x206563696e206120\n   0x000000000000071e <+36>:    movabs rdx,0x6e6f6c206563696e\n   0x0000000000000728 <+46>:    mov    QWORD PTR [rbp-0x90],rax\n   0x000000000000072f <+53>:    mov    QWORD PTR [rbp-0x88],rdx\n   0x0000000000000736 <+60>:    movabs rax,0x676e697274732067\n   0x0000000000000740 <+70>:    mov    QWORD PTR [rbp-0x80],rax\n   0x0000000000000744 <+74>:    mov    BYTE PTR [rbp-0x78],0x0\n   0x0000000000000748 <+78>:    lea    rdx,[rbp-0x90]\n   0x000000000000074f <+85>:    lea    rax,[rbp-0x70]\n   0x0000000000000753 <+89>:    mov    rsi,rdx\n   0x0000000000000756 <+92>:    mov    rdi,rax\n   0x0000000000000759 <+95>:    call   0x5b0 <strcpy@plt>\n   0x000000000000075e <+100>:   lea    rax,[rbp-0x70]\n   0x0000000000000762 <+104>:   mov    rsi,rax\n   0x0000000000000765 <+107>:   lea    rdi,[rip+0xe8]        # 0x854\n   0x000000000000076c <+114>:   mov    eax,0x0\n   0x0000000000000771 <+119>:   call   0x5d0 <printf@plt>\n   0x0000000000000776 <+124>:   lea    rax,[rbp-0x70]\n   0x000000000000077a <+128>:   movabs rsi,0x4141414141414120\n   0x0000000000000784 <+138>:   movabs rdi,0x4141414141414141\n   0x000000000000078e <+148>:   mov    QWORD PTR [rax],rsi\n   0x0000000000000791 <+151>:   mov    QWORD PTR [rax+0x8],rdi\n   0x0000000000000795 <+155>:   movabs rdx,0x4141414141414141\n   0x000000000000079f <+165>:   movabs rcx,0x4141414141414141\n   0x00000000000007a9 <+175>:   mov    QWORD PTR [rax+0x10],rdx\n   0x00000000000007ad <+179>:   mov    QWORD PTR [rax+0x18],rcx\n   0x00000000000007b1 <+183>:   mov    BYTE PTR [rax+0x20],0x0\n   0x00000000000007b5 <+187>:   mov    eax,0x0\n   0x00000000000007ba <+192>:   mov    rcx,QWORD PTR [rbp-0x8]\n   0x00000000000007be <+196>:   xor    rcx,QWORD PTR fs:0x28\n   0x00000000000007c7 <+205>:   je     0x7ce <main+212>\n   0x00000000000007c9 <+207>:   call   0x5c0 <__stack_chk_fail@plt>\n   0x00000000000007ce <+212>:   leave\n   0x00000000000007cf <+213>:   ret\n</code></pre>\nI think i understand which part is doing what. \nBut some things are not clear to me.\n\nstrcpy is only called once and only when the second argument is a variable. Why is ther no call for the second strcopy?\nprintf is called with a string and a second arg. The string is loaded from rip+0xe8. Why is the string provided to the second strcopy not loaded in the same fashion? It is \"hardcoded\" with in the moveabs instructions.\n\nIs this due to some compiler optimization? Can someone elaborate?\n",
    "votes": "2",
    "answers": 1,
    "views": "761",
    "tags": [
        "assembly",
        "c",
        "gdb"
    ],
    "user": "joachim",
    "time": "Mar 26, 2020 at 15:26",
    "comments": [],
    "answers_data": [
        {
            "content": "<pre><code>import binascii\nprint(binascii.hexlify(b\" a nice nice long string\"))\nprint(binascii.hexlify(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"))\n</code></pre>\nyou can find both the string in your listing \n<pre><code>b'2061206e696365206e696365206c6f6e6720737472696e67'\nb'41414141414141414141414141414141414141414141414141414141414141'\n</code></pre>\nfirst string\n<pre><code>0x0000000000000714 <+26>:    movabs rax,0x206563696e206120\n0x000000000000071e <+36>:    movabs rdx,0x6e6f6c206563696e\n0x0000000000000736 <+60>:    movabs rax,0x676e697274732067\n</code></pre>\nsecond string \n<pre><code> 0x000000000000077a <+128>:   movabs rsi,0x4141414141414120\n 0x0000000000000784 <+138>:   movabs rdi,0x4141414141414141\n 0x000000000000078e <+148>:   mov    QWORD PTR [rax],rsi\n 0x0000000000000791 <+151>:   mov    QWORD PTR [rax+0x8],rdi\n 0x0000000000000795 <+155>:   movabs rdx,0x4141414141414141\n 0x000000000000079f <+165>:   movabs rcx,0x4141414141414141\n</code></pre>\nfirst time you give it an address which is unknown at compile time so compiler is forced to use the function (dynamic arguments)   \nsecond time you give a CONSTANT String which can be split and put into the c\n(static argument)   \nor if you provide a very very big string it can take the address and do a repmovsq    \n<pre><code>strcpy(d, \" lshdgfdghsdfghsdfghsdfhgsdfhgsdfhgshsfur4tye36346asdgxzcvgaewt34t sg afeaerwbhtyhswrtwqee5t6e67redhfdxbw45bh hhjljuhlfjsdhlksjdghsdlkjfhgsldkjfghlskjdghlkjsdhggkjsdhgksdjhgskdjhglsdkjhgfskjdhfgsdkjhfgkjsdfhgskdjhfgsdk;ljhg;djkgsjhg;dsljkhf;ljg;dljg;jh\");\n}\n</code></pre>\nusing repmovsq\n<pre><code>mov     eax, OFFSET FLAT:.LC1\nmov     ecx, 31\nmov     rdi, rdx\nmov     rsi, rax\nrep movsq\n\n.LC1:\n        .string \" lshd\n</code></pre>\njust to confirm remove the b[] = line and put strcpy(c,const string ); you will see the compiler has eliminated the .plt entry also and will convert the \nstrcpy to __builtin_memcpy()\n<pre><code> __builtin_memcpy (&c, \" a nice nice long string\", 25);\n  printf (\"Hello World %s\n\", &c);\n  __builtin_memcpy (&c, \" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", 33);\n</code></pre>\ncompile with -fno-builtin and you will get both strcpy\n<pre><code>.LC0:\n        .string \"Hello World %s\n\"\n.LC1:\n        .string \" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\nmain:\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 144\n        movabs  rax, 2334381286331801888\n        movabs  rdx, 7957697952982722926\n        mov     QWORD PTR [rbp-32], rax\n        mov     QWORD PTR [rbp-24], rdx\n        movabs  rax, 7453010373645639783\n        mov     QWORD PTR [rbp-16], rax\n        mov     BYTE PTR [rbp-8], 0\n        lea     rdx, [rbp-32]\n        lea     rax, [rbp-144]\n        mov     rsi, rdx\n        mov     rdi, rax\n        call    strcpy\n        lea     rax, [rbp-144]\n        mov     rsi, rax\n        mov     edi, OFFSET FLAT:.LC0\n        mov     eax, 0\n        call    printf\n        lea     rax, [rbp-144]\n        mov     esi, OFFSET FLAT:.LC1\n        mov     rdi, rax\n        call    strcpy\n        mov     eax, 0\n        leave\n        ret\n</code></pre>\nyou can read about various other __builtins here\n",
            "votes": "4",
            "user": "blabb",
            "time": "Mar 26, 2020 at 18:41",
            "is_accepted": false,
            "comments": []
        }
    ]
}