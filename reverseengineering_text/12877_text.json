{
    "title": "Simple main program",
    "link": "https://reverseengineering.stackexchange.com/questions/12877/simple-main-program",
    "content": "I got an x86 binary for linux and I use gdb to disassemble the main function. I see this:\n<pre><code>   0x08048080 <+0>:     push   0x8049128\n   0x08048085 <+5>:     call   0x804810f\n   0x0804808a <+10>:    call   0x804809f\n   0x0804808f <+15>:    cmp    eax,0x10f\n   0x08048094 <+20>:    je     0x80480dc\n   0x0804809a <+26>:    call   0x8048103\n</code></pre>\nI could not understand it since the regular main that I disassemble normally looks like the one below with some preambles.\n<pre><code>   0x0804841d <+0>:     push   %ebp\n   0x0804841e <+1>:     mov    %esp,%ebp\n   0x08048420 <+3>:     and    $0xfffffff0,%esp\n   0x08048423 <+6>:     sub    $0x10,%esp\n   0x08048426 <+9>:     movl   $0x80484d0,(%esp)\n   0x0804842d <+16>:    call   0x80482f0 <puts@plt>\n   0x08048432 <+21>:    leave  \n   0x08048433 <+22>:    ret    \n</code></pre>\nQuestions:\nCan someone explain the first disassembly?\n",
    "votes": "0",
    "answers": 1,
    "views": "215",
    "tags": [
        "disassembly",
        "x86"
    ],
    "user": "drdot",
    "time": "Jun 18, 2016 at 5:41",
    "comments": [
        {
            "user": "Guntram Blohm",
            "text": "How do you know the first disassembly is the main function?\n",
            "time": null
        },
        {
            "user": "drdot",
            "text": "(gdb) disassemble main\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "This looks like a normal main function. Its just that your addresses have not been resolved properly in the first disassembly, while they have been in the second one. You can do \n<pre><code>info symbol 0x804810f</code></pre> \nin  gdb and it would output something like\n<pre><code>puts in section .lib</code></pre>\nThis way you can resolve all the functions being called. Alternatively you can use the <pre><code>nm</code></pre> utility.\nThe second disassembly has prolog and epilog for stack management and function returns because it has been auto generated by the compiler. However in the first disassembly, it looks like the program author assembled the file with nasm and author used minimal code to do so.\n",
            "votes": "1",
            "user": "sudhackar",
            "time": "Jun 18, 2016 at 7:04",
            "is_accepted": true,
            "comments": [
                {
                    "user": "drdot",
                    "text": "<span class=\"comment-copy\">This really helps. I have resolved all the function names in this program. However, I still dont understand \"push   $0x8049128\". Is this pushing the ebp? if it is, why is ebp a fix value and how did the programmer find out this fix value?</span>",
                    "time": null
                },
                {
                    "user": "drdot",
                    "text": "<span class=\"comment-copy\">Another question: The first call resolves to function puts, the second call resolves to fscanf. je resolves to YouWin. The last call resolves to exit. fscanf requires a file pointer normally created by fopen. Why I dont see a call to fopen in this program?</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">Stdin maybe did you try providing say i waaana winnnn and chek a compare</span>",
                    "time": null
                },
                {
                    "user": "sudhackar",
                    "text": "<span class=\"comment-copy\">@dannycrane The function parameters are passed on to the stack. So \"push 0x8049128\" will push 0x8049128 to the stack which is probably address of a string in the memory, as a parameter to puts. So is something like puts(0x8049128).</span>",
                    "time": null
                }
            ]
        }
    ]
}