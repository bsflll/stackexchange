{
    "title": "Trying to understand this interrupted (?) function prologue",
    "link": "https://reverseengineering.stackexchange.com/questions/30969/trying-to-understand-this-interrupted-function-prologue",
    "content": "Note: The uninterrupted disassembly is at the bottom\nHey, I'm looking at the the assembly and I'm trying to reverse engineer the function\nHere, it seems like we are saving the previous <pre><code>rbp</code></pre>. Though, it seems like there is no new value for <pre><code>rbp</code></pre>\n<pre><code>0x004010b0      push    rbp\n</code></pre>\nWe are clearing the <pre><code>xmm0</code></pre> registers\n<pre><code>0x004010b1      pxor    xmm0, xmm0\n</code></pre>\nMoving <pre><code>0x40202c</code></pre> into <pre><code>rdi</code></pre> for the call <pre><code>fgets</code></pre>. This would be the first argument. If I were to view the address at <pre><code>0x40402c</code></pre>, I would see the string <pre><code>Input</code></pre>\n<pre><code>0x004010b5      lea     rdi, str.Input: ; 0x40202c ; const char *s\n</code></pre>\nMaking room for local variables, but it seems odd to be doing it after the <pre><code>lea</code></pre> and <pre><code>pxor</code></pre>. So the previous stack frame never de-alloacted so we just increased it by much larger\n<pre><code>0x004010bc      sub     rsp, 0x50\n</code></pre>\nMoving the <pre><code>xmm0</code></pre> onto the top of stack. I don't think I've ever seen an <pre><code>xmmword</code></pre> before. I also imagine this is a local variable.\n<pre><code>0x004010c0      movaps  xmmword [rsp], xmm0\n</code></pre>\nAh, here's the rest of prologue! We are setting the value of <pre><code>rbp</code></pre> to <pre><code>rsp</code></pre> so the stack frame is <pre><code>0</code></pre>\n<pre><code>0x004010c4      mov     rbp, rsp\n</code></pre>\nCreating local variables!\n<pre><code>0x004010c7      movaps  xmmword [rsp + 0x10], xmm0\n0x004010cc      movaps  xmmword [rsp + 0x20], xmm0\n0x004010d1      movaps  xmmword [rsp + 0x20], xmm0\n</code></pre>\nAssigning a loval variable <pre><code>0</code></pre>. Because it is a byte, it is probably a char\n<pre><code>0x004010d6      mov     byte [rsp + 0x40], 0\n</code></pre>\nWe passed <pre><code>Input</code></pre> into <pre><code>rdi</code></pre> and called puts so we outputted <pre><code>Input</code></pre>\n<pre><code>0x004010db      call    puts       \n</code></pre>\nArguments are passed into <pre><code>rdi</code></pre>, <pre><code>rsi</code></pre>, and <pre><code>rdx</code></pre>. So we have: <pre><code>fgets(rbp, 0x41, stdin)</code></pre>.\nIt's also worth nothing that <pre><code>rbp</code></pre> is probably the buffer and we passed <pre><code>0x41</code></pre> as the size which is a large buffer. The stack frame is <pre><code>0</code></pre> because we only recently moved the value of <pre><code>rsp</code></pre> into <pre><code>rbp</code></pre>. (i.e., <pre><code>rbp = rsp</code></pre>).\nAnd we did not not allocated space after the <pre><code>mov rbp, rsp</code></pre>.\n<pre><code>0x004010e0      mov     rdx, qword [stdin] ; 0x404090 ; FILE *stream\n0x004010e7      mov     esi, 0x41 \n0x004010ec      mov     rdi, rbp   \n0x004010ef      call    fgets     \n</code></pre>\n<pre><code>rbp</code></pre> was the buffer so we're moving the string into the first argument. The buffer might have been 65, but the char array could have terminated before that so the string length could have shorter.\n<pre><code>0x004010f4      mov     rdi, rbp \n0x004010f7      call    strlen  \n</code></pre>\nPass the string itself, <pre><code>rbp</code></pre>, and the length of the string, which was the return value of <pre><code>strlen</code></pre> (and return values are placed in <pre><code>eax</code></pre>) and pass it into the function\n<pre><code>0x004010fc      mov     rdi, rbp\n0x004010ff      mov     esi, eax\n0x00401101      call    fcn.0040152b\n</code></pre>\nClean up the stack and return 0!\n<pre><code>0x00401106      add     rsp, 0x50\n0x0040110a      xor     eax, eax\n0x0040110c      pop     rbp\n0x0040110d      ret\n</code></pre>\nSo, I imagine <pre><code>main</code></pre> looks like\n<pre><code>#include <stdio.h>\n#include <string.h>\n\n\nint main()\n{\n    char str[65];\n\n    float local_var_1 = 0;\n    float local_var_2 = 0;\n    float local_var_3 = 0;\n    char  rsp_40      = 0;\n\n    puts(\"Input\");\n\n    fgets(str, 65, stdin);\n    int str_length = strlen(str);\n\n    some_fun(str, str_length);\n\n    return 0;\n};\n</code></pre>\nIs there anything wrong with this assessment?\nThe original assembly:\n<pre><code>main:\n0x004010b0      push    rbp\n0x004010b1      pxor    xmm0, xmm0\n0x004010b5      lea     rdi, str.Input: ; 0x40202c ; const char *s\n0x004010bc      sub     rsp, 0x50\n0x004010c0      movaps  xmmword [rsp], xmm0\n0x004010c4      mov     rbp, rsp\n0x004010c7      movaps  xmmword [rsp+0x10], xmm0\n0x004010cc      movaps  xmmword [rsp+0x20], xmm0\n0x004010d1      movaps  xmmword [rsp+0x30], xmm0\n0x004010d6      mov     byte [rsp+0x40], 0\n0x004010db      call    puts       ; sym.imp.puts ; int puts(const char *s)\n0x004010e0      mov     rdx, qword [stdin] ; 0x404090 ; FILE *stream\n0x004010e7      mov     esi, 0x41  ; 'A' ; 65 ; int size\n0x004010ec      mov     rdi, rbp   ; char *s\n0x004010ef      call    fgets      ; sym.imp.fgets ; char *fgets(char *s, int size, FILE *stream)\n0x004010f4      mov     rdi, rbp   ; const char *s\n0x004010f7      call    strlen     ; sym.imp.strlen ; size_t strlen(const char *s)\n0x004010fc      mov     rdi, rbp   ; int64_t arg1\n0x004010ff      mov     esi, eax   ; uint64_t arg2\n0x00401101      call    fcn.0040152b\n0x00401106      add     rsp, 0x50\n0x0040110a      xor     eax, eax\n0x0040110c      pop     rbp\n0x0040110d      ret\n</code></pre>\n",
    "votes": "0",
    "answers": 1,
    "views": "81",
    "tags": [
        "disassembly",
        "x86",
        "static-analysis"
    ],
    "user": "Happy Jerry",
    "time": "Oct 8, 2022 at 0:52",
    "comments": [
        {
            "user": "blabb",
            "text": "movaps is similar to doing a memset (....)  in your example it  clears of 0x40 bytes to NULL  [rsp],[rsp+10] , [rsp+20] , [rsp+30]  something roughly equal to char foo[0x40] ={0};\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "As i commented there are no float or xmm operations that are happening in your code\nthe xmm operations are compiler optimizations to set a small buffer to Zero\nor memset the buffer to NULL\nroughly equivalent to memset(buff,0,size); or most probably a declaration like char foo[SIZE] ={0} optimized away;\nsee the demo below\nsource code\n<pre><code>:\\>type movaps.cpp\n#include <stdio.h>\n#include <string.h>\nint main(void) {\n        char foo[0x41] = {0};\n        puts(\"input\");\n        printf(\"%s\\tsize=%zd\n\" ,foo,strlen(fgets(foo,0x41,stdin)));\n        return 0;\n}\n</code></pre>\ncompiling with maximum optimizations enabled in vs2019 community as x64\n<pre><code>:\\>cl /Zi /W4 /analyze /Ox movaps.cpp /link /release\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.29.30146 for x64\n</code></pre>\nexecuting the compiled binary\n<pre><code>:\\>movaps.exe\ninput\njajajajaj\njajajajaj\n        size=10\n</code></pre>\ndisassembling the relevant function main() in this case\n<pre><code>:\\>cdb -c \"uf movaps!main;q\" movaps.exe\n\nMicrosoft (R) Windows Debugger Version 10.0.19041.685 AMD64\n\nntdll!LdrpDoDebuggerBreak+0x30:\n00007ff8`516e0930 cc              int     3\n0:000> cdb: Reading initial command 'uf movaps!main;q'\nmovaps!main:\n00007ff6`14501000 4881ec88000000  sub     rsp,88h\n00007ff6`14501007 488b05fadf0600  mov     rax,qword ptr [movaps!__security_cookie (00007ff6`1456f008)]\n00007ff6`1450100e 4833c4          xor     rax,rsp\n00007ff6`14501011 4889442470      mov     qword ptr [rsp+70h],rax\n00007ff6`14501016 0f57c0          xorps   xmm0,xmm0\n00007ff6`14501019 488d0d60c30500  lea     rcx,[movaps!__xt_z+0x8 (00007ff6`1455d380)]\n00007ff6`14501020 33c0            xor     eax,eax\n00007ff6`14501022 0f11442420      movups  xmmword ptr [rsp+20h],xmm0\n00007ff6`14501027 88442460        mov     byte ptr [rsp+60h],al\n00007ff6`1450102b 0f11442430      movups  xmmword ptr [rsp+30h],xmm0\n00007ff6`14501030 0f11442440      movups  xmmword ptr [rsp+40h],xmm0\n00007ff6`14501035 0f11442450      movups  xmmword ptr [rsp+50h],xmm0\n00007ff6`1450103a e861110100      call    movaps!puts (00007ff6`145121a0)\n00007ff6`1450103f 33c9            xor     ecx,ecx\n00007ff6`14501041 e8fa080100      call    movaps!__acrt_iob_func (00007ff6`14511940)\n00007ff6`14501046 4c8bc0          mov     r8,rax\n00007ff6`14501049 488d4c2420      lea     rcx,[rsp+20h]\n00007ff6`1450104e ba41000000      mov     edx,41h\n00007ff6`14501053 e8240c0100      call    movaps!fgets (00007ff6`14511c7c)\n00007ff6`14501058 49c7c0ffffffff  mov     r8,0FFFFFFFFFFFFFFFFh\n00007ff6`1450105f 90              nop\n\nmovaps!main+0x60:\n00007ff6`14501060 49ffc0          inc     r8\n00007ff6`14501063 42803c0000      cmp     byte ptr [rax+r8],0\n00007ff6`14501068 75f6            jne     movaps!main+0x60 (00007ff6`14501060)\n\nmovaps!main+0x6a:\n00007ff6`1450106a 488d542420      lea     rdx,[rsp+20h]\n00007ff6`1450106f 488d0d12c30500  lea     rcx,[movaps!__xt_z+0x10 (00007ff6`1455d388)]\n00007ff6`14501076 e885000000      call    movaps!printf (00007ff6`14501100)\n00007ff6`1450107b 33c0            xor     eax,eax\n00007ff6`1450107d 488b4c2470      mov     rcx,qword ptr [rsp+70h]\n00007ff6`14501082 4833cc          xor     rcx,rsp\n00007ff6`14501085 e856010000      call    movaps!__security_check_cookie (00007ff6`145011e0)\n00007ff6`1450108a 4881c488000000  add     rsp,88h\n00007ff6`14501091 c3              ret\nquit:\n:\\>\n</code></pre>\n",
            "votes": "1",
            "user": "blabb",
            "time": "Oct 8, 2022 at 4:00",
            "is_accepted": false,
            "comments": [
                {
                    "user": "MendelG",
                    "text": "<span class=\"comment-copy\">Can you please help me with: <a href=\"https://reverseengineering.stackexchange.com/questions/31031/why-does-stepping-over-exit-the-program-but-running-it-with-the-run-button\" title=\"why does stepping over exit the program but running it with the run button\">reverseengineering.stackexchange.com/questions/31031/…</a> ?</span>",
                    "time": null
                }
            ]
        }
    ]
}