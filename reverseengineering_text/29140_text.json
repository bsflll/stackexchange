{
    "title": "Format of data in the .code/.text section",
    "link": "https://reverseengineering.stackexchange.com/questions/29140/format-of-data-in-the-code-text-section",
    "content": "I'm attempting to dissect/disassemble a windows PE file under Linux using objdump.  On surface analysis, the .code section was disassembled to :\n<pre><code>tmp.exe:     file format pei-i386\n\n\nDisassembly of section CODE:\n\n00401000 <CODE>:\n  401000:       04 10                   add    $0x10,%al\n  401002:       40                      inc    %eax\n  401003:       00 03                   add    %al,(%ebx)\n  401005:       07                      pop    %es\n  401006:       42                      inc    %edx\n  401007:       6f                      outsl  %ds:(%esi),(%dx)\n  401008:       6f                      outsl  %ds:(%esi),(%dx)\n  401009:       6c                      insb   (%dx),%es:(%edi)\n  40100a:       65                      gs\n  40100b:       61                      popa\n  40100c:       6e                      outsb  %ds:(%esi),(%dx)\n  40100d:       01 00                   add    %eax,(%eax)\n  40100f:       00 00                   add    %al,(%eax)\n  401011:       00 01                   add    %al,(%ecx)\n  401013:       00 00                   add    %al,(%eax)\n  401015:       00 00                   add    %al,(%eax)\n  ...\n</code></pre>\nThen I looked at the entry point which was 0x45e534, which\nended up within an opcode:\n<pre><code>\n  45e52f:       00 dc                   add    %bl,%ah\n  45e531:       e2 45                   loop   0x45e578\n  45e533:       00 55 8b                add    %dl,-0x75(%ebp)\n  45e536:       ec                      in     (%dx),%al\n  45e537:       83 c4 f0                add    $0xfffffff0,%esp\n  45e53a:       b8 04 e3 45 00          mov    $0x45e304,%eax\n  45e53f:       e8 e0 84 fa ff          call   0x406a24\n</code></pre>\nWhich, I feel is very wrong; but since my understanding of assembly is lacking, I could be wrong.\nSo having read [1] and the chapter on Disassembly in \"Practical Malware Analysis\", I realized that there could be data in the .text (or in this case, CODE) section.  So I took a gander at the\nhex dump on the file and came across at the beginning of\nthe code section:\n<pre><code>0000400: 0410 4000 0307 426f 6f6c 6561 6e01 0000  ..@...Boolean...\n0000410: 0000 0100 0000 0010 4000 0546 616c 7365  ........@..False\n0000420: 0454 7275 658d 4000 2c10 4000 0204 4368  .True.@.,.@...Ch\n0000430: 6172 0100 0000 00ff 0000 0090 4010 4000  ar..........@.@.\n0000440: 0107 496e 7465 6765 7204 0000 0080 ffff  ..Integer.......\n0000450: ff7f 8bc0 5810 4000 0104 4279 7465 0100  ....X.@...Byte..\n0000460: 0000 00ff 0000 0090 6c10 4000 0104 576f  ........l.@...Wo\n0000470: 7264 0300 0000 00ff ff00 0090 8010 4000  rd............@.\n0000480: 0108 4361 7264 696e 616c 0500 0000 00ff  ..Cardinal......\n0000490: ffff ff90 9810 4000 0a06 5374 7269 6e67  ......@...String\n...\n\n</code></pre>\nThis lead me to believe that there is definitely DATA in the code section [but, again, I could be wrong].\nMy question is (even given [1]), is it possible to figure out what the format of the DATA is in that part of the binary?\nWith my limited understanding, I'm guessing it's a structure of some sort or possibly a long list of DB/DW but (again, I could be wrong).\nFor instance, the very first set:\n<pre><code>0410 4000 0307 426f 6f6c 6561 6e01 00 00..\n\n</code></pre>\nCould the above be translated to something like (in assembly)\n<pre><code>   DB 0x00401004\n   DB 0x0703\n   DB \"Boolean\"\n   ...\n</code></pre>\nI tried to look for the opcode DB in [2] but couldn't find it, so I'm wondering if I'm barking up the wrong tree.\nAny help/pointers appreciated\n:ewong\n[1] - How do reverse engineers commonly detect the format of binary data?\n[2] - http://mathemainzel.info/files/x86asmref.html\n",
    "votes": "0",
    "answers": 2,
    "views": "377",
    "tags": [
        "disassembly",
        "malware",
        "static-analysis"
    ],
    "user": "ewokx",
    "time": "Aug 16, 2021 at 10:09",
    "comments": [],
    "answers_data": [
        {
            "content": "objdump disassembles linearly, it does not do control flow, so you may get gibberish in return. Use\n<pre><code>objdump -f \n</code></pre>\nto get the entry point, and use that address as <pre><code>--start-address</code></pre> argument.\nBe aware — since it is linear, it will disassemble from this address till the end of the binary or end of the code section, so you may need to provide a <pre><code>--stop-address</code></pre>, too, if you don't want a seemingly endless spew.\n<pre><code>:\\>f:\\mingw\\bin\\objdump.exe -f .\\getinst.exe\n\n.\\getinst.exe:     file format pei-i386\narchitecture: i386, flags 0x0000012f:\nHAS_RELOC, EXEC_P, HAS_LINENO, HAS_DEBUG, HAS_LOCALS, D_PAGED\nstart address 0x00404ee3 <<<<<<<<<\n</code></pre>\nDisassembling some bytes from a specific address:\n<pre><code>:\\>f:\\mingw\\bin\\objdump.exe -d --start-address 0x00404ee3 --stop-address 0x00404f00 .\\getinst.exe\n\n.\\getinst.exe:     file format pei-i386\n\n\nDisassembly of section .text:\n\n00404ee3 <.text+0x3ee3>:\n  404ee3:       e8 0a 07 00 00          call   0x4055f2\n  404ee8:       e9 74 fe ff ff          jmp    0x404d61\n  404eed:       8b 4d f4                mov    -0xc(%ebp),%ecx\n  404ef0:       64 89 0d 00 00 00 00    mov    %ecx,%fs:0x0\n  404ef7:       59                      pop    %ecx\n  404ef8:       5f                      pop    %edi\n  404ef9:       5f                      pop    %edi\n  404efa:       5e                      pop    %esi\n  404efb:       5b                      pop    %ebx\n  404efc:       8b e5                   mov    %ebp,%esp\n  404efe:       5d                      pop    %ebp\n  404eff:       51                      push   %ecx\n</code></pre>\nIf you notice, the instruction at <pre><code>0x404eed</code></pre> may never be executed as there is a hard-coded <pre><code>jmp</code></pre> which will divert the control flow, so all disassembly after the jmp might be gibberish and useless.\nYou may <pre><code>need</code></pre> to provide <pre><code>0x404d61</code></pre> as <pre><code>--start-address</code></pre> for following the flow as below:\n<pre><code>:\\>f:\\mingw\\bin\\objdump.exe -d --start-address 0x404d61 --stop-address 0x404d80 .\\getinst.exe\n\n.\\getinst.exe:     file format pei-i386\n\n\nDisassembly of section .text:\n\n00404d61 <.text+0x3d61>:\n  404d61:       6a 14                   push   $0x14\n  404d63:       68 b0 9c 42 00          push   $0x429cb0\n  404d68:       e8 53 0b 00 00          call   0x4058c0\n  404d6d:       6a 01                   push   $0x1\n  404d6f:       e8 d9 02 00 00          call   0x40504d\n  404d74:       59                      pop    %ecx\n  404d75:       84 c0                   test   %al,%al\n  404d77:       0f 84 50 01 00 00       je     0x404ecd\n  404d7d:       32 db                   xor    %bl,%bl\n  404d7f:       88                      .byte 0x88\n</code></pre>\nIf you notice, you may still see gibberish at <pre><code>0x404d7d</code></pre>. That is because the provided stop-address is insufficient to decode the bytes into a sensible instruction.\n<pre><code>:\\>f:\\mingw\\bin\\objdump.exe -M intel -d --start-address 0x404d7d --stop-address 0x404d8b .\\getinst.exe\n\n.\\getinst.exe:     file format pei-i386\n\n\nDisassembly of section .text:\n\n00404d7d <.text+0x3d7d>:\n  404d7d:       32 db                   xor    bl,bl\n  404d7f:       88 5d e7                mov    BYTE PTR [ebp-0x19],bl\n  404d82:       83 65 fc 00             and    DWORD PTR [ebp-0x4],0x0\n  404d86:       e8 90 02 00 00          call   0x40501b\n</code></pre>\nEdit\n<pre><code>db = define byte like  size(1)  \"\\xff\"   \ndw = define word like  size(2)  \"\\xff\\xff\"  \ndd = define dword like size(4)  \"\\xff\\xff\\xff\\xff\"     \ndq = define qword like size(8)  \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"  \n</code></pre>\n",
            "votes": "1",
            "user": "MarianD",
            "time": "Aug 16, 2021 at 18:27",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "Delphi executables store read only data such as RTTI (Run time type information) at the start of CODE section. <pre><code>objdump</code></pre> can’t know that it’s not really code so it tries to disassemble it as instructions and you get nonsense.\n",
            "votes": "0",
            "user": "Igor Skochinsky",
            "time": "Aug 18, 2021 at 20:16",
            "is_accepted": false,
            "comments": []
        }
    ]
}