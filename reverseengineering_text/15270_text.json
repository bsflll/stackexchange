{
    "title": "legitimate memory pages that are marked as RWX?",
    "link": "https://reverseengineering.stackexchange.com/questions/15270/legitimate-memory-pages-that-are-marked-as-rwx",
    "content": "In windows and linux x86 (including x86_64) world, is there any legitimate binary (i.e., a program binary generated by the typical compiling-assembling-linking flow and no manual editing on binary after it is generated) that will have RWX memory pages after being loaded? If yes, what are the use cases?\n",
    "votes": "2",
    "answers": 3,
    "views": "3k",
    "tags": [
        "x86",
        "memory",
        "binary"
    ],
    "user": "drdot",
    "time": "May 4, 2017 at 5:35",
    "comments": [
        {
            "user": "julian",
            "text": "operating system? compiler? binary format?\n",
            "time": null
        },
        {
            "user": "drdot",
            "text": "OS: linux, windows. Compiler: gcc, visual studio, binary: ELF.\n",
            "time": null
        },
        {
            "user": "julian",
            "text": "ELF binaries won't be executed by a windows kernel and ELF segment permissions are denoted RWE rather than RWX\n",
            "time": null
        },
        {
            "user": "julian",
            "text": "what does it mean for a binary to be considered \"legitimate\"?\n",
            "time": null
        },
        {
            "user": "drdot",
            "text": "@SYS_V, a program binary generated by the typical compiling-linking-assembling flow, i.e., no manual editing on binary after it is generated.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Note: this answer corresponds to the original question\nProcess segment permissions may vary across architectures and implementations. For example, it is expected that on more recent x86 Linux systems that GCC creates binaries with non-executable stacks. In contrast with this, it used to be the case that MIPS did not even support an non-executable stack - in other words, every MIPS binary had its stack permissions set to RWE.\n\nMIPS floating point support requires that any instruction that cannot\n  be directly executed by the FPU, be emulated by the kernel.  Part of\n  this emulation involves executing non-FPU instructions that fall in\n  the delay slots of FP branch instructions.  Since the beginning of\n  MIPS/Linux time, this has been done by placing the instructions on the\n  userspace thread stack, and executing them there, as the instructions\n  must be executed in the MM context of the thread receiving the\n  emulation.\nBecause of this, the de facto MIPS Linux userspace ABI requires that\n  the userspace thread have an executable stack.  It is de facto,\n  because it is not written anywhere that this must be the case, but it\n  is never the less a requirement.[1]\n\nA kernel patch had to be developed in order to support MIPS executable stack protection:\n\nThe following series implements an executable stack protection in MIPS.\nIt sets up a per-thread 'VDSO' page and appropriate TLB support.\n  Page is set write-protected from user and is maintained via kernel VA.\n  MIPS FPU emulation is shifted to new page and stack is relieved for\n  execute protection as is as all data pages in default setup during ELF\n  binary initialization. The real protection is controlled by GLIBC and\n  it can do stack protected now as it is done in other architectures and\n  I learned today that GLIBC team is ready for this.\nNote: actual execute-protection depends from HW capability, of course.\nThis patch is required for MIPS32/64 R2 emulation on MIPS R6 architecture.[2]\n\nHere is a concrete example, using a MIPS ELF binary from a ZTE router:\n<pre><code>$ file cspd \ncspd: ELF 32-bit MSB executable, MIPS, MIPS-I version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped\n</code></pre>\nNote the permissions of segment <pre><code>GNU_STACK</code></pre>:\n<pre><code>$ readelf -l cspd \n\nElf file type is EXEC (Executable file)\nEntry point 0x59d790\nThere are 8 program headers, starting at offset 52\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  PHDR           0x000034 0x00400034 0x00400034 0x00100 0x00100 R E 0x4\n  INTERP         0x000134 0x00400134 0x00400134 0x00014 0x00014 R   0x1\n      [Requesting program interpreter: /lib/ld-uClibc.so.0]\n  REGINFO        0x000148 0x00400148 0x00400148 0x00018 0x00018 R   0x4\n  LOAD           0x000000 0x00400000 0x00400000 0x1ef050 0x1ef050 R E 0x10000\n  LOAD           0x1ef050 0x005ff050 0x005ff050 0x148e2 0x2a070 RW  0x10000\n  DYNAMIC        0x000160 0x00400160 0x00400160 0x00130 0x00130 RWE 0x4\n  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4    <---\n  NULL           0x000000 0x00000000 0x00000000 0x00000 0x00000     0x4\n\n Section to Segment mapping:\n  Segment Sections...\n   00     \n   01     .interp \n   02     .reginfo \n   03     .interp .reginfo .dynamic .hash .dynsym .dynstr .init .text .MIPS.stubs .fini .rodata \n   04     .data.rel.ro .data .rld_map .got .sbss .bss \n   05     .dynamic \n   06     \n   07     \n</code></pre>\n\n1. Patchwork MIPS: Allow FPU emulator to use non-stack area.\n2. MIPS executable stack protection\n",
            "votes": "2",
            "user": "julian",
            "time": "May 3, 2017 at 23:46",
            "is_accepted": true,
            "comments": [
                {
                    "user": "drdot",
                    "text": "<span class=\"comment-copy\">Thank you for the answer. I did not realize the question is so broad. I am only interested in the case for x86. Optionally, if you know something about ARM, that would be great. But I am OK with x86 only use cases.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "Just-In-Time Compilation support could be one reason for pages to be legitimately marked RWX.  In iOS MobileSafari is one of a small number of Apple apps that has a \"dynamic codesigning\" entitlement which allows for the RWX pages to be mapped.  Despite the potential danger, JavaScript performance is too important to not have these pages.  This makes Safari a desirable target for exploits.  For more information on a recent iOS exploit that attacked Safari for its RWX pages read the Pegasus Technical Report\n",
            "votes": "1",
            "user": "user1593858",
            "time": "May 5, 2017 at 23:15",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "It seems some .NET native binaries, e.g. <pre><code>System.ni.dll</code></pre> have an RWX <pre><code>.xdata</code></pre> section, although I believe they're not generated by a normal compilation workflow (they're produced by <pre><code>ngen</code></pre> AFAIK) so they're probably not covered by the current version of the question.\n",
            "votes": "0",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": []
        }
    ]
}