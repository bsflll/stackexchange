{
    "title": "Delphi Pascal Try..Except..Finally block",
    "link": "https://reverseengineering.stackexchange.com/questions/2895/delphi-pascal-try-except-finally-block",
    "content": "I'm having trouble reverse-engineering a specific Delphi Pascal .exe (old vsn., pre-1995 so probably v.3). From the system calls I understand this is probably a <pre><code>try..except..finally</code></pre> block, but I am at a loss finding the 'normal' route through the code, and what the <pre><code>except</code></pre> and (possibly) <pre><code>finally</code></pre> blocks are.\nThe assembly looks like this:\n<pre><code>782CFC  33 C0                   xor    eax, eax\n782CFE  55                      push   ebp\n782CFF  68 (782E37)             push   _FINALLY_A_0_782E37\n782D04  64 FF 30                push   dword ptr fs:[eax]\n782D07  64 89 20                mov    dword ptr fs:[eax], esp\n\n            _try_0_782D0A:\n782D0A  8B D3                   mov    edx, ebx\n782D0C  8B C6                   mov    eax, esi\n782D0E  E8 D1 F3 FF FF          call   ...unrelated...\n782D13  8D 56 1C                lea    edx, [esi+1Ch]\n.. lots of regular code here ..\n.. ending with ..\n782E17  8B 18                   mov    ebx, dword ptr [eax]\n782E19  FF 53 20                call   dword ptr [ebx+20h]\n\n        finally_1_782E1C:\n782E1C  33 C0                   xor    eax, eax\n782E1E  5A                      pop    edx\n782E1F  59                      pop    ecx\n782E20  59                      pop    ecx\n782E21  64 89 10                mov    dword ptr fs:[eax], edx\n782E24  68 (782E3E)             push   _end_1_782E3E\n\n                @block_L:\n782E29  8D 45 F4                lea    eax, [ebp + local_0C]\n782E2C  BA 02 00 00 00          mov    edx, 2\n782E31  E8 12 E3 F7 FF          call   System.@LStrArrayClr\n782E36  C3                      retn\n\n            _FINALLY_A_0_782E37:\n782E37  E9 B4 E2 F7 FF          jmp    System.@HandleFinally\n\n            _FINALLY_B_0_782E3C:\n782E3C  EB EB                   jmp    @block_L\n                ; -------\n\n            _end_1_782E3E:\n782E3E  5F                      pop    edi\n782E3F  5E                      pop    esi\n782E40  5B                      pop    ebx\n782E41  8B E5                   mov    esp, ebp\n782E43  5D                      pop    ebp\n782E44  C3                      retn\n</code></pre>\n-- this is output from my own disassembler, but I don't think there are errors in it. The labels have been auto-named, but I still cannot follow the 'logic' (if any) from one block to the next. In particular, the bottom half, right before the function epilogue, confuses me.\nAre these fragments enough to reconstruct the original <pre><code>try</code></pre>..<pre><code>finally</code></pre> blocks?\n\nAfter reading Igor's answer: yes they are. Consider these flowcharts: left, original before special handling of try/finally blocks, right, afterwards.\n\nIn the original flowchart, I considered every jump from one basic block to another as a link, and the code flow stops at every <pre><code>retn</code></pre>. <pre><code>if</code></pre> (E-(F)-K) and <pre><code>if-else</code></pre> (G-H/I-J) structures can clearly be discerned. However, pushing return addresses and the other 'tricks' of exception handling, defeat this, as can be seen by the dangling blocks N and O -- they 'enter' from nowhere --, and a separate block 'M' which comes and goes from nowhere.\nAt the right, I separated the initialization of the exception block from the main code (adding a new block B), and concatenated the finalize structure into one single new block (M), which ultimately jumps to an AFTER_TRY (which happened to be the last Exit block). Now it's clear that\n\nright after the prologue, a <pre><code>try</code></pre> is initiated;\nall code ends up at the <pre><code>finally</code></pre> block M, which\nthen always exists the code at a single fixed point.\n",
    "votes": "12",
    "answers": 1,
    "views": "3k",
    "tags": [
        "disassembly",
        "decompilation"
    ],
    "user": "Jongware",
    "time": "Oct 7, 2013 at 21:44",
    "comments": [],
    "answers_data": [
        {
            "content": "Delphi implements <pre><code>try</code></pre>/<pre><code>except</code></pre>/<pre><code>finally</code></pre> by using Win32 Structured Exception Handlers (SEH). The basics of SEH are explained in the classic article by Matt Pietrek, so I'll skip to the details relevant to Delphi only.\n1. <pre><code>try</code></pre> entry\nEntry to a <pre><code>try</code></pre> block, or a block which protects automatic variables that need to be destructed on exit (such as strings) looks like the following:\n<pre><code>xor     eax, eax\npush    ebp\npush    offset SEH_HANDLER\npush    dword ptr fs:[eax]\nmov     fs:[eax], esp\n</code></pre>\nThis is a typical way of setting up a SEH frame. After it's run, top of the stack will look like this:\n<pre><code>       +-----------+\nESP+00 |    next   | <- fs:[0] points here\n       +-----------+\nESP+04 |  handler  |\n       +-----------+\nESP+08 | saved_ebp |\n       +-----------+\n</code></pre>\nThe pointer to this structure will be passed to the SEH handler.\n2. <pre><code>try</code></pre> exit\nAt the end of the <pre><code>try</code></pre> block, the SEH frame is torn down:\n<pre><code>    xor     eax, eax\n    pop     edx               ; pop 'next' into edx\n    pop     ecx               ; pop handler\n    pop     ecx               ; pop saved_ebp\n    mov     fs:[eax], edx     ; move 'next' into fs:[0]\n</code></pre>\nIf there is a <pre><code>finally</code></pre> handler or automatic destructors, then it continues like this:\n<pre><code>    push    offset AFTER_TRY  ; make it so the 'ret' will jump to AFTER_TRY\nFINALLY_HANDLER:\n    <destruct automatic variables created in the try block>\n    <finally handler body>\n    ret                       ; jumps to AFTER_TRY\n</code></pre>\nOtherwise there is a simple jump:\n<pre><code>    jmp AFTER_TRY\n</code></pre>\n3. <pre><code>finally</code></pre> handler\nIn case the program use <pre><code>finally</code></pre> statement, or in case of the <pre><code>try..finally</code></pre> added by the compiler to guard automatic variables, the SEH handler looks like this:\n<pre><code>SEH_HANDLER:\n    jmp     _HandleFinally\n    jmp     FINALLY_HANDLER\n</code></pre>\n4. <pre><code>except</code></pre> handler\nIf the program uses an <pre><code>except</code></pre> handler to catch all exceptions, the code looks a little different:\n<pre><code>SEH_HANDLER:\n    jmp     _HandleAnyException\n    <handler code>\n    call    _DoneExcept\n</code></pre>\n5. <pre><code>except on</code></pre> handlers\nIf the program uses <pre><code>except on...</code></pre> to match the exception(s) being caught, the compiler generates a table of one or more possible exception classes with corresponding handlers:\n<pre><code>SEH_HANDLER:\n    jmp     _HandleOnException\n    dd <numExceptions>\n    dd offset ExceptionClass1\n    dd offset OnException1_handler\n    dd offset ExceptionClass2\n    dd offset OnException2_handler\n    <...>\n\nOnException1_handler:\n    <handler code>\n    call    _DoneExcept\n\nOnException2_handler:\n    <handler code>\n    call    _DoneExcept\n</code></pre>\nThere may be some variations, but I think I covered most of it.\nThe source code of <pre><code>_HandleFinally</code></pre>, <pre><code>_HandleAnyException</code></pre>, <pre><code>_HandleOnException</code></pre>, <pre><code>_DoneExcept</code></pre> and a few other exceptions-related functions can be found in <pre><code>system.pas</code></pre> in the VCL sources.\n",
            "votes": "11",
            "user": "Igor Skochinsky",
            "time": "Oct 7, 2013 at 15:26",
            "is_accepted": true,
            "comments": []
        }
    ]
}