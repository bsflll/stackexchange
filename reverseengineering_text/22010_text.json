{
    "title": "Figuring out correct user input key from final key + generated buffer",
    "link": "https://reverseengineering.stackexchange.com/questions/22010/figuring-out-correct-user-input-key-from-final-key-generated-buffer",
    "content": "I've recently gotten into reversing crackmes, and I seem to always fail at the ones similar to this.\nThe final key that the program uses for comparison is not the key that should be used as input, the key used as input is used in an algorithm with another set of data to check if it generates the final key.\nHere is the code so it makes a bit more sense.\n<pre><code>signed __int64 __fastcall ValidateSerials(unsigned int *generatedData, unsigned int *finalCorrectSerial, unsigned int *UserInputSerial)\n{\n  signed int i; // [rsp+0h] [rbp-18h]\n  signed int j; // [rsp+4h] [rbp-14h]\n  signed int currentUserInputsr; // [rsp+8h] [rbp-10h]\n  int v7; // [rsp+Ch] [rbp-Ch]\n\n  for ( i = 0; i < 4; ++i )\n  {\n    v7 = 0;\n    currentUserInputsr = UserInputSerial[i];\n    for ( j = 6; j >= 0; --j )\n    {\n      v7 += generatedData[j] * (currentUserInputsr & 1);\n      currentUserInputsr >>= 1;\n    }\n    if ( v7 != finalCorrectSerial[i] )\n      return 0i64;\n  }\n  return 1i64;\n}\n</code></pre>\nif I know <pre><code>generatedData</code></pre> and <pre><code>finalCorrectSerial</code></pre>, how can I generate the correct <pre><code>UserInputSerial</code></pre>? I've tried to reverse the entire functions logic but I always get it wrong. I'm fairly new into solving keygens such as this but not reverse engineering in general.\nThanks\n",
    "votes": "0",
    "answers": 2,
    "views": "91",
    "tags": [
        "c++",
        "crackme"
    ],
    "user": null,
    "time": "Aug 30, 2019 at 20:35",
    "comments": [],
    "answers_data": [
        {
            "content": "I wrote a function, that generates a valid input from given <pre><code>generatedData</code></pre> and <pre><code>finalCorrectSerial</code></pre>. The function calculates a subset that, when summed up, equals the corresponding value in <pre><code>finalCorrectSerial</code></pre>. It then creates a valid input from that. (The function <pre><code>subsetSum()</code></pre> is taken from here and was modified to return just one subset and that by it's indices):\n<pre><code>bool subsetSum(unsigned int* set, unsigned int* subSet, int n, int subSize, int total, int nodeCount ,int sum, int* outN) {\n   if( total == sum) {\n       *outN = subSize;\n      return 1;\n   } \n   else {\n      for( int i = nodeCount; i < n; i++ ) {     //find node along breadth\n         subSet[subSize] = i;\n         if (subsetSum(set,subSet,n,subSize+1,total+set[i],i+1,sum, outN)) return 1;     //do for next node in depth\n      }\n   }\n   return 0;\n}\n\nbool genInput(unsigned int* generatedData, unsigned int* finalCorrectSerial, unsigned int* out) {\n    for (int i = 0; i < 4; i++) {\n        unsigned int subs[7];\n        int size = 0;\n        subsetSum(generatedData, subs, 7, 0, 0, 0, finalCorrectSerial[i], &size);\n\n        std::cout << \"finalCorrectSerial[\" << i << \"] (\" << finalCorrectSerial[i] << \") has \" << (size ? \"a\" : \"no\") << \" subset (indices): \";\n        for (int j = 0; j < size; j++ ) {\n            std::cout << subs[j] << \" \";\n        }\n        std::cout << \"\n\";\n\n        if (!size) return 0;\n\n        for (int j = 0; j < size; j++) {\n            out[i] |= (1u << (6 - subs[j]));\n        }\n\n    }\n    return 1;\n}\n</code></pre>\nA test run (with arbitrary numbers):\n<pre><code>int main()\n{\n  unsigned int genData[] = { 10, 55, 1, 3, 7, 98, 1};\n  unsigned int key[] = { 66, 5, 4, 5};\n  unsigned int input[4] = { 0 };\n\n  std::cout << \"Generating Input was \" << (genInput(genData, key, input) ? \"successfull\n\" : \"unsuccessful\n\");\n  for (int j = 0; j < 4; j++) {\n            std::cout << input[j] << \" \";\n    }\n    std::cout << \"\n\";\n\n  std::cout << (ValidateSerials(genData, key, input) ? \"true\" : \"false\");\n\n  return 1;\n}\n</code></pre>\nreturns\n<pre><code>finalCorrectSerial[0] (66) has a subset (indices): 0 1 2 \nfinalCorrectSerial[1] (5) has a subset (indices): 2 3 6 \nfinalCorrectSerial[2] (4) has a subset (indices): 2 3 \nfinalCorrectSerial[3] (5) has a subset (indices): 2 3 6 \nGenerating Input was successfull\n112 25 24 25 \ntrue\n</code></pre>\n",
            "votes": "1",
            "user": "Anonymous Anonymous",
            "time": "Aug 31, 2019 at 15:46",
            "is_accepted": false,
            "comments": [
                {
                    "user": "user29468",
                    "text": "<span class=\"comment-copy\">Thank you, that actually worked. But i'm still a little confused on it all. What would you say is necessary to learn/understand well before tackling key gens similar to this?</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "This function simply checks each input number (<pre><code>UserInputSerial[i]</code></pre>) whether it is correct and it's doing so by summing up <pre><code>generatedData[j] * (UserInputSerial[i] & (1 << (6 - j)))</code></pre>, so it's basically iterating through <pre><code>UserInputSerial[i]</code></pre>'s <pre><code>7</code></pre> least significant bytes and if some of them is <pre><code>1</code></pre> the relevant number from <pre><code>generatedData</code></pre> will be taken into the sum (<pre><code>v7</code></pre>).\nSince, I suspect, the author of this crackme wants to accept only one input, <pre><code>v7</code></pre> has to get different values for all possible inputs, so for each <pre><code>a = UserInputSerial[i1]</code></pre>, <pre><code>b = UserInputSerial[i2]</code></pre>, if <pre><code>a != b</code></pre>, then <pre><code>v7</code></pre> counted for <pre><code>a</code></pre> has to be different than <pre><code>v7</code></pre> counted for <pre><code>b</code></pre>. In other words, if <pre><code>v7</code></pre> is function taking <pre><code>UserInputSerial[i]</code></pre> and <pre><code>generatedData</code></pre>, it has to be injection. \nThe easiest way to generate such a function is to initialise <pre><code>generatedData</code></pre> in such a way, that <pre><code>generatedData[j] > sum(generatedData[i<j])</code></pre>. So for example it could be that <pre><code>generatedData[j] = 2^j</code></pre> or <pre><code>generatedData[j] = 3^j</code></pre>. So, knowing the correct <pre><code>v7</code></pre> value for each <pre><code>UserInputSerial[i]</code></pre> and <pre><code>generatedData</code></pre>, you should be able to easily obtain the <pre><code>x</code></pre> such that <pre><code>v7(x, generatedData) = finalCorrectSerial[i]</code></pre> in a way similar as you would convert <pre><code>finalCorrectSerial[i]</code></pre> to binary.\nSo, assuming that indeed <pre><code>generatedData[j] > sum(generatedData[i<j])</code></pre>, you can write something like this:\n<pre><code>char bits[7]; // bits of the correct UserInputSerial[i]\nint a = finalCorrectSerial[i];\nfor (j = 6; j >= 0; j--)\n{\n    if (a >= generatedData[j])\n    {\n        a -= generatedData[j];\n        bits[j] = 1;\n    }\n    else\n        bits[j] = 0;\n}\n</code></pre>\nIf it's not the case, you can just check <pre><code>v7(x, generatedData)</code></pre> for all possible numbers having less or <pre><code>7</code></pre> bytes and check which one will cause <pre><code>v7</code></pre> to produce the desired value (<pre><code>finalCorrectSerial[i]</code></pre>).\n",
            "votes": "0",
            "user": "bart1e",
            "time": "Aug 31, 2019 at 10:20",
            "is_accepted": false,
            "comments": []
        }
    ]
}