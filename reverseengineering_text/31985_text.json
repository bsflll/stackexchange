{
    "title": "How do I extract sprites and backgrounds from .BIN files? (dos game - 1988)",
    "link": "https://reverseengineering.stackexchange.com/questions/31985/how-do-i-extract-sprites-and-backgrounds-from-bin-files-dos-game-1988",
    "content": "Does anyone know what tools should I use to extract the backgrounds and sprites of this very rare old game: Armorik the Viking?\nThe files are in .BIN format. No idea how to open them. I tried Game Extractor and QuickBMS tools but they could not read the files.\nWhat type of BIN are these? The game is from 1988 and was released by InfoGrames.\nThis is the game:\nhttps://archive.org/download/msdos_Armorik_the_Viking_-_The_Eight_Conquests_1988/Armorik_the_Viking_-_The_Eight_Conquests_1988.zip\nMany thanks in advance!\n",
    "votes": "2",
    "answers": 2,
    "views": "492",
    "tags": [
        "ida",
        "disassembly",
        "ghidra"
    ],
    "user": "Fab",
    "time": "Jun 19, 2023 at 22:50",
    "comments": [
        {
            "user": "Ali Rizvi-Santiago",
            "text": "Unless you want to do some work to 100% confirm (as it's just a .COM file), screenshots of the game look like it's CGA. As per moddingwiki.shikadi.net/wiki/Raw_CGA_Data, it's a pretty simple format with every pair of bits representing a color. To confirm it's CGA with reverse-engineering, though, you'd scan for \"INT 10h\" in the disassembly to identify all possible screen mode changes, and I'm pretty certain that they're using \"INT 21h\" to read the contents of those filenames.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "BACKS.BIN - backgrounds. You'll have to write a program to decode those images using your preferred programming language. Some info:\n\nAll images are 320x200, 2 bits per pixel.\n\nall images contain header - 8 bytes (4 values - 2 bytes per value, all header contain values 0,0-319,199)\n\nImages are interlaced - first part of image contains only even rows, second - odd rows.\n\nAll images are packed with RLE compression, pseudocode:\n<pre><code> while(!needExit) {\n\n     controlByte = getNextByte(data[position]);\n     position++;\n\n     if (controlByte == 0) {\n         needExit = true;\n     } else if (controlByte == 0x80) {\n         // change CGA plane\n         buffer = oddRows;\n     } else if ((controlByte & 0x80) == 0) {\n         for (int i=0; i<controlByte; i++) {\n             word = getNextTwoBytes(data, position + i*2);\n             buffer.write(word);\n         }\n         position += controlByte * 2;\n     } else {\n         controlByte = controlByte & 0x7F;\n         word = getNextTwoBytes(data, position);\n         for (int i=0; i<controlByte; i++) {\n             buffer.write(word);\n         }\n         position += 2;\n     }\n }\n</code></pre>\n\n\nMOTIFS.BIN - sprites. This file is not packed, so you can see/extract sprites with programs like \"Texture/Tiles finder\" (if they support CGA/2 bits per pixel modes).\n\n256 sprites of size 32x32 pixels\n\n3 sprites of size 48x48 pixels\n\n3 sprites of size 64x64 pixels\n\n2 bits per pixel, CGA pal.\n\nAfter each sprite lies its transparency mask, also 2 bits per pixel. If 2 bits in mask both set then corresponding pixel in sprite is transparent.\n\n\n - https://imgur.com/a/UEf75nF\n",
            "votes": "2",
            "user": "Max",
            "time": "Jun 28, 2023 at 22:02",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "I tried to read the file BACKS.BIN but I can only view one image from the output_images.bin file generated by the following C++ code. It looks like the output file does not contain all the content from the input file BACKS.BIN; I'm not sure how to fix it. Any ideas on how to improve the below code? Many thanks!\nMy viewer is GBS as well.\nhere it is: https://ibb.co/MhvhZZq\n<pre><code>#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n\nconst int IMAGE_WIDTH = 320;\nconst int IMAGE_HEIGHT = 200;\nconst int HEADER_SIZE = 8;\n\nstruct ImageHeader {\n    int width;\n    int height;\n};\n\nbool getNextTwoBytes(const std::vector<char>& data, int position, short& word) {\n    if (position + 1 >= data.size())\n        return false;\n\n    word = (static_cast<uint8_t>(data[position + 1]) << 8) | static_cast<uint8_t>(data[position]);\n    return true;\n}\n\nbool extractAndDecompressImages(const std::string& inputFilePath, const std::string& outputFilePath) {\n    std::ifstream inputFile(inputFilePath, std::ios::binary);\n    if (!inputFile) {\n        std::cerr << \"Error: Could not open input file.\n\";\n        return false;\n    }\n\n    inputFile.seekg(0, std::ios::end);\n    std::streampos fileSize = inputFile.tellg();\n    inputFile.seekg(0, std::ios::beg);\n\n    int imageCount = static_cast<int>(fileSize / (HEADER_SIZE + IMAGE_WIDTH * IMAGE_HEIGHT));\n    if (imageCount == 0) {\n        std::cerr << \"Error: Invalid input file format.\n\";\n        return false;\n    }\n\n    std::ofstream outputFile(outputFilePath, std::ios::binary);\n    if (!outputFile) {\n        std::cerr << \"Error: Could not create output file \" << outputFilePath << \"\n\";\n        return false;\n    }\n\n    for (int i = 0; i < imageCount; ++i) {\n        ImageHeader header;\n        inputFile.read(reinterpret_cast<char*>(&header), sizeof(ImageHeader));\n\n        std::vector<char> compressedData(IMAGE_WIDTH * IMAGE_HEIGHT);\n        inputFile.read(compressedData.data(), compressedData.size());\n\n        std::vector<char> decompressedData;\n        decompressedData.reserve(IMAGE_WIDTH * IMAGE_HEIGHT * 2); // Reserve enough space to avoid reallocations\n\n        int position = 0;\n\n        while (position < compressedData.size()) {\n            unsigned char controlByte = static_cast<unsigned char>(compressedData[position++]);\n            if (controlByte == 0) {\n                break;\n            } else if (controlByte == 0x80) {\n                // change CGA plane (not relevant for decompression)\n                // Assuming CGA plane change is already handled outside of decompression.\n            } else if ((controlByte & 0x80) == 0) {\n                for (int i = 0; i < controlByte; i++) {\n                    short word;\n                    if (!getNextTwoBytes(compressedData, position + i * 2, word)) {\n                        std::cerr << \"Error: Invalid input file format.\n\";\n                        return false;\n                    }\n                    decompressedData.insert(decompressedData.end(), {static_cast<char>(word & 0xFF), static_cast<char>(word >> 8)});\n                }\n                position += controlByte * 2;\n            } else {\n                controlByte = controlByte & 0x7F;\n                short word;\n                if (!getNextTwoBytes(compressedData, position, word)) {\n                    std::cerr << \"Error: Invalid input file format.\n\";\n                    return false;\n                }\n                for (int i = 0; i < controlByte; i++) {\n                    decompressedData.insert(decompressedData.end(), {static_cast<char>(word & 0xFF), static_cast<char>(word >> 8)});\n                }\n                position += 2;\n            }\n        }\n\n        // Write the decompressed data to the output file using modern C++ iterators\n        std::copy(decompressedData.begin(), decompressedData.end(), std::ostreambuf_iterator<char>(outputFile));\n    }\n\n    return true;\n}\n\nint main() {\n    const std::string inputFilePath = \"BACKS.bin\";\n    const std::string outputFilePath = \"output_images.bin\";\n\n    if (extractAndDecompressImages(inputFilePath, outputFilePath)) {\n        std::cout << \"Extraction and decompression successful!\n\";\n    } else {\n        std::cout << \"Extraction and decompression failed.n\";\n    }\n\n    return 0;\n}\n</code></pre>\n",
            "votes": "1",
            "user": "The Thinker",
            "time": "Jul 26, 2023 at 3:30",
            "is_accepted": false,
            "comments": []
        }
    ]
}