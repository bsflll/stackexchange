{
    "title": "Restoring the file structure from a cocos2d-x JS Android APK, post decryption?",
    "link": "https://reverseengineering.stackexchange.com/questions/33245/restoring-the-file-structure-from-a-cocos2d-x-js-android-apk-post-decryption",
    "content": "I am currently learning how to reverse engineer an APK and have made significant progress. Here’s what I've accomplished so far:\n\nDecryption & Code Browsing: Converted the Dalvik bytecode (.dex files) to readable Java and JavaScript code.\nUnbundling: Unbundled the decrypted JavaScript files. (Though they are still minified)\nUUID Decryption: Figured out how to decrypt UUIDs into filenames and vice versa, and found resource paths for some UUIDs.\n\nHowever, I’m stuck on figuring out the correct folder structure for certain assets within the \"Main\" folder.\nWhat I’ve Discovered So Far\nHere’s what I know about the asset packs in the \"Main\" folder:\n\nEach asset pack has a UUID, which corresponds to an image containing multiple assets.\nThere is a JSON file for each asset pack, but these don't provide much useful information regarding the folder structure.\nEach asset in the image has its own JSON file that includes:\n\nThe pack name near the beginning.\nDetails about the asset's position in the image.\n\n\nThe manifest contains every asset's location, but only assets listed in <pre><code>/resources/config.json</code></pre> have \"paths\" to help re-map them.\n\nMy Questions\n\nHow can I determine the correct folder structure for these assets?\nIs there a pattern or tool that can help map these assets to their appropriate locations?\n\nImportant Note: There is NO map file - the manifest lists the obfuscated names and their md5 or sha-256 depending on which one you look at, My goal is to reverse engineer back to the original format that the code references.\nCode Samples & Structure\nI’ve included some relevant code snippets and file structure details to illustrate what I’m working with:\nExample <pre><code>config.json</code></pre> (UUIDs without paths):\n<pre><code>{\n    \"paths\": {},\n    \"types\": [],\n    \"uuids\": [\n        \"05mU7WsllFO4elu4Re6/pm\",\n        \"fcTsdoxZlLpKd3It99/+h6\"\n    ],\n    \"scenes\": {\n        \"db://assets/main.fire\": 127,\n        \"db://assets/start.fire\": 120\n    },\n    \"redirect\": [1, 0, 2, 0, 4, ... 0, 146, 0],\n    \"deps\": [\"resources\", \"internal\"],\n    \"packs\": {},\n    \"name\": \"main\",\n    \"importBase\": \"import\",\n    \"nativeBase\": \"native\",\n    \"debug\": false,\n    \"isZip\": false,\n    \"encrypted\": true\n}\n</code></pre>\nExample of Bundled Code Before Unbundling:\n(but you can see the bottom section provides a filestructure / names for the bundles, which is how I reverse engineered and unbundled it)\n<pre><code>{\n    1: [function(e, t, i) {\n        \"use strict\";\n        const n = i;\n        n.bignum = e(\"bn.js\");\n        n.define = e(\"./asn1/api\").define;\n        n.base = e(\"./asn1/base\");\n        n.constants = e(\"./asn1/constants\");\n        n.decoders = e(\"./asn1/decoders\");\n        n.encoders = e(\"./asn1/encoders\");\n    }, {\n        \"./asn1/api\": 2,\n        \"./asn1/base\": 4,\n        \"./asn1/constants\": 8,\n        \"./asn1/decoders\": 10,\n        \"./asn1/encoders\": 13,\n        \"bn.js\": 15\n    }],\n</code></pre>\nFile Structure\nHere’s a partial view of the file structure I’m working with:\n<pre><code>Directory: T:\\assets\n  Subdirectory: ad-viewer\n  Subdirectory: assets\n  Subdirectory: dexopt\n  Subdirectory: jsb-adapter\n  Subdirectory: src\n  File: audience_network.dex\n  File: cid\n  File: main.js\n  File: project.json\n  File: tt_mime_type.pro\n\nDirectory: T:\\assets\\assets\n  Subdirectory: internal\n  Subdirectory: localizeData\n  Subdirectory: main\n  Subdirectory: manifest\n  Subdirectory: resources\n  Subdirectory: Script\n\nDirectory: T:\\assets\\assets\\internal\n  Subdirectory: import\n  Subdirectory: native\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\internal\\import\n  Subdirectory: 09\n\nDirectory: T:\\assets\\assets\\internal\\import\\09\n  File: 0967b326a.json\n\nDirectory: T:\\assets\\assets\\internal\native\n  Subdirectory: 02\n\nDirectory: T:\\assets\\assets\\internal\native\\02\n  File: 0275e94c-56a7-410f-bd1a-fc7483f7d14a.png\n\nDirectory: T:\\assets\\assets\\localizeData\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\main\n  Subdirectory: import\n  Subdirectory: native\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\main\\import\n  Subdirectory: 05\n  Subdirectory: 06\n  Subdirectory: 08\n  Subdirectory: 12\n.....\nDirectory: T:\\assets\\assets\\manifest\n  Subdirectory: import\n  Subdirectory: native\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\manifest\\import\n  Subdirectory: 83\n\nDirectory: T:\\assets\\assets\\manifest\\import\\83\n  File: 83f57686-53e5-4bc7-bdf0-33bcd506f93b.json\n\nDirectory: T:\\assets\\assets\\manifest\native\n  Subdirectory: 83\n\nDirectory: T:\\assets\\assets\\manifest\native\\83\n  File: 83f57686-53e5-4bc7-bdf0-33bcd506f93b.manifest\n\nDirectory: T:\\assets\\assets\\resources\n  Subdirectory: import\n  Subdirectory: native\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\resources\\import\n  Subdirectory: 00\n  Subdirectory: 01\n  Subdirectory: 02\n....\nDirectory: T:\\assets\\assets\\Script\n  Subdirectory: import\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\Script\\import\n  Subdirectory: c8\n\nDirectory: T:\\assets\\assets\\Script\\import\\c8\n  File: c85c3dbd-5a7d-424c-8e07-965706736336.json\n\nDirectory: T:\\assets\\dexopt\n  File: baseline.prof\n  File: baseline.profm\n\nDirectory: T:\\assets\\jsb-adapter\n  File: jsb-builtin.js\n  File: jsb-engine.js\n\nDirectory: T:\\assets\\src\n  Subdirectory: assets\n  File: cocos2d-jsb.js\n  File: settings.js\n\nDirectory: T:\\assets\\src\\assets\n  Subdirectory: libs\n\nDirectory: T:\\assets\\src\\assets\\libs\n  File: thinkingdata.mg.cocoscreator.min.js\n</code></pre>\nSpecific Asset Example\n\nAsset pack UUID: <pre><code>1e58fbfa7</code></pre>\n\nImage file: <pre><code>assets\\assets\\main\native\\1e\\1e58fbfa7.png</code></pre>\nJSON file: <pre><code>assets\\assets\\main\\import\\1e\\1e58fbfa7.json</code></pre>\nJSON Contents:\n\n\n\n<pre><code>[\n    1,\n    0,\n    0,\n    [\n        \"cc.Texture2D\"\n    ],\n    0,\n    [\n        \"0,9729,9729,33071,33071,0,0,0\",\n        -1\n    ],\n    [\n        0\n    ],\n    0,\n    [],\n    [],\n    []\n]\n</code></pre>\nTraceback\nI search for that string (1e58fbfa7) in all files and find a matching JSON for each of the assets on that image, here is an example of one:\n(I do understand what these are - they are stating where the asset that relates to that file / UUID is on the pack)\n<pre><code>[\n    1,\n    [\n        \"1e58fbfa7\"\n    ],\n    [\n        \"_textureSetter\"\n    ],\n    [\n        \"cc.SpriteFrame\"\n    ],\n    0,\n    [\n        {\n            \"name\": \"UI_Bt_world\",\n            \"rect\": [\n                342,\n                446,\n                127,\n                115\n            ],\n            \"offset\": [\n                0,\n                0.5\n            ],\n            \"originalSize\": [\n                129,\n                116\n            ],\n            \"capInsets\": [\n                0,\n                0,\n                0,\n                0\n            ]\n        }\n    ],\n    [\n        0\n    ],\n    0,\n    [\n        0\n    ],\n    [\n        0\n    ],\n    [\n        0\n    ]\n]\n</code></pre>\nThat JSON is \\assets\\assets\\main\\import\\3a\\3aa50555-73a6-416d-b35a-cfab79466fa7.json\nIf I convert that to a UUID (3apQVVc6ZBbbNaz6t5Rm+n) I will find it in two locations, config.json (snippet provided above) and another location (\\assets\\assets\\main\\import\\9f\\9fde386a-2232-446d-9554-549e101dde19.json) which is somewhat similar to the config.json, but not quite... snippet:\n<pre><code>[\n    1,\n    [\n        \"ecpdLyjvZBwrvm+cedCcQy\",\n...\n    [\n        \"node\",\n        \"_spriteFrame\",\n        \"_N$file\",\n...\n   [\n        [\n            \"cc.Node\",\n            [\n                \"_name\",\n...\n               \"_children\"\n            ],\n            -2,\n            4,\n...\n                ]\n            ],\n            [\n                0,\n                \"58H6b2PPdJip4dKNTXDv0T\",\n                1,\n                0\n            ],\n            [\n                4,\n                4278190080\n            ],\n            [\n                5,\n                1242,\n                2688\n            ]\n        ]\n    ],\n    0,\n    [\n        0,\n        12,\n...\n        96,\n        97,\n        1\n    ]\n]\n</code></pre>\nI convert that file name into a UUID (9f3jhqIjJEbZVUVJ4QHd4Z) and find it in yet another file (\\assets\\assets\\main\\import\\d7\\d726ed83-41aa-4389-bd34-dd1e963ba515.json)...\n<pre><code>[\n    1,\n    [\n        \"9f3jhqIjJEbZVUVJ4QHd4Z\"\n    ],\n    [\n        \"mainNode\",\n        \"node\",\n        \"scene\"\n    ],\n    [\n        [\n            \"cc.SceneAsset\",\n            [\n                \"_name\",\n                \"asyncLoadAssets\"\n            ],\n            1\n        ],\n        [\n            \"cc.Scene\",\n            [\n                \"_name\",\n...\n    [\n        0,\n        -1,\n        2,\n        0,\n        1,\n        2,\n        0,\n        2,\n        1,\n        2\n    ],\n    [\n        0\n    ],\n    [\n        0\n    ],\n    [\n        0\n    ]\n]\n</code></pre>\nI went even deeper, converted that file name to a UUID (d7Ju2DQapDib003R6WO6UV) and looked and found it in one location.... the original config file. So now I'm back to the beginning!\n",
    "votes": "0",
    "answers": 1,
    "views": "80",
    "tags": [
        "android",
        "unpacking",
        "deobfuscation",
        "apk",
        "javascript"
    ],
    "user": "Lucy Taylor",
    "time": "Oct 4, 2024 at 2:12",
    "comments": [],
    "answers_data": [
        {
            "content": "It sounds like you’re making impressive progress with your reverse engineering efforts. You’re stuck at reconstructing the folder structure of the assets, and this can indeed be tricky. However, based on the patterns you’ve discovered, we can attempt to create a strategy to reverse the structure:\nStrategy for Determining the Folder Structure\n\nAnalyze UUID Relationships:\n\n\nYou’ve identified that UUIDs correspond to both asset packs and individual assets. By converting these UUIDs back and forth between JSON files and their image counterparts, you have already managed to trace some dependencies.\nTo move forward, it’s important to explore any hierarchical relationships between these UUIDs. For example, when an asset UUID appears in a JSON file, check how it references other assets and their corresponding files. This often gives hints about the structure, such as child/parent relationships.\n\n\nUse the Asset Pack Information (e.g., “rect”, “offset”, “originalSize”):\n\n\nThe metadata in the JSON files, particularly fields like \"rect\", \"offset\", and \"originalSize\", gives clues about how assets were packed into a texture atlas. If certain assets are packed together (as indicated by shared UUIDs or proximity in the texture), they may belong in the same folder or share a common prefix in the file structure.\nPattern Recognition: Look for patterns in asset metadata to determine if they relate to certain parts of the game. For example, UI elements might share common characteristics, which could suggest they belong in a UI folder.\n\n\nPath Reconstruction from Known UUIDs:\n\n\nSince some assets in the config.json have paths, you can use these as a starting point for the folder structure. For example, assets related to specific game scenes like \"db://assets/main.fire\" might reside in the assets/main folder.\nUse the assets that have paths as “anchors” and attempt to match their structure to the UUIDs that don’t yet have paths. You can cross-reference these with their relationships in the JSON files.\n\n\nExamine Obfuscated Names and Hashes (MD5 or SHA-256):\n\n\nThe manifest contains MD5 or SHA-256 hashes of asset files. These are likely computed from the file contents, filenames, or paths. While it’s difficult to reverse these directly, you might observe patterns between the hashes of similar assets (e.g., UI elements, textures).\nYou could attempt to compute hashes of certain path combinations and compare them against the values in the manifest to reconstruct parts of the folder structure.\n\n\nFolder Structure from Resource Metadata:\n\n\nThe \"packs\": {} section of config.json indicates grouping of certain assets. Investigate if these groupings follow a consistent naming convention or folder hierarchy.\nCheck if there are any consistent prefixes or suffixes in the UUIDs or paths for assets that should belong in the same folder (e.g., textures, models, sounds). This could provide insights into how folders should be organized.\n\nTools & Techniques to Help\n\nAutomated Dependency Trackers:\n\n\nTools like Unity Asset Bundle Extractor (even if you’re not working with Unity, these tools might help interpret textures and packed assets) or APK reverse-engineering tools like JEB could help in further automating the analysis.\nYou might use a script (e.g., Python) to recursively trace dependencies through the JSON files, reconstructing the relationships between assets and helping generate a potential folder structure.\n\n\nCross-reference UUIDs and Hashes:\n\n\nConsider generating a script to extract UUIDs and their corresponding asset data (e.g., position in atlas, size, type) and then attempt to sort them into potential folder structures based on their metadata. As you process more files, patterns should emerge.\n\n\nVisualization of Assets in Texture Atlases:\n\n\nVisualizing the rect coordinates and asset positions on the texture atlas might help you guess at the logical grouping of assets. If you can map assets spatially, it might reveal clues about folder structure (e.g., UI elements packed closely together).\nTools like Texture Packer can be used to visualize texture atlases and help you identify how the assets are grouped.\n\nAdditional Steps to Consider\n\nRecursive Conversion of UUIDs: You’ve done this manually, but consider writing a script to automate the process of recursively converting UUIDs and tracing the connections between assets. This can speed up the process of identifying groupings and dependencies.\nGuess the Original Folder Structure: For assets you can’t place definitively, consider trying common folder structures used in game development (e.g., UI, Textures, Audio, Scenes, Scripts) and see if these align with any of the UUID patterns or JSON relationships.\nTest Iterations: Once you’ve mapped out a possible structure, you could attempt a test reorganization and see if it matches what’s expected in the execution of the app, based on the decompiled JavaScript code.\n\nWith these strategies, you should be able to progress further in reconstructing the original asset structure from the obfuscated files.\n",
            "votes": "0",
            "user": "Maximiliano López",
            "time": "Oct 8, 2024 at 2:15",
            "is_accepted": false,
            "comments": [
                {
                    "user": "sudhackar",
                    "text": "<span class=\"comment-copy\">This reads like its written by chatgpt</span>",
                    "time": null
                }
            ]
        }
    ]
}