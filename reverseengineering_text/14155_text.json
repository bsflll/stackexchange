{
    "title": "C++ to assembly, GCC vs CL",
    "link": "https://reverseengineering.stackexchange.com/questions/14155/c-to-assembly-gcc-vs-cl",
    "content": "I have following C++ code:\n<pre><code>int main(){\n\n  int a = 1;\n  double d = 1.2;\n\n  return 0;\n}\n</code></pre>\nand get the following assembly using GCC 6.2 -m32:\n<pre><code>main:\n        lea     ecx, [esp+4]\n        and     esp, -8\n        push    DWORD PTR [ecx-4]\n        push    ebp\n        mov     ebp, esp\n        push    ecx\n        sub     esp, 20\n        mov     DWORD PTR [ebp-12], 1\n        fld     QWORD PTR .LC0\n        fstp    QWORD PTR [ebp-24]\n        mov     eax, 0\n        add     esp, 20\n        pop     ecx\n        pop     ebp\n        lea     esp, [ecx-4]\n        ret\n.LC0:\n        .long   858993459\n        .long   1072902963\n</code></pre>\nand using MS CL 19:\n<pre><code>_d$ = -12                                         ; size = 8\n_a$ = -4                                                ; size = 4\n_main   PROC\n        push     ebp\n        mov      ebp, esp\n        sub      esp, 12              ; 0000000cH\n        mov      DWORD PTR _a$[ebp], 1\n        movsd    xmm0, QWORD PTR __real@3ff3333333333333\n        movsd    QWORD PTR _d$[ebp], xmm0\n        xor      eax, eax\n        mov      esp, ebp\n        pop      ebp\n        ret      0\n_main   ENDP\n</code></pre>\nI have several questions.\n\nwhat's  mean first three lines in GCC version?\n<pre><code>lea     ecx, [esp+4]</code></pre>\n<pre><code>and     esp, -8</code></pre>\n<pre><code>push    DWORD PTR [ecx-4]</code></pre>\nMS CL version allocates 12 bytes, 4 for int and 8 for double: \n<pre><code>sub      esp, 12  // that's great.</code></pre>\nBut why GCC allocates 24?\n<pre><code>push ecx</code></pre>\n<pre><code>sub esp, 20</code></pre>\n",
    "votes": "1",
    "answers": 1,
    "views": "850",
    "tags": [
        "disassembly",
        "assembly",
        "c++",
        "disassemblers",
        "gcc"
    ],
    "user": "Person.Junkie",
    "time": "Dec 12, 2016 at 22:01",
    "comments": [],
    "answers_data": [
        {
            "content": "Given that you didn't specify any optimization flag and used -m32, GCC performed no optimization on your code. The -m32 flag specifies the generation of a 32 bit code for a compiler configured to generate 64 bit code by default. In 32 bit mode, even with optimizations activated, GCC will generate a sub-optimal code given that the only way to do floating point computations in 32 bit mode on Intel machines is through x87 instructions. If you remove the -m32 flag and add -O3 (third level of optimization in GCC) you'll obtain the following assembly code (quite similar to the one generated by Microsoft's CL) :\n<pre><code>.LC1:\n        .string \"%d %lf\n\"\n        .section   .text.startup,\"ax\",@progbits\n        .p2align 4,,15\n        .globl  main\n        .type   main, @function\nmain:\n.LFB0:\n        .cfi_startproc\n        subq    $8, %rsp\n        .cfi_def_cfa_offset 16\n        movl    $1, %esi\n        movl    $.LC1, %edi\n        movsd   .LC0(%rip), %xmm0\n        movl    $1, %eax\n        call    printf\n        xorl    %eax, %eax\n        addq    $8, %rsp\n        .cfi_def_cfa_offset 8\n        ret\n        .cfi_endproc\n.LFE0:\n        .size   main, .-main\n        .section   .rodata.cst8,\"aM\",@progbits,8\n        .align 8\n.LC0:\n        .long   858993459\n        .long   1072902963 \n</code></pre>\nNote : I added a printf to the code because if the GCC optimization pass sees no use of the two variables, they will be removed (dead code elimination). I invite you to check out my post on the subject of optimized vs. non optimized code (Assembly Code - GCC optimized vs not).\nYou can also notice that CL used an XMM register to store the 64 bit double element stored in .LC0. XMM registers are part of the SSE (Streaming SIMD Extensions) instruction set used mainly for floating point scalar & vector operations. Its implementation is much cleaner and faster than the x87 instruction set. \nQ1 :\n<pre><code>lea     ecx, [esp+4]      //load the content of [esp + 4] into ecx\nand     esp, -8           //align the stack pointer to 8 bytes (same as esp & ~7)\npush    DWORD PTR [ecx-4] //push the content of [ecx - 4] on the stack \n\n[ecx - 4] = [[esp + 4] - 4]\n</code></pre>\nLet's suppose the stack is in this state : \n<pre><code>     |       main      |\n     |      return     |\n     |      address @  |\n     +-----------------+  <--- esp + 4 ---> ecx\n     |    some value   |\n     +-----------------+  <--- esp = ebp\n</code></pre>\nThe first instruction puts the existing stack content (main return address @) in ecx. It is equivalent to this :\n<pre><code>mov ecx, esp\nsub ecx, 4\nmov ecx, [ecx]\n</code></pre>\nYou can see that the lea instruction does in one take what these instructions do in three takes.\nThe second instruction aligns esp on an 8 byte boundary. What that means is that the lower 3 order bits of the address pointed by esp will be 0. Memory accesses are faster on Intel machines when aligned on a power of 2 boundary.\nThe third instruction changes the state of the stack to the following :\n<pre><code>     |         @       |\n     +-----------------+  <--- esp + 4 ---> ecx\n     |    some value   |\n     +-----------------+  <--- ebp\n     |       @ - 4     |  \n     +-----------------+  <--- esp\n</code></pre>\nTherefore, when the main function is done, it will return to @ - 4.\nQ2 :\nLet's reason mathematically :\n<pre><code>         We have : EBP = ESP0 \n         push ecx implies ESP1 = ESP0 - 4 \n         then : ESP2 = ESP1 - 20 \n         therefore : ESP0 = ESP2 - 24\n         mov DWORD PTR [ebp-12], 1 implies x = EBP - 12 = ESP0 - 12\n         We know that ESP0 = ESP2 - 24\n         Therefore x = ESP2 - 24 - 12 = ESP2 - 36\n         fstp    QWORD PTR [ebp-24] implies y = EBP - 24 = ESP0 - 24\n         Therefore y = ESP2 - 24 - 24 = ESP2 - 48\n</code></pre>\nNow, from this demonstration we extracted the location of the integer x = ESP2 - 36, and the location of the double y = ESP2 - 48.\nTo compute the distance between both variables, we subtract y from x and obtain the following : x - y = ESP2 - 36 - ESP2 + 48 = 48 - 36 = 12. And that's the amount of bytes used by GCC for storing both of your 32 bit/4 byte and 64 bit/8 byte variables.\n",
            "votes": "4",
            "user": "Community",
            "time": "Apr 13, 2017 at 12:49",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Person.Junkie",
                    "text": "<span class=\"comment-copy\">Thanks, why we have this three lines in GCC 32-bit mode and don't have in 64-bit mode. What is the purpose of this three lines?</span>",
                    "time": null
                },
                {
                    "user": "yaspr",
                    "text": "<span class=\"comment-copy\">Check the Q1 update</span>",
                    "time": null
                }
            ]
        }
    ]
}