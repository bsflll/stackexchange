{
    "title": "How calls work in x86",
    "link": "https://reverseengineering.stackexchange.com/questions/15644/how-calls-work-in-x86",
    "content": "I am studying some X86 code and I often see calls:\n<pre><code>call sym.imp.printf\ncall sym.imp.scanf\ncall sym.imp.strcmp\ncall sym.imp.__stack_chk_fail\n</code></pre>\nThose examples are the most common calls.\nBut how do they actually work?\nI mean, I know they are system calls, also printf along with scanf, strcmp are C functions. But my question is where do they get the parameters from?\nsym.imp.strcmp: where is it getting strings from to compare?\nWhere is the value of scanf saved?\nAnd also, what does the call sym.imp.__stack_chk_fail does?\n",
    "votes": "1",
    "answers": 1,
    "views": "9k",
    "tags": [
        "assembly",
        "x86",
        "system-call"
    ],
    "user": "Florin",
    "time": "Jun 23, 2017 at 17:09",
    "comments": [],
    "answers_data": [
        {
            "content": "System calls vs. function calls\n\nI mean, I know they are system calls, also printf along with scanf, strcmp are C functions.\n\nMany C library functions are wrappers around system calls. <pre><code>printf</code></pre> and <pre><code>scanf</code></pre> are are examples of this. However, it should not be assumed that all C library functions execute system calls, as none of the <pre><code>string.h</code></pre> library functions, including <pre><code>strcmp</code></pre>,  execute any system calls.\n\nA system call is a controlled entry point into the kernel, allowing a process to request that the kernel perform some action on the process’s behalf. The kernel makes a range of services accessible to programs via the system call application programming interface (API).1\n\nThe mechanism by which system calls are made is quite different than by that which function calls are made:\n\nThe [C library] wrapper function executes a trap machine instruction (<pre><code>int 0x80</code></pre>), which causes the processor to switch from user mode to kernel mode and execute code pointed to by location <pre><code>0x80</code></pre> (128 decimal) of the system’s trap vector.\nMore recent x86-32 architectures implement the <pre><code>sysenter</code></pre> instruction, which provides a faster method of entering kernel mode than the conventional int <pre><code>0x80</code></pre> trap instruction. The use of <pre><code>sysenter</code></pre> is supported in the 2.6 kernel and from glibc 2.3.2 onward.1\n\nHere is a visual depiction of the C library function <pre><code>execve</code></pre> being executed, in which <pre><code>execve</code></pre> makes a system call:\n\nx86 calling conventions\nWhen a function is called, flow of control branches to a different location in memory via the <pre><code>call</code></pre> instruction:\n\nSaves procedure linking information on the stack and branches to the procedure (called procedure) specified with the destination (target) operand. The target operand specifies the address of the first instruction in the called procedure. This operand can be an immediate value, a general purpose register, or a memory location.2\n\nHere is some simple example code:\n<pre><code>0804841d <main>:\n 804841d:       55                      push   %ebp\n 804841e:       89 e5                   mov    %esp,%ebp\n 8048420:       83 e4 f0                and    $0xfffffff0,%esp\n 8048423:       83 ec 20                sub    $0x20,%esp\n 8048426:       c7 44 24 18 f0 84 04    movl   $0x80484f0,0x18(%esp)\n 804842d:       08 \n 804842e:       c7 44 24 1c 04 00 00    movl   $0x4,0x1c(%esp)\n 8048435:       00 \n 8048436:       8b 44 24 18             mov    0x18(%esp),%eax\n 804843a:       89 44 24 08             mov    %eax,0x8(%esp)         <--- argument 3\n 804843e:       8b 44 24 1c             mov    0x1c(%esp),%eax\n 8048442:       89 44 24 04             mov    %eax,0x4(%esp)         <--- argument 2\n 8048446:       c7 04 24 0a 85 04 08    movl   $0x804850a,(%esp)      <--- argument 1\n 804844d:       e8 9e fe ff ff          call   80482f0 <printf@plt>   <--- function call\n 8048452:       b8 00 00 00 00          mov    $0x0,%eax\n 8048457:       c9                      leave  \n 8048458:       c3                      ret\n</code></pre>\nHere, the memory address that execution branches to when <pre><code>printf</code></pre> is called via <pre><code>call</code></pre> is <pre><code>0x80482f0</code></pre>.\n\nBut my question is where do they get the parameters from?\n\nArguments are pushed onto the stack in reverse order of their corresponding parameters in the function definition prior to the function call. The return value is saved in <pre><code>%eax</code></pre>. This is in accordance with x86 calling convention, referred to as cdecl:\n\nCaller Rules\nTo make a subrouting call, the caller should:\n\nBefore calling a subroutine, the caller should save the contents of certain registers that are designated caller-saved. The caller-saved registers are EAX, ECX, EDX. Since the called subroutine is allowed to modify these registers, if the caller relies on their values after the subroutine returns, the caller must push the values in these registers onto the stack (so they can be restore after the subroutine returns.\n\nTo pass arguments to the subroutine, push them onto the stack before the call. The arguments should be pushed in inverted order (i.e. last argument first). Since the stack grows down, the first arguments will be stored at the lowest address (this inversion of arguments was historically used to allow functions to be passed a variable number of parameters).\n\nTo call the subroutine, use the call instruction. This instruction places the return address on top of the arguments on the stack, and branches to the subroutine code. This invokes the subroutine, which should follow the callee rules below.\n\n\nAfter the subroutine returns (immediately following the call instruction), the caller can expect to find the return value of the subroutine in the register EAX. To restore the machine state, the caller should:\n\nRemove the arguments from stack. This restores the stack to its state before the call was performed.\nRestore the contents of caller-saved registers (EAX, ECX, EDX) by popping them off of the stack. The caller can assume that no other registers were modified by the subroutine. 3\n\n\nFor a more in-depth discussion of x86 calling conventions, refer to the x86 ABI documentation found in the System V Application Binary Interface Intel386 Architecture Processor Supplment, Fourth Edition.\n<pre><code>__stack_chk_fail</code></pre> and stack guards\n\nAnd also, what does the call sym.imp.__stack_chk_fail does?\n\n<pre><code>__stack_chk_fail</code></pre> is called when the stack canary has been overwritten due to a buffer overflow:\n\nThe basic idea behind stack protection is to push a \"canary\" (a randomly chosen integer) on the stack just after the function return pointer has been pushed. The canary value is then checked before the function returns; if it has changed, the program will abort. Generally, stack buffer overflow (aka \"stack smashing\") attacks will have to change the value of the canary as they write beyond the end of the buffer before they can get to the return pointer. Since the value of the canary is unknown to the attacker, it cannot be replaced by the attack. Thus, the stack protection allows the program to abort when that happens rather than return to wherever the attacker wanted it to go.4\n\nHere is some example annotated code:\n<pre><code>000000000040055d <test>:\n  40055d:   55                      push   %rbp\n  40055e:   48 89 e5                mov    %rsp,%rbp\n  400561:   48 83 ec 20             sub    $0x20,%rsp\n  400565:   89 7d ec                mov    %edi,-0x14(%rbp)\n  400568:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax     <- get guard variable value\n  40056f:   00 00 \n  400571:   48 89 45 f8             mov    %rax,-0x8(%rbp)   <- save guard variable on stack\n  400575:   31 c0                   xor    %eax,%eax\n  400577:   8b 45 ec                mov    -0x14(%rbp),%eax\n  40057a:   48 8b 55 f8             mov    -0x8(%rbp),%rdx   <- move it to register\n  40057e:   64 48 33 14 25 28 00    xor    %fs:0x28,%rdx     <- check it against original\n  400585:   00 00 \n  400587:   74 05                   je     40058e <test+0x31>\n  400589:   e8 b2 fe ff ff          callq  400440 <__stack_chk_fail@plt> \n  40058e:   c9                      leaveq \n  40058f:   c3                      retq   \n</code></pre>\n\n1. The Linux Programming Interface, Chapter 3 \"System Programming Concepts\"\n2. x86 Instruction Set Reference - CALL - c9x.me\n3. x86 Assembly Guide - University of Virginia Computer Science\n4. \"Strong\" stack protection for GCC - LWN.net\n",
            "votes": "7",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Florin",
                    "text": "<span class=\"comment-copy\">Thank you for the answer! Now I understand how things works.  Is there any way to get in touch with you for more informations?</span>",
                    "time": null
                },
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">@FineasSilaghi I'm on twitter so you can message me there if you like. What kind of additional information are you interested in?</span>",
                    "time": null
                },
                {
                    "user": "Florin",
                    "text": "<span class=\"comment-copy\">I can't find SYS_V via Twitter</span>",
                    "time": null
                },
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">@FineasSilaghi <a href=\"https://twitter.com/_SYS_V\" rel=\"nofollow noreferrer\">twitter.com/_SYS_V</a></span>",
                    "time": null
                }
            ]
        }
    ]
}