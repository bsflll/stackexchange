{
    "title": "Getting to the specific offset in assembly code",
    "link": "https://reverseengineering.stackexchange.com/questions/18750/getting-to-the-specific-offset-in-assembly-code",
    "content": "I try to reverse engineering an application and I came to the point that I don't understand. I have the following disassembled code with <pre><code>gdb</code></pre>:\n<pre><code>   │0x7ffff76f7e4b <_ZN16CRRegistratorImp8RegisterEbPv+587> je     0x7ffff76f7ce6 <_ZN16CRRegistratorImp8RegisterEbPv+230>                                                              │\n   │0x7ffff76f7e51 <_ZN16CRRegistratorImp8RegisterEbPv+593> mov    rdi,QWORD PTR [rbp+0x10]                                                                                             │\n   │0x7ffff76f7e55 <_ZN16CRRegistratorImp8RegisterEbPv+597> mov    rax,QWORD PTR [rdi]                                                                                                  │\n   │0x7ffff76f7e58 <_ZN16CRRegistratorImp8RegisterEbPv+600> call   QWORD PTR [rax+0x30]                                                                                                 │\n   │0x7ffff76f7e5b <_ZN16CRRegistratorImp8RegisterEbPv+603> test   al,al                                                                                                                │\n   │0x7ffff76f7e5d <_ZN16CRRegistratorImp8RegisterEbPv+605> je     0x7ffff76f7ce6 <_ZN16CRRegistratorImp8RegisterEbPv+230>                                                              │\n   │0x7ffff76f7e63 <_ZN16CRRegistratorImp8RegisterEbPv+611> jmp    0x7ffff76f7d29 <_ZN16CRRegistratorImp8RegisterEbPv+297>      \n   │0x7ffff76f7e68 <_ZN16CRRegistratorImp8RegisterEbPv+616> xor    edx,edx                                                                                                              │\n   │0x7ffff76f7e6a <_ZN16CRRegistratorImp8RegisterEbPv+618> mov    rsi,r12                                                                                                              │\n   │0x7ffff76f7e6d <_ZN16CRRegistratorImp8RegisterEbPv+621> mov    rdi,rbp                                                                                                              │\n   │0x7ffff76f7e70 <_ZN16CRRegistratorImp8RegisterEbPv+624> call   0x7ffff7596518 <_Z18CallRegGuiCallbackP13CRRegistratorPv13ERegGUIAction@plt>                                         │\n   │0x7ffff76f7e75 <_ZN16CRRegistratorImp8RegisterEbPv+629> jmp    0x7ffff76f7e41 <_ZN16CRRegistratorImp8RegisterEbPv+577>                                                              │\n   │0x7ffff76f7e77 <_ZN16CRRegistratorImp8RegisterEbPv+631> mov    edx,0x4                                                                                                              │\n   │0x7ffff76f7e7c <_ZN16CRRegistratorImp8RegisterEbPv+636> mov    rsi,r12                                                                                                              │\n   │0x7ffff76f7e7f <_ZN16CRRegistratorImp8RegisterEbPv+639> mov    rdi,rbp                                                                                                              │\n   │0x7ffff76f7e82 <_ZN16CRRegistratorImp8RegisterEbPv+642> call   0x7ffff7596518 <_Z18CallRegGuiCallbackP13CRRegistratorPv13ERegGUIAction@plt>    \n</code></pre>\nThis is not the whole procedure, but I think it is not needed. What I want to know is, how to get to to the address <pre><code>0x7ffff76f7e68</code></pre> (<pre><code>+616</code></pre>). \nI was thinking that somewhere in this procedure I will find something like this instruction:\n<pre><code>jmp    0x7ffff76f7e68 <_ZN16CRRegistratorImp8RegisterEbPv+616></code></pre>\nbut there is no such instruction in this procedure and it is not possible to get it there because on address <pre><code>+611</code></pre> there is the the <pre><code>jmp</code></pre> instruction. So I have the following questions:\n\nIs it dead code?\nIs it possible to jump directly to this specific address (<pre><code>+616</code></pre>) from other procedure?\nIs there another way to get to this address?\n",
    "votes": "3",
    "answers": 1,
    "views": "540",
    "tags": [
        "disassembly"
    ],
    "user": "Tom",
    "time": "Jul 10, 2018 at 20:22",
    "comments": [],
    "answers_data": [
        {
            "content": "There are several possibilities. At least it doesn't look like junk, so probably the disassembler engine built into GDB is right about the opcodes.\nGDB is somewhat limited when it comes to showing those details that count when reverse engineering a bigger target. This could actually be dead code, since the names indicate that this is C++ code. Hence there's always a chance that certain virtual functions are never referenced and yet remain in the binary. Essentially there are corner cases that would lead to dead code. But it's hard to tell from this small window into the target that you provide and without more knowledge about the target in question.\nFirst I would start by demangling the names, since you seem to have debug symbols for the application:\n<pre><code>CRRegistratorImp::Register(bool, void*)\nCallRegGuiCallback(CRRegistrator*, void*, ERegGUIAction)\n</code></pre>\nAs per this list you can see that the Linux ABI (System V AMD64 ABI) makes use of the following registers (in order) on x86-64: RDI, RSI, RDX, RCX, R8, R9, XMM0–7.\nFrom this knowledge I'd deduce that these could be two very small wrapper functions to do a similar job:\n<pre><code>; first function\nxor    edx,edx\nmov    rsi,r12\nmov    rdi,rbp\ncall   0x7ffff7596518 <_Z18CallRegGuiCallbackP13CRRegistratorPv13ERegGUIAction@plt>\njmp    0x7ffff76f7e41 <_ZN16CRRegistratorImp8RegisterEbPv+577>\n; second function below\nmov    edx,0x4\nmov    rsi,r12\nmov    rdi,rbp\ncall   0x7ffff7596518 <_Z18CallRegGuiCallbackP13CRRegistratorPv13ERegGUIAction@plt>\n</code></pre>\nRoughly (respectively:\n<pre><code>CallRegGuiCallback($RDI, $RSI, 0);\nCallRegGuiCallback($RDI, $RSI, 0x4);\n</code></pre>\nWithout a proper disassembler you won't be able to tell if that code is dead (== unreferenced). GDB is just too crude a tool for this job. And even with a proper disassembler you will not be a 100% sure that it is dead code even though the disassembler \"reasoned\" it is.\nThat said, give radare2 (free of charge, open source), Hopper (commercial, but affordable) or IDA Pro (commercial, but relatively expensive, yet very very powerful) a try. These should give you a considerably better idea of what parts of the code are referenced by other parts of the code.\nTo answer your questions:\n\nIs it dead code?\nPossible, but there's no way to tell for certain (i.e. to rule out false negatives!).\nIs it possible to jump directly to this specific address (+616) from other procedure?\nCertainly, a <pre><code>jmp</code></pre> may actually even be sufficient, semantically, because these small functions seem to pass the parameters to the <pre><code>call</code></pre> themselves.\nIs there another way to get to this address?\nYeah, from the top of my head I could come up with about half a dozen or so, and there are probably more sneaky ones. However, that (sub-)question is somewhat open-ended. Anyway, you could <pre><code>jmp</code></pre> or use any kind of conditional jump. You could <pre><code>call</code></pre> or you could load the address into a register and do an indirect <pre><code>call</code></pre> or you could obfuscate the address, load it into a register and then do whatever kind of bit-juggling and arithmetic and an indirect call, or you could have a vtable that would end up calling this particular chunk of code.\n\nA bigger chunk of disassembly might help in this case.\n",
            "votes": "4",
            "user": "0xC0000022L",
            "time": "Jul 10, 2018 at 21:02",
            "is_accepted": true,
            "comments": []
        }
    ]
}