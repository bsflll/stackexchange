{
    "title": "Find password in a c compiled binary file",
    "link": "https://reverseengineering.stackexchange.com/questions/24638/find-password-in-a-c-compiled-binary-file",
    "content": "I'm currently learning to do some basic reverse engineering of binary files using Cutter. The program i'm struggling on test if the password entered as argument is correct, if not, return an error message. I have some serious gap in assembly and I can't figure out the password on this one. I've worked on it for some times and arrived at a point where i'm stuck..\nHere is the decompiled code, the test of the password happend during the while/if iterations so what's before is just to give some contex.\n<pre><code>undefined4 main(int param_1,int param_2){\n    undefined4 uVar1;\n    size_t sVar2;\n    undefined4 local_21;\n    undefined4 local_1d;\n    undefined local_19;\n    char *local_18;\n    int local_14;\n    undefined4 *local_10;\n\n    local_10 = &param_1;\n    local_14 = 0;\n    if (param_1 == 2) {\n          local_21 = 0x776f7264;\n          local_1d = 0x70617373;\n          local_19 = 0;\n          local_18 = *(char **)(param_2 + 4);\n          sVar2 = strlen(local_18);\n          if (sVar2 < 8) {\n                uVar1 = 0xffffffff;\n          }\n          else {\n                while (local_14 < 8) {\n                      if ((int)local_18[local_14] + 1 != (int)*(char                   \n                          *)((int)&local_21 + local_14)) {\n                              puts(\"Wrong password.\");\n                              return 0xffffffff;\n                      }\n                      local_14 = local_14 + 1;\n                }\n                puts(\"Access granted.\");\n                uVar1 = 0;\n                }\n          }\n    else {\n          puts(\"One and only one argument PLS.\");\n          uVar1 = 0xffffffff;\n    }\n    return uVar1;\n}\n</code></pre>\nUPDATE 1, What I know from my guess and the help of others :\n\nThe program doesn't return any error message if the password given is less than 8 character. (If it is >=8 it says that the password is incorrect). I do think that the password must be 8 character.\nThe password is probably in hexadecimal. Why do I think that ? the var used during the verification of the password (local_21 = 776f7264 = word) is exactly 8 characters and we do iterate 8 times in the verification.\nThere's some kind of shift involved since we are testing (local_18[local_14] + 1) with local_18 the argument i entered and local_14 the iterator being incremented in the end of the while. From what I've been told that it will shift the password i enter and it need to be the same as (int)*(char *)((int)&local_21 + local_14)) but i can't figure out what is it.\nSo If my though are correct, i need to find a 8 caracter Hexadecimal from which i'll shift the characters (remplace b by a for example) to match what i'm trying to translate \" (int)*(char *)((int)&local_21 + local_14)) \"\n\nI'm trying to find out if I'm right..\nUPDATE 2, Here is a screen of the assembly tree and the while section zoomed in.\nI also commented it below but as you can see there's some section where I just can't understand what's happening :\n<pre><code>VARS : \nlocal_21 = 0x776f7264 ; (String) word used in password comparaison\nlocal_1d = 0x70617373 ;(String) pass but unused\nlocal_14 = 0 ;iterator\nlocal_18 = argv[1] (it's the string given as an argument, let's \n           assume i've entered \"examples\")\n\n- mov edx, dword [local_14] -->  load the value of local_14 into edx \n                                 local_14 = 0\n\n- mov eax, dword[local_18] --> load the function argument into the \n                               register \n                               local_18 = examples\n\n\n- add eax, edx --> add the value 0 to our password (does it means we \n                   add 0 to the address of our input or directly to \n                   the input ?)\n\n- movzx eax, byte[eax] --> get the first character in eax (is he \n                           taking the hexa character 7 ?\n\n- movsx eax, al --> ?\n\n- lea ecx, [eax + 1] --> load the address of [eax+1] into eax (don't \n                         know what is in eax+1..)\n\n- lea edx, [local_21] --> load the address of local_21 in edx\n                          it is 0x776f7264 so what does it stock ? Do \n                          I considerer this as a value or as an \n                          address?\n\n- mov eax, dword[local_14] --> load the value of local_14 (0) into \n                             eax, so 0x0 ?\n\n- add eax, edx -> we add local_14 (0) to eax, so do we have 0x776f7264\n\n- movzx eax, byte[eax] --> exact same thing as before.\n\n- movsx eax, al --> same as before\n\n- cmp ecx, eax --> we compare ecx et eax (eax=?, ecx = [eax+1] = ?)\n\n- add dword [local_14], 1 --> we add 1 to (local_14), it became 1 (our \n                            iterator)\n\n- cmp dword [local-14], 7 --> we compare our iterator with with 7, if \n                              it is lower we continue \n\n- we start again from the start \n</code></pre>\nI have trouble understand if 0x776f7264 is actually an address or just the value in eax. So when i add 1, what is actually happend (2,3 etc..) ? Do i had this directly to the hexa or do I consider adding it to a character ?\nLike 77 = w so i add 1 to w and it gives me x\nI'm really sorry if i have poorly explained my problem and will do my best to answer any questions regarding my post.\nThanks a lot and have a nice day !\n",
    "votes": "2",
    "answers": 1,
    "views": "953",
    "tags": [
        "assembly",
        "decompilation"
    ],
    "user": "xdka",
    "time": "Apr 7, 2020 at 5:04",
    "comments": [
        {
            "user": "Paweł Łukasik",
            "text": "You are almost there with your analysis. I think if you would rename some of the vars and change the types it would be more clear. Maybe support yourself with debugging, too?\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Some of your observations are correct and some are not.\nLet's analyze that:\n\n<pre><code>local_14</code></pre> is indeed a loop iterator, so the while loop is in fact a <pre><code>for</code></pre> loop that runs 8 iterations. You can try renaming that variable to <pre><code>i</code></pre> for better clarity.\n<pre><code>local_18</code></pre> is the user input, which like you observed, should be in the length of 8; otherwise the check fails.\nThe decompiler cannot infer what <pre><code>local_21</code></pre> is and shows it as an integer. However, we can see that <pre><code>local_18</code></pre> is compared to it (<pre><code>local_14</code></pre> used as the index to that buffer), so it might be a <pre><code>char</code></pre> buffer after all. Additionally, we know that the comparison of <pre><code>local_18</code></pre> and <pre><code>local_21</code></pre> is 8 bytes long - so what is going on? Decompilation can be misleading sometime, and this is an example for that: note that <pre><code>local_21</code></pre> and <pre><code>local_1d</code></pre> are consecutive on the stack (which I remind you, grows backwards) so they are in fact a single <pre><code>char</code></pre> buffer in a size of 8. The compiler initializes them both as integers, because this is the optimized way to do so. Note that <pre><code>0x776f7264</code></pre> and <pre><code>0x70617373</code></pre> are ASCII strings, an observation that comes with the experience in reverse engineering. This is just a simple 'memcmp' in a size of 8;  it is hard to see that because of the excessive casting there.\n\nBTW, the password is not hexadecimal, this is just how data is stored in memory. The interpretation of the values are context-depended.\nHope it helps.\n",
            "votes": "2",
            "user": "Eli",
            "time": "Apr 7, 2020 at 11:01",
            "is_accepted": false,
            "comments": []
        }
    ]
}