{
    "title": "Java Help Understanding RSA Encrypt/Decrypt file and SD card",
    "link": "https://reverseengineering.stackexchange.com/questions/26993/java-help-understanding-rsa-encrypt-decrypt-file-and-sd-card",
    "content": "I was directed this way from the main superuser site:\nI have zero experience with Java or Android apps (I have coding experience in C) and tried reverse engineering a [now defunct/unsupported] app which would take a serial number* and encrypt it using RSA with PKCS1Padding.\nI'm happy to share what I have, as the creator is uncontactable, and only a very selected few people have files (or access to the software) in relation to this, so the key can be 'in the wild'. What I believe to be the code is below... I roughly understand what it is doing.\n<pre><code>.class public Lcom/h1dd3n/securefiles/Keygen;\n.super Ljava/lang/Object;\n.source \"Keygen.java\"\n\n\n# static fields\n.field static key:Ljava/lang/String;\n\n.field static modulus:Ljava/math/BigInteger;\n\n.field static pubExp:Ljava/math/BigInteger;\n\n\n# direct methods\n.method static constructor <clinit>()V\n    .locals 3\n\n    .prologue\n    const/16 v2, 0x10\n\n    .line 15\n    const-string v0, \"00FB451D3F45D82B92FC6F243D50441DD75F2DB995842A3D389FC4536A27F42242C9C8DCB4DA0E2573E5CA2E5D0A2AD7E790D8A79CAC2DE68BEAF99D21E229A9CF04ABD09D61C8C66C4FE3B32456496305792FF9D2D2198B87BFAB2637518C1D3F44D27B93EF2C0ED3379993D04944EB356D4BDE343017CFB13405B403A3D81D2C7B099AE5651CF14DD3CBE21C435076F244D9DA8F54DA19BA6301AF1F7DA699E2EBFD9C0BB2778D812E8D9BE66089B2783B9E60FA28FA83CD3B356669BC15BC84058FEEE493CCFBE2E13E0B53B01886D47EB75BFC75758A5CFA5A1836E697FD51846578B4BDEDE3A6BD1FE4D49ABAC072AED433AC5A19BF94C9F6C7F4D95740EF\"\n\n    sput-object v0, Lcom/h1dd3n/securefiles/Keygen;->key:Ljava/lang/String;\n\n    .line 16\n    new-instance v0, Ljava/math/BigInteger;\n\n    sget-object v1, Lcom/h1dd3n/securefiles/Keygen;->key:Ljava/lang/String;\n\n    invoke-direct {v0, v1, v2}, Ljava/math/BigInteger;-><init>(Ljava/lang/String;I)V\n\n    sput-object v0, Lcom/h1dd3n/securefiles/Keygen;->modulus:Ljava/math/BigInteger;\n\n    .line 17\n    new-instance v0, Ljava/math/BigInteger;\n\n    const-string v1, \"010001\"\n\n    invoke-direct {v0, v1, v2}, Ljava/math/BigInteger;-><init>(Ljava/lang/String;I)V\n\n    sput-object v0, Lcom/h1dd3n/securefiles/Keygen;->pubExp:Ljava/math/BigInteger;\n\n    return-void\n.end method\n\n.method public constructor <init>()V\n    .locals 0\n\n    .prologue\n    .line 14\n    invoke-direct {p0}, Ljava/lang/Object;-><init>()V\n\n    return-void\n.end method\n\n.method public static encrypt(Ljava/lang/String;)[B\n    .locals 7\n    .param p0, \"text\"    # Ljava/lang/String;\n\n    .prologue\n    .line 23\n    :try_start_0\n    new-instance v2, Ljava/security/spec/RSAPublicKeySpec;\n\n    sget-object v5, Lcom/h1dd3n/securefiles/Keygen;->modulus:Ljava/math/BigInteger;\n\n    sget-object v6, Lcom/h1dd3n/securefiles/Keygen;->pubExp:Ljava/math/BigInteger;\n\n    invoke-direct {v2, v5, v6}, Ljava/security/spec/RSAPublicKeySpec;-><init>(Ljava/math/BigInteger;Ljava/math/BigInteger;)V\n\n    .line 24\n    .local v2, \"keySpec\":Ljava/security/spec/RSAPublicKeySpec;\n    const-string v5, \"RSA\"\n\n    invoke-static {v5}, Ljava/security/KeyFactory;->getInstance(Ljava/lang/String;)Ljava/security/KeyFactory;\n\n    move-result-object v3\n\n    .line 25\n    .local v3, \"kf\":Ljava/security/KeyFactory;\n    invoke-virtual {v3, v2}, Ljava/security/KeyFactory;->generatePublic(Ljava/security/spec/KeySpec;)Ljava/security/PublicKey;\n\n    move-result-object v4\n\n    .line 27\n    .local v4, \"publicKey\":Ljava/security/PublicKey;\n    const-string v5, \"RSA/ECB/PKCS1Padding\"\n\n    invoke-static {v5}, Ljavax/crypto/Cipher;->getInstance(Ljava/lang/String;)Ljavax/crypto/Cipher;\n\n    move-result-object v0\n\n    .line 28\n    .local v0, \"cipher\":Ljavax/crypto/Cipher;\n    const/4 v5, 0x1\n\n    invoke-virtual {v0, v5, v4}, Ljavax/crypto/Cipher;->init(ILjava/security/Key;)V\n\n    .line 29\n    invoke-virtual {p0}, Ljava/lang/String;->getBytes()[B\n\n    move-result-object v5\n\n    invoke-virtual {v0, v5}, Ljavax/crypto/Cipher;->doFinal([B)[B\n    :try_end_0\n    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0\n\n    move-result-object v5\n\n    .line 35\n    .end local v0    # \"cipher\":Ljavax/crypto/Cipher;\n    .end local v2    # \"keySpec\":Ljava/security/spec/RSAPublicKeySpec;\n    .end local v3    # \"kf\":Ljava/security/KeyFactory;\n    .end local v4    # \"publicKey\":Ljava/security/PublicKey;\n    :goto_0\n    return-object v5\n\n    .line 31\n    :catch_0\n    move-exception v1\n\n    .line 33\n    .local v1, \"e\":Ljava/lang/Exception;\n    invoke-virtual {v1}, Ljava/lang/Exception;->printStackTrace()V\n\n    .line 35\n    const/4 v5, 0x0\n\n    goto :goto_0\n.end method\n</code></pre>\nNow I have a file of which I wish to view the original contents that was encrypted using this method.\nHow on earth do I do that? I'd also be interested in creating new files in a similar way on a Windows based system if possible...\nFull APK source (minus resources as some confidential stuff in there) is available here (it only worked on some v5/v6 Android devices)\nFile I wish to decrypt is [here]\nthe file is generated in SecureKeySource\\smali\\com\\tmsec\\securedisk\\Activator and saved onto the SD Card.\nSerial number is the manufacturer's data from an SD card which is then encrypted and used by another piece of software to allow access. The device was password write protected to prevent deletion/formatting. If you lost this SD card you were screwed as you couldn't access the programs! The device would be checked and deny access if there was a data mismatch. This was the most secure method on an extremely low budget that was thought of at the time of creation - a few years back now; why they did it this way I do not know... I have key backups but no way of associating them with cards or no methods of creating new cards without buying old android tablets/phones and hoping they work with microSD cards (no idea how they originally did it on normal SD cards!! OTG adapters don't seem to show the manufacturer data?). I do have the password to remove write access allowing the cards to be formatted however as that was recorded at least.\nI was hoping that (looking at the extracted source code) there would be some sort of KeyGenerator class where I could enter the new ID as a string and then run.\n",
    "votes": "1",
    "answers": 1,
    "views": "257",
    "tags": [
        "android",
        "encryption",
        "java"
    ],
    "user": "Dan Lewis",
    "time": "Nov 13, 2021 at 4:21",
    "comments": [
        {
            "user": "sudhackar",
            "text": "The links for the files attached need to be public\n",
            "time": null
        },
        {
            "user": "Dan Lewis",
            "text": "Thanks, hadn't noticed. They are now public\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Have you tried using the Frida.re, is an excellent tool for intercepting Android functions, for example you can hook this function responsible for calculating the RSA, see an example from the frida documentation itself:\n<pre><code>import frida, sys\n\ndef on_message(message, data):\n    if message['type'] == 'send':\n        print(\"[*] {0}\".format(message['payload']))\n    else:\n        print(message)\n\njscode = \"\"\"\nJava.perform(function () {\n  // Function to hook is defined here\n  var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity');\n\n  // Whenever button is clicked\n  var onClick = MainActivity.onClick;\n  onClick.implementation = function (v) {\n    // Show a message to know that the function got called\n    send('onClick');\n\n    // Call the original onClick handler\n    onClick.call(this, v);\n\n    // Set our values after running the original onClick handler\n    this.m.value = 0;\n    this.n.value = 1;\n    this.cnt.value = 999;\n\n    // Log to the console that it's done, and we should have the flag!\n    console.log('Done:' + JSON.stringify(this.cnt));\n  };\n});\n\"\"\"\n\nprocess = frida.get_usb_device().attach('com.example.seccon2015.rock_paper_scissors')\nscript = process.create_script(jscode)\nscript.on('message', on_message)\nprint('[*] Running CTF')\nscript.load()\nsys.stdin.read()\n</code></pre>\nTo use this framework you will need to have adb installed on your computer and activate the usb debbug settings, after accepting the RSA that is generated on the connection.\nPlease for a more complete explanation consider reading the following part of the documentation:\nSolving Android CTF\nFor beginners a step-by-step tutorial on dynamic analysis with Frida use:\nFrida Start\n",
            "votes": "1",
            "user": "Happy",
            "time": "Feb 11, 2021 at 12:42",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Happy",
                    "text": "<span class=\"comment-copy\">You can also generate the Java equivalent if you are not familiar with SMALI, this can help you with reconstruct.</span>",
                    "time": null
                }
            ]
        }
    ]
}