{
    "title": "Heap Chunk Structure Does Not Contain Previous Section Info",
    "link": "https://reverseengineering.stackexchange.com/questions/19293/heap-chunk-structure-does-not-contain-previous-section-info",
    "content": "I'm reading Shellcoder's Handbook to learn more about exploitation and overflows. I reached the chapter on Heap Overflows. The book mentions that a heap is split into chunks where each chunk contains two important pieces of info: \n\nThe size of the previous chunk, if allocated\nSize of current chunck\nData\n\nThe following image is taken from a Blackhat presentation\n\nI made a small demo to test this. Below is the code:\n<pre><code>    1 #include <stdio.h>\n    2 #include <string.h>\n    3 #include <stdlib.h>\n    4\n    5 int\n    6 main (int argc, char *argv[]){\n    7     char *buf, *buf2;\n    8\n    9     buf = (char *) malloc(1024);\n   10     buf2 = (char *) malloc(1024);\n   11\n   12     printf(\"buf=%p\n\", buf);\n   13     printf(\"buf2=%p\n\", buf2);\n   14     strcpy(buf, argv[1]);\n   15     strcpy(buf2, argv[2]);\n   16     printf(\"buf=%s\n\", buf);\n   17     printf(\"buf2=%s\n\", buf2);\n   18     free(buf2);\n   19     return 0;\n   20 }\n</code></pre>\nI've placed a breakpoint on line 18 and checked the memory. Here's the dump after running the following command:\n<pre><code>./basicheap $(python -c 'print(\"A\"*1000 + \" \" +\"XXXXABCDEFGH\")')</code></pre>\nThis is the memory dump of <pre><code>buf1</code></pre>:\n<pre><code>[0x08048543]> pxw 0x50 @ [fcnvar.local_1ch]-8\n0x0804b158  0x00000000 0x00000411 0x41414141 0x41414141  ........AAAAAAAA\n0x0804b168  0x41414141 0x41414141 0x41414141 0x41414141  AAAAAAAAAAAAAAAA\n0x0804b178  0x41414141 0x41414141 0x41414141 0x41414141  AAAAAAAAAAAAAAAA\n0x0804b188  0x41414141 0x41414141 0x41414141 0x41414141  AAAAAAAAAAAAAAAA\n0x0804b198  0x41414141 0x41414141 0x41414141 0x41414141  AAAAAAAAAAAAAAAA\n</code></pre>\nThis is the memory dump of <pre><code>buf2</code></pre>:\n<pre><code>[0x08048543]> pxw 0x50 @ [fcnvar.local_20h]-8\n0x0804b568  0x00000000 0x00000411 0x58585858 0x44434241  ........XXXXABCD\n0x0804b578  0x48474645 0x00000000 0x00000000 0x00000000  EFGH............\n0x0804b588  0x00000000 0x00000000 0x00000000 0x00000000  ................\n0x0804b598  0x00000000 0x00000000 0x00000000 0x00000000  ................\n0x0804b5a8  0x00000000 0x00000000 0x00000000 0x00000000  ................\n</code></pre>\nThe output shows <pre><code>0x411</code></pre> as the size of the both chunk, which is 1024 + 17 bits for whatever. This is the the first (and only) piece of information in the header for both chunks.\nHowever, I don't see any info relating to any previous chunks. In Shellcoder's, the author is trying to demonstrate how one can overflow <pre><code>buf1</code></pre> to overwrite the header info of <pre><code>buf2</code></pre>.\nDid the writers of glibc forgo the size of previous chunk in the header info, or is it something I'm missing?\nP.S: The build command I used was <pre><code>gcc -no-pie -g basicheap.c -o basicheap</code></pre>\n",
    "votes": "4",
    "answers": 1,
    "views": "1k",
    "tags": [
        "binary-analysis",
        "radare2",
        "exploit",
        "shellcode",
        "heap"
    ],
    "user": "Solidak",
    "time": "Sep 8, 2018 at 16:18",
    "comments": [],
    "answers_data": [
        {
            "content": "The diagram you linked to seems to be wrong. The size of the previous chunk is stored in the current chunk iff, the previous chunk is free.\nThis image is more appropriate of what an allocated heap chunk looks like.\n\nSource: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/\nLets take the following code to demonstrate this.\n<pre><code>#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main (int argc, char *argv[])\n{\n    char *buf1, *buf2, *buf3;\n    buf1 = (char *) malloc(1024);\n    buf2 = (char *) malloc(1024);\n    buf3 = (char *) malloc(1024);\n\n    printf(\"buf1=%p\n\", buf1);\n    printf(\"buf2=%p\n\", buf2);\n    printf(\"buf3=%p\n\", buf3);\n\n    memset(buf1, 'A', 1024);\n    memset(buf2, 'B', 1024);\n    memset(buf3, 'C', 1024);\n\n    free(buf2);\n    return 0;\n}\n</code></pre>\nNote: Instead of two chunks, I'm taking three chunks or otherwise freeing the first may coalesce it into the top chunk. We will free the middle chunk and examine the chunk contents before and after the <pre><code>free</code></pre> call is executed.\nThe binary was compiled with <pre><code>gcc -m32 -g ./heap.c</code></pre>. Debug the binary in gdb as you would normally and set a breakpoint on line 20 at the <pre><code>free(buf2)</code></pre> call.\n\nWhen the breakpoint hit, let's examine the three chunks.\n\n<pre><code>malloc</code></pre> returns the pointer to <pre><code>chunk + 8</code></pre>, so we subtracted 8 from each of the addresses. Additionally, I've also highlighted the chunk sizes (2nd member of a heap chunk) in the above image.\nHowever the chunk sizes are not actually <pre><code>0x409</code></pre> . Glibc heap chunks are always aligned to 8 bytes which means the last three bits are always zero. Hence, these three bits are used for storing other information (<pre><code>A</code></pre>, <pre><code>M</code></pre> and <pre><code>P</code></pre> bits).\n<pre><code>0x409</code></pre> when converted to binary comes out to be <pre><code>100 0000 1001</code></pre>.\n\nTo get the true chunk size we have to discard the last three bits (<pre><code>A</code></pre> <pre><code>M</code></pre> <pre><code>P</code></pre>) i.e. we should consider only <pre><code>100 0000 1000</code></pre>. When this is converted to decimal we get 1032.\n\nThe true chunk size is indeed 1032. 1024 bytes for our data and the other 8 for the first two members.\nComing back to gdb, lets step over the <pre><code>free</code></pre> call and examine the chunks once again.\n\nChunk 2 has been freed. Let's have a look at chunk 3 (<pre><code>buf3</code></pre>).\n\nThe first member of chunk 3 now contains <pre><code>0x408</code></pre> which is <pre><code>1032</code></pre> in decimal - this is the size of chunk 2. Thus the previous size is stored in chunk 3 only after chunk 2 has been freed, not when it is in-use. \nThe <pre><code>P</code></pre> bit I was referring before stands for <pre><code>PREV_INUSE</code></pre>. This bit is set when the previous chunk is in use. Since the previous chunk is now free this bit is set to 0. As a result the second member now also contains <pre><code>0x408</code></pre> (instead of <pre><code>0x409</code></pre>) which equals <pre><code>100 0000 1000</code></pre>.\n\nAs shown in the image above, the <pre><code>P</code></pre> bit is unset. Hope, this clears your understanding.\n",
            "votes": "9",
            "user": "0xec",
            "time": "Sep 8, 2018 at 21:14",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Solidak",
                    "text": "<span class=\"comment-copy\">This was superb! Thank you so much for the effort!</span>",
                    "time": null
                }
            ]
        }
    ]
}