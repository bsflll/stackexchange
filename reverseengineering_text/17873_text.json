{
    "title": "Help reversing code which uses ATL::CStringT",
    "link": "https://reverseengineering.stackexchange.com/questions/17873/help-reversing-code-which-uses-atlcstringt",
    "content": "I'm attempting to learn reversing techniques using IDA on an exe built with VC/MFC, and could use a little initial help learning some patterns for simplifying the decompiled code. \nIDA found approximately 30K subroutines in my exe, and they make heavy use of the CString class, so that seems like a good place to start. I've read a lot of IDA tutorials and articles, but haven't found anything that covers this specifically.\nHere's a relatively simple example, unmodified by me:\n<pre><code>void __cdecl sub_428258(int a1, int a2, int a3)\n{\n  int v3; // esi\n  int v4; // eax\n  int v5; // eax\n  char v6; // [esp+10h] [ebp-10h]\n  int v7; // [esp+1Ch] [ebp-4h]\n\n  v7 = 0;\n  v3 = ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::ReverseFind(&a1, 92);// Find '\\'\n  if ( v3 < 0\n    && (v3 = ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::ReverseFind(&a1, 47), v3 < 0) )// Find '/'\n  {\n    ATL::CSimpleStringT<wchar_t,1>::Empty(a2);\n    ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::operator=(a3, &a1);// Return empty string in a3\n  }\n  else\n  {\n    v4 = ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::Left(&a1, &v6, v3);\n    LOBYTE(v7) = 1;\n    ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::operator=(a2, v4);\n    LOBYTE(v7) = 0;\n    ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::~CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(&v6);\n    v5 = ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::Right(\n           &a1,\n           &v6,\n           *(_DWORD *)(a1 - 12) - v3 - 1);\n    LOBYTE(v7) = 2;\n    ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::operator=(a3, v5);\n    LOBYTE(v7) = 0;\n    ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::~CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(&v6);\n  }\n  v7 = -1;\n  ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>::~CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t>>>(&a1);\n}\n</code></pre>\nBecause IDA was able to use the MFC PDB file and RTTI, the logic is pretty easy to follow in this case. It seems to be doing something like splitting the first CString param on '\\' or '/', and returning the split strings in the second and third CString params, i.e.:\n<pre><code>void Split(CString source, CString &left, CString &right);\n</code></pre>\nQuestions:\n\nIs this likely a class member function, and if so, how do you know?\nWhy is V7 being set before each call to the CString functions?\nWhat is \"*(_DWORD *)(a1 - 12) - v3 - 1\" doing?\nIs there a way to tell IDA to just use \"CString\" instead of the fully expanded type?\nCan I define a CString struct to help simplify the code?\n\nMy guess is that it is a member function, and that the answers to #2 and #3 have to do with the class definition, but I'm just not sure. An example of the simplified code would really help.\n",
    "votes": "2",
    "answers": 3,
    "views": "2k",
    "tags": [
        "ida",
        "c++",
        "msvc",
        "mfc"
    ],
    "user": "Chris Olsen",
    "time": "Apr 2, 2018 at 15:47",
    "comments": [
        {
            "user": "mrexodia",
            "text": "It might be helpful to know that a CString is a struct with a single pointer in it (it points to the string directly, but in front of it there is extra data). The decompiler doesn’t deal with this nicely at all. Defining the struct can be done but you won’t get much better output other than better CString in front of the casts.\n",
            "time": null
        },
        {
            "user": "mrexodia",
            "text": "Oh and I think V7 is used for exception handling (detection of which state the program is in). I’ll write a full answer later.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "to know that, it's better to look at assembler, not pseudocode. If there's an argument passed to sub_428258 through ECX, most likely yes, this should be a method of some class.\nmaybe error code, which should be returned by the function. I.e. current function definition might be wrong. Can't tell without seeing the assembler.\nseems like it's accessing to some member of the class, pointer to which is stored in a1, so I suppose it's something in ATLString.\nif I understand it correct, those long names - are imported functions, so IDA just demangles and shows the names as is. You may only rename them manually.\nYes, it would help you with 3.\n",
            "votes": "1",
            "user": "Anton Kukoba",
            "time": "Apr 5, 2018 at 12:36",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Chris Olsen",
                    "text": "<span class=\"comment-copy\">Thanks Anton. I have learned a lot more in the 2 days since posting the question, and your answers confirm what I've learned so far. #2 is still a mystery to me, so thanks for the error code suggestion. Will check it out.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "What is \"*(_DWORD *)(a1 - 12) - v3 - 1\" doing?\n\nthis is probably undocumented or poorly documented i don't know \nthese are from memory of my fiddling with this Cstring (be aware for misinterpretation from my part too )\nit is trying to return you the substring after <pre><code>*\\*</code></pre> \nthe Cstring when initialized is normally a part of a bigger structure or class or whatever its terminology is  you can use windbg to follow on any generic Cstring Constructor\n<pre><code>0:000> ?? &s\nclass ATL::CStringT<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t> > > * 0x0016fb2c\n   +0x000 m_pszData        : 0x00584630  \"C:\\Program Files\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\"\n\n0:000> $$ your a1 is == 0x584630 \n0:000> $$ your (a1-12) is == (0x584630 - 0n12) = 0x584624 \n0:000> $$ it is accessing the length of cstring->m_pszData because it is a part of bigger structure \n\n0:000> dt -r cstr!ATL::CNilStringData (0x584630-10)\n   +0x000 pStringMgr       : 0x56dc1578 ATL::IAtlStringMgr\n      +0x000 __VFN_table : 0x567a3458 \n   +0x004 nDataLength      : 0n69\n   +0x008 nAllocLength     : 0n69\n   +0x00c nRefs            : 0n1\n   +0x010 achNil           : [2]  \"C:\"\n\n0:000> $$ CNilStringData is also a part of bigger struct/class but not relevent to present discussion\n\n0:000> ??  (wchar_t *)(( cstr!ATL::CNilStringData *) @@(0x584630-10))->achNil\nwchar_t * 0x00584630\n \"C:\\Program Files\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\"\n\n0:000> ??  (wchar_t *)(( cstr!ATL::CNilStringData *) @@(poi(s)-10))->achNil\nwchar_t * 0x00584630\n \"C:\\Program Files\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\"\n0:000> $$ so *(dword *) (a1-12) is accessing the nDataLength\n</code></pre>\nyou can test with some code like this \n<pre><code>int main()\n{\n    CString s(_T(\"C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2017\\\\Community\\\\Common7\\\\Tools\"));\n    CString t(_T(\"C:\\\\Program Files\"));\n    CString u(_T(\"C:\\\\Program Files\\\\Microsoft Visual Studio\"));\n    CString v(_T(\"C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2017\"));\n    CString w(_T(\"C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2017\\\\Community\"));\n    CString x(_T(\"C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2017\\\\Community\\\\Common7\"));\n    int found;\n    CString temp[6] = { s,t,u,v,w,x };\n    for (int i = 0; i < 6; i++) {\n        printf(\"%x\n\", wcslen(temp[i].GetBuffer()));\n        if ((found = temp[i].ReverseFind(_T('\\\\'))) != -1) {\n            printf(\"%S\n\", (LPCWSTR)temp[i].Mid(found));\n            printf(\"%S\n\", (LPCWSTR)temp[i].Right(found));\n        }\n    }\n\n    return 0;\n}\n</code></pre>\ncompiled and executed you would get \n<pre><code>45\n\\Tools\ngram Files\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\n10\n\\Program Files\nes\n28\n\\Microsoft Visual Studio\nft Visual Studio\n2d\n\\2017\nogram Files\\Microsoft Visual Studio\\2017\n37\n\\Community\n Files\\Microsoft Visual Studio\\2017\\Community\n3f\n\\Common7\nam Files\\Microsoft Visual Studio\\2017\\Community\\Common7\nPress any key to continue . . .\n</code></pre>\nput the compiled exe in windbg and give it a stir\n<pre><code>0:000> .for(r $t0=0; @$t0<6; r $t0 = @$t0+1) { dx  wcslen(temp[@$t0].m_pszData)}\nwcslen(temp[@$t0].m_pszData) : 0x45\nwcslen(temp[@$t0].m_pszData) : 0x10\nwcslen(temp[@$t0].m_pszData) : 0x28\nwcslen(temp[@$t0].m_pszData) : 0x2d\nwcslen(temp[@$t0].m_pszData) : 0x37\nwcslen(temp[@$t0].m_pszData) : 0x3f\n0:000> .for(r $t0=0; @$t0<6; r $t0 = @$t0+1) {dt cstr!ATL::CNilStringData nDataLength @@C++(*(int *)(&temp[@$t0]) - 0x10)}\n   +0x004 nDataLength : 0x45\n   +0x004 nDataLength : 0x10\n   +0x004 nDataLength : 0x28\n   +0x004 nDataLength : 0x2d\n   +0x004 nDataLength : 0x37\n   +0x004 nDataLength : 0x3f\n0:000> .for(r $t0=0; @$t0<6; r $t0 = @$t0+1) {.printf \"%mu\n\" , @@c++((wchar_t *) temp[@$t0].m_pszData)}\nC:\\Program Files\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\nC:\\Program Files\nC:\\Program Files\\Microsoft Visual Studio\nC:\\Program Files\\Microsoft Visual Studio\\2017\nC:\\Program Files\\Microsoft Visual Studio\\2017\\Community\nC:\\Program Files\\Microsoft Visual Studio\\2017\\Community\\Common7\n</code></pre>\n",
            "votes": "1",
            "user": "blabb",
            "time": "Apr 8, 2018 at 12:42",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "Yep, I know it would be \"necroanswer\" but still may be someone find this answer usefull.\n\nIf we have suggestion that decompiler skipped an argument (especially <pre><code>this</code></pre>) you can go into function and return back (then F5), IDA Pro automatically resolve it. No need to check assembler. This commonly happens when arguments passed through registers.\n<pre><code>v7</code></pre> is just compiler \"metainformation\" it's common for MSVC, for my reverse-engineer career I suggests: looks like MSVC set ups points where program goes through function. Just ignore variables like that.\nThis kinda fishy because all functions of <pre><code>CStringT</code></pre> called against <pre><code>a1</code></pre> accept <pre><code>a1</code></pre> with <pre><code>&</code></pre>. But others arguments passed into <pre><code>CStringT</code></pre> without <pre><code>&</code></pre>. This means <pre><code>a2</code></pre> and <pre><code>a3</code></pre> are <pre><code>CStringT</code></pre> pointers (Please see NOTE 1 below). Concerning <pre><code>a1</code></pre> it looks like you have parent structure with <pre><code>CStringT</code></pre> embedded into it. Expression <pre><code>*(_DWORD *)(a1 - 12) - v3 - 1)</code></pre> most likely be <pre><code>PARENT(a1)->Size - v3 - 1</code></pre> in source code. Where PARENT is a macros returning parent of some variable and <pre><code>a1</code></pre> some struct containing <pre><code>CStringT</code></pre>. Something like that:\n\n<pre><code>struct Container {\n    int Size;\n    int Unk0;\n    int Unk1;\n    CStringT String;  // <- a1 points here and CStringT here not a pointer but a part of structure\n    // other fields\n}\n</code></pre>\nIt's also commonly used practice. You could mitigate it in reverse pseudocode with shifted pointers\nAlso some words about <pre><code>v6</code></pre> - it's also a <pre><code>CStringT</code></pre> and because type haven't been defined for it, IDA Pro showed incorrect stack and I suppose other fields present there:\n<pre><code>char v6; // [esp+10h] [ebp-10h]\nint v7; // [esp+1Ch] [ebp-4h]\n</code></pre>\nYou could notice <pre><code>v6</code></pre> passed with <pre><code>&</code></pre> - it means <pre><code>CStringT</code></pre> for <pre><code>v6</code></pre> allocated in stack and not a pointer.\n\nYou could rename it to just <pre><code>CString</code></pre> but you lose information and in program can be other <pre><code>CString</code></pre> templated function. I'd rather said it is quite bad practice to rename \"purple\" functions. But in some case IDA Pro can goes mad then, yep it required :)\n\nSee NOTE 1, if you have to reverse-engineer quite a large program (may be also not large) you must define structures and names. Otherwise you will look just at mess.\n\n\nNOTE 1: For nice and accurate reverse-engineering you should always set types (otherwise you always be in mess). If you not sure for now how type is look likes you could just set it as <pre><code>struct CStringT</code></pre> (<pre><code>struct</code></pre> is necessary!). For IDA Pro it like <pre><code>void*</code></pre> but you note actual type and when <pre><code>CStringT</code></pre> structure will be created IDA Pro substitute it.\nNOTE 2: Using assembler for reverse-engineering at state of art of IDA Pro decompile is mostly unnecessary. Yeap, IDA Pro have errors and we need to fix them in assembler (for example \"immediates\" instead of \"addresses\" for PPC) and also layout firmware into database, etc. But mostly you should use power of decompiler; programs nowaday too large and complex to fiddling with assembler instructions.\nNOTE 3: Yep, you need reverse-engineering to find out another comp\n",
            "votes": "1",
            "user": "mblw",
            "time": "Jun 5, 2023 at 8:19",
            "is_accepted": false,
            "comments": []
        }
    ]
}