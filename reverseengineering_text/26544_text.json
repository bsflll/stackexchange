{
    "title": "Understand/Reverse simple (but good quality) TTS engine",
    "link": "https://reverseengineering.stackexchange.com/questions/26544/understand-reverse-simple-but-good-quality-tts-engine",
    "content": "For quite a long time I wanted to add TTS (text-to-speech) to my MCU applications and I tried quite few of them with more or less success always hitting a wall that either quality is not good or needed CPU power is too much.\nHowever I recently found a very old TTS from ZX Spectrum (in the link is more info and also link to original tap file repository) that is really good and simple (just 801 Bytes of Z80 asm code). So I did it a try , disassembled it (extract the basic and asm from tap file by my own utilities and disassembled with YAZD) and port the result to C++ with complete success. It sound good on both PC and MCU with very little CPU power needed. It produces 1 bit digital sound.\nHere is the C++ source code I made:\n<pre><code>//---------------------------------------------------------------------------\n//---  ZX Hlasovy program voicesoft 1985  -----------------------------------    \n//--- ported to C++ by Spektre ver: 1.001 -----------------------------------\n//---------------------------------------------------------------------------\n#ifndef _speech_h\n#define _speech_h\n//---------------------------------------------------------------------------\n// API:\nvoid sound_out(bool on);    // you need to code this function (should add a sample to sound output)\nvoid say_text(char *txt);   // say null terminated text, \"a'c'\" -> \"áè\"\n//---------------------------------------------------------------------------\n// internals:\nvoid say_char(char chr);    // internal function for single character (do not use it !!!)\nvoid say_wait(WORD ws);     // internal wait (do not use it !!!)\n//---------------------------------------------------------------------------\n// vars:\nbool _sound_on=false;       // global state of the reproductor/sound output\n//---------------------------------------------------------------------------\n// config: (recomputed for 44100 Hz samplerate)\nconst static BYTE t_speed=5;        // [samples] 1/(speech speed) (pitch)\nconst static WORD t_pause=183;      // [samples] pause between chars\nconst static WORD t_space=2925;     // [samples] pause ` `\nconst static WORD t_comma=5851;     // [samples] pause `,`\n//---------------------------------------------------------------------------\n// tables:\nconst static BYTE tab_char0[52]=    //  0..25 normal alphabet A..Z\n    {                               // 26..51 diacritic alphabet A..Z\n    0x00,0x02,0x06,0x0a,0x0e,0x10,0x12,0x16,0x1a,0x1c,0x22,0x26,0x2a,0x2e,0x32,\n    0x34,0x38,0x42,0x48,0x4a,0x4e,0x50,0x50,0x56,0x1a,0x5c,0x64,0x66,0x70,0x74,\n    0x7a,0x7c,0xc2,0x84,0x86,0xc2,0xc2,0xc2,0x88,0x8c,0x92,0x94,0xc2,0x9e,0xa6,\n    0xa8,0xae,0xb0,0xc2,0xc2,0x86,0xbc\n    };\nconst static BYTE tab_char1[196]=\n    {\n    0x36,0x81,0x34,0x19,0x31,0xab,0x18,0x19,0x91,0xc3,0x34,0x19,0x31,0xe0,0x36,\n    0x84,0x92,0xe3,0x35,0x19,0x51,0x9c,0x31,0x31,0x34,0x96,0x36,0x87,0x33,0x3a,\n    0x32,0x3d,0x32,0xc0,0x18,0x19,0x51,0x9c,0x33,0x22,0x31,0xb1,0x31,0x31,0x36,\n    0xa5,0x31,0x31,0x36,0xa8,0x36,0x8a,0x18,0x19,0x31,0xab,0x18,0x19,0x51,0x1c,\n    0x34,0x31,0x32,0x34,0x32,0xb7,0x22,0x10,0x13,0x19,0x21,0xae,0x92,0xc3,0x18,\n    0x19,0x31,0xe0,0x36,0x8d,0x34,0x31,0x32,0x34,0x32,0xb7,0x18,0x19,0x71,0x1c,\n    0x92,0xc3,0x32,0x31,0x32,0x43,0x32,0x44,0x32,0xc5,0x3f,0x81,0x34,0x19,0x31,\n    0x2b,0x33,0x3a,0x32,0x3d,0x32,0xc0,0x18,0x19,0x91,0xd3,0x33,0x19,0x71,0x6d,\n    0x32,0x93,0x3e,0x84,0x92,0x63,0x33,0x3a,0x32,0x3d,0x32,0xc0,0x92,0xf3,0x3e,\n    0x87,0x31,0x31,0x36,0x25,0x31,0x31,0x35,0x25,0x32,0x93,0x3e,0x8a,0x18,0x19,\n    0x31,0x2b,0x33,0x3a,0x32,0x3d,0x32,0xc0,0x13,0x19,0x32,0x60,0x13,0x19,0x71,\n    0xdd,0x92,0xd3,0x18,0x19,0x71,0x6d,0x32,0x93,0x3e,0x8d,0x34,0x31,0x32,0x34,\n    0x32,0x37,0x33,0x3a,0x32,0x3d,0x32,0xc0,0x32,0x53,0x32,0x54,0x32,0xd5,0x1a,\n    0x99\n    };\nconst static BYTE tab_char2[262]=\n    {\n    0x1a,0x99,0xe1,0xc3,0xe1,0xc7,0x8f,0x0f,0xf8,0x03,0x0f,0x07,0xc1,0xe3,0xff,\n    0x40,0x17,0xff,0x00,0x03,0xf8,0x7c,0xc1,0xf1,0xf8,0x03,0xfe,0x00,0x7f,0xfc,\n    0x00,0x03,0xf8,0x0f,0x09,0xf1,0xfe,0x03,0xef,0x40,0x17,0xff,0x00,0x03,0xe1,\n    0x5c,0x35,0xc5,0xaa,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x8e,0x38,0x73,\n    0xcf,0xf8,0x78,0xc3,0xdf,0x1c,0xf1,0xc7,0xfe,0x03,0xc0,0xff,0x00,0x00,0xff,\n    0xf8,0x00,0x7f,0xf8,0x03,0xff,0xf0,0x01,0xff,0xe0,0x03,0xaa,0xca,0x5a,0xd5,\n    0x21,0x3d,0xfe,0x1f,0xf8,0x00,0x00,0x1f,0xff,0xfc,0x20,0x00,0x00,0x03,0xff,\n    0xff,0x08,0x79,0x00,0x02,0xff,0xe1,0xc7,0x1f,0xe0,0x03,0xff,0xd0,0x01,0xff,\n    0xf0,0x03,0x7f,0x01,0xfa,0x5f,0xc0,0x07,0xf8,0x0f,0xc0,0xff,0x00,0x42,0xaa,\n    0xa5,0x55,0x5a,0xaa,0xaa,0x5a,0xa5,0x5a,0xaa,0x55,0x55,0xaa,0xaa,0xa5,0x55,\n    0xaa,0x5a,0xaa,0xa5,0x55,0xaa,0xaa,0xa5,0x55,0xaa,0xaa,0x55,0xa5,0xa5,0xaa,\n    0xa5,0xb7,0x66,0x6c,0xd8,0xf9,0xb3,0x6c,0xad,0x37,0x37,0x66,0xfc,0x9b,0x87,\n    0xf6,0xc0,0xd3,0xb6,0x60,0xf7,0xf7,0x3e,0x4d,0xfb,0xfe,0x5d,0xb7,0xde,0x46,\n    0xf6,0x96,0xb4,0x4f,0xaa,0xa9,0x55,0xaa,0xaa,0xa5,0x69,0x59,0x9a,0x6a,0x95,\n    0x55,0x95,0x55,0x6a,0xa5,0x55,0xa9,0x4d,0x66,0x6a,0x92,0xec,0xa5,0x55,0xd2,\n    0x96,0x55,0xa2,0xba,0xcd,0x00,0x66,0x99,0xcc,0x67,0x31,0x8e,0x66,0x39,0xa6,\n    0x6b,0x19,0x66,0x59,0xc6,0x71,0x09,0x67,0x19,0xcb,0x01,0x71,0xcc,0x73,0x19,\n    0x99,0xcc,0xc6,0x67,0x19,0x9a,0xc6,\n    };\nconst static BYTE tab_char3[5]={ 0x00,0x2e,0x5a,0x5e,0xfe };\n//---------------------------------------------------------------------------\nvoid say_text(char *txt)\n    {\n    WORD hl;\n    BYTE a,b,c;\n    for (b=0xBB,hl=0;;hl++)     // process txt\n        {\n        a=b;                    // a,c char from last iteration\n        c=b;\n        if (!a) break;          // end of txt\n        b=txt[hl];              // b actual char\n        if ((b>='a')&&(b<='z')) b=b+'A'-'a'; // must be uppercase\n        a=c;\n        if ((a>='A')&&(a<='Z'))\n            {\n            // handle diacritic\n            if (a!='C'){ a=b; if (a!='\\'') a=c; else{ a=c; a+=0x1A; b=0xBB; }}\n            else{\n                a=b;\n                if (a=='H'){ a+=0x1A; b=0xBB; }\n                 else{ if (a!='\\'') a=c; else{ a=c; a+=0x1A; b=0xBB; }}\n                }\n            // syntetize sound\n            say_char(a);\n            continue;\n            }\n        if (a==',')say_wait(t_comma);\n        if (a==' ')say_wait(t_space);\n        }\n    }\n//----------------------------------------------------------------------\nvoid say_wait(WORD ws)\n    {\n    for (;ws;ws--) sound_out(_sound_on);\n    }\n//----------------------------------------------------------------------\nvoid say_char(char chr) // chr =  < `A` , `Z`+26 >\n    {\n    WORD hl,hl0;\n    BYTE a,b,c,cy,cy0,ws;\n    hl=tab_char0[chr-'A'];\n    for (;;)\n        {\n        c =tab_char1[hl  ]&0x0F;\n        c|=tab_char1[hl+1]&0x80;\n        for (;;)\n            {\n            a=tab_char1[hl];\n            a=(a>>5)&7;\n            cy=a&1;\n            hl0=hl;\n            if (a!=0)\n                {\n                b=tab_char3[a];\n                hl=hl0;\n                a=tab_char1[hl+1];\n                hl0=hl;\n                cy0=(a>>7)&1;\n                a=((a<<1)&254)|cy;\n                cy=cy0;\n                hl=a;\n                a=0x80;\n                for (;;)\n                    {\n                    _sound_on=(a&tab_char2[hl]);\n                    for (ws=t_speed;ws;ws--) sound_out(_sound_on);\n                    b--;\n                    if (!b) break;\n                    cy=a&1;     \n                    a=((a>>1)&127)|(cy<<7);\n                    if (!cy) continue;\n                    hl++;\n                    }\n                }\n            a^=a;\n            say_wait(t_pause);\n            c--;\n            a=c&0x0F;\n            hl=hl0; \n            if (a==0) break;\n            }\n        cy0=(c>>7)&1;\n        a=((c<<1)&254)|cy;\n        cy=cy0;\n        if (cy) return;\n        hl+=2;\n        }\n    }\n//---------------------------------------------------------------------------\n#endif\n//---------------------------------------------------------------------------\n</code></pre>\nThis works perfectly however I would like to understand how the sound is synthetized. I can not make any sense of it... is it some sort of compression of samples or uses formant filter to synthetize sound or combines them or its something else?\nSo I want to dissect the <pre><code>say_char</code></pre> function to make sense/meaning of the <pre><code>tab_char?[]</code></pre> LUT tables.\n[Edit2] thanks to Edward new more C/C++ like version\nI rearranged the tables and added a lot of comment info to be more didactical and possible to tweak:\n<pre><code>//---------------------------------------------------------------------------\n//---  ZX Hlasovy program voicesoft 1985  -----------------------------------\n//--- ported to C++ by Spektre ver: 2.001 -----------------------------------\n//---------------------------------------------------------------------------\n#ifndef _speech_h\n#define _speech_h\n//---------------------------------------------------------------------------\n// API:\nvoid sound_out(bool on);    // you need to code this function (should add a sample to sound output)\nvoid say_text(char *txt);   // say null terminated text, \"a'c'\" -> \"áč\"\n//---------------------------------------------------------------------------\n// internals:\nvoid say_char(char chr);    // internal function for single character (do not use it !!!)\nvoid say_wait(WORD ws);     // internal wait (do not use it !!!)\n//---------------------------------------------------------------------------\n// vars:\nbool _sound_on=false;       // global state of the reproductor/sound output\n//---------------------------------------------------------------------------\n// config: (recomputed for 44100 Hz samplerate)\nconst static BYTE t_speed=5;        // [samples] 1/(speech speed) (pitch)\nconst static WORD t_pause=183;      // [samples] pause between chars\nconst static WORD t_space=2925;     // [samples] pause ` `\nconst static WORD t_comma=5851;     // [samples] pause `,`\n//---------------------------------------------------------------------------\n// point to RLE encoded character sound (RLE_ix)\nconst static BYTE tab_char[52]=\n    {\n//   A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z\n     0, 1, 3, 5, 7, 8, 9,11,13,14,17,19,21,23,25,26,28,33,36,37,39,40,40,43,13,46,\n//   A' B' C' D' E' F' G' H' I' J' K' L' M' N' O' P' Q' R' S' T' U' V' W' X' Y' Z'\n    50,51,56,58,61,62,97,66,67,97,97,97,68,70,73,74,97,79,83,84,87,88,97,97,67,94,\n    };\n// RLE encoded character sounds\nconst static WORD tab_RLE[98]=\n    {\n    //  15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0\n    // end -----num------ ------------PCM_ix-----------\n                                                // ix char\n    0x9804,                                     //  0 A\n    0x103D,0x8473,                              //  1 B\n    0x203C,0x84AB,                              //  3 C\n    0x103D,0x8524,                              //  5 D\n    0x980B,                                     //  7 E\n    0x892B,                                     //  8 F\n    0x143D,0x8444,                              //  9 G\n    0x0481,0x9035,                              // 11 H\n    0x9812,                                     // 13 I,Y\n    0x0C96,0x089D,0x88A4,                       // 14 J\n    0x203C,0x8444,                              // 17 K\n    0x0C5E,0x8481,                              // 19 L\n    0x0481,0x9865,                              // 21 M\n    0x0481,0x986C,                              // 23 N\n    0x9819,                                     // 25 O\n    0x203C,0x8473,                              // 26 P\n    0x203C,0x0444,0x1081,0x0888,0x888F,         // 28 Q\n    0x0827,0x0C3C,0x847A,                       // 33 R\n    0x88AB,                                     // 36 S\n    0x203C,0x8524,                              // 37 T\n    0x9820,                                     // 39 U\n    0x1081,0x0888,0x888F,                       // 40 V,W\n    0x203C,0x0451,0x88AB,                       // 43 X\n    0x0881,0x08CC,0x08D3,0x88DA,                // 46 Z\n    0xBC04,                                     // 50 A'\n    0x103D,0x0473,0x0C96,0x089D,0x88A4,         // 51 B' *\n    0x203C,0x84E1,                              // 56 C'\n    0x0C3D,0x054C,0x882E,                       // 58 D'\n    0xB80B,                                     // 61 E'\n    0x092B,0x0C96,0x089D,0x88A4,                // 62 F' *\n    0x8959,                                     // 66 CH,H'\n    0xB812,                                     // 67 I',Y'\n    0x0481,0x1865,                              // 68 M' overlap with N' *\n                  0x0481,0x1465,0x882E,         // 70 N' overlap with M'\n    0xB819,                                     // 73 O'\n    0x203C,0x0473,0x0C96,0x089D,0x88A4,         // 74 P' *\n    0x0C3C,0x0924,0x0C3C,0x8517,                // 79 R'\n    0x88E1,                                     // 83 S'\n    0x203C,0x054C,0x882E,                       // 84 T'\n    0xB820,                                     // 87 U'\n    0x1081,0x0888,0x088F,0x0C96,0x089D,0x88A4,  // 88 V',W' *\n    0x0902,0x0909,0x8910,                       // 94 Z'\n    0xA83C,                                     // 97 G',J',K',L',Q',X',W' (no sound)\n    // missing: Ľ/Ĺ,Ř/Ŕ,Ú/ˇU,ô,ä,é/ě\n    // accent?: B',F',M',P',V'\n    // nosound: G',J',K',L',Q',X',W'\n    };\n// formant sounds sampled as 1bit PCM\nconst static BYTE tab_PCM[]=\n    {\n// bits,1bit PCM samples                            //  ix,sample in binary\n     24,0x1A,0x99,0xE1,                             //   0,000110101001100111100001\n     46,0xC3,0xE1,0xC7,0x8F,0x0F,0xF8,              //   4,110000111110000111000111100011110000111111111000\n     46,0x03,0x0F,0x07,0xC1,0xE3,0xFF,              //  11,000000110000111100000111110000011110001111111111\n     46,0x40,0x17,0xFF,0x00,0x03,0xF8,              //  18,010000000001011111111111000000000000001111111000\n     46,0x7C,0xC1,0xF1,0xF8,0x03,0xFE,              //  25,011111001100000111110001111110000000001111111110\n     46,0x00,0x7F,0xFC,0x00,0x03,0xF8,              //  32,000000000111111111111100000000000000001111111000\n     46,0x0F,0x09,0xF1,0xFE,0x03,0xEF,              //  39,000011110000100111110001111111100000001111101111\n     46,0x40,0x17,0xFF,0x00,0x03,0xE1,              //  46,010000000001011111111111000000000000001111100001\n     46,0x5C,0x35,0xC5,0xAA,0x35,0x00,              //  53,010111000011010111000101101010100011010100000000\n      0,                                            //  60,\n     46,0x00,0x00,0x00,0x00,0x00,0x3E,              //  61,000000000000000000000000000000000000000000111110\n     90,0x3E,0x8E,0x38,0x73,0xCF,0xF8,0x78,0xC3,    //  68,0011111010001110001110000111001111001111111110000111100011000011\n        0xDF,0x1C,0xF1,0xC7,                        //     11011111000111001111000111000111\n     94,0x8E,0x38,0x73,0xCF,0xF8,0x78,0xC3,0xDF,    //  81,1000111000111000011100111100111111111000011110001100001111011111\n        0x1C,0xF1,0xC7,0xFE,                        //     00011100111100011100011111111110\n     46,0x03,0xC0,0xFF,0x00,0x00,0xFF,              //  94,000000111100000011111111000000000000000011111111\n     46,0xF8,0x00,0x7F,0xF8,0x03,0xFF,              // 101,111110000000000001111111111110000000001111111111\n     46,0xF0,0x01,0xFF,0xE0,0x03,0xAA,              // 108,111100000000000111111111111000000000001110101010\n     46,0xCA,0x5A,0xD5,0x21,0x3D,0xFE,              // 115,110010100101101011010101001000010011110111111110\n     46,0x1F,0xF8,0x00,0x00,0x1F,0xFF,              // 122,000111111111100000000000000000000001111111111111\n     46,0xFC,0x20,0x00,0x00,0x03,0xFF,              // 129,111111000010000000000000000000000000001111111111\n     46,0xFF,0x08,0x79,0x00,0x02,0xFF,              // 136,111111110000100001111001000000000000001011111111\n     46,0xE1,0xC7,0x1F,0xE0,0x03,0xFF,              // 143,111000011100011100011111111000000000001111111111\n     46,0xD0,0x01,0xFF,0xF0,0x03,0x7F,              // 150,110100000000000111111111111100000000001101111111\n     46,0x01,0xFA,0x5F,0xC0,0x07,0xF8,              // 157,000000011111101001011111110000000000011111111000\n     46,0x0F,0xC0,0xFF,0x00,0x42,0xAA,              // 164,000011111100000011111111000000000100001010101010\n    254,0xAA,0xA5,0x55,0x5A,0xAA,0xAA,0x5A,0xA5,    // 171,1010101010100101010101010101101010101010101010100101101010100101\n        0x5A,0xAA,0x55,0x55,0xAA,0xAA,0xA5,0x55,    //     0101101010101010010101010101010110101010101010101010010101010101\n        0xAA,0x5A,0xAA,0xA5,0x55,0xAA,0xAA,0xA5,    //     1010101001011010101010101010010101010101101010101010101010100101\n        0x55,0xAA,0xAA,0x55,0xA5,0xA5,0xAA,0xA5,    //     0101010110101010101010100101010110100101101001011010101010100101\n     46,0xA5,0x55,0x5A,0xAA,0xAA,0x5A,              // 204,101001010101010101011010101010101010101001011010\n     46,0x5A,0xAA,0xAA,0x5A,0xA5,0x5A,              // 211,010110101010101010101010010110101010010101011010\n     46,0xAA,0x5A,0xA5,0x5A,0xAA,0x55,              // 218,101010100101101010100101010110101010101001010101\n    254,0xB7,0x66,0x6C,0xD8,0xF9,0xB3,0x6C,0xAD,    // 225,1011011101100110011011001101100011111001101100110110110010101101\n        0x37,0x37,0x66,0xFC,0x9B,0x87,0xF6,0xC0,    //     0011011100110111011001101111110010011011100001111111011011000000\n        0xD3,0xB6,0x60,0xF7,0xF7,0x3E,0x4D,0xFB,    //     1101001110110110011000001111011111110111001111100100110111111011\n        0xFE,0x5D,0xB7,0xDE,0x46,0xF6,0x96,0xB4,    //     1111111001011101101101111101111001000110111101101001011010110100\n     46,0x66,0x6C,0xD8,0xF9,0xB3,0x6C,              // 258,011001100110110011011000111110011011001101101100\n     46,0xD8,0xF9,0xB3,0x6C,0xAD,0x37,              // 265,110110001111100110110011011011001010110100110111\n     46,0xB3,0x6C,0xAD,0x37,0x37,0x66,              // 272,101100110110110010101101001101110011011101100110\n     94,0x3E,0x4D,0xFB,0xFE,0x5D,0xB7,0xDE,0x46,    // 279,0011111001001101111110111111111001011101101101111101111001000110\n        0xF6,0x96,0xB4,0x4F,                        //     11110110100101101011010001001111\n     46,0xDE,0x46,0xF6,0x96,0xB4,0x4F,              // 292,110111100100011011110110100101101011010001001111\n    254,0x4F,0xAA,0xA9,0x55,0xAA,0xAA,0xA5,0x69,    // 299,0100111110101010101010010101010110101010101010101010010101101001\n        0x59,0x9A,0x6A,0x95,0x55,0x95,0x55,0x6A,    //     0101100110011010011010101001010101010101100101010101010101101010\n        0xA5,0x55,0xA9,0x4D,0x66,0x6A,0x92,0xEC,    //     1010010101010101101010010100110101100110011010101001001011101100\n        0xA5,0x55,0xD2,0x96,0x55,0xA2,0xBA,0xCD,    //     1010010101010101110100101001011001010101101000101011101011001101\n     94,0x6A,0x92,0xEC,0xA5,0x55,0xD2,0x96,0x55,    // 332,0110101010010010111011001010010101010101110100101001011001010101\n        0xA2,0xBA,0xCD,0x00,                        //     10100010101110101100110100000000\n    254,0x00,0x66,0x99,0xCC,0x67,0x31,0x8E,0x66,    // 345,0000000001100110100110011100110001100111001100011000111001100110\n        0x39,0xA6,0x6B,0x19,0x66,0x59,0xC6,0x71,    //     0011100110100110011010110001100101100110010110011100011001110001\n        0x09,0x67,0x19,0xCB,0x01,0x71,0xCC,0x73,    //     0000100101100111000110011100101100000001011100011100110001110011\n        0x19,0x99,0xCC,0xC6,0x67,0x19,0x9A,0xC6,    //     0001100110011001110011001100011001100111000110011001101011000110\n    };\n//---------------------------------------------------------------------------\nvoid say_text(char *txt)\n    {\n    int i;\n    char a0,a1;\n    for (a1=0xBB,i=0;a1;i++)                            // process txt\n        {\n        a0=a1; a1=txt[i];                               // a0,a1 are last,actual char\n        if ((a1>='a')&&(a1<='z')) a1+='A'-'a';          // a..z -> A..Z\n        if ((a0=='C')&&(a1=='H')){ a0='H'; a1='\\''; }   // CH -> H'\n        if ((a0>='A')&&(a0<='Z'))\n            {\n            if (a1=='\\''){ a0+=0x1A; a1=0xBB; }         // handle diacritic\n            say_char(a0);                               // syntetize sound\n            continue;\n            }\n        if (a0==',') say_wait(t_comma);\n        if (a0==' ') say_wait(t_space);\n        }\n    }\n//----------------------------------------------------------------------\nvoid say_wait(WORD ws)\n    {\n    for (;ws;ws--) sound_out(_sound_on);\n    }\n//----------------------------------------------------------------------\nvoid say_char(char chr) // chr =  < `A` , `Z`+26 >\n    {\n    WORD a;\n    BYTE ws,pcm;\n    int i,j,e,num,pcm_ix,bits;\n    i=tab_char[chr-'A'];\n    for (e=1;e;i++)\n        {\n        a=tab_RLE[i];\n        e     =!(a     &0x8000);\n        num   = (a>>10)&0x001F;\n        pcm_ix=  a     &0x03FF;\n        for (;num;num--)\n            {\n            for (j=pcm_ix,bits=tab_PCM[j],j++;bits;j++)\n             for (pcm=tab_PCM[j],a=0x80;(bits)&&(a);a>>=1,bits--)\n              for (_sound_on=(a&pcm),ws=t_speed;ws;ws--)\n               sound_out(_sound_on);\n            say_wait(t_pause);\n            }\n        }\n    }\n//---------------------------------------------------------------------------\n#endif\n//---------------------------------------------------------------------------\n</code></pre>\n",
    "votes": "5",
    "answers": 1,
    "views": "292",
    "tags": [
        "c++",
        "audio"
    ],
    "user": "Spektre",
    "time": "Dec 18, 2020 at 12:47",
    "comments": [],
    "answers_data": [
        {
            "content": "I can't really understand the speech from the Hlasový program at all, but perhaps it is suitable for your needs.\nI don't have any specific knowledge of this particular software, but based on the time of release and the size, it's almost undoubtedly a formant-based system.  The typical software (on the 8-bit computers of that vintage) used a text-to-phoneme and then phoneme-to-formant conversion.\nA somewhat larger but more intelligible system from that era was \"S.A.M.\" or \"Software Automated Mouth\" that someone has now ported to Javascript.  Follow the links from there to read more, including reverse-engineered C code.\nThe author of that software from the early 1980s, Mark Barton, was actually recently interviewed and offers some insights into that software.\nThis program\nHere's a further analysis of your reverse-engineered software.  I'll tell you how I did it as well as showing the result.  First, I started looking at the inner-most loop and successively rewrote it, testing the result each time to make sure it produced identical results at each step.  Then I essentially repeated that for larger and larger portions of the function.  I also renamed and added variables to make them better reflect how the software is actually using them.  While the Z80 is limited in the registers it can use (and what those registers can do) we do not have that same limitation in C++, so the code is rewritten for clarity.\nsay_char()\n<pre><code>void say_char(char chr)         // chr =  < `A` , `Z`+26 >\n{\n    const Chain *chain = &chain_sequence[chain_start[chr - 'A']];\n    for (BYTE c=0; (c & 0x80) == 0; ++chain) {\n        // count is in low four bits of c, end flag is high bit\n        for (c = chain->copies_and_end(); c & 0xf; --c) {\n            BYTE a = chain->numbits_lookup();\n            if (a != 0) {\n                BYTE bitcount = num_bits[a];\n                BYTE bitloc = chain->start_index();\n\n                // bitcount is the number of bits to emit\n                // starting with the MSB of sound_bits[bitloc]\n                for ( ;bitcount; ++bitloc) {\n                    for (BYTE mask = 0x80; mask; mask >>= 1) {\n                        _sound_on = (mask & sound_bits[bitloc]);\n                        for (BYTE ws = t_speed; ws; ws--)\n                            sound_out(_sound_on);\n                        if (--bitcount == 0)\n                            break;\n                    }\n                }\n            }\n            say_wait(t_pause);\n        }\n    }\n}\n</code></pre>\nHere's the explanation.  First, I renamed the structures:\n<pre><code>tab_char0 --> chain_start\ntab_char1 --> chain_sequence\ntab_char2 --> sound_bits\ntab_char3 --> num_bits\n</code></pre>\nThen I modified the <pre><code>chain_sequence</code></pre> to use a two-byte C++ structure instead.  The definition is this:\n<pre><code>struct Chain {\n        // bits: 7    6    5    4    3    2    1    0\n    BYTE a;  //  m2   m1   c0   -    l3   l2   l1   l0\n    BYTE b;  // end | c7   c6   c5   c4   c3   c2   c1\n\n    bool end() const { return b & 0x80; }\n    BYTE copies() const { return a & 0x0F; }\n    BYTE start_index() const { return ((b & 0x7f) << 1) | ((a & 0x20) >> 5); }\n    BYTE copies_and_end() const {\n        return (a & 0x0F) | (b & 0x80);\n    }\n    BYTE numbits_lookup() const {\n        return (a >> 5) & 7;\n    }\n    friend std::ostream& operator<<(std::ostream& out, const Chain& ch) {\n        return out \n            << \"copies = \" << unsigned(ch.copies())\n            << \", start_index = \" << unsigned(ch.start_index())\n            << \", numbits_lookup = \" << unsigned(ch.numbits_lookup())\n            << \", end = \" << std::boolalpha << bool(ch.b & 0x80)\n            << \", useless = \" << bool(ch.a & 0x10);\n    }\n};\n</code></pre>\nDue to this change, I had to modify the <pre><code>chain_start</code></pre> table to halve each of the entries.\nHow it works\nFor each letter, the code starts with a lookup in the <pre><code>chain_start</code></pre> table.  That is an index into the <pre><code>chain_sequence</code></pre> table.  If we select the first three entries in that table, they look like this:\n<pre><code>const static Chain chain_sequence[98] = {\n    /* A = 0 */ { 0x36, 0x81, },\n    /* B = 1 */ { 0x34, 0x19, }, { 0x31, 0xab, },\n    /* C = 3 */ { 0x18, 0x19, }, { 0x91, 0xc3, },\n</code></pre>\nEach of these is a chain sequence, with the last item identified with the high bit of the second byte set.  For the letter 'A', it translates to this:\n<pre><code>copies = 6, start_index = 3, numbits_lookup = 1, end = true \n</code></pre>\nWhat this then means is that the code creates six copies of a bit pattern.  Each copy ends with <pre><code>t_pause</code></pre> zero bits.  For the beginning bits of each copy, the code uses the <pre><code>numbits_lookup</code></pre> value to look up the desired length in the 5-byte <pre><code>num_bits</code></pre>.  So for 'A', the lookup is 1 and that corresponds to 0x2e = 46, but the way the code is written, that actually corresponds to one fewer bits actually emitted, or 45 in this case.\nNext it uses the <pre><code>start_index</code></pre> as the index into <pre><code>sound_bits</code></pre>.  Each byte in the table is then clocked out starting with the most significant bit of each byte.  So in this case, index 3 and a length of 45 bits corresponds to these entries in the table:\n<pre><code>0xc3 0xe1 0xc7 0x8f, 0x0f, 0xf8\n\n1100 0011  1110 0001  1100 0111  1000 1111  0000 1111  1111 10xx\n</code></pre>\nThe last two bits, marked xx are unused.  So the effect of this is that the output corresponds to six copies of this:\n<pre><code>1100001111100001110001111000111100001111111110\n... followed by `t_pause` 0 bits\n</code></pre>\nCommentary\nTranslation bug\nThere is a bug in the code.  If you look closely, one of the bits in what I'm calling <pre><code>Chain</code></pre> is not used (bit 4 of the first byte), but one of the other bits is used twice (bit 5 of the first byte).\nIndeed, I disassembled the original Z80 code and found this:\n<pre><code>add hl,de       ; cy = 0 (can't overflow)\nld b,(hl)       ; b = bitlen[a];\npop hl          ;\ninc hl          ;\nld a,(hl)       ; a = chain_sequence[hl + 1]\ndec hl          ;\npush hl         ;\nrla             ; the carry shifted in is always zero\nld de,sound_bits    ; point to bit table\nld l,a          ;\nld h,000h       ;\nadd hl,de       ; hl = sound_bits[a]\nld a,080h       ; start with mask = 0x80\n</code></pre>\nYour code seems to imply that the carry bit is set when calling what I've labeled <pre><code>start_index()</code></pre> and it is, but closer to the relevant <pre><code>rla</code></pre> instruction that creates the <pre><code>sound_bits</code></pre> index byte, the carry bit is guaranteed to be zero.  The add instruction, as noted above, cannot overflow and so clears the carry bit.  None of the instructions from there to the <pre><code>rla</code></pre> instruction alter the carry bit, so it is zero at that point.\nOther observations\nAlso the first three bytes of the <pre><code>sound_bits</code></pre> array appear to be unused.\nThere doesn't appear to be a lot of overlapping data, but there could be.  The chain sequence for one of the letters is re-used.  I haven't worked on decoding the actual diacritics used here, but if the second 26 letters are designated A' to Z', the one for M' starts at index 68 and includes 5 chain segments.  The one for N' uses the last three of these segments.\nAlso for short and long versions of the same vowel, such as A and A' (A with čárka signifies a long vowel in Czech), the current code repeats the chain token, but with just a longer sequence.  It might be possible to combine them and use a single bit flag to indicate a vowel.\nOn a 16-bit machine, this could be made much more efficient by restructuring the data.  It could also be modified to be event driven on an embedded system.  For example, this could be interrupt-driven by a timer interrupt.  Or one could create a queue of samples and use DMA transfer to clock them out to a speaker.\nPhysics\nWhat this is doing is creating the lowest frequency via a sequence of bits (minimum of 45) followed by <pre><code>t_pause</code></pre> zeroes.  The higher frequencies are created within the leading bit patterns in each copy.  As expected, this a formant-based synthesizer with relatively low resolution.\n",
            "votes": "6",
            "user": "Edward",
            "time": "Dec 17, 2020 at 16:03",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Spektre",
                    "text": "<span class=\"comment-copy\">nice links and yes those are standard formant using goniometrics... but the ZX TTS engines I saw use just bit masking, bitshifts and LUTs instead (not even integer arithmetic) nowhere resembling any goniometrics (they where done differently with arithmetics btw.) and I am interested on the sciense/tricks behind that ... maybe its some kind of simplification as the output is just 1 bit digital instead of DAC... btw the Hlasovy program is for slavic languages ... not very good for english unless you retype the suff phoneticaly (maybe that is why you did not understand it)</span>",
                    "time": null
                },
                {
                    "user": "Edward",
                    "text": "<span class=\"comment-copy\">If I have time, I'll take a deeper look and update my answer.</span>",
                    "time": null
                },
                {
                    "user": "Spektre",
                    "text": "<span class=\"comment-copy\">Its definatelly working like you are describing. I am in process of rewriting the tables and code to more C++ like and also to be tweakable... Once done I will add it to my quesiton. Btw looks like I was right its RLE compression of PCM sampled Formant base tones :) awesme work would upvote more if I could ... And I think youre right repairing the cy behavior for RLA sounded a bit better... I got the first 2 tables reorganized,...</span>",
                    "time": null
                },
                {
                    "user": "Spektre",
                    "text": "<span class=\"comment-copy\">OK I added my version of re-coded speech following your understanding of the tables function. Thanks a lot for the hard-work.</span>",
                    "time": null
                },
                {
                    "user": "Spektre",
                    "text": "<span class=\"comment-copy\">I updated the code a bit with complete rework of all tables, I also get rid of the bits table and disected the PCM samples alot ...</span>",
                    "time": null
                }
            ]
        }
    ]
}