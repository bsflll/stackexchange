{
    "title": "How does array indexing works at the assembly level?",
    "link": "https://reverseengineering.stackexchange.com/questions/18760/how-does-array-indexing-works-at-the-assembly-level",
    "content": "Can anyone give me an example to understand how array indexing is working in assembly.\nFor example, in C:\n<pre><code>char s[1000]; \n\nfor (int = 0; i < 5; i++)\n{\n  s[i]  = i;\n}\n</code></pre>\nAnd, in x86 assembly:\n<pre><code>add eax,edx\nmovzx eax, byte ptr [eax]\n</code></pre>\n",
    "votes": "-3",
    "answers": 1,
    "views": "2k",
    "tags": [
        "disassembly",
        "assembly"
    ],
    "user": "ReverserT",
    "time": "Jul 11, 2018 at 16:53",
    "comments": [
        {
            "user": "perror",
            "text": "For God sake! Learn about the wiki syntax and try to better proof read your question before hitting the \"Send\" button...\n",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "First you want to know the C version of an array in assembly and now the same in the opposite direction. Tempting to close-vote this as a mirror-duplicate of your earlier question. You accepted an answer ... but did you not understand it? Then you need to work on your assembly knowledge.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "First of all, here is a small example written in C:\n<pre><code>#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_ROW 5\n#define MAX_COLUMN 10\n\nint main (void)\n{\n  int array[MAX_ROW][MAX_COLUMN];\n\n  for (int row = 0; row < MAX_ROW; ++row)\n    for (int column = 0; column < MAX_COLUMN; ++column)\n      array[row][column] = ((row - 1) * (column + 1)) & ~row ;\n\n  for (int i = 0; i < MAX_ROW; ++i)\n    fprintf (stdout, \"array[%1$d][%1$d] = %2$d\n\", i, array[i][i]);\n\n  return EXIT_SUCCESS;\n}\n</code></pre>\nI compiled it with:\n<pre><code>$> gcc -Wall -Wextra -std=c11 -Os -o sample sample.c\n</code></pre>\nThe resulting (amd64) assembly is as follow:\n<pre><code>0000000000001050 <main>:\n    1050:       41 54                   push   %r12\n    1052:       55                      push   %rbp\n    1053:       83 c8 ff                or     $0xffffffff,%eax\n    1056:       53                      push   %rbx\n    1057:       41 b8 fe ff ff ff       mov    $0xfffffffe,%r8d\n    105d:       48 81 ec d0 00 00 00    sub    $0xd0,%rsp\n    1064:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\n    1069:       49 89 cc                mov    %rcx,%r12\n    106c:       44 89 c7                mov    %r8d,%edi\n    106f:       31 d2                   xor    %edx,%edx\n    1071:       29 c7                   sub    %eax,%edi\n    1073:       89 fe                   mov    %edi,%esi\n    1075:       41 89 f1                mov    %esi,%r9d\n    1078:       01 fe                   add    %edi,%esi\n    107a:       41 21 c1                and    %eax,%r9d\n    107d:       44 89 0c 91             mov    %r9d,(%rcx,%rdx,4)\n    1081:       48 ff c2                inc    %rdx\n    1084:       48 83 fa 0a             cmp    $0xa,%rdx\n    1088:       75 eb                   jne    1075 <main+0x25>\n    108a:       ff c8                   dec    %eax\n    108c:       48 83 c1 28             add    $0x28,%rcx\n    1090:       83 f8 fa                cmp    $0xfffffffa,%eax\n    1093:       75 d7                   jne    106c <main+0x1c>\n    1095:       48 8d 2d 68 0f 00 00    lea    0xf68(%rip),%rbp\n    109c:       31 db                   xor    %ebx,%ebx\n    109e:       48 6b c3 2c             imul   $0x2c,%rbx,%rax\n    10a2:       48 8b 3d 87 2f 00 00    mov    0x2f87(%rip),%rdi\n    10a9:       89 da                   mov    %ebx,%edx\n    10ab:       48 89 ee                mov    %rbp,%rsi\n    10ae:       48 ff c3                inc    %rbx\n    10b1:       41 8b 0c 04             mov    (%r12,%rax,1),%ecx\n    10b5:       31 c0                   xor    %eax,%eax\n    10b7:       e8 74 ff ff ff          callq  1030 <fprintf@plt>\n    10bc:       48 83 fb 05             cmp    $0x5,%rbx\n    10c0:       75 dc                   jne    109e <main+0x4e>\n    10c2:       48 81 c4 d0 00 00 00    add    $0xd0,%rsp\n    10c9:       31 c0                   xor    %eax,%eax\n    10cb:       5b                      pop    %rbx\n    10cc:       5d                      pop    %rbp\n    10cd:       41 5c                   pop    %r12\n    10cf:       c3                      retq   \n</code></pre>\nIf we take the time to look precisely at the whole assembly code, we can see that the interesting part is the following:\n<pre><code>1064:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\n1069:       49 89 cc                mov    %rcx,%r12\n106c:       44 89 c7                mov    %r8d,%edi <-----------------\\\n106f:       31 d2                   xor    %edx,%edx                   |\n1071:       29 c7                   sub    %eax,%edi                   |\n1073:       89 fe                   mov    %edi,%esi                   |\n1075:       41 89 f1                mov    %esi,%r9d <-----------\\     |\n1078:       01 fe                   add    %edi,%esi             |     |\n107a:       41 21 c1                and    %eax,%r9d             |     |\n107d:       44 89 0c 91             mov    %r9d,(%rcx,%rdx,4)    |     |\n1081:       48 ff c2                inc    %rdx                  |     |\n1084:       48 83 fa 0a             cmp    $0xa,%rdx             |     |\n1088:       75 eb                   jne    1075 <main+0x25>------/     |\n108a:       ff c8                   dec    %eax                        |\n108c:       48 83 c1 28             add    $0x28,%rcx                  |\n1090:       83 f8 fa                cmp    $0xfffffffa,%eax            |\n1093:       75 d7                   jne    106c <main+0x1c> -----------/\n</code></pre>\nIt depict the double loop that initialize the example matrix where <pre><code>rdx</code></pre> is the <pre><code>column</code></pre> variable (it is compared to <pre><code>0xa</code></pre> which is 10 in decimal) and <pre><code>eax</code></pre> is the <pre><code>row</code></pre> variable (it is compared to <pre><code>0xfffffffa</code></pre> which is -6). For some reasons that we will see later, one index is increased and the other one is decreased, but both start from zero.\nNow, the access to the array is located here:\n<pre><code>107d:       44 89 0c 91             mov    %r9d,(%rcx,%rdx,4)\n</code></pre>\nWhich would be translated into <pre><code>mov [rcx + 4*rdx], r9d</code></pre> in Intel format. Basically:\n\n<pre><code>rcx</code></pre> is the base address of the current row.\n<pre><code>rdx</code></pre> is the column index within the same row vector.\n\nNote that when we move to the next row, <pre><code>rcx</code></pre> is updated like that:\n<pre><code>108c:       48 83 c1 28             add    $0x28,%rcx\n</code></pre>\nBasically, it moves from the current row to the next one knowing that the row contains 10 items and each item is an <pre><code>int</code></pre> (4 bytes). So, 40 bytes in total which is 0x28 in hexadecimal.\nAnd, the very first initialization of <pre><code>rcx</code></pre> is given by:\n<pre><code>1064:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\n</code></pre>\nIt clearly load the address of the <pre><code>array</code></pre> which is somewhere on the stack.\nGetting all together now!\nSo, we have the <pre><code>array</code></pre> on the stack at <pre><code>rsp+0x8</code></pre> which is a contiguous memory area of size:\n<pre><code>5 * 10 * 4 bytes (`rows * columns * sizeof(int)`) = 200 bytes = 0xc8 bytes\n</code></pre>\nAnd, it is mapped as a sequence of rows of 40 bytes each. Each row gather 10 columns with cells of 4 bytes which can be depicted as follow:\n<pre><code>---------------------------------------------------------------------------------\n ... | array[0][0] | array[0][1] | array[0][2] | array[0][3] | array[0][4] | ...\n---------------------------------------------------------------------------------\n</code></pre>\nOf course, you can find more complex mapping when dealing with multi-dimensional arrays in C, this one is quite simple. Just for completude remember that in total generality the mapping of a multi-dimensional array in C looks usually like that:\n\nAnd, the structure of the assembly code will follow these constraints (slightly more complex but not so much once you understood the previous simple example).\n",
            "votes": "7",
            "user": "perror",
            "time": "Jul 11, 2018 at 18:48",
            "is_accepted": false,
            "comments": []
        }
    ]
}