{
    "title": "Can I trap SIGSEGV (on a Linux) and what are are the conditions to make it works? (for a crackme)",
    "link": "https://reverseengineering.stackexchange.com/questions/21597/can-i-trap-sigsegv-on-a-linux-and-what-are-are-the-conditions-to-make-it-works",
    "content": "I'm writing some crackmes.one challenge and I want to write a challenge where the solution appears on a segmentation fault. (And you have to disassemble the code to find a way to segfault. It should be fun, right?)\nI found some hard-to-understand theoretical answer here and there but I can't find a practical solution. Because most of the question are \"how to recover from a sigsegv\" and most of the answer are \"you can't, make your code right so it doesn't segfault\".\nWhat would be the most \"trap-able\" segfault? a call to a null function pointer? a double-free? ...?\nWhat can I do in my signal handler? It seems there are some harsh condition (reentrancy, async-signal-safe function, etc...).\nIf someone can give me some safe pointer (pun intended) to some kind of documentation, blog, ... or an explanation a bit more useful than \"just read the POSIX bible\". It would be greatly appreciated.\nMy code doesn't need to be portable. If it works on a moderately standard Linux (Debian, Redhat, Ubuntu, CentOS) it will be fine.\n",
    "votes": "6",
    "answers": 2,
    "views": "8k",
    "tags": [
        "linux",
        "crackme"
    ],
    "user": "ker2x",
    "time": "Oct 16, 2020 at 8:19",
    "comments": [],
    "answers_data": [
        {
            "content": "A solution working in Windows was given in my question - this way, you can cause program to continue after it receives <pre><code>SIGSEGV</code></pre>.\nYou can do similar thing on linux (though I would recommend using <pre><code>sigaction</code></pre> instead of <pre><code>signal</code></pre> which is deprecated (see link)). That is, register signal handler for this signal and cause it whichever way you prefer to - execution will be passed to the handler, where you can continue.\nAn example code is given below:\n<pre><code>#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nvoid handler(int sig)\n{\n    write(1, \"success\", strlen(\"success\")); // printf is not recommended here, but should work as well\n    exit(0);\n}\n\nint main()\n{\n    struct sigaction sa;\n    memset (&sa, '\\0', sizeof(sa));\n    sa.sa_sigaction = &handler;\n    sa.sa_flags = SA_SIGINFO;\n    sigaction(SIGSEGV, &sa, NULL); // register handler for SIGSEGV\n    int *a; // a will contain some garbage value\n    int b = *a; // trigger segmentation fault; transfer control to handler\n}\n</code></pre>\nOf course, you can use the same trick as in my example on Windows and continue the execution outside <pre><code>handler</code></pre>.\n",
            "votes": "5",
            "user": "bart1e",
            "time": "Jul 1, 2019 at 17:59",
            "is_accepted": true,
            "comments": [
                {
                    "user": "ker2x",
                    "text": "<span class=\"comment-copy\">Thank you ! i bookmarked the post you linked and will read it too. I don't have enough reputation to upvote you but your answer is greatly appreciated.</span>",
                    "time": null
                },
                {
                    "user": "bart1e",
                    "text": "<span class=\"comment-copy\">You can accept it if you feel it answered your question. And if not, let me know about any doubts, so I can improve it.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "An excellent reference (probably the best one) that can be consulted for this type of problem is The Linux Programming Interface, which includes 3 full chapters on the topic of signals:\n\nSignals: Fundamental Concepts\nSignals: Signal Handlers\nSignals: Advanced features\n\nThese chapters include example code as well as diagrams and clear explanations.\n(A free pdf of the book can easily be found online.)\nSee also: Binary Obfuscation Using Signals\nTo your questions:\n\nWhat would be the most \"trap-able\" segfault ? a call to a null function pointer ? a double-free ? ... ?\n\nA signal handler, should it exist, will be called by the kernel on the basis of the signal (specifically, its number as defined in <pre><code><signal.h></code></pre>), rather than the specific event that triggered the signal. This means that you are free to decide what kind of invalid memory reference to make in order to trigger a segmentation fault. Dereferencing a null pointer is probably the most reliable, since it guarantees program behavior will be deterministic, as a segmentation fault will always occur irrespective of stack contents or the layout of the process in memory.\n\n\nWhat can i do in my signal handler ? It seems there are some harsh condition (reentrancy, async-signal-safe function,...).\n\nYou have several options. But first, a bit about non-reentrant library functions:\n\nFunctions can also be nonreentrant if they use static data structures for their\n  internal bookkeeping. The most obvious examples of such functions are the members of the <pre><code>stdio</code></pre> library (<pre><code>printf()</code></pre>, <pre><code>scanf()</code></pre>, and so on), which update internal data structures for buffered I/O. Thus, when using <pre><code>printf()</code></pre> from within a signal handler, we may sometimes see strange output—or even a program crash or data corruption—if the handler interrupts the main program in the middle of executing a call to <pre><code>printf()</code></pre> or another <pre><code>stdio</code></pre> function.\n\nThe important part is the last sentence. Implementing an exception handler for <pre><code>SIGSEGV</code></pre> may result in unintended signal handler behavior if non-reentrant library functions are called within the exception handler, since it may be possible to trigger a segmentation fault outside of the specific conditions you anticipate. For example, when user input is read into a buffer via <pre><code>scanf</code></pre>, unless bounds checking is properly implemented, a buffer overflow due to 1000 'A's being entered can result in <pre><code>SIGSEGV</code></pre> being sent to the process, which will then trigger the exception handler during the execution of an <pre><code>stdio</code></pre> function. If the signal handler also calls an <pre><code>stdio</code></pre> function, undefined behavior may occur.\n\nThe most interesting approach for your case would probably be changing the <pre><code>uc_mcontext.gregs[REG_RIP]</code></pre> (RIP here is the x86-64 instruction pointer) value in the signal handler's <pre><code>context</code></pre> struct to point to a function somewhere else in the program. After the signal handler finishes, program execution would resume at that function. Alternatively, the <pre><code>uc_mcontext.gregs[REG_RIP]</code></pre> value can incremented to skip/jump over the instructions that caused the signal handler to execute in the first place. This means that the signal handler could be designed to simply jump to a different location in the program upon  receiving <pre><code>SIGSEGV</code></pre>. This approach, (or alternatively, executing a nonlocal goto), eliminates the need for any I/O to be performed by the signal handler (no need for <pre><code>printf()</code></pre>, etc.). The drawback is that this approach is architecture-dependent. Examples illustrating this technique can be found in the following article: Linux - Writing Fault Handlers. Some related example code can also be found here: In a signal handler, how to know where the program is interrupted?\nNote that since it is possible for a process to send a signal to itself, it is not necessary to choose <pre><code>SIGSEGV</code></pre> as the handled signal; <pre><code>getpid()</code></pre> and <pre><code>kill()</code></pre> can be used to send some other signal to the process in order to trigger the signal handler. \nAdditionally, it is possible to execute a non-local goto from within the exception handler itself via functions <pre><code>sigsetjmp()</code></pre> and <pre><code>siglongjmp()</code></pre>. Unlike using <pre><code>uc_mcontext.gregs[XXX]</code></pre> to modify the instruction pointer, this approach appears to be portable:\n\n\nIn general, it is preferable to write simple signal handlers. One important reason for this is to reduce the risk of creating race conditions. Two common designs for signal handlers are the following:\n\nThe signal handler sets a global flag and exits. The main program periodically\n  checks this flag and, if it is set, takes appropriate action. (If the main program\n  cannot perform such periodic checks because it needs to monitor one or more\n  file descriptors to see if I/O is possible, then the signal handler can also write a single byte to a dedicated pipe whose read end is included among the file\n  descriptors monitored by the main program. We show an example of this technique in Section 63.5.2.)\nThe signal handler performs some type of cleanup and then either terminates\n  the process or uses a nonlocal goto (Section 21.2.1) to unwind the stack and\n  return control to a predetermined location in the main program. \n\n\n\n[Executing a nonlocal goto] provides a way to recover after delivery of a signal caused by a hardware exception (e.g., a memory access error), and also allows us to catch a signal and return control to a particular point in a program. For example, upon receipt of a SIGINT signal (normally generated by typing Control-C), the shell performs a nonlocal goto to return control to its main input loop (and thus read a new command).\n\n\n\n\nSupplementary info:\n\n\nA signal is a notification to a process that an event has occurred. Signals are sometimes described as software interrupts. Signals are analogous to hardware interrupts in that they interrupt the normal flow of execution of a program; in most cases, it is not possible to predict exactly when a signal will arrive.\n  One process can (if it has suitable permissions) send a signal to another process.\n  In this use, signals can be employed as a synchronization technique, or even as a\n  primitive form of interprocess communication (IPC). It is also possible for a process to send a signal to itself. However, the usual source of many signals sent to a process is the kernel.\n\n\nReference: The Linux Programming Interface, chapters 20 and 21\n",
            "votes": "2",
            "user": "julian",
            "time": "Jul 4, 2019 at 15:33",
            "is_accepted": false,
            "comments": [
                {
                    "user": "ker2x",
                    "text": "<span class=\"comment-copy\">Thank you &lt;3 I just finished my latest crackme (guild hall adventure) and will implement this trick in chapter 4 ! :)</span>",
                    "time": null
                },
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">@ker2x you’re welcome and I look forward to trying to solve your new crackme programs :)</span>",
                    "time": null
                }
            ]
        }
    ]
}