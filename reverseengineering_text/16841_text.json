{
    "title": "Address to file offset",
    "link": "https://reverseengineering.stackexchange.com/questions/16841/address-to-file-offset",
    "content": "I have read <pre><code>st_value</code></pre> from the ELF symbol table, with the value being 4195622. When converted to hex, the value is 400580. I am aware that the file offset is 580 bytes. \nMy question is how to actually convert the address to file offset concretely. \nThanks\n",
    "votes": "3",
    "answers": 1,
    "views": "10k",
    "tags": [
        "file-format",
        "elf"
    ],
    "user": "Marius.pharoe",
    "time": "Nov 25, 2017 at 23:52",
    "comments": [],
    "answers_data": [
        {
            "content": "Subtract <pre><code>0x400000</code></pre> from <pre><code>st_value</code></pre> since the address is located in the first <pre><code>LOAD</code></pre> segment of the binary.\n\nAccording to the System V ABI (generic), the meaning of the <pre><code>st_value</code></pre> symbol depends on what type of object file the binary is:\n\nSymbol table entries for different object file types have slightly different interpretations\n  for the <pre><code>st_value</code></pre> member.\n\nIn relocatable files, <pre><code>st_value</code></pre> holds alignment constraints for a symbol whose section index is <pre><code>SHN_COMMON</code></pre>.\nIn relocatable files, <pre><code>st_value</code></pre> holds a section offset for a defined symbol. That is, <pre><code>st_value</code></pre> is an offset from the beginning of the section that <pre><code>st_shndx</code></pre> identifies.\nIn executable and shared object files, <pre><code>st_value</code></pre> holds a virtual address. To make these filesâ€™ symbols more useful for the dynamic linker, the section offset (file interpretation) gives way to a virtual address (memory interpretation) for which the section number is irrelevant.\n\n\nAn executable ELF64 object file linked by <pre><code>ld</code></pre> has a canonical base address of <pre><code>0x0000000000400000</code></pre> given by the linker script variable <pre><code>__executable_start</code></pre>. This means that one can subtract the value of the base address from the <pre><code>st_value</code></pre> to find its file offset.\nWe can verify this by looking at a link map of an ELF64 binary. Here a snippet of the output of <pre><code>ld -M /bin/ls</code></pre>:\n<pre><code>Memory Configuration\n\nName             Origin             Length             Attributes\n*default*        0x0000000000000000 0xffffffffffffffff\n\nLinker script and memory map\n\nLOAD /bin/ls\n                0x0000000000400000                PROVIDE (__executable_start, 0x400000)    <--------------\n                0x0000000000400190                . = (0x400000 + SIZEOF_HEADERS)\n\n.interp         0x0000000000400190       0x1c\n *(.interp)\n .interp        0x0000000000400190       0x1c /bin/ls\n\n.note.ABI-tag   0x00000000004001ac       0x20\n .note.ABI-tag  0x00000000004001ac       0x20 /bin/ls\n\n.note.gnu.build-id\n                0x00000000004001cc       0x24\n *(.note.gnu.build-id)\n .note.gnu.build-id\n                0x00000000004001cc       0x24 /bin/ls\n</code></pre>\nThis can be further verified by examining the section-to-segment mapping of the same binary via <pre><code>readelf -l /bin/ls</code></pre>:\n<pre><code>Elf file type is EXEC (Executable file)\nEntry point 0x404890\nThere are 9 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040\n                 0x00000000000001f8 0x00000000000001f8  R E    8\n  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238\n                 0x000000000000001c 0x000000000000001c  R      1\n      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\n  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000  <-------------\n                 0x0000000000019d44 0x0000000000019d44  R E    200000\n  LOAD           0x0000000000019df0 0x0000000000619df0 0x0000000000619df0\n                 0x0000000000000804 0x0000000000001570  RW     200000\n  DYNAMIC        0x0000000000019e08 0x0000000000619e08 0x0000000000619e08\n                 0x00000000000001f0 0x00000000000001f0  RW     8\n  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254\n                 0x0000000000000044 0x0000000000000044  R      4\n  GNU_EH_FRAME   0x000000000001701c 0x000000000041701c 0x000000000041701c\n                 0x000000000000072c 0x000000000000072c  R      4\n  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000\n                 0x0000000000000000 0x0000000000000000  RW     10\n  GNU_RELRO      0x0000000000019df0 0x0000000000619df0 0x0000000000619df0\n                 0x0000000000000210 0x0000000000000210  R      1\n\n Section to Segment mapping:\n  Segment Sections...\n   00     \n   01     .interp \n   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame \n   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss \n   04     .dynamic \n   05     .note.ABI-tag .note.gnu.build-id \n   06     .eh_frame_hdr \n   07     \n   08     .init_array .fini_array .jcr .dynamic .got\n</code></pre>\nThe first <pre><code>LOAD</code></pre> segment has a base address of <pre><code>0x0000000000400000</code></pre>.\nCompare the values in the <pre><code>Off</code></pre> column with those in the <pre><code>Address</code></pre> column:\n<pre><code>$ readelf -SW /bin/ls\nThere are 28 section headers, starting at offset 0x1a700:\n\nSection Headers:\n  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0\n  [ 1] .interp           PROGBITS        0000000000400238 000238 00001c 00   A  0   0  1\n  [ 2] .note.ABI-tag     NOTE            0000000000400254 000254 000020 00   A  0   0  4\n  [ 3] .note.gnu.build-id NOTE            0000000000400274 000274 000024 00   A  0   0  4\n  [ 4] .gnu.hash         GNU_HASH        0000000000400298 000298 000068 00   A  5   0  8\n  [ 5] .dynsym           DYNSYM          0000000000400300 000300 000c18 18   A  6   1  8\n  [ 6] .dynstr           STRTAB          0000000000400f18 000f18 000593 00   A  0   0  1\n  [ 7] .gnu.version      VERSYM          00000000004014ac 0014ac 000102 02   A  5   0  2\n  [ 8] .gnu.version_r    VERNEED         00000000004015b0 0015b0 000090 00   A  6   2  8\n  [ 9] .rela.dyn         RELA            0000000000401640 001640 0000a8 18   A  5   0  8\n  [10] .rela.plt         RELA            00000000004016e8 0016e8 000a80 18   A  5  12  8\n  [11] .init             PROGBITS        0000000000402168 002168 00001a 00  AX  0   0  4\n  [12] .plt              PROGBITS        0000000000402190 002190 000710 10  AX  0   0 16\n  [13] .text             PROGBITS        00000000004028a0 0028a0 00f65a 00  AX  0   0 16\n  [14] .fini             PROGBITS        0000000000411efc 011efc 000009 00  AX  0   0  4\n  [15] .rodata           PROGBITS        0000000000411f20 011f20 0050fc 00   A  0   0 32\n  [16] .eh_frame_hdr     PROGBITS        000000000041701c 01701c 00072c 00   A  0   0  4\n  [17] .eh_frame         PROGBITS        0000000000417748 017748 0025fc 00   A  0   0  8\n  [18] .init_array       INIT_ARRAY      0000000000619df0 019df0 000008 00  WA  0   0  8\n  [19] .fini_array       FINI_ARRAY      0000000000619df8 019df8 000008 00  WA  0   0  8\n  [20] .jcr              PROGBITS        0000000000619e00 019e00 000008 00  WA  0   0  8\n  [21] .dynamic          DYNAMIC         0000000000619e08 019e08 0001f0 10  WA  6   0  8\n  [22] .got              PROGBITS        0000000000619ff8 019ff8 000008 08  WA  0   0  8\n  [23] .got.plt          PROGBITS        000000000061a000 01a000 000398 08  WA  0   0  8\n  [24] .data             PROGBITS        000000000061a3a0 01a3a0 000254 00  WA  0   0 32\n  [25] .bss              NOBITS          000000000061a600 01a5f4 000d60 00  WA  0   0 32\n  [26] .gnu_debuglink    PROGBITS        0000000000000000 01a5f4 000008 00      0   0  1\n  [27] .shstrtab         STRTAB          0000000000000000 01a5fc 0000fe 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n</code></pre>\n",
            "votes": "5",
            "user": "julian",
            "time": "Nov 26, 2017 at 4:39",
            "is_accepted": true,
            "comments": []
        }
    ]
}