{
    "title": "Reverse engineering what seems to be a checksum used for RS232 packets",
    "link": "https://reverseengineering.stackexchange.com/questions/30472/reverse-engineering-what-seems-to-be-a-checksum-used-for-rs232-packets",
    "content": "I will try to be as concise as possible: the issue is, I'm trying to develop a custom application for a dielectric tester. I have access to the original program, which was made some 20 years ago or more; the communication happens via a serial port (RS232).\nI had already developed a simpler program for this very same device 4 years ago, so I already had some experience: my approach was to just sniff packets while using the original application and then try to reverse engineer the communication protocol. I have unfortunately stumbled upon what seems to be some kind of checksum. This machine can receive a test program (that is, a series of steps with some parameters like voltage, duration, etc.), which is sent as a string, something like this:\n<pre><code>.úQ P1_2 P2_0 P3_1 P4_0 P5_0 P7_0 P8_0 P9_0 P10_0 P12_0 P13_0 P17_0 P18_0 P19_0 P20_0 P21_12 P22_0 P26_0 P27_0 P28_0 P30_0 P34_0 P35_0 P37_1 P38_500 P39_1 T_Example*english H9-1_0_10_10_0_20000_10_1_0_0_1000_0_0_0_0_0_0_1_0_0_0_0_0_1_1_0 D1_AAAAAAAA Um1__ H9-2_0_10_10_0_20000_10_1_0_0_1000_0_0_0_0_0_0_1_0_0_0_0_0_1_1_0 D2_BBBBBBBB Um2__ Z6470516010223 b n 4B.\n</code></pre>\nAnd these are the corresponding bytes (hex numbers):\n<pre><code>02 81 fa 51 20 50 31 5f 32 20 50 32 5f 30 20 50 33 5f 31 20 50 34 5f 30 20 50 35 5f 30 20 50 37 5f 30 20 50 38 5f 30 20 50 39 5f 30 20 50 31 30 5f 30 20 50 31 32 5f 30 20 50 31 33 5f 30 20 50 31 37 5f 30 20 50 31 38 5f 30 20 50 31 39 5f 30 20 50 32 30 5f 30 20 50 32 31 5f 31 32 20 50 32 32 5f 30 20 50 32 36 5f 30 20 50 32 37 5f 30 20 50 32 38 5f 30 20 50 33 30 5f 30 20 50 33 34 5f 30 20 50 33 35 5f 30 20 50 33 37 5f 31 20 50 33 38 5f 35 30 30 20 50 33 39 5f 31 20 54 5f 45 78 61 6d 70 6c 65 2a 65 6e 67 6c 69 73 68 20 48 39 2d 31 5f 30 5f 31 30 5f 31 30 5f 30 5f 32 30 30 30 30 5f 31 30 5f 31 5f 30 5f 30 5f 31 30 30 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 31 5f 30 20 44 31 5f 41 41 41 41 41 41 41 41 20 20 55 6d 31 5f 5f 20 48 39 2d 32 5f 30 5f 31 30 5f 31 30 5f 30 5f 32 30 30 30 30 5f 31 30 5f 31 5f 30 5f 30 5f 31 30 30 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 31 5f 30 20 44 32 5f 42 42 42 42 42 42 42 42 20 20 55 6d 32 5f 5f 20 5a 36 34 37 30 35 31 36 30 31 30 32 32 33 20 62 20 6e 20 34 42 03\n</code></pre>\nThe first 3 bytes seem to be fixed at <pre><code>02 81 fa</code></pre> while the last byte is always <pre><code>03</code></pre>, the actual content starts at <pre><code>P1_2 [...]</code></pre> and ends at <pre><code>[...]Um2__ </code></pre>. My problem is with the ending portion of the string (before the <pre><code>03</code></pre> byte): <pre><code>Z6470516010223 b n 4B</code></pre>.\nFrom various captures I was able to deduce that the end portion is always <pre><code>ZXXXXXXXXXXXXX b n XX</code></pre> where the first 13 Xs after the Z are decimal digits and the last 2 Xs are hexadecimal digits.\nI will now list some facts I discovered during my research:\n\nThe machine will not accept the program unless these two numbers are correct.\nSending the exact same string multiple times will always work.\nIf the content of the message changes, using the same two numbers will not work.\nSending a program with the original companion application multiple times will result in messages with different numbers at the end.\nGenerating random numbers and going brute force will sometimes result in the program being accepted (a bit more often than I had initially believed, but still this is not a feasible solution)\n\nThis leads me to believe that these two numbers are connected in some way to the content of message but there is also some other factor, like time, involved.\nI have tried with multiple tools to see if it was some common checksum algorithm like CRC-32, CRC-64, etc. but to no avail (then again, the numbers are not fixed so I kinda expected that).\nI do have access to the original software (which was made with VB6 and unfortunately only decompiles to sweet x86 assembly), as I said, and I am trying to disassemble and reverse engineer the algorithm directly from the source, but it is proving to be a tad harder than I expected so I thought I might try and ask here if anyone might have any clue on this while I bang my head against IDA Pro.\nHere are a couple more data captures that might help:\n<pre><code>.úQ P1_2 P2_0 P3_1 P4_0 P5_0 P7_0 P8_0 P9_0 P10_0 P12_0 P13_0 P17_0 P18_0 P19_0 P20_0 P21_12 P22_0 P26_0 P27_0 P28_0 P30_0 P34_0 P35_0 P37_1 P38_500 P39_1 T_Example*english H9-1_0_10_10_0_20000_10_1_0_0_1000_0_0_0_0_0_0_1_0_0_0_0_0_1_1_0 D1_AAAAAAAAC Um1__ H9-2_0_10_10_0_20000_10_1_0_0_1000_0_0_0_0_0_0_1_0_0_0_0_0_1_1_0 D2_BBBBBBBB Um2__ Z2511316010223 b n 0C.\n\n02 81 fa 51 20 50 31 5f 32 20 50 32 5f 30 20 50 33 5f 31 20 50 34 5f 30 20 50 35 5f 30 20 50 37 5f 30 20 50 38 5f 30 20 50 39 5f 30 20 50 31 30 5f 30 20 50 31 32 5f 30 20 50 31 33 5f 30 20 50 31 37 5f 30 20 50 31 38 5f 30 20 50 31 39 5f 30 20 50 32 30 5f 30 20 50 32 31 5f 31 32 20 50 32 32 5f 30 20 50 32 36 5f 30 20 50 32 37 5f 30 20 50 32 38 5f 30 20 50 33 30 5f 30 20 50 33 34 5f 30 20 50 33 35 5f 30 20 50 33 37 5f 31 20 50 33 38 5f 35 30 30 20 50 33 39 5f 31 20 54 5f 45 78 61 6d 70 6c 65 2a 65 6e 67 6c 69 73 68 20 48 39 2d 31 5f 30 5f 31 30 5f 31 30 5f 30 5f 32 30 30 30 30 5f 31 30 5f 31 5f 30 5f 30 5f 31 30 30 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 31 5f 30 20 44 31 5f 41 41 41 41 41 41 41 41 43 20 20 55 6d 31 5f 5f 20 48 39 2d 32 5f 30 5f 31 30 5f 31 30 5f 30 5f 32 30 30 30 30 5f 31 30 5f 31 5f 30 5f 30 5f 31 30 30 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 31 5f 30 20 44 32 5f 42 42 42 42 42 42 42 42 20 20 55 6d 32 5f 5f 20 5a 32 35 31 31 33 31 36 30 31 30 32 32 33 20 62 20 6e 20 30 43 03\n\n\n.úQ P1_2 P2_0 P3_1 P4_0 P5_0 P7_0 P8_0 P9_0 P10_0 P12_0 P13_0 P17_0 P18_0 P19_0 P20_0 P21_12 P22_0 P26_0 P27_0 P28_0 P30_0 P34_0 P35_0 P37_1 P38_500 P39_1 T_Example*english H9-1_0_10_10_0_20000_10_1_0_0_1000_0_0_0_0_0_0_1_0_0_0_0_0_1_1_0 D1_AAAAAAAA Um1__ H9-2_0_10_10_0_20000_10_1_0_0_1000_0_0_0_0_0_0_1_0_0_0_0_0_1_1_0 D2_BBBBBBBB Um2__ Z8212316010223 b n 41.\n\n02 81 fa 51 20 50 31 5f 32 20 50 32 5f 30 20 50 33 5f 31 20 50 34 5f 30 20 50 35 5f 30 20 50 37 5f 30 20 50 38 5f 30 20 50 39 5f 30 20 50 31 30 5f 30 20 50 31 32 5f 30 20 50 31 33 5f 30 20 50 31 37 5f 30 20 50 31 38 5f 30 20 50 31 39 5f 30 20 50 32 30 5f 30 20 50 32 31 5f 31 32 20 50 32 32 5f 30 20 50 32 36 5f 30 20 50 32 37 5f 30 20 50 32 38 5f 30 20 50 33 30 5f 30 20 50 33 34 5f 30 20 50 33 35 5f 30 20 50 33 37 5f 31 20 50 33 38 5f 35 30 30 20 50 33 39 5f 31 20 54 5f 45 78 61 6d 70 6c 65 2a 65 6e 67 6c 69 73 68 20 48 39 2d 31 5f 30 5f 31 30 5f 31 30 5f 30 5f 32 30 30 30 30 5f 31 30 5f 31 5f 30 5f 30 5f 31 30 30 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 31 5f 30 20 44 31 5f 41 41 41 41 41 41 41 41 20 20 55 6d 31 5f 5f 20 48 39 2d 32 5f 30 5f 31 30 5f 31 30 5f 30 5f 32 30 30 30 30 5f 31 30 5f 31 5f 30 5f 30 5f 31 30 30 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 31 5f 30 20 44 32 5f 42 42 42 42 42 42 42 42 20 20 55 6d 32 5f 5f 20 5a 38 32 31 32 33 31 36 30 31 30 32 32 33 20 62 20 6e 20 34 31 03\n\n\n.Å˙Q P1_2 P2_0 P3_1 P4_0 P5_0 P7_0 P8_0 P9_0 P10_0 P12_0 P13_0 P17_0 P18_0 P19_0 P20_0 P21_12 P22_0 P26_0 P27_0 P28_0 P30_0 P34_0 P35_0 P37_1 P38_500 P39_1 T_Example*english H9-1_0_10_10_0_20000_10_1_0_0_1000_0_0_0_0_0_0_1_0_0_0_0_0_1_1_0 D1_AAAAAAAA Um1__ H9-2_0_10_10_0_20000_10_1_0_0_1000_0_0_0_0_0_0_1_0_0_0_0_0_1_1_0 D2_BBBBBBBB Um2__ Z8372415091224 b n 4C.\n\n02 81 fa 51 20 50 31 5f 32 20 50 32 5f 30 20 50 33 5f 31 20 50 34 5f 30 20 50 35 5f 30 20 50 37 5f 30 20 50 38 5f 30 20 50 39 5f 30 20 50 31 30 5f 30 20 50 31 32 5f 30 20 50 31 33 5f 30 20 50 31 37 5f 30 20 50 31 38 5f 30 20 50 31 39 5f 30 20 50 32 30 5f 30 20 50 32 31 5f 31 32 20 50 32 32 5f 30 20 50 32 36 5f 30 20 50 32 37 5f 30 20 50 32 38 5f 30 20 50 33 30 5f 30 20 50 33 34 5f 30 20 50 33 35 5f 30 20 50 33 37 5f 31 20 50 33 38 5f 35 30 30 20 50 33 39 5f 31 20 54 5f 45 78 61 6d 70 6c 65 2a 65 6e 67 6c 69 73 68 20 48 39 2d 31 5f 30 5f 31 30 5f 31 30 5f 30 5f 32 30 30 30 30 5f 31 30 5f 31 5f 30 5f 30 5f 31 30 30 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 31 5f 30 20 44 31 5f 41 41 41 41 41 41 41 41 20 20 55 6d 31 5f 5f 20 48 39 2d 32 5f 30 5f 31 30 5f 31 30 5f 30 5f 32 30 30 30 30 5f 31 30 5f 31 5f 30 5f 30 5f 31 30 30 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 31 5f 30 20 44 32 5f 42 42 42 42 42 42 42 42 20 20 55 6d 32 5f 5f 20 5a 38 33 37 32 34 31 35 30 39 31 32 32 34 20 62 20 6e 20 34 43 03\n\n\n.úQ P1_2 P2_0 P3_1 P4_0 P5_0 P7_0 P8_0 P9_0 P10_0 P12_0 P13_0 P17_0 P18_0 P19_0 P20_0 P21_12 P22_0 P26_0 P27_0 P28_0 P30_0 P34_0 P35_0 P37_1 P38_500 P39_1 T_Example*english H9-1_0_10_10_0_20000_10_1_0_0_1000_0_0_0_0_0_0_1_0_0_0_0_0_1_1_0 D1_AAAAAAAA Um1__ H9-2_0_10_10_0_20000_10_1_0_0_1000_0_0_0_0_0_0_1_0_0_0_0_0_1_1_0 D2_BBBBBBBB Um2__ Z7534415052223 b n 4F.\n\n02 81 fa 51 20 50 31 5f 32 20 50 32 5f 30 20 50 33 5f 31 20 50 34 5f 30 20 50 35 5f 30 20 50 37 5f 30 20 50 38 5f 30 20 50 39 5f 30 20 50 31 30 5f 30 20 50 31 32 5f 30 20 50 31 33 5f 30 20 50 31 37 5f 30 20 50 31 38 5f 30 20 50 31 39 5f 30 20 50 32 30 5f 30 20 50 32 31 5f 31 32 20 50 32 32 5f 30 20 50 32 36 5f 30 20 50 32 37 5f 30 20 50 32 38 5f 30 20 50 33 30 5f 30 20 50 33 34 5f 30 20 50 33 35 5f 30 20 50 33 37 5f 31 20 50 33 38 5f 35 30 30 20 50 33 39 5f 31 20 54 5f 45 78 61 6d 70 6c 65 2a 65 6e 67 6c 69 73 68 20 48 39 2d 31 5f 30 5f 31 30 5f 31 30 5f 30 5f 32 30 30 30 30 5f 31 30 5f 31 5f 30 5f 30 5f 31 30 30 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 31 5f 30 20 44 31 5f 41 41 41 41 41 41 41 41 20 20 55 6d 31 5f 5f 20 48 39 2d 32 5f 30 5f 31 30 5f 31 30 5f 30 5f 32 30 30 30 30 5f 31 30 5f 31 5f 30 5f 30 5f 31 30 30 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 30 5f 30 5f 30 5f 30 5f 30 5f 31 5f 31 5f 30 20 44 32 5f 42 42 42 42 42 42 42 42 20 20 55 6d 32 5f 5f 20 5a 37 35 33 34 34 31 35 30 35 32 32 32 33 20 62 20 6e 20 34 46 03\n</code></pre>\n",
    "votes": "0",
    "answers": 0,
    "views": "107",
    "tags": [
        "encodings",
        "serial-communication",
        "checksum"
    ],
    "user": "Davide",
    "time": "Jun 4, 2022 at 15:25",
    "comments": [
        {
            "user": "dieter reichl",
            "text": "Hi, when I understood correct, the final 2 digits depend fully on those 10 decimal digits and you need an algorithm to calculate them. Do you can manipulate the 10 digit packet by your own,  by example by counting up single digits, and present the checksum? As checksum of 4 out of 5 examples starts with \"4\", CRC is very unlikely. To show that, I think you can reduce the table on those 10 digits, spacer, checksum. Make it easier to overlook, and the rest of info is redundant. The more data available, the bigger the chance is.\n",
            "time": null
        },
        {
            "user": "Davide",
            "text": "Many thanks for your input. If I understand correctly, you are suggesting that the second number is connected to the first one in some way? I will try to collect a lot more data (unfortunately, I need to be physically connected to the device, which can't be moved, so I will do that in a couple of days). In the meanwhile, I noticed that the first number always ends with \"223\" except in the third case of the last four, where it's \"224\", but I can't see the correlation with the content...\n",
            "time": null
        },
        {
            "user": "Davide",
            "text": "Also, pardon me but I didn't understand this question: \"Do you can manipulate the 10 digit packet by your own, by example by counting up single digits, and present the checksum?\" If you mean whether I have control on that number, the answer is no: it's not part of the actual content of the message and is computed in some way by the application when I send the test program to the device. Of course, in my own application I can manipulate that however I want, if that's what you mean.\n",
            "time": null
        },
        {
            "user": "dieter reichl",
            "text": "When I understood correct, sending \"...Z2511316010223 b n 0C.\" will be accepted, while by example \"...Z2511316010223 b n 0D.\" will be rejected. Is this correct? All your messages have the same content starting with \".úQ\" till \"Um2__ \". Is this content always the same or can this be varied?\n",
            "time": null
        },
        {
            "user": "dieter reichl",
            "text": "Another one to get better understanding and hopefully simplify communication: considering first message will it be correct to identify \".úQ P1_2 ... Um2__ \" as part 1, \"Z7534415052223\" as part 2, \" b n \" as part 3 and \"4F.\" as part 4? Part 1 is the so called \"test program\"? Part 3 is always identical? Part 2 and 4 are generated by the program in a way that is not understood at the moment? Or only part 4? The relevant information is in part1, but when you modify part1, you need to generate valid pair of part 2&4 or is random part2 and a valid part4 also accepted?\n",
            "time": null
        }
    ],
    "answers_data": []
}