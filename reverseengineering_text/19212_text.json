{
    "title": "How to set a Mouse Click BreakPoint in OllyDbg?",
    "link": "https://reverseengineering.stackexchange.com/questions/19212/how-to-set-a-mouse-click-breakpoint-in-ollydbg",
    "content": "In the debugger program OllyDbg, How do I set a breakpoint when the left mouse button is pressed? It doesn't matter what it clicks on, so upon mouse click, the breakpoint stops the debugger.\n",
    "votes": "2",
    "answers": 2,
    "views": "2k",
    "tags": [
        "ollydbg",
        "breakpoint"
    ],
    "user": "Robert Tattorn",
    "time": "Aug 31, 2018 at 14:14",
    "comments": [
        {
            "user": "user202729",
            "text": "See also How can I set a breakpoint for a button click?\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "All messages in a gui application passes through the Application Defined Callback WinProc whose prototype is \n<pre><code>LRESULT CALLBACK WindowProc(\n  _In_ HWND   hwnd,\n  _In_ UINT   uMsg,\n  _In_ WPARAM wParam,\n  _In_ LPARAM lParam\n);\n</code></pre>\nso when you have breakpointed on a wndproc  \n<pre><code>esp    -> return Address\nesp+4  -> hwnd \nesp+8  -> uMsg  \n.....\n</code></pre>\n** MSDN Doc For List of messages**\nto know a windoproc or class proc \nuse alt+w  shortcut in ollydbg (opens a list of windows )\nright click to open the context menu and follow Either Wndproc or ClassProc\nfor the appropriate window of choice \nhit shift+f4 and set a log breakpoint that never pauses  and \nset the function type to be WndProc (Assume Function Of Type DropDown)\nsee screen shot below\n\nand run the app \ngo to log window and observe you will see a lot of logs like this \n<pre><code>00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00010236  hWnd = 00010236, class = CalcFrame, text = Calculator\n            00000210  Msg = WM_PARENTNOTIFY\n            00000204  Event = WM_RBUTTONDOWN, ID = 0\n            00230006  Data = 230006\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00030248  hWnd = 00030248, class = CalcFrame\n            00000021  Msg = WM_MOUSEACTIVATE\n            00010236  hParent = 00010236, class = CalcFrame, text = Calculator\n            02040001  Hittest = HTCLIENT, MouseMsg = WM_RBUTTONDOWN\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00010236  hWnd = 00010236, class = CalcFrame, text = Calculator\n            00000021  Msg = WM_MOUSEACTIVATE\n            00010236  hParent = 00010236, class = CalcFrame, text = Calculator\n            02040001  Hittest = HTCLIENT, MouseMsg = WM_RBUTTONDOWN\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00030248  hWnd = 00030248, class = CalcFrame\n            00000020  Msg = WM_SETCURSOR\n            00030248  hWnd = 00030248, class = CalcFrame\n            02040001  Hittest = HTCLIENT, MouseMsg = WM_RBUTTONDOWN\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00010236  hWnd = 00010236, class = CalcFrame, text = Calculator\n            00000020  Msg = WM_SETCURSOR\n            00030248  hWnd = 00030248, class = CalcFrame\n            02040001  Hittest = HTCLIENT, MouseMsg = WM_RBUTTONDOWN\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00030248  hWnd = 00030248, class = CalcFrame\n            00000204  Msg = WM_RBUTTONDOWN\n            00000002  Keys = MK_RBUTTON\n            00230006  X = 6, Y = 35.\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00030248  hWnd = 00030248, class = CalcFrame\n            00000084  Msg = WM_NCHITTEST\n            00000000  wParam = 0\n            01790207  X = 519., Y = 377.\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00030248  hWnd = 00030248, class = CalcFrame\n            00000020  Msg = WM_SETCURSOR\n            00030248  hWnd = 00030248, class = CalcFrame\n            02050001  Hittest = HTCLIENT, MouseMsg = WM_RBUTTONUP\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00010236  hWnd = 00010236, class = CalcFrame, text = Calculator\n            00000020  Msg = WM_SETCURSOR\n            00030248  hWnd = 00030248, class = CalcFrame\n            02050001  Hittest = HTCLIENT, MouseMsg = WM_RBUTTONUP\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00030248  hWnd = 00030248, class = CalcFrame\n            00000205  Msg = WM_RBUTTONUP\n</code></pre>\nnow refine the breakpoint to suit your condition\n(change from never to on condition\nadd condition  like when uMsg == WM_LBUTTONDOWN  ie\n[esp+8] == 0x20x..20y (see the stack layout mention earlier\n0x200 t0 0x220 are WM_MOUSE EVENT MESSAGES \nhere is screenshot that shows a possible configuration and result below screen shot\n\n<pre><code>00551EDE  INT3: [esp+8] = WM_MOUSEMOVE\n00551EDE  INT3: [esp+8] = WM_NCHITTEST\n00551EDE  INT3: [esp+8] = WM_PARENTNOTIFY\n00551EDE  INT3: [esp+8] = WM_MOUSEACTIVATE\n00551EDE  INT3: [esp+8] = WM_MOUSEACTIVATE\n00551EDE  INT3: [esp+8] = WM_SETCURSOR\n00551EDE  INT3: [esp+8] = WM_SETCURSOR\n00551EDE  INT3: [esp+8] = WM_LBUTTONDOWN\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00030248  hWnd = 00030248, class = CalcFrame\n            00000201  Msg = WM_LBUTTONDOWN\n            00000001  Keys = MK_LBUTTON\n            00350004  X = 4, Y = 53.\n00551EDE  INT3: [esp+8] = WM_NCHITTEST\n00551EDE  INT3: [esp+8] = WM_SETCURSOR\n00551EDE  INT3: [esp+8] = WM_SETCURSOR\n00551EDE  INT3: [esp+8] = WM_LBUTTONUP\n00551EDE  INT3: [esp+8] = WM_NCHITTEST\n00551EDE  INT3: [esp+8] = WM_PARENTNOTIFY\n00551EDE  INT3: [esp+8] = WM_MOUSEACTIVATE\n00551EDE  INT3: [esp+8] = WM_MOUSEACTIVATE\n00551EDE  INT3: [esp+8] = WM_SETCURSOR\n00551EDE  INT3: [esp+8] = WM_SETCURSOR\n00551EDE  INT3: [esp+8] = WM_RBUTTONDOWN\n00551EDE  Call to CALC.WndProc from USER32.77B4C4E4\n            00030248  hWnd = 00030248, class = CalcFrame\n            00000204  Msg = WM_RBUTTONDOWN\n            00000002  Keys = MK_RBUTTON\n            00350004  X = 4, Y = 53.\n00551EDE  INT3: [esp+8] = WM_NCHITTEST\n00551EDE  INT3: [esp+8] = WM_SETCURSOR\n00551EDE  INT3: [esp+8] = WM_SETCURSOR\n00551EDE  INT3: [esp+8] = WM_RBUTTONUP\n</code></pre>\n",
            "votes": "4",
            "user": "blabb",
            "time": "Aug 31, 2018 at 18:29",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "Regardless of operating system, a mouse click represents an event and there is a bunch of event handling plumbing that makes this happen. Some of this can hinge upon certain design choices like how processes are separated in the GUI. \nA common pattern is to register a context relative to which events can be processed through an implemented handler. Traditionally under Windows, this is a \"Window Class\" and practically everything is a window. The definition of that window class includes a function/method that handles the events/messages sent to the target window. To target a specific window with a debugger, you would want to break on a condition where the message/event handling function is called with the event you want (like <pre><code>WM_LBUTTONDOWN</code></pre> on Windows). There are cases where default handling of events can occur as well, a la <pre><code>DefWindowProc()</code></pre>.\nDoing this in a broader context would require hooking that is facilitated by the operating system, perhaps at the kernel level. There may be other options for you available through Hooks.\n",
            "votes": "1",
            "user": "NirIzr",
            "time": "Aug 31, 2018 at 17:53",
            "is_accepted": false,
            "comments": []
        }
    ]
}