{
    "title": "What's this obfuscation technique?",
    "link": "https://reverseengineering.stackexchange.com/questions/20501/whats-this-obfuscation-technique",
    "content": "I'm reverse-engineering a particular dylib on Mac OS X. The dylib is highly obfuscated, but I suspect it's from some well-known technique that I'm not aware of.\nI'd like to describe it in the hope that someone here could identify it:\n\nThere are junk instructions inserted everywhere, and every basic block is split by a lot of unconditional jump (but no opaque predicate is used).\nAt its core, it looks like a obfuscated VM. It behaves like this:\n\nAt entry, it push a starting value on the stack, then <pre><code>call</code></pre> an entry point:\n<pre><code>000000010013E070 68 5C 98 42 11                          push    1142985Ch\n000000010013E075 E8 B5 B4 0E 00                          call    sub_10022952F\n</code></pre>\nThe entry (e.g. <pre><code>sub_10022952F</code></pre>) isn't a usual function. It will save all registers and point <pre><code>rsi</code></pre> to an embedded data location that is determined by the <pre><code>push</code></pre> (i.e. the <pre><code>push 1142985Ch</code></pre> above), then starts reading <pre><code>rsi</code></pre> array and jumping accordingly:\n<pre><code>000000010013EED7 8B 06                                   mov     eax, [rsi]\n000000010013EED9 F5                                      ;; cmc\n000000010013EEDA 45 84 FD                                ;; test    r13b, r15b\n000000010013EEDD 48 81 C6 04 00 00 00                    add     rsi, 4\n000000010013EEE4 66 41 81 FA 1C 3B                       ;; cmp     r10w, 3B1Ch\n000000010013EEEA 33 C3                                   xor     eax, ebx\n000000010013EEEC D1 C0                                   rol     eax, 1\n000000010013EEEE E9 FD 8E 15 00                          jmp     loc_100297DF0\n\n0000000100297DF0 FF C0                                   inc     eax\n0000000100297DF2 0F C8                                   bswap   eax\n0000000100297DF4 F8                                      ;; clc\n0000000100297DF5 E9 F2 D6 E4 FF                          jmp     loc_1000E54EC\n\n00000001000E54EC C1 C0 03                                rol     eax, 3\n00000001000E54EF 0F C8                                   bswap   eax\n00000001000E54F1 53                                      push    rbx\n00000001000E54F2 31 04 24                                xor     [rsp], eax\n00000001000E54F5 0F B7 D8                                ;; movzx   ebx, ax\n00000001000E54F8 0F BA F3 82                             ;; btr     ebx, 82h\n00000001000E54FC 5B                                      pop     rbx\n00000001000E54FD F5                                      ;; cmc\n00000001000E54FE 49 F7 C7 E5 0F 9B 74                    ;; test    r15, 749B0FE5h\n00000001000E5505 F9                                      ;; stc\n00000001000E5506 48 63 C0                                movsxd  rax, eax\n00000001000E5509 48 03 F8                                add     rdi, rax\n00000001000E550C E9 D0 49 08 00                          jmp     loc_100169EE1\n\n0000000100169EE1 FF E7                                   jmp     rdi\n</code></pre>\nI've commented out junk code. The code will fetch value from <pre><code>[rsi]</code></pre> into <pre><code>rax</code></pre>, and do some bit-level-operation with <pre><code>rbx</code></pre>; then advance <pre><code>rdi <- rdi + rax</code></pre>; then jump to <pre><code>rdi</code></pre>.\nThis structure is everywhere in the dylib, and in a chain connected by <pre><code>jmp rdi</code></pre>, the bit-level-operations are also the same. But chains from different entry point may have different bit operation for <pre><code>rax</code></pre> and <pre><code>rbx</code></pre>.\nThe VM doesn't have any central structure (like a dispatcher or something), and the jumps go everywhere, not restricted to some location.\nTo call external function like <pre><code>pthread_mutex_lock</code></pre>, it will go out of the VM loop first; then call the external function; then go to another entry point. There are many entry points (<pre><code>push xxxx / call xxxx</code></pre>) to enter VM loop.\nI believe this is some well-known technique, because when the dylib is modified, it will prompt message:\n\nFile corrupted! This program has been manipulated and maybe it's\n  infected by a Virus or cracked. This file won't work anymore.\n\nIt's not a standard Mac OS X message, and Google search for this exact message gives a lot of result, but none of them explains the technique itself.\nSome additional information:\n\nIt has sections named UPX0/UPX1, but I think they are disguise and the technique has nothing to do with UPX. Because the code only does self-checking, no self-modifying. As a result, it's still obfuscated just as the original file after fully loaded.\nI don't know how the it works exactly by now. But I think it's some sort of a VM, because I've traced the invoke of a function of the dylib, I only find the following normal function calls:\n\n<pre><code>pthread_mutex_lock</code></pre> --> 3 <pre><code>new operator</code></pre> --> <pre><code>pthread_mutex_unlock</code></pre>.\nAnd everything else is done inside by those <pre><code>jump rdi</code></pre> structures mentioned above and switches among many entries points. Therefore the rest of the code logic resides in the VM loop.\n",
    "votes": "4",
    "answers": 2,
    "views": "786",
    "tags": [
        "obfuscation",
        "deobfuscation"
    ],
    "user": "user27283",
    "time": "Jan 29, 2019 at 16:45",
    "comments": [
        {
            "user": "user27283",
            "text": "@perror I'm aware of \"control-flow flattening\", it's the technique for <pre><code>jmp rdi</code></pre>. But the actual difficulty is how the VM codes (pointed by <pre><code>rsi</code></pre>) behaves, and junk code and unconditional jump isn't essential here. I believe this obfuscation is generated by some well-known specific technique as the \"file corrupted\" message suggests. So that I don't have to deobfuscate it again by myself.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "I could be wrong, but it looks like VMProtect v3. For this version, this obfuscator inlines all handlers, so that's normal you don't find any dispatcher.\n",
            "votes": "3",
            "user": "wisk",
            "time": "Jan 29, 2019 at 19:17",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Rolf Rolles",
                    "text": "<span class=\"comment-copy\">+1 -- looks like VMProtect to me also, though I'm not sure about the version.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "Yes, this is VMProtect v3 virtualization based protector, which works by disassembling the x86 byte code of the target executable and compiling it into a proprietary, polymorphic byte code which is executed in a custom interpreter at run-time.\nVMProtect is a stack machine.\nEach handler though consisting of scant few instructions performs several tasks, e.g. popping several values, performing multiple operations, pushing one or more values.\nhere is some analysis of its dispatcher:\n<pre><code>push edi; push all registers\npush ecx\npush edx\npush esi\npush ebp\npush ebx\npush eax\npush edx\npushf\npush 0 ; imagebase fixup\nmov esi, [esp+8+arg_0] ; esi = pointer to VM bytecode\nmov ebp, esp ; ebp = VM's \"stack\" pointer\nsub esp, 0C0h\nmov edi, esp ; edi = \"scratch\" data area\n\nVM__FOLLOW__Update:\nadd esi, [ebp+0]\n\nVM__FOLLOW__Regular:\nmov al, [esi]; read a byte from EIP\nmovzx eax, al\nsub esi, -1; increment EIP\njmp ds:VM__HandlerTable[eax*4] ; execute instruction handler\n</code></pre>\nHere is a disassembly of some instruction handlers:\n<pre><code>#00:x = [EIP-1] & 0x3C; y = popd; [edi+x] = y\n\n.text:00427251 and al, 3Ch; al = instruction number\n.text:00427254 mov edx, [ebp+0] ; grab a dword off the stack\n.text:00427257 add ebp, 4 ; pop the stack\n.text:0042725A mov [edi+eax], edx ; store the dword in the scratch space\n\n#01:x = [EIP-1] & 0x3C; y = [edi+x]; pushd y\n\n.vmp0:0046B0EB and al, 3Ch; al = instruction number\n.vmp0:0046B0EE mov edx, [edi+eax] ; grab a dword out of the scratch space\n.vmp0:0046B0F1 sub ebp, 4 ; subtract 4 from the stack pointer\n.vmp0:0046B0F4 mov [ebp+0], edx ; push the dword onto the stack\n\n#02:x = popw, y = popw, z = x + y, pushw z, pushf\n\n.text:004271FB mov ax, [ebp+0] ; pop a word off the stack\n.text:004271FF sub ebp, 2\n.text:00427202 add [ebp+4], ax ; add it to another word on the stack\n.text:00427206 pushf\n.text:00427207 pop dword ptr [ebp+0] ; push the flags\n\n#03:x = [EIP++]; w = popw; [edi+x] = Byte(w)\n\n.vmp0:0046B02A movzx eax, byte ptr [esi] ; read a byte from EIP\n.vmp0:0046B02D mov dx, [ebp+0] ; pop a word off the stack\n.vmp0:0046B031 inc esi ; EIP++\n.vmp0:0046B032 add ebp, 2; adjust stack pointer\n.vmp0:0046B035 mov [edi+eax], dl ; write a byte into the scratch area\n\n#04:x = popd, y = popw, z = x << y, pushd z, pushf\n\n.vmp0:0046B095 mov eax, [ebp+0]; pop a dword off the stack\n.vmp0:0046B098 mov cl, [ebp+4] ; pop a word off the stack\n.vmp0:0046B09B sub ebp, 2\n.vmp0:0046B09E shr eax, cl ; shr the dword by the word\n.vmp0:0046B0A0 mov [ebp+4], eax; push the result\n.vmp0:0046B0A3 pushf\n.vmp0:0046B0A4 pop dword ptr [ebp+0] ; push the flags\n\n#05:x = popd, pushd ss:[x]\n\n.vmp0:0046B5F7 mov eax, [ebp+0]; pop a dword off the stack\n.vmp0:0046B5FA mov eax, ss:[eax] ; read a dword from ss\n.vmp0:0046B5FD mov [ebp+0], eax; push that dword\n</code></pre>\n",
            "votes": "2",
            "user": "0xC0000022L",
            "time": "Jan 9, 2023 at 8:56",
            "is_accepted": false,
            "comments": []
        }
    ]
}