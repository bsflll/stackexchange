{
    "title": "Running machine code that I need to execute with arguments. How?",
    "link": "https://reverseengineering.stackexchange.com/questions/15936/running-machine-code-that-i-need-to-execute-with-arguments-how",
    "content": "There is a program which I expect to run to generate a seed, but I don't know how to proceed and I am new to reversing. \nI have the machine code of a program which is built for x86 architecture. I know that the expected function of the code is to generate a seed from three 8 byte arguments. However, I have no idea on how to proceed and debug this. The numbers in this case are (as integer, not hex) 1095923727, 3459613537, and 2312051101.\nThe hexdump of the code looks like this:\n<pre><code>5589 e583 ec18 c704 2410 0000 00e8 26ff\nffff 8945 f0c7 45f4 0000 0000 eb62 8345\nf401 8b45 08f7 d0c1 e810 3345 0889 45f8\n8b55 f48b 45f8 01d0 69c0 6745 2301 35ef\ncdab 8989 4508 8b45 0831 450c 8b45 0801\n4510 8b55 f48b 45f8 01d0 69c0 efcd ab89\n3567 4523 0189 4508 8b45 0889 45f8 8b45\n0c89 4508 8b45 1089 450c 8b45 f889 4510\n817d f4ff 0000 0076 958b 550c 8b45 0831\nd033 4510 8945 f88b 45f0 8945 fc8b 55fc\n8b45 0889 028b 45fc 8d50 048b 450c 8902\n8b45 fc8d 5008 8b45 1089 028b 45fc 8d50\n0c8b 45f8 8902 8b45 f0c9 c3         \n</code></pre>\nRunning that through a disassembler (r2 in this case) yields this:\n<pre><code>/ (fcn) fcn.00000000 203\n|   fcn.00000000 (int arg_8h, int arg_ch, int arg_10h);\n|           ; var int local_10h @ rbp-0x10\n|           ; var int local_ch @ rbp-0xc\n|           ; var int local_8h @ rbp-0x8\n|           ; var int local_4h @ rbp-0x4\n|           ; arg int arg_8h @ rbp+0x8\n|           ; arg int arg_ch @ rbp+0xc\n|           ; arg int arg_10h @ rbp+0x10\n|           0x00000000      55             push rbp\n|           0x00000001      89e5           mov ebp, esp\n|           0x00000003      83ec18         sub esp, 0x18\n|           0x00000006      c70424100000.  mov dword [rsp], 0x10       ; [0x10:4]=0x4589ffff\n|           0x0000000d      e826ffffff     call 0xffffffffffffff38\n|           0x00000012      8945f0         mov dword [rbp - local_10h], eax\n|           0x00000015      c745f4000000.  mov dword [rbp - local_ch], 0\n|       ,=< 0x0000001c      eb62           jmp 0x80\n|      .--> 0x0000001e      8345f401       add dword [rbp - local_ch], 1\n|      ||   0x00000022      8b4508         mov eax, dword [rbp + arg_8h] ; [0x8:4]=0x1024\n|      ||   0x00000025      f7d0           not eax\n|      ||   0x00000027      c1e810         shr eax, 0x10\n|      ||   0x0000002a      334508         xor eax, dword [rbp + arg_8h]\n|      ||   0x0000002d      8945f8         mov dword [rbp - local_8h], eax\n|      ||   0x00000030      8b55f4         mov edx, dword [rbp - local_ch]\n|      ||   0x00000033      8b45f8         mov eax, dword [rbp - local_8h]\n|      ||   0x00000036      01d0           add eax, edx\n|      ||   0x00000038      69c067452301   imul eax, eax, 0x1234567\n|      ||   0x0000003e      35efcdab89     xor eax, 0x89abcdef\n|      ||   0x00000043      894508         mov dword [rbp + arg_8h], eax ; [0x8:4]=0x1024\n|      ||   0x00000046      8b4508         mov eax, dword [rbp + arg_8h] ; [0x8:4]=0x1024\n|      ||   0x00000049      31450c         xor dword [rbp + arg_ch], eax\n|      ||   0x0000004c      8b4508         mov eax, dword [rbp + arg_8h] ; [0x8:4]=0x1024\n|      ||   0x0000004f      014510         add dword [rbp + arg_10h], eax\n|      ||   0x00000052      8b55f4         mov edx, dword [rbp - local_ch]\n|      ||   0x00000055      8b45f8         mov eax, dword [rbp - local_8h]\n|      ||   0x00000058      01d0           add eax, edx\n|      ||   0x0000005a      69c0efcdab89   imul eax, eax, 0x89abcdef\n|      ||   0x00000060      3567452301     xor eax, 0x1234567\n|      ||   0x00000065      894508         mov dword [rbp + arg_8h], eax ; [0x8:4]=0x1024\n|      ||   0x00000068      8b4508         mov eax, dword [rbp + arg_8h] ; [0x8:4]=0x1024\n|      ||   0x0000006b      8945f8         mov dword [rbp - local_8h], eax\n|      ||   0x0000006e      8b450c         mov eax, dword [rbp + arg_ch] ; [0xc:4]=0xff26e800\n|      ||   0x00000071      894508         mov dword [rbp + arg_8h], eax ; [0x8:4]=0x1024\n|      ||   0x00000074      8b4510         mov eax, dword [rbp + arg_10h] ; [0x10:4]=0x4589ffff\n|      ||   0x00000077      89450c         mov dword [rbp + arg_ch], eax ; [0xc:4]=0xff26e800\n|      ||   0x0000007a      8b45f8         mov eax, dword [rbp - local_8h]\n|      ||   0x0000007d      894510         mov dword [rbp + arg_10h], eax ; [0x10:4]=0x4589ffff\n|      ||   ; JMP XREF from 0x0000001c (fcn.00000000)\n|      |`-> 0x00000080      817df4ff0000.  cmp dword [rbp - local_ch], 0xff ; [0xff:4]=-1 ; 255\n|      `==< 0x00000087      7695           jbe 0x1e\n|           0x00000089      8b550c         mov edx, dword [rbp + arg_ch] ; [0xc:4]=0xff26e800\n|           0x0000008c      8b4508         mov eax, dword [rbp + arg_8h] ; [0x8:4]=0x1024\n|           0x0000008f      31d0           xor eax, edx\n|           0x00000091      334510         xor eax, dword [rbp + arg_10h]\n|           0x00000094      8945f8         mov dword [rbp - local_8h], eax\n|           0x00000097      8b45f0         mov eax, dword [rbp - local_10h]\n|           0x0000009a      8945fc         mov dword [rbp - local_4h], eax\n|           0x0000009d      8b55fc         mov edx, dword [rbp - local_4h]\n|           0x000000a0      8b4508         mov eax, dword [rbp + arg_8h] ; [0x8:4]=0x1024\n|           0x000000a3      8902           mov dword [rdx], eax\n|           0x000000a5      8b45fc         mov eax, dword [rbp - local_4h]\n|           0x000000a8      8d5004         lea edx, dword [rax + 4]    ; 0x4\n|           0x000000ab      8b450c         mov eax, dword [rbp + arg_ch] ; [0xc:4]=0xff26e800\n|           0x000000ae      8902           mov dword [rdx], eax\n|           0x000000b0      8b45fc         mov eax, dword [rbp - local_4h]\n|           0x000000b3      8d5008         lea edx, dword [rax + 8]    ; 0x8\n|           0x000000b6      8b4510         mov eax, dword [rbp + arg_10h] ; [0x10:4]=0x4589ffff\n|           0x000000b9      8902           mov dword [rdx], eax\n|           0x000000bb      8b45fc         mov eax, dword [rbp - local_4h]\n|           0x000000be      8d500c         lea edx, dword [rax + 0xc]  ; 0xc\n|           0x000000c1      8b45f8         mov eax, dword [rbp - local_8h]\n|           0x000000c4      8902           mov dword [rdx], eax\n|           0x000000c6      8b45f0         mov eax, dword [rbp - local_10h]\n|           0x000000c9      c9             leave\n\\           0x000000ca      c3             ret\n</code></pre>\nHow can I run the code above with the three input arguments and generate output?\n",
    "votes": "2",
    "answers": 2,
    "views": "382",
    "tags": [
        "disassembly",
        "debugging",
        "cryptography"
    ],
    "user": "veor",
    "time": "Jul 28, 2017 at 11:50",
    "comments": [
        {
            "user": "julian",
            "text": "This is disassembly of x86_64 code rather than x86\n",
            "time": null
        },
        {
            "user": "Sigtran",
            "text": "and missing  call 0xffffffffffffff38\n",
            "time": null
        },
        {
            "user": "veor",
            "text": "Sorry for that. The question still remains the same given the machine code.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "This should work, i think i didnt miss anything.\nWould be nice to know at least a few expected inputs and outputs for comparison. \nAlso not sure if the call 0xffffffffffffff38 would do anything to local_10h aside from making a struct of integers..\n<pre><code>#include<stdio.h>\n#include<string.h>\n\nunsigned * func_00000000 (unsigned arg_8h, unsigned arg_ch, unsigned arg_10h) {\n    static unsigned local_10h [4]; //init should be local_10h call 0xffffffffffffff38 ??\n    unsigned local_ch;\n    unsigned local_8h;\n    unsigned local_4h;\n\n\n    for (local_ch = 0; local_ch <= 0xff; ++local_ch) {\n        local_8h = local_4h + (((~arg_8h >> 16 ^ arg_8h) + local_ch) * 0x1234567 ^ 0x89abcdef);\n        arg_ch = ((~arg_8h >> 16 ^ arg_8h) + local_ch) * 0x89abcdef ^ 0x1234567;\n        arg_8h = arg_10h ^ (((~arg_8h >> 16 ^ arg_8h) + local_ch) * 0x1234567 ^ 0x89abcdef);\n        arg_10h = local_8h;\n        local_4h = arg_ch;\n    }\n    local_10h[0] = arg_8h;\n    local_10h[1] = arg_10h;\n    local_10h[2] = local_4h;\n    local_10h[3] = arg_8h ^ arg_10h ^ local_4h;\n    return local_10h;\n}\n\nmain()\n{\n    unsigned * p;\n    int i;\n    p = func_00000000(1095923727, 3459613537, 2312051101);\n\n    for ( i = 0; i < 4; i++ ) {\n        printf( \"%u\n\", p[i]);\n   }\n\n   return 0;\n\n}\n</code></pre>\n",
            "votes": "1",
            "user": "Sigtran",
            "time": "Jul 28, 2017 at 18:07",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "I can see three ways to do that:\n\nUsing IDA's AppCall functionality to call that function from within IDA's console.\n\nSpawning a debugger (x64, olly) and debug any process, find an empty region in memory and change the instruction pointer to point to it. Since parameters to this function are passed on the stack, make sure you override the stack with your desired input value.\n\nIf you're looking for a more automated/generic approach to running that function, run that code from within your own executable, as if it was a C function compiled.\nUsing GCC and Extended ASM you can create a small stub function that will only push variables to the stack and jump to an executable region containing the raw binary defined in an array for example (make sure the region is executable and protections are off). You could also simply embed the copied assembly into your code.\n",
            "votes": "1",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": false,
            "comments": []
        }
    ]
}