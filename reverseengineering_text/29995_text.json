{
    "title": "How to create and change variables at address in IDA Python?",
    "link": "https://reverseengineering.stackexchange.com/questions/29995/how-to-create-and-change-variables-at-address-in-ida-python",
    "content": "I'd like to be able to create and change global variables at addresses with IDA Python: if variable doesn't exist, create it, if it exists, change it, set its name, undefine it.\nFor structs, there's <pre><code>idc.add_struc</code></pre>, <pre><code>idc.add_struc_member</code></pre>, <pre><code>idc.set_member_type</code></pre>, <pre><code>idc.set_member_name</code></pre>, <pre><code>idc.del_struc</code></pre>, <pre><code>idc.del_struc_member</code></pre>.\nThere's <pre><code>idc.set_name</code></pre> to set a name at address and <pre><code>ida_bytes.get_flags</code></pre> function to get flags, but I can't find a respective function such as <pre><code>set_flags</code></pre> or <pre><code>set_type</code></pre> to change global variable type at address. So to set variable type to dword, I'd do something like <pre><code>ida_bytes.set_flags(0x14001D01C, ida_bytes.dword_flag())</code></pre>, and to set it to structure type, I'd like to do something like <pre><code>ida_bytes.set_flags(0x14001D01C, ida_bytes.stru_flag(), ida_struct.get_struc_id(\"MyStructName\"))</code></pre>\nI scrolled through idaapi, ida_bytes, idc, ida_struct and ida_typeinf documentation. I also searched for <pre><code>set_</code></pre>, <pre><code>_flag</code></pre>, <pre><code>_type</code></pre> and other in the search box on the hex-rays documentation website, and also manually with Ctrl+F in the pages for namespaces above, but couldn't find functions to set flags at address.\n",
    "votes": "3",
    "answers": 2,
    "views": "1k",
    "tags": [
        "ida",
        "idapython"
    ],
    "user": "KulaGGin",
    "time": "Mar 23, 2023 at 9:29",
    "comments": [],
    "answers_data": [
        {
            "content": "The methods I was looking for are:\n\n<pre><code>ida_bytes.create_data</code></pre> (and other <pre><code>create_</code></pre> variations, such as\n<pre><code>create_byte</code></pre>) to create and change type of variables.\n<pre><code>ida_bytes.del_items</code></pre> to undefine variables.\n<pre><code>idc.set_name</code></pre> or <pre><code>ida_name.set_name</code></pre> to define, change and undefine names of variables.\n\nTo get the name of the variable at address, use <pre><code>idc.get_name</code></pre>.\nTo get the type of the variable at address, first retreive the flags with <pre><code>ida_bytes.get_flags</code></pre>. Then to get its actual type you can use functions, such as <pre><code>idc.is_byte</code></pre> to determine if it's a byte, or <pre><code>idc.is_struct</code></pre> to determine if it's a struct. Then, if it's a struct, to determine specific type of a struct, use <pre><code>idaapi.get_opinfo(struct_id_buffer, ea, 0, flags)</code></pre> (example).\nFor structs, there's <pre><code>idc.add_struc</code></pre>, <pre><code>idc.add_struc_member</code></pre>, <pre><code>idc.set_member_type</code></pre>, <pre><code>idc.set_member_name</code></pre>, <pre><code>idc.del_struc</code></pre>, <pre><code>idc.del_struc_member</code></pre>.\n",
            "votes": "3",
            "user": "Ray",
            "time": "Mar 23, 2023 at 9:28",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "Disclaimer: I maintain the ida-minsc plugin...\nUsing the minsc plugin at https://github.com/arizvisa/ida-minsc, you can use both the <pre><code>database.get</code></pre> and <pre><code>database.set</code></pre> namespaces to fetch or apply things to an address in the database. Names can be fetched or applied via the <pre><code>database.name</code></pre> function with an address.\nGetting, Setting, Testing\nWithin both of these namespaces from the minsc plugin are namespaces such as <pre><code>database.set.integer</code></pre>, or <pre><code>database.set.float</code></pre> which can be used to set the flags as required for an integer or floating-point value. To undefine the type applied to an address, the <pre><code>database.set.undefine</code></pre> can be used. The following python demonstrates each of these.\n<pre><code>Python>db.disasm()\n'1c020b965: db 1\n1c020b966: db 0\n1c020b967: db 0\n1c020b968: db 10h'\n\nPython>print(_)\n1c020b965: db 1\n1c020b966: db 0\n1c020b967: db 0\n1c020b968: db 10h\n\n# Set the current address to a uint32_t, and return its value.\nPython>db.set.integer.uint32_t()\n0x10000001\n\nPython>db.disasm()\n'1c020b965: dd 10000001h' \n\n# Get a floating-point number from the current address.\nPython>db.get.float()   # or db.get.float.single() if you do not want to use the item size.\n2.5243551976337916e-29\n\n# Undefine 4 bytes at the current address.\nPython>db.set.undefine(idc.here(), 4)\n0x4\n\nPython>db.disasm()\n'1c020b965: db 1\n1c020b966: db 0\n1c020b967: db 0\n1c020b968: db 10h'\n</code></pre>\nIf you are trying to test the information applied to an address, the entirety of the <pre><code>database.type</code></pre> namespace should cover things. If information about the type at the current address is necessary, the <pre><code>database.get.type</code></pre> function can be used to fetch the pythonic-type for an address.\n<pre><code># Return the size of an item.\nPython>db.t.size()\n0x4\n\n# Return whether there is a structure at an address.\nPython>db.t.structure.has()\nTrue\n\n# Get the type of structure if it's there.\nPython>db.t.structure.has() and db.t.structure()\n<class 'structure' name='_GUID' offset=0x2ac34 size=0x10784>\n\n# Get the pythonic type at an address.\nPython>db.name(), db.disasm()\n('_Feature_1559121213__private_reporting', '2ac30: dd ?')\n\nPython>db.get.type()\n(<class 'int'>, 0x4)\n\n# Flags...if really needed.\nPython>db.type.flags()\n0x20005400\n\nPython>db.type.flags(idc.here(), idaapi.FF_DWORD)\n0x20000000\n</code></pre>\nStructures/Unions (and Arrays)\nStructures can be set by name or object to an address using the <pre><code>database.set.structure</code></pre> function. Similarly, arrays of types can be applied using the <pre><code>database.set.array</code></pre> function. These functions can be paired with both the <pre><code>database.get.structure</code></pre> or <pre><code>database.get.array</code></pre> functions to decode values from the database.\nIt is also worth noting that these functions also support the pythonic-types feature from minsc.\n<pre><code>Python>db.disasm()\n'1c020b965: db 1\n1c020b966: db 0\n1c020b967: db 0\n1c020b968: db 10h'\n\n# Apply the \"GUID\" structure to the current address.\nPython>db.set.struct(idc.here(), 'GUID')\n{'Data1': 0x10000001, 'Data2': 0x300, 'Data3': 0x6, 'Data4': array('B', [6, 2, 16, 4, 69, 69, 69, 5])}\n\nPython>db.disasm()\n'1c020b965: _GUID <10000001h, 300h, 6, <6, 2, 10h, 4, 45h, 45h, 45h, 5>>' \n\n# Set the current address to a 32-element array of 2-byte (16-bit) integers.\nPython>db.set.array(idc.here(), (int,2), 0x20)\narray('H', [1, 4096, 768, 6, 518, 1040, 17733, 1349, 1285, 1285, 12341, 20480, 0, 0, 8224, 20536, 1872, 0, 12343, 22320, 1872, 0, 8224, 8, 0, 2048, 26720, 24672, 24672, 0, 28784, 30840])\n\n# Decode the data at the current address using the structure \"GUID\"\nPython>db.get.struc(idc.here(), 'GUID')\n{'Data1': 0x10000001, 'Data2': 0x300, 'Data3': 0x6, 'Data4': array('B', [6, 2, 16, 4, 69, 69, 69, 5])}\n\nPython>db.disasm()\n'1c020b965: db 1, 2 dup(0), 10h, 0, 3, 6, 0, 6, 2, 10h, 4, 3 dup(45h)'\n\n# Decode the data at the current address as a 4-element array of the structure \"GUID\".\nPython>db.get.array(idc.here(), struc.by('GUID'), 4)\n[{'Data1': 0x10000001, 'Data2': 0x300, 'Data3': 0x6, 'Data4': array('B', [6, 2, 16, 4, 69, 69, 69, 5])}, {'Data1': 0x5050505, 'Data2': 0x3035, 'Data3': 0x5000, 'Data4': array('B', [0, 0, 0, 0, 32, 32, 56, 80])}, {'Data1': 0x750, 'Data2': 0x3037, 'Data3': 0x5730, 'Data4': array('B', [80, 7, 0, 0, 32, 32, 8, 0])}, {'Data1': 0x8000000, 'Data2': 0x6860, 'Data3': 0x6060, 'Data4': array('B', [96, 96, 0, 0, 112, 112, 120, 120])}]\n</code></pre>\nStructure/Union members (<pre><code>FF_STRUCT</code></pre>)\nAccessing the members of a structure in minsc is done entirely using a <pre><code>structure_t</code></pre> class. This can be fetched by name using <pre><code>structure.by</code></pre>. Once an instance of a <pre><code>structure_t</code></pre> is fetched, then you can access its members by index or slice. Each member instance is using a <pre><code>member_t</code></pre> class. Adding a member can be done via <pre><code>members_t.add</code></pre>.\nAs specified in another answer (as <pre><code>set_member_name</code></pre> and <pre><code>set_member_type</code></pre>), with minsc you can use the <pre><code>member_t.name</code></pre>, <pre><code>member_t.type</code></pre>, and <pre><code>member_t.typeinfo</code></pre> attributes to change the name or type of a member.\n<pre><code>Python>st=struc.by('GUID')\n\nPython>st.members\n<class 'structure' name='_GUID' size=0x10>\n[0]  0+0x4       unsigned int 'Data1' (<class 'int'>, 4)\n[1]  4+0x2   unsigned __int16 'Data2' (<class 'int'>, 2)\n[2]  6+0x2   unsigned __int16 'Data3' (<class 'int'>, 2)\n[3]  8+0x8 unsigned __int8[8] 'Data4' [(<class 'int'>, 1), 8]\n\nPython>st.members[0].name, st.members[0].typeinfo = 'blah', 'char[4]'\n\nPython>st.members[0]\n<member '_GUID.blah' index=0 offset=0x0 size=+0x4 typeinfo='char[4]'> \n\n# Slices are probably useful if you're trying to copy a range of global\n# variables and types into a structure. This way you can apply your new\n# structure to the global address that you copied things from.\n\nPython>db.disasm()\n'2ac40: dd 100h dup( ?)\n2b040: db 200h dup( ?)\n2b240: db 100h dup( ?)\n2b340: db 10000h dup( ?)\n3b340: db 84h dup( ?)'\n\n# Copy the types from the range of addresses that we just disassembled.\nPython>st=struc.by('GUID')\nPython>st.members[:] = [database.type(ea) for ea in database.address()]\n\nPython>st.members\n<class 'structure' name='_GUID' size=0x10784>\n[0]     0+0x400      int[256] 'field_0'     [(<class 'int'>, 4), 256]\n[1]   400+0x200     char[512] 'field_400'   [(<class 'int'>, 1), 512]\n[2]   600+0x100     char[256] 'field_600'   [(<class 'int'>, 1), 256]\n[3]   700+0x10000 char[65536] 'field_700'   [(<class 'int'>, 1), 65536]\n[4] 10700+0x84      char[132] 'field_10700' [(<class 'int'>, 1), 132]\n\n# Copy the names from each address that we have selected.\nPython>for ea, m in zip(database.address(), st.members):\nPython>    m.name = db.name(ea)\n\nPython>st.members\n<class 'structure' name='_GUID' size=0x10784>\n[0]     0+0x400      int[256] '_gFECLog'       [(<class 'int'>, 4), 256]\n[1]   400+0x200     char[512] '_gFECExp'       [(<class 'int'>, 1), 512]\n[2]   600+0x100     char[256] '_gFECInverse'   [(<class 'int'>, 1), 256]\n[3]   700+0x10000 char[65536] '_gFECMultTable' [(<class 'int'>, 1), 65536]\n[4] 10700+0x84      char[132] '_gFECLog2'      [(<class 'int'>, 1), 132]\n</code></pre>\nTypes (<pre><code>tinfo_t</code></pre>)\nDespite the ability to set structures and other things via flags, it is recommended to use types from the local type library when applying things to an address. This can be done via the <pre><code>database.type</code></pre> function in minsc (which is also aliased as <pre><code>database.t</code></pre>).\n<pre><code>Python>db.disasm()\n'1c020b965: _GUID <10000001h, 300h, 6, <6, 2, 10h, 4, 45h, 45h, 45h, 5>>'\n\n# Grab the type at the current address as a demonstration, and then undefine it.\nPython>db.t(), type(db.t())\n(GUID, <class 'ida_typeinf.tinfo_t'>)\n\nPython>db.set.undefine()\n0x10\n\n# Apply some type to the current address.\nPython>db.t('struct {int a; int b; int c; int d;}')\nGUID\n\nPython>db.disasm()\n'1c020b965: $47D2AD9FB6277417A51DF31EA5A2E03E <10000001h, 60300h, 4100206h, \\\\'\n\n# Fetch the type at the current address.\nPython>db.t()\nstruct {int a;int b;int c;int d;}\n</code></pre>\nThe old structure API is expected to be deprecated at some point in the future in favor of the local type library.\nStrings\nAlthough these were not asked about in the original question, these are related to the flags (<pre><code>FF_STRLIT</code></pre>) for an address.\nStrings can also be applied using <pre><code>database.set.string</code></pre> and fetched via <pre><code>database.get.string</code></pre>.\n<pre><code>Python>db.disasm()\n'278124e0: text \"UTF-16LE\", \\'Archive\\',0'\n\n# This string is already defined, so return it.\nPython>db.get.string()\n'Archive'\n\n# Undefine the string at the current address, it was 0x10 bytes.\nPython>db.set.undefine()\n0x10\n\nPython>db.disasm(count=10)\n'278124e0: db 41h\n278124e1: db 0\n278124e2: db 72h\n278124e3: db 0\n278124e4: db 63h\n278124e5: db 0\n278124e6: db 68h\n278124e7: db 0\n278124e8: db 69h\n278124e9: db 0'\n\n# Re-create the string using a 2-byte character width.\nPython>db.set.string(idc.here(), width=2)\n'Archive\\x00'\n\nPython>db.disasm()\n'278124e0: text \"UTF-16LE\", \\'Archive\\',0'\n</code></pre>\nThese string functions support different encodings using the concept of a \"string type\". A \"string type\" is either an integer describing the character width, or a tuple containing the character width and the number of bytes for the length prefix (if it has one).\n<pre><code>Python>db.disasm()\n'278118c8: db 8Ch\n278118c9: db 9Fh\n278118ca: db 8Dh\n278118cb: db 0F5h'\n\n# Apply a string type using the \"Shift-JIS\" encoding to the current address.\nPython>db.set.string(idc.here(), encoding='shift-jis')\n'検索フォルダには保存できません。\\x00'\n\nPython>db.disasm()\n'278118c8: text \"SHIFT-JIS\", \\'検索フォルダには保存できません。\\',0'\n\n# Undefine the string at the current address. It was 0x21 bytes.\nPython>db.set.unknown()\n0x21\n\n# Decode the string at the current address using a \"Shift-JIS\" encoding.\nPython>db.get.string(idc.here(), encoding='shift-jis')\n'検索フォルダには保存できません。'\n\nPython>db.disasm()\n'278118c8: db 8Ch'\n\n# Disassemble some random address that allows us to use a length.\nPython>db.disasm()\n\"27815328: dw 6\n2781532a: db 'CoCreateInstance',0\"\n\n# Undefine both addresses that are selected, resulting in 0x13 bytes being undefined.\nPython>db.set.undefine()\n0x13\n\n# Apply a string with a 2-byte length prefix and 1-byte character width to the current address.\nPython>db.set.string(idc.here(), strtype=(1, 2))\n'CoCrea'\n\n# 16-bit length at current address is 6.\nPython>db.get.i.uint16_t()\n0x6\n\n# Size of the current item is the sum of 2-bytes for the length\n# and its value of 0x06. This results in an item size of 0x08.\nPython>db.type.size()\n0x8\n\n# Get string at current address.\nPython>db.get.string()\n'CoCrea'\n\n# Ignoring the applied string type, decode the current address as\n# a string with a 1-byte character width, 0-byte length prefix (null-terminated).\nPython>db.get.string(idc.here()+2, strtype=(1,0))\n'CoCreateInstance'\n</code></pre>\n",
            "votes": "1",
            "user": "Ali Rizvi-Santiago",
            "time": "Jul 21, 2024 at 6:48",
            "is_accepted": false,
            "comments": [
                {
                    "user": "KulaGGin",
                    "text": "<span class=\"comment-copy\">Thank you very much for your detailed answer, I'll keep this in mind and try to use your library next time.</span>",
                    "time": null
                }
            ]
        }
    ]
}