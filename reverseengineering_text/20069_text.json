{
    "title": "Nested Structures in IDA",
    "link": "https://reverseengineering.stackexchange.com/questions/20069/nested-structures-in-ida",
    "content": "I'm trying to figure out how to explore structs in IDA, and getting stuck on the basics. I wrote a very basic test app;\n<pre><code>int main() {\n    const int kBits = 1024;\n    const int kExp = 3;\n\n    RSA *rsa = RSA_generate_key(kBits, kExp, 0, 0);\n    RSA_print_fp(stdout, rsa, 0);\n\n    RSA_free(rsa);\n    return 0;\n}\n</code></pre>\nThen I imported the OpenSSL headers, so IDA now understands what <pre><code>RSA*</code></pre> and <pre><code>BIGNUM*</code></pre> are. <pre><code>BIGNUM</code></pre> is actually pointing to <pre><code>bignum_st</code></pre> which is referenced from RSA, which is <pre><code>rsa_st</code></pre>.\nThen, dropped a breakpoint in the pseudocode view;\n\nNow, if I hover over <pre><code>v3</code></pre>, I see it's parsing the struct. So I want to do something like grab the value of <pre><code>rsa->d->dmax</code></pre>, but there doesn't seem to be a way to do this? I can't seem to find a way to access <pre><code>v3</code></pre> by name in IDAPython, nor can I seem to 'walk' the structure to get to the int that lives at <pre><code>dmax</code></pre>. Is there some way to do this?\n",
    "votes": "5",
    "answers": 3,
    "views": "1k",
    "tags": [
        "ida",
        "debugging",
        "idapython",
        "linux",
        "hexrays"
    ],
    "user": "XeroxDucati",
    "time": "Jan 18, 2023 at 8:13",
    "comments": [
        {
            "user": "Biswapriyo",
            "text": "Your code works as usual but it raises exception code in IDA+windbg. Can you share the compiled Windows binary?\n",
            "time": null
        },
        {
            "user": "Pororo",
            "text": "Can I assume what you want to do is to dump the value of <pre><code>v3->d->dmax</code></pre> upon reaching this breakpoint?\n",
            "time": null
        },
        {
            "user": "XeroxDucati",
            "text": "@Pororo yes, exactly!\n",
            "time": null
        },
        {
            "user": "XeroxDucati",
            "text": "@Biswapriyo I can't imagine it would work in windows.. I'm doing this under Linux (CentOS 7 if it matters)\n",
            "time": null
        },
        {
            "user": "Jane",
            "text": "for some reason I thought this was the writing stack exchange, anyway -  +1 good question! will follow this.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "My knowledge of the IDAPython API isn't the most complete, but what I would do is\n\nRead the source (or look in IDA) to find the location (byte offsets) of <pre><code>d</code></pre> in <pre><code>rsa_st</code></pre> and <pre><code>dmax</code></pre> in <pre><code>bignum_st</code></pre>. This is easy since the members of the structures above <pre><code>d</code></pre> and <pre><code>dmax</code></pre> are pointers or int types.\nInspect the disassembly just before the call and determine the location of <pre><code>v3</code></pre> -\nfrom the pseudocode it appears to be stored in the stack. If you are lucky, pressing tab while your cursor is on <pre><code>v3</code></pre> will take you to some mov operation in disassembly.\nWhen the breakpoint is hit, use a combination of <pre><code>idc.get_reg_value</code></pre> and <pre><code>idc.get_bytes</code></pre> commands (see https://www.hex-rays.com/products/ida/support/idadoc/162.shtml), using the result from step 2 as a starting point.\n",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "Jan 18, 2023 at 10:17",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "Here are the steps:\n\nSet breakpoint. Run the local debugger with F9. Open Debugger dropdown menu form menu bar and choose \"Take memory snapshot\". Here is the screenshot:\n\n\n\nDouble click on the variables that you want to know (here the <pre><code>RSA*</code></pre> pointer). IDA will take you to the stack view (aka. IDA View-RIP). Do not move the cursor otherwise you will get different value. Press N to name the variable in that stack view. \"Rename address\" window will pop-up. Here is the screenshot:\n\n\n\nAfter naming the variable in that stack view, press Y to add the data type i.e. structure type. For this case it will be <pre><code>RSA</code></pre>, not the pointer because all stack variables placed linearly. Here is the screenshot:\n\n\nNow you can see all the struct members value.\n",
            "votes": "0",
            "user": "Biswapriyo",
            "time": "Dec 8, 2018 at 5:05",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "\"Setting a breakpoint\" suggests that you are doing dynamic analysis. Assuming that and assuming this happens on a real system, may I suggest an alternative route for Linux, based on my other assumption that you are linking OpenSSL dynamically?\nWhen on Linux (and a number of other unixoid systems) you can guide the dynamic linker/loader to override a function. If you know Windows and DLLs it could probably be compared a little to DLL placement attacks, but it is more flexible and requires less effort.\nNB: Obviously this approach doesn't teach you how about dealing with structs in IDA, but I think it is a very powerful technique to keep in mind. Because it is an alternative approach that doesn't satisfy your constraint of wanting to learn more about dealing with structs in IDA, I am making this a CW.\nThere are some components for this approach:\n\nyou need a \"wrapper\" shared object, let's call it <pre><code>mock_openssl_rsagenkey.so</code></pre>, exporting <pre><code>RSA_generate_key()</code></pre> with a binary compatible signature to that from the original OpenSSL shared object (something like <pre><code>libcrypto.so</code></pre>)\nyou need to tell <pre><code>ld.so</code></pre> via environment variable to preload <pre><code>mock_openssl_rsagenkey.so</code></pre> (see below)\n\n<pre><code>ld.so</code></pre> will take care -- when resolving symbols -- that the preloaded ones take precedence. This is how one of the modes of operation for eFence is implemented (look for <pre><code>LD_PRELOAD</code></pre>, the man page also lists the exported symbols).\nSo now your only remaining task would be to turn up the correct prototype for <pre><code>RSA_generate_key</code></pre> from the <pre><code>libcrypto.so</code></pre> that your binary uses (try <pre><code>ldd ./your_binary</code></pre> to list dependencies) and write the wrapper <pre><code>.so</code></pre>, using <pre><code>dlopen()</code></pre> and <pre><code>dlsym()</code></pre> to locate the original <pre><code>RSA_generate_key</code></pre> symbols from the actual <pre><code>libcrypto.so</code></pre>\n\nFull example\n<pre><code>main.c</code></pre>\nThis is approximately the program you created and are analyzing.\n<pre><code>#include <stdio.h>\n#include <stdlib.h>\n#include <openssl/rsa.h>\n\nint main(int argc, char const ** argv, char const** envp)\n{\n    int const kBits = 1024;\n    int const kExp = 3;\n\n    RSA *rsa = RSA_generate_key(kBits, kExp, 0, 0);\n    RSA_print_fp(stdout, rsa, 0);\n\n    RSA_free(rsa);\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<pre><code>mock_openssl.c</code></pre>\nThis is the wrapper shared object, which we'll load with <pre><code>LD_PRELOAD</code></pre>.\n<pre><code>#include <dlfcn.h>\n#include <openssl/rsa.h>\n\ntypedef RSA* (*RSA_generate_key_t)(int, unsigned long, void (*)(int, int, void *), void *);\nstatic RSA_generate_key_t real_RSA_generate_key = 0;\nstatic void* libcrypto = 0;\n\nstatic void init() __attribute__((constructor));\nstatic void fini() __attribute__((destructor));\n\nvoid init()\n{\n    if (!libcrypto)\n    {\n        libcrypto = dlopen(\"libcrypto.so.3\", RTLD_NOW);\n        if (!libcrypto)\n        {\n            libcrypto = dlopen(\"libcrypto.so\", RTLD_NOW);\n        }\n        fprintf(stderr, \"Loaded libcrypto: %p\n\", libcrypto);\n        if (libcrypto)\n        {\n            real_RSA_generate_key = (RSA_generate_key_t)dlsym(libcrypto, \"RSA_generate_key\");\n        }\n        fprintf(stderr, \"\\tRSA_generate_key == %p\n\", (void*)real_RSA_generate_key);\n    }\n}\n\nvoid fini()\n{\n    if (libcrypto)\n    {\n        dlclose(libcrypto);\n        libcrypto = 0;\n        real_RSA_generate_key = 0;\n    }\n}\n\nRSA* RSA_generate_key(int bits, unsigned long e, void (*callback)(int, int, void *), void *cb_arg)\n{\n    if (!real_RSA_generate_key)\n    {\n        fprintf(stderr, \"FATAL: Have no function pointer for original RSA_generate_key()\n\");\n        return 0;\n    }\n    fprintf(stderr, \"Calling real_RSA_generate_key(%i, %lu, %p, %p)\n\", bits, e, callback, cb_arg);\n    RSA* ret = real_RSA_generate_key(bits, e, callback, cb_arg);\n    /* do something with ret here */\n    if (ret)\n    {\n        fprintf(stderr, \"Returned RSA key: %p ... I can do what I want with it ... MUHAHAHA!\n\", ret);\n    }\n    return ret;\n}\n</code></pre>\nExplanation:\n\n<pre><code>RSA_generate_key_t</code></pre> parrots the prototype of the original function as <pre><code>typedef</code></pre>\n<pre><code>real_RSA_generate_key</code></pre> is going to hold the function pointer retrieved from the real <pre><code>libcrypto.so</code></pre>\n<pre><code>libcrypto</code></pre> is going to hold the handle to the loaded <pre><code>libcrypto.so</code></pre>\n<pre><code>init()</code></pre> -- declared as constructor -- will run when our wrapper <pre><code>.so</code></pre> gets loaded\n\nit attempts to load <pre><code>libcrypto.so.3</code></pre>\nfailing that, attempts to load <pre><code>libcrypto.so</code></pre>\nif successful in either of the preceding steps, it uses <pre><code>dlsym()</code></pre> to fetch the address of the real <pre><code>RSA_generate_key</code></pre> and stores it in <pre><code>real_RSA_generate_key</code></pre>\n... also outputs the steps, something like:\n<pre><code>Loaded libcrypto: 0x7f9ad86e3700\n        RSA_generate_key == 0x7f9ad8478b50\n</code></pre>\n\n\n\n<pre><code>finit()</code></pre> -- declared as destructor -- will run when our wrapper <pre><code>.so</code></pre> gets unloaded\n<pre><code>RSA_generate_key()</code></pre> is our wrapper to the original function and will be called in place of the one from <pre><code>libcrypto.so</code></pre> by a program that preloads this <pre><code>.so</code></pre>\n\n<pre><code>GNUmakefile</code></pre>\nThe GNU <pre><code>make</code></pre> recipes to build our stuff.\n<pre><code>CC:=gcc\nCFLAGS:=$(strip -Wno-deprecated-declarations $(CFLAGS))\nall: bin so\nbin: your_binary\nso: mock_openssl_rsagenkey.so\n\nbin: LDLIBS=-lcrypto\n\nyour_binary: main.c\n        $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@\n\nso: CFLAGS=-shared -fPIC\nso: LDFLAGS=-Wl,-soname,libcrypto.so\nso: LDLIBS=-ldl\n\nmock_openssl_rsagenkey.so: mock_openssl.c\n        $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@\n\n.PHONY: all so bin\n</code></pre>\nSteps\n\nwrite each of the above with the name I gave in the subsection titles into a file\nrun <pre><code>make</code></pre> (on Debian/Ubuntu you may want to install <pre><code>build-essential</code></pre>, for other systems consult your documentation)\ninvoke, e.g. with this <pre><code>env LD_PRELOAD=./mock_openssl_rsagenkey.so ./your_binary</code></pre>\n\nOutput (excerpt)\n<pre><code>$ LD_PRELOAD=./mock_openssl_rsagenkey.so ./your_binary\nLoaded libcrypto: 0x7f9ad86e3700\n        RSA_generate_key == 0x7f9ad8478b50\nCalling real_RSA_generate_key(1024, 3, (nil), (nil))\nReturned RSA key: 0x55d1bfc40c10 ... I can do what I want with it ... MUHAHAHA!\nRSA Private-Key: (1024 bit, 2 primes)\nmodulus:\n    00:d2:85:86:68:fb:1f:b0:92:c7:dd:09:08:7a:39:\n    21:7e:74:27:36:08:23:0d:1f:6c:7a:ec:47:5d:fc:\n    27:c9:95:c2:a4:e1:9f:99:1b:3f:d9:f8:88:65:30:\n    93:c6:7d:2b:31:9b:b1:cb:5c:5a:b8:7a:20:c0:4b:\n    63:25:c4:3a:30:c3:81:16:56:28:ac:f7:74:93:6b:\n    93:64:db:c9:d5:0f:64:f8:15:b4:0d:18:1d:86:c1:\n    60:4b:5a:2f:2f:b7:fb:90:03:13:d5:be:1e:05:05:\n    0e:91:54:79:5b:58:2f:02:de:0a:1f:ef:06:a4:0a:\n    28:e4:55:3f:31:9d:a9:26:53\npublicExponent: 3 (0x3)\nprivateExponent:\n...\n</code></pre>\nExplanation:\n\nLines 1..2 are from <pre><code>init()</code></pre>\nLines 3..4 are from <pre><code>RSA_generate_key()</code></pre> in our wrapper <pre><code>.so</code></pre>\n\nNB: this shows you have full access to all the arguments! While it may be a little more intricate to do, it would also clearly be possible to wrap the callback mechanism provided by OpenSSL into our own, e.g.:\n\nprior to calling <pre><code>real_ RSA_generate_key()</code></pre>, allocate a struct holding original <pre><code>callback</code></pre> pointer and <pre><code>cb_arg</code></pre>\npass our own callback function\n\ninside our callback function unwrap the struct and pass arguments to the original callback if and as needed\n\n\nafter <pre><code>real_ RSA_generate_key()</code></pre> clean up the allocated struct\n\n\n\n\n\nThe above as Base64-encoded <pre><code>.tar.xz</code></pre> file for convenience:\n<pre><code>/Td6WFoAAATm1rRGAgAhARwAAAAQz1jM4Cf/BCJdACOThvK+tJ2QH6+woi2u3zkiEOlUoV1cX9AZ\n+FC3A1WH7iUCMxAdurFVdxDDlniCFn58+KgLrhSGdLxvJiWTMjuOBhIYwKHirauzr5++28b5NTbw\n5OiW8LJArEPs+IWgu/EuT61aIKGLFonGy9apeCHMMEzdN9wUILkS5CNSFe5L1gKJCeVZ2PTWGqzA\nyu0nBvlpA0e7H81rA/msgoO1us3mbbQkkYuZ0lOkt5t5qn8H7c7oZe/gip3oyXmFlfJsscG2OmjK\nKmKWZbFLgb3EQuM0929MRGATHYCl5McORvugai2AeHPJRTLVTKrZC2rYj9buuEY5PH6ufW1b8NT1\nklXJkPU0gfOhGsEVcYQUMmp56aXGqzp6kq6xhAcIH+U+oEbbZBAC9QSSyFMH40nmRrPUOfIHnwhn\no/QclEtbierPsRwJMLjXS5uuz7IP1zxdOtshXJUDfmkXhj7/AIOCoLJ1PTWOIW4wq54yFSokdBUA\nlbzUk/VluIqyIx0D81HMRU2qJuptH2c28ij92+c7nHcH7M+WncwXoUPSZL2M31SUvS7DsFQkgqbM\nbeWSW2XgnV9vSKGomuCUY5vT671UD7hYddEuoR+vtJdEnEXENHfIu6rmK/3Zg9UwzYrHIMvkxm9B\nl1rxP+4C3x3Sy4qBzBup44Q7p62bVMG3CiSD2ZCkktQgeQFyPklGJLw3KriMexMoLc4eSA0EwfhU\nrr33b6n5uW3JN3pJ8IfwRW+KXS+DI0wnroLCGHdwzfXDhFPSMTaeFL4oICzQoX6gyPjLWRPciwZR\ng/2fZp9xA25j/6YP1M8i8eUcckB3Z2ispYtTsDa+D2osEcK4JAtHaDCJ/6gH3wSIJh3Dx5upaHz1\n0wQDQkS4T4O3Igf7B4wigAHWSHIih8Cl9bN8L36S5ZC58o3VeMgsLpLUkcRhf0bl6dhD113rJkqO\nG5GTlyp13YB7U2pynt9EY4TfVqCj7NvEAXHpt67MmNSqwl4c6Eslm/XplS0gTzKbP1tZo70AvkYO\noks0eYGhmE6HmcwwolqNJ3UQWkmPeUrBA5WHILHDvS3fhZkuoRgSJ+swyez8oKtOo5Y6sxGH1yDH\n0Bt5SeDmk6wErTqUb+YTDKQw1wMzY3DdeUSOny6PJumC/D9HBwmIehhDB7YxMVaQ2jcW02//bngq\nJ+zcjmBbjvKhMSOcCBVAPD7EAYyB6uerSAg4DrpsUkyYAw8+49lYe6STGKpy8OOt4OXah6WnG8/E\nGsbYlHm1RfJuMIgfYRU0+O+//xipV/q5EF/FzaQoDYuV2mPsx6TvYAganEUh78E4P9+GXBC8FsPE\nZjUrahpKmyLFm9zVmN0l3BYa20EpXmujuePO/51T3TZlxgcf5fjV87vF7BBmj8vcaVe+U02IcB1M\nZ6OAl1cAAAAAtSETkCuEMZwAAb4IgFAAAJJ1AFKxxGf7AgAAAAAEWVo=\n</code></pre>\n\nTelling <pre><code>ld.so</code></pre> to preload the wrapper <pre><code>.so</code></pre>\nBash and some other shells will be contend to do it with:\n<pre><code>LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so ./your_binary\n</code></pre>\nbut the more portable way is:\n<pre><code>env LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so ./your_binary\n</code></pre>\nwhich uses <pre><code>/usr/bin/env</code></pre> -- instead of relying on a shell-builtin facility 00 to set the environment variable for a single invocation.\nObviously you could also at the prompt (<pre><code>$ </code></pre> signifies it!) to:\n<pre><code>$ export LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so\n$ ./your_binary\n</code></pre>\nor on some less comfortable (or older) shells:\n<pre><code>$ LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so\n$ export LD_PRELOAD\n$ ./your_binary\n</code></pre>\nLast, but not least, you could create a little wrapper script, which we'll name <pre><code>your_binary.sh</code></pre> based on <pre><code>your_binary</code></pre>:\n<pre><code>#!/usr/bin/env bash\nexport LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so\nexec \"${0%.sh}\" \"$@\"\n</code></pre>\n\n<pre><code>#!/usr/bin/env bash</code></pre> is the most portable hashbang, compared to hardcoding the path to a particular <pre><code>bash</code></pre> binary\n<pre><code>export LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so</code></pre> exports <pre><code>LD_PRELOAD</code></pre> as environment variable with the shown value\n<pre><code>exec \"${0%.sh}\" \"$@\"</code></pre>:\n\n<pre><code>\"${0%.sh}\"</code></pre> strips the <pre><code>.sh</code></pre> suffix, yielding the name without it\n<pre><code>\"$@\"</code></pre> expanding to the quoted arguments passed to our script (e.g. <pre><code>\"$1\" \"$2\"</code></pre> ...)\n<pre><code>exec</code></pre> isn't strictly necessary here, but I prefer it for these small wrapper scripts; it replaces the current shell with the given command\n",
            "votes": "0",
            "user": "2 revs0xC0000022L",
            "time": "Jan 18, 2023 at 10:23",
            "is_accepted": false,
            "comments": []
        }
    ]
}