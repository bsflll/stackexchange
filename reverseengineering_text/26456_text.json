{
    "title": "Correct way to understand local_ in ghidra disassembly",
    "link": "https://reverseengineering.stackexchange.com/questions/26456/correct-way-to-understand-local-in-ghidra-disassembly",
    "content": "Attached is the part of a disassembled main from a x86 binary file, generated by ghidra.\n<pre><code>                             **************************************************************\n                             *                          FUNCTION                          *\n                             **************************************************************\n                             undefined main(undefined1 param_1)\n             undefined         AL:1           <RETURN>                                XREF[1]:     0804835e(W)  \n             undefined1        Stack[0x4]:1   param_1                                 XREF[1]:     08048309(*)  \n             undefined4        EAX:4          str_in                                  XREF[1]:     0804835e(W)  \n             undefined4        Stack[0x0]:4   local_res0                              XREF[1]:     08048310(R)  \n             undefined4        Stack[-0x10]:4 local_10                                XREF[6]:     08048358(R), \n                                                                                                   08048363(W), \n                                                                                                   0804836d(R), \n                                                                                                   08048388(R), \n                                                                                                   08048393(W), \n                                                                                                   0804839d(R)  \n             undefined4        Stack[-0x14]:4 local_14                                XREF[2]:     0804831a(W), \n                                                                                                   08048366(R)  \n             undefined4        Stack[-0x18]:4 local_18                                XREF[2]:     08048321(W), \n                                                                                                   08048396(R)  \n             undefined4        Stack[-0x2c]:4 local_2c                                XREF[3]:     08048369(W), \n                                                                                                   08048399(W), \n                                                                                                   080483ac(W)  \n             undefined4        Stack[-0x30]:4 local_30                                XREF[12]:    08048328(*), \n                                                                                                   08048334(*), \n                                                                                                   08048340(*), \n                                                                                                   0804834c(*), \n                                                                                                   0804835b(*), \n                                                                                                   08048370(*), \n                                                                                                   0804837c(*), \n                                                                                                   0804838b(*), \n                                                                                                   080483a0(*), \n                                                                                                   080483b4(*), \n                                                                                                   080483c2(*), \n                                                                                                   080483d0(*)  \n                             main                                            XREF[2]:     Entry Point(*), \n                                                                                          _start:08048167(*)  \n        08048309 8d 4c 24 04     LEA        ECX=>param_1,[ESP + 0x4]\n        0804830d 83 e4 f0        AND        ESP,0xfffffff0\n        08048310 ff 71 fc        PUSH       dword ptr [ECX + local_res0]\n        08048313 55              PUSH       EBP\n        08048314 89 e5           MOV        EBP,ESP\n        08048316 51              PUSH       ECX\n        08048317 83 ec 24        SUB        ESP,0x24\n        0804831a c7 45 f4        MOV        dword ptr [EBP + local_14],DAT_080a6b19          = 6Ah    j\n                 19 6b 0a 08\n        08048321 c7 45 f0        MOV        dword ptr [EBP + local_18],s_the_ripper_080a6b1e = \"the ripper\"\n                 1e 6b 0a 08\n</code></pre>\nSame code from gdb\n<pre><code>   0x08048309 <+0>: lea    ecx,[esp+0x4]\n   0x0804830d <+4>: and    esp,0xfffffff0\n   0x08048310 <+7>: push   DWORD PTR [ecx-0x4]\n   0x08048313 <+10>:    push   ebp\n   0x08048314 <+11>:    mov    ebp,esp\n   0x08048316 <+13>:    push   ecx\n   0x08048317 <+14>:    sub    esp,0x24\n=> 0x0804831a <+17>:    mov    DWORD PTR [ebp-0xc],0x80a6b19\n</code></pre>\nWhy is ghidra changeing <pre><code>[ebp-0xc]</code></pre> to <pre><code>[EBP + local_14]</code></pre>.\nSimilar question I found is Ghidra interpreting stack pointers wrongly but reading the answer, I'm not getting the meaning of <pre><code>[EBP + local_14]</code></pre> Here, is ghidra just renaming <pre><code>-0xc</code></pre> to a easily readable name like <pre><code>local_14</code></pre>? I'm not getting how to make sense of this exactly.\nIn the function header, it is shown that <pre><code>Stack[-0x10]:4 local_10</code></pre>. I assume it means that <pre><code>local_10</code></pre> is 4 byte variable at Stack[-0x10], where Stack is the stack pointer upon entry to function. But why is it added to ebp. What's the meaning of that representation used by ghidra?\n",
    "votes": "4",
    "answers": 1,
    "views": "5k",
    "tags": [
        "disassembly",
        "binary-analysis",
        "x86",
        "gdb",
        "ghidra"
    ],
    "user": "Mah35h",
    "time": "Dec 6, 2020 at 16:52",
    "comments": [
        {
            "user": "rustyMagnet",
            "text": "Before doing anything with Ghidra, I start to help Ghidra by telling it the return types of functions ( <pre><code>int</code></pre>, <pre><code>void</code></pre>, <pre><code>char *</code></pre>, etc ). Then I do the same for the function parameters.  Just this step alone starts to clear up the local variables.  Did you try that ?\n",
            "time": null
        },
        {
            "user": "hairlessbear",
            "text": "One thing you can do that may make this more obvious is to turn off the setting that causes Ghidra to use the <pre><code>local_</code></pre> variables directly in the assembly. You can do this via <pre><code>Edit -> Tool Options -> Listing Fields -> Operands Field -> Markup Stack Variable References</code></pre>. This will change the display to show the normal operands, with an arrow indicating what stack variable is being referenced.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Since local variables are usually placed on the stack in <pre><code>x86</code></pre> and <pre><code>esp</code></pre> register can change during function execution, it is more convenient to save the value of <pre><code>esp</code></pre> register on function entry and access data relatively to that value. <pre><code>ebp</code></pre> register is used for this purpose. So you will often see\n<pre><code>push ebp\nmov ebp, esp\n</code></pre>\nlines at the begining of functions. In the example you have provided it is the case - all local variables are accessed this way, through <pre><code>ebp</code></pre>.\nNow, there are two different naming conventions for local variables:\n\nfirst and more natural one: if <pre><code>[ebp - xxx]</code></pre> is accessed, it will be displayed as <pre><code>[ebp + local_xxx]</code></pre>. Here, <pre><code>local_xxx = -xxx</code></pre>, so for instance, <pre><code>local_18 = -0x18</code></pre>.\nsecond and less intuitive one makes use of the <pre><code>esp</code></pre> value at the beginning of a function. In your example, two dwords are pushed on the stack before <pre><code>mov ebp, esp</code></pre> line. It means, that if some local variable was called <pre><code>local_xxx</code></pre> in the first convention, in the second one it will be named <pre><code>local_xxx+0x8</code></pre>, for instance <pre><code>local_18</code></pre> in the first one will be <pre><code>local_20</code></pre> in the second one, used by Ghidra.\n\nWhy do we add <pre><code>0x8</code></pre> in the second one? Because two dwords (<pre><code>8</code></pre> bytes) were pushed onto the stack before <pre><code>esp</code></pre> value was saved into <pre><code>ebp</code></pre> and in <pre><code>x86</code></pre> architecture stack \"grows downwards\", which means if you push something onto it, this value will be saved there and <pre><code>esp</code></pre> will be decreased accordingly (in this case, twice, by <pre><code>4</code></pre> bytes). So, in your particular example, you have the instruction\n<pre><code>mov    DWORD PTR [ebp-0xc],0x80a6b19\n</code></pre>\nwhich would be displayed as\n<pre><code>mov    DWORD PTR [ebp+local_c],0x80a6b19\n</code></pre>\nin the first convention and\n<pre><code>mov    DWORD PTR [ebp+local_14],0x80a6b19\n</code></pre>\nin the second one, implemented in Ghidra, since <pre><code>0xc + 0x8 = 0x14</code></pre>.\n",
            "votes": "9",
            "user": "bart1e",
            "time": "Dec 8, 2020 at 17:26",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Mah35h",
                    "text": "<span class=\"comment-copy\">Just to confirm. In the second convention, when it shows <code>ebp+local_14</code> , ebp actually mean the value of esp at the beginning of of the function call and not the value of ebp when the instruction is ran?</span>",
                    "time": null
                },
                {
                    "user": "bart1e",
                    "text": "<span class=\"comment-copy\">No, it is current ebp value (which is entry_esp-8).</span>",
                    "time": null
                },
                {
                    "user": "Mah35h",
                    "text": "<span class=\"comment-copy\">then value of local_14 should be -0xC right. Else it'll point to wrong memory location when added with ebp</span>",
                    "time": null
                },
                {
                    "user": "bart1e",
                    "text": "<span class=\"comment-copy\">Exactly. And that's why I called this convention \"less intuitive\".</span>",
                    "time": null
                }
            ]
        }
    ]
}