{
    "title": "Dumpbin: Correlating thunk jumps in .reloc to disassembly",
    "link": "https://reverseengineering.stackexchange.com/questions/11233/dumpbin-correlating-thunk-jumps-in-reloc-to-disassembly",
    "content": "I have an application that I am auditing that runs code from an imported DLL. Said DLL itself has imports. Specifically, during execution there's a point where the following is called (EIP is in said DLL):\n<pre><code>68DC6648:    jmp dword ptr ds:[68DD21C8h]\n68DC664E:    nop\n68DC664f:    nop\n</code></pre>\nI performed \n<pre><code>disasm /all /disasm X:\\path\\to\\dll\\myDll.dll\n</code></pre>\nOn the DLL in an attempt to determine where [68DD21C8] goes to. Mosdef appears as though it is a part of a thunk table for relocations or IAT. My assumption sppears to be correct, as I find [68DD21C8] under the .reloc header under a section called BASE RELOCATIONS:\n<pre><code>BASE RELOCATIONS #4\n...    ...        ...\n6000 RVA,    10C SizeOfBlock\n...    ...        ...\n64A    HIGHLOW    68DD21C8\n</code></pre>\nThe preferred image base is:\n<pre><code>68DC0000 image base (68DC0000 to 68DD7FFFF)\n</code></pre>\nAlso, the DLL entrypoint appears to be 68DC1000. \nMy question is: how do I determine the memory address for [68DD21C8] and its relative code/disassembly?\nI tried baseaddr + RVA + ordinal to get:\n68DC0000 + 6000 + 64A == 68DC664A\nHowever, it falls within range of my disassembled code. In my disassembly from dumpbin, 68DC664A isn't a valid address and would lie between the previously stated thunk!\n<pre><code>68DC6648:    jmp dword ptr ds:[68DD21C8h] ;<--contains 68DC664A!!!\n68DC664E:    nop\n68DC664f:    nop\n</code></pre>\nI double checked I have my maths right and searched around, found this previous answer on stack exchange, but it only verified my math above was correct\n",
    "votes": "0",
    "answers": 1,
    "views": "692",
    "tags": [
        "disassembly",
        "debugging",
        "pe"
    ],
    "user": "grepNstepN",
    "time": "May 23, 2017 at 12:37",
    "comments": [],
    "answers_data": [
        {
            "content": "If you have set a proper _NT_SYMBOL_PATH dumpbin uses the symbols if they exist and provide you a name of the import instead of hex\nthe example below shows alls that have resolved names instead of hex for  windows calc.exe\n<pre><code>C:\\>dumpbin /disasm c:\\WINDOWS\\system32\\calc.exe | grep -i \"jmp.*\\[\"\n  01004A9B: FF 24 85 FA 50 00  jmp         dword ptr [eax*4+10050FAh]\n  01007BC8: FF 25 7C 10 00 01  jmp         dword ptr [__imp__LocalFree@4]\n  0101263C: FF 25 BC 11 00 01  jmp         dword ptr [__imp____CxxFrameHandler]\n  01012670: FF 25 C0 11 00 01  jmp         dword ptr [__imp___CxxThrowException@8]\n  010127A4: FF 25 E4 11 00 01  jmp         dword ptr [__imp___XcptFilter]\n</code></pre>\nin case there are no symbols \n<pre><code>C:\\>dumpbin /disasm c:\\usedll.exe | grep -i \"jmp.*\\[\"\n  0040106E: FF 25 0C 20 40 00  jmp         dword ptr ds:[0040200Ch]\n  00401074: FF 25 00 20 40 00  jmp         dword ptr ds:[00402000h]\n  0040107A: FF 25 04 20 40 00  jmp         dword ptr ds:[00402004h]\n  00401080: FF 25 08 20 40 00  jmp         dword ptr ds:[00402008h]\n  00401086: FF 25 14 20 40 00  jmp         dword ptr ds:[00402014h]\n</code></pre>\nyou can view the raw data at the address (if it is an imported address it would be an unresolved first thunk ) windows loader fills it when it is loading the exe dump bin does not resolve it\n<pre><code>C:\\>dumpbin /RAWDATA:4,6 c:\\usedll.exe | grep 402000\n  00402000: 00002082 00002090 000020A2 00002074 00000000 000020C0\n</code></pre>\nto resolve this manually you should parse the import table \n00002082 will point to an import \n00002090 will point to another import in x.dll etc \n00000000 is a seperator \n20c0 will point to an import in y.dll and so on \nname of x.dll , y.dll z.dll will also be the part of import table \nhere is a complete import table of a non symbol exe \n<pre><code>C:\\>dumpbin /RAWDATA:4 c:\\usedll.exe | grep -A 14 402000\n  00402000: 00002082 00002090 000020A2 00002074  . ... ..ó ..t ..\n  00402010: 00000000 000020C0 00000000 00002058  ....└ ......X ..\n  00402020: 00000000 00000000 000020B2 00002000  ........▓ ... ..\n  00402030: 0000206C 00000000 00000000 000020CE  l ..........╬ ..\n  00402040: 00002014 00000000 00000000 00000000  . ..............\n  00402050: 00000000 00000000 00002082 00002090  ......... ... ..\n  00402060: 000020A2 00002074 00000000 000020C0  ó ..t ......└ ..\n  00402070: 00000000 78450075 72507469 7365636F  ....u.ExitProces\n  00402080: 00A20073 65657246 7262694C 00797261  s.ó.FreeLibrary.\n  00402090: 65470129 6F725074 64644163 73736572  ).GetProcAddress\n  004020A0: 01A90000 64616F4C 7262694C 41797261  ..⌐.LoadLibraryA\n  004020B0: 454B0000 4C454E52 642E3233 00006C6C  ..KERNEL32.dll..\n  004020C0: 654D01BB 67617373 786F4265 53550041  ╗.MessageBoxA.US\n  004020D0: 32335245 6C6C642E 00 00              ER32.dll..\n</code></pre>\nyou can observe 20b2 and 20ce pointing to kernel32.dll and user32.dll respectively\nedit \nthe  address in your query does not point to an import table it is part of reloc or a fixup\nfixups do not jump between modules they fall within the module being examined   \n<pre><code>C:\\>dumpbin /RELOCATIONS c:\\WINDOWS\\system32\\kernel32.dll | head -n 11 | tail -3\n\nBASE RELOCATIONS #4\n    1000 RVA,       70 SizeOfBlock\n     62C  HIGHLOW            7C810B50\n\nC:\\>dumpbin /Rawdata:4 c:\\WINDOWS\\system32\\kernel32.dll | grep -i 7c801620\n  7C801620: 00000000 90909090 68146A90 7C810B50  .........j.hP..|\n\nnotice 7c810b50  if the dll is loaded in preferred imagebase this wont change\n\nif the image base is changed loader will find the dword at imagebase+rva+offset \nsubtract the preferred imagebase and add the new imagebase to that result and\npatch the dword to point to correct location \n\nsuppose the preferrred imagebase of 7c800000 wasn't available and dll was loaded at 7d800000 \nloader will fetch the dword 7c810b50 at 7d80162c subtract 7c800000 from it result = 10b50 \nadd 7d800000 and patch 7c810b50 to 7d810b50 \n</code></pre>\nin the query\nyou say \n<pre><code>68DC6648:    jmp dword ptr ds:[68DD21C8h] ;<--contains 68DC664A!!!\n</code></pre>\nthat means it is jumping to the middle of the opcode \ndisassembling 68dc66fa you get \n<pre><code>xxxxx       68 DC664A90     PUSH    904A66DC\nxxxxx       90              NOP\n</code></pre>\nyou may need something better than dumpbin to deal with obfuscation \nedit\nregarding your comment about import parsing no the offsets have nothing to do with base + rva + xxx\nthey do not point to any remote module no reference to any import module address exist in the importing module\n(just take a step back and think what would happen if the dll in the import\ntable was rebased ?? where the exe is going to look for ?? get the idea??)   \nin the import  table pasted above  2082,2090,20a2,2074 points to 4 imports from first dll\n20c0 points to 1 import from second dll  this is firstthunk that will be replaced by the loader with actual import address\nimport table is denoted in pe header->optinal header->datadir[1]\n<pre><code>0:000> dt ntdll!_IMAGE_NT_HEADERS -y opt.datadi[1]. 4000b0\n   +0x018 OptionalHeader : \n      +0x060 DataDirectory  : [1] \n         +0x000 VirtualAddress : 0x201c\n         +0x004 Size           : 0x3c\n</code></pre>\nsee 201c and size 3c that is 15 dwords see below for splitup\n<pre><code>typedef struct _IMAGE_IMPORT_DESCRIPTOR {\n  union   {\n    DWORD   Characteristics;\n    DWORD   OriginalFirstThunk;   <-----00002058,0000206c,00000000\n  } DUMMYUNIONNAME;\n  DWORD   TimeDateStamp;    <-----------00000000,00000000,00000000\n  DWORD   ForwarderChain;   <-----------00000000,00000000,00000000\n  DWORD   Name;             <-----------000020b2,000020ce,00000000 \n  DWORD   FirstThunk;       <-----------00002000,00002014,00000000\n} IMAGE_IMPORT_DESCRIPTOR;\nthe last is a null entry that means 5 dwords that are 00000000\n</code></pre>\nthe original firstthunk a copy of first thunk stays as it is \nthe orignal first thunk gets modified by loader \nloader loads the specified dll using an internal function of LoadLibrary()--->LdrLoadDll() \nand uses an internal api of GetProcAddress  to fetch the importAddress and patches the OriignalFirstThunk  \nthe module being examined has no inkling about the addresses \nyou cant manually calculate anything about a remote dll import from import table\n",
            "votes": "1",
            "user": "blabb",
            "time": "Nov 3, 2015 at 5:26",
            "is_accepted": true,
            "comments": [
                {
                    "user": "grepNstepN",
                    "text": "<span class=\"comment-copy\">So i ran <code>dumpbin /RAWDATA:4 myDll.dll</code> and checked the dumpbin raw data dump and I think I understand. So each contiguous series of bytes not separated by 0's (e.g. 2082, 2090, 20A2, 2074) represents imports from another DLL, and I would have to note the order of contiguous bytes to tell which specific DLL and import its' referring to? Last, in your example, the <code>2082</code> can be used to calculate the memory address in its DLL in the same manner as above, e.g. <code>dll base addr + RVA + ord (in this case, 2082)</code> ?</span>",
                    "time": null
                },
                {
                    "user": "grepNstepN",
                    "text": "<span class=\"comment-copy\">makes sense. <b>thats</b> why they call it fixing up relocations. thanks blabb, spot on! I tried to RTFM but you made more sense <a href=\"https://msdn.microsoft.com/en-us/library/ms809762.aspx\" rel=\"nofollow noreferrer\">msdn.microsoft.com/en-us/library/ms809762.aspx</a></span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">no import table offsets  cannot be used to parse any address from remote module i added some details about how import parsing is done take a look</span>",
                    "time": null
                },
                {
                    "user": "grepNstepN",
                    "text": "<span class=\"comment-copy\">That helped immensely! I started to manually parse the array of <code>IMAGE_IMPORT_DESCRIPTOR</code> structures my dll had and I made sense of it. Also found out <a href=\"http://win32assembly.programminghorizon.com/pe-tut6.html\" rel=\"nofollow noreferrer\">Iczelion</a> had a tut on that. I'll have a beer for ya at the end of the day mate</span>",
                    "time": null
                }
            ]
        }
    ]
}