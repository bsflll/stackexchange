{
    "title": "Problem with IDA Pro Code",
    "link": "https://reverseengineering.stackexchange.com/questions/9177/problem-with-ida-pro-code",
    "content": "I have decompiled a DLL and IDA Pro came up with the following code:\n<pre><code>signed int __thiscall sub_10029900(void *a1, int a2) \n{    \nint v2; // esi@1\nint v3; // ebx@1\nint v4; // eax@1\nint v5; // edx@3\nint v6; // eax@5\nsigned int v7; // esi@5\nbool v8; // cf@7\nsigned int v9; // eax@8\nint v11; // [sp+10h] [bp-20h]@1\n\nv2 = 0;\nv3 = EnumFirstValidChild(a1, &v11);\n\n..........\n\nreturn v2;\n}\n</code></pre>\nWhere <pre><code>EnumFirstValidChild</code></pre> is defined as:\n<pre><code>int __userpurge EnumFirstValidChild&lt;eax>(int a1&lt;eax>, int a2, int a3);\n</code></pre>\nI modified the code above to call the userpurge function as follows:\n<pre><code>int *v12 = &v11;\n\n__asm \n{ \n  push v12\n  push a1\n  call sub_10029800\n  mov v3, eax\n}\n</code></pre>\nThe problem I am having is that the call to this function is causing a stack a Run-Time Check Failure #2 - Stack around <pre><code>v11</code></pre> variable.\n<pre><code>v11</code></pre> is 4 bytes long and I see that more than 16 bytes are wtitten to that pointer.\nWhat could it be wrong? \nThanks!\nEDIT: \nDisassembled code listing of <pre><code>sub_10029900</code></pre>\n<pre><code>.text:10029900 ; =============== S U B R O U T I N E ===========\n.text:10029900\n.text:10029900 ; Attributes: bp-based frame\n.text:10029900\n.text:10029900 sub_10029900    proc near               ; CODE XREF: sub_1000F400+F1p\n.text:10029900                                         ; sub_10010870+135p ...\n.text:10029900\n.text:10029900 var_20          = dword ptr -20h\n.text:10029900 arg_0           = dword ptr  8\n.text:10029900\n.text:10029900                 mov     edi, edi\n.text:10029902                 push    ebp\n.text:10029903                 mov     ebp, esp\n.text:10029905                 and     esp, 0FFFFFFF8h\n.text:10029908                 sub     esp, 24h\n.text:1002990B                 lea     eax, [esp+24h+var_20]\n.text:1002990F                 push    ebx\n.text:10029910                 push    esi\n.text:10029911                 push    edi\n.text:10029912                 push    eax\n.text:10029913                 push    ecx\n.text:10029914                 xor     esi, esi\n.text:10029916                 call    ds:EnumFirstValidChild\n.text:1002991C                 mov     ebx, eax\n.text:1002991E                 lea     eax, [esi+1]\n.text:10029921                 test    ebx, ebx\n.text:10029923                 jz      short loc_10029985\n.text:10029925                 mov     edi, [ebp+arg_0]\n.text:10029928\n.text:10029928 loc_10029928:                           ; CODE XREF: sub_10029900+6Aj\n.text:10029928                 test    eax, eax\n.text:1002992A                 jz      short loc_10029983\n.text:1002992C                 mov     edx, [esp+30h+var_20]\n.text:10029930                 test    edx, edx\n.text:10029932                 jz      short loc_1002995E\n.text:10029934                 test    edi, edi\n.text:10029936                 jz      short loc_1002995E\n.text:10029938                 mov     eax, edi\n.text:1002993A                 mov     esi, 0Ch\n.text:1002993F                 nop\n.text:10029940\n.text:10029940 loc_10029940:                           ; CODE XREF: sub_10029900+4Fj\n.text:10029940                 mov     ecx, [edx]\n.text:10029942                 cmp     ecx, [eax]\n.text:10029944                 jnz     short loc_10029958\n.text:10029946                 add     edx, 4\n.text:10029949                 add     eax, 4\n.text:1002994C                 sub     esi, 4\n.text:1002994F                 jnb     short loc_10029940\n.text:10029951                 mov     eax, 1\n.text:10029956                 jmp     short loc_1002995A\n.text:10029958 ; ---------------------------------------------------------------------------\n.text:10029958\n.text:10029958 loc_10029958:                           ; CODE XREF: sub_10029900+44j\n.text:10029958                 xor     eax, eax\n.text:1002995A\n.text:1002995A loc_1002995A:                           ; CODE XREF: sub_10029900+56j\n.text:1002995A                 test    eax, eax\n.text:1002995C                 jnz     short loc_1002996C\n.text:1002995E\n.text:1002995E loc_1002995E:                           ; CODE XREF: sub_10029900+32j\n.text:1002995E                                         ; sub_10029900+36j\n.text:1002995E                 lea     eax, [esp+30h+var_20]\n.text:10029962                 push    eax\n.text:10029963                 push    ebx\n.text:10029964                 call    ds:EnumNextValidChild\n.text:1002996A                 jmp     short loc_10029928\n.text:1002996C ; ---------------------------------------------------------------------------\n.text:1002996C\n.text:1002996C loc_1002996C:                           ; CODE XREF: sub_10029900+5Cj\n.text:1002996C                 push    ebx\n.text:1002996D                 mov     esi, 1\n.text:10029972                 call    ds:EndEnumValidChild\n.text:10029978                 mov     eax, esi\n.text:1002997A                 pop     edi\n.text:1002997B                 pop     esi\n.text:1002997C                 pop     ebx\n.text:1002997D                 mov     esp, ebp\n.text:1002997F                 pop     ebp\n.text:10029980                 retn    4\n.text:10029983 ; ---------------------------------------------------------------------------\n</code></pre>\nDisassembled code listing of <pre><code>EnumFirstValidChild</code></pre>.\n<pre><code>.text:1000B710 ; Exported entry   4. EnumFirstValidChild\n.text:1000B710\n.text:1000B710 ; =============== S U B R O U T I N E ==============\n.text:1000B710\n.text:1000B710 ; Attributes: bp-based frame\n.text:1000B710\n.text:1000B710                 public EnumFirstValidChild\n.text:1000B710 EnumFirstValidChild proc near ; DATA XREF: .text:off_10027368o\n.text:1000B710\n.text:1000B710 var_28          = dword ptr -28h\n.text:1000B710 var_24          = dword ptr -24h\n.text:1000B710 var_20          = dword ptr -20h\n.text:1000B710 var_1C          = dword ptr -1Ch\n.text:1000B710 var_18          = byte ptr -18h\n.text:1000B710 var_C           = dword ptr -0Ch\n.text:1000B710 var_4           = dword ptr -4\n.text:1000B710 arg_0           = dword ptr  8\n.text:1000B710 arg_4           = dword ptr  0Ch\n.text:1000B710\n.text:1000B710                 mov     edi, edi\n.text:1000B712                 push    ebp\n.text:1000B713                 mov     ebp, esp\n.text:1000B715                 and     esp, 0FFFFFFF8h\n.text:1000B718                 mov     eax, large fs:0\n.text:1000B71E                 push    0FFFFFFFFh\n.text:1000B720                 push    offset SEH_1001DAD0\n.text:1000B725                 push    eax\n.text:1000B726                 mov     large fs:0, esp\n.text:1000B72D                 sub     esp, 20h\n.text:1000B730                 mov     ecx, dword_1002ACE8\n.text:1000B736                 push    ebx\n.text:1000B737                 push    esi\n.text:1000B738                 push    edi\n.text:1000B739                 xor     edi, edi\n.text:1000B73B                 test    ecx, ecx\n.text:1000B73D                 jnz     short loc_1000B77D\n.text:1000B73F                 push    dword_1002ACE4\n.text:1000B745                 lea     eax, [esp+3Ch+var_28]\n.text:1000B749                 push    eax\n.text:1000B74A                 push    7Ch\n.text:1000B74C                 push    1\n.text:1000B74E                 call    ds:api_func_107\n.text:1000B754                 mov     ecx, [esp+38h+var_28]\n.text:1000B758                 mov     [esp+38h+var_24], ecx\n.text:1000B75C                 mov     [esp+38h+var_4], edi\n.text:1000B760                 test    ecx, ecx\n.text:1000B762                 jz      short loc_1000B76D\n.text:1000B764                 call    sub_10005440\n.text:1000B769                 mov     ecx, eax\n.text:1000B76B                 jmp     short loc_1000B76F\n.text:1000B76D ; ---------------------------------------------------------------------------\n.text:1000B76D\n.text:1000B76D loc_1000B76D:                           ; CODE XREF: EnumFirstValidChild+52j\n.text:1000B76D                 xor     ecx, ecx\n.text:1000B76F\n.text:1000B76F loc_1000B76F:                           ; CODE XREF: EnumFirstValidChild+5Bj\n.text:1000B76F                 mov     [esp+38h+var_4], 0FFFFFFFFh\n.text:1000B777                 mov     dword_1002ACE8, ecx\n.text:1000B77D\n.text:1000B77D loc_1000B77D:                           ; CODE XREF: EnumFirstValidChild+2Dj\n.text:1000B77D                 mov     eax, [ebp+arg_0]\n.text:1000B780                 lea     esi, [ecx+34h]\n.text:1000B783                 mov     [esp+38h+var_24], eax\n.text:1000B787                 mov     ecx, esi\n.text:1000B789                 lea     eax, [esp+38h+var_24]\n.text:1000B78D                 push    eax\n.text:1000B78E                 lea     eax, [esp+3Ch+var_18]\n.text:1000B792                 push    eax\n.text:1000B793                 call    sub_10008330\n.text:1000B798                 mov     ecx, [eax]\n.text:1000B79A                 mov     ebx, [eax+4]\n.text:1000B79D                 mov     eax, [esi+4]\n.text:1000B7A0                 mov     [esp+38h+var_20], ecx\n.text:1000B7A4                 mov     [esp+38h+var_1C], ebx\n.text:1000B7A8                 mov     [esp+38h+var_24], eax\n.text:1000B7AC                 test    ecx, ecx\n.text:1000B7AE                 jz      short loc_1000B7B4\n.text:1000B7B0                 cmp     ecx, esi\n.text:1000B7B2                 jz      short loc_1000B7BE\n.text:1000B7B4\n.text:1000B7B4 loc_1000B7B4:                           ; CODE XREF: EnumFirstValidChild+9Ej\n.text:1000B7B4                 call    ds:_invalid_parameter_noinfo\n.text:1000B7BA                 mov     eax, [esp+38h+var_24]\n.text:1000B7BE\n.text:1000B7BE loc_1000B7BE:                           ; CODE XREF: EnumFirstValidChild+A2j\n.text:1000B7BE                 mov     esi, [ebp+arg_4]\n.text:1000B7C1                 cmp     ebx, eax\n.text:1000B7C3                 jz      short loc_1000B80B\n.text:1000B7C5                 lea     ecx, [esp+38h+var_20]\n.text:1000B7C9                 call    sub_10008390\n.text:1000B7CE                 mov     ebx, [eax+4]\n.text:1000B7D1                 test    ebx, ebx\n.text:1000B7D3                 jz      short loc_1000B80B\n.text:1000B7D5                 push    esi\n.text:1000B7D6                 push    0\n.text:1000B7D8                 mov     ecx, ebx\n.text:1000B7DA                 call    sub_1001D620\n.text:1000B7DF                 test    eax, eax\n.text:1000B7E1                 jz      short loc_1000B80B\n.text:1000B7E3                 push    dword_1002ACE4\n.text:1000B7E9                 lea     eax, [esp+3Ch+var_24]\n.text:1000B7ED                 push    eax\n.text:1000B7EE                 push    8\n.text:1000B7F0                 push    1\n.text:1000B7F2                 call    ds:api_func_107\n.text:1000B7F8                 mov     edi, [esp+38h+var_24]\n.text:1000B7FC                 test    edi, edi\n.text:1000B7FE                 jz      short loc_1000B80B\n.text:1000B800                 mov     [edi], ebx\n.text:1000B802                 mov     dword ptr [edi+4], 0\n.text:1000B809                 jmp     short loc_1000B824\n.text:1000B80B ; ---------------------------------------------------------------------------\n.text:1000B80B\n.text:1000B80B loc_1000B80B:                           ; CODE XREF: EnumFirstValidChild+B3j\n.text:1000B80B                                         ; EnumFirstValidChild+C3j ...\n.text:1000B80B                 xor     eax, eax\n.text:1000B80D                 mov     [esi], eax\n.text:1000B80F                 mov     [esi+4], eax\n.text:1000B812                 mov     [esi+8], eax\n.text:1000B815                 mov     [esi+0Ch], eax\n.text:1000B818                 mov     [esi+10h], eax\n.text:1000B81B                 mov     [esi+14h], eax\n.text:1000B81E                 mov     [esi+18h], eax\n.text:1000B821                 mov     [esi+1Ch], eax\n.text:1000B824\n.text:1000B824 loc_1000B824:                           ; CODE XREF: EnumFirstValidChild+F9j\n.text:1000B824                 mov     ecx, [esp+38h+var_C]\n.text:1000B828                 mov     eax, edi\n.text:1000B82A                 pop     edi\n.text:1000B82B                 pop     esi\n.text:1000B82C                 mov     large fs:0, ecx\n.text:1000B833                 pop     ebx\n.text:1000B834                 mov     esp, ebp\n.text:1000B836                 pop     ebp\n.text:1000B837                 retn    8\n.text:1000B837 EnumFirstValidChild endp\n.text:1000B837\n.text:1000B837 ; ---------------------------------------------------------------------------\n</code></pre>\nDecompiled code of <pre><code>sub_10029900</code></pre>.\n<pre><code>signed int __thiscall sub_10029900(void *this, int a2) //note that I changed *this to *a1\n{\n  int v2; // esi@1\n  int v3; // ebx@1\n  int v4; // eax@1\n  int v5; // edx@3\n  int v6; // eax@5\n  signed int v7; // esi@5\n  bool v8; // cf@7\n  signed int v9; // eax@8\n  int v11; // [sp+10h] [bp-20h]@1\n\n  v2 = 0;\n  v3 = EnumFirstValidChild(this, &v11);\n  v4 = 1;\n  if ( v3 )\n  {\n    while ( v4 )\n    {\n     v5 = v11;\n      if ( v11 && a2 )\n      {\n        v6 = a2;\n        v7 = 12;\n        while ( *(_DWORD *)v5 == *(_DWORD *)v6 )\n        {\n          v5 += 4;\n          v6 += 4;\n          v8 = (unsigned int)v7 < 4;\n          v7 -= 4;\n          if ( v8 )\n          {\n            v9 = 1;\n            goto LABEL_10;\n          }\n        }\n        v9 = 0;\nLABEL_10:\n        if ( v9 )\n        {\n          EndEnumValidChild(v3);\n          return 1;\n       }\n      }\n      v4 = EnumNextValidChild(v3, &v11);\n    }\n    v2 = 0;\n  }\n  EndEnumValidChild(v3);\n  return v2;\n}\n</code></pre>\nDecompiled code of <pre><code>EnumFirstValidChild</code></pre>.\n<pre><code>int __userpurge EnumFirstValidChild<eax>(int a1<eax>, int a2, int a3)\n{\n  int v3; // ecx@1\n  int v4; // edi@1\n  int v5; // esi@6\n  int v6; // eax@6\n  int v7; // ecx@6\n  int v8; // ebx@6\n  int v9; // eax@6\n  int v10; // ebx@10\n  int v12; // [sp+1Ch] [bp-28h]@2\n  int v13; // [sp+20h] [bp-24h]@2\n  int v14; // [sp+24h] [bp-20h]@6\n  int v15; // [sp+28h] [bp-1Ch]@6\n  char v16; // [sp+2Ch] [bp-18h]@6\n  int v17; // [sp+38h] [bp-Ch]@1\n  int (__cdecl *v18)(); // [sp+3Ch] [bp-8h]@1\n  int v19; // [sp+40h] [bp-4h]@1\n\n  v19 = -1;\n  v18 = SEH_1001DAD0;\n  v17 = a1;\n  v3 = dword_1002ACE8;\n  v4 = 0;\n  if ( !dword_1002ACE8 )\n  {\n    api_func_107(1, 124, &v12, dword_1002ACE4);\n    v13 = v12;\n    v19 = 0;\n    if ( v12 )\n      v3 = sub_10005440(v12);\n    else\n      v3 = 0;\n    v19 = -1;\n    dword_1002ACE8 = v3;\n  }\n  v5 = v3 + 52;\n  v13 = a2;\n  v6 = sub_10008330(v3 + 52, (int)&v16, (int)&v13);\n  v7 = *(_DWORD *)v6;\n  v8 = *(_DWORD *)(v6 + 4);\n  v9 = *(_DWORD *)(v5 + 4);\n  v14 = v7;\n  v15 = v8;\n  v13 = v9;\n  if ( !v7 || v7 != v5 )\n  {\n    invalid_parameter_noinfo(v7);\n    v9 = v13;\n  }\n  if ( v8 != v9\n    && (v10 = *(_DWORD *)(sub_10008390(&v14) + 4)) != 0\n    && sub_1001D620(v10, 0, a3)\n    && (api_func_107(1, 8, &v13, dword_1002ACE4), (v4 = v13) != 0) )\n  {\n    *(_DWORD *)v13 = v10;\n    *(_DWORD *)(v4 + 4) = 0;\n  }\n  else\n  {\n    *(_DWORD *)a3 = 0;\n    *(_DWORD *)(a3 + 4) = 0;\n    *(_DWORD *)(a3 + 8) = 0;\n    *(_DWORD *)(a3 + 12) = 0;\n    *(_DWORD *)(a3 + 16) = 0;\n    *(_DWORD *)(a3 + 20) = 0;\n    *(_DWORD *)(a3 + 24) = 0;\n    *(_DWORD *)(a3 + 28) = 0;\n  }\n  return v4;\n}\n</code></pre>\n",
    "votes": "2",
    "answers": 1,
    "views": "2k",
    "tags": [
        "ida"
    ],
    "user": "fred26",
    "time": "Jun 20, 2015 at 5:06",
    "comments": [
        {
            "user": "Spl3en",
            "text": "In your code, sub_10029800 takes 2 arguments but in your prototypes it takes 3. I'm not sure, but I guess that sub_10029800 is following the __thiscall calling convention, and the decompiler misinterprets its prototype.\n",
            "time": null
        },
        {
            "user": "Spl3en",
            "text": "Could you give us the disassembly code for 10029900 and 10029800 so we can figure out what's going on precisely ?\n",
            "time": null
        },
        {
            "user": "fred26",
            "text": "Spl3en thanks, I modified above 10029800 to EnumFirstValidChild, and copy pasted both functions\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Let's start from the beginning:\n<pre><code>int __userpurge EnumFirstValidChild<eax>(int a1<eax>, int a2, int a3);\n</code></pre>\nYour <pre><code>EnumFirstValidChild</code></pre> prototype takes <pre><code>eax</code></pre> as the first argument, but if you look at <pre><code>eax</code></pre> in this function, it gets immediately erased by <pre><code>Teb->NtTib->ExceptionList</code></pre> (aka <pre><code>fs:[0]</code></pre>) at <pre><code>.text:1000B718</code></pre>.\nThus, the first argument isn't valid. Let's fix that as a first step:\n<pre><code>int __cdecl EnumFirstValidChild (int a1, int a2);\n</code></pre>\nI think you have already found that out, but better make sure everything is clear.\nNow, more precisely about your question:\n\nv11 is 4 bytes long and I see that more than 16 bytes are written to that pointer.\nWhat could it be wrong?\n\nAs you may know, Hex-Rays doesn't produce compilable C code, but pseudo C-like code.\nYou have to give hints to the decompiler if you want it to decompile a correct C code.\nAbout your issue, you were right. v11 is not 4 bytes long, but actually at least 32 bytes long: at the end of the function <pre><code>EnumFirstValidChild</code></pre>, it writes 32 bytes at the address of the second argument:\n<pre><code>*(_DWORD *)a3 = 0;\n*(_DWORD *)(a3 + 4) = 0;\n*(_DWORD *)(a3 + 8) = 0;\n*(_DWORD *)(a3 + 12) = 0;\n*(_DWORD *)(a3 + 16) = 0;\n*(_DWORD )(a3 + 20) = 0;\n*(_DWORD *)(a3 + 24) = 0;\n*(_DWORD *)(a3 + 28) = 0;\n</code></pre>\nFurthermore, the decompiler gives you a quick way to notice this:\nIn <pre><code>sub_10029900</code></pre>, there's nothing on the stack except:\n<pre><code>int v11; // [bp-20h]\n</code></pre>\nAs you can see, there's some space between bp and bp-20h. There is just enough space for your 32 bytes array, so we can conclude that your structure size is indeed 32 bytes long.\nIf you wish, you can fix the output of Hex-Rays following this procedure:\n",
            "votes": "3",
            "user": "Peter Mortensen",
            "time": "Apr 24, 2023 at 18:08",
            "is_accepted": true,
            "comments": []
        }
    ]
}