{
    "title": "ELF - The start address of .got section is different from the entry point address of the GOT(global offset table)",
    "link": "https://reverseengineering.stackexchange.com/questions/19392/elf-the-start-address-of-got-section-is-different-from-the-entry-point-addres",
    "content": "I used <pre><code>readelf</code></pre> to read the information of the ELF file. I found the address of <pre><code>.got</code></pre> section in the section header is different from the GOT entry point address read from the dynamic section. Is the data which stored between <pre><code>.got</code></pre> address and the entry point of GOT like garbage? The follow is apart of information got from <pre><code>readelf</code></pre>.\n\nELF Header - This ELF is run on ARMv7A.\n<pre><code>ELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           ARM\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          38412 (bytes into file)\n  Flags:                             0x5000200, Version5 EABI, soft-float ABI\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         8\n  Size of section headers:           40 (bytes)\n  Number of section headers:         26\n  Section header string table index: 25\n</code></pre>\n\nSection Headers - The address of <pre><code>.got</code></pre> section is at <pre><code>0x00008eac</code></pre>\n<pre><code>Section Headers:\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\n  [ 1] .note.gnu.build-i NOTE            00000134 000134 000024 00   A  0   0  4\n  [ 2] .dynsym           DYNSYM          00000158 000158 0006a0 10   A  3   1  4\n  [ 3] .dynstr           STRTAB          000007f8 0007f8 000704 00   A  0   0  1\n  [ 4] .hash             HASH            00000efc 000efc 000334 04   A  2   0  4\n  [ 5] .gnu.version      VERSYM          00001230 001230 0000d4 02   A  2   0  2\n  [ 6] .gnu.version_d    VERDEF          00001304 001304 00001c 00   A  3   1  4\n  [ 7] .gnu.version_r    VERNEED         00001320 001320 000020 00   A  3   1  4\n  [ 8] .rel.dyn          REL             00001340 001340 000178 08   A  2   0  4\n  [ 9] .rel.plt          REL             000014b8 0014b8 000250 08  AI  2  10  4\n  [10] .plt              PROGBITS        00001708 001708 00038c 00  AX  0   0  4\n  [11] .text             PROGBITS        00001a94 001a94 0053d4 00  AX  0   0  4\n  [12] .ARM.extab        PROGBITS        00006e68 006e68 000078 00   A  0   0  4\n  [13] .ARM.exidx        ARM_EXIDX       00006ee0 006ee0 000178 08  AL 11   0  4\n  [14] .rodata           PROGBITS        00007058 007058 000038 00  AM  0   0  4\n  [15] .fini_array       FINI_ARRAY      00008cf8 007cf8 000008 00  WA  0   0  4\n  [16] .data.rel.ro      PROGBITS        00008d00 007d00 00007c 00  WA  0   0  4\n  [17] .init_array       INIT_ARRAY      00008d7c 007d7c 000008 00  WA  0   0  4\n  [18] .dynamic          DYNAMIC         00008d84 007d84 000128 08  WA  3   0  4\n  [19] .got              PROGBITS        00008eac 007eac 000154 00  WA  0   0  4\n  [20] .data             PROGBITS        00009000 008000 001450 00  WA  0   0  4\n  [21] .bss              NOBITS          0000a450 009450 000004 00  WA  0   0  4\n  [22] .comment          PROGBITS        00000000 009450 000065 01  MS  0   0  1\n  [23] .note.gnu.gold-ve NOTE            00000000 0094b8 00001c 00      0   0  4\n  [24] .ARM.attributes   ARM_ATTRIBUTES  00000000 0094d4 000034 00      0   0  1\n  [25] .shstrtab         STRTAB          00000000 009508 000103 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n</code></pre>\n\nA Part of Dynamic Section\n<pre><code>Dynamic section at offset 0x7d84 contains 32 entries:\n  Tag        Type                         Name/Value\n 0x00000003 (PLTGOT)                     0x8ecc\n 0x00000002 (PLTRELSZ)                   592 (bytes)\n 0x00000017 (JMPREL)                     0x14b8\n 0x00000014 (PLTREL)                     REL\n 0x00000011 (REL)                        0x1340\n 0x00000012 (RELSZ)                      376 (bytes)\n 0x00000013 (RELENT)                     8 (bytes)\n 0x6ffffffa (RELCOUNT)                   41\n 0x00000006 (SYMTAB)                     0x158\n 0x0000000b (SYMENT)                     16 (bytes)\n 0x00000005 (STRTAB)                     0x7f8\n 0x0000000a (STRSZ)                      1796 (bytes)\n 0x00000004 (HASH)                       0xefc\n ...\n</code></pre>\n\nTail of <pre><code>.dynamic</code></pre> and Head of <pre><code>.got</code></pre>\n<pre><code>...\n0x8e84:   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   |................|\n0x8e94:   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   |................|\n0x8ea4:   00 00 00 00 00 00 00 00  00                        |.........       |\n; section: .got\n0x8eac:   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00   |................|\n0x8ebc:   00 00 00 00 58 70 00 00  e0 6e 00 00 00 00 00 00   |....Xp...n......|\n0x8ecc:   00 00 00 00 00 00 00 00  00 00 00 00 08 17 00 00   |................|\n0x8edc:   08 17 00 00 08 17 00 00  08 17 00 00 08 17 00 00   |................|\n...\n</code></pre>\nThe Oracle's specification mentioned:\n\nThe symbol _GLOBAL_OFFSET_TABLE_ can be used to access the table. This symbol can reside in the middle of the .got section, allowing both negative and nonnegative subscripts into the array of addresses.\n\nBut the data before the entry of GOT are quietly different from others. All of the other data points to the very first PLT address(<pre><code>0x1708</code></pre>). Is the space before the entry point of GOT used to store the address of external functions as the same as others, or there are other ways to use them, or they are just unuseful garbage?\n\nUpdate\nI found there are two numbers in the block <pre><code>0x8eac</code></pre> to <pre><code>0x8ecb</code></pre>, the block before the entry point of the GOT. At <pre><code>0x8ec0</code></pre>, <pre><code>0x7058</code></pre> is the address of <pre><code>.rodata</code></pre> section. And at <pre><code>0x8ec4</code></pre>, <pre><code>0x6ee0</code></pre> is the address of <pre><code>.ARM.exidx</code></pre> section. Is it that filling these two address in <pre><code>.got</code></pre> a specific feature of the chain tools and compilers for ARM?\nI have not seen any specification of ELF mentions this.\n",
    "votes": "3",
    "answers": 1,
    "views": "2k",
    "tags": [
        "arm",
        "elf"
    ],
    "user": "IvanaGyro",
    "time": "Sep 27, 2018 at 16:41",
    "comments": [
        {
            "user": "perror",
            "text": "Well, in fact, it is normal that a fresh GOT (without resolution of addresses) is filled of pointers linking the start of the PLT. This is needed for the first initialization of the GOT (remember, the first time you encounter the function@plt, you need to execute the program which is located at the very beginning of the PLT). So, this explain why you have the PLT address repeatedly stored in the GOT (one address per library function that is used in the binary).\n",
            "time": null
        },
        {
            "user": "IvanaGyro",
            "text": "I know why PLT address repeatedly stored in the GOT. Each of the addresses stores the address of its corresponding external function or external variable. I am curious about the usage of the block before the entry point of the GOT.\n",
            "time": null
        },
        {
            "user": "perror",
            "text": "Okay, I better understand your question. But, you should try to look at the .dynamic section at runtime. It may change a lot of things... As the name suggest, it must be initialized only at start time (when the linker has performed his job). My guess is that you will see the addresses of all the listed variables set once at runtime.\n",
            "time": null
        },
        {
            "user": "Igor Skochinsky",
            "text": "what do you mean by \"entry point of GOT\"? AFAIK there is no such term\n",
            "time": null
        },
        {
            "user": "IvanaGyro",
            "text": "@IgorSkochinsky Sorry, I have not explained it clearly. The term, \"entry point of GOT\", means the address follows the tag, PLTGOT, in the <pre><code>.dynamic</code></pre> section. The address is also as the same as the address of GOT[0] in most of the specifications of the ELF.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "It's difficult to say without the sample, but you need to keep in mind that the dynamic loader does not care about sections. It only uses information from the program headers, including the <pre><code>PT_DYNAMIC</code></pre> entry (it may well be different from the <pre><code>.dynamic</code></pre> section in which case the section's contents is simply ignored).\nWhile customarily the GOT starts at the beginning of the <pre><code>.got</code></pre> section, it is not a requirement for the loader to do its job. It only uses the dynamic tags and dynamic relocation info (<pre><code>DT_JMPREL</code></pre>, <pre><code>DT_PLTREL</code></pre>, <pre><code>DT_REL</code></pre>, plus <pre><code>DT_SYMTAB</code></pre>,<pre><code>DT_STRTAB</code></pre> and <pre><code>DT_HASH</code></pre> and for symbol resolution). In fact, you can remove the section table completely and the file will still run (but some tools may have difficulties parsing it).\nPossibly some other section got merged with <pre><code>.got</code></pre>, although I don't know what it could be.\n",
            "votes": "2",
            "user": "Igor Skochinsky",
            "time": "Sep 20, 2018 at 19:23",
            "is_accepted": true,
            "comments": []
        }
    ]
}