{
    "title": "Why addresses of variable on stack are not consecutive?",
    "link": "https://reverseengineering.stackexchange.com/questions/4250/why-addresses-of-variable-on-stack-are-not-consecutive",
    "content": "The code below is generated by gcc from a simple scanf program. \nMy question is that \n\nWhy these 3 addresses of variables are not consecutive when allocated?\nIf not, when could I speculate the number of variables generated from stack by watching the\nclause like <pre><code>add esp, N</code></pre> which is often at the end of a routine? Is it related with calling convention?\nIn this example, why compiler does not generated the <pre><code>add esp, 20h</code></pre> with it?\n\nC code \n<pre><code>#include <stdio.h>\nint main() {\n  int x;\n  printf (\"Enter X:\n\");\n  scanf (\"%d\", &x);\n  printf (\"You entered %d...\n\", x);\n  return 0;\n};\n</code></pre>\nasm\n<pre><code>main            proc near\nvar_20          = dword ptr -20h\nvar_1C          = dword ptr -1Ch\nvar_4           = dword ptr -4\n                push    ebp\n                mov     ebp, esp\n                and     esp, 0FFFFFFF0h\n                sub     esp, 20h\n                mov     [esp+20h+var_20], offset aEnterX ; \"Enter X:\"\n                call    _puts\n                mov     eax, offset aD  ; \"%d\"\n                lea     edx, [esp+20h+var_4]\n                mov     [esp+20h+var_1C], edx\n                mov     [esp+20h+var_20], eax\n                call    ___isoc99_scanf\n                mov     edx, [esp+20h+var_4]\n                mov     eax, off set aYouEnteredD___ ; \"You entered %d...\n\"\n                mov     [esp+20h+var_1C], edx\n                mov     [esp+20h+var_20], eax\n                call    _printf\n                mov     eax, 0\n                leave\n                retn\nmain            endp\n</code></pre>\n",
    "votes": "4",
    "answers": 4,
    "views": "1k",
    "tags": [
        "disassembly",
        "assembly",
        "x86",
        "c"
    ],
    "user": "upton",
    "time": "May 3, 2014 at 17:43",
    "comments": [],
    "answers_data": [
        {
            "content": "There is only actually one local variable in your function: x. This variable is located on the stack where you would expect it, at <pre><code>ebp-4</code></pre>. IDA is getting confused because this particular function, instead of pushing variables onto the stack before calling a function, is moving them instead. This tricks IDA into thinking those are local variables when they're actually just the locations at the top of the stack.\n<pre><code>mov     [esp+20h+var_1C], edx  <===> push edx\nmov     [esp+20h+var_20], eax  <===> push eax\n</code></pre>\nI can't definitively explain why gcc is doing this, but my guess is that you compiled without optimizations. This instruction layout might make debugging easier.\nI think you're also confusing calling conventions with local variable cleanup. Every function needs to clean up its own local variable area. Your main() function is doing that with the <pre><code>leave</code></pre> instruction. Calling conventions are related to cleaning up the parameters passed to a function.\n",
            "votes": "5",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "there is no add esp ,20 because of the leave instruction (LEAVE PROCDURE ) instruction \nquoted ftom intel instruction manual\n<pre><code>6.5.2 LEAVE Instruction\nThe LEAVE instruction, which does not have any operands, reverses the action of the previous ENTER instruction. \nThe LEAVE instruction copies the contents of the EBP register into the ESP register to release all stack space allocated to the procedure. Then it restores the old value ofthe EBP register from the stack. This simultaneously \nrestores the ESP register to its original value. A subsequent RET instruction then can remove any arguments and \nthe return address pushed on the stack by the calling program for use by the procedure.\n</code></pre>\nas to the other part in your question i guess it is because the compiler didn't generate any push argument instruction it utilises the top part for moving the args into stack \nand bottom part for varargs storage \n<pre><code>mov [esp],%d\nmov [esp+4] , ADDR where to store the input ie ADDR of [esp+1c]\n</code></pre>\n",
            "votes": "3",
            "user": "blabb",
            "time": "May 3, 2014 at 17:44",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "There's actually only one stack variable in this function: <pre><code>var_4</code></pre>\nIn the disassembly above, IDA incorrectly detects arguments passed to <pre><code>_puts()</code></pre>, <pre><code>___isoc99_scanf()</code></pre>, and <pre><code>_printf()</code></pre> as local stack variables. To see this, let's analyze the following snippet:\n<pre><code>mov     [esp+20h+var_20], offset aEnterX ; \"Enter X:\"\ncall    _puts\n</code></pre>\n<pre><code>var_20</code></pre> is defined by IDA at the beginning of this function as <pre><code>-20h</code></pre>, so <pre><code>mov [esp+20h+var_20], offset aEnterX</code></pre> is effectively saying <pre><code>mov [esp+20h+-20h], offset aEnterX</code></pre>, which is the same as <pre><code>mov [esp], offset aEnterX</code></pre>. In other words, the code is just pushing <pre><code>offset aEnterX</code></pre> onto the stack before calling <pre><code>_puts()</code></pre>, and IDA is unfortunately detecting that \"alternative push\" as a local stack variable.\n",
            "votes": "3",
            "user": "Jason Geffner",
            "time": "May 3, 2014 at 17:48",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "(I deal more with code generated by Visual C++, so some parts of this answer are just educated guesses.)\n\n1.Why these 3 addresses of variables are not consecutive when allocated?\n\nVariable alignment and even presence on the stack is up to the compiler and can differ based on the specific compiler version you use, the optimization options being used, and other factors.\nThe 3 variables in your example are not all \"real\" variables. <pre><code>var_4</code></pre> is the variable corresponding to your <pre><code>x</code></pre>, whereas <pre><code>var_1C</code></pre> and <pre><code>var_20</code></pre> are simply results of GCC's approach to passing arguments to deeper function calls. When you write <pre><code>scanf(\"%d\", &x);</code></pre>, GCC knows that it will need to pass two 4-byte variables to that function on the stack, so it pre-emptively reserves enough room for them upon entering the function. This way, it doesn't need to <pre><code>push</code></pre> anything onto the stack (which might be problematic if there's no stack space left...), it just needs to <pre><code>mov</code></pre> the arguments into that preallocated space.\nThat doesn't explain why there's a gap between the two allocations, though. GCC also prefers to align stack allocations to 16 bytes1, and this is where I am guessing it seems that the sizes needed for \"real local variables\" and \"space reserved for deeper function arguments\" are aligned independently before being summed into the final value of \"reserved stack space\".\n1You can control this alignment by using <pre><code>-mpreferred-stack-boundary=num</code></pre>.\n\n2.If not, when could I speculate the number of variables generated from stack by watching the clause like <pre><code>add esp, N</code></pre> which is often at the end of a routine? Is it related with calling convention?\n\nAs you can see in this example, that instruction does not always get generated. Its counterpart, <pre><code>sub esp, N</code></pre>, is a much better indicator. From that you can make educated guesses about the amount/sizes of local variables.\nCalling convention is not related to a function's local variables, it controls the way the arguments are passed into the function and whose responsibility it is to clean them up afterwards.\n\n3.In this example, why compiler does not generated the <pre><code>add esp, 20h</code></pre> with it?\n\nThe function in your example begins with <pre><code>push ebp; mov ebp, esp</code></pre>, which saves the original values of both <pre><code>ebp</code></pre> and <pre><code>esp</code></pre>. The <pre><code>leave</code></pre> instruction at the end does the reverse - it restores the saved values of <pre><code>esp</code></pre> and <pre><code>ebp</code></pre>, so there's no need to calculate anything.\nThe saved <pre><code>ebp</code></pre> is also known as a frame pointer. It is possible to instruct the compiler not to generate it, in which case the original value of <pre><code>esp</code></pre> needs to be restored using that calculation you mentioned.\n",
            "votes": "2",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": []
        }
    ]
}