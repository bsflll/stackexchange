{
    "title": "IDA Hex-Rays: How to SAFELY fix incorrect function declarations?",
    "link": "https://reverseengineering.stackexchange.com/questions/20591/ida-hex-rays-how-to-safely-fix-incorrect-function-declarations",
    "content": "Update:\nThe problem turned out to be more complex and complex because Hex-Rays incorrectly restores the stack after calls of <pre><code>stdcall</code></pre> functions from <pre><code>cdecl</code></pre> functions:\n<pre><code>.text:00403F2F 074                 mov     edx, gameScreenHeight\n.text:00403F35 074                 mov     ecx, [eax]\n.text:00403F37 **074**             push    10h\n.text:00403F39 078                 push    edx\n.text:00403F3A 07C                 mov     edx, gameScreenWidth\n.text:00403F40 07C                 push    edx\n.text:00403F41 080                 push    eax\n.text:00403F42 084                 mov     eax, [ecx+54h]\n.text:00403F45 084                 call    eax\n.text:00403F47 **070**             test    eax, eax\n.text:00403F49 070                 jz      short loc_4\n</code></pre>\nAs a result, a function that takes 4 arguments gets only three:\nBad: <pre><code>lpDD->lpVtbl->SetDisplayMode(lpDD, gameScreenWidth, gameScreenHeight, 16, **a1**)</code></pre>\nGood: <pre><code>lpDD->lpVtbl->SetDisplayMode(lpDD, gameScreenWidth, gameScreenHeight, 16)</code></pre>\nAs a result, the function may not use the register value, but only save and restore it, but due to the shifted pointer to the stack after the call, it is considered to be used in some problem call. This causes the entire call chain to be marked as using this register as an argument.\nWorst of all, such a problem arises in branched functions, which have several exit points and in each of them the stack is balanced (000). I can't just change the stack pointer after an erroneous call. I must also find another call and balance the changes made. x.x\n\nThe original question:\nI need to detect and safely fix incorrectly recognized function signatures. How I can do that?\nFor example, this function saves game settings:\n<pre><code>BOOL __thiscall sub_410640(HKEY this)\n{\n  HKEY v1; // ecx\n  HKEY v2; // ecx\n\n  sub_431C00(this, \"volumeMaster\", *(_DWORD *)&phkResult);\n  sub_431C00(*(HKEY *)&g_volumeMusic, \"volumeMusic\", *(_DWORD *)&g_volumeMusic);\n  sub_431C00(v1, \"volumeFX\", *(_DWORD *)&g_volumeFX);\n  sub_431C00(v2, \"volumeSpeech\", *(_DWORD *)&g_volumeSpeech);\n  return sub_431C00(*(HKEY *)&dword_4A262C, \"volumeMinimum\", *(_DWORD *)&dword_4A262C);\n}\n\n.text:00410640     sub_410640      proc near               ; CODE XREF: PlayVideo+50↑p\n.text:00410640                                             ; sub_416910+1A6↓p\n.text:00410640 000                 mov     eax, phkResult\n.text:00410645 000                 push    eax             ; Data\n.text:00410646 004                 push    offset ValueName ; \"volumeMaster\"\n.text:0041064B 008                 call    sub_431C00\n\n.text:00410650 008                 mov     ecx, g_volumeMusic\n.text:00410656 008                 push    ecx             ; Data\n.text:00410657 00C                 push    offset aVolumemusic ; \"volumeMusic\"\n.text:0041065C 010                 call    sub_431C00\n\n.text:00410661 010                 mov     edx, g_volumeFX\n.text:00410667 010                 push    edx             ; Data\n.text:00410668 014                 push    offset aVolumefx ; \"volumeFX\"\n.text:0041066D 018                 call    sub_431C00\n\n.text:00410672 018                 mov     eax, g_volumeSpeech\n.text:00410677 018                 push    eax             ; Data\n.text:00410678 01C                 push    offset aVolumespeech ; \"volumeSpeech\"\n.text:0041067D 020                 call    sub_431C00\n\n.text:00410682 020                 mov     ecx, dword_4A262C\n.text:00410688 020                 push    ecx             ; Data\n.text:00410689 024                 push    offset aVolumeminimum ; \"volumeMinimum\"\n.text:0041068E 028                 call    sub_431C00\n\n.text:00410693 028                 add     esp, 28h\n.text:00410696 000                 retn\n.text:00410696     sub_410640      endp\n</code></pre>\nIf we look at the function inside, we can see that the arguments passed through the registers are not used in any way.\nIn addition, it is obvious that calls to the same function should be uniform and the transfer of such arguments does not make any sense.\n<pre><code>BOOL __usercall sub_431C00@<eax>(HKEY a1@<ecx>, LPCSTR lpValueName, ...)\n{\n  LONG v3; // esi\n  HKEY phkResult; // [esp+0h] [ebp-4h]\n  va_list Data; // [esp+Ch] [ebp+8h]\n\n  va_start(Data, lpValueName);\n  phkResult = a1;\n  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, SubKey, 0, 1u, &phkResult) )\n    return 0;\n  v3 = RegSetValueExA(phkResult, lpValueName, 0, 4u, (const BYTE *)Data, 4u);\n  RegCloseKey(phkResult);\n  return v3 == 0;\n}\n\n.text:00410600     sub_410600      proc near               ; CODE XREF: sub_4073F0+2B0↑p\n.text:00410600                                             ; WinMain(x,x,x,x)+5F4↓p ...\n.text:00410600\n.text:00410600     arg_0           = dword ptr  4\n.text:00410600\n.text:00410600 000                 mov     eax, [esp+arg_0]\n.text:00410604 000                 test    eax, eax\n.text:00410606 000                 mov     ecx, 1\n.text:0041060B 000                 mov     dword_4AE978, ecx\n.text:00410611 000                 mov     dword_4AF074, eax\n.text:00410616 000                 jz      short locret_410632\n.text:00410618 000                 mov     dword_4A267C, 69h\n.text:00410622 000                 mov     dword_4AE920, 0\n.text:0041062C 000                 mov     dword_4AF03C, ecx\n.text:00410632\n.text:00410632     locret_410632:                          ; CODE XREF: sub_410600+16↑j\n.text:00410632 000                 retn\n.text:00410632     sub_410600      endp\n</code></pre>\nAnd now I need to adjust the declaration of these functions so that it corresponds to reality.\nBut two questions arise:\n\nHow to understand what the problem is?\nHow to make corrections safely so that one error in one function does not lead to unbalance of the stack and decompilation errors throughout the entire application database?\n\nExpected result:\n<pre><code>BOOL __usercall sub_431C00(LPCSTR lpValueName, _DWORD value);\n\nsub_431C00(\"volumeMaster\", *(_DWORD *)&phkResult);\nsub_431C00(\"volumeMusic\", *(_DWORD *)&g_volumeMusic);\nsub_431C00(\"volumeFX\", *(_DWORD *)&g_volumeFX);\nsub_431C00(\"volumeSpeech\", *(_DWORD *)&g_volumeSpeech);\n</code></pre>\nLink to this PE File\nOh yeah, the funny thing is that in this case IDA correctly defines the function signature, but for some reason Hex-Rays blows the roof off:\nIDA: <pre><code>int __cdecl sub_431C00(LPCSTR lpValueName, BYTE Data)</code></pre>\nHex-Rays: <pre><code>BOOL __usercall sub_431C00@<eax>(HKEY a1@<ecx>, LPCSTR lpValueName, ...)</code></pre>\n",
    "votes": "1",
    "answers": 2,
    "views": "3k",
    "tags": [
        "ida",
        "hexrays",
        "calling-conventions",
        "stack-variables"
    ],
    "user": "Albeoris",
    "time": "Feb 12, 2019 at 22:23",
    "comments": [
        {
            "user": "Biswapriyo",
            "text": "Possible duplicate of Why does IDA show wrong function arguments in pseudocode?\n",
            "time": null
        },
        {
            "user": "Igor Skochinsky",
            "text": "\" we can see that the arguments passed through the registers are not used in any way.\" <- Really? What about <pre><code>ecx</code></pre>?\n",
            "time": null
        },
        {
            "user": "Albeoris",
            "text": "@IgorSkochinsky <pre><code>mov ecx, 1</code></pre> what about <pre><code>ecx</code></pre>? The function uses two arguments from the stack.\n",
            "time": null
        },
        {
            "user": "Igor Skochinsky",
            "text": "In the question body you’re comparing disassembly of sub_410600   with decompilation of sub_431C00\n",
            "time": null
        },
        {
            "user": "Albeoris",
            "text": "@IgorSkochinsky, ah got it!\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Welcome to RE.SE!\n\nHow to understand what the problem is?\n\nWhen the function is decompiled, IDA checks for its dependencies via dataflow analysis. Basically, it asks which values have to be defined in order to make this function work.\nWhen it encounters the first line of the function (<pre><code>push ecx</code></pre>) IDA noticed that the value of ecx is used before it was defined in this function, hence it establishes it as a dependency, even though IDA is well aware that it is not a parameter to the <pre><code>RegOpenkeyExA</code></pre> call through its signature. At either and of the function, the ecx value is restored.\nThis is what makes IDA think, ecx is part of the function signature: it actually is\nFun IDA fact: When you decompile function <pre><code>sub_410640</code></pre> first without looking at <pre><code>sub_431C00</code></pre>, the signatures are like you want them to be (due to the lack of information)\n<pre><code>int sub_410640()\n{\n  sub_431C00(\"volumeMaster\", phkResult);\n  sub_431C00(\"volumeMusic\", dword_4D55C8);\n  sub_431C00(\"volumeFX\", dword_4D55CC);\n  sub_431C00(\"volumeSpeech\", dword_4D55D0);\n  return sub_431C00(\"volumeMinimum\", dword_4A262C);\n}\n</code></pre>\nThe core problem is the weird useage of the ecx register in this function. Even from an optimization point of view, it does not make any sense.\n\nHow to make corrections safely so that one error in one function does\n  not lead to unbalance of the stack and decompilation errors throughout\n  the entire application database?\n\nFor example, you could NOP-out the code pushing and poping ecx in the function, since it seems the calling function doesn't rely on this value remaining constant. I tested it real quick and it seems to work.\nYou could also solve the pointer aliasing problem. If you could find a way to proof that the <pre><code>ecx</code></pre> value on the stack is not written or read, one could omit this parameter. Sadly, that's pretty hard.\nYou could also try and come up with a better decompiler utilizing different heuristics, I guess. You could also try RetDec or Snowman for better results, but they will perform dataflow analysis similar to Hex-Rays and may end up with similar results.\nThe decompiler works kind of like a one-way function. When you invoke it, the current function and meta data like variable names and function signatures are passed to it. Although it allows for some corrections, its only the meta data and should not change the assembly code at all.\n",
            "votes": "2",
            "user": "Nordwald",
            "time": "Feb 12, 2019 at 6:16",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Albeoris",
                    "text": "<span class=\"comment-copy\">Thank you very much for the help! Knowing which direction to look for, I found even more problems on my head. I updated my post by describing the situation. It will not be easy ...</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "The decompiler decided that <pre><code>ecx</code></pre> is used by <pre><code>sub_431C00</code></pre> because of <pre><code>push    ecx</code></pre> at the beginning of the function which fills the stack slot later used by the variable <pre><code>phkResult</code></pre>, so it may look as if the initial value of <pre><code>phkResult</code></pre> is taken from <pre><code>ecx</code></pre>:\n<pre><code>.text:00431C00                 push    ecx\n.text:00431C01                 lea     eax, [esp+4+phkResult]\n.text:00431C04                 push    eax             ; phkResult\n.text:00431C05                 push    1               ; samDesired\n.text:00431C07                 push    0               ; ulOptions\n.text:00431C09                 push    offset SubKey   ; \"SOFTWARE\\\\Valkyrie Studios\\\\Septerra Co\"...\n.text:00431C0E                 push    80000002h       ; hKey\n.text:00431C13                 call    ds:RegOpenKeyExA\n.text:00431C19                 test    eax, eax\n.text:00431C1B                 jz      short loc_431C21\n.text:00431C1D                 xor     eax, eax\n.text:00431C1F                 pop     ecx\n.text:00431C20                 retn\n</code></pre>\nIn fact, this <pre><code>push ecx</code></pre> is just a shorter versions of <pre><code>sub esp, -4</code></pre> - the value of <pre><code>ecx</code></pre> does not need to be preserved across function calls so this push is used to reserve 4 bytes of the stack for the <pre><code>phkResult</code></pre> variable. Unfortunately, it is pretty difficult for an automatic algorithm to differentiate between genuine pushes to save registers or pass arguments to function calls and dummy ones to manipulate the stack. If you decided that the ecx usage is false positive, just fix the function prototype (Y key) and remove the unnecessary argument:\n<pre><code>int __cdecl sub_431C00(LPCSTR lpValueName, DWORD Data)\n{\n  LSTATUS v3; // esi\n  HKEY phkResult; // [esp+0h] [ebp-4h]\n\n  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Valkyrie Studios\\\\Septerra Core\", 0, 1u, &phkResult) )\n    return 0;\n  v3 = RegSetValueExA(phkResult, lpValueName, 0, REG_DWORD, (const BYTE *)&Data, 4u);\n  RegCloseKey(phkResult);\n  return v3 == 0;\n}\n</code></pre>\nAnd now the parent sub has nice decompilation too:\n<pre><code>int sub_410640()\n{\n  sub_431C00(\"volumeMaster\", g_volumeMaster);\n  sub_431C00(\"volumeMusic\", g_volumeMusic);\n  sub_431C00(\"volumeFX\", g_volumeFX);\n  sub_431C00(\"volumeSpeech\", g_gvolumeSpeech);\n  return sub_431C00(\"volumeMinimum\", g_volumeMinimum);\n}\n</code></pre>\nSo, to summarize:\n\nThe problem is caused by compiler optimization confusing the decompiler into deciding that the register value is used while it's just a dummy filler. \nThere is no one true solution that always works, you'll need to experiment and be prepared to roll back and try again. With experience it will become easier.\n\nP.S. IDA did not add <pre><code>ecx</code></pre> to the function prototype because it only analyzes stack arguments. The decompiler does dataflow analysis so it can recover register arguments too, but sometimes it can result in false positives, like here.\n",
            "votes": "2",
            "user": "Igor Skochinsky",
            "time": "Feb 13, 2019 at 9:16",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Albeoris",
                    "text": "<span class=\"comment-copy\">Thanks for the detailed answer. It is a pity that you can not mark both. Very interesting information about optimization!</span>",
                    "time": null
                },
                {
                    "user": "Orwellophile",
                    "text": "<span class=\"comment-copy\">\"101 ways to manipulate the stack pointer to confuse decompilers.\"  I'm not sure where the notion that half of them are optimisations rather than obfuscations should make me laugh or cry.  +1 for holding a competition for the most obscure ways to manipulate the stack :)</span>",
                    "time": null
                }
            ]
        }
    ]
}