{
    "title": "Randomly picking up a x86 register for an instruction",
    "link": "https://reverseengineering.stackexchange.com/questions/12834/randomly-picking-up-a-x86-register-for-an-instruction",
    "content": "I came around a piece of malware which i am analyzing and have found that it uses some kind of math to randomly selecting a register for a specific instruction\nWhich i don't understand how this operation is calculated depend on what?\nHere is an example of what i mean\nlet's say that i wanted to randomly pick up a register for the instruction\n<pre><code>ADD DWORD PTR DS:[0],EAX\n</code></pre>\nWe know the opcode for this instruction is 01 05 00 00 00 00\nThe bold number represents the register for this instruction\n05 == EAX\n0D == ECX\nTo better explain this here is the instruction with all the registers\n<pre><code>0041580B    0105 00000000   ADD DWORD PTR DS:[0],EAX\n00415811    010D 00000000   ADD DWORD PTR DS:[0],ECX\n00415817    0115 00000000   ADD DWORD PTR DS:[0],EDX\n0041581D    011D 00000000   ADD DWORD PTR DS:[0],EBX\n00415823    0125 00000000   ADD DWORD PTR DS:[0],ESP\n00415829    012D 00000000   ADD DWORD PTR DS:[0],EBP\n0041582F    0135 00000000   ADD DWORD PTR DS:[0],ESI\n00415835    013D 00000000   ADD DWORD PTR DS:[0],EDI\n</code></pre>\nThe malware uses a register index starting from 0 (EAX) till 7 (EDI)\nThe number is get SHLed first with the number 3 then it is ORed with 5 to get the right register opcode. So my question is how the author came to the conclusion of that?\nI would say that SHL REG,3 equals REG*8 that is the number of max registers? but why do we need to OR it with 05? is it because the starting opcode of this instruction is 05?\nDoes anybody have a better explanation for this? or any hint words for a better comprehend?\n",
    "votes": "11",
    "answers": 1,
    "views": "890",
    "tags": [
        "assembly",
        "x86",
        "malware",
        "register"
    ],
    "user": "RCECoder",
    "time": "Dec 30, 2016 at 20:01",
    "comments": [],
    "answers_data": [
        {
            "content": "To better understand this, you need to study instruction encoding formats i.e. x86 for this question.\nAn x86 instruction looks like this\n<pre><code>+----------------------+--------+--------+-----+--------------+-----------+\n| Instruction prefixes | Opcode | ModR/M | SIB | Displacement | Immediate |\n+----------------------+--------+--------+-----+--------------+-----------+\n|          0-4         |   1-3  |   0-1  | 0-1 |      0-4     |    0-4    |\n+----------------------+--------+--------+-----+--------------+-----------+\n</code></pre>\nThe numbers on the second row indicates the length in bytes of the corresponding part.\nFor the instruction,\n<pre><code>010D 00000000   ADD DWORD PTR DS:[0],ECX\n</code></pre>\nthere is no instruction prefix.\nThe opcode for <pre><code>ADD</code></pre> is <pre><code>01</code></pre> (Check here)\nThe second byte of the instruction i.e <pre><code>ModR/M</code></pre>is <pre><code>0D</code></pre>.\nThe <pre><code>ModR/M</code></pre> byte provides addressing information about the instruction. It specifies whether an operand is in a register or in memory; if it is in memory, then fields within the byte specify the addressing mode to be used.\nThe <pre><code>ModR/M</code></pre> byte can be broken down into\n<pre><code>+-----+------------+-----+\n| Mod | Reg/Opcode | R/M |\n+-----+------------+-----+\n|  2  |      3     |  3  |\n+-----+------------+-----+\n</code></pre>\nHere the numbers on the second row indicates the length in bits of the corresponding parts.\nThe <pre><code>Mod</code></pre> field (2 bits) combines with the <pre><code>R/M</code></pre> field (3 bits) to form 32 possible values 8 registers and 24 addressing modes.\nThe <pre><code>Reg/Opcode</code></pre> field (3 bits) specifies either a register number or three more bits of opcode information; the <pre><code>r/m</code></pre> field (3 bits) can specify a register as the location of an operand, or it can form part of the addressing-mode encoding in combination with the <pre><code>Mod</code></pre> field.\nNow, convert the <pre><code>ModR/M</code></pre> i.e <pre><code>0D</code></pre> to binary. You would get.\n<pre><code>+-----+------------+-----+\n| Mod | Reg/Opcode | R/M |\n+-----+------------+-----+\n|  00 |     001    | 101 |\n+-----+------------+-----+\n</code></pre>\nThe <pre><code>Mod</code></pre> and <pre><code>R/M</code></pre> fields are <pre><code>00</code></pre> and <pre><code>101</code></pre> respectively. This indicates displacement only addressing mode. See the table below.\n \nFor all the instructions this mode of addressing is used, hence the reason for  <pre><code>OR</code></pre>ing with 5 (in binary 101) to set that particular bit pattern.\nComing to the <pre><code>Reg/Opcode</code></pre> field, this indicates a register. \n<pre><code>001</code></pre> is the register index for <pre><code>ECX</code></pre>. \nFor the first instruction i.e\n<pre><code>0105 00000000   ADD DWORD PTR DS:[0],EAX</code></pre>\nthis field is <pre><code>000</code></pre> standing for <pre><code>EAX</code></pre>. You can check by converting <pre><code>05</code></pre> to binary.\nSee more in the table below taken from here.\n\nSo basically the register value was <pre><code>SHL</code></pre>ed with 3 to move it to the correct position. The Reg/Opcode field is 3 bits from the right.\nFinally the last 4 bytes are <pre><code>00000000</code></pre>. This represents the displacement which is zero in this example.\n",
            "votes": "18",
            "user": "0xec",
            "time": "Jun 12, 2016 at 18:49",
            "is_accepted": true,
            "comments": []
        }
    ]
}