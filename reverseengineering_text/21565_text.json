{
    "title": "angr | populate int array with constraints",
    "link": "https://reverseengineering.stackexchange.com/questions/21565/angr-populate-int-array-with-constraints",
    "content": "How do I populate memory address using <pre><code>angr</code></pre> with array of integers (?) and add a constraint so each int will be positive & less than 17 ?\nI hope it's clear I need to find out the <pre><code>in_array</code></pre> combination\nchall.c\n<pre><code>// gcc -m32 chall.c -o chall \n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\nint p = 0;\nint c = 1;\nchar d[45] = {0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0};\nchar in_array[16] = {0};\n\nint M(char *a1, int a2);\nvoid BAD();\nvoid GOOD();\n\nint main(int argc, char *argv[])\n{\n  if (M(in_array, 16))\n    GOOD();\n}\n\n\nint M(char *a1, int a2)\n{\n  char *v2; // r11\n  unsigned int v3; // r10\n  signed int v4; // r9\n  int v5; // r6\n  int v6; // r3\n  int v7; // r4\n  int v8; // r5\n  signed int v9; // r8\n  unsigned int v10; // r2\n  unsigned int v11; // r1\n  char v12; // r1\n  int v14; // [sp+14h] [bp-34h]\n  char v15[16]; // [sp+18h] [bp-30h]\n  int v16; // [sp+28h] [bp-20h]\n\n  v2 = a1;\n  v3 = a2;\n  if ( a2 >= 2 )\n  {\n    v4 = (unsigned int)a2 >> 1;\n    M(a1, (unsigned int)a2 >> 1);\n    if ( c )\n    {\n      v5 = (int) &v2[v3 >> 1];\n      M(&v2[v3 >> 1], v3 - (v3 >> 1));\n      if ( c )\n      {\n        v6 = v3 - (v3 >> 1);\n        v14 = v3 - (v3 >> 1);\n        if ( (signed int)(v3 - (v3 >> 1)) >= 1 )\n        {\n          v7 = 0;\n          v8 = 0;\n          v9 = 0;\n          while ( 1 )\n          {\n            v10 = *(char *)(v5 + v8);\n            v11 = v2[v9];\n            if ( v11 >= v10 )\n            {\n              if ( v11 <= v10 || d[p] )\n              {\nLABEL_21:\n                c = 0;\n                BAD();\n                // return 0;\n              }\n              ++p;\n              v12 = *(char *)(v5 + v8++);\n            }\n            else\n            {\n              if ( d[p] != 1 )\n                goto LABEL_21;\n              v6 = v14;\n              ++p;\n              v12 = v2[v9++];\n            }\n            v15[v7++] = v12;\n            if ( v9 >= v4 || v8 >= v6 )\n              goto LABEL_16;\n          }\n        }\n        v9 = 0;\n        v8 = 0;\n        v7 = 0;\nLABEL_16:\n        if ( v4 > v9 )\n        {\n          memcpy(&v15[v7], &v2[v9], v4 - v9);\n          v6 = v14;\n          v7 = v7 + v4 - v9;\n        }\n        if ( v8 < v6 )\n          memcpy(&v15[v7], &v2[v8 + v4], v3 - v8 - v4);\n        memcpy(v2, v15, v3);\n      }\n    }\n  }\n  return 1;\n}\n\nvoid BAD() \n{\n  printf(\"BAD\n\");\n  exit(2);\n}\n\nvoid GOOD() \n{\n  printf(\"GOOD\n\");\n\n  for (int j = 0; j < 16; j++)\n    printf(\"%d \", in_array[j]);\n\n  printf(\"\n\");\n}\n\n</code></pre>\n<pre><code>\n$ readelf -s chall | grep -E \"in_array|GOOD|BAD|main\" | grep -v libc\n    44: 0000063d    46 FUNC    GLOBAL DEFAULT   14 BAD\n    72: 000006d9    69 FUNC    GLOBAL DEFAULT   14 main\n    78: 00002078    16 OBJECT  GLOBAL DEFAULT   24 in_array\n    79: 0000066b   110 FUNC    GLOBAL DEFAULT   14 GOOD\n\n</code></pre>\nsolve.py\n<pre><code>import angr\nimport claripy\n\nbase = 0x400000\nmain, good, bad = base + 0x6d9, base + 0x66b, base + 0x63d\npointer_size = 4\nin_array_addr, in_array_size = base + 0x2078, 16 * pointer_size\n\np = angr.Project('./chall')\nstate = p.factory.blank_state(addr=main)\n\narr = claripy.BVS('in_array', in_array_size)\nfor i in arr.chop(pointer_size):\n  state.add_constraints(i >= 0)\n  state.add_constraints(i < 17)\nstate.memory.store(in_array_addr, arr)\n\nsm = p.factory.simulation_manager(state)\n\nsm.explore(find=good, avoid=bad)\nprint('found ?', len(sm.found))\n\nflag_state = sm.found[0]\nflag_data = flag_state.memory.load(in_array, in_array_size)\nprint(flag_state.solver.eval(flag_data, cast_to=bytes).strip(b'\\0\n'))\n\n</code></pre>\nangr log\n<pre><code>WARNING | cle.loader | The main binary is a position-independent executable. It is being loaded with a base address of 0x400000.\nWARNING | angr.state_plugins.symbolic_memory | The program is accessing memory or registers with an unspecified value. This could indicate unwanted behavior.\nWARNING | angr.state_plugins.symbolic_memory | angr will cope with this by generating an unconstrained symbolic variable and continuing. You can resolve this by:\nWARNING | angr.state_plugins.symbolic_memory | 1) setting a value to the initial state\nWARNING | angr.state_plugins.symbolic_memory | 2) adding the state option ZERO_FILL_UNCONSTRAINED_{MEMORY,REGISTERS}, to make unknown regions hold null\nWARNING | angr.state_plugins.symbolic_memory | 3) adding the state option SYMBOL_FILL_UNCONSTRAINED_{MEMORY_REGISTERS}, to suppress these messages.\nWARNING | angr.state_plugins.symbolic_memory | Filling memory at 0x7fff0000 with 4 unconstrained bytes referenced from 0x4006e0 (main+0x7 in chall (0x6e0))\nWARNING | angr.state_plugins.symbolic_memory | Filling register ebp with 4 unconstrained bytes referenced from 0x4006e3 (main+0xa in chall (0x6e3))\nWARNING | angr.state_plugins.symbolic_memory | Filling register esi with 4 unconstrained bytes referenced from 0x400721 (M+0x3 in chall (0x721))\nWARNING | angr.state_plugins.symbolic_memory | Filling register ebx with 4 unconstrained bytes referenced from 0x400722 (M+0x4 in chall (0x722))\nfound ? 0\n</code></pre>\n",
    "votes": "2",
    "answers": 1,
    "views": "2k",
    "tags": [
        "angr"
    ],
    "user": "James W.",
    "time": "Jun 30, 2019 at 13:02",
    "comments": [
        {
            "user": "0xec",
            "text": "Using <pre><code>state.solver.add</code></pre>. Examples here\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Making a few changes to the code you've posted, angr is able to find a solution.\nThe addresses of the symbol are resolved dynamically using <pre><code>proj.loader.find_symbol</code></pre>. This avoids hard coding the address which may each change each-time the source is recompiled.\nInstead of declaring a big BitVector covering the entire array, I've declared 16 8-bit BitVectors, one each for every element of the array. This way it's easier to apply the constraints.\n<pre><code>import angr\n\nproj = angr.Project('./chall')\n\n# Addresses of symbols\nmain = proj.loader.find_symbol('main').rebased_addr\ngood = proj.loader.find_symbol('GOOD').rebased_addr \nbad = proj.loader.find_symbol('BAD').rebased_addr \n\nin_array_addr = proj.loader.find_symbol('in_array').rebased_addr  \n\n# in_array is a char array with 16 elements and sizeof(char)=1\nin_array_size = 16 * 1\n\ninitial_state = proj.factory.entry_state(addr=main)\n\nfor i in range(in_array_size):\n    # Each char of the array is a 8 bit BitVector\n    ch = initial_state.solver.BVS('ch{}'.format(i), 8)\n\n    # Add constraints\n    initial_state.solver.add(ch >= 0)    \n    initial_state.solver.add(ch < 17)\n\n    # Store BV to memory\n    initial_state.memory.store(in_array_addr+i, ch)\n\n\n# Create a Simulation manager from the current state\nsm = proj.factory.simulation_manager(initial_state)\n\n# Find a path to good while avoiding bad\nsm.explore(find=good, avoid=bad)\n\nprint(\"No. of solutions found:\", len(sm.found))\n\nif len(sm.found) > 0:        \n    # Considering the first goal state\n    goal_state = sm.found[0]\n\n    # Load contents of memory at the said address\n    flag_data = goal_state.memory.load(in_array_addr, in_array_size)\n\n    # Convert flag_data from BitVector to bytes\n    answer = goal_state.solver.eval(flag_data, cast_to=bytes)\n    print (list(answer))\n</code></pre>\nOutput\n<pre><code>user@70a6c29adea0 $ python solve.py\nWARNING | 2019-07-04 21:09:04,764 | angr.state_plugins.symbolic_memory | The program is accessing memory or registers with an unspecified value. This could indicate unwa\nnted behavior.\nWARNING | 2019-07-04 21:09:04,764 | angr.state_plugins.symbolic_memory | angr will cope with this by generating an unconstrained symbolic variable and continuing. You ca\nn resolve this by:\nWARNING | 2019-07-04 21:09:04,764 | angr.state_plugins.symbolic_memory | 1) setting a value to the initial state\nWARNING | 2019-07-04 21:09:04,764 | angr.state_plugins.symbolic_memory | 2) adding the state option ZERO_FILL_UNCONSTRAINED_{MEMORY,REGISTERS}, to make unknown regions h\nold null\nWARNING | 2019-07-04 21:09:04,764 | angr.state_plugins.symbolic_memory | 3) adding the state option SYMBOL_FILL_UNCONSTRAINED_{MEMORY_REGISTERS}, to suppress these messa\nges.\nWARNING | 2019-07-04 21:09:04,765 | angr.state_plugins.symbolic_memory | Filling register edi with 4 unconstrained bytes referenced from 0x8048861 (__libc_csu_init+0x1 i\nn chall (0x8048861))\nWARNING | 2019-07-04 21:09:04,770 | angr.state_plugins.symbolic_memory | Filling register ebx with 4 unconstrained bytes referenced from 0x8048863 (__libc_csu_init+0x3 i\nn chall (0x8048863))\nNo. of solutions found: 1\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16]\n</code></pre>\nUPDATE\nAfter OP mentioned that its a challenge from Google CTF Quals 2019, I decided to look at the original binary instead.\nApparently the previous answer from angr doesn't satisfy the C code OP posted. There were a couple of reasons for this.\nThe first and glaring mistake was using the <pre><code>goal_state</code></pre> to load <pre><code>flag_data</code></pre>. This is wrong as in <pre><code>goal_state</code></pre> the <pre><code>flag_data</code></pre> will get changed.\nThe second mistake was the bytes of <pre><code>in_array</code></pre> should be in between 0 and 16 (not 0 and 17).\nThis can be inferred from the Ghidra decompiler screenshot.\n\nThe last line \n<pre><code>return uVar2 & (uint)((byte)local_24[15] < 16);\n</code></pre>\nchecks whether the final element of the array is <pre><code>< 16</code></pre>.\nThe following updated script prints out the the contents of <pre><code>in_array</code></pre> which satisfies the constraints.\n<pre><code>import angr\n\nproj = angr.Project('./chall')\n\n# Addresses of symbols\nmain = proj.loader.find_symbol('main').rebased_addr\ngood = proj.loader.find_symbol('GOOD').rebased_addr \nbad = proj.loader.find_symbol('BAD').rebased_addr \n\nin_array_addr = proj.loader.find_symbol('in_array').rebased_addr  \nin_array_size = 16\n\ninitial_state = proj.factory.blank_state(addr=main)\nflag = [None] * in_array_size\n\nfor i in range(in_array_size):\n    # Each char of the array is a 8 bit BitVector\n    ch = initial_state.solver.BVS('ch{}'.format(i), 8)\n    flag[i] = ch\n\n    # Add constraints\n    initial_state.solver.add(ch >= 0)    \n    initial_state.solver.add(ch < 16)\n\n    # Store BV to memory\n    initial_state.memory.store(in_array_addr+i, ch)\n\n\n# Create a Simulation manager from the current state\nsm = proj.factory.simulation_manager(initial_state)\n\n# Find a path to good while avoiding bad\nsm.explore(find=good, avoid=bad)\n\nprint(\"No. of solutions found:\", len(sm.found))\n\nif len(sm.found) > 0:        \n    # Considering the first goal state\n    goal_state = sm.found[0]       \n\n    print([goal_state.solver.eval(d) for d in flag])\n</code></pre>\nOutput\n<pre><code>user@ec03a79cf15f$ python solver.py\nWARNING | 2019-07-06 10:29:07,128 | angr.state_plugins.symbolic_memory | The program is accessing memory or registers with an unspecified value. This could indicate unwanted behavior.\nWARNING | 2019-07-06 10:29:07,128 | angr.state_plugins.symbolic_memory | angr will cope with this by generating an unconstrained symbolic variable and continuing. You can resolve this by:\nWARNING | 2019-07-06 10:29:07,129 | angr.state_plugins.symbolic_memory | 1) setting a value to the initial state\nWARNING | 2019-07-06 10:29:07,129 | angr.state_plugins.symbolic_memory | 2) adding the state option ZERO_FILL_UNCONSTRAINED_{MEMORY,REGISTERS}, to make unknown regions hold null\nWARNING | 2019-07-06 10:29:07,129 | angr.state_plugins.symbolic_memory | 3) adding the state option SYMBOL_FILL_UNCONSTRAINED_{MEMORY_REGISTERS}, to suppress these messages.\nWARNING | 2019-07-06 10:29:07,129 | angr.state_plugins.symbolic_memory | Filling memory at 0x7fff0000 with 4 unconstrained bytes referenced from 0x8048532 (main+0x7 in chall (0x8048532))\nWARNING | 2019-07-06 10:29:07,131 | angr.state_plugins.symbolic_memory | Filling register ebp with 4 unconstrained bytes referenced from 0x8048535 (main+0xa in chall (0x8048535))\nWARNING | 2019-07-06 10:29:07,380 | angr.state_plugins.symbolic_memory | Filling register ebx with 4 unconstrained bytes referenced from 0x8048567 (M+0x3 in chall (0x8048567))\nNo. of solutions found: 1\n[9, 8, 7, 2, 11, 15, 13, 10, 6, 5, 14, 4, 3, 0, 12, 1]\n</code></pre>\nUsing the following as the contents of <pre><code>in_array</code></pre> solves the challenge.\n<pre><code>[9, 8, 7, 2, 11, 15, 13, 10, 6, 5, 14, 4, 3, 0, 12, 1]\n</code></pre>\n",
            "votes": "4",
            "user": "0xec",
            "time": "Jul 6, 2019 at 10:33",
            "is_accepted": true,
            "comments": [
                {
                    "user": "0xec",
                    "text": "<span class=\"comment-copy\">@Iddo I see. But this is the solution angr came up with. Maybe some other changes need to be made. Sharing the original challenge binary would be great.</span>",
                    "time": null
                },
                {
                    "user": "0xec",
                    "text": "<span class=\"comment-copy\">@Iddo Check updated answer</span>",
                    "time": null
                },
                {
                    "user": "James W.",
                    "text": "<span class=\"comment-copy\">The 17 was on purpose &gt;&lt; honeyput, thanks mate, u deserve more than the +50</span>",
                    "time": null
                },
                {
                    "user": "0xec",
                    "text": "<span class=\"comment-copy\">@Iddo Thanks. Angr would still find a solution with <code>&lt; 17</code> . <code>10, 8, 7, 2, 12, 16, 14, 11, 6, 5, 15, 4, 3, 0, 13, 1</code>  but this is not correct as far as the original challenge is concerned.</span>",
                    "time": null
                },
                {
                    "user": "James W.",
                    "text": "<span class=\"comment-copy\">I have another related question hopefully you can help <a href=\"https://reverseengineering.stackexchange.com/questions/25571/angr-arm64-call-state-not-resolved\" title=\"angr arm64 call state not resolved\">reverseengineering.stackexchange.com/questions/25571/…</a></span>",
                    "time": null
                }
            ]
        }
    ]
}