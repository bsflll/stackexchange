{
    "title": "WHY and WHEN do we need SEH for buffer overflowing",
    "link": "https://reverseengineering.stackexchange.com/questions/19372/why-and-when-do-we-need-seh-for-buffer-overflowing",
    "content": "In our course in university, we recently moved on from standard buffer-overflows to SEH based ones.\nMy exploit is already ready and working thanks to some nice tutorials, although I am still not sure I completely understand, when and why we need the SEH buffer-overflow.\nMy understanding so far is that, if there are no explicit exception handlers in the source code, every thread will get an automatic one, specific handlers will be there additionally.\nFor programs, which are vulnerable to SEH BOF a buffer-overflow will cause the e.g. Immunity debugger to pause the program at an exception. Only after the exception is passed to the program the <pre><code>EIP</code></pre> register is overwritten with the malicious buffer.\nQuestion 1:\n\nWhy does this not happen for every program then since there should be an automatic exception handler in any case?\n\nAfter passing the exception <pre><code>EIP</code></pre> and <pre><code>ESP</code></pre> are overwritten, with values from my buffer, yet other registers are zeroed out (<pre><code>EAX</code></pre>, <pre><code>EBX</code></pre>, <pre><code>ESI</code></pre> & <pre><code>EDI</code></pre> in my example). So I can control <pre><code>EIP</code></pre> and <pre><code>ESP</code></pre>, but the tutorials mention that it is useless, due to the zeroed out registers.\nHowever, they never explain why the zeroed out registers are the problem - so here is my second lack of understanding.\nQuestion 2:\n\nWhat exactly is the deal with the zeroed out registers and why would they break shellcode execution?\n\nNow we also overwrite the NSEH and SEH records and using a pattern can figure out the exact offset to overwrite those. Then comes the magic with referencing some module which has <pre><code>POP POP RET</code></pre> to get to <pre><code>ESP + 8</code></pre>.\nPlus eventually yet another jump.\nQuestion 3:\n\nWhy do I need POP POP RET and the final jump?\n\n\nI have the exploit working and can hand it in like this, yet it feels very unsatisfactory and pointless without actually understanding what is going on.\nI only started working with low level stuff recently and still have a lot to learn, so I am very thankful for every help.\n",
    "votes": "7",
    "answers": 1,
    "views": "1k",
    "tags": [
        "windows",
        "x86",
        "immunity-debugger",
        "buffer-overflow",
        "seh"
    ],
    "user": "SuperSpitter",
    "time": "Jun 17, 2020 at 9:54",
    "comments": [],
    "answers_data": [
        {
            "content": "First of all, read this:\nhttps://www.blackhat.com/presentations/bh-asia-03/bh-asia-03-litchfield.pdf\nThat's pretty much how all this started.\nA SEH buffer overflow is a specific stack overflow that targets the <pre><code>EXCEPTION_REGISTRATION_RECORD</code></pre> sitting some arbitrary distance down the stack.\n\nWhy does this not happen for every program then since there should be an automatic exception handler in any case?\n\nYes it would, as you can't really disable SEH on Windows. Provided your buffer overflow can reach the <pre><code>EXCEPTION_REGISTRATION_RECORD</code></pre> and you can trigger an exception.\n\nAfter passing the exception EIP and ESP are overwritten, with values from my buffer, yet other registers are zeroed out (EAX, EBX, ESI & EDI in my example).\n\nfrom my <pre><code>ntdll.dll</code></pre> version <pre><code>10.0.17134.254</code></pre>...\nbefore being <pre><code>XOR</code></pre>'d...\n<pre><code>EAX</code></pre> holds a pointer to the current <pre><code>EXCEPTION_REGISTRATION_RECORD</code></pre> so if you have overwritten <pre><code>EXCEPTION_REGISTRATION_RECORD->Next</code></pre> with the payload address and set the <pre><code>EXCEPTION_REGISTRATION_RECORD->Handler</code></pre> to a random instruction that peformed <pre><code>JMP/CALL [EAX]</code></pre>, that might be an attack vector.\n<pre><code>EBX</code></pre> is already set to <pre><code>0</code></pre> at the start of <pre><code>RtlDispatchException</code></pre> It previously contained the <pre><code>PEXCEPTION_RECORD</code></pre>.\n<pre><code>ESI</code></pre> is the <pre><code>PEXCEPTION_RECORD</code></pre> and <pre><code>EDI</code></pre> is the <pre><code>PCONTEXT</code></pre>.\n\nWhat exactly is the deal with the zeroed out registers and why would they break shellcode execution?\n\nThey don't necessarily. Before we get to execution of the handler we have to go through <pre><code>ntdll!KiDispatchUserException</code></pre> -> <pre><code>ntdll!RtlDispatchException</code></pre> which end up overwriting all the registers anyway. \nIt's why the kernel saves them in the <pre><code>CONTEXT</code></pre> struct before returning to usermode.\nThis exploit isn't a simple <pre><code>EIP</code></pre> hijack. There are big changes to the stack and registers before we get execution after the exception.\n\nWhy do I need POP POP RET and the final jump?\n\nDo you mean why not just set the <pre><code>EXCEPTION_REGISTRATION_RECORD->Handler</code></pre> directly to the shellcode?\nThis is a ROP gadget to redirect execution to the value of <pre><code>ESP+8</code></pre>. If you get this far in the exploit then the data at <pre><code>ESP+8</code></pre> is controllable by you, but you might not necessarily know where that is in advance.\nSecondly, there are many sanity and security checks between the exception and the handler execution. If any of these fail the program is terminated before the handler is run. What these consist of depend on the version of Windows you are targeting. SafeSEH is one of them. Very simply it validates the handler address against a whitelist, but it can't validate for handlers in modules that were not compiled with SafeSEH. So if the POP/POP/RET comes from a module loaded and compiled without SafeSEH, ntdll cannot determine if it's malicious. \n\nPlus eventually yet another jump.\n\nThis is the best part!\nBecause <pre><code>ESP+8</code></pre> is where we will be landing, we can put the shellcode here. Except it's the <pre><code>EXCEPTION_REGISTRATION_RECORD</code></pre> that we need to be intact so <pre><code>EXCEPTION_REGISTRATION_RECORD->Handler</code></pre> makes the first part of the exploit work.\nLuckily, <pre><code>EXCEPTION_REGISTRATION_RECORD->Prev</code></pre> (which you have as <pre><code>NSEH</code></pre>) represents the first 4 bytes to the shellcode where POP/POP/RET will return.\nA short jump in x86 can be encoded with just 2 bytes. So this final jump skips 6 byte over the <pre><code>NSEH</code></pre> so it can remain valid for the exploit to work.\nThis blog :\nhttps://dkalemis.wordpress.com/2010/10/27/the-need-for-a-pop-pop-ret-instruction-sequence/\nExplains the final part far better than I can.\n",
            "votes": "6",
            "user": "Abigail",
            "time": "Sep 18, 2018 at 5:16",
            "is_accepted": true,
            "comments": [
                {
                    "user": "josh",
                    "text": "<span class=\"comment-copy\">It might be worth noting that this kind of stack-based exploit does no longer work in Microsoft's 64-bit world. See the article <a href=\"http://www.osronline.com/article.cfm?article=469\" rel=\"nofollow noreferrer\">osronline.com/article.cfm?article=469</a>. With 32-Bit programs (C++), MS offers the /SAFESEH linker option preventing such exploits as well (if I understood right).</span>",
                    "time": null
                }
            ]
        }
    ]
}