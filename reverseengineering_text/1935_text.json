{
    "title": "How to handle stripped binaries with GDB? No source, no symbols and GDB only shows addresses?",
    "link": "https://reverseengineering.stackexchange.com/questions/1935/how-to-handle-stripped-binaries-with-gdb-no-source-no-symbols-and-gdb-only-sho",
    "content": "I have GDB but the binary I want to reverse engineer dynamically has no symbols. That is, when I run the <pre><code>file</code></pre> utility it shows me stripped:\n<pre><code>ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, stripped\n</code></pre>\nWhat options do I have if the environment in which this runs doesn't allow a remote IDA Pro instance to connect to <pre><code>gdbserver</code></pre>? In short: the environment you have is limited in what it allows you to do, but you do have trusty old <pre><code>gdb</code></pre> and a binary to reverse engineer.\n",
    "votes": "123",
    "answers": 2,
    "views": "101k",
    "tags": [
        "tools",
        "dynamic-analysis",
        "linux",
        "debuggers",
        "gdb"
    ],
    "user": "0xC0000022L",
    "time": "May 4, 2023 at 11:56",
    "comments": [
        {
            "user": "Mellowcandle",
            "text": "unstrip is a tool that can try to restore lost symbol names of known library calls.\n",
            "time": null
        },
        {
            "user": "Jichao",
            "text": "<pre><code>b __libc_start_main</code></pre>\n",
            "time": null
        },
        {
            "user": "0xC0000022L",
            "text": "@Jichao doesn't that make the assumption that 1.) a specific implementation of a C runtime is being used and b.) that the binary isn't statically linked? Perhaps I am missing something here. But if I recall correctly no symbols are required for an ELF to find its entry point at load time.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Conventions used plus preliminary remarks\nI am trimming the output of GDB for brevity since it usually shows the copyright and other information at the beginning of every session (use <pre><code>-q</code></pre> to suppress). When I reproduce the output I'll start at the first <pre><code>(gdb)</code></pre> prompt line, or in case or auto-executed commands from the first genuine output line.\nIn order to distinguish commands entered at the GDB prompt, these will have a leading <pre><code>(gdb) </code></pre> just like in the real world. For shell command this will either be no prefix at all or <pre><code>$ </code></pre> as it appears to be the convention on most unixoid systems.\nWhen I use a particular command, such as <pre><code>vim</code></pre> as my editor, you are free to use your own favorite editor of course. Be it <pre><code>emacs</code></pre> or <pre><code>nano</code></pre>, I won't judge ya ;)\nGetting started\nThis section is about setting up your <pre><code>gdb</code></pre> environment and starting the process. I'll also include a few tidbits for the complete newcomers.\nTricks you should know\nGDB has a nice prompt at which your cursor will stop after the program breaks or whenever you are stepping or some such.\n\nPressing RETURN (aka ENTER) after you ran a GDB command will run the same command again. This is useful when you are stepping through code with <pre><code>step</code></pre> or <pre><code>next</code></pre> and simply want to continue one by one.\nCommands can be abbreviated as long as they are unambiguous. For some oft used commands a particular shorthand exists that takes precedence despite ambiguity:\n\n<pre><code>b</code></pre> for <pre><code>break</code></pre> (despite <pre><code>bt</code></pre> and <pre><code>backtrace</code></pre>)\n<pre><code>c</code></pre> or <pre><code>cont</code></pre> for <pre><code>continue</code></pre> (despite <pre><code>catch</code></pre>, <pre><code>call</code></pre> and so on)\n<pre><code>n</code></pre> for <pre><code>next</code></pre> (despite <pre><code>ni</code></pre> and <pre><code>nexti</code></pre>)\n\n\nYou can call actual library functions or even functions from within the debugged program using the command <pre><code>call</code></pre>. This means you can try out behavior or force behavior.\nYou can start GDB with <pre><code>gdbtui</code></pre> or <pre><code>gdb -tui</code></pre> to get a - supposedly more convenient - more visual text user interface. It shows the source code at the top and the <pre><code>(gdb)</code></pre> prompt below. You can also switch to this layout by executing the command <pre><code>layout src</code></pre> at the <pre><code>(gdb)</code></pre> prompt.\nGDB has a command line completion feature much like many shells, so use Tab to your advantage and also make sure to use <pre><code>help</code></pre> or <pre><code>help [keyword|command]</code></pre> whenever you are in need of help.\n<pre><code>shell</code></pre> allows you to execute commands in the shell, so that you can run commands from within your GDB session. During development an example would be <pre><code>shell make</code></pre>.\n<pre><code>print</code></pre>, <pre><code>examine</code></pre> and <pre><code>display</code></pre> know various formats (<pre><code>/FMT</code></pre>) which you can use to make the output more readable.\nWhen source-level debugging you can use C type casts to display values. Imagine a C string behind a <pre><code>void *</code></pre> (which GDB knows thanks to the symbols in such case). Simply cast to <pre><code>(char*)</code></pre> and print it: <pre><code>print (char*)variable</code></pre>.\n\nGetting the process to run\nSince we want to dynamically analyze the binary, we need to start it first.\nCommand line\nWe can do that straight from the command line by passing not only the path to the binary, but also the arguments we want to start it with. The whole process then looks like this:\n<pre><code>$ gdb --args ./exe argument1 argument2\n</code></pre>\nEasy enough. From the <pre><code>(gdb)</code></pre> prompt you can then issue the <pre><code>run</code></pre> command (shorthand <pre><code>r</code></pre>) to run <pre><code>./exe</code></pre> with the parameters given on the command line. I prefer this method, but your mileage may vary.\n\nGDB prompt\nFire up GDB and at the <pre><code>(gdb)</code></pre> prompt use the <pre><code>file</code></pre> command to load the binary and then use the <pre><code>run</code></pre> command to start it with the arguments you want to pass:\n<pre><code>$ gdb\n(gdb) file exe\n(gdb) run argument1 argument2\n</code></pre>\nan alternative to the above would be the use of <pre><code>set args</code></pre> like this:\n<pre><code>$ gdb\n(gdb) file exe\n(gdb) set args argument1 argument2\n(gdb) run\n</code></pre>\n\nYou can also see in any case which arguments <pre><code>run</code></pre> would pass to the started process by issuing a:\n<pre><code>(gdb) show args\n</code></pre>\nbtw: if you were wondering about environment variables, use GDB's built-in <pre><code>help</code></pre> command as <pre><code>help set</code></pre> and <pre><code>help show</code></pre>. Pointers: <pre><code>set environment VARNAME=VALUE</code></pre> and <pre><code>show environment [VARNAME]</code></pre> and <pre><code>unset environment VARNAME</code></pre>.\nPhew, but why does the program stop with a <pre><code>SIGSEGV</code></pre> (segment fault)?\nWell, we don't know yet, but it looks like this little beasty wants the proper treatment. Since we practice defensive computing, we don't want to run anything we don't know much about, right? So let's start over. If this would have been malware we'd have to flush the machine and reinstall or restore a snapshot if it's a VM guest.\nFirst we'll want to run the <pre><code>info</code></pre> command as follows:\n<pre><code>(gdb) info file\n</code></pre>\nObserve:\n\nThere are two important pieces of information, the most relevant for us being the line stating:\n<pre><code>Entry point: 0x400710\n</code></pre>\nalright, so we can set a break point on that one and then <pre><code>run</code></pre> the process with the arguments we fancy.\n<pre><code>.gdbinit</code></pre> for the win\nBut wait, this is getting tedious already. No easy method to automate these steps in some way? As a matter of fact there is. A file named <pre><code>.gdbinit</code></pre> can be used to issue commands to GDB upon startup. You can also pass a file with GDB commands using the <pre><code>-x</code></pre> argument on the (shell) command line. If I have a number of projects, usually they are in subfolders with a <pre><code>.gdbinit</code></pre> file each.\nSide-note: <pre><code>-nx</code></pre> prevents the <pre><code>.gdbinit</code></pre> contents from being executed upon startup.\nSo we know which arguments we want to pass and we know the address of the break point, this translates to the following <pre><code>.gdbinit</code></pre> file:\n<pre><code>file exe\nbreak *0x400710\nrun argument1 argument2\n</code></pre>\nThe output I get when I start <pre><code>gdb</code></pre> without any other arguments is:\n<pre><code>Breakpoint 1 at 0x400710\n\nBreakpoint 1, 0x0000000000400710 in ?? ()\n(gdb) \n</code></pre>\nNice! But this looks different ...\nAssembly and GDB\nSo you're used to see the next line you're going to execute and then your trusty old <pre><code>(gdb)</code></pre> prompt. But no such thing. We have no source for this binary and furthermore symbols. Doh! So we contemplate the blinking caret at the <pre><code>(gdb)</code></pre> prompt and wonder what to do. Don't fret, GDB can also handle assembly code. Only problem, it defaults to the - in my opinion - inconvenient AT&T assembly syntax. I prefer the Intel flavor and the following command tells GDB to do just that:\n<pre><code>(gdb) set disassembly-flavor intel\n</code></pre>\nShowings the assembly code\nAnd how is it going to show us the assembly code? Well, similar to the TUI mode (check the tag wiki for gdb) by using the following command:\n<pre><code>(gdb) layout asm\n</code></pre>\nand if you are so inclined, also:\n<pre><code>(gdb) layout regs\n</code></pre>\nwhich will also show you the contents of the registers in an overview.\nLet's run it again\nSo we end up with the following <pre><code>.gdbinit</code></pre> for our purposes:\n<pre><code>file exe\nbreak *0x400710\nset disassembly-flavor intel\nlayout asm\nlayout regs\nrun argument1 argument2\n</code></pre>\nAnd when we start <pre><code>gdb</code></pre> without arguments we end up with this:\n\nSweet. So we can see the disassembly while we step through the code. We could conclude this here, but of course there are more tricks to be learned, so why not go a little further.\nNOTE: the registers with white/gray background show that a value has changed. Not too meaningful when we just started the program, but mighty useful when stepping through code later on.\nbtw, if you prefer to save screen estate\n... and have it less visual, starting with GDB 7.0 you can use:\n<pre><code>set disassemble-next-line on\n</code></pre>\non GDB versions before that you can emulate the behavior by settings an automatic <pre><code>display</code></pre>:\n<pre><code>display/i $pc\n</code></pre>\nor shorter <pre><code>disp/i $pc</code></pre> where <pre><code>/i</code></pre> is the format, you can remember it best by thinking \"instruction\" and <pre><code>$pc</code></pre> being the instruction pointer, also known as program counter - hence <pre><code>pc</code></pre>.\nAlso good to know\nSometimes when stepping through assembly the <pre><code>regs</code></pre> and <pre><code>asm</code></pre> views will get borked. Simply execute the respective <pre><code>layout</code></pre> commands again to restore them to their old glory:\n<pre><code>(gdb) layout asm\n(gdb) layout regs\n</code></pre>\n\"Debugging\" at assembly level\nTurns out when you are in assembly mode some of the commands you are used to from source-level debugging simply won't work. That makes sense, because a single source line means usually a dozen instructions or more. The <pre><code>next</code></pre> and <pre><code>step</code></pre> commands, however, have instruction-level counterparts:\n\n<pre><code>nexti</code></pre> (shorthand <pre><code>ni</code></pre> ... anyone else thinking of shrubbery?)\n<pre><code>stepi</code></pre> (shorthand <pre><code>si</code></pre>)\n\nFrom our disassembly above we know:\n<pre><code>0x40072d        mov    rdi,0x40f961\n</code></pre>\nand for all practical purposes this is the <pre><code>main</code></pre> function. Of course if you were to reverse engineer malware you should be more careful, but in this case it is. So let's add a breakpoint to this address (<pre><code>0x40f961</code></pre>) instead of the entry point:\n<pre><code>break *0x40f961\n</code></pre>\nIf we <pre><code>examine</code></pre> (shorthand <pre><code>x</code></pre>) the code at which we are currently, we can see:\n<pre><code>(gdb) x/5i $pc\nx/5i $pc\n=> 0x40f961:    push   rbp\n   0x40f962:    mov    rbp,rsp\n   0x40f965:    mov    eax,0x0\n   0x40f96a:    call   0x40911f\n   0x40f96f:    pop    rbp\n</code></pre>\nOkay, the <pre><code>call</code></pre> is what we want to follow, so let's step inside of it using <pre><code>si</code></pre>. We get to see another <pre><code>call</code></pre> immediately at the instruction pointer when entering the function:\n<pre><code>(gdb) x/5i $pc\nx/5i $pc\n=> 0x40911f:    call   0x400b8c\n   0x409124:    push   rbp\n   0x409125:    mov    rbp,rsp\n   0x409128:    push   r10\n   0x40912a:    push   r11\n</code></pre>\nThe <pre><code>call</code></pre> leads us to a function which calls <pre><code>ptrace(PTRACE_TRACEME, ...)</code></pre>, now why would it do that?\n<pre><code>0x400bab        call   0x4006b8 <ptrace@plt>\n</code></pre>\nWell, it's an old anti-debugger trick which Mellowcandle has described in another Q&A here:\n\nDetecting tracing in Linux\n\nBut how do we get around it? We'd have to overwrite the <pre><code>call</code></pre> to the function which calls <pre><code>ptrace()</code></pre> with <pre><code>nop</code></pre> or something along those lines.\nThis is where GDB becomes a little unwieldy. But we can use <pre><code>set</code></pre> so do the magic for us. Let's first inspect the instruction bytes:\n<pre><code>(gdb) x/10b $pc\nx/10b $pc\n0x40911f:       0xe8    0x68    0x7a    0xff    0xff    0x55    0x48    0x89\n0x409127:       0xe5    0x41\n</code></pre>\nThe <pre><code>0xe8</code></pre> is a call instruction and we know now that it is 5 bytes long. So let's <pre><code>nop</code></pre> this out. (<pre><code>x/10b $pc</code></pre> means examine 10 bytes at program counter - default format is hex already).\nSo we do while stopped at <pre><code>0x40911f</code></pre>:\n<pre><code>(gdb) set write\n(gdb) set {unsigned int}$pc = 0x90909090\n(gdb) set {unsigned char}($pc+4) = 0x90\n(gdb) set write off\n</code></pre>\nand verify the patched location:\n<pre><code>(gdb) x/10i $pc\nx/10i $pc\n=> 0x40911f:    nop\n   0x409120:    nop\n   0x409121:    nop\n   0x409122:    nop\n   0x409123:    nop\n   0x409124:    push   rbp\n   0x409125:    mov    rbp,rsp\n   0x409128:    push   r10\n   0x40912a:    push   r11\n   0x40912c:    push   rbx\n</code></pre>\nExcellent. We can now execute it.\nAlternatives to the given method\n\nalternative for patching: <pre><code>set {unsigned int}0x40911f = 0x90909090</code></pre> followed by <pre><code>set {unsigned char}0x409123 = 0x90</code></pre>\nManipulate the program counter (instruction pointer) instead:\n\n\n<pre><code>set $pc+=5</code></pre> or the more explicit <pre><code>set $pc=$pc+5</code></pre>\n<pre><code>jump *$pc+5</code></pre>\n\nBetter ways yet to manipulate/patch the running program\nThere are alternative (and way superior) methods like this one by Tavis Ormandy. I'm reproducing the <pre><code>assemble</code></pre> macro below (in case it goes offline from the other place):\n<pre><code>define assemble\n # dont enter routine again if user hits enter\n dont-repeat\n if ($argc)\n  if (*$arg0 = *$arg0)\n    # check if we have a valid address by dereferencing it,\n    # if we havnt, this will cause the routine to exit.\n  end\n  printf \"Instructions will be written to %#x.\n\", $arg0\n else\n  printf \"Instructions will be written to stdout.\n\"\n end\n printf \"Type instructions, one per line.\n\"\n printf \"End with a line saying just \\\"end\\\".\n\"\n if ($argc)\n  # argument specified, assemble instructions into memory\n  # at address specified.\n  shell nasm -f bin -o /dev/stdout /dev/stdin \\\n    <<< \"$( echo \"BITS 32\"; while read -ep '>' r && test \"$r\" != end; \\\n                do echo -E \"$r\"; done )\" | hexdump -ve \\\n        '1/1 \"set *((unsigned char *) $arg0 + %#2_ax) = %#02x\n\"' \\\n            > ~/.gdbassemble\n  # load the file containing set instructions\n  source ~/.gdbassemble\n  # all done.\n  shell rm -f ~/.gdbassemble\n else\n  # no argument, assemble instructions to stdout\n  shell nasm -f bin -o /dev/stdout /dev/stdin \\\n    <<< \"$( echo \"BITS 32\"; while read -ep '>' r && test \"$r\" != end; \\\n                do echo -E \"$r\"; done )\" | ndisasm -i -b32 /dev/stdin\n end\nend\ndocument assemble\nAssemble instructions using nasm.\nType a line containing \"end\" to indicate the end.\nIf an address is specified, insert instructions at that address.\nIf no address is specified, assembled instructions are printed to stdout.\nUse the pseudo instruction \"org ADDR\" to set the base address.\nend\n</code></pre>\nAgain the above script snippet wasn't written by me, but by Tavis Ormandy - see the link above.\nThis concludes this little Q&A.\n",
            "votes": "197",
            "user": "0xC0000022L",
            "time": "Jan 29, 2023 at 20:50",
            "is_accepted": true,
            "comments": [
                {
                    "user": "0xea",
                    "text": "<span class=\"comment-copy\">great writeup! just one note: -q as a cmd arg gets rid of the copyright stuff</span>",
                    "time": null
                },
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">I though I knew <code>gdb</code> pretty well, but I learned a lot. Thanks !</span>",
                    "time": null
                },
                {
                    "user": "Hackndo",
                    "text": "<span class=\"comment-copy\">This <b>AWESOME</b> answer saved my life more than once. Thank you, and thanks again.</span>",
                    "time": null
                },
                {
                    "user": "RichieHH",
                    "text": "<span class=\"comment-copy\">Best gdb intro I have seen.. Excellent.</span>",
                    "time": null
                },
                {
                    "user": "ramrunner",
                    "text": "<span class=\"comment-copy\">Oh, what sad times are these when passing ruffians can say ni at will to old debuggers...(seriously great answer though! XD)</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "I used to use https://github.com/gdbinit/Gdbinit for tuning GDB but it's getting a bit dated, so I'd recommend https://github.com/hugsy/gef now as a modern alternative.\n",
            "votes": "2",
            "user": "Mega Tonnage",
            "time": "Jan 30, 2023 at 9:45",
            "is_accepted": false,
            "comments": []
        }
    ]
}