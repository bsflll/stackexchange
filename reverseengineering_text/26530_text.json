{
    "title": "What are my options to add instructions to a binary?",
    "link": "https://reverseengineering.stackexchange.com/questions/26530/what-are-my-options-to-add-instructions-to-a-binary",
    "content": "I am fairly new to reversing so apologies in advance if any terminology is incorrect.\nI am currently using ghidra on windows to look at the instructions/decompilation of a binary and I am looking to add some instructions to an existing function to change its behaviour. In this case, it is fairly trivial as I only want to add a fixed value to an existing function parameter, but I would also like some information on more advanced cases where the inserted code is slightly more complex.\nI made a small test program to test this out and I managed to add the instruction by editing the binary in a hex editor and simply shifting the function bytes and inserting my own. However I realized that this is only possible because there was a bunch of empty memory following the function, so I could just shift them all down but this isn't always the case.\n<pre><code>                         **************************************************************\n                         *                          FUNCTION                          *\n                         **************************************************************\n                         ulonglong __fastcall FUN_140011810(int param_1, int para\n         ulonglong         RAX:8          <RETURN>\n         int               ECX:4          param_1\n         int               EDX:4          param_2\n         undefined4        Stack[0x10]:4  local_res10                             XREF[3]:     140011810(W), \n                                                                                               140011835(R), \n                                                                                               140011848(R)  \n         undefined4        Stack[0x8]:4   local_res8                              XREF[2]:     140011814(W), \n                                                                                               14001184e(R)  \n         undefined1        Stack[-0x10]:1 local_10                                XREF[1]:     140011867(*)  \n         undefined4        Stack[-0xf4]:4 local_f4                                XREF[4]:     140011858(W), \n                                                                                               14001185b(R), \n                                                                                               140011861(W), \n                                                                                               140011864(R)  \n         undefined1        Stack[-0xf8]:1 local_f8                                XREF[1]:     140011821(*)  \n                         FUN_140011810                                   XREF[1]:     thunk_FUN_140011810:14001104b(T), \n                                                                                      thunk_FUN_140011810:14001104b(j)  \n   140011810 89 54 24 10     MOV        dword ptr [RSP + local_res10],param_2\n   140011814 89 4c 24 08     MOV        dword ptr [RSP + local_res8],param_1\n   140011818 55              PUSH       RBP\n   140011819 57              PUSH       RDI\n   14001181a 48 81 ec        SUB        RSP,0x108\n             08 01 00 00\n   140011821 48 8d 6c        LEA        RBP=>local_f8,[RSP + 0x20]\n             24 20\n   140011826 48 8b fc        MOV        RDI,RSP\n   140011829 b9 42 00        MOV        param_1,0x42\n             00 00\n   14001182e b8 cc cc        MOV        EAX,0xcccccccc\n             cc cc\n   140011833 f3 ab           STOSD.REP  RDI\n   140011835 8b 8c 24        MOV        param_1,dword ptr [RSP + local_res10]\n             28 01 00 00\n   14001183c 48 8d 0d        LEA        param_1,[DAT_140021008]                          = 01h\n             c5 f7 00 00\n   140011843 e8 44 f8        CALL       thunk_FUN_140011e80                              undefined thunk_FUN_140011e80(ch\n             ff ff\n   140011848 8b 85 08        MOV        EAX,dword ptr [RBP + local_res10]\n             01 00 00\n   14001184e 8b 8d 00        MOV        param_1,dword ptr [RBP + local_res8]\n             01 00 00\n   140011854 03 c8           ADD        param_1,EAX\n   140011856 8b c1           MOV        EAX,param_1\n   140011858 89 45 04        MOV        dword ptr [RBP + local_f4],EAX\n   14001185b 8b 45 04        MOV        EAX,dword ptr [RBP + local_f4]\n   14001185e 83 c0 0a        ADD        EAX,0xa\n   140011861 89 45 04        MOV        dword ptr [RBP + local_f4],EAX\n   140011864 8b 45 04        MOV        EAX,dword ptr [RBP + local_f4]\n   140011867 48 8d a5        LEA        RSP=>local_10,[RBP + 0xe8]\n             e8 00 00 00\n   14001186e 5f              POP        RDI\n   14001186f 5d              POP        RBP\n   140011870 c3              RET\n   140011871 cc              ??         CCh\n   140011872 cc              ??         CCh\n   140011873 cc              ??         CCh\n   140011874 cc              ??         CCh\n   140011875 cc              ??         CCh\n   140011876 cc              ??         CCh\n   140011877 cc              ??         CCh\n   140011878 cc              ??         CCh\n   140011879 cc              ??         CCh\n   14001187a cc              ??         CCh\n   14001187b cc              ??         CCh\n   14001187c cc              ??         CCh\n   14001187d cc              ??         CCh\n   14001187e cc              ??         CCh\n   14001187f cc              ??         CCh\n   140011880 cc              ??         CCh\n   140011881 cc              ??         CCh\n   140011882 cc              ??         CCh\n</code></pre>\nSpecifically, <pre><code>14001185e 83 c0 0a        ADD        EAX,0xa</code></pre>\nI could duplicate this instruction and change <pre><code>0xa</code></pre> to alter the output value.\nIn the more complex binary I have a larger function with similar parameters, except there is no additional memory at the end of the function so this approach to shift the remaining bytes wouldn't work as there is another function directly below. I also can't remove any of the current instructions to make space as that might break existing functionality. There is plenty of empty memory elsewhere in the binary so I thought of adding a jmp instruction to perform some instructions, and then jumping back but some of the instructions use local variables so I'm unsure if this will work.\nSo given the above example, and none of the extra memory at the end of the function, how can I insert some custom instructions?\n",
    "votes": "2",
    "answers": 3,
    "views": "4k",
    "tags": [
        "assembly"
    ],
    "user": "jjmcc",
    "time": "Dec 13, 2020 at 15:40",
    "comments": [],
    "answers_data": [
        {
            "content": "What you are really looking for is a code stud. A code cave uses unused space to sort of jump add your own code and jump back. The problem with code caves is that there is a size constraint in the PE binary that won't give you a lot of space.\nA code stud on the other hand is adding an addition .TEXT section. With this method you can avoid the pitfalls of DEP and have much more space. I have had easily up to 8 MB of space to work in.\nAll you will need to do is open the binary in the StudPE and add a section and make sure it is executable and then just jump to it ... do anything you want and jump back.\nAlso don't worry about inserting BYTES just use Ram Michael's multi assembler tool HERE in a debugger(olly or x64dbg) and just copy and paste the assembly code in.  It needs to match MASM syntax, but converting is easy.\nI have done whole projects like this so rest assured this is the easy way of doing things and save yourself hours of work.\nYou can use this tool here to create one Stud PE\n",
            "votes": "2",
            "user": "LUser",
            "time": "Feb 2, 2021 at 10:20",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "You are asking how to insert a \"code cave\" or a \"balcony\" into existing code. You could proceed like so:\n\nSelect a location in the code from where you like to branch into your code cave. You should be prepared to replace existing code with five bytes, a <pre><code>JMP</code></pre> code and four offset bytes, and possible following surplus bytes with <pre><code>NOP</code></pre> statements to avoid garbage code.\nCarefully note the assembler mnemonics as well as the code bytes of the code to be replaced by your <pre><code>JMP</code></pre>.\nCalculate the offset and patch your existing code, e.g. in a hex editor of your choice. Keep in mind that you are in the 64-bit world where RIP-relative addressing is applied (your example shows it).\nAt the location of your code cave, re-enter the instruction which you replaced by the <pre><code>JMP</code></pre>. If addresses are involved, re-calculate according to RIP-relative addressing.\nSave all registers/flags which you intend to modify, and which should have their original values back when leaving the code cave.\nEnter your new code bytes.\nRestore registers/flags as appropriate.\n<pre><code>JMP</code></pre> back to the next statement of your original code.\n\nLet me make an example how to calculate the target address of the <pre><code>JMP</code></pre> statement:\nAssume you wish to replace the\n<pre><code>LEA param_1, [DAT_140021008]\n</code></pre>\nstatement with a <pre><code>JMP to 140018000</code></pre> where you might have free space for the code cave, and the subsequent re-insertion of that <pre><code>LEA</code></pre> command at the new location.\nOf course\n\nthat address must allow code to be executed (beware of DEP \"Data Execute Prevention\").\nand you should be able to find that location in your hex editor. I do not know whether Ghidra allows patching directly in the code.\n\nCalculate the address offset: Take your destination address and get the difference to the next instruction. Your replaced code will look similar to the following one (syntax possibly not correct):\n<pre><code>14001183c E9 xx xx xx xx    JMP 140018000       ; the xx's to be calculated\n140011841 90                NOP\n140011842 90                NOP\n140011843 e8 44 f8 ff ff    CALL thunk_FUN_140011e80 ;existing code\n\nOffset: 140018000 - 140011841 = 67bf, the JMP line becoming\n14001183c E9 bf 67 00 00    JMP 140018000       \n</code></pre>\nAt address <pre><code>140018000</code></pre> you might wish to re-insert the LEA statement:\n<pre><code>140018000 48 8d 0d 79 9e ff ff      LEA param_1, [DAT_140011e80]\n140018007 Your new code\n...\nJMP back to 140011843\n</code></pre>\nThe correct offset for the LEA call has been calculated:\n<pre><code>140011e80 - 140018007 = ffff9e79 = -6187\n</code></pre>\nPerhaps the mnemonic <pre><code>param_1</code></pre> will be replaced by <pre><code>ECX</code></pre>, as that register is holding the <pre><code>param_1</code></pre>.\nAt the end of your code cave you have to calculate the <pre><code>JMP</code></pre> back to your original code in just the same way.\nYou might have noticed that due to the necessary target address re-calculations your simple \"shift down\" method also needs careful attention in the general case.\nRemark: If you look in your example code at the statement at address <pre><code>140011843</code></pre>\n<pre><code>CALL       thunk_FUN_140011e80\n</code></pre>\nyou might note the \"<pre><code>thunk_</code></pre>\" prefix. It means that the immediate address is different from <pre><code>140011e80</code></pre>. It is a \"proxy\", probably a <pre><code>JMP</code></pre> target inserted by the compiler leading to the address indicated in Ghidra's code. Ghidra calculates this for you.\nThe outlined method is to sketch the general construction of a code cave. Problems like local variables located on the stack must be considered (keeping the stack consistent), or items listed in the relocation table of the PE64 header. Care must be taken to handle those properly.\n",
            "votes": "1",
            "user": "josh",
            "time": "Feb 1, 2021 at 17:15",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "I believe, you have to change that address to apropriate \"JMP\" command, and append ADD EAX,0xa at the end of the executable file, all other commands if overwritten and also the rest desired actions as well and after finishing, jmp back to the incremented address, you will need to correct executables header file as well for modified file length. Sure, when adding your own instructions, remember to correct all changed register pointers, e.g. stack...\n",
            "votes": "0",
            "user": "Zurab",
            "time": "Dec 28, 2020 at 15:42",
            "is_accepted": false,
            "comments": []
        }
    ]
}