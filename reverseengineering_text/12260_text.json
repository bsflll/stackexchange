{
    "title": "How to log all memory accesses (read and write) including the memory content in a binary execution trace?",
    "link": "https://reverseengineering.stackexchange.com/questions/12260/how-to-log-all-memory-accesses-read-and-write-including-the-memory-content-in",
    "content": "I would like to create an execution trace of a binary. To be precise, I would like to record every executed assembly instruction, together with possible memory accesses. By memory accesses I mean reading from, or writing to, memory. For these accesses I would like to record where the instruction reads from (resp. writes to) and what value it reads (resp. what value it writes).\nIf possible, I would prefer a solution which works on Windows and Linux, as well as for different kinds of CPUs.\nThe performance does not matter for the moment, i.e. a debugger script would be okay. \nI tried several things, but I did not manage to get what I wanted:\n\nIDA: I could not find a straight forward way of getting the memory accesses with content (there are obscure functions such as <pre><code>idc.GetTevRegMem</code></pre> (see here) but to reach my goal things get very very complex.\nValgrind: <pre><code>valgrind --tool=lackey --trace-mem=yes</code></pre> gave me the accesses, but not the content, see here for lackey\nGDB: Using watchpoints is not an option as their number is restricted\n\nFor the moment, PANDA seems to be the most promising choice (see comment of PANDA author here). Yet, I don't know PANDA and thus cannot tell how complex the creation of a suitable PANDA plugin will get.\nAs my goal seems not very exotic to me, I figured there must exist something already or there must be an easy way. For example, some lines of debugger script code, a PIN tool (yet Intel only), or a qemu argument or the like. Does it?\n",
    "votes": "6",
    "answers": 1,
    "views": "5k",
    "tags": [
        "ida",
        "debugging",
        "qemu",
        "tracing"
    ],
    "user": "langlauf.io",
    "time": "Apr 13, 2017 at 12:49",
    "comments": [
        {
            "user": "Neitsa",
            "text": "I'd definitely go with a DBI framework. PIN can do that easily (although you'll be restricted to x86 / x64). Check the pinatrace example source. Use <pre><code>PIN_SafeCopy</code></pre> (not used in the example) to access the memory, and you're done.\n",
            "time": null
        },
        {
            "user": "Ta Thanh Dinh",
            "text": "I think of DBI also, but PIN (and DynamoRIO) cannot trace kernel space accesses.\n",
            "time": null
        },
        {
            "user": "0xec",
            "text": "You can consult this (PDF) thesis report, specifically chapter 3\n",
            "time": null
        },
        {
            "user": "langlauf.io",
            "text": "@ExtremeCoders thanks, they are also using PANDA. Really seems like the way to go if one wants everything: different CPUs, kernel+userspace, different OSes.\n",
            "time": null
        },
        {
            "user": "Guntram Blohm",
            "text": "As valgrind is open source, i'd guess it can't be too hard to add memory content to the --trace-mem=yes output.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "I know that this question was asked some time ago, but here comes the solution working on Windows. \nNote: See the last section of this answer to get the solution for other systems and architectures.\nx86 32 bit files\nOllyDbg2 is the tool that can be used for logging every single assembly instruction along with memory reads and writes. A short guide how to log it is presented below:\n\nRun OllyDbg.\nSelect <pre><code>Options</code></pre>-><pre><code>Options...</code></pre> (or use <pre><code>Alt</code></pre>+<pre><code>o</code></pre> shortcut). The options window will show up.\nSearch for <pre><code>Run trace</code></pre> section and select options specified on image below:\n\n\nOf course, if you don't want Olly to log all string instructions or code in system DLLs, you may just select two relevant boxes. Additionally, you may choose smaller trace buffer size if you want to dump the log to a file.\n\nNow, open your target application, but don't start it yet.\nSelect <pre><code>View</code></pre>-><pre><code>Run trace</code></pre>.\nRight click on a window that appeared and select memory and register options you want to have in the trace.\nRight click on that window once again and select <pre><code>Log to file...</code></pre> option and choose the file where you want to write entire run trace.\nPress <pre><code>Ctrl</code></pre>+<pre><code>F11</code></pre> to start tracing.\nWhen you want it to stop, click pause button (or <pre><code>F12</code></pre>) to pause execution.\nYou will see the instructions logged in <pre><code>Run trace</code></pre> window.\nRight click on <pre><code>Run trace</code></pre> window and select <pre><code>Stop logging</code></pre> option. This will close and save the trace file.\n\nThat's it! You may now open and analyse the file (it will be probably huge nonetheless).\nThe small excerpt of such a file is presented below (it shows only modified registers and doesn't enter system DLLs):\n<pre><code>main  <ModuleEntryPoint>          JMP SHORT 00401012\nmain  00401012                    MOV EAX,[DWORD DS:4F61EF]               [004F61EF]=0                EAX=00000000\nmain  00401017                    SHL EAX,2\nmain  0040101A                    MOV [DWORD DS:4F61F3],EAX               [004F61F3]=0\nmain  0040101F                    PUSH EDX                                [0019FF80]=0                ESP=0019FF80\nmain  00401020                    PUSH 0                                  [0019FF7C]=0                ESP=0019FF7C\nmain  00401022                    CALL <JMP.&KERNEL32.GetModuleHandleA>                               EAX=00400000, ECX=DC5CD787, ESP=0019FF80\nmain  00401027                    MOV EDX,EAX                                                         EDX=00400000\nmain  00401029                    CALL 004E7210                                                       ESP=0019FF7C\nmain  004E7210                    MOV EAX,EDX\nmain  004E7212                    CMP [BYTE DS:4F61E0],0                  [004F61E0]=00\nmain  004E7219                    JNE SHORT 004E7240\nmain  004E721B                    CMP [BYTE DS:4F61E1],0                  [004F61E1]=00\nmain  004E7222                    JE SHORT 004E7238\nmain  004E7238                    MOV ECX,[DWORD DS:57D7D4]               [0057D7D4]=ollydbg.0061B108 ECX=0061B108\nmain  004E723E                    MOV [DWORD DS:ECX],EAX                  [0061B108]=0\nmain  004E7240                    MOV EAX,[DWORD DS:57D7D8]               [0057D7D8]=ollydbg.0061B131 EAX=0061B131\nmain  004E7245                    MOV [BYTE DS:EAX],1                     [0061B131]=00\n</code></pre>\nDOS executables\nDOSBox Debugger will log everything you want when you are analysing DOS executable.\n\nDownload it from here for example.\nStart application by dragging and dropping the executable on DOSBox Debugger icon.\nPress <pre><code>Alt</code></pre>+<pre><code>Pause</code></pre> at the moment you want to start logging the execution trace - application will freeze.\nSwitch to debugger window. You will see something like this:\n\nType <pre><code>logl n</code></pre>, where <pre><code>n</code></pre> is a (hexadecimal) number of instructions to log; for example: <pre><code>logl ffff</code></pre>.\nThe log file has been created and should be located in the same directory as DOSBox debugger - it will have <pre><code>LOGCPU.txt</code></pre> name.\n\nSeveral lines of resulting file are given below:\n<pre><code>01A2:00004654  mov  ax,si                                              8B C6                 EAX:0000002A EBX:0000002A ECX:00000A00 EDX:00000000 ESI:00000004 EDI:00000004 EBP:0000FFE2 ESP:0000FFDE DS:26EF ES:A000 FS:0000 GS:0000 SS:26EF CF:1 ZF:0 SF:1 OF:0 AF:1 PF:1 IF:1 TF:0 VM:0 FLG:00007293 CR0:00000000\n01A2:00004656  mov  dx,000E                                            BA 0E 00              EAX:00000004 EBX:0000002A ECX:00000A00 EDX:00000000 ESI:00000004 EDI:00000004 EBP:0000FFE2 ESP:0000FFDE DS:26EF ES:A000 FS:0000 GS:0000 SS:26EF CF:1 ZF:0 SF:1 OF:0 AF:1 PF:1 IF:1 TF:0 VM:0 FLG:00007293 CR0:00000000\n01A2:00004659  imul dx                                                 F7 EA                 EAX:00000004 EBX:0000002A ECX:00000A00 EDX:0000000E ESI:00000004 EDI:00000004 EBP:0000FFE2 ESP:0000FFDE DS:26EF ES:A000 FS:0000 GS:0000 SS:26EF CF:1 ZF:0 SF:1 OF:0 AF:1 PF:1 IF:1 TF:0 VM:0 FLG:00007293 CR0:00000000\n01A2:0000465B  mov  bx,ax                                              8B D8                 EAX:00000038 EBX:0000002A ECX:00000A00 EDX:00000000 ESI:00000004 EDI:00000004 EBP:0000FFE2 ESP:0000FFDE DS:26EF ES:A000 FS:0000 GS:0000 SS:26EF CF:0 ZF:0 SF:1 OF:0 AF:1 PF:1 IF:1 TF:0 VM:0 FLG:00007296 CR0:00000000\n01A2:0000465D  cmp  word [bx+56F6],0001        ds:[572E]=0000          83 BF F6 56 01        EAX:00000038 EBX:00000038 ECX:00000A00 EDX:00000000 ESI:00000004 EDI:00000004 EBP:0000FFE2 ESP:0000FFDE DS:26EF ES:A000 FS:0000 GS:0000 SS:26EF CF:0 ZF:0 SF:1 OF:0 AF:1 PF:1 IF:1 TF:0 VM:0 FLG:00007296 CR0:00000000\n01A2:00004662  jne  00004678 ($+14)            (down)                  75 14                 EAX:00000038 EBX:00000038 ECX:00000A00 EDX:00000000 ESI:00000004 EDI:00000004 EBP:0000FFE2 ESP:0000FFDE DS:26EF ES:A000 FS:0000 GS:0000 SS:26EF CF:1 ZF:0 SF:1 OF:0 AF:1 PF:1 IF:1 TF:0 VM:0 FLG:00007296 CR0:00000000\n01A2:00004678  inc  si                                                 46                    EAX:00000038 EBX:00000038 ECX:00000A00 EDX:00000000 ESI:00000004 EDI:00000004 EBP:0000FFE2 ESP:0000FFDE DS:26EF ES:A000 FS:0000 GS:0000 SS:26EF CF:1 ZF:0 SF:1 OF:0 AF:1 PF:1 IF:1 TF:0 VM:0 FLG:00007296 CR0:00000000\n</code></pre>\nEvery or almost every architectures and systems\nradare2 is the tool that may be used for your purpose regardless the system and architecture (complete list of them is given here).\n\nRun <pre><code>r2 -c aei -d programToDebug</code></pre>.\nPut a breakpoint at the address where you want to start tracing (using <pre><code>db address_in_hex</code></pre> for example).\nRun <pre><code>dc</code></pre> to continue until the breakpoint is hit.\nType <pre><code>e dbg.trace=1</code></pre> and press enter.\nRun <pre><code>des N</code></pre> to step <pre><code>N</code></pre> instructions (for example <pre><code>des 10</code></pre>).\nUse <pre><code>dtd > log1</code></pre> to print instructions traced to <pre><code>log1</code></pre> file.\nUse <pre><code>dte > log2</code></pre> to print all memory and register accesses to <pre><code>log2</code></pre> file.\nSample contents of these files are given below:\n\nInstructions:\n\nAnd some corresponding memory accesses:\n\nOf course, it will be nicer to have these outputs listed in such a way as OllyDbg does, for example, but it just requires to write a script that links these two files together and displays the information in more convenient way. Like so, for instance:\n\nPython script for creating such an output from these files is available here. Usage:\n<pre><code>./prettyTraceLog.py file1 file2\n</code></pre>\n, where <pre><code>log1</code></pre> and <pre><code>log2</code></pre> are default values. If you find any bug, or want to modify it for some other reason, feel free to do it.\nThanks @pancake for telling me how to do tracing in <pre><code>radare2</code></pre>.\n",
            "votes": "4",
            "user": "bart1e",
            "time": "Jun 13, 2019 at 13:47",
            "is_accepted": false,
            "comments": []
        }
    ]
}