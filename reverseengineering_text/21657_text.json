{
    "title": "Find Reference To Resource String In Windows 3.1 16-bit DLL with IDA Pro",
    "link": "https://reverseengineering.stackexchange.com/questions/21657/find-reference-to-resource-string-in-windows-3-1-16-bit-dll-with-ida-pro",
    "content": "Experimenting Visual Basic 4 in DosBox + Windows 3.1 running on Windows 10. While I have installed SHARE.exe from MS-DOS 6.22 and it seems to run OK, it still fails to detect it.\nThe error I get is : \"SHARE.exe must be installed in order to run Visual Basic\"\nI wanted to work out how the SHARE.exe detection works. I installed the Windows 3.1 SDK and tried to debug with CodeView. However I can't figure out how to set a breakpoint on MESSAGEBOX, and I can't use the keyboard shortcut to \"halt\" the system and break into CodeView as it seems to be passed to Windows host instead of Dosbox.\nAn analysis of VBIDE.dll I can find the error message:\n<pre><code>res098:0000 ; Resource, type (8006): String table\nres098:0000 ; File offset      : 26CB0h  Length: 0100h\nres098:0000 ; Attributes (1C30): Movable Pure\nres098:0000 ; Resource ID      : 3143\nres098:0000 ; ===========================================================================\nres098:0000\nres098:0000 ; Segment type: Regular\nres098:0000 res098          segment para public 'RESOURCE' use16\nres098:0000                 assume cs:res098\nres098:0000                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\nres098:0000 a8shareExeMustB db '8SHARE.EXE must be installed in order to run Visual Basic',0\nres098:003A aRecordsourcePr db '>RecordSource property of the associated data control is empty.MV'\nres098:003A                 db 'isual Basic was not able to start up due to an invalid system con'\n</code></pre>\nThe VBIDE.dll is referenced in VB.exe this way:\n<pre><code>cseg15:2EBF                 mov     es, [bp+var_4+2]\ncseg15:2EC2                 mov     byte ptr es:[si+1], 0\ncseg15:2EC7                 lea     ax, [bp+var_17A]\ncseg15:2ECB                 push    ss\ncseg15:2ECC                 push    ax              ; LPCSTR\ncseg15:2ECD                 push    ds\ncseg15:2ECE                 push    offset aVbideDll ; \"VBIDE.DLL\"\ncseg15:2ED1                 call    sub_37E70\ncseg15:2ED6                 mov     word_10C9DC, ax\ncseg15:2ED9                 or      ax, ax\ncseg15:2EDB                 jnz     short loc_389CC\ncseg15:2EDD                 push    ds\ncseg15:2EDE                 push    offset aVbideDll_0 ; \"VBIDE.DLL\"\ncseg15:2EE1                 push    ds\ncseg15:2EE2                 push    offset aTheLanguageDll ; \"The language DLL '%s' could not be foun\"...\ncseg15:2EE5                 lea     ax, [bp+var_27A]\n</code></pre>\nI suspect this word_10C9DC location is important, and it's referenced when calling LOADSTRING (Some examples there are many more)\n<pre><code>cseg09:269A                 enter   50h, 0\ncseg09:269E                 push    word_10C9DC     ; HINSTANCE\ncseg09:26A2                 push    7D0h            ; UINT\ncseg09:26A5                 lea     ax, [bp+var_28]\ncseg09:26A8                 push    ss\ncseg09:26A9                 push    ax              ; LPSTR\ncseg09:26AA                 push    28h ; '('       ; int\ncseg09:26AC                 call    LOADSTRING\ncseg09:26B1                 push    word_10C9DC     ; HINSTANCE\ncseg09:26B5                 push    [bp+arg_2]      ; UINT\ncseg09:26B8                 lea     ax, [bp+var_50]\ncseg09:26BB                 push    ss\ncseg09:26BC                 push    ax              ; LPSTR\ncseg09:26BD                 push    28h ; '('       ; int\ncseg09:26BF                 call    LOADSTRING\ncseg09:26C4                 lea     ax, [bp+var_28]\ncseg09:26C7                 push    ss\ncseg09:26C8                 push    ax              ; LPCSTR\ncseg09:26C9                 lea     ax, [bp+var_50]\ncseg09:26CC                 push    ss\ncseg09:26CD                 push    ax              ; LPCSTR\ncseg09:26CE                 push    [bp+arg_0]      ; int\ncseg09:26D1                 push    seg cseg04\ncseg09:26D4                 push    offset aVbIni   ; \"VB.INI\"\ncseg09:26D7                 call    GETPRIVATEPROFILEINT\ncseg09:26DC                 leave\n</code></pre>\nThere is a few MESSAGEBOX references:\nMessageBox #1\n<pre><code>cseg05:0EC8                 push    0               ; HWND\ncseg05:0ECA                 les     bx, dword_10C1F8\ncseg05:0ECE                 add     bx, es:[bx+9Ah]\ncseg05:0ED3                 push    es\ncseg05:0ED4                 push    bx              ; LPCSTR\ncseg05:0ED5                 push    0\ncseg05:0ED7                 push    0               ; LPCSTR\ncseg05:0ED9                 push    10h             ; UINT\ncseg05:0EDB                 call    MESSAGEBOX\n</code></pre>\nMessageBox #2\n<pre><code>cseg15:2FE2                 push    0               ; HWND\ncseg15:2FE4                 les     bx, dword_10C1F8\ncseg15:2FE8                 add     bx, es:[bx+9Eh]\ncseg15:2FED                 push    es\ncseg15:2FEE                 push    bx              ; LPCSTR\ncseg15:2FEF                 push    seg cseg02\ncseg15:2FF2                 push    offset byte_9EC8 ; LPCSTR\ncseg15:2FF5                 push    1010h           ; UINT\ncseg15:2FF8                 call    MESSAGEBOX\n</code></pre>\nMessageBox #4 & 5\n<pre><code>cseg47:297E                 push    bp\ncseg47:297F                 mov     bp, sp\ncseg47:2981                 push    di\ncseg47:2982                 push    si\ncseg47:2983                 mov     di, [bp+6]\ncseg47:2986                 mov     es, word ptr [bp+8]\ncseg47:2989                 push    word ptr es:[di]\ncseg47:298C                 push    word ptr es:[di+4]\ncseg47:2990                 push    word ptr es:[di+2]\ncseg47:2994                 push    word ptr es:[di+8]\ncseg47:2998                 push    word ptr es:[di+6]\ncseg47:299C                 push    word ptr es:[di+0Ah]\ncseg47:29A0                 call    MESSAGEBOX\ncseg47:29A5                 mov     si, ax\ncseg47:29A7                 or      si, ax\ncseg47:29A9                 jnz     short loc_B517F\ncseg47:29AB                 mov     es, word ptr [bp+8]\ncseg47:29AE                 and     word ptr es:[di+0Ah], 0CF0Fh\ncseg47:29B4                 push    word ptr es:[di]\ncseg47:29B7                 push    word ptr es:[di+4]\ncseg47:29BB                 push    word ptr es:[di+2]\ncseg47:29BF                 push    word ptr es:[di+8]\ncseg47:29C3                 push    word ptr es:[di+6]\ncseg47:29C7                 or      word ptr es:[di+0Ah], 1010h\ncseg47:29CD                 push    word ptr es:[di+0Ah]\ncseg47:29D1                 call    MESSAGEBOX\n</code></pre>\nI couldn't work out which messagebox was displaying the message, so I replaced them all with int 3, this allowed me to break into the CodeView debugger. From this I worked out relevant MESSAGEBOX code displaying error was:\n<pre><code>cseg47:297E                 push    bp\ncseg47:297F                 mov     bp, sp\ncseg47:2981                 push    di\ncseg47:2982                 push    si\ncseg47:2983                 mov     di, [bp+6]\ncseg47:2986                 mov     es, word ptr [bp+8]\ncseg47:2989                 push    word ptr es:[di]\ncseg47:298C                 push    word ptr es:[di+4]\ncseg47:2990                 push    word ptr es:[di+2]\ncseg47:2994                 push    word ptr es:[di+8]\ncseg47:2998                 push    word ptr es:[di+6]\ncseg47:299C                 push    word ptr es:[di+0Ah]\ncseg47:29A0                 call    MESSAGEBOX\n</code></pre>\nHowever there was no xref to this section of code, the only reference I could find to this location was these push statements:\n<pre><code>loc_B51AB:\nmov     ax, [bp+arg_6]\nmov     dx, [bp+arg_8]\nmov     [bp+var_A], ax\nmov     [bp+var_8], dx\nmov     ax, [bp+arg_2]\nmov     dx, [bp+arg_4]\nmov     [bp+var_6], ax\nmov     [bp+var_4], dx\nmov     ax, [bp+arg_0]\nmov     [bp+var_2], ax\npush    seg cseg47\npush    297Eh\nlea     ax, [bp+var_C]\npush    ss\npush    ax\npush    ss\npush    ax\ncall    sub_B4F7C\nleave\nretf    0Ch\nsub_B5188 endp\n</code></pre>\nWhat code set up the message box string here, and is there a way by knowing the details in resource DLL what assembly I should look for when then string is loaded.\n",
    "votes": "1",
    "answers": 1,
    "views": "480",
    "tags": [
        "ida",
        "windows",
        "assembly",
        "x86"
    ],
    "user": "chentiangemalc",
    "time": "Jul 13, 2019 at 5:06",
    "comments": [],
    "answers_data": [
        {
            "content": "From the code you posted, it seems that <pre><code>sub_B4F7C</code></pre> is a function registering handlers, in this case, function at <pre><code>297Eh</code></pre>. This address (function pointer) is probably being saved somewhere by <pre><code>sub_B4F7C</code></pre> and will be called when <pre><code>SHARE.EXE</code></pre> is not detected.\nThus, this handler won't be called directly; when the event occurs, the code will just check at relevant address for a function registered for that event and call it. It will use the address previously put into memory by <pre><code>sub_B4F7C</code></pre>, instead of hardcoded value.\nIn short: don't worry, this function will be called. You can verify it by putting a breakpoint at its beginning. It is also worth to mark this handler as a function (select the relevant fragment and press <pre><code>P</code></pre>). You can then right click at <pre><code>297Eh</code></pre>, select <pre><code>offset</code></pre> and select the offset of the newly created function to display.\nNote: According to documentation (for <pre><code>32</code></pre>bit, but signature seems to be the same), <pre><code>word_10C9DC</code></pre> is the identifier of module containing the strings to load.\n",
            "votes": "1",
            "user": "bart1e",
            "time": "Jul 13, 2019 at 16:37",
            "is_accepted": false,
            "comments": []
        }
    ]
}