{
    "title": "Fixing corrupt ELF header field \"e_shnum\" for use in GDB",
    "link": "https://reverseengineering.stackexchange.com/questions/12316/fixing-corrupt-elf-header-field-e-shnum-for-use-in-gdb",
    "content": "If the ELF header which usually can be read using <pre><code>readelf</code></pre> has been manually manipulated, let's say by increasing the value for the \"Size of section headers\" the binary still can be executed and works well.\nHowever, this manipulation seems to trip up reverse engineering tools like GDC and GDB gives me the error: <pre><code>not in executable format: File format not recognized</code></pre>.\nIs there a way to fix the ELF header without knowing the original value of \"Size of section headers\" in order to be able again to analyze the file using standard tools?\nDetailed info:\nGDB is failing to run the binary because it says the file is <pre><code>not in executable format : File format not recognized</code></pre> but it works outside the GDB. The same things happen with the <pre><code>libbfd</code></pre> parser, it can't parse because file format is not recognized. The fact is I only change the number of section headers.\nCode\n<pre><code>#include <stdio.h>\n\nint main()\n{\n    printf(\"Hello World!\n\");\n    return 0;\n}\n</code></pre>\nBuild by invoking <pre><code>make hello</code></pre> or on a 64-bit system <pre><code>make CFLAGS=-m32 hello</code></pre>.\nELF header before\n<pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x8048320\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          4472 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         30 <-- notice me!\n  Section header string table index: 27\n</code></pre>\nELF header after\n<pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x8048320\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          4472 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         52 <-- already changed!\n  Section header string table index: 27\n</code></pre>\nGDB will output,\n\nnot in executable format: File format not recognized\n\nBut if I run it outside of GDB,\n<pre><code>$ ./hello output:\nHello World!\n</code></pre>\nSo is there either a method to fix the value for <pre><code>e_shnum</code></pre> without knowing the correct value, or a workaround so I can debug this file in GDB?\n",
    "votes": "7",
    "answers": 2,
    "views": "14k",
    "tags": [
        "gdb",
        "elf",
        "crackme"
    ],
    "user": "Fakhri Zulkifli",
    "time": "Nov 21, 2018 at 1:01",
    "comments": [],
    "answers_data": [
        {
            "content": "In this particular case, repairing the header can be automated. Since the section header string table is present, the original value of <pre><code>e_shnum</code></pre> can be found by counting the number of strings in the table.\nOriginal:\n<pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x3e0\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          6056 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         29  <-----------------\n  Section header string table index: 28\n</code></pre>\nCorrupted:\n<pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x3e0\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          6056 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         52  <------------------\n  Section header string table index: 28\nreadelf: Error: Reading 2080 bytes extends past end of file for section headers\nreadelf: Error: Reading 7216 bytes extends past end of file for dynamic string table\n</code></pre>\nReading the section header string table:\n\n<pre><code>#!/usr/bin/python3\n\nfrom elftools.elf.elffile import ELFFile\n\nwith open('hello', 'rb') as f:\n    elffile = ELFFile(f)\n    print(\"original e_shnum:\\t\" + str(len(elffile.get_section(28).data().decode('ascii').split('\\x00')) + 1))\n</code></pre>\n\nWhen run against the binary with the corrupted header, the output is as follows:\n<pre><code>$ python3 recover_e_shnum.py \noriginal e_shnum:   29\n</code></pre>\nThis script will repair the header automatically:\n\n<pre><code>#!/usr/bin/python3\n\nfrom elftools.elf.elffile import ELFFile\nfrom struct import pack\n\nwith open('hello', 'rb+') as f:\n    elffile = ELFFile(f)\n    e_shnum = len(elffile.get_section(28).data().decode('ascii').split('\\x00')) + 1 \n    f.seek(48)\n    f.write(pack('h', e_shnum))\n</code></pre>\n",
            "votes": "3",
            "user": "julian",
            "time": "Jan 1, 2020 at 2:54",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "I recreated your binary and then used Radare to corrupt the header exactly as you did, changing the number of section headers to 52.\n<pre><code>r2 -w a.out -1c's 0; pfo elf64; .pf.elf_header.shnum=52'\n</code></pre>\nThis only generated a warning with subsequent invocations of <pre><code>readelf</code></pre>.\n<pre><code>$ readelf -h a.out \nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x1050\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          14624 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         11\n  Size of section headers:           64 (bytes)\n  Number of section headers:         52\n  Section header string table index: 28\nreadelf: Error: Reading 3328 bytes extends past end of file for section headers\n</code></pre>\nBut I got the similar error from GDB,\n\nnot in executable format: file truncated\n\nAnd, if I try to debug that file, I get\n\nNo executable file specified.\n\nI could go back to the original easily with\n<pre><code>r2 -w a.out -c's 0; pfo elf64; .pf.elf_header.shnum=52'\n</code></pre>\nHowever to answer your question about tooling,\n\nRadare works with it even if the header is set to 52. You can still debug it.\nYou can get gdb to work if the header is less than the original <pre><code>shnum</code></pre>, for instance setting it to <pre><code>1</code></pre> will only warn you,\n\nBFD: warning: /tmp/a.out has a corrupt string table index - ignoring\n\nbut you can still debug the program.\n",
            "votes": "2",
            "user": "Evan Carroll",
            "time": "Nov 20, 2018 at 22:59",
            "is_accepted": false,
            "comments": []
        }
    ]
}