{
    "title": "The structure of the Python's marshaled code object (or .pyc file)",
    "link": "https://reverseengineering.stackexchange.com/questions/21085/the-structure-of-the-pythons-marshaled-code-object-or-pyc-file",
    "content": "Help me to decipher the Python's marshaled code object. The <pre><code>.pyc</code></pre> files are almost the same: The structure of .pyc files.\nI have:\n\nThe code object compiled from the source.\nThe marshaled representation of this code object.\nThe recursive disassembly of its (code object) code section.\nAll its fields values.\n\nThe main purpose: \nI want to find out, how the different code objects stored and referenced from each other. That is, how the links to the child code objects are stored?  The module should have references to all its functions. The function should have references to all other functions, callable from it. Etc. Does Virtual Machine preserves the code object <pre><code>id</code></pre>, when storing it to the <pre><code>.pyc</code></pre>? I don't thinks so, because can't see <pre><code>id</code></pre>s in the <pre><code>.pyc</code></pre> file.\nFor example, I have such instruction in the disassembled source:\n<pre><code>LOAD_CONST        2 (<code object baz at 0x7f380995e5d0, file \"foo.py\", line 7>)\n</code></pre>\nHence:\n\nHow the Virtual Machine will found the <pre><code>baz</code></pre> code object? I can't see all this information: <pre><code>0x7f380995e5d0, file \"foo.py\", line 7</code></pre> in the marshaled string. Does the object id <pre><code>0x7f380995e5d0</code></pre> stored in the marshaled code or it is created each time the program is running? \nIf it is not stored, how the connection of objects is preserved in the marshaled code objects (<pre><code>.pyc</code></pre> files)?\n\nI think, I will investigate by the <pre><code>gdb</code></pre> further, but maybe this approach (<pre><code>.pyc</code></pre> file deciphering) also will do the job.\nCurrent result:\nI used all this information for creating the next file: the first column is the binary representation of marshaled code object, the second is the meaning of each byte sequences, which I have determined already.\n<pre><code>b'\n\\xe3                    <don't know>\n\\x00\\x00\\x00\\x00        <foo.py: co_argcount: 0>\n\\x00\\x00\\x00\\x00        <foo.py: co_kwonlyargcount: 0>\n\\x00\\x00\\x00\\x00        <foo.py: co_nlocals: 0>\n\\x03\\x00\\x00\\x00        <foo.py: co_stacksize: 3>               \n@\\x00\\x00\\x00           <foo.py: co_flags = '@' = 0x40 = 64>\ns.\\x00\\x00\\x00          <foo.py: number of bytes for module instructions = '.' = 46>\nd\\x00                   <foo.py: co_code:  0 LOAD_CONST        0 (1)\nZ\\x00                   <foo.py: co_code:  2 STORE_NAME        0 (a)\nd\\x01                   <foo.py: co_code:  4 LOAD_CONST        1 (2)\nZ\\x01                   <foo.py: co_code:  6 STORE_NAME        1 (b)\ne\\x00                   <foo.py: co_code:  8 LOAD_NAME         0 (a)\ne\\x01                   <foo.py: co_code: 10 LOAD_NAME         1 (b)\n\\x17\\x00                <foo.py: co_code: 12 BINARY_ADD\nZ\\x02                   <foo.py: co_code: 14 STORE_NAME        2 (c)\nd\\x02                   <foo.py: co_code: 16 LOAD_CONST        2 (<code object baz at 0x7f380995e5d0, file \"foo.py\", line 7>)\nd\\x03                   <foo.py: co_code: 18 LOAD_CONST        3 ('baz')\n\\x84\\x00                <foo.py: co_code: 20 MAKE_FUNCTION     0\nZ\\x03                   <foo.py: co_code: 22 STORE_NAME        3 (baz)\ne\\x03                   <foo.py: co_code: 24 LOAD_NAME         3 (baz)\ne\\x00                   <foo.py: co_code: 26 LOAD_NAME         0 (a)\ne\\x01                   <foo.py: co_code: 28 LOAD_NAME         1 (b)\n\\x83\\x02                <foo.py: co_code: 30 CALL_FUNCTION     2\nZ\\x04                   <foo.py: co_code: 32 STORE_NAME        4 (multiplication)\ne\\x04                   <foo.py: co_code: 34 LOAD_NAME         4 (multiplication)\nd\\x01                   <foo.py: co_code: 36 LOAD_CONST        1 (2)\n\\x13\\x00                <foo.py: co_code: 38 BINARY_POWER\nZ\\x05                   <foo.py: co_code: 40 STORE_NAME        5 (square)\nd\\x04                   <foo.py: co_code: 42 LOAD_CONST        4 (None)\nS\\x00                   <foo.py: co_code: 44 RETURN_VALUE\n)\\x05                   <foo.py: co_const: size>\n\\xe9\\x01\\x00\\x00\\x00    <foo.py: co_const[0]: 1>\n\\xe9\\x02\\x00\\x00\\x00    <foo.py: co_const[1]: 2>\nc                       <TYPE_CODE>\n\\x02\\x00\\x00\\x00        <baz: co_argcount: 2>\n\\x00\\x00\\x00\\x00        <baz: co_kwonlyargcount: 0>\n\\x02\\x00\\x00\\x00        <baz: co_nlocals: 2>\n\\x02\\x00\\x00\\x00        <baz: co_stacksize: 2>               \nC\\x00\\x00\\x00           <baz: co_flags = 'C' = 0x43 = 67>\ns\\x08\\x00\\x00\\x00       <baz: co_code: size = 8 bytes>\n|\\x00                   <baz: co_code: 0 LOAD_FAST                0 (x) \n|\\x01                   <baz: co_code: 2 LOAD_FAST                1 (y) \n\\x14\\x00                <baz: co_code: 4 BINARY_MULTIPLY                \nS\\x00                   <baz: co_code: 6 RETURN_VALUE                   \n)\\x01                   <baz: co_const: size>\nN                       <baz: co_const[0]: None>\n\\xa9\\x00                <don't know> \n)\\x02                   <baz: co_varnames: size>\n\\xda\\x01                <baz: number of characters of next item>\nx                       <baz: co_varnames[0]: x>\n\\xda\\x01                <baz: number of characters of next item>\ny                       <baz: co_varnames[1]: y>\nr\\x03\\x00\\x00\\x00       <baz: don't know. But the 'r' = 'TYPE_REF'>\nr\\x03\\x00\\x00\\x00       <baz: don't know. But the 'r' = 'TYPE_REF'>\n\\xfa\\x06                <baz: next item length>\nfoo.py                  <baz: co_filename>\n\\xda\\x03                <baz: number of characters of next item>\nbaz                     <baz: co_name: 'baz'>\n\\x07\\x00\\x00\\x00        <baz: co_firstlineno: 7>\ns\\x02\\x00\\x00\\x00       <baz: co_lnotab: size = 2 >\n\\x00\\x01                <baz: co_lnotab>\nr\\x07\\x00\\x00\\x00       <foo.py: co_const[3]: reference to baz>\nN                       <foo.py: co_const[4]: None>\n)\\x06                   <foo.py: co_names: size> \n\\xda\\x01                <foo.py: number of characters of next item>\na                       <foo.py: co_names[0]: a>\n\\xda\\x01                <foo.py: number of characters of next item>\nb                       <foo.py: co_names[1]: b>\n\\xda\\x01                <foo.py: number of characters of next item>\nc                       <foo.py: co_names[2]: c>\nr\\x07\\x00\\x00\\x00       <foo.py: co_names[3]: reference to baz>\nZ\\x0e                   <foo.py: number of characters of next item>\nmultiplication          <foo.py: co_names[4]: multiplication>\nZ\\x06                   <foo.py: number of characters of next item>\nsquare                  <foo.py: co_names[5]: square>\nr\\x03\\x00\\x00\\x00       <foo.py: don't know>     \nr\\x03\\x00\\x00\\x00       <foo.py: don't know>     \nr\\x03\\x00\\x00\\x00       <foo.py: don't know>     \nr\\x06\\x00\\x00\\x00       <foo.py: don't know>     \n\\xda\\x08                <foo.py: number of characters of next item>\n<module>                <foo.py: co_name>\n\\x03\\x00\\x00\\x00        <foo.py: co_firstlineno>\ns\n\\x00\\x00\\x00         <foo.py: co_lnotab: size = '\n' = 0A>\n\\x04\\x01                <foo.py: o_lnotab> \n\\x04\\x01                <foo.py: o_lnotab>\n\\x08\\x02                <foo.py: o_lnotab>\n\\x08\\x07                <foo.py: o_lnotab>\n\n\\x01'                 <foo.py: o_lnotab>\n</code></pre>\n\nCode snippets required for replication:\n1) The source code: <pre><code>foo.py</code></pre>\n<pre><code>a = 1 \nb = 2 \nc = a + b \n\ndef baz(x,y):\n    return x * y\n\nmultiplication = baz(a,b)\nsquare = multiplication ** 2\n</code></pre>\n2) The marshaled representation of <pre><code>foo.py</code></pre>.\n<pre><code>source_py = \"foo.py\"\n\nwith open(source_py) as f_source:\n    source_code = f_source.read()\n\ncode_obj_compile = compile(source_code, source_py, \"exec\")\n\ndata = marshal.dumps(code_obj_compile)\n\nprint(data)\n</code></pre>\n3) The full (recursive) disassembly of the code object.\n<pre><code>import types\n\ndis.dis(code_obj_compile)\n\nfor x in code_obj_compile.co_consts:\n    if isinstance(x, types.CodeType):\n        sub_byte_code = x\n        func_name = sub_byte_code.co_name\n        print('\nDisassembly of %s:' % func_name)\n        dis.dis(sub_byte_code)\n</code></pre>\n4) All code object's field values.\n<pre><code>def print_co_obj_fields(code_obj):\n    # Iterating through all instance attributes\n    # and calling all having the 'co_' prefix\n    for name in dir(code_obj):\n        if name.startswith('co_'):\n            co_field = getattr(code_obj, name)\n            print(f'{name:<20} = {co_field}')\n\nprint_co_obj_fields(code_obj_compile)\n</code></pre>\n",
    "votes": "3",
    "answers": 2,
    "views": "3k",
    "tags": [
        "python"
    ],
    "user": "MiniMax",
    "time": "Apr 10, 2019 at 21:17",
    "comments": [],
    "answers_data": [
        {
            "content": "The answer below is with reference to Python 2.7\n\nHow the Virtual Machine will found the baz code object? I can't see all this information: 0x7f380995e5d0, file \"foo.py\", line 7 in the marshaled string. Does the object id 0x7f380995e5d0 stored in the marshaled code or it is created each time the program is running?\n\nThe <pre><code>baz</code></pre> code object is located within the <pre><code>co_consts</code></pre> member. Going by your example.\n<pre><code>>>> import marshal\n>>> import dis\n>>> \n>>> source_py = \"foo.py\"\n>>> \n>>> with open(source_py) as f_source:\n...     source_code = f_source.read()\n>>> \n\n>>> code_obj_compile = compile(source_code, source_py, \"exec\")\n</code></pre>\nIf you disassemble, the newly generated code object you can find references to <pre><code>baz</code></pre>\n<pre><code>>>> dis.dis(code_obj_compile)\n  1           0 LOAD_CONST               0 (7)\n              3 STORE_NAME               0 (a)\n\n  2           6 LOAD_CONST               1 (5)\n              9 STORE_NAME               1 (b)\n\n  3          12 LOAD_NAME                0 (a)\n             15 LOAD_NAME                1 (b)\n             18 BINARY_ADD\n             19 STORE_NAME               2 (c)\n\n  5          22 LOAD_CONST               2 (<code object baz at 0x7f1dcdb06bb0, file \"foo.py\", line 5>)\n             25 MAKE_FUNCTION            0\n... snip...\n</code></pre>\nThe <pre><code>baz</code></pre> code object is located within the <pre><code>co_consts</code></pre> array of the parent code object as shown below.\n<pre><code>>>> code_obj_compile.co_consts[2]\n<code object baz at 0x7f1dcdb06bb0, file \"foo.py\", line 5>\n</code></pre>\nAnd you can disassemble that as well.\n<pre><code>>>> dis.dis(code_obj_compile.co_consts[2])\n  6           0 LOAD_FAST                0 (x)\n              3 LOAD_FAST                1 (y)\n              6 BINARY_MULTIPLY\n              7 RETURN_VALUE\n</code></pre>\nThe objects will be created each time the program is run. Hence the addresses will change correspondingly.\n\nIf it is not stored, how the connection of objects is preserved in the marshaled code objects (.pyc files)?\n\nJust explained. If you look at the instruction carefully you can notice the <pre><code>LOAD_CONST</code></pre> instruction takes a offset as a parameter - the operand.\n<pre><code>  5          22 LOAD_CONST               2 (<code object baz at 0x7f1dcdb06bb0, file \"foo.py\", line 5>)\n</code></pre>\nHere the offset is 2 which instructs the Python Virtual Machine to load the third (zero based) item in the <pre><code>co_consts</code></pre> array on to the evaluation stack. So the \"connection\" is preserved using the offsets into the other metadata members.\n",
            "votes": "4",
            "user": "0xec",
            "time": "Apr 9, 2019 at 11:55",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "The purpose of a code object marshaling is the storing and restoring the program to/from the file. Therefore, it should have the coding scheme for all Python's features: objects, bytecode, names, etc, otherwise it can't restore a program from the file.\nSo, it uses multiple type identifiers, which can be divided into four groups:\n\nsingle TYPE:   {the type identifier} the size is 1 byte.\n<pre><code> Example: TYPE_NONE = 'N'`, `TYPE_TRUE = 'T'.\n</code></pre>\n\nshort TYPE:    {the type identifier} + 1 byte value\n<pre><code> Example: TYPE_SHORT_ASCII_INTERNED = 'Z'.\n</code></pre>\n\nlong TYPE:     {the type identifier} + 4 bytes value\n<pre><code> Example: TYPE_STRING = 's'.\n</code></pre>\n\nobject TYPE:   {the type identifier} + the combination of all different types, including the <pre><code>object TYPE</code></pre> itself. That is, it has the recursive structure.\n<pre><code> Example: TYPE_CODE = 'c'\n</code></pre>\n\n\nAll types can be seen here: cpython/Python/marshal.c\nAlso, the code object has multiple <pre><code>int</code></pre> fields. They doesn't have identifier in the marshaled string, just the sequence of four bytes values.\n<pre><code>    int co_argcount;            /* #arguments, except *args */\n    int co_kwonlyargcount;      /* #keyword only arguments */\n    int co_nlocals;             /* #local variables */\n    int co_stacksize;           /* #entries needed for evaluation stack */\n    int co_flags;               /* CO_..., see below */\n    int co_firstlineno;         /* first source line number */\n    \n</code></pre>\nThe full code object structure is here: cpython/Include/code.h \nIt is useful to know the order, in which the code object have been dumped, because then we can calculate the each field offset in the resulting string, like - the first four byte is <pre><code>co_argcount</code></pre>, the second is <pre><code>co_kwonlyargcount</code></pre>, etc.\nThe order of code object dumping:\n<pre><code>    # PyCodeObject *co - pointer to the code object\n    # p                - pointer to the file object,\n    that accumulating marshaled code object before\n    writing to the file.\n    \n    W_TYPE(TYPE_CODE, p);\n    w_long(co->co_argcount, p);\n    w_long(co->co_kwonlyargcount, p);\n    w_long(co->co_nlocals, p);\n    w_long(co->co_stacksize, p);\n    w_long(co->co_flags, p);\n    w_object(co->co_code, p);\n    w_object(co->co_consts, p);\n    w_object(co->co_names, p);\n    w_object(co->co_varnames, p);\n    w_object(co->co_freevars, p);\n    w_object(co->co_cellvars, p);\n    w_object(co->co_filename, p);\n    w_object(co->co_name, p);\n    w_long(co->co_firstlineno, p);\n    w_object(co->co_lnotab, p);\n</code></pre>\nThe result: foo.py marshaled string fully deciphered:\n<pre><code>b'\n\\xe3                    <foo.py: '\\xe3' & 0x80 (FLAG_REF)  = 'c' (TYPE_CODE)>\n\\x00\\x00\\x00\\x00        <foo.py: co_argcount: 0>\n\\x00\\x00\\x00\\x00        <foo.py: co_kwonlyargcount: 0>\n\\x00\\x00\\x00\\x00        <foo.py: co_nlocals: 0>\n\\x03\\x00\\x00\\x00        <foo.py: co_stacksize: 3>               \n@\\x00\\x00\\x00           <foo.py: co_flags = '@' = 0x40 = 64>\ns.\\x00\\x00\\x00          <foo.py: number of bytes for module instructions = '.' = 46>\nd\\x00                   <foo.py: co_code:  0 LOAD_CONST        0 (1)\nZ\\x00                   <foo.py: co_code:  2 STORE_NAME        0 (a)\nd\\x01                   <foo.py: co_code:  4 LOAD_CONST        1 (2)\nZ\\x01                   <foo.py: co_code:  6 STORE_NAME        1 (b)\ne\\x00                   <foo.py: co_code:  8 LOAD_NAME         0 (a)\ne\\x01                   <foo.py: co_code: 10 LOAD_NAME         1 (b)\n\\x17\\x00                <foo.py: co_code: 12 BINARY_ADD\nZ\\x02                   <foo.py: co_code: 14 STORE_NAME        2 (c)\nd\\x02                   <foo.py: co_code: 16 LOAD_CONST        2 (<code object baz at 0x7f380995e5d0, file \"foo.py\", line 7>)\nd\\x03                   <foo.py: co_code: 18 LOAD_CONST        3 ('baz')\n\\x84\\x00                <foo.py: co_code: 20 MAKE_FUNCTION     0\nZ\\x03                   <foo.py: co_code: 22 STORE_NAME        3 (baz)\ne\\x03                   <foo.py: co_code: 24 LOAD_NAME         3 (baz)\ne\\x00                   <foo.py: co_code: 26 LOAD_NAME         0 (a)\ne\\x01                   <foo.py: co_code: 28 LOAD_NAME         1 (b)\n\\x83\\x02                <foo.py: co_code: 30 CALL_FUNCTION     2\nZ\\x04                   <foo.py: co_code: 32 STORE_NAME        4 (multiplication)\ne\\x04                   <foo.py: co_code: 34 LOAD_NAME         4 (multiplication)\nd\\x01                   <foo.py: co_code: 36 LOAD_CONST        1 (2)\n\\x13\\x00                <foo.py: co_code: 38 BINARY_POWER\nZ\\x05                   <foo.py: co_code: 40 STORE_NAME        5 (square)\nd\\x04                   <foo.py: co_code: 42 LOAD_CONST        4 (None)\nS\\x00                   <foo.py: co_code: 44 RETURN_VALUE\n)\\x05                   <foo.py: co_const: size>\n\\xe9\\x01\\x00\\x00\\x00    <foo.py: co_const[0]: 1; '\\xe9' & 0x80 (FLAG_REF) = 'i' (TYPE_INT)>\n\\xe9\\x02\\x00\\x00\\x00    <foo.py: co_const[1]: 2; '\\xe9' & 0x80 (FLAG_REF) = 'i' (TYPE_INT)>\nc                       <foo.py: co_const[2]: 'c' = TYPE_CODE>\n\\x02\\x00\\x00\\x00        <baz: co_argcount: 2>\n\\x00\\x00\\x00\\x00        <baz: co_kwonlyargcount: 0>\n\\x02\\x00\\x00\\x00        <baz: co_nlocals: 2>\n\\x02\\x00\\x00\\x00        <baz: co_stacksize: 2>               \nC\\x00\\x00\\x00           <baz: co_flags = 'C' = 0x43 = 67>\ns\\x08\\x00\\x00\\x00       <baz: co_code: size = 8 bytes>\n|\\x00                   <baz: co_code: 0 LOAD_FAST                0 (x) \n|\\x01                   <baz: co_code: 2 LOAD_FAST                1 (y) \n\\x14\\x00                <baz: co_code: 4 BINARY_MULTIPLY                \nS\\x00                   <baz: co_code: 6 RETURN_VALUE                   \n)\\x01                   <baz: co_const: size>\nN                       <baz: co_const[0]: None>\n\\xa9\\x00                <baz: co_names: size = 0  '\\xa9' & 0x80 (FLAG_REF)  = ')'> \n)\\x02                   <baz: co_varnames: size>\n\\xda\\x01                <baz: number of characters of next item; '\\xda' & 0x80 (FLAG_REF)  = 'Z'>\nx                       <baz: co_varnames[0]: x>\n\\xda\\x01                <baz: number of characters of next item; '\\xda' & 0x80 (FLAG_REF)  = 'Z'>\ny                       <baz: co_varnames[1]: y>\nr\\x03\\x00\\x00\\x00       <baz: co_freevars: reference to empty tuple '()'>     \nr\\x03\\x00\\x00\\x00       <baz: co_cellvars: reference to empty tuple '()'>\n\\xfa\\x06                <baz: next item length>\nfoo.py                  <baz: co_filename>\n\\xda\\x03                <baz: number of characters of next item>\nbaz                     <baz: co_name: 'baz'>\n\\x07\\x00\\x00\\x00        <baz: co_firstlineno: 7>\ns\\x02\\x00\\x00\\x00       <baz: co_lnotab: size = 2 >\n\\x00\\x01                <baz: co_lnotab>\nr\\x07\\x00\\x00\\x00       <foo.py: co_const[3]: reference to 'baz'>\nN                       <foo.py: co_const[4]: None>\n)\\x06                   <foo.py: co_names: size> \n\\xda\\x01                <foo.py: number of characters of next item>\na                       <foo.py: co_names[0]: a>\n\\xda\\x01                <foo.py: number of characters of next item>\nb                       <foo.py: co_names[1]: b>\n\\xda\\x01                <foo.py: number of characters of next item>\nc                       <foo.py: co_names[2]: c>\nr\\x07\\x00\\x00\\x00       <foo.py: co_names[3]: reference to 'baz'>\nZ\\x0e                   <foo.py: number of characters of next item>\nmultiplication          <foo.py: co_names[4]: multiplication>\nZ\\x06                   <foo.py: number of characters of next item>\nsquare                  <foo.py: co_names[5]: square>\nr\\x03\\x00\\x00\\x00       <foo.py: co_varnames: reference to empty tuple '()'>     \nr\\x03\\x00\\x00\\x00       <foo.py: co_freevars: reference to emtpy tuple '()'>     \nr\\x03\\x00\\x00\\x00       <foo.py: co_cellvars: reference to empty tuple '()'>\nr\\x06\\x00\\x00\\x00       <foo.py: co_filename: reference to 'foo.py'>     \n\\xda\\x08                <foo.py: number of characters of next item>\n<module>                <foo.py: co_name>\n\\x03\\x00\\x00\\x00        <foo.py: co_firstlineno>\ns\n\\x00\\x00\\x00         <foo.py: co_lnotab: size = '\n' = 0A>\n\\x04\\x01                <foo.py: o_lnotab> \n\\x04\\x01                <foo.py: o_lnotab>\n\\x08\\x02                <foo.py: o_lnotab>\n\\x08\\x07                <foo.py: o_lnotab>\n\n\\x01'                 <foo.py: o_lnotab>\n</code></pre>\nThe useful information:\nHow to create a code object in python?\n",
            "votes": "1",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": []
        }
    ]
}