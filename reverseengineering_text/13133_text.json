{
    "title": "What are the results of this sbb instruction?",
    "link": "https://reverseengineering.stackexchange.com/questions/13133/what-are-the-results-of-this-sbb-instruction",
    "content": "I'm doing a crackme to learn some reversing, and I stumbled upon this code generated by C++ MFC:\n<pre><code>sbb eax, eax\nsbb eax, -1\ntest eax, eax\njz exit\n</code></pre>\nBefore that code a comparison is done, such as <pre><code>cmp al, bl</code></pre> where al and bl hold some value read from the serial\nThe thing that confused me, is I figured that the cmp and two sbb instructions are equivalent to this pseudocode:\n<pre><code>cmp a,b\neax=-1 if b>a\neax=1 otherwise\n</code></pre>\nHowever this confused me because eax can never be 0, so the zero flag will always be set.  Therefore, I figure the chunk of code \n<pre><code>test eax, eax\njz exit\n</code></pre>\nis useless because it does nothing- but how can this be? I don't think their C++ compiler would generate useless code like that\nWhere am I wrong here?\n",
    "votes": "1",
    "answers": 1,
    "views": "1k",
    "tags": [
        "x86",
        "crackme"
    ],
    "user": "Jason",
    "time": "Jul 25, 2016 at 3:45",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "What is the code before first <pre><code>sbb</code></pre>?\n",
            "time": null
        },
        {
            "user": "peter ferrie",
            "text": "the zero flag will always be clear, rather than set, but you are correct that the branch will never be taken.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "are you sure it was compiler generated ?\nmay be it was hand crafted or deliberately coded like wise \nmay be it checks the sign flag further down in the jz path \nmay be red herring ? \nwell whatever it requires more info \nbased on the info provided only thing that pops up is a check for sign flag further down the path \nhere is a small compilable c code that shows what flags and results are for the operations in the query \n<pre><code>#include <stdio.h>\nint helper (unsigned char a , unsigned char b )\n{\n    unsigned char res = 0;\n    unsigned char flag = 0;\n    __asm\n    {\n        xor eax,eax\n        xor ecx,ecx\n        mov al,a        ;          = 0  1  2  3  4  5  6  7\n        mov cl,b        ;          = 4  4  4  4  4  4  4  4\n        cmp al,cl       ;cf        = 1  1  1  1  0  0  0  0\n        sbb eax,eax     ;x-x-cf    =-1 -1 -1 -1  0  0  0  0\n        sbb eax,-1      ;x-(-1)-cf =-1 -1 -1 -1  1  1  1  1\n        mov res,al      ;          = ---------\"\"-----------\n        pushfd\n        xor eax,eax\n        mov eax,dword ptr ss:[esp]\n        popfd\n        lahf\n        mov flag , al\n    }\n    bool zf = ((flag & 64)==64);\n    bool sf = ((flag & 128)==128);\n    bool cf = ((flag & 1)==1);\n    printf(\"%2x %2x %2x %2x %2x %2x\n\" ,a,b,res,zf,sf,cf);\n}\nint main (void)\n{\n    printf(\" a  b  r  z  s  c\n\");\n    for (unsigned char i = 0; i < 8 ;i++){\n        helper(i,4);\n    }\n    return 0;\n}\n</code></pre>\nresult\n<pre><code>:\\>dir /b & cl /nologo runasm.cpp & runasm.exe\nrunasm.cpp\nrunasm.cpp\n a  b  r  z  s  c\n 0  4 ff  0  1  1\n 1  4 ff  0  1  1\n 2  4 ff  0  1  1\n 3  4 ff  0  1  1\n 4  4  1  0  0  1\n 5  4  1  0  0  1\n 6  4  1  0  0  1\n 7  4  1  0  0  1\n</code></pre>\n",
            "votes": "1",
            "user": "blabb",
            "time": "Jul 25, 2016 at 10:10",
            "is_accepted": true,
            "comments": []
        }
    ]
}