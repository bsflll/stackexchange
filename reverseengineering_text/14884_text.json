{
    "title": "DLink LIF firmware: Error reading block 1191378964 from file. (Success)",
    "link": "https://reverseengineering.stackexchange.com/questions/14884/dlink-lif-firmware-error-reading-block-1191378964-from-file-success",
    "content": "I'm trying to look inside some D-link modem firmware using a LIF image. I get:\n<pre><code>v@debian:~/lifutils# src/progs/lifstat /home/v/Downloads/DSL-25\nVolume : �SI \nTracks: 0 Surfaces: 0 Blocks per Track: 0.\nWarning the medium was not initialized properly!\nDirectory start : 1191378964 (37230592/1/5) end : 1191395347 (37231104/1/4)\nError reading block 1191378964 from file. (Success)\nv@debian:~/lifutils# \n</code></pre>\nHow would you go about reversing this? The modem expects the file to be uploaded using the web interface so I assume there's some offset I need to specify? But the modem doesn't allow me to peek.\nDlink-firmware LIF-utils\n",
    "votes": "2",
    "answers": 1,
    "views": "294",
    "tags": [
        "firmware",
        "security"
    ],
    "user": "vink",
    "time": "Mar 12, 2017 at 9:05",
    "comments": [],
    "answers_data": [
        {
            "content": "There is no LIF file in the D-Link binary file containing the firmware image. <pre><code>file</code></pre> returns a false positive. Since there is no LIF file present, tools in the <pre><code>lifutils</code></pre> package will fail or produce erroneous results\nDo not trust tools implicitly. Tools can return false positives if they rely on magic numbers, particular byte sequences and the like. When analyzing new, unknown or unfamiliar files, especially files that do not conform to a known standard, verify the results of the tools using manual techniques such as analyzing a hexdump and visualization of the structure of the binary\n\nWe can claim with a high degree of confidence that a HP-UX LIF file cannot be present in a D-Link binary without even analyzing the file.\nHP and the Logical Interchange Format\nStarting with the LIF:\nFrom the <pre><code>lif</code></pre> manual page:\n\nLIF (Logical  Interchange Format) is a Hewlett-Packard standard \n  mass-storage format that can be  used for interchange of files among\n  various HP computer systems.  A LIF volume contains a header\n  (identifying it as a LIF volume) and a directory that defines the\n  contents (i.e. files) of the volume.  The size of the directory is\n  fixed when the volume is initialized (see lifinit(1)) and sets an\n  upper bound on the number of files that can be created on the volume.\n  HP-UX contains a set of utilities (referred to as lif*(1)) that can be\n  used to:\n\nInitialize a LIF volume (i.e. create a header and an empty directory),\nCopy files to and from LIF volumes,\nList the contents of LIF volumes,\nRemove LIF files,\nRename LIF files.\n\nThe lif*(1) utilities are the only utilities within HP-UX where the\n  internal  structure of  a LIF volume is known.  To the rest of HP-UX,\n  a LIF volume is simply a file containing some unspecified data.  The\n  term LIF volume should in no way be confused with the HP-UX notion of\n  a file system volume or mountable volume.\n\nMore info from an HP forum: Understanding boot programs and LIF area....\nLIF files are designed to be used on HP-UX systems.\nNow to HP-UX:\nFrom Wikipedia:\n\nHP-UX (from \"Hewlett Packard Unix\") is Hewlett Packard Enterprise's\n  proprietary implementation of the Unix operating system, based on UNIX\n  System V (initially System III) and first released in 1984. Recent\n  versions support the HP 9000 series of computer systems, based on the\n  PA-RISC processor architecture, and HP Integrity systems, based on\n  Intel's Itanium architecture.\n\nHP-UX is proprietary (the opposite of open-source) and runs on systems with a unique instruction set architecture called PA-RISC.\nArmed with this knowledge, we can conclude that unless\n\nD-Link has some kind of agreement with HP allowing D-Link to use proprietary HP hardware and software \nD-Link devices use HP processors and HP-UX\n\nLIF files actually cannot be present in D-Link firmware. \nHow to go about reversing the file\nIn statistics there is an approach called exploratory data analysis in which the data is explored using various techniques in order to gain insight about the data prior to formal analysis. A similar approach can be taken in binary analysis and reversing, in which static techniques are employed prior to dynamic techniques.\nHere is a good reference: Reverse Engineering Firmware: Linksys WAG120N\n1. <pre><code>file</code></pre> can be used, but do not expect it to be helpful\nIn general, <pre><code>file</code></pre> is basically useless when analyzing binary files that contain firmware images because these binaries often have many different files embedded within them, such as HTML documents, image files such as GIF and JPEG files, compressed file systems, bootloaders and of course the firmware itself. These do not conform to any standard and their structure and contents vary across devices and manufacturers, hence no magic bytes or standard headers or signatures. Sometimes <pre><code>file</code></pre> is worse than useless because it returns false positives.\n2. <pre><code>strings</code></pre> and <pre><code>hexdump</code></pre>\nThere may be useful strings embedded in the binary, such as pathnames to interesting files, names of functions, error messages, etc. If no human-readable ASCII sequences are produced by running <pre><code>strings</code></pre> it is a strong indicator that the binary is encoded in some way (compression, obfuscation, encryption). <pre><code>hexdump</code></pre> provides a way to quickly determine if there is a discernible header structure within the binary.\n3. Scan the binary with a firmware analysis tool like <pre><code>binwalk</code></pre>\nUsing <pre><code>binwalk</code></pre> with no arguments other than the name of the file to scan will cause <pre><code>binwalk</code></pre> to search for various signatures within the binary that indicate the beginning of compressed regions, as well as additional information such as the presence of other files. Running <pre><code>binwalk</code></pre> against the firmware image from the link in the question produces quite a bit of useful output:\n<pre><code>DECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n44468         0xADB4          ZyXEL rom-0 configuration block, name: \"dbgarea\", compressed size: 0, uncompressed size: 0, data offset from start of block: 16\n44504         0xADD8          ZyXEL rom-0 configuration block, name: \"dbgarea\", compressed size: 0, uncompressed size: 0, data offset from start of block: 16\n85043         0x14C33         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 66696 bytes\n118036        0x1CD14         Unix path: /usr/share/tabset/vt100:\\\n118804        0x1D014         ZyXEL rom-0 configuration block, name: \"spt.dat\", compressed size: 0, uncompressed size: 0, data offset from start of block: 16\n118824        0x1D028         ZyXEL rom-0 configuration block, name: \"autoexec.net\", compressed size: 25972, uncompressed size: 11886, data offset from start of block: 16\n128002        0x1F402         GIF image data, version \"89a\", 125 x 25\n136194        0x21402         GIF image data, version \"87a\", 153 x 55\n173900        0x2A74C         Copyright string: \"Copyright &copy; 2007 D-Link System, Inc.\"\n188042        0x2DE8A         Copyright string: \"Copyright &copy; 2007 D-Link System, Inc.\"\n213304        0x34138         Copyright string: \"Copyright &copy; 2007 D-Link System, Inc.\"\n350259        0x55833         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 2659840 bytes\n</code></pre>\n4. Confirm the results of the scan using additional techniques \n\nManual analysis using <pre><code>hexdump</code></pre>\n\nLike <pre><code>file</code></pre>, <pre><code>binwalk</code></pre> searches for specific sequences of bytes, which means it also can produce false positives. In the output of the scan, 2 LZMA compression signatures were found, one at offset <pre><code>0x14C33</code></pre> and another at offset <pre><code>0x55833</code></pre>. If the region immediately following the compression signature is structurally distinct from the region prior to the compression signature and looks random, it is a sign that it is not a false positive. Additional verification is required, however.\noutput of <pre><code>hexdump -C -s 0x14900</code></pre> (the compression signature is at <pre><code>0x14C33</code></pre>):\n<pre><code>00014900  74 20 20 31 20 20 20 20  20 00 43 77 6d 70 41 74  |t  1     .CwmpAt|\n00014910  74 72 32 20 20 20 20 20  20 31 00 52 65 73 65 72  |tr2      1.Reser|\n00014920  76 65 5f 33 20 20 20 20  20 20 20 31 00 52 65 73  |ve_3       1.Res|\n00014930  65 72 76 65 5f 34 09 09  09 09 31 00 53 65 72 76  |erve_4....1.Serv|\n00014940  65 72 56 36 09 09 09 09  31 00 53 65 72 76 65 72  |erV6....1.Server|\n00014950  56 36 5f 65 78 74 09 09  31 00 41 63 63 65 73 73  |V6_ext..1.Access|\n00014960  53 65 63 48 6f 73 74 56  36 09 31 00 41 63 63 65  |SecHostV6.1.Acce|\n00014970  73 73 53 65 63 48 6f 73  74 56 36 5f 65 78 74 09  |ssSecHostV6_ext.|\n00014980  31 00 52 65 73 65 72 76  65 5f 35 09 09 09 09 31  |1.Reserve_5....1|\n00014990  00 50 43 50 09 09 09 09  09 09 31 00 42 77 43 74  |.PCP......1.BwCt|\n000149a0  72 6c 52 75 6c 65 09 09  31 36 00 00 00 00 00 00  |rlRule..16......|\n000149b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00014c00  00 00 00 00 00 00 53 49  47 04 00 01 04 88 00 00  |......SIG.......|\n00014c10  41 cf e0 00 cb 32 d5 a5  48 54 50 5f 54 43 20 56  |A....2..HTP_TC V|\n00014c20  20 30 2e 30 35 00 00 00  00 00 00 00 00 00 00 00  | 0.05...........|\n00014c30  00 00 00 5d 00 00 80 00  88 04 01 00 00 00 00 00  |...]............|\n00014c40  00 1e 02 1a 10 f9 e9 ec  c2 6e a7 ff e6 17 33 0d  |.........n....3.|\n00014c50  5c ae 0c 00 3f 33 0b dd  d4 9a 4d 26 de e8 35 ed  |\\...?3....M&..5.|\n00014c60  8a dc 50 d0 60 18 b3 a3  6d 95 ff 45 c1 7f 15 94  |..P.`...m..E....|\n00014c70  d0 12 90 ae ec 09 a6 1d  75 6e 41 b3 b6 43 24 6d  |........unA..C$m|\n00014c80  55 cb bd 11 32 f9 54 f1  96 d5 9f f1 21 d1 39 b6  |U...2.T.....!.9.|\n00014c90  d3 44 2d 74 9d 5d ff fc  3c 7f 53 84 86 03 df 84  |.D-t.]..<.S.....|\n00014ca0  2c 5b 25 94 c2 60 f4 66  01 c1 62 9d 05 af 43 34  |,[%..`.f..b...C4|\n00014cb0  9e 57 6c 8b e8 41 24 80  48 c5 5a 56 27 1a 1c c3  |.Wl..A$.H.ZV'...|\n</code></pre>\nFirst, we observe that there is a series of ASCII strings followed by an empty region (many 0x00 bytes) followed by random-looking data.\nSecond, we observe that the sequence at offset <pre><code>0x14C33</code></pre> is <pre><code>5d 00 00 80 00</code></pre>. This is indeed consistent with LZMA compression.\nThird, we observe that the strings and null data region precede the LZMA compression signature and random-looking data.\nThese together are a good indication of the presence of a compressed region.\n\nConfirm the presence of compressed regions using entropy analysis\n\nCompressed data typically has much higher entropy than non-random uncompressed data. We can take advantage of this by locating compressed regions in a binary using entropy analysis. This can be done by using <pre><code>binwalk</code></pre> with the <pre><code>-E</code></pre> option like so:\n<pre><code>$ binwalk -E DSL-2520U</code></pre>\n<pre><code>DECIMAL       HEXADECIMAL     ENTROPY\n--------------------------------------------------------------------------------\n0             0x0             Falling entropy edge (0.778887)\n84992         0x14C00         Rising entropy edge (0.971648)   <----Notice\n101376        0x18C00         Falling entropy edge (0.600073)\n138240        0x21C00         Falling entropy edge (0.000000)\n350208        0x55800         Rising entropy edge (0.966418)   <----Notice\n</code></pre>\nWe observe here that the offsets at which there is a rising entropy edge are very close to the offsets at which the LZMA compression signatures were found.\nHere is the entropy plot:\n\nWe can see in the plot that there are 2 areas within the binary with entropy close to 1, consistent with compression.\n5. Visualize the binary with a visualization tool like binvis.io\nHere are some binary visualization tools to choose from: Visualizing ELF Binaries.\nI like using binvis.io because it is fast, convenient and has some useful features.\nVisualization can assist in quickly identifying interesting regions within binaries.\n<pre><code>ASCII data (blue)\n  |          |\n  v          v</code></pre>\n\n<pre><code>\n     ^                                 ^\n     |                                 |\n compressed                        compressed\n     |                                 |\n     v                                 v\n</code></pre>\n\n<pre><code>\n   ^             ^\n   |             |\n regions of 0x00 bytes</code></pre>\n6. Extract data from the binary\nWhat is in those compressed regions? We can find out by extracting them.\n<pre><code>$ binwalk -Me DSL-2520U</code></pre>\nperforms the extraction and scans each extracted block. The extracted data is in a new directory called <pre><code>_DSL-2520U.extracted</code></pre>.\n7. Analyze the extracted data\nRepeat the preceding steps for each extracted binary, but this time look for code (which will identify executable files like a kernel or bootloader), and file systems, which will contain utilities like web servers and <pre><code>.cgi</code></pre> software. \nOne way of locating code is by using the <pre><code>-A</code></pre> argument with <pre><code>binwalk</code></pre>:\n<pre><code>$ binwalk -A 14C33\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n304           0x130           MIPS instructions, function epilogue\n612           0x264           MIPS instructions, function epilogue\n676           0x2A4           MIPS instructions, function epilogue\n2576          0xA10           MIPS instructions, function epilogue\n3548          0xDDC           MIPS instructions, function epilogue\n3592          0xE08           MIPS instructions, function epilogue\n3636          0xE34           MIPS instructions, function epilogue\n3672          0xE58           MIPS instructions, function epilogue\n4252          0x109C          MIPS instructions, function epilogue\n4336          0x10F0          MIPS instructions, function epilogue\n4420          0x1144          MIPS instructions, function epilogue\n4936          0x1348          MIPS instructions, function epilogue\n<snip>\n</code></pre>\nExcellent. It looks like the binary contains MIPS assembly code. This can be disassembled with radare2 or IDA or some other tool.\nThat should be enough information to get started.\nResources\nThese don't have to do with the device/firmware asked about in the question specifically, but devttys0 is a pro and reading his posts will give you an idea of how to approach many challenges faced when reversing firmware. \nExtracting Non-Standard SquashFS Images\nReverse Engineering Firmware: Linksys WAG120N\nReverse Engineering VxWorks Firmware: WRT54Gv8\nExploiting Embedded Systems – Part 1\nfirmware.re is experimental\n",
            "votes": "6",
            "user": "Community",
            "time": "Apr 13, 2017 at 12:49",
            "is_accepted": false,
            "comments": []
        }
    ]
}