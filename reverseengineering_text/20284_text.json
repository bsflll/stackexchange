{
    "title": "Debug point not hit with radare2",
    "link": "https://reverseengineering.stackexchange.com/questions/20284/debug-point-not-hit-with-radare2",
    "content": "I am doing this reverse engenering challenge. I executed theses commands to analyse the main function :\n<pre><code>radare2.exe ch15.exe\naaa\ns main\npdf\n</code></pre>\nThis is the output of the pdf command :\n<pre><code>[0x004017b8]> pdf\n/ (fcn) main 80\n|   main (int argc, char **argv, char **envp);\n|           ; arg signed int arg_8h @ ebp+0x8\n|           ; arg char **s @ ebp+0xc\n|           ; var size_t local_4h @ esp+0x4\n|           ; CALL XREF from section..text (+0x3f4)\n|           0x004017b8      55             push ebp\n|           0x004017b9      89e5           mov ebp, esp\n|           0x004017bb      83e4f0         and esp, 0xfffffff0\n|           0x004017be      83ec10         sub esp, 0x10\n|           0x004017c1      e87a0d0000     call fcn.00402540\n|           0x004017c6      837d0801       cmp dword [arg_8h], 1       ; [0x8:4]=-1 ; 1\n|       ,=< 0x004017ca      7e28           jle 0x4017f4\n|       |   0x004017cc      8b450c         mov eax, dword [s]          ; [0xc:4]=-1 ; 12\n|       |   0x004017cf      83c004         add eax, 4\n|       |   0x004017d2      8b00           mov eax, dword [eax]\n|       |   0x004017d4      890424         mov dword [esp], eax        ; const char *s\n|       |   0x004017d7      e894100000     call sub.msvcrt.dll_strlen_870 ; size_t strlen(const char *s)\n|       |   0x004017dc      89c2           mov edx, eax\n|       |   0x004017de      8b450c         mov eax, dword [s]          ; [0xc:4]=-1 ; 12\n|       |   0x004017e1      83c004         add eax, 4\n|       |   0x004017e4      8b00           mov eax, dword [eax]\n|       |   0x004017e6      89542404       mov dword [local_4h], edx\n|       |   0x004017ea      890424         mov dword [esp], eax\n|       |   0x004017ed      e834ffffff     call sub.Gratz_man_:_726    ; sub.Usage:__s_pass_700+0x26\n|      ,==< 0x004017f2      eb0d           jmp 0x401801\n|      ||   ; CODE XREF from main (0x4017ca)\n|      |`-> 0x004017f4      8b450c         mov eax, dword [s]          ; [0xc:4]=-1 ; 12\n|      |    0x004017f7      8b00           mov eax, dword [eax]\n|      |    0x004017f9      890424         mov dword [esp], eax\n|      |    0x004017fc      e8fffeffff     call sub.Usage:__s_pass_700\n|      |    ; CODE XREF from main (0x4017f2)\n|      `--> 0x00401801      b800000000     mov eax, 0\n|           0x00401806      c9             leave\n\\           0x00401807      c3             ret\n[0x004017b8]>\n</code></pre>\nI can see that a function is called named sub.Usage:__s_pass_700, probably the password. I go to this function with this command :\n<pre><code>s sub.Usage:__s_pass_700\npdf\n</code></pre>\nThe output is :\n<pre><code>[0x00401700]> pdf\n/ (fcn) sub.Usage:__s_pass_700 184\n|   sub.Usage:__s_pass_700 (int arg_8h, unsigned int arg_ch);\n|           ; var int local_ch @ ebp-0xc\n|           ; arg int arg_8h @ ebp+0x8\n|           ; arg unsigned int arg_ch @ ebp+0xc\n|           ; var int local_4h @ esp+0x4\n|           ; CALL XREF from main (0x4017fc)\n|           0x00401700      55             push ebp\n|           0x00401701      89e5           mov ebp, esp\n|           0x00401703      83ec18         sub esp, 0x18\n|           0x00401706      b844404000     mov eax, str.Usage:__s_pass ; 0x404044 ; \"Usage: %s pass\"\n|           0x0040170b      8b5508         mov edx, dword [arg_8h]     ; [0x8:4]=-1 ; 8\n|           0x0040170e      89542404       mov dword [local_4h], edx\n|           0x00401712      890424         mov dword [esp], eax        ; const char *format\n|           0x00401715      e896110000     call sub.msvcrt.dll_printf_8b0 ; int printf(const char *format)\n|           0x0040171a      c70424000000.  mov dword [esp], 0\n|           0x00401721      e87a110000     call sub.msvcrt.dll_exit_8a0\n|           ;-- sub.Gratz_man_:_726:\n|           ; CALL XREF from main (0x4017ed)\n|           0x00401726      55             push ebp\n|           0x00401727      89e5           mov ebp, esp\n|           0x00401729      83ec28         sub esp, 0x28               ; '('\n|           0x0040172c      c745f4000000.  mov dword [local_ch], 0\n|           0x00401733      837d0c07       cmp dword [arg_ch], 7       ; [0xc:4]=-1 ; 7\n|       ,=< 0x00401737      7571           jne 0x4017aa\n|       |   0x00401739      8b4508         mov eax, dword [arg_8h]     ; [0x8:4]=-1 ; 8\n|       |   0x0040173c      0fb600         movzx eax, byte [eax]\n|       |   0x0040173f      3c53           cmp al, 0x53                ; 'S' ; 83\n|      ,==< 0x00401741      7567           jne 0x4017aa\n|      ||   0x00401743      8b4508         mov eax, dword [arg_8h]     ; [0x8:4]=-1 ; 8\n|      ||   0x00401746      83c001         add eax, 1\n|      ||   0x00401749      0fb600         movzx eax, byte [eax]\n|      ||   0x0040174c      3c50           cmp al, 0x50                ; 'P' ; 80\n|     ,===< 0x0040174e      755a           jne 0x4017aa\n|     |||   0x00401750      8b4508         mov eax, dword [arg_8h]     ; [0x8:4]=-1 ; 8\n|     |||   0x00401753      83c002         add eax, 2\n|     |||   0x00401756      0fb600         movzx eax, byte [eax]\n|     |||   0x00401759      3c61           cmp al, 0x61                ; 'a' ; 97\n|    ,====< 0x0040175b      754d           jne 0x4017aa\n|    ||||   0x0040175d      8b4508         mov eax, dword [arg_8h]     ; [0x8:4]=-1 ; 8\n|    ||||   0x00401760      83c003         add eax, 3\n|    ||||   0x00401763      0fb600         movzx eax, byte [eax]\n|    ||||   0x00401766      3c43           cmp al, 0x43                ; 'C' ; 67\n|   ,=====< 0x00401768      7540           jne 0x4017aa\n|   |||||   0x0040176a      8b4508         mov eax, dword [arg_8h]     ; [0x8:4]=-1 ; 8\n|   |||||   0x0040176d      83c004         add eax, 4\n|   |||||   0x00401770      0fb600         movzx eax, byte [eax]\n|   |||||   0x00401773      3c49           cmp al, 0x49                ; 'I' ; 73\n|  ,======< 0x00401775      7533           jne 0x4017aa\n|  ||||||   0x00401777      8b4508         mov eax, dword [arg_8h]     ; [0x8:4]=-1 ; 8\n|  ||||||   0x0040177a      83c005         add eax, 5\n|  ||||||   0x0040177d      0fb600         movzx eax, byte [eax]\n|  ||||||   0x00401780      3c6f           cmp al, 0x6f                ; 'o' ; 111\n| ,=======< 0x00401782      7526           jne 0x4017aa\n| |||||||   0x00401784      8b4508         mov eax, dword [arg_8h]     ; [0x8:4]=-1 ; 8\n| |||||||   0x00401787      83c006         add eax, 6\n| |||||||   0x0040178a      0fb600         movzx eax, byte [eax]\n| |||||||   0x0040178d      3c53           cmp al, 0x53                ; 'S' ; 83\n| ========< 0x0040178f      7519           jne 0x4017aa\n| |||||||   0x00401791      b853404000     mov eax, str.Gratz_man_:    ; 0x404053 ; \"Gratz man :)\"\n| |||||||   0x00401796      890424         mov dword [esp], eax        ; const char *format\n| |||||||   0x00401799      e812110000     call sub.msvcrt.dll_printf_8b0 ; int printf(const char *format)\n| |||||||   0x0040179e      c70424000000.  mov dword [esp], 0\n| |||||||   0x004017a5      e8f6100000     call sub.msvcrt.dll_exit_8a0\n| |||||||   ; XREFS: CODE 0x00401737  CODE 0x00401741  CODE 0x0040174e  CODE 0x0040175b  CODE 0x00401768\n| |||||||   ; XREFS: CODE 0x00401775  CODE 0x00401782  CODE 0x0040178f\n| ```````-> 0x004017aa      c70424604040.  mov dword [esp], str.Wrong_password ; [0x404060:4]=0x6e6f7257 ; \"Wrong password\" ; const char *s\n|           0x004017b1      e802110000     call sub.msvcrt.dll_puts_8b8 ; int puts(const char *s)\n|           0x004017b6      c9             leave\n\\           0x004017b7      c3             ret\n[0x00401700]>\n</code></pre>\nNow I can see that the instruction | ========< 0x0040178f      7519           jne 0x4017aa compare the password with the parameter passed as argument.\nI would like now put a breakpoint on the jne instruction but I can't because the memory is unmapped. I execute the command to execute the program :\n<pre><code>ood ABadPassword\ndb 0x0040178f\ndc\n</code></pre>\nThe result is :\n<pre><code>[0x771ece30]> dc\n(5448) loading library at 77180000 (C:\\Windows\\SysWOW64\ntdll.dll) ntdll.dll\n(5448) unloading library at 000C0000 (not cached) not cached\n(5448) unloading library at 75580000 (not cached) not cached\n(5448) unloading library at 00610000 (not cached) not cached\n(5448) loading library at 75580000 (C:\\Windows\\SysWOW64\\kernel32.dll) kernel32.dll\n(5448) loading library at 73A60000 (C:\\Windows\\SysWOW64\\KernelBase.dll) KernelBase.dll\n(5448) loading library at 74060000 (C:\\Windows\\SysWOW64\\msvcrt.dll) msvcrt.dll\n</code></pre>\nI don't understand why I don't hit the break point. Also, I am obligated to execute twice the dc command to see : wrong password.\nMy goal is to change the rip next addess.\n",
    "votes": "3",
    "answers": 1,
    "views": "209",
    "tags": [
        "binary-analysis",
        "radare2",
        "binary",
        "breakpoint"
    ],
    "user": "Anonymous",
    "time": "Jan 4, 2019 at 20:01",
    "comments": [],
    "answers_data": [
        {
            "content": "Your breakpoint doesn't work as it is put in the part of the code that is not executed with the pass your provided. I'll try not to give too much hint so that you can still solve it by yourself.\nYou wrote\n\nNow I can see that the instruction | ========< 0x0040178f 7519 jne 0x4017aa compare the password with the parameter passed as argument.\n\nThis is wrong. It doesn't not compare 'the password', it compare one of the character of the password. If you check the code there are some other instructions that are being executed and already validated your password as wrong so the line at <pre><code>0x40178f</code></pre> is not even reached with 'ABadPassword' passed as an argument. \nYou need to analyse code more carefully and see where earlier in the code the breakpoint should be put.\nAs for your second problem\n\nAlso, I am obligated to execute twice the dc command to see : wrong password.\n\nThere might be some debug event that <pre><code>radare2</code></pre> responds to with the break of your code execution, thus require you to decide what to do. If it's not exceptional then <pre><code>dc</code></pre> should get execution further.\n",
            "votes": "3",
            "user": "Paweł Łukasik",
            "time": "Jan 5, 2019 at 21:18",
            "is_accepted": true,
            "comments": []
        }
    ]
}