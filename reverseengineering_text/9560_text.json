{
    "title": "Why darwin kernel crashes on function call via lldb while debugging the process?",
    "link": "https://reverseengineering.stackexchange.com/questions/9560/why-darwin-kernel-crashes-on-function-call-via-lldb-while-debugging-the-process",
    "content": "I wanted to debug the hanging ruby process, but instead my kernel crashes each time when I'm doing the following steps:\n\nI'm re-running my ruby script (vagrant) which hangs:\n<pre><code>$ vagrant destroy -f && VAGRANT_LOG=info vagrant up\n...\nINFO ssh: Setting SSH_AUTH_SOCK remotely: /tmp/ssh-FP9viQfD9J/agent.1425\n(process hanging)\nload: 2.48  cmd: ruby 1384 waiting 2.90u 0.62s\n</code></pre>\nI'm attaching <pre><code>lldb</code></pre> into the running process (on different terminal):\n<pre><code>$ lldb -p $(pgrep -fn ruby)\n</code></pre>\n\nPopup: Developer Tools Access needs to take control of another process for debugging to continue. Type your password. Continue.\n\n<pre><code>(lldb) process attach --pid 1442\nProcess 1442 stopped\nExecutable module set to \"/opt/vagrant/bin/../embedded/bin/ruby\".\nArchitecture set to: x86_64-apple-macosx.\n\n(lldb) thread list\nProcess 1442 stopped\n* thread #1: tid = 0x2427, 0x00007fff84f3f716 libsystem_kernel.dylib`__psynch_cvwait + 10, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\n  thread #2: tid = 0x245d, 0x00007fff84f3f9aa libsystem_kernel.dylib`__select + 10\n  thread #3: tid = 0x2a8d, 0x00007fff84f4094a libsystem_kernel.dylib`poll + 10\n  thread #4: tid = 0x2a9a, 0x00007fff84f3f716 libsystem_kernel.dylib`__psynch_cvwait + 10\n</code></pre>\nI'm calling <pre><code>rb_backtrace()</code></pre> for thread #1:\n<pre><code>(lldb) call (void)rb_backtrace()\n</code></pre>\nwhich prints for me the ruby backtrace as expected (on process foreground):\n<pre><code>from /opt/vagrant/embedded/gems/gems/vagrant-1.7.2/plugins/communicators/ssh/communicator.rb:566:in `block in shell_execute'\nfrom /opt/vagrant/embedded/gems/gems/vagrant-1.7.2/plugins/communicators/ssh/communicator.rb:566:in `loop'\n</code></pre>\nSince ruby is using different threads, I wanted to do the same for thread #2 (which failed):\n<pre><code>(lldb) thread select 2\n* thread #2: tid = 0x245d, 0x00007fff84f3f9aa libsystem_kernel.dylib`__select + 10\n    frame #0: 0x00007fff84f3f9aa libsystem_kernel.dylib`__select + 10\nlibsystem_kernel.dylib`__select + 10:\n-> 0x7fff84f3f9aa:  jae    0x7fff84f3f9b4            ; __select + 20\n   0x7fff84f3f9ac:  movq   %rax, %rdi\n   0x7fff84f3f9af:  jmp    0x7fff84f3c19a            ; cerror\n   0x7fff84f3f9b4:  retq   \n\n(lldb) thread list\nProcess 1442 stopped\n  thread #1: tid = 0x2427, 0x00007fff84f3f716 libsystem_kernel.dylib`__psynch_cvwait + 10, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\n* thread #2: tid = 0x245d, 0x00007fff84f3f9aa libsystem_kernel.dylib`__select + 10\n  thread #3: tid = 0x2a8d, 0x00007fff84f4094a libsystem_kernel.dylib`poll + 10\n  thread #4: tid = 0x2a9a, 0x00007fff84f3f716 libsystem_kernel.dylib`__psynch_cvwait + 10\n\n(lldb) call (void)rb_backtrace()\n</code></pre>\n\nKernel panic screen: You need to restart your computer.\n\nAt this point the kernel crashed with the following backtrace found in log:\n<pre><code>panic(cpu 2 caller 0xffffff80022dcc1d): Kernel trap at 0xffffff80025f69e4, type 14=page fault, registers:\nFault CR2: 0x0000000001f6d695, Error code: 0x0000000000000000, Fault CPU: 0x2\nBacktrace (CPU 2), Frame : Return Address\n0xffffff81f0ca3aa0 : 0xffffff8002223139 \n0xffffff81f0ca3b20 : 0xffffff80022dcc1d \n...\nBSD process name corresponding to current thread: ruby\n\nMac OS version:\n13F1077\n\nKernel version:\nDarwin Kernel Version 13.4.0: Wed Mar 18 16:20:14 PDT 2015; root:xnu-2422.115.14~1/RELEASE_X86_64\nlast loaded kext at 244023643290: com.apple.filesystems.msdosfs 1.9 (addr 0xffffff7f8308c000, size 65536)\nloaded kexts:\nfoo.tap 1.0\nfoo.tun 1.0\norg.virtualbox.kext.VBoxNetAdp  4.3.12\norg.virtualbox.kext.VBoxNetFlt  4.3.12\norg.virtualbox.kext.VBoxUSB 4.3.12\norg.virtualbox.kext.VBoxDrv 4.3.12\ncom.apple.filesystems.msdosfs   1.9\n...\n</code></pre>\n\nThis happened already twice.\nWhat was the reason for a kernel crash? Is it a <pre><code>lldb</code></pre>/<pre><code>kernel</code></pre> bug, or expected behaviour by doing something wrong? If so, what should be the correct safer approach of calling <pre><code>rb_backtrace()</code></pre> on different threads (without crashing the kernel)?\nFor clarification, ruby script (vagrant) was run without <pre><code>sudo</code></pre>, the same as <pre><code>lldb</code></pre>.\nI'm using lldb-320.4.160.\n",
    "votes": "1",
    "answers": 0,
    "views": "591",
    "tags": [
        "debugging",
        "osx",
        "kernel-mode",
        "callstack",
        "lldb"
    ],
    "user": "kenorb",
    "time": "Aug 5, 2015 at 22:41",
    "comments": [
        {
            "user": "Div",
            "text": "If you are running <pre><code>kdumpd</code></pre> on your main machine, then you can catch the panic dumps that way if you are but you also need to set the nvram properly as well. So on the remote machine you need to have setup ahead of time in the nvram: boot-args=-v debug=0xd44 _panicd_ip=127.55.56.29 replace <pre><code>127.55.56.59</code></pre> with your IP address. See Apple document describing how to do it here. Is there a reason why you can't just run <pre><code>lldb</code></pre> directly on your debug machine? If you could you could just do a <pre><code>bt</code></pre> directly on the other thread. If\n",
            "time": null
        }
    ],
    "answers_data": []
}