{
    "title": "Ghidra SDK Register TypeFlags are not populated",
    "link": "https://reverseengineering.stackexchange.com/questions/26771/ghidra-sdk-register-typeflags-are-not-populated",
    "content": "I am using the Ghidra P-Code in a Ghidra script and I am looking for an architecture-independent way to decide if a register used in a P-Code Op is the Stack or the Base Pointer (basically making the decision without using the name of the register, since that depends on the architecture).\nSo for instance if there is this P-Code Op:\n<pre><code>INT_ADD (register, 0x20, 8) , (const, 0xffffffffffffffc8, 8)</code></pre>\nThe first parameter is in reality RSP because this operation calculates the offset of a variable on the stack. So my goal is to find an architecture-independent way to ask Ghidra whether this register is the stack or the base pointer.\nI looked at the Register class in Ghidra and it seems that Register instances should have an attribute called typeFlags, that could be used to ask what kind of register it is:\n<pre><code>public class Register implements java.io.Serializable, Comparable<Register> {\n\n    private static final List<String> EMPTY_COLLECTION = new ArrayList<>();\n\n    private final static long serialVersionUID = 1;\n    public final static int TYPE_NONE = 0; // nothing special\n    public final static int TYPE_FP = 1; // frame pointer\n    public final static int TYPE_SP = 2; // stack pointer\n    public final static int TYPE_PC = 4; // program counter\n    public final static int TYPE_CONTEXT = 8; // processor state\n    public final static int TYPE_ZERO = 16; // Register is always zero\n    public final static int TYPE_HIDDEN = 32; // Register should not be exposed to users.\n    public final static int TYPE_DOES_NOT_FOLLOW_FLOW = 64; // Register value should NOT follow disassembly flow\n\n    /** Register can be used in SIMD operations **/\n    public final static int TYPE_VECTOR = 128;\n\n    private String name;\n    private String description; // description of the register\n    private Address address; // smallest address containing bits for this register\n    private int numBytes;\n    private int leastSigBit;\n    private int bitLength;\n    private int typeFlags; // type of register\n    private boolean bigEndian;\n</code></pre>\nSo I wrote a function that converts the Varnode to a Register instance using the 'Language' of the analysed binary and checks the typeFlags:\n<pre><code>        /*\n         *  Checks if the varnode is a stack or a frame pointer, depending on the language in use\n         */\n        public Boolean isStackRegister(Varnode input) {\n            if (input.isRegister()) {\n                Register reg = language.getRegister(input.getAddress(), input.getSize());\n                printf(\"XXX %s %s\n\", language.toString(), input.toString(language));\n                int typeFlags = reg.getTypeFlags();\n                // check if the register is either a frame pointer or a stack pointer\n                if ((typeFlags & Register.TYPE_SP) != 0 || (typeFlags & Register.TYPE_FP) != 0) {\n                    return true;\n                }\n            }\n            return false;           \n        }\n</code></pre>\nI was expecting the typeFlags attribute to be correctly populated, however, in the debugger, I see that it is set to 0 even if it is the RSP:\n\nFor me, this feels like a Ghidra bug or a not implemented feature.\nAnybody know how to get the typeFlags working, or any other way to check whether a register is a Stack or Base pointer, without using its name?\n",
    "votes": "1",
    "answers": 0,
    "views": "150",
    "tags": [
        "decompilation",
        "ghidra",
        "script"
    ],
    "user": "gerion",
    "time": "Jan 14, 2021 at 10:10",
    "comments": [],
    "answers_data": []
}