{
    "title": "angr multiple reads same variable",
    "link": "https://reverseengineering.stackexchange.com/questions/19185/angr-multiple-reads-same-variable",
    "content": "I'm writing a script to solve a binary that asks for multiple strings like the following c code,\nMy problem I can't dump the 'second_pass, I just get \"first_pass\".\nprobably due of the use of the same variable to read input from. any help please\n<pre><code>#include <stdio.h>\n\nint main()\n{\n    int i, lose = 1;\n    char first[20]=\"first_pass\", input[20];\n    scanf(\"%s\", input);\n    for(i=0; i < strlen(first); i++)\n    {\n        if(first[i] != input[i])\n            lose = 0;\n    }\n\n    if(lose)\n        printf(\"gg\");\n    else\n        printf(\"fail\");\n\n\n    char second[20]=\"second_pass\";\n    scanf(\"%s\", input);\n    for(i=0; i < strlen(second); i++)\n    {\n        //printf(\"%c = %c\n\", second[i], input[i]);\n        if(second[i] != input[i])\n            lose = 0;\n    }\n\n    printf(\"\n\");\n    if(lose)\n        printf(\"gg\");\n    else\n        printf(\"fail\");\n}\n</code></pre>\nmy angr script \n<pre><code>import angr\nimport logging\n\n\n\nstart_at = 0x400550\n\nfail = (0x400681,0x400751)\nsuccess = (0x400680, 0x400740)\n\n\n\n\np = angr.Project(\"./a.out\", load_options={'auto_load_libs': False})\n\n\nstate = p.factory.blank_state(addr=addr_main)\n\npath = p.factory.path(state)\npathgroup = p.factory.path_group(path)\nprint \"Searching...\"\nfound_state = pathgroup.explore(find=success, avoid=fail)\n\nif found_state.found:\n    f = found_state.found[0].state\n\n    print \"Flag: %s\" % (f.posix.dumps(0)[0:20],)\n</code></pre>\n",
    "votes": "3",
    "answers": 1,
    "views": "427",
    "tags": [
        "angr"
    ],
    "user": "soolidsnake",
    "time": "Aug 29, 2018 at 15:58",
    "comments": [],
    "answers_data": [
        {
            "content": "Since OP didn't specify the addresses referred to by the hardcoded offsets, I'm gonna assume his intention. I'm assuming the values in <pre><code>find</code></pre> match the two <pre><code>printf(\"gg\")</code></pre> statements and the two values in <pre><code>avoid</code></pre> match the two <pre><code>printf(\"fail\");</code></pre> statements.\nFirst of all, I believe your program has two unintentional considerable bugs in it, preventing the intended solutions from being needed:\n\nThe first and more considerable of the two is the use of <pre><code>lose</code></pre> in your code. It is sufficient to only correctly provide one of the passwords to permanently set <pre><code>lose</code></pre> to <pre><code>false</code></pre>. Doing so using the first password means <pre><code>lose</code></pre> will be <pre><code>false</code></pre> for both, effectively reaching the two success criteria you specified. Simply put, because <pre><code>lose</code></pre> is not being reset to the default of <pre><code>true</code></pre> after the first password validation, is is enough to provide the first password to get two <pre><code>gg</code></pre>s.\nThis one does not really interfere with solving the challenge but is also probably a bug. We'll go over why it's an issue for angr in a few paragraphs but for now I'll just point out your string comparison is lacking any validation for the correct length, or that the input string is terminated when the hardcoded password is.\n\nI find your example code quite interesting because those are two relatively common security vulnerabilities.\nIgnoring the first logical bug above, I believe the issue is your configured success criteria; According to angr documentation (emphasis is mine):\n\nWhen launching <pre><code>.explore()</code></pre> with a <pre><code>find</code></pre> argument, execution will run until a state is found that matches the find condition, which can be the address of an instruction to stop at, a list of addresses to stop at, or a function which takes a state and returns whether it meets some criteria.\nWhen any of the states in the active stash match the <pre><code>find</code></pre> condition, they are placed in the found stash, and execution terminates. You can then explore the found state, or decide to discard it and continue with the other ones. You can also specify an <pre><code>avoid</code></pre> condition in the same format as <pre><code>find</code></pre>. When a state matches the <pre><code>avoid</code></pre> condition, it is put in the avoided stash, and execution continues. Finally, the <pre><code>num_find</code></pre> argument controls the number of states that should be found before returning, with a default of <pre><code>1</code></pre>. Of course, if you run out of states in the active stash before finding this many solutions, execution will stop anyway.\n\nProviding a sequence of addresses in <pre><code>explorer</code></pre>'s <pre><code>find</code></pre>, like you did, means either one is an acceptable success condition. Because you did not provide any <pre><code>num_find</code></pre> the default of <pre><code>1</code></pre> is assumed and <pre><code>execute</code></pre> returns with the first success found.\nObviously, this is the success criteria for the first password. That is forced upon angr because the <pre><code>avoid</code></pre> parameter you provided. If the <pre><code>avoid</code></pre>  condition is reached the current exploration path is terminated, preventing any additional exploration down that path. In your case, providing an <pre><code>avoid</code></pre> of the failure of the first password means any paths failing the first password will be immediately discarded. Therefore, intentionally or not - thanks to your <pre><code>avoid</code></pre>, no path is possible that does reach a success in the first password test.\nThere are several ways to properly solve this challenge and I'll go over them.\nIncreasing <pre><code>num_find</code></pre> to more than one result\nOne might think a proper solution could be to increase <pre><code>num_find</code></pre> to more than one, allowing more than one <pre><code>found</code></pre> states to be reached before <pre><code>explorer</code></pre> returns. That, however, is a mistake. Because your example code does not makes sure passwords are actually identical strings because there's no length validation and the null terminator is not compared, it appears any string starting with <pre><code>\"first_pass\"</code></pre> should be considered a valid solution. Interestingly enough, this accidently allows more than one solution (and in reality, quite a lot), so increasing <pre><code>num_find</code></pre> to any computationally feasible value will yield additional solutions to the first password, never reaching the second one.\nbtw, to fix the erroneous password verification condition, you can either verify lengths match, use a string comparison function (such as <pre><code>strcmp</code></pre> and derivatives), or change the conditional from <pre><code><</code></pre> to <pre><code><=</code></pre> so it will include the null terminator.\nseparating the two tests\nSince the two scenarios are completely independent of one another, you could run to executions. One for each password, setting a single <pre><code>find</code></pre> and <pre><code>avoid</code></pre> value for each, as well as setting the entry point for the second one. Splitting the two executions will effectively create a more simple set of constraints which should be executing faster. Of course, you can even run them in parallel to gain an additional performance advantage.\ncorrectly specifying the success criteria\nAlthough your values of <pre><code>find</code></pre> and <pre><code>avoid</code></pre> may initially seem correct, we've discussed several reasons why in reality they fail to accurately describe your intention. A more accurate specification of those parameters will be setting <pre><code>avoid</code></pre> to both <pre><code>printf(\"fail\");</code></pre> statements, as you did. However you'll need to remove the first <pre><code>printf(\"gg\")</code></pre> and only keep the second, as it won't be reached without passing both passwords (assuming the logical bug mentioned above is fixed).\n",
            "votes": "1",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": false,
            "comments": []
        }
    ]
}