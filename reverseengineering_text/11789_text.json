{
    "title": "Different disassembly for the same function?",
    "link": "https://reverseengineering.stackexchange.com/questions/11789/different-disassembly-for-the-same-function",
    "content": "I have this code:\n<pre><code>#include <stdio.h>\nint main()\n{\nprintf(\"a=%d; b=%d; c=%d\", 1, 2, 3);\nreturn 0;\n};</code></pre>\nI compile it with <pre><code>gcc -g 3arg.cpp</code></pre>. Disassemble with <pre><code>objdump -d -M intel a.out</code></pre>. In the output there is exactly one function named <pre><code>_init</code></pre> and it is disassembled like this:\n<pre><code>00000000004003e0 <_init>:\n  4003e0:       48 83 ec 08             sub    rsp,0x8\n  4003e4:       48 8b 05 0d 0c 20 00    mov    rax,QWORD PTR [rip+0x200c0d]        # 600ff8 <_DYNAMIC+0x1d0>\n  4003eb:       48 85 c0                test   rax,rax\n  4003ee:       74 05                   je     4003f5 <_init+0x15>\n  4003f0:       e8 3b 00 00 00          call   400430 <__gmon_start__@plt>\n  4003f5:       48 83 c4 08             add    rsp,0x8\n  4003f9:       c3                      ret</code></pre>\nThis is <pre><code>gdb</code></pre> output:\n<pre><code>$ gdb -q a.out\nReading symbols from a.out...done.\n(gdb) disassemble _init\nDump of assembler code for function _init:\n   0x00000000004003e0 <+0>:  sub    $0x8,%rsp\n   0x00000000004003e4 <+4>:  mov    0x200c0d(%rip),%rax        # 0x600ff8\n   0x00000000004003eb <+11>: test   %rax,%rax\n   0x00000000004003ee <+14>: je     0x4003f5 <_init+21>\n   0x00000000004003f0 <+16>: callq  0x400430 <__gmon_start__@plt>\n   0x00000000004003f5 <+21>: add    $0x8,%rsp\n   0x00000000004003f9 <+25>: retq   \nEnd of assembler dump.\n(gdb) break _init\nBreakpoint 1 at 0x4003e0\n(gdb) run\nStarting program: [redacted]/a.out \n\nBreakpoint 1, _init (argc=1, argv=0x7fffffffdf68, envp=0x7fffffffdf78) at ../csu/init-first.c:52\n52  ../csu/init-first.c: No such file or directory.\n(gdb) disassemble _init\nDump of assembler code for function _init:\n=> 0x00007ffff7a36c20 <+0>:  push   %r13\n   0x00007ffff7a36c22 <+2>:  push   %r12\n   0x00007ffff7a36c24 <+4>:  mov    %edi,%r12d\n   0x00007ffff7a36c27 <+7>:  push   %rbp\n   0x00007ffff7a36c28 <+8>:  mov    %rsi,%rbp\n   0x00007ffff7a36c2b <+11>: push   %rbx\n[etc.]</code></pre>\nWhy is the last disassembly different? It's not even the same data disassembled in a different way (As seen when comparing the <pre><code>objdump</code></pre> output with output of <pre><code>gdb</code></pre> command <pre><code>x/10b $rip</code></pre> when the breakpoint has been hit). If it's a different <pre><code>_init</code></pre> function: \n\nhow can I put a breakpoint at the one that's seen in the <pre><code>objdump</code></pre> output and the first disassembly in <pre><code>gdb</code></pre>?\nwhy did <pre><code>gdb</code></pre> say Breakpoint 1 was at <pre><code>0x4003e0</code></pre> and then stopped at a different function?\n",
    "votes": "4",
    "answers": 1,
    "views": "1k",
    "tags": [
        "disassembly",
        "gdb",
        "objdump"
    ],
    "user": "user14742",
    "time": "Jan 23, 2017 at 10:34",
    "comments": [],
    "answers_data": [
        {
            "content": "To arrive to your <pre><code>_init</code></pre> function just continue execution. This will stop once again in the intended place.\n<pre><code>    gdb -q test.out\n    Reading symbols from test.out...done.\n    (gdb) b _init\n    Breakpoint 1 at 0x4003e0\n    (gdb) run\n    Starting program: /home/[censored]/stk/test.out \n\n    Breakpoint 1, _init (argc=1, argv=0x7fffffffe008, envp=0x7fffffffe018) at ../csu/init-first.c:52\n    52  ../csu/init-first.c: No such file or directory.\n    (gdb) bt\n    #0  _init (argc=1, argv=0x7fffffffe008, envp=0x7fffffffe018) at ../csu/init-first.c:52\n    #1  0x00007ffff7dea0fd in call_init (l=0x7ffff7ff74c0, argc=argc@entry=1, argv=argv@entry=0x7fffffffe008, env=env@entry=0x7fffffffe018) at dl-init.c:64\n    #2  0x00007ffff7dea223 in call_init (env=<optimized out>, argv=<optimized out>, argc=<optimized out>, l=<optimized out>) at dl-init.c:36\n    #3  _dl_init (main_map=0x7ffff7ffe1c8, argc=1, argv=0x7fffffffe008, env=0x7fffffffe018) at dl-init.c:126\n    #4  0x00007ffff7ddb30a in _dl_start_user () from /lib64/ld-linux-x86-64.so.2\n    #5  0x0000000000000001 in ?? ()\n    #6  0x00007fffffffe364 in ?? ()\n    #7  0x0000000000000000 in ?? ()\n    (gdb) c\n    Continuing.\n\n    Breakpoint 1, 0x00000000004003e0 in _init ()\n    (gdb) bt\n    #0  0x00000000004003e0 in _init ()\n    #1  0x0000000000400593 in __libc_csu_init ()\n    #2  0x00007ffff7a36e55 in __libc_start_main (main=0x40052d <main>, argc=1, argv=0x7fffffffe008, init=0x400560 <__libc_csu_init>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffdff8)\n        at libc-start.c:246\n    #3  0x0000000000400469 in _start ()\n    (gdb) info shared\n    From                To                  Syms Read   Shared Object Library\n    0x00007ffff7ddaae0  0x00007ffff7df54e0  Yes         /lib64/ld-linux-x86-64.so.2\n    0x00007ffff7a344a0  0x00007ffff7b79583  Yes         /lib/x86_64-linux-gnu/libc.so.6\n    (gdb) x/10i $pc\n=> 0x4003e0 <_init>:    sub    $0x8,%rsp\n   0x4003e4 <_init+4>:  mov    0x200c0d(%rip),%rax        # 0x600ff8\n   0x4003eb <_init+11>: test   %rax,%rax\n   0x4003ee <_init+14>: je     0x4003f5 <_init+21>\n   0x4003f0 <_init+16>: callq  0x400430 <__gmon_start__@plt>\n   0x4003f5 <_init+21>: add    $0x8,%rsp\n   0x4003f9 <_init+25>: retq \n(gdb) info breakpoints\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   <MULTIPLE>         \n    breakpoint already hit 2 times\n1.1                         y     0x00000000004003e0 <_init>\n1.2                         y     0x00007ffff7a36c20 in _init at ../csu/init-first.c:52\n</code></pre>\nAccording to information about shared libraries, it stopped first time in address area of <pre><code>libc.so</code></pre>, which looks like also has <pre><code>_init</code></pre> function, which caused <pre><code>gdb</code></pre> to set this breakpoint there too (see breakpoint definition at the end of the listing).\nIf you want to set a breakpoint in your specific address, you can use\n<pre><code> b *address\n</code></pre>\nnotation. If you want to set a breakpoint on a specific function from specific source file you can use something like \n<pre><code>(gdb) break test.c:call1\n</code></pre>\nThe same thing is discussed a bit deeper here .\nGood luck.\n",
            "votes": "10",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": []
        }
    ]
}