{
    "title": "How can I manually figure out stack variable/buffer sizes from stripped x86-64 disassembly?",
    "link": "https://reverseengineering.stackexchange.com/questions/31083/how-can-i-manually-figure-out-stack-variable-buffer-sizes-from-stripped-x86-64-d",
    "content": "I am looking at the following CTF challenge:\n<pre><code> 0x56555779 <+0>:   lea    ecx,[esp+0x4]\n   0x5655577d <+4>: and    esp,0xfffffff0\n   0x56555780 <+7>: push   DWORD PTR [ecx-0x4]\n   0x56555783 <+10>:    push   ebp\n   0x56555784 <+11>:    mov    ebp,esp\n   0x56555786 <+13>:    push   ebx\n   0x56555787 <+14>:    push   ecx\n   0x56555788 <+15>:    sub    esp,0x40\n   0x5655578b <+18>:    call   0x56555600 <__x86.get_pc_thunk.bx>\n   0x56555790 <+23>:    add    ebx,0x1820\n   0x56555796 <+29>:    mov    eax,DWORD PTR [ebx+0x44]\n   0x5655579c <+35>:    mov    eax,DWORD PTR [eax]\n   0x5655579e <+37>:    push   0x0\n   0x565557a0 <+39>:    push   0x0\n   0x565557a2 <+41>:    push   0x2\n   0x565557a4 <+43>:    push   eax\n   0x565557a5 <+44>:    call   0x56555580 <setvbuf@plt>\n   0x565557aa <+49>:    add    esp,0x10\n=> 0x565557ad <+52>:    mov    DWORD PTR [ebp-0xc],0x2\n   0x565557b4 <+59>:    mov    DWORD PTR [ebp-0x10],0x0\n   0x565557bb <+66>:    sub    esp,0xc\n   0x565557be <+69>:    lea    eax,[ebx-0x1620]\n   0x565557c4 <+75>:    push   eax\n   0x565557c5 <+76>:    call   0x56555550 <puts@plt>\n   0x565557ca <+81>:    add    esp,0x10\n   0x565557cd <+84>:    sub    esp,0xc\n   0x565557d0 <+87>:    lea    eax,[ebx-0x15b5]\n   0x565557d6 <+93>:    push   eax\n   0x565557d7 <+94>:    call   0x56555550 <puts@plt>\n   0x565557dc <+99>:    add    esp,0x10\n   0x565557df <+102>:   mov    eax,DWORD PTR [ebx+0x40]\n   0x565557e5 <+108>:   mov    eax,DWORD PTR [eax]\n   0x565557e7 <+110>:   sub    esp,0x4\n   0x565557ea <+113>:   push   eax\n   0x565557eb <+114>:   push   0x2b\n   0x565557ed <+116>:   lea    eax,[ebp-0x3b]\n   0x565557f0 <+119>:   push   eax\n   0x565557f1 <+120>:   call   0x56555530 <fgets@plt>\n   0x565557f6 <+125>:   add    esp,0x10\n   0x565557f9 <+128>:   sub    esp,0x8\n   0x565557fc <+131>:   lea    eax,[ebx-0x159f]\n   0x56555802 <+137>:   push   eax\n   0x56555803 <+138>:   lea    eax,[ebp-0x3b]\n   0x56555806 <+141>:   push   eax\n   0x56555807 <+142>:   call   0x56555510 <strcmp@plt>\n   0x5655580c <+147>:   add    esp,0x10\n   0x5655580f <+150>:   test   eax,eax\n   0x56555811 <+152>:   je     0x5655582f <main+182>\n   0x56555813 <+154>:   sub    esp,0xc\n   0x56555816 <+157>:   lea    eax,[ebx-0x1584]\n   0x5655581c <+163>:   push   eax\n   0x5655581d <+164>:   call   0x56555550 <puts@plt>\n   0x56555822 <+169>:   add    esp,0x10\n   0x56555825 <+172>:   sub    esp,0xc\n   0x56555828 <+175>:   push   0x0\n   0x5655582a <+177>:   call   0x56555560 <exit@plt>\n   0x5655582f <+182>:   sub    esp,0xc\n   0x56555832 <+185>:   lea    eax,[ebx-0x1564]\n   0x56555838 <+191>:   push   eax\n   0x56555839 <+192>:   call   0x56555550 <puts@plt>\n   0x5655583e <+197>:   add    esp,0x10\n   0x56555841 <+200>:   mov    eax,DWORD PTR [ebx+0x40]\n   0x56555847 <+206>:   mov    eax,DWORD PTR [eax]\n   0x56555849 <+208>:   sub    esp,0x4\n   0x5655584c <+211>:   push   eax\n   0x5655584d <+212>:   push   0x2b\n   0x5655584f <+214>:   lea    eax,[ebp-0x3b]\n   0x56555852 <+217>:   push   eax\n   0x56555853 <+218>:   call   0x56555530 <fgets@plt>\n   0x56555858 <+223>:   add    esp,0x10\n   0x5655585b <+226>:   sub    esp,0x8\n   0x5655585e <+229>:   lea    eax,[ebx-0x154d]\n   0x56555864 <+235>:   push   eax\n   0x56555865 <+236>:   lea    eax,[ebp-0x3b]\n   0x56555868 <+239>:   push   eax\n   0x56555869 <+240>:   call   0x56555510 <strcmp@plt>\n   0x5655586e <+245>:   add    esp,0x10\n   0x56555871 <+248>:   test   eax,eax\n   0x56555873 <+250>:   je     0x56555891 <main+280>\n   0x56555875 <+252>:   sub    esp,0xc\n   0x56555878 <+255>:   lea    eax,[ebx-0x1584]\n   0x5655587e <+261>:   push   eax\n   0x5655587f <+262>:   call   0x56555550 <puts@plt>\n   0x56555884 <+267>:   add    esp,0x10\n   0x56555887 <+270>:   sub    esp,0xc\n   0x5655588a <+273>:   push   0x0\n   0x5655588c <+275>:   call   0x56555560 <exit@plt>\n   0x56555891 <+280>:   sub    esp,0xc\n   0x56555894 <+283>:   lea    eax,[ebx-0x1534]\n   0x5655589a <+289>:   push   eax\n   0x5655589b <+290>:   call   0x56555550 <puts@plt>\n   0x565558a0 <+295>:   add    esp,0x10\n   0x565558a3 <+298>:   sub    esp,0xc\n   0x565558a6 <+301>:   lea    eax,[ebp-0x3b]\n   0x565558a9 <+304>:   push   eax\n   0x565558aa <+305>:   call   0x56555520 <gets@plt>\n   0x565558af <+310>:   add    esp,0x10\n   0x565558b2 <+313>:   cmp    DWORD PTR [ebp-0x10],0xdea110c8\n   0x565558b9 <+320>:   jne    0x565558c2 <main+329>\n   0x565558bb <+322>:   call   0x565556fd <print_flag>\n   0x565558c0 <+327>:   jmp    0x565558d4 <main+347>\n   0x565558c2 <+329>:   sub    esp,0xc\n   0x565558c5 <+332>:   lea    eax,[ebx-0x1584]\n   0x565558cb <+338>:   push   eax\n   0x565558cc <+339>:   call   0x56555550 <puts@plt>\n   0x565558d1 <+344>:   add    esp,0x10\n   0x565558d4 <+347>:   mov    eax,0x0\n   0x565558d9 <+352>:   lea    esp,[ebp-0x8]\n   0x565558dc <+355>:   pop    ecx\n   0x565558dd <+356>:   pop    ebx\n   0x565558de <+357>:   pop    ebp\n   0x565558df <+358>:   lea    esp,[ecx-0x4]\n   0x565558e2 <+361>:   ret    \nEnd of assembler dump.\n</code></pre>\nGhidra decompiler shows me this:\n<pre><code>{\n  int iVar1;\n  char user_buf [43];\n  int overwrite_me;\n  undefined4 local_14;\n  undefined *local_10;\n  \n  local_10 = &stack0x00000004;\n  setvbuf(stdout,(char *)0x2,0,0);\n  local_14 = 2;\n  overwrite_me = 0;\n  puts(\n        \"Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other  side he see.\"\n        );\n  puts(\"What... is your name?\");\n  fgets(user_buf,0x2b,stdin);\n  iVar1 = strcmp(user_buf,\"Sir Lancelot of Camelot\n\");\n  if (iVar1 != 0) {\n     puts(\"I don\\'t know that! Auuuuuuuugh!\");\n                            /* WARNING: Subroutine does not return */\n     exit(0);\n  }\n  puts(\"What... is your quest?\");\n  fgets(user_buf,0x2b,stdin);\n  iVar1 = strcmp(user_buf,\"To seek the Holy Grail.\n\");\n  if (iVar1 != 0) {\n     puts(\"I don\\'t know that! Auuuuuuuugh!\");\n                            /* WARNING: Subroutine does not return */\n     exit(0);\n  }\n  puts(\"What... is my secret?\");\n  gets(user_buf);\n  if (overwrite_me == -0x215eef38) {\n     print_flag();\n  }\n  else {\n     puts(\"I don\\'t know that! Auuuuuuuugh!\");\n  }\n  return 0;\n}\n</code></pre>\nOk, some of those vars I obviously named, but the decompiler knows that there's an int, followed by a 43-byte char buffer, followed by an int up at the top of the function. How do decompilers and disassemblers learn this info? By looking at the disassembly in <pre><code>gdb</code></pre>, I do not know that the buffer is 43 bytes for example because there is a single <pre><code>sub esp, 0x40</code></pre> instruction, which overs all of that in one motion. However, I can infer the size based on these instructions:\n<pre><code>   0x565557eb <+114>:   push   0x2b\n   0x565557ed <+116>:   lea    eax,[ebp-0x3b]\n</code></pre>\nHowever, in some situations, it may not be that obvious.\nNOTE: I am not trying to solve this challenge, I've already solved it - this is a curiosity/educational question.\n",
    "votes": "3",
    "answers": 0,
    "views": "103",
    "tags": [
        "ida",
        "disassembly",
        "ghidra",
        "decompiler"
    ],
    "user": "the_endian",
    "time": "Nov 4, 2022 at 22:07",
    "comments": [
        {
            "user": "the_endian",
            "text": "Thanks. I seem to be a master of \"big questions\", thats why I reverse. :)\n",
            "time": null
        }
    ],
    "answers_data": []
}