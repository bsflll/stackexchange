{
    "title": "Decoding an unknown image format with \"DREK\" signature (*.drk)",
    "link": "https://reverseengineering.stackexchange.com/questions/13221/decoding-an-unknown-image-format-with-drek-signature-drk",
    "content": "There are some unknow images, which I would like to decode to <pre><code>RRGGBBAA</code></pre> format. It was a really hard work, but at the moment I can somewhat understand, that which part of the binary is responsible for what. But I'm stuck at the end, and I have no idea how to continue it. This is what I've found out:\nI know, that the size of the first image is a 9*3.\nThere is some kind of table at the begining of the file:\n<pre><code>0x08 0x08 0x10\n0x08 0x08 0x08\n0x00 0x00 0x00\n0x10 0x10 0x18\n0x18 0x18 0x20\n0x10 0x14 0x18\n0x08 0x08 0x10\n</code></pre>\nAnd this is the image data:\n<pre><code>0x09 0x00 0x03 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01 0x00 0x00 0x00\n0x0c 0x00 0x00 0x00 0x00 0x01 0x03 0x09 0x01 0x01 0x02 0x11 0x01 0x01 0x02 0x02\n0x01 0x0f 0x0f 0x03 0x0a 0x03 0x08 0x05 0x08 0x04 0x08 0x03 0x09 0x00 0x09 0x00\n0x0c 0x00 0x02\n</code></pre>\nThe number of elements in the table can be divided by three, so I think it is some kind of RRGGBB palette.\nBut I have no idea, how to decode the imagedata. It's size is not 9*3, so It may be compressed. It is a really small image, and I think that this is why the compression made the binary bigger than it was before.\n\nEdit:\nI've uploaded this file here: Download file\nI've colored it, to better understand it's structure.\nThe first part of the file:\n\n\nThe red section is just some kind of file signature.\nThe brown part is the file length in bytes. (1107)\nThe green shows, how many images are stored in the file (currently one)\nThe blue part shows, where the table begins ( 0x60 = at the 96th byte)\nThe grey part shows, how long the content in the table is. Currently it's 7, so the table has 7*3 = 21 bytes, the other values are <pre><code>CD</code></pre>\nThe table is marked with purple\n\nThe second part of the file:\n\n\nThe blue part is the header of the image.\nThe yellow part shows, how long the image is (51bytes)\nThe red is the image width, and the brown is the height (3*9)\nThe 8 zero bytes (selected with green) are the same in each file.\n\n\nI've uploaded two more files.\n\nA similar small file: Download\nAnd a bigger one: Download\n\nThe bigger file has a resolution of 800*600 And I suspect it is this one (screenshot):\n\nAt the beginning (from <pre><code>3C0</code></pre>), only the the first two or three bytes are set in each 4 byte group. From <pre><code>0xD28</code></pre>, I cannot recognise any pattern.\n\nEdit2:\nSpektre's code works with most of the files. But there are some small icons, with transparency, which look distorted.\nFor example this icon: Download\nAnd this is how it looks like, over a brownish background: \n\nIn this case, the scanlines are not fixed-width. And the unknown <pre><code>252</code></pre> flags at the beginning of each scanline, and <pre><code>254</code></pre> flags after every 32bytes are also different.\nI can recognise patterns and symmetry in the binary, but I haven't figured out yet, how it works.\nI've colored the scanlines of the icon's imagedata, to have a better overview:\n\nMany of them starts with, and all of them ends with <pre><code>0x02</code></pre>\n\nEdit3:\nI uploaded some images, with screenshots:\n\nSnowy mountain: Download\nThree icons: Download\n\nI uploaded two more images, which I found distorted. The first is an icon, which is almost perfect. And the second one is a dragon, which is barely recognisable.  Unfortunately I cannot provide screenshots for this two: Download\nI implemented the core algorithm ( from Spektre's answer ) in JS. It can be found, and edited online here: JSFiddle link\n\nEdit4:\nI've made some progress with the mountain, and the dragon.\nI think, that the first 7 bits of the flag byte shows, on which x coordinate the line starts ( ´xstart = flag>>1;´ ). The least significant bit is a switch, which marks, that the line has this offset or not. You can try/edit the current code here: JSFiddle link\nThe result is this:\n\nThe expected result would be similar to this (which is not far):\n\nThe distorted parts around the mountain are shadow/transparency, but I still wasn't be able to find any marks/flags about where the blocks with alpha values start and end.\n\nEdit5:\nI think, I've found a pattern in the mountain image. After the flag byte, the next byte may show, (<pre><code>flag2>>1</code></pre>), how many <pre><code>(Color, Alpha)</code></pre> blocks are at the beginning of the line.\nThe left side of the mountain looks slightly better now:\n\nUnfortunately this change breaks the other images\n",
    "votes": "16",
    "answers": 2,
    "views": "3k",
    "tags": [
        "binary-analysis",
        "file-format",
        "unpacking",
        "decompress",
        "binary-diagnosis"
    ],
    "user": "Iter Ator",
    "time": "Apr 13, 2017 at 12:49",
    "comments": [
        {
            "user": "user10070",
            "text": "I take it you don't know what the image actually looks like or anything? Without a header byte string, this will be tough to crack.\n",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "Is this all data in the file? Do you have more samples? (Preferably available for downloading.)\n",
            "time": null
        },
        {
            "user": "Iter Ator",
            "text": "I updated the question with more info, and downloadable samples\n",
            "time": null
        },
        {
            "user": "Iter Ator",
            "text": "@Spektre I will look at it in detail as soon as arrived home\n",
            "time": null
        },
        {
            "user": "Iter Ator",
            "text": "@Spektre The integer at <pre><code>0x388-0x38B</code></pre> points everywhere to <pre><code>0x3C0</code></pre>. The integer from <pre><code>0x38C-0x38F</code></pre> shows, where the image data ends. The 16bit integers at <pre><code>0x3C0</code></pre> and <pre><code>0x3C2</code></pre> are width and height again. And the bytes from <pre><code>0x3C4-0x3C7</code></pre> are always zero. As I see, only the <pre><code>0x37C-0x383</code></pre> part - which is still unknown - is different in almost every image.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "I was able to decode the images. Spektre did a great job detecting the files structure, and the debug view was really helpful in the process. I implemented the algorithm in JS, and the source code is available here: https://github.com/K-Adam/DrekDecoder\nSummary\nEach line starts with a flag byte. It tells the decoder how many pixels to write and which mode to use. There are three possible write modes:\n\nOpaque\nTransparent\nSkip\n\nIn opaque mode each pixel is represented by one byte, which references an RGB color in the palette. In transparent mode, the pixels are pairs of bytes: [Alpha, ColorIndex]\nAfter each sequence a control byte follows. Its structure is different from the flag byte, and also different in each writing mode. This control byte will tell how many pixels to write and which mode to use next, or if the end of the line is reached.\nDetails\nFlag byte\nIf the flag is zero <pre><code>(flag == 0x0)</code></pre>, then the line is empty.\nIf the LSB is set <pre><code>(flag & 0b1)</code></pre> then there is an offset at the beginning of the line, and the decoder will start in Skip mode. The rest of the bits will represent the length of the offset <pre><code>(flag >> 1) + 1</code></pre>\nIf the second bit is set then transparent, otherwise opaque mode will be used:\n<pre><code>mode = (flag & 0b10) ? Transparent : Opaque\n</code></pre>\nThe number of pixels can be found in the 5 MSB <pre><code>(flag >> 3) + 1</code></pre>\nSkip mode\nThe decoder will simply write <pre><code>n</code></pre> empty pixels to the output. The next byte will be a control byte.\nIf LSB is set, then the decoder will switch to transarent mode. The other 7 bits represent the number of transparent pixels.\nIf the three LSB is <pre><code>0b100</code></pre> then the decoder will continue in Skip mode, otherwise it will change to Opaque mode. The other bits represent the number of pixels <pre><code>(vv >> 3) + 1</code></pre>\nOpaque mode\nEach data byte references an RGB color in the palette.\nIf the LSB is set, then the decoder will switch to transparent mode for <pre><code>(v1 >> 1) + 1</code></pre> pixels. Otherwise the three LSB of the control byte is the flag:\n\n0b000 End of line\n0b110 Continue in opaque mode\n0b100 Switch to skip mode\n\nThe rest is the number of pixels <pre><code>(v1 >> 3) + 1</code></pre>.\nTransparent mode\nThe transparent blocks are represented by sequence of pairs: [Alpha, Color]. The 5 MSB of the alpha byte is the transparency (0-32). The color byte references an RGB color in the palette.\nThe two LSB of the control byte is a flag:\n\n0b10 End of the line\n0b11 Switch to opaque mode\n0b01 Switch to skip mode\n0b00 Continue in transparent mode\n\nThe rest of the bits is the number of pixels <pre><code>(v1 >> 2) + 1</code></pre>, except for transparent mode, where it is <pre><code>(v1 >> 3) + 1</code></pre>\nDecoding process\nSince the colors are referenced by index, two bytes are needed to represent a transparent pixel. By looking at the bottom-left part of the mountain, it was clear from those alternating patterns, that it has to be transparent there. The colors around the round icons were also not right, so I suspected that the outer pixels are half transparent as well.\nIn the large image <pre><code>0xFE</code></pre> appears after each 32 bytes. It does not reference a color from the palette, so it has to be some kind of control byte.\nThen I started to write down the bytes in binary, where the color seemed not right. I grouped these values by where by where they appear, and then I spotted, that the least significant bits are similar on the boundary of transparent and opaque regions.\nAfter further analysis, when I was able to decode the smaller icons by hand, I implemented the algorithm, and tested it for larger ones. From there, it was easy to eliminate the remaining anomalies in the result.\n",
            "votes": "4",
            "user": "K-Adam",
            "time": "Aug 22, 2019 at 14:55",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "[Complete ReEdit3] further progress & shortening the text to fit the 30KB limit\nFirst some input how I got here (for future readers trying to do the same for different format).\n\nImage Data size\nComparing provided background image to its raw image size <pre><code>xs*ys</code></pre> reveal direct dependence Which implies no compression or one that has always the same pixel to data ratio. I was assuming No compression.\nImage Data align.\nFirst numbers are <pre><code>DWORD</code></pre> aligned with zero padding. By closer look it is always <pre><code>DWORD[ys]</code></pre> so that is implying some info per each ScanLine. The numbers are increasing with constant step. For <pre><code>800x600</code></pre> image With step <pre><code>826</code></pre> Implying it is ScanLine directory containing relative offsets. Tests confirms it:\n\nThe small images are too small to see any details so I ignore them completely.\nThe vertical lines are the <pre><code>26 BYTES</code></pre> inconsistency with <pre><code>xs</code></pre> starting from first <pre><code>BYTE</code></pre> of ScanLine containing some kind of info. After more taught and pixel measuring these lines appears each <pre><code>33 BYTES</code></pre> probably containing some flag info (like: tile highlight,transparency or effect masks). If skipped The result is closer:\n\nColors\nI simply took your ScreenShot and compare first decoded pixel with its. Find the color index in palette matching the color from each image and spotted the difference is simple increment. So I firstly increment the color index while decoding And result was good. After some research I found out that palette data has <pre><code>257</code></pre> colors instead of assumed <pre><code>256</code></pre> at first so I change the palette offset to compensate (no need for color index change anymore) Implying the first color entry (skipped by offset change) is some kind of special color (see bullet #1). Latter I deduced it is not color at all and does not belong to palette data but to header data. Now the result is:\n\nIf I would not spot the color dependency then I would do histogram for decoded and screenshot image and then analyze dependency on most occuring colors indexes hoping to spot some pattern. \nComparison\nI pixel match the decoded image with your ScreenShot but the images are not matching. Possibly some post processing or lighting was applied to it or there is some mistake in the decoding. It is hard to decide as I have no access to the original App and or knowledge of its inner workings. You should check more Images to see if there are some artifacts or not. The small images are unusable as you do not know the content and also the size is small for any significant details to reveal ...\nTransparent images\nWell Iter Ator spotted that some files are not decoded properly and deduced that it has something to do with transparency (as the images was icons and later also sprites). So some more in depth analysis was take in place to make some progress. \nAfter some thinking and looping in circles I create special debug views so I can see encoded image data , reference screenshot and the corresponding palette colors in some convenient way to spot patterns or dependency. The result was something like this:\n\nI simply render each pixel/BYTE of data as square with color corresponding to the palette entry and render the hex code inside. I render encoded ScanLine and screenshot ScanLine below (with cross matched color code from image palette printed inside. Then I painfully cross-reference both ScanLines in Paint and after comparing all the icons I got start deducing encoding format. The gaps means some kind of flag or prefix, sequence or special command. After implementing these rules into decoder then suddenly the images got looking much better. \nI got in a state where all the icons I got was pixel perfect but after more images came in (sprites) it was obvious that some codes may be variable and more in depth analysis of the chunks in file is needed to search for some code table or dictionary.\nTo help with the analysis I rewrite the decoder debug view to separate class with capability to recognize perfect color match (square) and close color match (circle) to better asses the codes on non transparent pixels first.\n\nI started with rules like this:\nFrom it I deduced this (not fully OK see the code for actual state):\nfirst 2 Bytes are flags\n03 unknonw flag/command skip flag can follow!\n\nalso end sequence 23 (flag and pixel follows as 01)\n02 end of scanline\n01 flag and pixel follows, end of sequence (if not in first 5 pixels)\nstart of sequence:  13,17,23,27,2B\npixel follows:      0D,0F,12,15,16,18,1A,1C,1D,1E\nflag or pixel follows:  06,07,0C,0E?,10\nsequence can not start as first pixel otherwise it is pixel\nsequence can stop after 5 pixels already done else 01/03 is just pixel\n\nI improved it much more later directly in the decoder\nScanLine offsets \nAs I find out if the first BYTE of ScanLine was used as offset for transparent images some of the images looks much better. Ite Ator found out that it is the offset and LSB bit is switch of this capability. I found out that  if the first BYTE of first ScanLine is <pre><code>0xFC</code></pre> then it is not transparent image and the decoding is described in first bullets. I introduced <pre><code>mode 0/1</code></pre> variable to recognize this in the decoder. And The offset is active only in mode 1 (transparency). Also I found out that the <pre><code>offset=(flag>>1)+1</code></pre> as it makes more sense from encoding efficiency side (test confirms it was correct assumption).\nFile chunks\nIn search for missing code table or dictionary I started to dissect the file-format (each BYTE that is not used yet). After some coding and analysis I added another debug output to decoder that creates text for each file/frame in aligned form so I can easily compare between all the images I got as comparing in two ro more hex-views is not very convenient.\nHere the header data:\n<pre><code>file                          K  E  R  D              file_size        frames image_ofs                                                                                                                                                                                                   palette_ofs used_colors\ndragon              00000000: 4B 45 52 44 C8 00 00 00 A1 BF 01 00 01 00 0B 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 2E 00 0A 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 00 01 00 00 18 CD CD CD \nmountain            00000000: 4B 45 52 44 C8 00 00 00 58 8C 01 00 01 00 02 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 56 8A 01 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 00 01 00 00 18 CD CD CD \nicon0               00000000: 4B 45 52 44 C8 00 00 00 4F 05 00 00 01 00 01 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 5A 00 00 00 18 CD CD CD \nicon1               00000000: 4B 45 52 44 C8 00 00 00 4F 05 00 00 01 00 01 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 59 00 00 00 18 CD CD CD \nicon2               00000000: 4B 45 52 44 C8 00 00 00 4D 05 00 00 01 00 01 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 50 00 00 00 18 CD CD CD \nicon3               00000000: 4B 45 52 44 C8 00 00 00 46 0B 00 00 01 00 01 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 00 01 00 00 18 CD CD CD \nback                00000000: 4B 45 52 44 C8 00 00 00 78 9D 07 00 01 00 01 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 00 01 00 00 18 CD CD CD \n</code></pre>\nAnd here the ImageData:\n<pre><code>file                                                                    frame sz          xs          ys                                                                                                                                                                                                                      xs    ys                \ndragon              00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 04 25 00 00 B2 00 00 00 5B 00 00 00 E5 FF FF FF B3 FF FF FF 00 00 00 00 C0 03 00 00 C4 28 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD B2 00 5B 00 00 00 00 00 \n                    000028C4: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 02 00 A1 26 00 00 B6 00 00 00 5B 00 00 00 DD FF FF FF B4 FF FF FF 00 00 00 00 24 29 00 00 C5 4F 00 00 60 03 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 B6 00 5B 00 00 00 00 00 \n                    00004FC5: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 03 00 57 27 00 00 C4 00 00 00 5E 00 00 00 D6 FF FF FF B1 FF FF FF 00 00 00 00 25 50 00 00 7C 77 00 00 C4 28 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C4 00 5E 00 00 00 00 00 \n                    0000777C: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 04 00 26 28 00 00 BF 00 00 00 64 00 00 00 D3 FF FF FF AA FF FF FF 00 00 00 00 DC 77 00 00 02 A0 00 00 C5 4F 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BF 00 64 00 00 00 00 00 \n                    0000A002: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 05 00 70 29 00 00 C3 00 00 00 67 00 00 00 D0 FF FF FF A6 FF FF FF 00 00 00 00 62 A0 00 00 D2 C9 00 00 7C 77 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C3 00 67 00 00 00 00 00 \n                    0000C9D2: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 06 00 DA 29 00 00 C6 00 00 00 6C 00 00 00 CF FF FF FF A2 FF FF FF 00 00 00 00 32 CA 00 00 0C F4 00 00 02 A0 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C6 00 6C 00 00 00 00 00 \n                    0000F40C: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 07 00 33 2A 00 00 C5 00 00 00 6F 00 00 00 D1 FF FF FF 9F FF FF FF 00 00 00 00 6C F4 00 00 9F 1E 01 00 D2 C9 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C5 00 6F 00 00 00 00 00 \n                    00011E9F: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 08 00 1A 2B 00 00 C0 00 00 00 6C 00 00 00 D4 FF FF FF A2 FF FF FF 00 00 00 00 FF 1E 01 00 19 4A 01 00 0C F4 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 00 6C 00 00 00 00 00 \n                    00014A19: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 09 00 59 29 00 00 BE 00 00 00 68 00 00 00 DA FF FF FF A7 FF FF FF 00 00 00 00 79 4A 01 00 D2 73 01 00 9F 1E 01 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BE 00 68 00 00 00 00 00 \n                    000173D2: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 0A 00 E5 26 00 00 B5 00 00 00 62 00 00 00 E1 FF FF FF AB FF FF FF 00 00 00 00 32 74 01 00 17 9B 01 00 19 4A 01 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 B5 00 62 00 00 00 00 00 \n                    00019B17: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 0B 00 CA 23 00 00 AB 00 00 00 5A 00 00 00 EA FF FF FF B3 FF FF FF 00 00 00 00 77 9B 01 00 41 BF 01 00 D2 73 01 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 00 5A 00 00 00 00 00 \nmountain            00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 A7 BA 00 00 37 01 00 00 D3 00 00 00 00 00 00 00 C9 FF FF FF 00 00 00 00 C0 03 00 00 67 BE 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD 00 00 00 00 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 37 01 D3 00 00 00 00 00 \n                    0000BE67: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 02 00 2B C7 00 00 3C 01 00 00 DD 00 00 00 FC FF FF FF C4 FF FF FF 00 00 00 00 C7 BE 00 00 F2 85 01 00 60 03 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 3C 01 DD 00 00 00 00 00 \nicon0               00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 2F 01 00 00 0D 00 00 00 0D 00 00 00 11 00 00 00 F9 FF FF FF 00 00 00 00 C0 03 00 00 EF 04 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 0D 00 0D 00 00 00 00 00 \nicon1               00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 2F 01 00 00 0D 00 00 00 0D 00 00 00 11 00 00 00 F9 FF FF FF 00 00 00 00 C0 03 00 00 EF 04 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 0D 00 0D 00 00 00 00 00 \nicon2               00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 2D 01 00 00 0D 00 00 00 0D 00 00 00 11 00 00 00 F9 FF FF FF 00 00 00 00 C0 03 00 00 ED 04 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 0D 00 0D 00 00 00 00 00 \nicon3               00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 26 07 00 00 26 00 00 00 26 00 00 00 05 00 00 00 ED FF FF FF 00 00 00 00 C0 03 00 00 E6 0A 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 26 00 26 00 00 00 00 00 \nback                00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 58 99 07 00 20 03 00 00 58 02 00 00 08 00 00 00 B4 FD FF FF 00 00 00 00 C0 03 00 00 18 9D 07 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 20 03 58 02 00 00 00 00 \n</code></pre>\nrevealing the structure better. I found out some things from this like frame index and the ImageData align is to <pre><code>0x0360</code></pre> instead of <pre><code>0x0370</code></pre> I assumed before this. Also <pre><code>0xCD</code></pre> pattern is present only for first frames and not at all positions. The file-format is like this:\n<pre><code>Offset              DataType                Meaning\n--------------------------------------------------------\nHeader (0x0000):\n0x0000              char[4]                 `DREK` Signature\n0x0008              DWORD                   whole file size\n0x000E              WORD                    number of frames\n0x0010              DWORD                   ImageData offset from start of file 0x0360\n0x0054              DWORD                   Palette offset from start of file 0x0060\n0x0058              DWORD                   used_colors from Palette (rest are set to (CD,CD,CD))\n--------------------------------------------------------\nPalette: (0x060)\n+0x0000             BYTE[768]               RGB palette\n--------------------------------------------------------\nImageData (0x0360)\n+0x000E             WORD                    frame 1,2,3,4,...\n+0x0010             DWORD                   sz (ImageData size - 0x60)\n+0x0014             DWORD                   xs\n+0x0018             DWORD                   ys\n+0x0060             WORD                    xs\n+0x0064             WORD                    ys\n+0x0068             DWORD[ys]               ScanLine offsets relative to end of this table (0x0068 + ys*4)\n+0x0068+(ys*4)      BYTE[sz-68-(ys*4)]      ScanLineData\n+0x0060+sz                                  Next frame ImageData if frame<frames\n</code></pre>\n\nNow finally The decoder\nThe code was written in Borlands BDS2006 C++ using VCL <pre><code>TBitmap</code></pre> and <pre><code>AnsiString</code></pre> So you need to rewrite it to your kind of gfx access and strings your programming environment supports. If you need help with the meaning of the gfx code see:\n\ngfx rendering in C++\n\nAlso File access functions may have a bit different name. I commented the code a bit but it should be obvious anyway. At least for those that already did things like this.\nThe defines just switch between debug and normal decoding. If not present then you do not need the debug image class <pre><code>img</code></pre> at all. To keep this simple and also in 30KB limit I removed the code for the debug draw class (those who want/need it look in the edit history). That means ignoring all the <pre><code>_debug_draw</code></pre> defines ...\nNow the icons defined pixels are decoded correctly. But I did a lot of assumptions and may not work on all images. I would need more examples with ScreenShots to make it more robust. The codes itself should encode alpha channel and may be also position/offset.\nI changed few codes and now I am temporarily ignoring the <pre><code>0x02</code></pre> end of <pre><code>ScanLine</code></pre> which make mess when not properly decoded codes are present. Also I added few special cases I found out. The x-offset for mode1 is also present.\nIn the code find line:\n<pre><code>// image data (decoded)\n</code></pre>\nThat is where main decoding is. The decoding variables are:\n\n<pre><code>_pixel</code></pre> - next <pre><code>BYTE</code></pre> is pixel\n<pre><code>_sequence</code></pre> - sequence of pixels follows (ending by <pre><code>0x01</code></pre> or <pre><code>0x03</code></pre> if more then 5 pixels rendered)\n<pre><code>_stop</code></pre> - end of scanline marked by <pre><code>0x02</code></pre>\n<pre><code>seq</code></pre> - just counter of how many pixels in sequence has been processed\n\nIn comments some of the codes are marked <pre><code>// OK</code></pre> those are not conflicting and straightforward. The rest of comments means what codes are following:\n\n<pre><code>pXX</code></pre> means pixel <pre><code>0xXX</code></pre>\n<pre><code>cXX</code></pre> means code  <pre><code>0xXX</code></pre>\n<pre><code>?XX</code></pre> means not sure if pixel or code\n<pre><code>?pXX</code></pre> means most likely pixel <pre><code>0xXX</code></pre>\n\nThe Transparent ScanLine data starts after first BYTE so do not skip 2 BYTEs just one !!!\nHere some previews:\n\nAnd the Dragon frames:\n\nThe C++ source for the decoder:\n<pre><code>#ifdef _debug_save\nAnsiString dbg_hdr=\"file                          K  E  R  D              file_size        frames image_ofs                                                                                                                                                                                                   palette_ofs used_colors\\r\n\";\nAnsiString dbg_img=\"                                                                        frame sz          xs          ys                                                                                                                                                                                                                      xs    ys                \\r\n\";\n#endif\nvoid load_drk(Graphics::TBitmap *bmp,AnsiString name)\n    {\n    AnsiString s,fnam;\n    fnam=name.SubString(1,name.Length()-4);\n\n    // variables\n    BYTE *dat;\n    int hnd,adr,adr0,siz;\n    int i,x,y,xs,ys,sz,mode,frame,frames;\n    DWORD *p,*dir,pal[256],r,g,b,a;\n    // allow direct pixel access\n    bmp->HandleType=bmDIB;\n    bmp->PixelFormat=pf32bit;\n    // read file into memory\n    hnd=FileOpen(name,fmOpenRead);\n    if (hnd<0) return;\n    siz=FileSeek(hnd,0,2);\n        FileSeek(hnd,0,0);\n    dat=new BYTE[siz];\n    if (dat==NULL) { FileClose(hnd); return; }\n    FileRead(hnd,dat,siz);\n    FileClose(hnd);\n    // decode\n    for (;;)\n        {\n        #ifdef _debug_save\n        // save frames to bmp\n        s=fnam+\"                    \";\n        s=s.SubString(1,20);\n        dbg_hdr+=s;\n        dbg_img+=s;\n        dbg_hdr+=\"00000000: \"; for (i=0;i<0x60;i++) { s=s.sprintf(\"%X \",dat[i]); while (s.Length()<3) s=\"0\"+s; dbg_hdr+=s; }\n        dbg_hdr+=\"\\r\n\";\n        #endif\n\n        // signature\n        if (siz<0x3C8) break;\n        if (((DWORD*)(dat))[ 0]!='DREK') break;\n        if (((DWORD*)(dat))[ 2]!=   siz) break;\n        // palette\n        for (adr=0x060,i=0;i<256;i++)\n            {\n            b=dat[adr]; adr++;\n            g=dat[adr]; adr++;\n            r=dat[adr]; adr++;\n            pal[i]=(r<<16)|(g<<8)|(b);\n            }\n        // frames\n        frames=((WORD*)(dat+0x0E))[0];\n        adr0  =((DWORD*)(dat))[4];\n        for (frame=0;frame<frames;adr0+=sz+0x60,frame++)\n            {\n            adr=adr0;\n            // resolution\n            if (adr0+0x60>siz) break;\n            sz=((DWORD*)(dat+adr))[4];\n            xs=((DWORD*)(dat+adr))[5];\n            ys=((DWORD*)(dat+adr))[6];\n            if (adr0+0x60+sz>siz) break;\n            bmp->SetSize(xs,ys);\n\n            #ifdef _debug_save\n            // save frames to bmp\n            if (frame) dbg_img+=\"                    \";\n            s=s.sprintf(\"%X: \",adr0); while (s.Length()<10) s=\"0\"+s; dbg_img+=s;\n            for (i=adr0;i<adr0+0x68;i++) { s=s.sprintf(\"%X \",dat[i]); while (s.Length()<3) s=\"0\"+s; dbg_img+=s; }\n            dbg_img+=\"\\r\n\";\n            #endif\n\n            // scanline table\n            dir=new DWORD[ys+1];\n            if (dir==NULL) break;\n            adr+=0x68;\n            for (y=0;y<ys;y++)\n             dir[y]=adr+(ys<<2)+((DWORD*)(dat+adr))[y];\n            dir[ys]=adr0+sz+0x68;\n\n            #ifdef _debug_draw\n            // set size and palette of debug image\n            img.resize(xs,ys);\n            for (i=0;i<256;i++) img.rgb_pal[i]=pal[i];\n            // copy reference data to debug image\n            for (y=0;y<ys;y++) img.p[y].ref=\"\";\n            if ((png->Height)&&(png->Width))\n                {\n                Graphics::TBitmap *qqq=new Graphics::TBitmap;\n                qqq->Assign(png);\n                qqq->HandleType=bmDIB;\n                qqq->PixelFormat=pf32bit;\n                for (y=0;(y<qqq->Height)&&(y<ys);y++)\n                    {\n                    img.p[y].ref=\"\";\n                    img.p[y].cmp=\"\";\n                    p=(DWORD*)qqq->ScanLine[y];\n                    for (x=0;(x<qqq->Width)&&(x<xs);x++)\n                        {\n                        for (a=0,b=256,g=768;a<256;a++)\n                            {\n                            r=rgb_absdistance(p[x],pal[a]);\n                            if (g>r) { g=r; b=a; }\n                            } a=b;\n                        if (g) g='1'; else g='0';\n                        img.p[y].ref+=char(BYTE(a));\n                        img.p[y].cmp+=char(BYTE(g));\n                        }\n                    }\n                delete qqq;\n                }\n            // copy encoded data to debug image\n            for (y=0;y<ys;y++)\n                {\n                adr=dir[y];\n                img.p[y].adr=adr;\n                img.p[y].enc=\"\";\n                img.p[y].dec=\"\";\n                img.p[y].spc=\"\";\n                for (;adr<dir[y+1];adr++)\n                 img.p[y].enc+=char(BYTE(dat[adr]));\n                }\n            #endif\n\n            // image data (decoded)\n            a=dat[dir[0]];\n            mode=0; if (a!=0xFC) mode=1;\n            for (y=0;y<ys;y++)\n                {\n                adr=dir[y];                     // get actual ScanLine offset in file\n                p=(DWORD*)bmp->ScanLine[y];     // get actual ScanLine pointer in bmp\n                int _sequence=0;\n                int _pixel=0;\n                int _stop=0;\n                int seq=0;\n                for (x=0;x<xs;x++) p[x]=0; x=0;\n\n                if (mode==1)\n                    {\n                    // 1st ScanLine BYTE (x-offset)\n                    a=dat[adr]; adr++;\n                    if (BYTE(a&1)==1)\n                        {\n                        x=(a>>1)+1;\n                        #ifdef _debug_draw\n                        for (i=0;i<x;i++) img.p[y].spc+='\\0';\n                        #endif\n                        }\n                    // 2nd ScanLine BYTE special cases\n                    a=dat[adr];\n                    if (a==0x0D) adr++; \n                    }\n                for (a=0;adr<dir[y+1];)\n                    {\n                    if (mode==0)\n                        {\n                        a=dat[adr]; adr++;              // color index\n                        if (int(x&31)==0)\n                            {\n                            r=a;                        // flag\n                            a=dat[adr]; adr++;          // color index\n                            }\n                        }\n                    if (mode==1) for (;;)\n                        {\n                        a=dat[adr]; adr++;              // color index\n                        if (_pixel) { _pixel=false; break; }\n                        if (_sequence) { seq++; if (seq<6) break; }\n                        // commands\n                        if (a==0x01)\n                            {\n                            a=dat[adr]; adr++;\n                            _pixel=true; _sequence=false;\n                            //if (a==0x07) { adr++; _pixel=false; }\n                            continue;\n                            }\n                        if (a==0x03)\n                            {\n                            if (!_sequence)\n                                {\n                                if (dat[adr]==0x18) _pixel=1;\n                                continue;\n                                }\n                            if (_sequence==0x2B) break;\n                            a=dat[adr]; adr++;\n                            _pixel=true; _sequence=false;\n                            //if (a==0x07) { adr++; _pixel=false; }\n                            continue;\n                            }\n                        if (_sequence) break;\n                        // unused: 0A,14,1F,20,21,22,24,25,26,28,29,2A,2C+\n                        // flag/color prefix\n    //                  if((a==0x02)&&(adr>dir[y]+3)) { _stop=true; break; }    // end of ScanLine\n                        if (a==0x04) { _pixel=1; continue; }    // ?? ?p18 p47 ?p47\n                        if (a==0x05) { _pixel=1; continue; }    // ?? ?18 ?09\n                        if (a==0x06) { _pixel=1; continue; }    // ?? ?p18 ?p47\n                        if (a==0x07) { _pixel=1; continue; }    // ?? ?18 ?46 ?47\n                        if (a==0x08) { _pixel=1; continue; }    // ?? ?09\n                        if (a==0x09) { _pixel=0; continue; }    // ?? ?p02 !!!!!!!!!!!\n                        if (a==0x0B) { _pixel=1; continue; }    // ?? ?p02\n                        if (a==0x0C) { _pixel=1; continue; }    // OK p1D\n                        if (a==0x0D)                            // ?? c04 p23 ?c06 p05 p12\n                            {\n                            _pixel=0;\n                            if (dat[adr]==0x02) _pixel=1;\n                            if (dat[adr]==0x05) _pixel=1;   // p47 c0D p05 | c0D c05 p09\n                            if (dat[adr]==0x12) _pixel=1;\n                            if (dat[adr]==0x23) _pixel=1;\n                            continue;\n                            }\n                        if (a==0x0E) { _pixel=1; continue; }    // OK p24 p26 p16\n                        if (a==0x0F) { _pixel=1; continue; }    // OK p0F\n                        if (a==0x10) { _pixel=1; continue; }    // OK p04\n                        if (a==0x11) { _pixel=1; continue; }    // ?? ?p02\n                        if (a==0x12) { _pixel=1; continue; }    // OK p27\n                        if (a==0x15) { _pixel=1; continue; }    // OK p16\n                        if (a==0x16) { _pixel=1; continue; }    // OK p16\n                        if (a==0x18) { _pixel=1; continue; }    // OK p00 p02\n                        if (a==0x19)                            // ?? p1B\n                            {\n                            _pixel=1;\n                            if (dat[adr]==0x01) _pixel=0;\n                            continue;\n                            }\n                        if (a==0x1A) { _pixel=1; continue; }    // OK p05 p04\n                        if (a==0x1B) { _pixel=1; continue; }    // OK p1F\n                        if (a==0x1C) { _pixel=1; continue; }    // OK p10\n                        if (a==0x1D) { _pixel=1; continue; }    // OK p33 p1E p14\n                        if (a==0x1E) { _pixel=1; continue; }    // OK p34 p50 p13\n\n                        // test from dragon and mountain\n                        if (a==0x49) { _pixel=1; continue; }    // ?? ?p02\n                        if (a==0xE3) { _pixel=1; continue; }    // ?? p18\n                        if (a==0xD7) { _pixel=1; continue; }    // ?? pBC\n                        if (a==0xDA) { _pixel=1; continue; }    // ?? ?p02\n\n                        // sequence start\n                        if (a==0x13) { seq=0; _sequence=a; } // 03\n                        if (a==0x17) { seq=0; _sequence=a; } // 01\n                        if (a==0x23) { seq=0; _sequence=a; } // 01 03\n                        if (a==0x27) { seq=0; _sequence=a; } // 01\n                        if (a==0x2B) { seq=0; _sequence=a; } // 01 !03 03\n                        if (_sequence)\n                            {\n                            if (adr==dir[y]+3) { _sequence=false; break; }\n                            continue;\n                            }\n                        break;\n                        }\n                    if (_stop) break;\n                    if (x>xs) break;\n                    if ((mode==1)&&((a==0xFE)||(a==0xFF))) { a=dat[adr]; adr++; }   // shadows?\n\n                    if ((x>=0)&&(x<xs)) p[x]=pal[a]; x++;\n                    #ifdef _debug_draw\n                    // copy decoded data to debug image\n                    img.p[y].dec+=char(BYTE(a));\n                    #endif\n                    }\n                }\n            delete[] dir; dir=NULL;\n            #ifdef _debug_save\n            // save frames to bmp\n            s=frame;\n            while (s.Length()<3) s=\"0\"+s;\n            png->Assign(bmp);\n            png->SaveToFile(\"decoded_\"+fnam+\"_\"+s+\".png\");\n            #endif\n            }\n        img.compute();\n        break;\n        }\n    delete[] dat;\n    }\n</code></pre>\n",
            "votes": "24",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">The comments have been <a href=\"http://chat.stackexchange.com/rooms/44406/discussion-on-answer-by-spektre-decoding-an-unknown-image-format-with-drek-sig\">moved to chat</a>; please do not use comments for extended discussions.</span>",
                    "time": null
                }
            ]
        }
    ]
}