{
    "title": "An issue when unpacking UPX",
    "link": "https://reverseengineering.stackexchange.com/questions/5889/an-issue-when-unpacking-upx",
    "content": "Since I love to play with the WinAPI or debugging in general, I decided to write a small unpacker for the open source PE executable packer UPX today (Windows version).\nIn order to accomplish this, I proceeded as follow:\n\n<pre><code>CreateProcess</code></pre> API all with <pre><code>DEBUG</code></pre> and <pre><code>DEBUG_ONLY_THIS_PROCESS</code></pre> flags.\n<pre><code>GetThreadContext</code></pre> API call in order to read value of <pre><code>EIP</code></pre>.\n<pre><code>ReadProcessMemory</code></pre> API call loop searching for the last <pre><code>JMP</code></pre> instruction.\nOverwriting the <pre><code>E9</code></pre> with <pre><code>CC</code></pre> in order to set an <pre><code>INT3</code></pre> breakpoint on the address.\nEntering <pre><code>DebugEvent</code></pre> loop waiting for the breakpoint. Once reached, reset byte back to <pre><code>E9</code></pre>, decrease <pre><code>EIP</code></pre> by one and jump to the address (<pre><code>OEP</code></pre>) of the target.\n\nAfter reaching the <pre><code>OEP</code></pre>, I proceed as follows in order to dump the process:\n\nRead ImageBase, Base of code, ImageSize, ... from original PE headers\n<pre><code>ReadProcessMemory(hProcess, header32.ImageBase, buffer, header32.SizeOfImage, bytes_read)</code></pre>\nSave buffer content to payload.bin, update the PE header of the file with new EntryPoint (<pre><code>OEP</code></pre>) and set <pre><code>RawDataOffset</code></pre> and <pre><code>RawDataSize</code></pre> of each section to its corresponding <pre><code>VirtualAddress</code></pre>/<pre><code>VirtualSize</code></pre>.\n\nAfter creating the dump with fixed <pre><code>OEP</code></pre> & RAW offsets/sizes for the sections, I fix the dump with ImpREC (right now manually, but I plan to use <pre><code>ImpREC.dll</code></pre> or the ImpREC lite source in order to assemble everything in one tool at a later point).\nThe thing that confuses me though, is the fact, that the resulting binaries worked perfectly fine (exact match with the MUP) for one test case (a small hello world fasm application) and my dump file was exactly the same I had received through OllyDump, but when I tried to do the same unpacking with an UPX packed version of <pre><code>putty.exe</code></pre>, my dumped memory varied from the one OllyDump had dumped starting at RAW offset <pre><code>0x73970</code></pre> (exact match before that address). \nHowever - the file size is again the same one (and all bytes before that offset match), just after that certain address the bytes magically won't match anymore (they are still non-zero though).\nI studied the source code in <pre><code>OllyDump.c</code></pre> thoroughly regarding this difference, but as for now I didn't find my mistake... In some cases my dumps are equal to the ones generated by OllyDump and in some they aren't. Or is the mistake probably in my approach already?\nNote: Source code omitted on purpose, since it's a few hundred lines long and super messy as for now. Can/will add further details if required or if I missed something, please just let me know in the comments.\n",
    "votes": "4",
    "answers": 1,
    "views": "1k",
    "tags": [
        "unpacking",
        "dumping",
        "upx"
    ],
    "user": "beta",
    "time": "Jul 18, 2014 at 20:28",
    "comments": [],
    "answers_data": [
        {
            "content": "Hard to tell what the reason for the differences might be without actually seeing the differences, but one guess is that you're doing <pre><code>ReadProcessMemory(hProcess, header32.ImageBase, buffer, header32.SizeOfImage, bytes_read)</code></pre>, while the other tool may be doing <pre><code>foreach(section) {ReadProcessMemory(hProcess, header32.ImageBase + section.RVA, buffer, section.VirtualSize, bytes_read)}</code></pre>; this may cause the \"caves\" between sections to differ.\n(BTW, I assume your <pre><code>header32.ImageBase</code></pre> is the actual base address of the module in memory, not just the image base address from the PE headers, since ASLR could relocate it at runtime.)\n",
            "votes": "1",
            "user": "Jason Geffner",
            "time": "Jul 18, 2014 at 14:03",
            "is_accepted": true,
            "comments": [
                {
                    "user": "beta",
                    "text": "<span class=\"comment-copy\">Thank you I gotta check this out next week (forgot my laptop at the office).</span>",
                    "time": null
                }
            ]
        }
    ]
}