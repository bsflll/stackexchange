{
    "title": "Packers/Protectors for Linux",
    "link": "https://reverseengineering.stackexchange.com/questions/3184/packers-protectors-for-linux",
    "content": "I was wondering if anyone had come across a packer/protector which could be used for ELF binaries. There seem to be quite a few articles on writing packers and protectors for the PE format -- however, there don't seem to be very many for Linux.\nThis is just a hobby and so far I've come across1 which is seems to be a very basic(but neat) introduction to SMC.\nAre there any resources/source code that you could point me to that I could refer and learn from?\n",
    "votes": "6",
    "answers": 3,
    "views": "12k",
    "tags": [
        "linux",
        "elf",
        "packers"
    ],
    "user": null,
    "time": "Dec 14, 2013 at 22:16",
    "comments": [],
    "answers_data": [
        {
            "content": "Apart from the classix UPX, you should take a look at Burneye (With its crackers, UNFburninhell and Burndump) and elfuck. They are pretty old, but still interesting.\nIf you are interested about tricks that can be used, this is a good introduction by aczid, and I would also recommend Binary protection schemes for a more complete overview. \nSomeone also presented a CanSecWest a packer named Shiva that was broken at Blackhat. Unfortunately, there is no sources available.\n",
            "votes": "8",
            "user": "jvoisin",
            "time": "Dec 14, 2013 at 19:12",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Krypton",
                    "text": "<span class=\"comment-copy\">any update on this list? Except UPX, those listed are really old and not maintained.</span>",
                    "time": null
                },
                {
                    "user": "jvoisin",
                    "text": "<span class=\"comment-copy\">Feel free to write your own if you're impatient ;)</span>",
                    "time": null
                },
                {
                    "user": "Rui F Ribeiro",
                    "text": "<span class=\"comment-copy\">Unfortunately many of the links above seem not to be working anymore.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "Click on the tool names to download. Some will be source code only, others binary only. Use at your own risk.\n\nThere are 4 sections: \n\nexperimental designs, which were developed to advance the state of the art in ELF binary protection or for research purposes\ntools resulting from personal projects or created for fun/as a hobby\nhistorically relevant protectors, now cracked/deprecated\nmodern protectors - those known at the time of writing to be used out in the \"real world\", so to speak (outside of academia - in malware for example).\n\n\nExperimental / Proof of Concept\n\n<pre><code>dacryfile</code></pre> (2001)\nphrack article: Armouring the ELF: Binary encryption on the UNIX platform\n\nDacryfile is a collection of tools which implement the following concept.\n  The host file is encrypted from the start of the <pre><code>.text</code></pre> section, to the end\n  of the <pre><code>.text</code></pre> segment. The file now has its object code and its read only\n  data protected by encryption, while all its data and dynamic objects are\n  open to inspection. The host file is injected with a parasite that will\n  perform the runtime decryption. This parasite can be of arbitrary size\n  because it is appended to the end of the <pre><code>.data</code></pre> segment. \n\n\"Parasite code\" refers to code inserted into the either the file on disk or the process image in memory in order to change the runtime behavior of the program. Various techniques that were historically used to accomplish this kind of code insertion are discussed in Silvio Cesare's article Unix Viruses (1999)\nThe mechanism by which the parasite code appended to the ELF binary containing the encrypted code accomplished is referred to by the grugq as \"subversive dynamic linking\":\n\nThe parasite itself is fairly simple, utilising the subversive dynamic\n  linking Linux library to access libc functions, and rc4 to decrypt the host.\n\nThis technique was detailed in his article Cheating the ELF, in which parasite code written to a dynamically linked executable to is able to make calls to library functions essentially by searching through the process's <pre><code>proc/self/maps</code></pre> file for <pre><code>glibc</code></pre>'s shared object loading and unloading functions to then load the libraries of interest.\n\n\n\n<pre><code>shiva 0.96</code></pre> (2003) (binary only (protected))\n\nIntroduction Presentation\nDefeat Presentation\nImplements the following features:\n\nOuter obfuscation layer to thwart static analysis\nAES encrpyted, password protected middle layer\nInner encrypted layer consisting of crypt blocks which may be memory-mapped on demand\nTRAP flag detection to prevent single-stepping\nforks and then the processes <pre><code>ptrace()</code></pre> each other, which prevents PTRACE_ATTACH\njumps into the middle of instructions\ncatches SIGTRAP\ntiming checks\nINT3 instruction replacement\n\nOutside of these presentations, it has been difficult to find additional information besides some discussion in <pre><code>phrack</code></pre> articles on ELF runtime encryption/decryption. No source code is available, only the binary, which is protected.\n\n\n\n\n<pre><code>cryptexec</code></pre> (2005)\nphrack article: cryptexec: Next-generation runtime binary encryption using on-demand function extraction. The source code is included at the end.\nHere runtime decryption is accomplished through a combination of a tracing function that uses a private stack, a disassembler and code emulation to read blocks of 24 bytes are read, decrypted, disassembled and then emulated. This ensures that no more than 24 bytes of unencrypted program code reside in memory while decrypting and executing the protected code.\n\nThe tracing routine maintains two contexts: the traced context and\n  its own context. The context consists of 8 32-bit general-purpose\n  registers and flags. Other registers are not modified by the routine.\n  Both contexts are held on the private stack (that is also used for\n  calling C).\nThe idea is to fetch, one at a time, instructions from the traced \n  program and execute them natively. Intel instruction set has rather \n  irregular encoding, so the XDE [5] disassembler engine is used to find \n  both the real opcode and total instruction length. During experiments on \n  FreeBSD (which uses LOCK- prefixed MOV instruction in its dynamic loader) \n  I discovered a bug in XDE which is described and fixed below.\nWe maintain our own EIP in traced_eip, round it down to the next lower\n  8-byte boundary and then decrypt 24 bytes into our own buffer.  Then\n  the disassembly takes place and the control is  transferred to emulation\n  routines via the opcode control table.  All instructions, except control\n  transfer, are executed natively (in traced context which is restored at\n  appropriate time).  After single instruction execution, the control is\n  returned to our tracing routine.\n\n\n\n\n<pre><code>CSPIM</code></pre> (2010)\nAlso developed by Vrba (the designer of the aforementioned <pre><code>cryptexec</code></pre>), and presented in the paper Program Obfuscation by Strong Cryptography (the paper is paywalled but the code is on github and the Vrba's site):\n\n...we present a program obfuscation method that is based on the combination of strong encryption of code and data and a CPU simulator(CSPIM) that implements the MIPS I instruction set. Our method is different from existing methods in that only a single word (32-bits) of the protected code or data is present as plain-text in main memory. Furthermore, our method allows the possibility of externally supplying the decryption key to the simulator. \n\n\nThe above diagram is from Enhancements to a virtual machine based code\nencryptor (no code available for this paper as far as I know).\n\n\nPersonal Projects\n\n<pre><code>cryptelf</code></pre> (2003) by SLACKo\nModifies binary by appending code to handle runtime decryption, changing the program entry point and changing the <pre><code>.note</code></pre> segment to <pre><code>LOAD</code></pre>. Encrypts the <pre><code>.text</code></pre> section by XORing its bytes with a key. \n\n\n\n<pre><code>ELF Encrypter</code></pre> - Last update: 2013-03-12\nAppears to rely on classical runtime code injection or parasite code techniques to accomplish runtime decryption.\n\nThe encrypted file (generated by the <pre><code>crypt-7lib program</code></pre>) will be decrypted at runtime by a shared library, directly linked to the binary or listed in<pre><code>LD_PRELOAD</code></pre>, during its initialization routine. The suite also contains programs to inject plain and encrypted code into ELF binaries.\nELF-Encrypter 0.12\n\nchanged the data segment infection technique\nadded the code to correct section table offsets\n\n\n\n\n\nps2-packer (2013)\nBased on UPX.\n\nJust like UPX this tool is designed to help you\n  create packed ELF to run on the PS2. It has a modular design, so anybody can\n  write any kind of module to it. It actually has a zlib module, a lzo module,\n  three ucl modules (n2b, n2d and n2e) and a null module, for demo purpose only.\n\n\n\n\nmidgetpack (2014)\n\nMidgetpack contains two modes of operation: password and curve25519 key exchange.\nThe curve25519 is the real advantage of midgetpack. In this mode, you do not\n  provide any password or key. Instead, a key file is generated at packing time.\n  This key file must be used everytime you wish to use the binary. When you start\n  the binary, it will give a challenge and expect a response. You copy/paste the\n  challenge in the input of the mpkex tool and receive a response containing the\n  encrypted key to the binary.\n  This key exchange is protected by Curve25519 key exchange, the key is encrypted\n  with aes-128 and the whole exchange is authenticated with HMAC-SHA256 to avoid\n  generic man-in-the-middle attacks.\n\n\n\n\n<pre><code>oplzkwp</code></pre> (2015)\n\noplzkwp is a library for ELF obfuscation. It uses PRESENT and blake244 to encrypt your payload on the fly. Only the functions that are currently executed are decrypted in memory. Both Linux (x86) and Android (ARM) are supported.\n\n\n\n\npocrypt (2015)\n\nProof of Code to demonstrate how to crypt parts of a binary. The modified binary is extended with a small function that decrypts the secured parts of the file at run-time to enable its execution.\n\n\n\n\n<pre><code>ELF-Packer</code></pre> (2017)\nSimple tool developed as a homework assignment. It uses parasite code inserted into a code cave to perform runtime XOR obfuscation or de-obfuscation of a target binary's <pre><code>.text</code></pre> section. The details are discussed in Simple Polymorphic x86-64 Runtime Code Segment Crpytor.\n\n\n\nELFcrypt (2018)\n\nSimple ELF crypter. Uses RC4 encryption.\n\n\n\n\nRyan O'Neill's (@ryan_elfmaster) experiments. These may have research value:\n\n\nELF Packer v0.3 (2009)\nsherlocked (2014)\ndavinci (2015)\nsaruman (2018)\n\n\n\nHistorical\n\n<pre><code>burneye</code></pre> (v1) by the Teso group (2002)\nThe following summary is given in cryptexec: Next-generation runtime binary encryption using on-demand function extraction (more information is included in burneye's documentation):\n\nSimilarly to Shiva, it has three layers: 1) obfuscation, 2) password-based encryption using RC4 and SHA1 (for generating the key from passphrase), and 3) the fingerprinting layer.\nThe fingerprinting layer is the most interesting one: the data about the\n  target system is collected (e.g. amount of memory, etc..) and made into\n  a 'fingeprint'. The executable is encrypted taking the fingerprint into\n  account so that the resulting binary can be run only on the host with the\n  given fingerprint. There are two fingerprinting options:\n\nFingeprint tolerance can be specified so that Small deviations are\n  allowed. That way, for example, the memory can be upgraded on the\n  target system and the executable will still work. If the number of\n  differences in the fingeprint is too large, the program won't work.\nSeal: the program produced with this option will run on any system.\n  However, the first time it is run, it creats a fingerprint of the\n  host and 'seals' itself to that host. The original seal binary is\n  securely deleted afterwards.\n\nThe encrypted binary can also be made to delete itself when a certain\n  environment variable is set during the program execution.\n\n\n\n\n<pre><code>objobf</code></pre> aka burneye2 (2003)\n\nIt reads one ELF relocateable object file and\n  produces a functional equivalent output file, which is an obfuscated version\n  of the input file. To do this, <pre><code>objobf</code></pre> breaks up all functions in the file to the basic block level. This representation is used to mutate the code while keeping it semantically equivalent. This involves dataflow analysis and basic block transformations. Afterwards, the basic block representation as control flow graph is linearized into a new object file, which is created from scratch.\n\n\n\n\nelfuck\nImplements executable compression as well as encryption. Based on UPX and <pre><code>burneye</code></pre>.\n\n\nELFuck uses excellent Markus F.X.J. Oberhumer's compression algorithm,\n  NRV2E which carries very good compression with tiny decompressor\n  (about 128 bytes!). This algorithm family is stolen from UPX, with\n  difference in that decompression is done in real time; ELFuck will\n  decompress ELF directly to .text/.data segment and executes authentic\n  ELF image from there, on other hand, UPX creates original ELF in /tmp\n  and execve() it, so that we don't need any writeable filesystem at all.\n\n\nBecause ELFuck is 100%-ly based on stolen ideas, I also implemented\n  this one of BurnEye. Someone may like to disallow other users to\n  use/analyse your binary (public shells, root browsing user's homes).\n  The algorithm is kinda simple, but seems to be pretty effective:\n  We'll select some password; expand it using sha1 to 160 bit key.\n  by this key we'll encrypt, using RC4 algorithm, whole binary\n  (except the decrypting stub, of course). We'll also keep\n  last 32bits of sha1 against original binary, in order to check password.\n  When someone will execute such protected binary; the stub will ask for\n  password, make hash of it and try to decrypt the binary back using\n  this key. Then we'll make a hash of potentially decrypted binary,\n  check it against the value we've saved while creating, and if matches,\n  the binary is decrypted correctly (=right password) and we'll let it\n  run.   \n\n\n\nModern\nThe majority of modern ELF binaries are protected using UPX or a variant thereof. 1,2\n\nThe simplest variation of the UPX packer used out in the wild is the 'LSD' packer, in which the string 'UPX' is changed to 'LSD'. An example of this was a XMR coin miner written in Go which targeted systems running Jenkins. \n\n\n\n<pre><code>mumblehard</code></pre> custom protector - not based on UPX\n\nThe whole packer actually consists of about 200 assembly instructions.\n  Another notable observation: system calls are made directly by using <pre><code>int 80h</code></pre> instructions. Another hint that it was written in assembly is that functions do not have the usual prologue to manage the stack. By doing system calls with interrupts, Mumblehard ELF binaries avoid any external dependency.\n  Furthermore, the packer works on both Linux and BSD systems. 1\n\nsamples:\n\n20b567084bcc6bd5ac47b2ab450bbe838ec88fc726070eb6e61032753734d233\n78c19897d08e35c0e50155c87f501e20f2d1dbfd38607fc8e12711d086d52204\n84dfe2ac489ba41dfb25166a983ee2d664022bbcc01058c56a1b1de82f785a43\n747d985d4bd302e974474dc9ab44cb1f60cb06206f3639c5d603db94395b877b\n9512cd72e901d7df95ddbcdfc42cdb16141ff155e0cb0f8321069212e0cd67a8\na5915c3060f5891242514b7899975393ef3d3cb87b33b6a767cffce4feac215f\n\n\n\n\na variant of <pre><code>tiny XMR mooner</code></pre> uses a custom packer according to the r2con 2018 presentation Unpacking the Non-Unpackable. \n\n8a0d9c84cfb86dd1f8c9acab87738d2cb82106aee0d88396f6fa86265ff252dd \nmd5sum from presentation: <pre><code>4f1fdacaee8e3c612c9ffbbe162042b2</code></pre>\nNote this particular file was the subject of The “Tiny XMR mooner” Linux cryptominer malware (the sha256 sum is identical) but no mention is made in this analysis of packing or any other form of binary protection.\n\n\n\n\n<pre><code>Linux/Tsunami</code></pre> with custom packer\n\n\nMalshare sample\nf22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863 (Virustotal)\nthere used to be an analysis available at pwning.fun but it looks like its been taken down.\n\n\n\nAdditional Information\nA taxonomy of self-modifying code for obfuscation (2011) concisely summarizes some of these tools and discusses a variety of obfuscation techniques.\nReferences\n\nUnderstanding Linux Malware\nModern Linux Malware Exposed\nUnboxing Linux/Mumblehard (2015) - ESET\n",
            "votes": "1",
            "user": "julian",
            "time": "Aug 11, 2019 at 5:47",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "UPX is an open-source packer that works on ELF binaries.\n",
            "votes": "0",
            "user": "Jason Geffner",
            "time": "Dec 14, 2013 at 15:05",
            "is_accepted": false,
            "comments": []
        }
    ]
}