{
    "title": "What causes the need for NOP sleds?",
    "link": "https://reverseengineering.stackexchange.com/questions/16706/what-causes-the-need-for-nop-sleds",
    "content": "So when taking a simple scenario and exploiting a stack buffer overflow in which I can execute code on the stack, my payload simply is:\n<pre><code>NOP Sled -> Shellcode -> Padding -> New RET Address (Pointing to the NOP Sled)\n</code></pre>\nWhat I get is that we need to have a memory address included in the shellcode which points somewhere into the NOP Sled, which we need because we \"can't be sure\" what the return address is.\nWhy can't we be sure?\nCould it be simple things such as argv[0] being different, eg. on one system the file might be \"/vuln\" and on another \"/home/user/vuln\" and for this reason the stack is already different?\nDo environment Variables play a role? What else is involved?\nBasically my question is: Which factors lead to the stack being different every time we execute / executing the vuln program on another machine?\n",
    "votes": "14",
    "answers": 2,
    "views": "4k",
    "tags": [
        "memory",
        "buffer-overflow",
        "security"
    ],
    "user": "L. Heldt",
    "time": "Nov 4, 2017 at 12:57",
    "comments": [],
    "answers_data": [
        {
            "content": "On modern systems the most obvious culprit is probably address space layout randomization, but stack frame layout variablity was problematic for exploit development even before ASLR became widely implemented. This was alluded to in AlephOne's venerable \"Smashing the Stack for Fun and Profit\":\n\n\nThe problem we are faced when trying to overflow the buffer of another\n  program is trying to figure out at what address the buffer (and thus our\n  code) will be.  The answer is that for every program the stack will\n  start at the same address.  Most programs do not push more than a few hundred or a few thousand bytes into the stack at any one time.  Therefore by knowing where the stack starts we can try to guess where the buffer we are trying to overflow will be.\n\n\nTrying to guess the\n  offset even while knowing where the beginning of the stack lives is nearly\n  impossible.  We would need at best a hundred tries, and at worst a couple of thousand.  The problem is we need to guess exactly where the address of our code will start.  If we are off by one byte more or less we will just get a segmentation violation or a invalid instruction.  One way to increase our chances is to pad the front of our overflow buffer with NOP instructions.\n\n\nSo this is an issue even without ASLR enabled. Reasons for this involve the following (as far as I know):\n\ncompilers/compiler toolchains and the ABI\nthe runtime environment\n\nCompilers, the ABI and Stack Frame Layout\nInterestingly, the code that manages the runtime stack is generated by the compiler and the compiler cannot know what the absolute positions of stack frames during program runtime will be:\n\nWhile the location of a stack frame cannot be predicted at compile time (the compiler cannot in general tell what other frames may already be on the stack), the offsets of objects within a frame usually can be statically determined. Moreover, the compiler can arrange (in the calling sequence or prologue) for a particular register, known as the frame pointer to always point to a known location within the frame of the current subroutine. Code that needs to access a local variable within\n  the current frame, or an argument near the top of the calling frame, can do so by adding a predetermined offset to the value in the frame pointer.1\n\nThe way in which memory is allocated and deallocated for stack frames can vary across compilers, as well as different versions of the same compiler toolchain. Why this might be the case is alluded to in the System V i386 Architecture Processor Supplement (page 36):\n\n\nThe stack is word aligned. Although the architecture does not require any alignment of the stack, software convention and the operating system\n  requires that the stack be aligned on a word boundary.\n\nBy default, GCC aligns the stack to a 16-byte boundary on i386 machines (x86):\n\n<pre><code>-mpreferred-stack-boundary=num</code></pre>\n  Attempt to keep the stack boundary aligned to a 2 raised to <pre><code>num</code></pre> byte boundary. If <pre><code>-mpreferred-stack-boundary</code></pre> is not specified, the default is 4 (16 bytes or 128 bits).\n\nThis means that even if a local variable or argument to a function is 4 bytes in length (such as  an<pre><code>int</code></pre>), at least 16 bytes of space will be allocated on the stack frame for that function. Since this is a command line argument for <pre><code>gcc</code></pre>, it goes without saying that this can be changed.\n\nOther areas depend on the compiler and the code being compiled. The standard calling sequence does not define a maximum stack frame size, nor does it restrict how a language system uses the ‘‘unspecified’’ area of the standard stack frame.\n\nThis \"unspecified\" area of a stack frame includes all of the frame except for the return address and the saved base pointer of the previous frame:\n\nThe data written to this area can include saved registers, local variables, temporaries, and arguments to the next function2. GCC will allocate memory required to store this data in a frame plus space required to maintain stack alignment to the boundary specified when the binary was compiled:\n\n\nHere is how all of this ties together:\n\nIt cannot be determined prior to run time what the absolute virtual memory addresses of data on the stack will be, so indirect addressing is used instead (using <pre><code>%ebp</code></pre> and <pre><code>%esp</code></pre> to calculate offsets, for example). However, to control EIP an absolute memory address of executable instructions must be written to EIP. So now one must figure out what this address is without having absolute addresses to work with when disassembling the binary\nThe precise layout of a stack frame, and by extension the runtime stack, is determined by the compiler used to create the binary one seeks to exploit. \n\nThis means that the amount of space allocated to variables such as buffers depends at the very least on the boundary to which the compiler aligns stack frames (4 bytes? 8 bytes? 16 bytes? and so on). \nThis can lead to \"slack space\" in stack frames to which no values associated with local variables are written (contains garbage data). \nIn addition to this, the compiler also determines in what order variables are laid out within the stack frame. \nCompilation with optimization can have adverse effects on calling conventions specified in the architecture-specific ABI and how stack frames are laid out\nCompilation with stack protection will further influence how data is arranged within stack frame by the compiler\n\n\nIn sum, the offset between the buffer being overflowed and the target return address location can vary based on compiler toolchain (GCC, TCC, MSVC, etc), compiler version (3.x, 4.x etc) and the particular options used to compile the binary (alignment value, optimization level, stack protection, etc):\n\nThe exact distance between the return address and the start of the [buffer] can change due to different compiler versions and different optimization flags. As long as the start of the buffer is aligned with DWORDs on the stack, this mutability can be accounted for by simply repeating the return address many times. This way, at least one of the instances will overwrite the return address, even if it has shifted around due to compiler optimizations.3\n\nThe Runtime Environment\nIt has been suggested elsewhere that stack layout indeterminicy can be caused by environmental variables and program arguments:\n\nExploit development can lead to serious headaches if you don't adequately account for factors that introduce non-determinism into the debugging process. In particular, the stack addresses in the debugger may not match the addresses during normal execution. This artifact occurs because the operating system loader places both environment variables and program arguments before the beginning of the stack\n\nThis makes sense if we look at how the stack is laid out in virtual memory:\n\nIf there are differences across executions in the environment or arguments, the location of the base of the stack may change as well.\nTo show that this is not simply idle speculation, we can look at a concrete example. First, we disable ASLR like so:\n<pre><code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></pre>\nThen we write a quick program in C:\n<pre><code>#include <stdio.h>\n\nint test(int a, int b)\n{\n        printf(\"%p\n\", &a);\n        return a*a + b*b;\n}\n\nint main(void)\n{\n        return test(3, 5);\n}\n</code></pre>\nWhen compiled and then run a few times with steadily increasing argument lengths, it is observed that the position on the stack of one of the local variables changes to lower and lower in virtual memory:\n<pre><code>$ gcc -m32 simple.c -o simple\n$ ./simple \n0xffffd210\n$ ./simple AAAAAAAA\n0xffffd200\n$ ./simple AAAAAAAAAAAAAAAA\n0xffffd200\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1f0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1f0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1e0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1e0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1d0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1d0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1c0\n</code></pre>\nThis indicates that changing the sizes of the arguments passed to <pre><code>execve</code></pre> also changes the position of the runtime stack in virtual memory. The weakness of this extremely trivial example is that it does not accurately reflect the complexity of real-world programs or capture how the runtime stack changes throughout execution of more complex processes. \nAn additional variable influencing the layout of the runtime stack is whether the binary is dynamically linked or not. If it is dynamically linked, process startup is handled by <pre><code>glibc</code></pre>. On x86 Linux systems the C runtime library function call sequence looks similar to this: \n\nThis will depend on what version of <pre><code>glibc</code></pre> the binary is linked against, and the runtime environment will vary across machines. This means that the function call sequence during process startup will vary across systems as well.\n\nSee also:\n\nhttps://www.win.tue.nl/~aeb/linux/hh/hh-10.html\nhttps://www.win.tue.nl/~aeb/linux/hh/bof-eng.txt\nhttps://0xax.gitbooks.io/linux-insides/content/Misc/program_startup.html\n\n\n1. Scott, Michael L. Programming Language Pragmatics. 3rd ed. Page 117\n2. Bryant, O'Hallaron. Computer Systems: A Programmer's Perspective. 2nd ed. Page 220\n3. Erickson, Jon. Hacking: The Art of Exploitation. 2nd ed. Page 136\n",
            "votes": "11",
            "user": "julian",
            "time": "Nov 5, 2017 at 23:16",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "As you mentioned, many things can leave you with a different memory layout than the one you expect: \n\nThe name of the binary is one.\nThe environment variables the binary gets is another one.\nIf it's being debugged (related to the previous point)\nSecurity measures such as stack cookies\nEtc\n\nUsing hardcoded addresses pointing to the stack as the address that will be taken by <pre><code>EIP</code></pre> is the wrong approach. That's how it was done in the early days. Sketchy approach and no DEP/NX in place.\nA more stable approach is that instead of jumping to the middle of the stack, you can directly jump to code that will get executed. There are different techniques to do so such as return-to-libc/library or ROP.\nAnother simpler approach is checking where your registers point in the moment when the overflow happens (actually, when the segfault is triggered). Imagine that <pre><code>ESP</code></pre> points to 0x12345678. If you have control of the contents of 0x12345678 at the moment of the segfault in a stable way, you can just use the address of a <pre><code>JMP ESP</code></pre>-kind instruction as what will be taken by <pre><code>EIP</code></pre>.\n\nWhy is this approach better?\n\nBecause you are certain that the binary itself or the libraries that get loaded (therefore, their instructions) when the binary is executed will always be stored in the same address. (1) \nLong story short, the motto goes by... \"If your exploit contains <pre><code>NOP</code></pre>s, you are doing something wrong!\". \nTo answer the question in your title, there is no need for NOP sleds.\n\nAs far as there's no ASLR or module re-base.\n",
            "votes": "1",
            "user": "newlog",
            "time": "Nov 4, 2017 at 17:21",
            "is_accepted": false,
            "comments": []
        }
    ]
}