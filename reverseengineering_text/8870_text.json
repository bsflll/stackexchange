{
    "title": "Extracting arguments from IDA",
    "link": "https://reverseengineering.stackexchange.com/questions/8870/extracting-arguments-from-ida",
    "content": "Let's say I have the following function in IDA:\n<pre><code>int __usercall function<eax>(char* message<ebp>, unsigned int count<edi>)\n</code></pre>\nWhat's the fastest way to extract the argument information using IDAPython, such that I get the following:\n<pre><code>[['char*', 'message', 'ebp'],['unsigned int','count','edi']]\n</code></pre>\nNot that it also needs to handle situations like:\n<pre><code>void *__usercall sub_4508B0@<rax>(void *(__usercall *function)@<rax>(int one@<eax>)@<rax>);\n</code></pre>\nWhich should give me something along the lines of:\n<pre><code>[['void * ...', 'function', 'rax']]\n</code></pre>\n",
    "votes": "10",
    "answers": 2,
    "views": "6k",
    "tags": [
        "ida",
        "disassembly",
        "idapython",
        "python"
    ],
    "user": "Zach Riggle",
    "time": "May 12, 2015 at 7:32",
    "comments": [],
    "answers_data": [
        {
            "content": "I received an answer from HexRays support which has a solution which does not rely on parsing the C string retrieved by <pre><code>GetType(ea)</code></pre>.\nLet's imagine we start with a function prototype:\n<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n</code></pre>\nThat's from an ELF file, x86 abi; stuff is passed on the stack.\nThen, I can do the following:\n<pre><code>Python>from idaapi import *\nPython>tif = tinfo_t()\nPython>get_tinfo2(here(), tif)\nTrue\nPython>funcdata = func_type_data_t()\nPython>tif.get_func_details(funcdata)\nTrue\nPython>funcdata.size()\n3\nPython>for i in xrange(funcdata.size()):\nPython>    print \"Arg %d: %s (of type %s, and of location: %s)\" % (i, funcdata[i].name, print_tinfo('', 0, 0, PRTYPE_1LINE, funcdata[i].type, '', ''), funcdata[i].argloc.atype())\nPython>\nArg 0: argc (of type int, and of location: 1)\nArg 1: argv (of type const char **, and of location: 1)\nArg 2: envp (of type const char **, and of location: 1)\n</code></pre>\nNote that it tells me the location type is <pre><code>1</code></pre>, which corresponds\nto 'stack':\nhttps://www.hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\nNow, let's assume I change the prototype to this:\n<pre><code>.text:0804ABA1 ; int __usercall main@<eip>(int argc@<eax>, const char **argv@<esp>, const char **envp@<edx>)\n</code></pre>\nThen:\n<pre><code>Python>get_tinfo2(here(), tif)\nTrue\nPython>tif.get_func_details(funcdata)\nTrue\nPython>for i in xrange(funcdata.size()):\nPython>    print \"Arg %d: %s (of type %s, and of location: %s)\" % (i, funcdata[i].name, print_tinfo('', 0, 0, PRTYPE_1LINE, funcdata[i].type, '', ''), funcdata[i].argloc.atype())\nPython>\nArg 0: argc (of type int, and of location: 3)\nArg 1: argv (of type const char **, and of location: 3)\nArg 2: envp (of type const char **, and of location: 3)\n</code></pre>\nArgument location type is <pre><code>3</code></pre> now, which corresponds to 'inside\nregister'.\n(Then, I would have to use <pre><code>reg1()</code></pre> to retrieve the actual\nregister number to know what register the argument is\npassed in)\nCredit goes to Arnaud of Hex Rays.\n",
            "votes": "15",
            "user": "Zach Riggle",
            "time": "May 12, 2015 at 16:28",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "Using the minsc plugin at https://github.com/arizvisa/ida-minsc, you can access information about a function (address, or <pre><code>func_t</code></pre>) or its prototype (<pre><code>tinfo_t</code></pre>) using the <pre><code>function.type</code></pre> namespace.\nDisclaimer: I maintain the ida-minsc plugin.\nIn this namespace are <pre><code>function.type.argument</code></pre> (for a single parameter), which is aliased as <pre><code>function.arg</code></pre>, or <pre><code>function.type.arguments</code></pre> (for all parameters), which is aliased as <pre><code>function.args</code></pre>. For the result of a prototype, there is also the <pre><code>function.type.result</code></pre> namespace, which is aliased as <pre><code>function.result</code></pre>. These namespaces include 3 classes of functions that can be used to fetch or modify their target.\nTypes\nThe <pre><code>function.type.arg</code></pre> and <pre><code>function.type.args</code></pre> namespaces can be used as a function to interact with the type of a parameter for a prototype.\n<pre><code>Python>func.t()\n__int64 __fastcall(char *Handle, __int64, __int64)\n\n# Get type of first parameter (0).\nPython>func.arg(idc.here(), 0)\nchar *\n\n# Return a list containing the type used for each of the parameters\nPython>func.args(idc.here())\n[char *, __int64, __int64]\n\n# Return the type of result, and then change it to void. Each of\n# these return their previous value if you change your mind.\nPython>func.result()\n__int64\n\nPython>func.result('void')\n__int64\n\n# Show the type being changed.\nPython>func.t()\nvoid __fastcall(char *Handle, __int64, __int64)\n</code></pre>\nSomething worth noting about <pre><code>function.type.args</code></pre> is that it has the ability to change the number of function arguments depending on the length of its parameter.\nNames\nThe next class of functions would be to interact with the parameter names. These are handled by the <pre><code>function.type.argument.name</code></pre> and <pre><code>function.type.arguments.names</code></pre>.\nIt is worth nothing that <pre><code>function.type.arguments.names</code></pre> does not affect the number of function parameters. Therefore it can also be used to erase all of the names associated with a function in case you only want IDA to propagate the types (rather than the parameter names). This can be combined with tags to identify the changes that have been mistakenly propagated.\n<pre><code>Python>h = idc.here()\nPython>func.t()\n__int64 __fastcall(char *Handle, __int64, __int64)\n\nPython>func.tag('__typeinfo__')\n'void __fastcall NtUserGetProcessDpiAwarenessContext(char *Handle, __int64, __int64)' \n\n# Return the name of the first argument.\nPython>func.arg.name(idc.here(), 0)\n'Handle'\n\n# Return all the names for each parameter. As opposed to using the\n# address, this acts directly on the tinfo_t for the function.\nPython>func.args.names(func.type(h()))\n['Handle', '', '']\n\n# Change the name for all of the parameters for the current function.\nPython>func.args.names('a b c'.split(' '))\n['Handle', '', '']\n\n# Render the full function prototype (extracting it from a tag).\nPython>func.tag('__typeinfo__')\n'void __fastcall NtUserGetProcessDpiAwarenessContext(char *a, __int64 b, __int64 c)'\n\n# Remove each parameter name from the function prototype.\nPython>func.t()\nvoid __fastcall(char *a, __int64 b, __int64 c)\n\nPython>func.args.names([])\n['a', 'b', 'c']\n\nPython>func.t()\nvoid __fastcall(char *, __int64, __int64)\n</code></pre>\nStorage\nThe final class of functions is for accessing the storage being used for a parameter. This is exposed via the <pre><code>function.type.argument.storage</code></pre> and <pre><code>function.type.arguments.storage</code></pre> functions. The storage can be returned in multiple ways depending on how the prototype is defined. The most general case is a register (<pre><code>ALOC_REG1</code></pre>) or storage location relative to the stack pointer (<pre><code>ALOC_STACK</code></pre>). Another way is via a phrase, being an offset relative to a register (<pre><code>ALOC_RREL</code></pre>). Some other ways are a static address (<pre><code>ALOC_STATIC</code></pre>), a list of contiguous registers (<pre><code>ALOC_REG2</code></pre>), or a dictionary (<pre><code>ALOC_DIST</code></pre>)\n<pre><code>Python>func.t()\n__int64 __usercall@<rax>(unsigned int@<ecx>, unsigned int@<edx>, unsigned int@<r8d>, unsigned int@<r9d>, int, unsigned int, unsigned int)\n\nPython>func.convention() == idaapi.CM_CC_SPECIAL\nTrue\n\n# Get the storage location for the 3rd parameter (2) and the result.\nPython>func.arg.storage(2), func.result.storage()\n(<class 'register_t' index=8 dtype=dt_dword name='r8d' position=0+32>, <class 'register_t' index=0 dtype=dt_qword name='rax' position=0+64>) \n\n# Stringify all of the storage locations for the prototype.\nPython>[\"{!s}\".format(x) for x in func.args.storage()]\n['%ecx', '%edx', '%r8d', '%r9d', 'location_t(offset=0x20, size=4)', 'location_t(offset=0x28, size=4)', 'location_t(offset=0x30, size=4)'] \n\n# Translate the location relative to the current stack pointer.\nPython>func.arg.storage(5)\nlocation_t(offset=0x28, size=4)\n\nPython>ins.reg.esp\n<class 'register_t' index=4 dtype=dt_dword name='esp' position=0+32>\n\nPython>func.arg.storage(5) + ins.reg.esp\nlocation_t(offset=0xffffc404, size=4)\n</code></pre>\nSpoiled\nIf you need to access the spoiled registers of a prototype, you can accomplish this with the <pre><code>function.type.spoiled</code></pre> function.\n<pre><code>Python>func.t()\n__int64 __usercall@<rax>(unsigned int@<ecx>, unsigned int@<edx>, unsigned int@<r8d>, unsigned int@<r9d>, int, unsigned int, unsigned int)\n\n# Verify there are no spoiled registers, then assign some by name or symbol.\nPython>func.t.spoiled()\n[]\n\nPython>func.t.spoiled(['eax', ins.reg.rsi])\n[]\n\nPython>func.t()\n__int64 __usercall __spoils<eax,rsi>@<rax>(unsigned int@<ecx>, unsigned int@<edx>, unsigned int@<r8d>, unsigned int@<r9d>, int, unsigned int, unsigned int)\n\n# Clear the spoiled registers from the prototype.\nPython>func.t.spoiled([])\n[]\n\nPython>func.t()\n__int64 __usercall __spoils<>@<rax>(unsigned int@<ecx>, unsigned int@<edx>, unsigned int@<r8d>, unsigned int@<r9d>, int, unsigned int, unsigned int)\n\n# Remove the spoiled attribute entirely.\nPython>func.t.spoiled(None)\n[<class 'register_t' index=0 dtype=dt_dword name='eax' position=0+32>, <class 'register_t' index=6 dtype=dt_qword name='rsi' position=0+64>]\n\nPython>func.t()\n__int64 __usercall@<rax>(unsigned int@<ecx>, unsigned int@<edx>, unsigned int@<r8d>, unsigned int@<r9d>, int, unsigned int, unsigned int)\n</code></pre>\nCombined\nCombining all of these together can be done individually or by using the <pre><code>function.type.arguments.iterate</code></pre> function.\n<pre><code>Python>for type, name, storage in zip(func.args(), func.args.names(), func.args.storage()):\nPython> print([\"{!s}\".format(type), name, \"{:s}\".format(storage)])\nPython>\n['unsigned int', '', 'ecx']\n['unsigned int', '', 'edx']\n['unsigned int', '', 'r8d']\n['unsigned int', '', 'r9d']\n['int', '', '0x20+4']\n['unsigned int', '', '0x28+4']\n['unsigned int', '', '0x30+4']\n\nPython>for index, (name, type, storage) in enumerate(func.args.iterate()):\nPython> print(index, [\"{!s}\".format(item) for item in [type, name, storage]])\nPython>\n0 ['unsigned int', '', '%ecx']\n1 ['unsigned int', '', '%edx']\n2 ['unsigned int', '', '%r8d']\n3 ['unsigned int', '', '%r9d']\n4 ['int', '', 'location_t(offset=0x20, size=4)']\n5 ['unsigned int', '', 'location_t(offset=0x28, size=4)']\n6 ['unsigned int', '', 'location_t(offset=0x30, size=4)'] \n</code></pre>\n",
            "votes": "0",
            "user": "Ali Rizvi-Santiago",
            "time": "Jul 22, 2024 at 17:38",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Ali Rizvi-Santiago",
                    "text": "<span class=\"comment-copy\">(Sorry for the advert on your q, ebeip90).</span>",
                    "time": null
                }
            ]
        }
    ]
}