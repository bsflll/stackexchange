{
    "title": "How to extract functions from one executable to include/link in another",
    "link": "https://reverseengineering.stackexchange.com/questions/6759/how-to-extract-functions-from-one-executable-to-include-link-in-another",
    "content": "I'm wondering what are the options (aside from attempting disassembly/decompilation and reassembly/recompilation) one has when it comes to extracting a series of functions from one binary, compiled for a specific platform and architecture and including it into a separate program in order to invoke those same functions in a newly compiled program.\nI've attempted the decompilation extraction route but the code produced by common tools (such as IDA Pro) is hardly compilable code, and the logic I'm looking at is obfuscated and complex to understand and rewrite/reproduce by hand.\nI've seen about a dozen applications that were able to do this with the same mentioned functions I'm trying to extract and can confirm they all look to be exactly the same when decompiling all other executables, can't figure out a route to do the same.\nAny pointers would be greatly appreciated.\n",
    "votes": "9",
    "answers": 2,
    "views": "11k",
    "tags": [
        "disassembly",
        "decompilation",
        "executable",
        "binary"
    ],
    "user": "Roberto Andrade",
    "time": "Dec 3, 2014 at 17:09",
    "comments": [
        {
            "user": "yaspr",
            "text": "Well, one way is to save the disassembled code of the functions in a .s or .asm file and compile/link your application with those files. This has 40% chance to work since most disassemblers do not produce assemblable/usable code (beware of bads and mixed data with instructions).\n",
            "time": null
        },
        {
            "user": "w s",
            "text": "It is also possible to use disassembled code as inlined assembly in manually crafted C functions. This will probably make global variables/functions handling easier.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "Assume you have some unknown object file. The source code of it was\n<pre><code>#include <stdio.h>\n#include <string.h>\n\n#define NCHAR   26\n\nvoid setkey(int i);\nchar *encrypt(char *s);\nchar keybuf[NCHAR];\nchar codepoint(char c);\n\nint main(void) {\n    char *secret;\n    setkey(5);\n    secret=strdup(\"Hello World\");\n    printf(\"%s\n\", encrypt(secret));\n}\n\nvoid setkey(int key) {\n    int i, val;\n    val=key;\n    for (i=0; i<NCHAR; i++) {\n        keybuf[i]=val%NCHAR;\n        val+=key;\n    }\n}\n\nchar *encrypt(char *s) {\n    char *t=s;\n    while (*s) {\n        if (*s>='a' && *s<='z') {\n            *s='a'+codepoint(*s-'a');\n        } else if (*s>='A' && *s<='Z') {\n            *s='A'+codepoint(*s-'A');\n        }\n        s++;\n    }\n    return t;\n}\n\nchar codepoint(char c) {\n    return keybuf[c];\n}\n</code></pre>\nThe only thing you have is the object code. For reference, <pre><code>objdump -d original</code></pre> yields\n<pre><code>Disassembly of section .text:\n\n0000000000400490 <_start>:\n  400490:   31 ed                   xor    %ebp,%ebp\n...\n000000000040057d <main>:\n  40057d:   55                      push   %rbp\n  40057e:   48 89 e5                mov    %rsp,%rbp\n...\n  4005b2:   c3                      retq   \n\n00000000004005b3 <setkey>:\n  4005b3:   55                      push   %rbp\n  4005b4:   48 89 e5                mov    %rsp,%rbp\n...\n  4005ed:   48 98                   cltq   \n  4005ef:   88 90 60 10 60 00       mov    %dl,0x601060(%rax)\n  4005f5:   8b 45 ec                mov    -0x14(%rbp),%eax\n...\n  400606:   c3                      retq   \n\n0000000000400607 <encrypt>:\n  400607:   55                      push   %rbp\n  400608:   48 89 e5                mov    %rsp,%rbp\n...\n  400677:   89 c7                   mov    %eax,%edi\n  400679:   e8 21 00 00 00          callq  40069f <codepoint>\n  40067e:   83 c0 41                add    $0x41,%eax\n...\n  40069e:   c3                      retq   \n\n000000000040069f <codepoint>:\n  40069f:   55                      push   %rbp\n  4006a0:   48 89 e5                mov    %rsp,%rbp\n...\n  4006ac:   48 98                   cltq   \n  4006ae:   0f b6 80 60 10 60 00    movzbl 0x601060(%rax),%eax\n  4006b5:   5d                      pop    %rbp\n  4006b6:   c3                      retq   \n</code></pre>\nYou want to use that code in your program. \nTo do this, you don't really have to understand or disassemble it, or make it compilable.\nThe only things you will need to find out, using IDA, a debugger, or your favourite tools, are:\n\nThe interesting part of the code is the part from 0x4005B3 to 0x4006B6. \nThis code references some variable at 0x601060 at two different locations, 0x4005ef and 0x4006ae. (The instructions need 2 resp. 3 bytes, so the addresses are at 0x4005b1 and 0x4006b1).\nTo use it, you have to call the function at 0x4005b3 with an integer first, then the function at 0x400607 with a string to get the encrypted string.\n\nLet's convert the whole .text section into an array of characters, ready to be embedded into C code:\n<pre><code>$ objdump -s -j .text original | grep '^ 4' | cut -d' ' -f3-6 | tr -d ' ' | sed 's/../0x&,/g'\n0x31,0xed,0x49,0x89,0xd1,0x5e,0x48,0x89,0xe2,0x48,0x83,0xe4,0xf0,0x50,0x54,0x49,\n...\n0x41,0x5e,0x41,0x5f,0xc3,0x66,0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00,\n0xf3,0xc3,\n</code></pre>\nand write a new program to use it.\n<pre><code>#include <stdio.h>\n#include <string.h>\n\nchar code[]={\n0x31,0xed,0x49,0x89,0xd1,0x5e,0x48,0x89,0xe2,0x48,0x83,0xe4,0xf0,0x50,0x54,0x49,\n0xc7,0xc0,0x30,0x07,0x40,0x00,0x48,0xc7,0xc1,0xc0,0x06,0x40,0x00,0x48,0xc7,0xc7,\n0x7d,0x05,0x40,0x00,0xe8,0xa7,0xff,0xff,0xff,0xf4,0x66,0x0f,0x1f,0x44,0x00,0x00,\n0xb8,0x4f,0x10,0x60,0x00,0x55,0x48,0x2d,0x48,0x10,0x60,0x00,0x48,0x83,0xf8,0x0e,\n0x48,0x89,0xe5,0x77,0x02,0x5d,0xc3,0xb8,0x00,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,\n0xf4,0x5d,0xbf,0x48,0x10,0x60,0x00,0xff,0xe0,0x0f,0x1f,0x80,0x00,0x00,0x00,0x00,\n0xb8,0x48,0x10,0x60,0x00,0x55,0x48,0x2d,0x48,0x10,0x60,0x00,0x48,0xc1,0xf8,0x03,\n0x48,0x89,0xe5,0x48,0x89,0xc2,0x48,0xc1,0xea,0x3f,0x48,0x01,0xd0,0x48,0xd1,0xf8,\n0x75,0x02,0x5d,0xc3,0xba,0x00,0x00,0x00,0x00,0x48,0x85,0xd2,0x74,0xf4,0x5d,0x48,\n0x89,0xc6,0xbf,0x48,0x10,0x60,0x00,0xff,0xe2,0x0f,0x1f,0x80,0x00,0x00,0x00,0x00,\n0x80,0x3d,0x19,0x0b,0x20,0x00,0x00,0x75,0x11,0x55,0x48,0x89,0xe5,0xe8,0x7e,0xff,\n0xff,0xff,0x5d,0xc6,0x05,0x06,0x0b,0x20,0x00,0x01,0xf3,0xc3,0x0f,0x1f,0x40,0x00,\n0x48,0x83,0x3d,0xc8,0x08,0x20,0x00,0x00,0x74,0x1e,0xb8,0x00,0x00,0x00,0x00,0x48,\n0x85,0xc0,0x74,0x14,0x55,0xbf,0x20,0x0e,0x60,0x00,0x48,0x89,0xe5,0xff,0xd0,0x5d,\n0xe9,0x7b,0xff,0xff,0xff,0x0f,0x1f,0x00,0xe9,0x73,0xff,0xff,0xff,0x55,0x48,0x89,\n0xe5,0x48,0x83,0xec,0x10,0xbf,0x05,0x00,0x00,0x00,0xe8,0x24,0x00,0x00,0x00,0xbf,\n0x44,0x07,0x40,0x00,0xe8,0xe7,0xfe,0xff,0xff,0x48,0x89,0x45,0xf8,0x48,0x8b,0x45,\n0xf8,0x48,0x89,0xc7,0xe8,0x5e,0x00,0x00,0x00,0x48,0x89,0xc7,0xe8,0x9f,0xfe,0xff,\n0xff,0xc9,0xc3,0x55,0x48,0x89,0xe5,0x89,0x7d,0xec,0x8b,0x45,0xec,0x89,0x45,0xfc,\n0xc7,0x45,0xf8,0x00,0x00,0x00,0x00,0xeb,0x36,0x8b,0x4d,0xfc,0xba,0x4f,0xec,0xc4,\n0x4e,0x89,0xc8,0xf7,0xea,0xc1,0xfa,0x03,0x89,0xc8,0xc1,0xf8,0x1f,0x29,0xc2,0x89,\n0xd0,0x6b,0xc0,0x1a,0x29,0xc1,0x89,0xc8,0x89,0xc2,0x8b,0x45,0xf8,0x48,0x98,0x88,\n0x90,0x60,0x10,0x60,0x00,0x8b,0x45,0xec,0x01,0x45,0xfc,0x83,0x45,0xf8,0x01,0x83,\n0x7d,0xf8,0x19,0x7e,0xc4,0x5d,0xc3,0x55,0x48,0x89,0xe5,0x48,0x83,0xec,0x20,0x48,\n0x89,0x7d,0xe8,0x48,0x8b,0x45,0xe8,0x48,0x89,0x45,0xf8,0xeb,0x71,0x48,0x8b,0x45,\n0xe8,0x0f,0xb6,0x00,0x3c,0x60,0x7e,0x2c,0x48,0x8b,0x45,0xe8,0x0f,0xb6,0x00,0x3c,\n0x7a,0x7f,0x21,0x48,0x8b,0x45,0xe8,0x0f,0xb6,0x00,0x83,0xe8,0x61,0x0f,0xbe,0xc0,\n0x89,0xc7,0xe8,0x58,0x00,0x00,0x00,0x83,0xc0,0x61,0x89,0xc2,0x48,0x8b,0x45,0xe8,\n0x88,0x10,0xeb,0x35,0x48,0x8b,0x45,0xe8,0x0f,0xb6,0x00,0x3c,0x40,0x7e,0x2a,0x48,\n0x8b,0x45,0xe8,0x0f,0xb6,0x00,0x3c,0x5a,0x7f,0x1f,0x48,0x8b,0x45,0xe8,0x0f,0xb6,\n0x00,0x83,0xe8,0x41,0x0f,0xbe,0xc0,0x89,0xc7,0xe8,0x21,0x00,0x00,0x00,0x83,0xc0,\n0x41,0x89,0xc2,0x48,0x8b,0x45,0xe8,0x88,0x10,0x48,0x83,0x45,0xe8,0x01,0x48,0x8b,\n0x45,0xe8,0x0f,0xb6,0x00,0x84,0xc0,0x75,0x84,0x48,0x8b,0x45,0xf8,0xc9,0xc3,0x55,\n0x48,0x89,0xe5,0x89,0xf8,0x88,0x45,0xfc,0x0f,0xbe,0x45,0xfc,0x48,0x98,0x0f,0xb6,\n0x80,0x60,0x10,0x60,0x00,0x5d,0xc3,0x66,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00,\n0x41,0x57,0x41,0x89,0xff,0x41,0x56,0x49,0x89,0xf6,0x41,0x55,0x49,0x89,0xd5,0x41,\n0x54,0x4c,0x8d,0x25,0x38,0x07,0x20,0x00,0x55,0x48,0x8d,0x2d,0x38,0x07,0x20,0x00,\n0x53,0x4c,0x29,0xe5,0x31,0xdb,0x48,0xc1,0xfd,0x03,0x48,0x83,0xec,0x08,0xe8,0x25,\n0xfd,0xff,0xff,0x48,0x85,0xed,0x74,0x1e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00,\n0x4c,0x89,0xea,0x4c,0x89,0xf6,0x44,0x89,0xff,0x41,0xff,0x14,0xdc,0x48,0x83,0xc3,\n0x01,0x48,0x39,0xeb,0x75,0xea,0x48,0x83,0xc4,0x08,0x5b,0x5d,0x41,0x5c,0x41,0x5d,\n0x41,0x5e,0x41,0x5f,0xc3,0x66,0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00,\n0xf3,0xc3,\n};\n\n// we don't know how large it has to be. From the disassembly,\n// we learned 26 bytes should be enough. Better make it larger and be\n// on the safe side.\nchar buffer[1000];\n\nint main(void) {\n\n    void (*f1)(int)=(void *)(code-0x400490+0x4005b3);\n    char* (*f2)(char *)=(void *)(code-0x400490+0x400607);\n\n    *(int *)(code-0x400490+0x4005f1)=(int)(long)&buffer;\n    *(int *)(code-0x400490+0x4006b1)=(int)(long)&buffer;\n\n    (*f1)(5);\n    printf(\"%s\n\", (*f2)(strdup(\"Hello World\")));\n    printf(\"%s\n\", (*f2)(strdup(\"Some other String\")));\n}\n</code></pre>\nSince the original text segment started at 0x400490, and our functions started at 0x4005b3 and 0x400607, we calculate the new offsets from the start of the <pre><code>code</code></pre> array. And since we \nfound two references to a buffer outside the original program, we patch them to point to our buffer instead. Note we don't have to do anything with the call from encrypt to codepoint,\nsince the code is position-independent anyway (call the function at 0x21 bytes from here).\nNow, don't forget to make the data/stack segment executable when we compile the program:\n<pre><code>$ cc -zexecstack -g -o copy copy.c\n$ ./copy\nOziix Lxmiu\nRxnz xwozm Rwmtsj\n</code></pre>\nOf course, there's still some problems to solve:\n\nYou have to find everything that might get called from your functions, and include all of it into your code.\nYou have to find all references to data outside your code, and patch the pointers accordingly; if the data contains pointers, patch them as well.\nIf your code calls any library functions, you'll have to do the relocation. Fortunately, the relocation table of the (ELF/PE) binary shows you where to do this.\n\nThe upside of this approach is it can even work between operating systems, if they use the same processor architecture. You might need to write wrapper functions around the calls however, \nif the ABI is different.\nIf you want to get fancy, don't call the functions directly; embed an emulator engine in your program and have the emulator execute the code. This can help you a lot to detect if\nsome code is missing, or where references to external data are. Once you get it running with an emulator, obviously, you can leave it in your final program, which may even enable\nyou to use some ARM routines in your new PC program. Or vice versa.\nYou can download the files at \nhttps://mega.co.nz/#!8dR0TZhA!Z4DdQ07JCUzV5nJiJ79PZhHbiKDu9QZEw10IXr7ssuI\n",
            "votes": "9",
            "user": "Guntram Blohm",
            "time": "Dec 4, 2014 at 19:58",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Scy",
                    "text": "<span class=\"comment-copy\">buffer address used by 0x4005ef should be 0x4005f1 not 0x4005b1</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "The only project that claimed something like this possible (with significant amount of semi-automated and manual work) is McSema.\nSee the source and examples, it may be useful.\n",
            "votes": "1",
            "user": "w s",
            "time": "Dec 4, 2014 at 12:47",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Roberto Andrade",
                    "text": "<span class=\"comment-copy\">Will check it out... so the outcome would still be binary/linkable code that I can compile against instead of decompiled source code correct? Any tips for making the code cross-platform? Would I be able to simply build my source for different platform/architectures linking to this single extracted binary?</span>",
                    "time": null
                },
                {
                    "user": "yaspr",
                    "text": "<span class=\"comment-copy\">If you use machine code/assembly, there is no chance your code is portable. You'll have to convert the instructions yourself or use a binary translator (ex: Intel's Houdini  which converts NEON to SSE). Or, you'll have to adapt decompiled code which sounds like a lot of work.</span>",
                    "time": null
                },
                {
                    "user": "w s",
                    "text": "<span class=\"comment-copy\">@yaspr See their demos. Looks very impressive.</span>",
                    "time": null
                }
            ]
        }
    ]
}