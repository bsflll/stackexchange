{
    "title": "What could be the purpose of XORing esp with a global variable? (stack canary protection)",
    "link": "https://reverseengineering.stackexchange.com/questions/16241/what-could-be-the-purpose-of-xoring-esp-with-a-global-variable-stack-canary-pr",
    "content": "I am currently looking at a function inside a Win32 executable's main module. After allocating memory on the stack (sub esp) and saving some registers on the stack, the value of esp is XORed with a global variable.\n<pre><code>mov eax, esp\nxor eax, DWORD PTR ds:[<some address>]\npush eax\n</code></pre>\nI wonder whether this is some kind of stack protection technique?\nEdit: I wrote the question from memory. The actual instruction sequence is:\n<pre><code>sub esp, 0xf0\nmov eax, DWORD PTR ds:[<some address>]\nxor eax, esp\nmov DWORD PTR ss:[esp+0xec], eax\n</code></pre>\n",
    "votes": "4",
    "answers": 2,
    "views": "3k",
    "tags": [
        "disassembly",
        "windows",
        "x86",
        "buffer-overflow",
        "stack"
    ],
    "user": "InkassoHeinzi",
    "time": "Sep 2, 2017 at 18:21",
    "comments": [],
    "answers_data": [
        {
            "content": "Yes, this is an implementation of what's often called \"Stack Canaries\", a method of stack Buffer Overflow Protection. That example you're describing is specifically the method used by Visual Studio, enabled by default since Visual Studio 2005, implemented since Visual Studio 2003. It is also called <pre><code>GS protection</code></pre> due to the fact Visual Studio provided the flags, <pre><code>/GS</code></pre> to enable and <pre><code>/GS-</code></pre> to disable, that protection and override the default behavior.  \nWhat is stack buffer overflow protection?\nThere are multiple stack buffer overflow protection techniques implemented by different compilers and 3rd party protection tools, but they all revolve around the same fundamental idea: When a stack buffer overflow is exploited, the attacker often overwrites the return address located on the stack to redirect code execution to a controlled address. Stack canaries work by prefixing the <pre><code>ret</code></pre> instruction with some sort of validation that the stack, and specifically the return address, was not altered by an attacker prior to the <pre><code>ret</code></pre> instruction being executed (which will result in a pop from the stack and placing the popped value in the instruction pointer).\nHow does the provided example protect the stack from such exploits?\nTo answer that, we'll need to provide the full implementation details of which you just provided the first half. Most stack overflow canary protections usually include inserting function prolog and epilog, and you only provided the former.\nHere's a commented example prolog:\n<pre><code>sub         esp,    8           //  allocate 8 bytes for cookie\nmov eax,    DWORD   PTR ___security_cookie\nxor eax,    esp                 //  xor cookie with current esp\nmov DWORD   PTR [esp+8],    eax //  save in stack\n</code></pre>\nThis prolog starts with allocating the stack variable's space just as any \"regular\" function would. It then continues to fetch a value randomly generated at the process start, and stored in a specific memory address, \n into register <pre><code>EAX</code></pre> and then <pre><code>xor</code></pre>-ing it with the current stack pointer. The resulting value is then stored on the stack.\nAnd a commented example epilog:\n<pre><code>mov ecx,    DWORD   PTR     [esp+8]  // Read saved cookie\nxor ecx,    esp                      // Xor saved cookie, should result in the same value\ncall        @__security_check_cookie@4  // Call a short function to validate resulting value is legit, and terminate safely otherwise\nadd         esp,    8\n</code></pre>\nThen, just before the function's <pre><code>ret</code></pre> instruction is executed, which under normal buffer overflow attack circumstances will fetch the overwritten return address and will execute attacker controlled code, a validation that the original stack cookie value was kept is made, triggering a safe failure in case the value differs from the expected stack cookie.\nThe logic in most of the cookie/canary based protections is the following:\n\nOn function entrance store a specific value, deterministic but unpredictable from the attacker's perspective. Preferably, one that's dependant on the function's execution conditions (such as the current ESP). That value should be placed between the function's return address and any buffer-overflow potential buffer or variable.\nOn function's exit, just before using the potentially overwritten return address, validate the stored cookie is same as expected, fail if it was somehow changed.\nAs classic buffer overflow attacks are rewriting the entire stack in a sequential manner (meaning that to overwrite the return address from stack variable <pre><code>buf</code></pre>, all data located on the stack between the return address and <pre><code>buf</code></pre> might also be overwritten), any overwrite of the return address must also modify the stack canary. As long as the attacker cannot predict the canary before triggering the function call, the attack will fail due to the canary validation performed just before <pre><code>ret</code></pre> is executed.\n\nWas that the end of stack based buffer overflows?\nNo, for several reasons the battle over stack overflow exploitation and protection carried on (and is still ongoing, in certain circumstances):\n\nSoon after the first canary protections implemented in Visual Studio, attacks against SEH exception structures (which are allocated on the stack to handle exceptions) began, and provided several anti-SEH buffer overflow protections (such as SafeSEH, which underwent several versions until it was fully reliable in protecting against such attacks including the later <pre><code>SEHOP</code></pre>). \nAdditionally, information leakage bugs were used to predict (and increase prediction chances) of canary values, which enabled bypassing the canary check and made stack based buffer overflows possible. \nSlightly similar to #2 but specific to canary protections, in certain cases an attacker could exploit the flow of the process's execution to slowly extract the canary values byte by byte, thus reducing a 2**32 (4294967296 possibilities) brute force to only 256*4 (1024 possibilities) brute force, making many attacks a lot more plausible.  \nBuffer overflow bugs allowing non-linear overwrites were also being used, to \"skip\" overwriting the stack canary (or most of it) to either completely avoid the need to predict the canary value, or reduce the modification range to a lower, 1 byte range. Such common examples are looks that overwrite only on certain conditions or those whom overwrite only 1 byte of a dword. These would also make the return address modification limited but were still useful (and occasionally more so, in certain cases where ASLR was also used).\n",
            "votes": "7",
            "user": "Igor Skochinsky",
            "time": "Sep 2, 2017 at 17:58",
            "is_accepted": true,
            "comments": [
                {
                    "user": "InkassoHeinzi",
                    "text": "<span class=\"comment-copy\">So, in contrast to Igor's answer, the return address is not immediately protected by xoring it with the cookie, but by checking whether the canary has been overwritten (assuming, as you stated, that a stack overflow will overwrite it)?</span>",
                    "time": null
                },
                {
                    "user": "NirIzr",
                    "text": "<span class=\"comment-copy\">In the code snippet you provided (which is more similar to the one I provided) the randomly generated cookie is XORed with the the ESP register (which points to the current location of the stack). In the code snippet Igor quoted, the cookie is XORed with where the return address is placed (on the stack). Both approaches work, and I can see slight advantages to either. However I think the main point to take from this answer is the overall reasoning and logic behind the stack cookie, and not the specific implementation used. The change might come from different protection versions.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "Yes, this is Microsoft's stack overflow protection, commonly known as \"GS cookie\". From Compiler Security Checks In Depth:\n\nWhen the function is compiled with /GS, the functions prolog will set\n  aside an additional four bytes and add three more instructions as\n  follows:\n<pre><code>sub   esp,24h\nmov   eax,dword ptr [___security_cookie (408040h)]\nxor   eax,dword ptr [esp+24h]\nmov   dword ptr [esp+20h],eax\n</code></pre>\nThe prolog contains an instruction that fetches a copy of the cookie,\n  followed by an instruction that does a logical xor of the cookie and\n  the return address, and then finally an instruction that stores the\n  cookie on the stack directly below the return address. From this point\n  forward, the function will execute as it does normally. When a function returns, the last thing to execute is the functionâ€™s epilog, which is the opposite of the prolog. \nWhen compiled with /GS, the security checks are also placed in the\n  epilog:\n<pre><code>mov   ecx,dword ptr [esp+20h]\nxor   ecx,dword ptr [esp+24h]\nadd   esp,24h\njmp   __security_check_cookie (4010B2h)\n</code></pre>\nThe stack's copy of the cookie is retrieved and then follows with the\n  XOR instruction with the return address. The ECX register should\n  contain a value that matches the original cookie stored in the\n  __security_cookie variable. The stack space is then reclaimed, and then, instead of executing the RET instruction, the JMP instruction to\n  the __security_check_cookie routine is executed.\n",
            "votes": "5",
            "user": "Igor Skochinsky",
            "time": "Sep 2, 2017 at 16:31",
            "is_accepted": false,
            "comments": []
        }
    ]
}