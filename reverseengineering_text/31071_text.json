{
    "title": "Reverse function in .rdata field",
    "link": "https://reverseengineering.stackexchange.com/questions/31071/reverse-function-in-rdata-field",
    "content": "I'm tracking a function called CreateIoCompletionPort in dns.exe. The import tab in IDA shows that it's imported from api-ms-win-core-io-l1-1-0.dll.\nHowever, it appears in .rdata section in the .dll file. How to find the assembly code of this function?\n<pre><code>.rdata:000000018000110B aCreateiocomple db 'CreateIoCompletionPort',0\n.rdata:000000018000110B                                         ; DATA XREF: .rdata:off_1800010A4↑o\n.rdata:0000000180001122 ; Exported entry   2. CreateIoCompletionPort\n.rdata:0000000180001122                 public CreateIoCompletionPort\n.rdata:0000000180001122 ; HANDLE __stdcall CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)\n.rdata:0000000180001122 CreateIoCompletionPort db 'kernel32.CreateIoCompletionPort',0\n.rdata:0000000180001122                                         ; DATA XREF: .rdata:off_180001088↑o\n.rdata:0000000180001142 aDeviceiocontro db 'DeviceIoControl',0  ; DATA XREF: .rdata:off_1800010A4↑o\n.rdata:0000000180001152 ; Exported entry   3. DeviceIoControl\n.rdata:0000000180001152                 public DeviceIoControl\n</code></pre>\n",
    "votes": "2",
    "answers": 2,
    "views": "274",
    "tags": [
        "ida",
        "windows"
    ],
    "user": "anonymous bear",
    "time": "Nov 2, 2022 at 14:33",
    "comments": [],
    "answers_data": [
        {
            "content": "Before I answer the question you asked, let me answer the question that you probably meant to ask: What are I/O completion ports on Windows or in general?\nThere is little point in attempting to chase (or reverse engineer) documented behavior. Of course if you want to look into the implementation of the function on the kernel side of things you may want to look at <pre><code>CreateIoCompletionPort()</code></pre> implemented in <pre><code>kernelbase.dll</code></pre> as a wrapper of <pre><code>NtCreateIoCompletion()</code></pre> and <pre><code>NtSetInformationFile()</code></pre> (and <pre><code>NtClose()</code></pre>). But even if you are interested in that part (which you'll find in <pre><code>ntoskrnl.exe</code></pre>) you could peek at the ReactOS to get an idea of how it may have been implemented on Windows (please note that ReactOS very often deviates from Windows, but to get a general idea it's great). Alternatively if you have access to the Windows Research Kernel (WRK) as student of an eligible institution you could have a look at the actual implementation of around a little under twenty years ago. Even better if you happen to have a source license to Windows, but given your question I assume you don't have that.\n\nActual answer to the question you asked\nGenerally I suggest you read up on API Sets first: here and here and here before you continue.\nThe summary is approximately that the API Sets are an attempt by Microsoft to categorize the classic Win32 API and move their implementations into more logical places all the while not breaking forward compatibility for previously built software. Looking at the implementation it also seems as if they are striving for versioning the APIs, probably to get rid of other more fragile mechanisms like AppCompat shims that aim for forward compatibility as well.\nAs an example: much of the implementation details of what used to be in <pre><code>kernel32.dll</code></pre> during the Windows NT/2000/XP/2003 era went into <pre><code>kernelbase.dll</code></pre> over the years.\nAfter reading up on the details you could then use a tool like Dependencies (somewhat of a spiritual successor to Dependency Walker) Api Set Viewer or API Set Resolver to figure out the dependencies.\nHowever, what you encountered here:\n<pre><code>.rdata:0000000180001122 ; Exported entry   2. CreateIoCompletionPort\n.rdata:0000000180001122                 public CreateIoCompletionPort\n.rdata:0000000180001122 ; HANDLE __stdcall CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)\n.rdata:0000000180001122 CreateIoCompletionPort db 'kernel32.CreateIoCompletionPort',0\n.rdata:0000000180001122                                         ; DATA XREF: .rdata:off_180001088↑o\n</code></pre>\nIs called a function forwarder. It's been in use for ages on Windows and at least the ground rules are easy.\n\nthe export points to a string\nthe string contains a module (stem only, without extension) and a function name: e.g. <pre><code><module>.<function-name></code></pre> (or <pre><code>kernel32.CreateIoCompletionPort</code></pre> in your exact example)\nwhen such a function forwarder is imported/resolved, the module gets loaded (if no already loaded) and then the pointer inside the importing entity will point to an address within that module\n\nIf you are a developer and you target a modern Windows version such as Windows 10 your application will statically import functions from <pre><code>api-ms-win-core-io-l1-1-0.dll</code></pre> and similar DLLs (see first link at the top) instead of <pre><code>kernel32.dll</code></pre> and others previously. These contain at most stubs but usually function forwarders to the \"canonical entity\" for said function.\nTaking your example <pre><code>CreateIoCompletionPort()</code></pre> whose function forwarder in <pre><code>api-ms-win-core-io-l1-1-0.dll</code></pre> points to the export of the same name from <pre><code>kernel32.dll</code></pre> we see:\n<pre><code>.text:000000018001D950 ; HANDLE __stdcall CreateIoCompletionPortStub(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)\n.text:000000018001D950                 public CreateIoCompletionPortStub\n.text:000000018001D950 CreateIoCompletionPortStub proc near    ; DATA XREF: .rdata:0000000180083838↓o\n.text:000000018001D950                                         ; .rdata:off_1800990A8↓o\n.text:000000018001D950                 jmp     cs:__imp_CreateIoCompletionPort\n.text:000000018001D950 CreateIoCompletionPortStub endp\n</code></pre>\n... whereas <pre><code>cs:__imp_CreateIoCompletionPort</code></pre> is:\n<pre><code>.idata:0000000180081458 ; HANDLE (__stdcall *CreateIoCompletionPort)(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)\n.idata:0000000180081458                 extrn __imp_CreateIoCompletionPort:qword\n</code></pre>\n... imported from ... *drum roll* <pre><code>api-ms-win-core-io-l1-1-0.dll</code></pre>. Oh my, we've just gone full circle, haven't we? But the innards of the API Set implementation and the PE loader (from <pre><code>ntdll.dll</code></pre>) help to resolve this. You can read more about API Set resolution here (also mind the references section!), by the author of the aforementioned Dependencies tool. If we use the second mentioned tool, Api Set Viewer, we can see that the functionality from <pre><code>api-ms-win-core-io-l1-1-0.dll</code></pre> is hosted by <pre><code>kernel32.dll</code></pre> and <pre><code>kernelbase.dll</code></pre> respectively:\n\n<pre><code>CreateIoCompletionPort()</code></pre> in particular is hosted by <pre><code>kernelbase.dll</code></pre>. And peeking at its implementation there we can see it wraps the <pre><code>NtCreateIoCompletion()</code></pre>, <pre><code>NtSetInformationFile()</code></pre> and <pre><code>NtClose()</code></pre> NT native APIs about which you can learn in part in the Windows Driver Kit, the few pieces Microsoft divulges via <pre><code>winternl.h</code></pre> in the Windows SDK and in books like Nebbett's \"Windows NT/2000 Native API Reference\" and similar works of the same era as well as the ReactOS source (mentioned before), the phnt project by Process Hacker and sites like undocumented.ntinternals.net. If you want to dig further into the internals of the API Set Map you could have a first look at the PEB layout (offsets 0x38 and 0x68 respectively) and the article from the author of Dependencies.\nAnd next time you'll know what a function fowarder is when you run across one of these odd \"string references\" in the export table of a PE file.\n",
            "votes": "4",
            "user": "0xC0000022L",
            "time": "Nov 7, 2022 at 12:39",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "i wrote this to dissect the file apisetschema.dll some time back  found in windows 10 system32 folder\nthis code is based on Geoff Chappells studies on ApiSetSchema\ncode in apisetres.cpp\n<pre><code>#include \"apisetdefs.h\"\nint main(void)\n{\n    FILE *infile = NULL;\n    errno_t err = fopen_s(&infile, \"c:\\\\windows\\\\system32\\\\apisetschema.dll\", \"rb\");\n    if (err == 0 && infile != NULL)\n    {\n        fseek(infile, 0, SEEK_SET);\n        size_t siz = fread_s(peheadbuf, BUSIZ, 1, 0x400, infile);\n        if (siz == 0x400)\n        {\n            PIMAGE_DOS_HEADER dhead = (PIMAGE_DOS_HEADER)&peheadbuf;\n            PIMAGE_NT_HEADERS64 nthead = (PIMAGE_NT_HEADERS64)(peheadbuf + dhead->e_lfanew);\n            PIMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(nthead);\n            for (WORD i = 0; i < nthead->FileHeader.NumberOfSections; i++)\n            {\n                if ((memcmp(Section->Name, \".apiset\", 8)) == 0)\n                {\n                    fseek(infile, Section->PointerToRawData, SEEK_SET);\n                    siz = fread_s(peheadbuf, BUSIZ, 1, sizeof(APISET_SCHEMA_HEADER_V6), infile);\n                    if (siz == sizeof(APISET_SCHEMA_HEADER_V6))\n                    {\n                        apisethead = (PAPISET_SCHEMA_HEADER_V6)&peheadbuf;\n                        printf(\"Version Number = %x\n\", apisethead->VersionNumber);\n                        printf(\"MapSize = %x\n\", apisethead->Mapsize);\n                        printf(\"isSealed = %x\n\", apisethead->isSealed);\n                        printf(\"Number of Apisets = %x\n\", apisethead->NumAPISets);\n                        printf(\"Offset to NameSpace Entries = %x\n\", apisethead->OffsetNameSpaceEntries);\n                        printf(\"Offset To hash Entries = %x\n\", apisethead->OffsetHashEntries);\n                        printf(\"Hash Multiplier = %x\n\", apisethead->HashMultiplier);\n                    }\n                    DWORD rawdataaddr = Section->PointerToRawData;\n                    DWORD mapoff = rawdataaddr + apisethead->OffsetNameSpaceEntries;\n                    for (unsigned int j = 0; j < apisethead->NumAPISets; j++)\n                    {\n                        DWORD apisetname = (mapoff + (j * sizeof(API_SET_NAMESPACE_ENTRY)));\n                        printf(\"%x\\t\", apisetname);\n                        fseek(infile, apisetname, SEEK_SET);\n                        siz = fread_s(apisetnsebuf, BUSIZ, 1, sizeof(API_SET_NAMESPACE_ENTRY), infile);\n                        apinsentry = (PAPI_SET_NAMESPACE_ENTRY)(apisetnsebuf);\n                        printf(\"%x\\t\", apinsentry->OffsetApiSetName);\n                        DWORD apivdllname = ((rawdataaddr) + (apinsentry->OffsetApiSetName));\n                        fseek(infile, apivdllname, SEEK_SET);\n                        memset(wbuf,0,sizeof(wbuf));\n                        siz = fread_s(wbuf, WBUSIZ , 1, apinsentry->SizeApiSetName, infile);\n                        printf(\"%-60.*S\\t\", (apinsentry->SizeApiSetName), wbuf);\n                        printf(\"%x\\t\", apinsentry->OffsetValueEntries); \n                        DWORD apildllname = ((rawdataaddr) + (apinsentry->OffsetValueEntries) );\n                        printf(\"%x\\t\", apildllname);\n                        fseek(infile, apildllname, SEEK_SET);\n                        siz = fread_s(apisetvalentbuf, BUSIZ, 1, sizeof(API_SET_VALUE_ENTRY), infile);\n                        apivalentry = (PAPI_SET_VALUE_ENTRY)(apisetvalentbuf);\n                        printf(\"%x\\t\" , apivalentry->ValueOffset);\n                        DWORD apivalentname = ((rawdataaddr) + (apivalentry->ValueOffset));\n                        fseek(infile,apivalentname,SEEK_SET);\n                        memset(wbuf,0,sizeof(wbuf));\n                        siz = fread_s(wbuf, WBUSIZ , 1, apivalentry->ValueLength, infile);\n                        printf(\"%-60.*S\n\", (apivalentry->ValueLength)/2, wbuf);\n\n                    }\n                };\n                Section++;\n            }\n        }\n    }\n}\n</code></pre>\nheader file  apisetres.h\n<pre><code>#include <stdio.h>\n#include <stdlib.h>\n#include <windows.h>\n\n#define BUSIZ 0x500\n#define WBUSIZ BUSIZ / 2\n\nunsigned char peheadbuf[BUSIZ];\nunsigned char apisetnsebuf[BUSIZ];\nunsigned char apisetvalentbuf[BUSIZ];\nwchar_t wbuf[BUSIZ];\n\ntypedef struct _APISET_SCHEMA_HEADER_V6\n{\n    DWORD VersionNumber;\n    DWORD Mapsize;\n    DWORD isSealed;\n    DWORD NumAPISets;\n    DWORD OffsetNameSpaceEntries;\n    DWORD OffsetHashEntries;\n    DWORD HashMultiplier;\n} APISET_SCHEMA_HEADER_V6, *PAPISET_SCHEMA_HEADER_V6;\n\ntypedef struct _API_SET_NAMESPACE_ENTRY\n{\n    DWORD isSealed;\n    DWORD OffsetApiSetName;\n    DWORD SizeApiSetName;\n    DWORD SizeApiSetNameNoHyphen;\n    DWORD OffsetValueEntries;\n    DWORD NumHosts;\n\n} API_SET_NAMESPACE_ENTRY, *PAPI_SET_NAMESPACE_ENTRY;\n\ntypedef struct _API_SET_VALUE_ENTRY\n{\n    DWORD Flags;\n    DWORD NameOffset;\n    DWORD NameLen;\n    DWORD ValueOffset;\n    DWORD ValueLength;\n\n} API_SET_VALUE_ENTRY, *PAPI_SET_VALUE_ENTRY;\n\nPAPISET_SCHEMA_HEADER_V6 apisethead = NULL;\nPAPI_SET_NAMESPACE_ENTRY apinsentry = NULL;\nPAPI_SET_VALUE_ENTRY apivalentry = NULL;\n</code></pre>\ncompiled and linked in win 10 x64 vc 2019 community as x64 binary with\n<pre><code>cl /Zi /W4 /analyze /Ehsc /Od apisetres.cpp /link /release\n</code></pre>\nexecuted to print both virtual dll as well as logical dll names\n<pre><code>:\\>apisetres.exe  > output.txt\n\n:\\>head -n 15 output.txt\nVersion Number = 6\nMapSize = 1c6b4\nisSealed = 0\nNumber of Apisets = 37a\nOffset to NameSpace Entries = 1c\nOffset To hash Entries = 1aae4\nHash Multiplier = 1f\n61c     538c    api-ms-onecoreuap-print-render-l1-1-0                           53d8    59d8    53ec    printrenderapihost.dll\n634     5418    api-ms-win-appmodel-identity-l1-2-0                             5460    5a60    5474    kernel.appcore.dll\n64c     5498    api-ms-win-appmodel-runtime-internal-l1-1-7                     54f0    5af0    5474    kernel.appcore.dll\n664     5504    api-ms-win-appmodel-runtime-l1-1-3                              5548    5b48    5474    kernel.appcore.dll\n67c     555c    api-ms-win-appmodel-state-l1-1-2                                559c    5b9c    5474    kernel.appcore.dll\n694     55b0    api-ms-win-appmodel-state-l1-2-0                                55f0    5bf0    5474    kernel.appcore.dll\n6ac     5604    api-ms-win-appmodel-unlock-l1-1-0                               5648    5c48    5474    kernel.appcore.dll\n6c4     565c    api-ms-win-base-bootconfig-l1-1-0                               56a0    5ca0    56b4    advapi32.dll\n</code></pre>\nthe hash entries ripped and pasted to a file named hashdump\nsorted the hashes index wise instead of default name wise\nindependnatly confirmed first 4 names by hashing them using hash algo   described in the study with a python script as below\n<pre><code>#index wise sorting of hashkeys from apisetschema.dll raw data \nimport numpy as np\nnp.set_printoptions(formatter={'all':lambda x: format(x , '08X')})\na = np.fromfile('hashdump',np.dtype([('hash', '<u4'), ('index', '<u4')]))\nb = sorted(a,key = lambda x: x[1])\nc = list(filter(None,b))\nprint( c[0],c[1],c[2],c[3] )\n\n#hashing actual virtual dll names excluding last hyphen \n\napn = [\n\"api-ms-onecoreuap-print-render-l1-1\",\n\"api-ms-win-appmodel-identity-l1-2\",\n\"api-ms-win-appmodel-runtime-internal-l1-1\",\n\"api-ms-win-appmodel-runtime-l1-1\"\n]\n\nfor j in range(0,len(apn),1):\n    hashfactor = 0x1f\n    hashkey = 0\n    for i in apn[j]:\n        hashkey = (hashkey * hashfactor + ord(i)) & 0xffffffff\n    print(\"(%08X, %08x)\" % (hashkey,j),end =' ')\n</code></pre>\nactual hashes index wise from apisetschema.dll versus algorithmic hashing of names from output.txt\n<pre><code>:\\>apisethash.py\n(BFEC7B66, 00000000) (1079FB19, 00000001) (59E37344, 00000002) (3655E8BE, 00000003)\n(BFEC7B66, 00000000) (1079FB19, 00000001) (59E37344, 00000002) (3655E8BE, 00000003)\n:\\> \n</code></pre>\n",
            "votes": "1",
            "user": "blabb",
            "time": "Nov 13, 2022 at 19:55",
            "is_accepted": false,
            "comments": []
        }
    ]
}