{
    "title": "Reverse engineering unknown RS232/UART binary protocol",
    "link": "https://reverseengineering.stackexchange.com/questions/15705/reverse-engineering-unknown-rs232-uart-binary-protocol",
    "content": "Background story\nFor couple of days I'm trying to crack the protocol used the old medical device, in order to collect data for a research in an automated way.\nThe device in question is Novametrix CO2SMO Plus, model 8100. Manufacturer of this device was bought, long time ago, by Respironics and than Respironcis was bought by Philips. Their website doesn't exists for last 12-14 years and archived copy doesn't have any useful information. Since device was designed before 2000 there's no software over the Internet - it was distributed on floppy disks so as software updates.\nDevice is very similar to model 7100, which was released ~3 years prior to the 8100. Devices mainly differ in software - the one in 8100 is much more sophisticated.\nPhysical layer\nAt first I stared from obvious things like determining physical layer of the connection - that went easy, since service manual actually lists all signals in DB25, located on the back of the device. \nAt the beginning I hoped 8100 will use similar, well documented by manufacturer, ASCII protocol (called <pre><code>NOVACOM1</code></pre>) as 7100 used. Unfortunately it's not the case. My device uses newer protocol called <pre><code>NOVACOM3</code></pre> - there's zero information about it in the Internet; it seems like <pre><code>NOVACOM2</code></pre> was never released.\nI don't own oscilloscope (and I don't have an access to electronics labs on my college), so I determined baudrate of the port just observing the traffic with different baudrates with debugging mode enabled on device (more on that later). With high confidence I can say it's 9600 8N1 (like in previous model).\nDevice uses NXP MC68332 MCU, which according to the data sheet is a rugged 32 bit core with quite a few subunits useful in an automotive applications. It also seems to be a secure one - since I have almost no experience in EE I quickly dismissed any possibilities to attempt of physically attacking the CPU.\nPC software\nAccording to the service manual, manufacturer had developed PC software used for communication with the device - \"CO2SMO Plus! for Windows\". Unfortunately it was sold as a separate package and it's nowhere to be found now.\nDiagnostic protocol\nThe device has two Novametrix protocols - <pre><code>NOVACOM3</code></pre> and <pre><code>SATDIAG</code></pre>. Since diagnostic protocols are usually simpler I started from the later one:\n\nSATDIAG streams data continuously\nProtocol, besides sending data to the computer, contains some unknown upload mode for firmware update (probably some XMODEM or so... I don't have firmeware blob, so obviously I didn't played with this)\nAfter analysis I can say with high confidence each packet begins with <pre><code>0x00</code></pre> and ends with <pre><code>0x0A</code></pre> (LF)\nProtocol streams packets few times a second (I didn't conducted any measurements on that, but it's 15-20/s)\nDevice alternates between sending 9 and 25 bytes (including 2B of header and footer) packets\nEvery few of seconds 41 bytes packet is transmitted \nMost probably no checksum is used (the same payloads contain different last byte, I also calculated popular checksums for few)\nProtocol seems to be aimed strictly for collecting performance data, some sort of resources usage or represents unknown internal state -  changes in measurements aren't causing any notable changes in packets. I also tried manually searching for numbers similar to these displayed by the device - no luck.\n\nIn summary <pre><code>SATDIAG</code></pre> seems to be more like a debugger dumping some performance metrics or resources usage.\nControl protocol\nNext I started playing with the protocol used to talk to the PC software - NOVACOM3:\n\nThe protocol follows request-response pattern\nIn order to display live waveforms protocol has to contain continuous mode which just streams data without additional queries: that is what I want to get\nBy sending different characters I determined that <pre><code>0x00</code></pre> marks end of the packet. There's no signs of any character marking beginning the the packets.\nIt looks like device expects (some?) packets to be 8 bytes (including trailing <pre><code>NULL-BYTE</code></pre>) long - while sending different lengths terminated by <pre><code>0x00</code></pre> I see for 8 bytes device is consistent with replying with 2 bytes.\nSeems to have no checksum - I've got different 2 bytes responses with the same first byte and different 2nd\nResponse packets seems to have no length defined\nSending multiple <pre><code>0x00</code></pre> seems to \"zero\" the device input buffer - while I was playing with determining length sending 3-4 <pre><code>0x00</code></pre> was causing device to behave consistently.\nSending multiple <pre><code>0x00</code></pre> generates no response\nProtocol may have some blocks of commands: while I started scanning by sending 1 byte + <pre><code>0x00</code></pre> I've got no response for 7 bytes after each of the bytes: <pre><code>0x10</code></pre>, <pre><code>0x30</code></pre>, <pre><code>0x50</code></pre>, <pre><code>0x70</code></pre>, <pre><code>0x90</code></pre>, <pre><code>0xb0</code></pre>, <pre><code>0xd0</code></pre>, <pre><code>0xf0</code></pre>\nAll responses which I was able to get were 2 bytes or 4 bytes (and the longer ones seem to be 2 packets actually). Each packet was started with <pre><code>0x2A</code></pre>\nThe only responses o was able to get were: <pre><code>{0x2A, 0xA0}</code></pre>, <pre><code>{0x2A, 0xA1}</code></pre>, <pre><code>{0x2A, 0x80}</code></pre>\nThe packet <pre><code>{0x2A, 0x80}</code></pre> may actually be some sort of ACK, since a lot of times I had to wait for second packet for a 1-1.5s when responses were 4 bytes long.\n<pre><code>0x20</code></pre> (space) / <pre><code>0x40</code></pre> (@) / <pre><code>0x60</code></pre> seems to be a white character - sending it followed by 0x00 leads to no response. These characters are also very common in SATDIAG.  It's a little bit suspicious that they're spaced so evenly 20-40-60. Now while writing this I think it might be some connection with the ranges described few points before (10-30-50-70-90-...)\n\nI'm stucked...\nI wasn't able to force device to start streaming - if I would manage to do that figuring out parameters shouldn't be that hard, since I have the display on the unit and I know which parameters to expect. Until than... I have no idea how to progress further. I also tried contacting Philips division which bought the company - no response whatsoever.\nAny ideas?\n",
    "votes": "3",
    "answers": 0,
    "views": "2k",
    "tags": [
        "hardware",
        "embedded",
        "serial-communication",
        "protocol"
    ],
    "user": "kiler129",
    "time": "Jun 28, 2017 at 5:03",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "are the flash chips soldered or socketed? I would suggest dumping them to extract the firmware, from which you can RE the protocol details.\n",
            "time": null
        },
        {
            "user": "kiler129",
            "text": "@IgorSkochinsky: I just opened the device. Besides the fact it's built like a tank everything is in sockets (even polyfuses!). It has two 2Mbit AT29C020-12JC memory chips, and according to ten service manual they're both occupied by the software. However I have no idea how to read them (without breaking the bank) nor how to analyze the software for this CPU.\n",
            "time": null
        },
        {
            "user": "Antonio Quevedo",
            "text": "I found out your question while searching for the CO2SMO protocol. In the next few days, I will try and run it with the original software, while running a serial data logger in the computer. Then I will check the results, and maybe we can crack the protocol together. Cheers Antonio\n",
            "time": null
        }
    ],
    "answers_data": []
}