{
    "title": "Bitwise operation between byte and 1?",
    "link": "https://reverseengineering.stackexchange.com/questions/20750/bitwise-operation-between-byte-and-1",
    "content": "I am having some trouble understanding what this is doing.\nThis is the commented pseudocode. \n<pre><code>mightGetUserInput(&std::__1::cin, &userInput) ; this fills the buffer with the user input, naming is a bit weird, but I'm not sure how to improve it?\n\nif ( userInput & 1 ) ; wtf is this doing? IDA flags userInput as _BYTE\n{\n  v54 = &userInput;  // \n  v55 = &userInput;  // This is literally junk. Has no use. Would be nice to clean this up but how?\n  v56 = &userInput;  //\n  length_of_userInput = *((_QWORD *)&userInput + 1); I have been able to only trigger this\n}\nelse\n{\n  v51 = &userInput;  //\n  v52 = &userInput;  // This is literally junk. Has no use. Would be nice to clean this up but how?\n  v53 = &userInput;  //\n  length_of_userInput = (signed int)userInput >> 1; No clue what this is doing\n} \n</code></pre>\nThis is the actual assembly if you prefer it:\n<pre><code>mov     [rbp+user_input], rcx\nmov     rcx, [rbp+user_input]\nmovzx   edx, byte ptr [rcx]\nand     edx, 1\ncmp     edx, 0\njz ....\n</code></pre>\nEDIT: Someone in the comments asked for the disassembly of mightGetUserInput: here it is. DISCLAIMER: This is the pseudocode generated by IDA. It's pretty ugly and big.\nI don't really know the size of userInput. It's either referred as void * or as __int64. If this is wrong (and can guide me through IDA, feel free to correct me).\n",
    "votes": "0",
    "answers": 2,
    "views": "99",
    "tags": [
        "ida",
        "assembly"
    ],
    "user": "G. Ramistella",
    "time": "Mar 1, 2019 at 20:02",
    "comments": [
        {
            "user": "wisk",
            "text": "Can you give the size of the var <pre><code>userInput</code></pre> and the disassembly of <pre><code>mightGetUserInput</code></pre>. I would say the original code should be something like: int userInput; std::cin >> userInput; if (userInput & 1) {...} else {...}\n",
            "time": null
        },
        {
            "user": "G. Ramistella",
            "text": "@wisk I added everything in the post.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "At it's most basic level, this code piece checks if the lowest bit of a given variable is set. As mentioned, one possibility is that this code checks if the variable is a even number.\nAnother option (which to me seems more reasonable given the limited context provided), is that the least significant bit is used as a flag/bit-field to signify the state of a value. \nSeveral commonly seen options are:\n\nspecifying whether something is initialized.\nwhat's the type of the value; either a string or an integer, for example. This can be seen in Javascript VMs, for example. To avoid storing an additional field.\nAn encoding of variable length values. ASN1, for example, encodes it's variable-length length fields dedicating a bit to whether this is the last byte of the length field.\n",
            "votes": "0",
            "user": "NirIzr",
            "time": "Mar 3, 2019 at 12:41",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "it may be a check for odd numbers\n",
            "votes": "0",
            "user": "blabb",
            "time": "Mar 2, 2019 at 4:16",
            "is_accepted": false,
            "comments": []
        }
    ]
}