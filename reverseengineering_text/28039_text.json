{
    "title": "Access data at memory address that is part of a struct",
    "link": "https://reverseengineering.stackexchange.com/questions/28039/access-data-at-memory-address-that-is-part-of-a-struct",
    "content": "Problem\nI have a struct of some type, say the DOS header at the beginning of a typical PE file:\n<pre><code>/DOS/IMAGE_DOS_HEADER\npack(disabled)\nStructure IMAGE_DOS_HEADER {\n   0   char[2]   2   e_magic   \"Magic number\"\n   2   word   2   e_cblp   \"Bytes of last page\"\n   4   word   2   e_cp   \"Pages in file\"\n   6   word   2   e_crlc   \"Relocations\"\n   8   word   2   e_cparhdr   \"Size of header in paragraphs\"\n   10   word   2   e_minalloc   \"Minimum extra paragraphs needed\"\n   12   word   2   e_maxalloc   \"Maximum extra paragraphs needed\"\n   14   word   2   e_ss   \"Initial (relative) SS value\"\n   16   word   2   e_sp   \"Initial SP value\"\n   18   word   2   e_csum   \"Checksum\"\n   20   word   2   e_ip   \"Initial IP value\"\n   22   word   2   e_cs   \"Initial (relative) CS value\"\n   24   word   2   e_lfarlc   \"File address of relocation table\"\n   26   word   2   e_ovno   \"Overlay number\"\n   28   word[4]   8   e_res[4]   \"Reserved words\"\n   36   word   2   e_oemid   \"OEM identifier (for e_oeminfo)\"\n   38   word   2   e_oeminfo   \"OEM information; e_oemid specific\"\n   40   word[10]   20   e_res2[10]   \"Reserved words\"\n   60   dword   4   e_lfanew   \"File address of new exe header\"\n   64   byte[64]   64   e_program   \"Actual DOS program\"\n}\nSize = 128   Actual Alignment = 1\n</code></pre>\nat address <pre><code>00400000</code></pre> in memory that is initialized as part of the loader and has some fixed values. It's already defined as a struct in Ghidra, e.g. by some auto analysis.\n\nNow I want to get the value of e.g. <pre><code>e_cp</code></pre>, the \"Pages in file\", in this case <pre><code>3</code></pre>, ideally as a proper Ghidra datatype in case that is a pointer, address or some more complex datatype. Ideally I want to access it by the name \"e_cp\" and not by hardcoding the offset.\nAttempts\n<pre><code>getDataAt(currentProgram.imageBase + 4)</code></pre>, returns <pre><code>null</code></pre>,\n<pre><code>etDataContaining(currentProgram.imageBase + 4)</code></pre> returns a DataDB object for the entire <pre><code>IMAGE_DOS_HEADER</code></pre> struct.\nHow can I get the actual value in memory at a known address, that is part of a struct?\n",
    "votes": "2",
    "answers": 2,
    "views": "3k",
    "tags": [
        "ghidra"
    ],
    "user": "Florian Magin",
    "time": "Jul 26, 2021 at 15:33",
    "comments": [
        {
            "user": "blabb",
            "text": ">>> getDataContaining(currentProgram.imageBase).getComponentAt(4) dw 3h  is that what you need ?\n",
            "time": null
        },
        {
            "user": "Florian Magin",
            "text": "yes, this was pretty much what I needed, and had initially tried to find on the RE SE, but didn't find an existing question. In the process of writing up the question I had found the solution myself and posted the question and a self answer as is encouraged stackoverflow.com/help/self-answer\n",
            "time": null
        },
        {
            "user": "blabb",
            "text": "I read your self answer but wasn't sure what was the required end result ?  what you were looking for so commented and answered  btw .....dat.getAllStructures() will return an iterator you can cast any data as any structure using next()  some thing like windbg (nt!_EPROCESS *) 0x1234\n",
            "time": null
        },
        {
            "user": "Florian Magin",
            "text": "The core of the answer is <pre><code>.getComponentAt</code></pre>. it took me a while to realize that the method for the datatype and the data object are different.\n",
            "time": null
        },
        {
            "user": "Florian Magin",
            "text": "I am not sure how <pre><code>dat.getAllStructures()</code></pre> would have helped me though. It seems easier to get the datatype of the data by using <pre><code>getDataContaining(currentProgram.imageBase).dataType</code></pre>\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "As i commented is this what you are looking for ?\n<pre><code>>>> base = getDataContaining(currentProgram.imageBase)\n>>> base\nIMAGE_DOS_HEADER \n>>> for i in range (0,base.length,1):\n...     print ( base.baseDataType.getComponentAt(i).toString() , base.getComponentAt(i))\n... \n(u'  0  0  char[2]  2  e_magic  \"Magic number\"', char[2] \"MZ\")\n(u'  0  0  char[2]  2  e_magic  \"Magic number\"', char[2] \"MZ\")\n(u'  1  2  word  2  e_cblp  \"Bytes of last page\"', dw 90h)\n(u'  1  2  word  2  e_cblp  \"Bytes of last page\"', dw 90h)\n(u'  2  4  word  2  e_cp  \"Pages in file\"', dw 3h)\n(u'  2  4  word  2  e_cp  \"Pages in file\"', dw 3h)\n(u'  3  6  word  2  e_crlc  \"Relocations\"', dw 0h)\n(u'  3  6  word  2  e_crlc  \"Relocations\"', dw 0h)\n(u'  4  8  word  2  e_cparhdr  \"Size of header in paragraphs\"', dw 4h)\n(u'  4  8  word  2  e_cparhdr  \"Size of header in paragraphs\"', dw 4h)\n(u'  5  10  word  2  e_minalloc  \"Minimum extra paragraphs needed\"', dw 0h)\n(u'  5  10  word  2  e_minalloc  \"Minimum extra paragraphs needed\"', dw 0h)\n(u'  6  12  word  2  e_maxalloc  \"Maximum extra paragraphs needed\"', dw FFFFh)\n(u'  6  12  word  2  e_maxalloc  \"Maximum extra paragraphs needed\"', dw FFFFh)\n(u'  7  14  word  2  e_ss  \"Initial (relative) SS value\"', dw 0h)\n(u'  7  14  word  2  e_ss  \"Initial (relative) SS value\"', dw 0h)\n(u'  8  16  word  2  e_sp  \"Initial SP value\"', dw B8h)\n(u'  8  16  word  2  e_sp  \"Initial SP value\"', dw B8h)\n(u'  9  18  word  2  e_csum  \"Checksum\"', dw 0h)\n(u'  9  18  word  2  e_csum  \"Checksum\"', dw 0h)\n(u'  10  20  word  2  e_ip  \"Initial IP value\"', dw 0h)\n(u'  10  20  word  2  e_ip  \"Initial IP value\"', dw 0h)\n(u'  11  22  word  2  e_cs  \"Initial (relative) CS value\"', dw 0h)\n(u'  11  22  word  2  e_cs  \"Initial (relative) CS value\"', dw 0h)\n(u'  12  24  word  2  e_lfarlc  \"File address of relocation table\"', dw 40h)\n(u'  12  24  word  2  e_lfarlc  \"File address of relocation table\"', dw 40h)\n(u'  13  26  word  2  e_ovno  \"Overlay number\"', dw 0h)\n(u'  13  26  word  2  e_ovno  \"Overlay number\"', dw 0h)\n(u'  14  28  word[4]  8  e_res[4]  \"Reserved words\"', dw[4] )\n(u'  14  28  word[4]  8  e_res[4]  \"Reserved words\"', dw[4] )\n(u'  14  28  word[4]  8  e_res[4]  \"Reserved words\"', dw[4] )\n(u'  14  28  word[4]  8  e_res[4]  \"Reserved words\"', dw[4] )\n(u'  14  28  word[4]  8  e_res[4]  \"Reserved words\"', dw[4] )\n(u'  14  28  word[4]  8  e_res[4]  \"Reserved words\"', dw[4] )\n(u'  14  28  word[4]  8  e_res[4]  \"Reserved words\"', dw[4] )\n(u'  14  28  word[4]  8  e_res[4]  \"Reserved words\"', dw[4] )\n(u'  15  36  word  2  e_oemid  \"OEM identifier (for e_oeminfo)\"', dw 0h)\n(u'  15  36  word  2  e_oemid  \"OEM identifier (for e_oeminfo)\"', dw 0h)\n(u'  16  38  word  2  e_oeminfo  \"OEM information; e_oemid specific\"', dw 0h)\n(u'  16  38  word  2  e_oeminfo  \"OEM information; e_oemid specific\"', dw 0h)\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  17  40  word[10]  20  e_res2[10]  \"Reserved words\"', dw[10] )\n(u'  18  60  dword  4  e_lfanew  \"File address of new exe header\"', ddw 108h)\n(u'  18  60  dword  4  e_lfanew  \"File address of new exe header\"', ddw 108h)\n(u'  18  60  dword  4  e_lfanew  \"File address of new exe header\"', ddw 108h)\n(u'  18  60  dword  4  e_lfanew  \"File address of new exe header\"', ddw 108h)\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n(u'  19  64  byte[64]  64  e_program  \"Actual DOS program\"', db[64] )\n</code></pre>\n",
            "votes": "2",
            "user": "blabb",
            "time": "Jul 24, 2021 at 18:26",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "I want to get the value of e.g. e_cp, the \"Pages in file\", in this case 3, ideally as a proper Ghidra datatype in case that is a pointer, address or some more complex datatype\n\nYou have to access a member of a struct (or an array) with the <pre><code>getComponent</code></pre> method, e.g. in Kotlin code( easily changed to Python or Java):\n<pre><code>var struct: DataDB = getDataAt(currentProgram.imageBase)\nstruct.getComponent(2)\n</code></pre>\nthis will return the value for the third (zero indexing) component of the <pre><code>IMAGE_DOS_HEADER</code></pre> struct: <pre><code>dw 3h</code></pre>\n\nIdeally I want to access it by the name \"e_cp\" and not by hardcoding the offset.\n\nThere seems to be no direct way to access a struct my member name. The information about the member names, types and sizes is contained in <pre><code>struct.dataType</code></pre> if this is cast to <pre><code>Structure</code></pre> you can use <pre><code>getComponent</code></pre> (different method than above!):\n<pre><code>import ghidra.program.model.data.Structure\nvar struct: Data = getDataAt(currentProgram.imageBase)\nvar structType: Structure = struct.dataType as Structure\nstructType.getComponent(2)\n</code></pre>\nwill result in a <pre><code>DataTypeComponent</code></pre> object rendered as:\n<pre><code>2  4  word  2  e_cp  \"Pages in file\"</code></pre>.\nThis object has an attribute <pre><code>fieldName</code></pre> that contains the name \"e_cp\" of this member.\nYou can use the <pre><code>structType.components</code></pre> attribute to find the field with your desired name, and then get the <pre><code>.ordinal</code></pre> attribute of the <pre><code>DataTypeComponent</code></pre> object to get the correct index to pass to <pre><code>struct.getComponent</code></pre>\nFor convenience and only in Kotlin you can define an Extension Method\n<pre><code>operator fun Data.get(name: String): Data? {\n    if (this.dataType is Structure){\n        val s = (this.dataType as Structure)\n        val idx = s.components.firstOrNull { it.fieldName == name }?.ordinal\n        return idx?.let(this::getComponent)\n    }\n    return null\n}\n</code></pre>\nthat allows <pre><code>Data</code></pre> objects to be indexed with a string, which will search the components for a field matching the passed string, and return the appropriate component:\n<pre><code>In [1]: getDataAt(currentProgram.imageBase)[\"e_cp\"]\nOut[1]: dw 3h\n</code></pre>\n",
            "votes": "2",
            "user": "Florian Magin",
            "time": "Jul 26, 2021 at 15:34",
            "is_accepted": true,
            "comments": []
        }
    ]
}