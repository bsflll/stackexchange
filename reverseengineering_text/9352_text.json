{
    "title": "Finding all API calls in a function",
    "link": "https://reverseengineering.stackexchange.com/questions/9352/finding-all-api-calls-in-a-function",
    "content": "is there a way to get a listing of all called APIs in a function via IDAPython. For example I have the below code from a function. \n<pre><code>.text:003A33D9                 call    esi ; _snwprintf\n.text:003A33DB                 add     esp, 1Ch\n.text:003A33DE                 mov     eax, 3A4336h\n.text:003A33E3                 push    ebx             ; dwReserved\n.text:003A33E4                 mov     [ebp+var_C], eax\n.text:003A33E7                 mov     [ebp+var_8], eax\n.text:003A33EA                 push    0Ch             ; dwBufferLength\n.text:003A33EC                 lea     eax, [ebp+pBuffer]\n.text:003A33EF                 push    eax             ; pBuffer\n.text:003A33F0                 push    26h             ; dwOption\n.text:003A33F2                 mov     [ebp+pBuffer], 1\n.text:003A33F9                 call    ds:UrlMkSetSessionOption\n.text:003A33FF                 lea     eax, [ebp+szUrlName]\n.text:003A3405                 push    eax             ; lpszUrlName\n.text:003A3406                 call    ds:DeleteUrlCacheEntryW\n</code></pre>\nI'd like to get all the API calls ( _snwprintf, UrlMkSetSessionOption, DeleteUrlCacheEntryW, etc). The following IDAPython function can be used to get most of them. \n<pre><code>def get_apis(func_addr):\n        calls = 0\n        apis = []\n        flags = GetFunctionFlags(func_addr)\n        # ignore library functions\n        if flags & FUNC_LIB or flags & FUNC_THUNK:\n            logging.debug(\"get_apis: Library code or thunk\")\n            return None\n        # list of addresses\n        dism_addr = list(FuncItems(func_addr))\n        for instr in dism_addr:\n            tmp_api_address = \"\"\n            if idaapi.is_call_insn(instr):\n                # In theory an API address should only have one xrefs\n                # The xrefs approach was used because I could not find how to\n                # get the API name by address.\n                for xref in XrefsFrom(instr, idaapi.XREF_FAR):\n                    if xref.to == None:\n                        calls += 1\n                        continue\n                    tmp_api_address = xref.to\n                    break\n                # get next instr since api address could not be found\n                if tmp_api_address == \"\":\n                    calls += 1\n                    continue\n                api_flags = GetFunctionFlags(tmp_api_address)\n                # check for lib code (api)\n                if api_flags & idaapi.FUNC_LIB == True or api_flags & idaapi.FUNC_THUNK:\n                    tmp_api_name = NameEx(0, tmp_api_address)\n                    if tmp_api_name:\n                        apis.append(tmp_api_name)\n                else:\n                    calls += 1\n        return (calls, apis\n</code></pre>\nOutput         \n<pre><code>Python>get_apis(here())\n(18, ['UrlMkSetSessionOption', 'DeleteUrlCacheEntryW', 'URLDownloadToFileW', 'GetModuleFileNameW', 'CreateProcessW', 'Sleep', 'ExitProcess', 'RtlGetLastWin32Error', 'byte_3A3E45', 'RtlGetLastWin32Error'])        \n</code></pre>\nThe issue I'm having is <pre><code>call  esi ; _snwprintf</code></pre> is not present. I understand I could use backtracing to find the value of ESI but I'd like to find another approach. Is there a more reliable technique for getting all APIs in a function? Similar data is present in the proximity browser.\n",
    "votes": "4",
    "answers": 2,
    "views": "6k",
    "tags": [
        "ida",
        "idapython"
    ],
    "user": "alexanderh",
    "time": "Jul 15, 2015 at 2:50",
    "comments": [
        {
            "user": "fileoffset",
            "text": "Maybe exhaustive emulation?\n",
            "time": null
        },
        {
            "user": "tmr232",
            "text": "Whenever you detect a register call, you can use <pre><code>idaapi.is_tilcmt</code></pre> to check if the comment is automatically propagated by IDA. If it is, it is pretty safe to assume that it is the name of the function being called. Would be able to help more as soon as I get to a computer with IDA on it.\n",
            "time": null
        },
        {
            "user": "OneAndOnly",
            "text": "Hey there, have you found any better way of gathering API calls that works on .NET files as well? whats your final code? thanks\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "an idc script that scans for Register calls and prints them\n( this script is using text search because ida wild card ? appears to be useless for masking\nie we cant search binary like  FF D?   so that all binary sequences \"ff d0\",\"ff d1\",\"ff d2\",etc can be searched at once) \n<pre><code>#include <idc.idc>\nstatic main (void) {\n  auto offset,count;\n  count = 1;\n  offset= MinEA();\n  while(offset != BADADDR) {\n    offset = FindText(offset+2,3,0,0,\"call    e\");\n    Message(\n    \"%03d %08x %s %s %s\n\",\n    count++,\n    offset,\n    GetMnem(offset),\n    GetOpnd(offset,0),\n    Name(Dfirst(offset))\n    );\n  }\n}\n</code></pre>\nresult on calc.exe xp sp3 x86\n<pre><code>Compiling file 'C:\\Documents and Settings\\Admin\\My Documents\\callreg.idc'...\nExecuting function 'main'...\n001 01001682 call esi CharNextW\n002 010016ba call esi CharNextW\n003 01001713 call esi \n004 01001740 call esi \n005 0100178b call esi \n006 010017b4 call esi \n007 01001a74 call esi GetProfileStringW\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n069 01007b5d call esi LoadLibraryA\n070 01007ba0 call eax \n071 0101248a call edi GetModuleHandleA\n072 010125e1 call edi GetModuleHandleA\n073 ffffffff   \n</code></pre>\n",
            "votes": "2",
            "user": "blabb",
            "time": "Jul 15, 2015 at 11:05",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "Using the minsc plugin at https://github.com/arizvisa/ida-minsc, you can do something like the following.\nDisclaimer: I maintain the ida-minsc plugin.\nNormally, to get all the calls from a function, you can use <pre><code>function.xref.calls</code></pre> (this is aliased as <pre><code>function.calls</code></pre> in minsc). From this, you could differentiate the results being returned by checking if it's loading from an address (+r), or just being used immediately (-r). This unfortunately means that you'll need to specially handle each operand.\n<pre><code>calls = []\nfor ref in func.calls():\n    if 'x' in ref:\n        calls.append(ref)\n    continue\n</code></pre>\nTo avoid this special handling for the operand type, we can instead check all the references using <pre><code>function.xref.down</code></pre>. We only care about references that are potentially executed, so we can filter those by checking if the reference is executable (+x). In the following snippet, we collect both the references to the instruction and a reference to the instruction's target.\n<pre><code>candidates = []\nfor ref, target in func.down():\n    if 'x' in ref:\n        candidates.append((ref, target))\n    continue\n</code></pre>\nNow, we need to filter these candidates for branches targeting an address that we might consider an API. As per some of the other answers, we'll use two sets of conditions to distinguish what we may consider a potential API call. The first condition is simply that if the target address is a known import, we can consider it a candidate. The second conditions are if the target address is a function, and has its flags set to be a library or a thunk, then it might also be a candidate.\nTo check if an address is considered an import, we can normally use <pre><code>database.imports.has</code></pre>. However, due to the way that IDA exposes imports (and laziness of the author of the minsc plugin), this could result in an O(n) time search for every address. One way to avoid this could be to make the assumption that if the target address is in a segment of type <pre><code>SEG_XTRN</code></pre> (using <pre><code>idaapi.segtype</code></pre>), then we could consider it an import. Despite this (since we care about the import name), we'll instead create a table of addresses for each valid import. This is done using the <pre><code>database.imports</code></pre> namespace in minsc.\n<pre><code>imports = {ea for ea, _ in database.imports()}\n</code></pre>\nNow that we have a set of imports, we can iterate through the list of candidates and check for our two conditions. The first condition requires checking the target address against our collected imports. The second condition uses <pre><code>function.has</code></pre>, <pre><code>function.type.library</code></pre>, and <pre><code>function.type.thunk</code></pre> to ensure that the target is a function and has either its thunk or library flag set.\n<pre><code>apis = []\nfor ref, target in candidates:\n    if target.address in imports:\n        print('import', db.disasm(ref))\n        apis.append((ref, target))\n\n    elif func.has(target) and (func.type.library(target) or func.type.thunk(target)):\n        print('library', db.name(target))\n        apis.append((ref, target))\n    continue\n</code></pre>\nFrom executing this python, we now have a list of APIs that we'll need to extract the names from. We can usually use the name for an address that is exposed by minsc via the <pre><code>database.name</code></pre> or <pre><code>function.name</code></pre> functions. Imports, however, can have a name and module that is entirely different from the name associated with the address in the database. To accommodate this characteristic about imports, we will special-case any target addresses that we know belong to an import so that we can extract the full name properly.\nThere's multiple ways of doing this, such as using a combination of the <pre><code>database.imports.name</code></pre> and <pre><code>database.imports.module</code></pre> functions. Instead, however, we will use the <pre><code>database.imports.fullname</code></pre> function to include the module with the name as a combined string.\n<pre><code>tally = {}\nfor ref, target in apis:\n    if func.has(target):\n        assert(func.type.library(target) or func.type.thunk(target))\n        name = func.name(target)\n\n    else:\n        assert(target.address in imports)\n        name = database.imports.fullname(target.address)\n\n    # collect all reference pairs using the target name as a key\n    items = tally.setdefault(name, [])\n    items.append((ref, target))\n\n# format as a count of calls and unique names\ncount = sum(len(refs) for _, refs in tally.items())\nnames = {name for name in tally}\ncount, list(names)\n</code></pre>\nThis results in the following output.\n<pre><code>import 117c6: call ds:ExAllocatePoolWithTag(x,x,x)\nimport 11804: call ds:ExFreePoolWithTag(x,x)\nlibrary _memset\n...\nimport 11b18: call ds:KfReleaseSpinLock(x,x)\n\n(0x11, ['ntoskrnl!ExFreePoolWithTag', 'HAL!KfAcquireSpinLock', 'ntoskrnl!PsGetCurrentProcess', 'ntoskrnl!RtlEqualSid', '_memset', 'HAL!KfReleaseSpinLock', 'ntoskrnl!KeInitializeSpinLock', 'ntoskrnl!ExAllocatePoolWithTag'])\n</code></pre>\nIf we want, we can check out tallied results using the \"<pre><code>calls</code></pre>\" variable that we gathered at the beginning with <pre><code>function.calls</code></pre>. We can use this to identify calls that are being made to a function that either did not meet our conditions, or did not have a reference to a target function. To accomplish this, we'll collect all our calls into a set, and then we'll iterate through our tallied results whilst discarding any matching references from our calls.\n<pre><code>skipped = {ref for ref in calls}\nfor name, references in tally.items():\n    for ref, target in references:\n        skipped.discard(ref)\n    continue\n</code></pre>\nNow we can go back through our leftover calls in \"<pre><code>skipped</code></pre>\" to identify everything that was listed, namely items that did not meet our two constraints. If the call is not loading its value from the target address (does not have +r), we will check to see if it is a register so that we can display calls that do not have a data reference. If it is loading its value from the target address, then this could be a memory reference operand of some sort that we would probably want to display.\n<pre><code>for ref in skipped:\n    if 'x' in ref and isinstance(ins.op(ref), register_t):\n        print('register-without-xref', db.disasm(ref))\n    elif 'r' in ref:\n        print('loaded', db.disasm(ref))\n    assert(ins.t.call(ref))\n</code></pre>\nResults could look something like the following.\n<pre><code>loaded 118c8: call dword ptr [si-72h]\nregister-without-xref 118c6: call esi\n</code></pre>\nFor the sake of displaying the special case that we wanted to ensure was handled, we will do another pass through the tallied results in order to list all call instruction that dispatch using a register and contain a data reference.\n<pre><code>for name, references in tally.items():\n    for ref, target in references:\n        if 'x' in ref and isinstance(ins.op(ref), register_t):\n            print('register-with-xref', name, db.disasm(ref))\n        elif 'r' in ref:\n            print('loaded-with-xref', name, db.disasm(ref))\n        continue\n    continue\n</code></pre>\nThe output from this could look like the following.\n<pre><code>loaded-with-xref ntoskrnl!ExAllocatePoolWithTag 117c6: call ds:ExAllocatePoolWithTag(x,x,x)\nloaded-with-xref ntoskrnl!ExFreePoolWithTag 11804: call ds:ExFreePoolWithTag(x,x)\nregister-with-xref ntoskrnl!ExFreePoolWithTag 118af: call esi\nregister-with-xref ntoskrnl!ExFreePoolWithTag 118b4: call esi\nloaded-with-xref ntoskrnl!KeInitializeSpinLock 11840: call ds:KeInitializeSpinLock(x)\nloaded-with-xref ntoskrnl!PsGetCurrentProcess 11850: call ds:PsGetCurrentProcess()\n</code></pre>\n",
            "votes": "0",
            "user": "Ali Rizvi-Santiago",
            "time": "Jul 21, 2024 at 3:33",
            "is_accepted": false,
            "comments": []
        }
    ]
}