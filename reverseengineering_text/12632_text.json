{
    "title": "How does GPROF hook to the program?",
    "link": "https://reverseengineering.stackexchange.com/questions/12632/how-does-gprof-hook-to-the-program",
    "content": "I compiled a simple <pre><code>helloworld</code></pre> and took a look at the disassembly using <pre><code>objdump</code></pre>.\nAt the beginning there is the <pre><code>_init</code></pre>:\n<pre><code>0000000000400600 <_init>:\n  400600:   48 83 ec 08             sub    rsp,0x8\n  400604:   48 8b 05 ed 09 20 00    mov    rax,QWORD PTR [rip+0x2009ed]        # 600ff8 <_DYNAMIC+0x1e0>\n  40060b:   48 85 c0                test   rax,rax\n  40060e:   74 05                   je     400615 <_init+0x15>\n  400610:   e8 1b 00 00 00          call   400630 <__gmon_start__@plt>\n  400615:   48 83 c4 08             add    rsp,0x8\n  400619:   c3                      ret    \n</code></pre>\nWhat is <pre><code>_DYNAMIC</code></pre>?\nUsing <pre><code>-x</code></pre> I can see the section details:\n<pre><code>Dynamic Section:\n  NEEDED               libstdc++.so.6\n  NEEDED               libc.so.6\n  INIT                 0x0000000000400600\n  FINI                 0x0000000000400864\n  INIT_ARRAY           0x0000000000600df8\n  INIT_ARRAYSZ         0x0000000000000010\n  FINI_ARRAY           0x0000000000600e08\n  FINI_ARRAYSZ         0x0000000000000008\n  GNU_HASH             0x0000000000400298\n  STRTAB               0x00000000004003c8\n  SYMTAB               0x00000000004002c0\n  STRSZ                0x000000000000011c\n  SYMENT               0x0000000000000018\n  DEBUG                0x0000000000000000\n  PLTGOT               0x0000000000601000\n  PLTRELSZ             0x0000000000000090\n  PLTREL               0x0000000000000007\n  JMPREL               0x0000000000400570\n  RELA                 0x0000000000400540\n  RELASZ               0x0000000000000030\n  RELAENT              0x0000000000000018\n  VERNEED              0x0000000000400500\n  VERNEEDNUM           0x0000000000000002\n  VERSYM               0x00000000004004e4\n</code></pre>\nHowever, I am not sure which entry is <pre><code>rip+0x2009ed</code></pre> referring to.\nConsidering that the next line is a call to <pre><code>gmon</code></pre>, does it have anything to do with a <pre><code>GPROF</code></pre> hook?\n",
    "votes": "3",
    "answers": 1,
    "views": "299",
    "tags": [
        "assembly",
        "x86-64"
    ],
    "user": "drum",
    "time": "May 11, 2016 at 5:14",
    "comments": [],
    "answers_data": [
        {
            "content": "This is a trick that's used by the initialization code to support monitoring when it's compiled in, and omit it when it isn't compiled in.\nWhen i compile a small test program using <pre><code>gcc -pg</code></pre>, then invoke <pre><code>objdump -Mintel -d</code></pre> on it, i get:\n<pre><code>00000000004004c0 <_init>:\n  4004c0:   48 83 ec 08             sub    rsp,0x8\n  4004c4:   48 8d 05 c5 00 00 00    lea    rax,[rip+0xc5]        # 400590 <__gmon_start__>\n  4004cb:   48 85 c0                test   rax,rax\n  4004ce:   74 05                   je     4004d5 <_init+0x15>\n  4004d0:   e8 bb 00 00 00          call   400590 <__gmon_start__>\n  4004d5:   48 83 c4 08             add    rsp,0x8\n  4004d9:   c3                      ret    \n</code></pre>\nIf i omit the <pre><code>-pg</code></pre> when compiling, this changes to:\n<pre><code>0000000000400418 <_init>:\n  400418:   48 83 ec 08             sub    rsp,0x8\n  40041c:   48 8b 05 d5 0b 20 00    mov    rax,QWORD PTR [rip+0x200bd5]        # 600ff8 <_DYNAMIC+0x1d0>\n  400423:   48 85 c0                test   rax,rax\n  400426:   74 05                   je     40042d <_init+0x15>\n  400428:   e8 43 00 00 00          call   400470 <__gmon_start__@plt>\n  40042d:   48 83 c4 08             add    rsp,0x8\n  400431:   c3                      ret    \n</code></pre>\nSo you see that, with monitoring enabled, the code checks if <pre><code>__gmon_start__</code></pre> is not null before calling the function. With monitoring disabled, it checks some variable, and if it is 0, it skips the call to <pre><code>__gmon_start__</code></pre>.\nBut wait. Why do we have a <pre><code>lea</code></pre> in the first case, and a <pre><code>mov</code></pre> in the second one? And why does the name end in <pre><code>@plt</code></pre> ?\nBecause, even if your program doesn't have profiling compiled in, maybe some of your dynamic libraries do, and maybe you're running against a profiling-enabled version of the C library. So the C library may provide a dynamic version of <pre><code>__gmon_start__</code></pre>, and it provides a flag to mark if it does so. This function and flag are defined in the GOT and GOTPLT sections.\nAnd indeed, if you note the address that's used, <pre><code>600FF8</code></pre>, and scroll down the <pre><code>objdump -x</code></pre> output a bit from your section details, you'll see:\n<pre><code> 21 .got          00000008  0000000000600ff8  0000000000600ff8  00000ff8  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 22 .got.plt      00000038  0000000000601000  0000000000601000  00001000  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n</code></pre>\nyou'll see the code accesses a GOT table entry (which, for a small test program, is the only entry in the GOT there is, which is why GOT is just 8 bytes in size).\n",
            "votes": "3",
            "user": "Guntram Blohm",
            "time": "May 11, 2016 at 7:10",
            "is_accepted": true,
            "comments": []
        }
    ]
}