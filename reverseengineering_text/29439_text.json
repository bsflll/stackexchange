{
    "title": "What's purpose of mov ebx, [esp+0]?",
    "link": "https://reverseengineering.stackexchange.com/questions/29439/whats-purpose-of-mov-ebx-esp0",
    "content": "I'm disassembling one SO library for fun and was wondering what's purpose of following procedure:\n<pre><code>sub_3699 proc near\nmov     ebx, [esp+0]\nretn\nsub_3699 endp\n</code></pre>\nIt's widely used across entire library with very confusing pattern (at least to me) like this:\n<pre><code>push    ebp\nmov     ebp, esp\npush    esi\npush    ebx\ncall    sub_3699        ; Here it is called\nadd     ebx, 1DD5Ch     ; And this magic number is something I'm trying to understand\n...                     ; rest of caller body\npop     ebx\npop     esi\npop     ebp\nretn\n</code></pre>\nPlease note magic number <pre><code>1DD5Ch</code></pre> added to <pre><code>EBX</code></pre> after procedure invocation. It seems that this number is unique across all invocations, but I have no idea of its purpose. Even <pre><code>EBX</code></pre> register itself doesn't seem to be read/write within caller code.\nAny idea?\nIf that matters, here is output of <pre><code>readelf -s ...</code></pre>\n<pre><code>ELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x14340\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          275660 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         5\n  Size of section headers:           40 (bytes)\n  Number of section headers:         25\n  Section header string table index: 24\n\nSection Headers:\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\n  [ 1] .hash             HASH            000000d4 0000d4 00221c 04   A  2   0  4\n  [ 2] .dynsym           DYNSYM          000022f0 0022f0 0047e0 10   A  3   1  4\n  [ 3] .dynstr           STRTAB          00006ad0 006ad0 00825f 00   A  0   0  1\n  [ 4] .gnu.version      VERSYM          0000ed30 00ed30 0008fc 02   A  2   0  2\n  [ 5] .gnu.version_r    VERNEED         0000f62c 00f62c 000020 00   A  3   1  4\n  [ 6] .rel.dyn          REL             0000f64c 00f64c 000eb8 08   A  2   0  4\n  [ 7] .rel.plt          REL             00010504 010504 0014b0 08   A  2   9  4\n  [ 8] .init             PROGBITS        000119b4 0119b4 00001c 00  AX  0   0  1\n  [ 9] .plt              PROGBITS        000119d0 0119d0 002970 04  AX  0   0 16\n  [10] .text             PROGBITS        00014340 014340 02b324 00  AX  0   0  4\n  [11] .fini             PROGBITS        0003f664 03f664 000017 00  AX  0   0  1\n  [12] .rodata           PROGBITS        0003f680 03f680 001fa0 00   A  0   0  8\n  [13] .eh_frame_hdr     PROGBITS        00041620 041620 00002c 00   A  0   0  4\n  [14] .eh_frame         PROGBITS        0004164c 04164c 0000f8 00   A  0   0  4\n  [15] .ctors            PROGBITS        00042000 042000 000018 00  WA  0   0  4\n  [16] .dtors            PROGBITS        00042018 042018 000018 00  WA  0   0  4\n  [17] .jcr              PROGBITS        00042030 042030 000004 00  WA  0   0  4\n  [18] .data.rel.ro      PROGBITS        00042038 042038 0006d8 00  WA  0   0  8\n  [19] .dynamic          DYNAMIC         00042710 042710 0000d0 08  WA  3   0  4\n  [20] .got              PROGBITS        000427e0 0427e0 0001b4 04  WA  0   0  4\n  [21] .got.plt          PROGBITS        00042994 042994 000a64 04  WA  0   0  4\n  [22] .data             PROGBITS        000433f8 0433f8 000010 00  WA  0   0  4\n  [23] .bss              NOBITS          00043408 043408 000bb0 00  WA  0   0  8\n  [24] .shstrtab         STRTAB          00000000 043408 0000c3 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  p (processor specific)\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  LOAD           0x000000 0x00000000 0x00000000 0x41744 0x41744 R E 0x1000\n  LOAD           0x042000 0x00042000 0x00042000 0x01408 0x01fb8 RW  0x1000\n  DYNAMIC        0x042710 0x00042710 0x00042710 0x000d0 0x000d0 RW  0x4\n  GNU_EH_FRAME   0x041620 0x00041620 0x00041620 0x0002c 0x0002c R   0x4\n  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4\n\n Section to Segment mapping:\n  Segment Sections...\n   00     .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame \n   01     .ctors .dtors .jcr .data.rel.ro .dynamic .got .got.plt .data .bss \n   02     .dynamic \n   03     .eh_frame_hdr \n   04     \n</code></pre>\n",
    "votes": "2",
    "answers": 1,
    "views": "453",
    "tags": [
        "disassembly",
        "x86"
    ],
    "user": "rkosegi",
    "time": "Oct 21, 2021 at 14:58",
    "comments": [],
    "answers_data": [
        {
            "content": "The purpose of <pre><code>sub_3699</code></pre> is to return address of the next instruction after the one that called that procedure. <pre><code>call sub_3699</code></pre> pushes address of the next instruction onto the stack and jumps to the first instruction of <pre><code>sub_3699</code></pre>.\nThat instruction takes the value at the top of the stack (without removing it) and writes it to <pre><code>ebx</code></pre>. Such a mechanism is usually used when position independent code is generated to avoid accessing data using harcoded addresses (though combination of <pre><code>call $+5, pop reg</code></pre> is more popular).\nSo instead of accessing some <pre><code>addr</code></pre> directly, you compute it relatively to the address of the next instruction. So, you first compute <pre><code>addr - address_of_next_instruction = addr - sub_3699() = 0x1DD5C</code></pre> (in your case) and to obtain <pre><code>addr</code></pre> you have to simply add <pre><code>sub_3699()</code></pre> to that number. After this addition, <pre><code>ebx</code></pre> contains <pre><code>addr</code></pre>.\n",
            "votes": "3",
            "user": "bart1e",
            "time": "Oct 21, 2021 at 17:57",
            "is_accepted": true,
            "comments": [
                {
                    "user": "rkosegi",
                    "text": "<span class=\"comment-copy\">Thank you, it make sense now</span>",
                    "time": null
                }
            ]
        }
    ]
}