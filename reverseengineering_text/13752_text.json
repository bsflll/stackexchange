{
    "title": "Programmatically reverse-engineering a dynamic dispatch method",
    "link": "https://reverseengineering.stackexchange.com/questions/13752/programmatically-reverse-engineering-a-dynamic-dispatch-method",
    "content": "Background: I want to convert Qt RTTI into symbols, to more easily navigate a large executable.\nIf you don't know already, Qt is a C++ application framework based on a message passing system. Since C++ has very little in the way of introspection and reflection, which are important features for an expressive message passing system, Qt comes with a tool called moc (Meta Object Compiler), which parses your source files and builds an index of classes, methods, properties etc. that need to be enumerated, resolved, etc. at runtime. Sadly, the metadata generated by moc is optimized for runtime access (in part because of limitations of the C++ language) and is slightly hostile to static analysis. In particular, you'd expect method tables like this (pseudocode):\n<pre><code>methods = {\n    \"frob\" -> &frob,\n    \"fuzz\" -> &fuzz\n}\n</code></pre>\nbut for several boring reasons, moc generates a dispatch method instead (pseudocode again):\n<pre><code>dispatch(method, args) {\n    switch(method) {\n        case \"frob\": return frob(args)\n        case \"fuzz\": return fuzz(args)\n        default: return -1\n    }\n}\n</code></pre>\nNeedless to say, decompiling even simple, machine-generated code is much, much harder than analyzing static data.\nConceptually, it's simple: find all dispatch functions, and run each of them in a simulator until it performs a call or returns; extract the method implementation address from the call opcode, write to symbol/map file with the method name. I already have a quick hack to identify dispatch functions (a hacked QtCore4.dll that hooks all objects and dumps their metadata), but I don't know what to use to decompile them.\nThe question: what (free) tools would you recommend to do this programmatically? At a minimum, I'd need a PE loader and an x86 simulator, Python preferred.\nI've been pointed to angr, which is impressive, and among other things translates code to a platform-independent IR, which increases the chances that I could actually release my code as a general purpose tool, but angr seems designed to do the complete opposite of what I need. Not only its documentation is sparse and impenetrable, but considering it's designed to derive the data from the code (and I already have the data!), it seems overengineered for my use case and would probably be unbearably slow even if I figured it out.\n",
    "votes": "2",
    "answers": 2,
    "views": "603",
    "tags": [
        "x86",
        "c++",
        "static-analysis",
        "qt"
    ],
    "user": "Michele Cicciotti",
    "time": "Oct 18, 2016 at 12:16",
    "comments": [],
    "answers_data": [
        {
            "content": "Wow, I actually figured out enough of angr to do it. Consider this C program (an extremely simplified scale model of qt_metacall):\n<pre><code>#include <stdio.h>\n\nint foo(void) {\n    return puts(\"foo\");\n}\n\nint bar(void) {\n    return puts(\"bar\");\n}\n\nint baz(void) {\n    return puts(\"baz\");\n}\n\nint frob(int n) {\n    switch (n) {\n    case 1:\n        return foo();\n    case 2:\n        return bar();\n    case 3:\n        return baz();\n    default:\n        return -1;\n    }\n}\n\nint main(int argc, char **argv) {\n    return frob(argc) < 0;\n}\n</code></pre>\nWe compile it and we use angr to determine the address of frob, like this:\n<pre><code>import angr\nb = angr.Project('a.out', load_options={'auto_load_libs':False})\nb.analyses.CFG()\n\nfor addr in [f.addr for f in b.kb.functions.values() if f.name == 'frob']:\n    print hex(addr)\n</code></pre>\n(in my use case, my hacked QtCore4.dll will provide the list of qt_metacall methods to be disassembled)\nThen this script, invoked as script.py [executable] [address of dispatcher function] [method index], will print the address of the method with the specified index:\n<pre><code>import angr\n\ndef main(argv):\n    executable=argv[1]\n    dispatcher=int(argv[2], 0)\n    method_index=int(argv[3], 0)\n\n    # Load the executable\n    b = angr.Project(executable, load_options={'auto_load_libs': False})\n\n    # Prepare a call to the dispatcher function, with the method index as its argument\n    state = b.factory.call_state(dispatcher, method_index)\n\n    # Isn't there an easier way to make a closure in Python?!\n    class CallAddr:\n        value = None\n\n        def on_exit(self, state):\n            # When the code performs a call, we've found the method that corresponds to the index\n            if state.inspect.exit_jumpkind == 'Ijk_Call':\n                # Resolve the address of the exit target, that's our method\n                self.value = state.se.any_int(state.inspect.exit_target)\n\n    method_addr = CallAddr()\n\n    # Install breakpoint to analyze \"exits\" (i.e. jumps)\n    state.inspect.b('exit', action=method_addr.on_exit)\n\n    # Step through the dispatcher function\n    p = b.factory.path(state)\n    p.step()\n\n    # Keep running until either a conditional or a call\n    while len(p.successors) == 1 and method_addr.value is None:\n        p = p.successors[0]\n        p.step()\n\n    # No call was performed, method not found\n    if method_addr.value is None:\n        return 1\n\n    print hex(method_addr.value)\n    return 0\n\nif __name__ == \"__main__\":\n    import sys\n    sys.exit(main(sys.argv))\n</code></pre>\nConsidering how powerful angr is (and how little of it I'm using), it feels like killing ants with a nuclear bomb, but it works\n",
            "votes": "3",
            "user": "Michele Cicciotti",
            "time": "Oct 18, 2016 at 16:56",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "The article \"Qt Internals & Reversing\" by Daniel Pistelli describes how Qt works on low level and how to reconstruct the slots and methods from the metadata (statically). It's probably a little outdated in regards to Qt5 but should be a good starting point.\n",
            "votes": "0",
            "user": "Igor Skochinsky",
            "time": "Oct 18, 2016 at 14:54",
            "is_accepted": false,
            "comments": [
                {
                    "user": "NirIzr",
                    "text": "<span class=\"comment-copy\">Also worths mentioning it has a complementary IDA script</span>",
                    "time": null
                },
                {
                    "user": "Michele Cicciotti",
                    "text": "<span class=\"comment-copy\">Sorry, I already read that article and it doesn't help me much. See that section about qt_metacall at the very end? qt_metacall is what I called \"dispatch\" in my pseudocode, and I don't want to analyze all qt_metacall methods by hand, especially considering that they're machine-generated and they have a very simple structure (if condition call method, else if condition call method, etc.)</span>",
                    "time": null
                }
            ]
        }
    ]
}