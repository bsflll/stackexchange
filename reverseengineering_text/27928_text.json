{
    "title": "MIPS assembly to C code",
    "link": "https://reverseengineering.stackexchange.com/questions/27928/mips-assembly-to-c-code",
    "content": "I think I'm really brain-dead and am not really sure what to do next, but I am trying to manually convert assembly code to a C program. It's not really working, but I'm not sure what is wrong. I would be glad for any help. The code consists of two <pre><code>.c</code></pre> files and one header file for the subroutine. In the header file, I only declared the <pre><code>extern int b</code></pre> variable, so I'm not posting it here.\n<pre><code>program code\n\n\nbuild/program-mips:     file format elf32-tradbigmips\n\n\nDisassembly of section my_text:\n\n00405060 <subroutine_fnc>:\n  405060:   27bdfff8    addiu   sp,sp,-8\n  405064:   afbe0004    sw  s8,4(sp)\n  405068:   03a0f025    move    s8,sp\n  40506c:   afc40008    sw  a0,8(s8)\n  405070:   8fc20008    lw  v0,8(s8)\n  405074:   00000000    nop\n  405078:   2842005b    slti    v0,v0,91\n  40507c:   10400006    beqz    v0,405098 <subroutine_fnc+0x38>\n  405080:   00000000    nop\n  405084:   8fc20008    lw  v0,8(s8)\n  405088:   00000000    nop\n  40508c:   28420041    slti    v0,v0,65\n  405090:   10400004    beqz    v0,4050a4 <subroutine_fnc+0x44>\n  405094:   00000000    nop\n  405098:   8fc20008    lw  v0,8(s8)\n  40509c:   1000000c    b   4050d0 <subroutine_fnc+0x70>\n  4050a0:   00000000    nop\n  4050a4:   3c020041    lui v0,0x41\n  4050a8:   8c4260d0    lw  v0,24784(v0)\n  4050ac:   00000000    nop\n  4050b0:   24430001    addiu   v1,v0,1\n  4050b4:   3c020041    lui v0,0x41\n  4050b8:   ac4360d0    sw  v1,24784(v0)\n  4050bc:   8fc20008    lw  v0,8(s8)\n  4050c0:   00000000    nop\n  4050c4:   24420020    addiu   v0,v0,32\n  4050c8:   afc20008    sw  v0,8(s8)\n  4050cc:   8fc20008    lw  v0,8(s8)\n  4050d0:   03c0e825    move    sp,s8\n  4050d4:   8fbe0004    lw  s8,4(sp)\n  4050d8:   27bd0008    addiu   sp,sp,8\n  4050dc:   03e00008    jr  ra\n  4050e0:   00000000    nop\n\n004050e4 <toplevel_fnc>:\n  4050e4:   27bdffc8    addiu   sp,sp,-56\n  4050e8:   afbf0034    sw  ra,52(sp)\n  4050ec:   afbe0030    sw  s8,48(sp)\n  4050f0:   03a0f025    move    s8,sp\n  4050f4:   1000001e    b   405170 <toplevel_fnc+0x8c>\n  4050f8:   00000000    nop\n  4050fc:   83c20028    lb  v0,40(s8)\n  405100:   00000000    nop\n  405104:   00402025    move    a0,v0\n  405108:   0c101418    jal 405060 <subroutine_fnc>\n  40510c:   00000000    nop\n  405110:   00021600    sll v0,v0,0x18\n  405114:   00021603    sra v0,v0,0x18\n  405118:   a3c20028    sb  v0,40(s8)\n  40511c:   24040001    li  a0,1\n  405120:   27c20028    addiu   v0,s8,40\n  405124:   00402825    move    a1,v0\n  405128:   24060001    li  a2,1\n  40512c:   24020fa4    li  v0,4004\n  405130:   0000000c    syscall\n  405134:   afc70018    sw  a3,24(s8)\n  405138:   afc20024    sw  v0,36(s8)\n  40513c:   8fc20018    lw  v0,24(s8)\n  405140:   00000000    nop\n  405144:   14400004    bnez    v0,405158 <toplevel_fnc+0x74>\n  405148:   00000000    nop\n  40514c:   8fc20024    lw  v0,36(s8)\n  405150:   10000002    b   40515c <toplevel_fnc+0x78>\n  405154:   00000000    nop\n  405158:   2402ffff    li  v0,-1\n  40515c:   afc20020    sw  v0,32(s8)\n  405160:   8fc20020    lw  v0,32(s8)\n  405164:   00000000    nop\n  405168:   04400018    bltz    v0,4051cc <toplevel_fnc+0xe8>\n  40516c:   00000000    nop\n  405170:   00002025    move    a0,zero\n  405174:   27c20028    addiu   v0,s8,40\n  405178:   00402825    move    a1,v0\n  40517c:   24060001    li  a2,1\n  405180:   24020fa3    li  v0,4003\n  405184:   0000000c    syscall\n  405188:   afc70018    sw  a3,24(s8)\n  40518c:   afc2001c    sw  v0,28(s8)\n  405190:   8fc20018    lw  v0,24(s8)\n  405194:   00000000    nop\n  405198:   14400004    bnez    v0,4051ac <toplevel_fnc+0xc8>\n  40519c:   00000000    nop\n  4051a0:   8fc2001c    lw  v0,28(s8)\n  4051a4:   10000002    b   4051b0 <toplevel_fnc+0xcc>\n  4051a8:   00000000    nop\n  4051ac:   2402ffff    li  v0,-1\n  4051b0:   afc20020    sw  v0,32(s8)\n  4051b4:   8fc30020    lw  v1,32(s8)\n  4051b8:   24020001    li  v0,1\n  4051bc:   1062ffcf    beq v1,v0,4050fc <toplevel_fnc+0x18>\n  4051c0:   00000000    nop\n  4051c4:   10000002    b   4051d0 <toplevel_fnc+0xec>\n  4051c8:   00000000    nop\n  4051cc:   00000000    nop\n  4051d0:   3c020041    lui v0,0x41\n  4051d4:   8c4260d0    lw  v0,24784(v0)\n  4051d8:   03c0e825    move    sp,s8\n  4051dc:   8fbf0034    lw  ra,52(sp)\n  4051e0:   8fbe0030    lw  s8,48(sp)\n  4051e4:   27bd0038    addiu   sp,sp,56\n  4051e8:   03e00008    jr  ra\n  4051ec:   00000000    nop\n\nprogram data\n\n\nbuild/program-mips:     file format elf32-tradbigmips\n\nContents of section my_data:\n 4160d0 00000000                             ....      \n</code></pre>\nHere is the code I retrieved so far:\nToplevel\n<pre><code>#include <stdio.h>\n#include \"subroutine.h\"\n\n\nint b = 0;\nint toplevel_fnc(void)\n{\n  char a = 0;\n  while (b < 0)\n  {\n    read(0, a, 1);\n    a = 3;\n    if (a != 1)\n    {\n      (long)b;\n      a = subroutine_fnc(b);\n      write(1,a,1);\n      b += 4;\n    }\n  }\n  return b;\n}\n</code></pre>\nSubroutine\n<pre><code>/* Implementation of the subroutine subroutine_fnc */\n\n#include \"subroutine.h\"\n\n\n\nint subroutine_fnc(int a)\n{\n  if (90 < a)\n  {\n    return a;\n  }\n  if (64 < a)\n  {\n    b += 1;\n    a += 32;\n    return a;\n  }\n}\n</code></pre>\n",
    "votes": "2",
    "answers": 2,
    "views": "2k",
    "tags": [
        "assembly",
        "decompilation",
        "c",
        "decompile",
        "mips"
    ],
    "user": "Brachopomoc",
    "time": "Jul 26, 2021 at 9:16",
    "comments": [
        {
            "user": "SSpoke",
            "text": "IDA PRO 7.5 then press F5 and problem should be solved.\n",
            "time": null
        },
        {
            "user": "macro_controller",
            "text": "Or in Ghidra <pre><code>ctrl+e</code></pre>\n",
            "time": null
        },
        {
            "user": "Peter Robertson",
            "text": "best option is to like mentioned above use especially ghidra for mips pseudo c and edit that pseudo code into something more operate able and compile able. Are you just doing this for self knowledge and learning for for application?\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "It's not really working, but I'm not sure what is wrong.\n\nMore information could help give more specific answers like what exactly is the behavior of the original program and what behavior is your compiled code producing?\nHave you compiled your program and compared the output assembly to see where it is similar and where it differs?\nI would also suggest on your first pass to not attempt to rewrite the logic too much and follow one branch at a time before reconstructing the meat. For example your <pre><code>subroutine_fnc</code></pre>:\n<pre><code>40506c:   afc40008    sw  a0,8(s8)\n405070:   8fc20008    lw  v0,8(s8)\n405074:   00000000    nop\n405078:   2842005b    slti    v0,v0,91\n40507c:   10400006    beqz    v0,405098 <subroutine_fnc+0x38>\n...\n405098:   8fc20008    lw  v0,8(s8)\n40509c:   1000000c    b   4050d0 <subroutine_fnc+0x70>\n...\n4050d0:   03c0e825    move    sp,s8\n4050d4:   8fbe0004    lw  s8,4(sp)\n4050d8:   27bd0008    addiu   sp,sp,8\n4050dc:   03e00008    jr  ra\n</code></pre>\nWe take a0 (usually the first argument) and save it to 8(s8). Then load 8(s8) into v0. <pre><code>slti v0, v0, 91</code></pre> is the equivalent of <pre><code>if(v0<91) v0=1 else v0=0</code></pre> and then <pre><code>beqz v0, 405098</code></pre> is \"go to 405098 if v0 is equal to 0\". 405098 loads 8(s8) back into v0 then unconditionally branches (jumps) to 4050d0. From here we have post-amble; restoring the value of s8, restoring the stack pointer, and returning to what called us. Keep in mind generally v0 is a register that MIPS uses to return values from so we'll just assume for now that's what is going on (pretty much confirmed by looking at the instruction immediately following the original call to subroutine_fnc where it makes use of v0 at 405110).\nSo in C that one branch is something akin to:\n<pre><code>int subroutine_fnc(int a) {\n   if (a < 91) {\n      ...\n   }\n405098:\n   return a;\n}\n</code></pre>\nContinuing on in the other direction of the first branch:\n<pre><code>405080:   00000000    nop\n405084:   8fc20008    lw  v0,8(s8)\n405088:   00000000    nop\n40508c:   28420041    slti    v0,v0,65\n405090:   10400004    beqz    v0,4050a4 <subroutine_fnc+0x44>\n405094:   00000000    nop\n</code></pre>\nReload 8(s8) into v0, <pre><code>if(v0<65) v0=1 else v0=0</code></pre>, \"go to 4050a4 if v0 is equal to 0\". If we don't take this branch, we land at 405098 which we've already covered so that leaves us something like:\n<pre><code>int subroutine_fnc(int a) {\n   if (a < 91) {\n      if ( a < 65 ) {\n          goto 405098:\n      }\n      4050a4:   3c020041    lui v0,0x41\n      4050a8:   8c4260d0    lw  v0,24784(v0)\n      4050ac:   00000000    nop\n      4050b0:   24430001    addiu   v1,v0,1\n      4050b4:   3c020041    lui v0,0x41\n      4050b8:   ac4360d0    sw  v1,24784(v0)\n      4050bc:   8fc20008    lw  v0,8(s8)\n      4050c0:   00000000    nop\n      4050c4:   24420020    addiu   v0,v0,32\n      4050c8:   afc20008    sw  v0,8(s8)\n      4050cc:   8fc20008    lw  v0,8(s8)\n   }\n405098:\n   return a;\n}\n</code></pre>\nNow that we've got the branches covered and being pretty simple, we can clean the logic up to get rid of that goto.\n<pre><code>int subroutine_fnc(int a) {\n   if (a < 91) {\n      if ( a >= 65 ) {\n          4050a4:   3c020041    lui v0,0x41\n          4050a8:   8c4260d0    lw  v0,24784(v0)\n          4050ac:   00000000    nop\n          4050b0:   24430001    addiu   v1,v0,1\n          4050b4:   3c020041    lui v0,0x41\n          4050b8:   ac4360d0    sw  v1,24784(v0)\n          4050bc:   8fc20008    lw  v0,8(s8)\n          4050c0:   00000000    nop\n          4050c4:   24420020    addiu   v0,v0,32\n          4050c8:   afc20008    sw  v0,8(s8)\n          4050cc:   8fc20008    lw  v0,8(s8)\n      }\n   }\n   return a;\n}\n</code></pre>\nAnd if you really want you could clean that up one step further by making it <pre><code>if ( a < 91 && a >= 65 ) {</code></pre>\nAt this point however you can see you've got the branching logic wrong before even confirming what the actual computations are. The reason your <pre><code>subroutine_fnc</code></pre> jumped out at me is what happens in your code if <pre><code>a</code></pre> is greater than 90?\nDisclosure, I don't remember MIPS much. I used this instruction reference and this register reference.\n",
            "votes": "3",
            "user": "Thomas Mouton",
            "time": "Dec 29, 2021 at 9:45",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "Generating Pseudo-Code\nYou should try to use specialized programs to generate pseudo-code in C. Writing code in C from raw asm is pain and it's strongly not recommended.\nTools\n\nGhidra (Free)\nIDA PRO     (Paid)\n\nIf you realy need to write it manually for some reasons I sugesst to use dissasemblers which will display asm in nice looking graph what should really help you.\nFor example:\n\nGhidra\nIDA FREE\nCutter\n",
            "votes": "2",
            "user": "Filip Poplewski",
            "time": "Jul 27, 2021 at 16:12",
            "is_accepted": false,
            "comments": []
        }
    ]
}