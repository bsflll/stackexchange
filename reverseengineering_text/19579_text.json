{
    "title": "Figuring out what a segment of assembly code does",
    "link": "https://reverseengineering.stackexchange.com/questions/19579/figuring-out-what-a-segment-of-assembly-code-does",
    "content": "I have the following assembly code:\n<pre><code>0000000000400711 <foo>:\n  400711:   55                      push   rbp\n  400712:   48 89 e5                mov    rbp,rsp\n  400715:   48 89 7d e8             mov    QWORD PTR [rbp-0x18],rdi\n  400719:   48 c7 45 f8 00 00 00    mov    QWORD PTR [rbp-0x8],0x0\n  400720:   00\n  400721:   eb 10                   jmp    400733 <foo+0x22>\n  400723:   48 8b 45 e8             mov    rax,QWORD PTR [rbp-0x18]\n  400727:   48 8d 50 ff             lea    rdx,[rax-0x1]\n  40072b:   48 89 55 e8             mov    QWORD PTR [rbp-0x18],rdx\n  40072f:   48 01 45 f8             add    QWORD PTR [rbp-0x8],rax\n  400733:   48 83 7d e8 00          cmp    QWORD PTR [rbp-0x18],0x0\n  400738:   75 e9                   jne    400723 <foo+0x12>\n  40073a:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  40073e:   5d                      pop    rbp\n  40073f:   c3                      ret\n</code></pre>\nI've been trying for several hours to figure out what this code does. From just trial and error with a C code to Assembly Code converter, I'm pretty sure the QWORD part comes from a char array, and the lines above it (push rbp, mov rbp, rsp) is just like a preamble. I'm really not sure how to interpret the lines that come after this. I tried storing the above code in as a file called \"file.S\" and then I used the following C code and terminal command to try and figure out what it does:\n<pre><code>#include <stdio.h>\nint foo(int, int);\n\nint main()\n{\n   // printf() displays the string inside quotation\n   printf(\"%d\", foo(2,2));\n   return 0;\n}\n</code></pre>\nThe terminal command I used was \n<pre><code>gcc -g -Og -no-pie -fno-pie -m32 main.c file.S\n</code></pre>\nbut I just get a whole bunch of errors.\nI have tried for many hours, but I'm not making any progress with deciphering this code. Any help is much appreciated. In addition, is there a fast way (e.g. a decompiler) that can do this for me in the future? I couldn't find any of those either.\n",
    "votes": "1",
    "answers": 1,
    "views": "1k",
    "tags": [
        "disassembly",
        "assembly",
        "decompilation"
    ],
    "user": "Joey",
    "time": "Oct 11, 2018 at 6:32",
    "comments": [],
    "answers_data": [
        {
            "content": "First of all, this is 64bit assembly because of the registers (<pre><code>rax</code></pre>,..) and the memory address in the first line. So with the option <pre><code>-m32</code></pre> that compiles to 32bit executables, you will get some problems. \nYou're right about the first part, <pre><code>push rbp</code></pre> and <pre><code>mov rbp,rsp</code></pre> is the function preamble. \n<pre><code>mov    QWORD PTR [rbp-0x18],rdi\nmov    QWORD PTR [rbp-0x8],0x0\n</code></pre>\nThese two QWORDS are not arguments but local variables. You can recognize this, because of the negative offset (variables are above the base pointer and the stack is growing towards lower addresses). x64 assembler gives the first arguments in registers, so the first line is a function argument. The second one is a local variable. Since they are QWORDS, the datatype has a length of 8 byte. The first instruction assigns the value of <pre><code>rdi</code></pre> to a local variable (say <pre><code>var_18</code></pre>) and the second assigns 0 to another local variable (say <pre><code>var_8</code></pre>). \n<pre><code>jmp    400733 <foo+0x22>\n</code></pre>\nThis is an unconditional jump to the location <pre><code>400733</code></pre> meaning you will always jump there. So we need to continue at this location. \n<pre><code>cmp    QWORD PTR [rbp-0x18],0x0\njne    400723 <foo+0x12>\n</code></pre>\nAt <pre><code>400733</code></pre> we see a compare instruction, followed by a conditional jump. The compare checks if the local variable <pre><code>var_18</code></pre> is 0, if so the value of <pre><code>var_8</code></pre> is returned (writing the value it to <pre><code>rax</code></pre> and return). Otherwise if not 0, we jump to <pre><code>400723</code></pre>. \n<pre><code>mov    rax,QWORD PTR [rbp-0x18]\nlea    rdx,[rax-0x1]\nmov    QWORD PTR [rbp-0x18],rdx\nadd    QWORD PTR [rbp-0x8],rax\n</code></pre>\nContinuing at <pre><code>400723</code></pre> the first three instructions decrease the value of <pre><code>var_18</code></pre> by 1. But the initial value before the subtraction is added to <pre><code>var_8</code></pre>. This seems a little confusing, but if you are familiar with C/C++, an instruction like <pre><code>var--</code></pre> comes in mind, where you use the value of the variable before it is subtracted.\nAnd then we are at the comparison to 0 again. So going over all these lines, it is obvious that this is a loop where the argument is a number which then acts as a counter, from which is counted down to zero. The second local variable <pre><code>var_8</code></pre> is simply the sum of the different counter values. For example if <pre><code>var_18</code></pre> has 5 then the result would be 5+4+3+2+1=15. \nThe corresponding C code would be similar to this.\n<pre><code>long foo(long nr) {\n    long var_8 = 0;\n\n    while(nr != 0) {\n        var_8 += nr--;\n    } \n    return var_8;\n}\n</code></pre>\n\n\nIn addition, is there a fast way (e.g. a decompiler) that can do this for me in the future? I couldn't find any of those either.\n\nYes, Hex-Rays Decompiler would do the job.\n",
            "votes": "4",
            "user": "pudi",
            "time": "Oct 11, 2018 at 5:18",
            "is_accepted": true,
            "comments": []
        }
    ]
}