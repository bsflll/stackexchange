{
    "title": "Force gcc to use more complex instructions",
    "link": "https://reverseengineering.stackexchange.com/questions/24980/force-gcc-to-use-more-complex-instructions",
    "content": "I am reverse engineering a piece of assembly. I am trying to write the equivalent code in C, however, when I compile my code, gcc prefers to use simple instructions instead of the complex ones that are used in my assembly. I was wondering if I can suggest or force gcc to use more complex instructions.\nEDIT: I have already tried using the <pre><code>-O</code></pre> options but they will change lots of other variables and therefore, don't look like a good solution.\nYou can find examples here:\n<pre><code>// original assembly\nlea     rdx, [rax+0x20]\n\n// generated by gcc\nadd     rax, 0x20\nmov     rdx, rax\n\n// C code\n0x20+((uint8_t *)lParm1)  // long lParm1\n</code></pre>\n<pre><code>// original assembly\ntest    eax, eax\n\n// generated by gcc\nmov     [rbp-0x10], eax\ncmp     [rbp-0x10], 0x0\n\n// C code\nif (!iVar)  // int iVar\n</code></pre>\n<pre><code>// original assembly\nmov     eax, [rax+0x40]\n\n// generated by gcc\nadd     rax, 0x40\nmov     eax, [rax]\n\n// C code\n(float)*(int *)(lParm1 + 0x40)\n</code></pre>\n",
    "votes": "0",
    "answers": 0,
    "views": "204",
    "tags": [
        "assembly",
        "decompilation",
        "gcc"
    ],
    "user": "Bat",
    "time": "May 11, 2020 at 14:07",
    "comments": [
        {
            "user": "sbluff",
            "text": "can you please share the c code that generates that set of instructions?\n",
            "time": null
        },
        {
            "user": "Robert",
            "text": "Often the original code smaller (is only one command vs. two). Therefore you may try to enable optimization for code size via <pre><code>-Os</code></pre> parameter.\n",
            "time": null
        },
        {
            "user": "Bat",
            "text": "I have already tried that. The thing is that it more or less achieves what I want but then changes lots of other variables. Therefore, doesn't seem like a good option\n",
            "time": null
        },
        {
            "user": "Robert",
            "text": "Please edit your question and include in detail what you already tried and why it  is not a suitable solution.\n",
            "time": null
        },
        {
            "user": "0xC0000022L",
            "text": "Actually in order to achieve what you want, you need to have a toolchain (including not just compiler frontend and backend, but also assembler and linker - linker if you use LTO or similar) which can produce the desired code. And then, depending on those (and the specs file - try <pre><code>gcc -dumpspecs</code></pre>) you can use <pre><code>-mtune</code></pre>, <pre><code>-mcpu</code></pre> and <pre><code>-march</code></pre> as well as some more architecture-specific options to optimize for a CPU model and so on. However, your question should be clarified further ... also, you may want to look at RetDec and LLVM IR, perhaps?!\n",
            "time": null
        }
    ],
    "answers_data": []
}