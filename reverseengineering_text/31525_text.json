{
    "title": "I trying rewrite asm to c++ [closed]",
    "link": "https://reverseengineering.stackexchange.com/questions/31525/i-trying-rewrite-asm-to-c",
    "content": "Closed. This question is off-topic. It is not currently accepting answers.\n                                \n                            \n\n\n\n\n\n\n\n\n\n\n\n Questions asking for help reverse-engineering a specific system are off-topic unless they demonstrate an understanding of the concepts involved and clearly identify a specific problem.\n\n\nClosed 2 years ago.\n\n\n\n\n\n\n\n                        Improve this question\n                    \n\n\n\nThis code generates an API key. I use it in an android app as .so file,\nbut I need to rewrite it to java from c++. How do I translate?\n<pre><code>push    rbp\npush    r15\npush    r14\npush    r13\npush    r12\npush    rbx\nsub     rsp, 198h\nmov     rbx, rdx\nmov     rdx, rsi\nmov     r12, rdi\nmov     rax, fs:28h\nmov     [rsp+1C8h+var_38], rax\nlea     rbp, [rsp+1C8h+var_70]\nmov     rdi, rbp\nmov     rsi, r12\ncall    __Z12getSignatureP7_JNIEnvP8_jobject ; getSignature(_JNIEnv *,_jobject *)\nlea     rdi, [rsp+1C8h+var_88]\nmov     edx, 3\nmov     ecx, 0Eh\nmov     rsi, rbp\nmov     r8, rbp\ncall    __ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2ERKS5_mmRKS4_ ; std::__ndk1::basic_string<char,std::__ndk1::char_traits<char>,std::__ndk1::allocator<char>>::basic_string(std::__ndk1::basic_string<char,std::__ndk1::char_traits<char>,std::__ndk1::allocator<char>> const&,ulong,ulong,std::__ndk1::allocator<char> const&)\nlea     rdi, [rsp+1C8h+var_A0]\nmov     edx, 13h\nmov     ecx, 0Bh\nmov     rsi, rbp\nmov     r8, rbp\ncall    __ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2ERKS5_mmRKS4_ ; std::__ndk1::basic_string<char,std::__ndk1::char_traits<char>,std::__ndk1::allocator<char>>::basic_string(std::__ndk1::basic_string<char,std::__ndk1::char_traits<char>,std::__ndk1::allocator<char>> const&,ulong,ulong,std::__ndk1::allocator<char> const&)\ntest    rbx, rbx\njz      loc_21FE3\n</code></pre>\nThe full code is here.\n\nAs I understand the key generation occurs here.\nTo generate a key in Java after importing the library, I call the native method x01 with a string argument.\nPlease explain how this code works\n",
    "votes": "2",
    "answers": 0,
    "views": "133",
    "tags": [
        "disassembly",
        "decompilation",
        "c++",
        "android"
    ],
    "user": "Master",
    "time": "2 years ago",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "Hi and welcome to RE.SE. So what's your question? Please also be aware that the code isn't complete. Until you provide a more complete piece of code and ask a question, you could read about the SysV ABI to see how the parameters are passed to those calls.\n",
            "time": null
        },
        {
            "user": "r0xdeadbeef",
            "text": "from the code you provided via p*stebin, it seems that the program creates a 128-bit hash represented as a 16-byte string in hexadecimal format. the hash is generated by performing a series of operations on an input string using a custom algorithm. at the beginning, the input string is converted into a byte buffer and padded with zeros. then, the length of the input string in bits is appended to the end of the buffer. after, the algorithm performs a series of operations on the buffer to generate the hash. the resulting hash is then represented as a string of hexadecimal digits and outputted.\n",
            "time": null
        },
        {
            "user": "r0xdeadbeef",
            "text": "... the code allows for the creation of a unique hash for any input string using a custom algorithm.\n",
            "time": null
        }
    ],
    "answers_data": []
}