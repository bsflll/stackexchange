{
    "title": "Has anyone encountered PNGs where the chunk data is encrypted/compressed?",
    "link": "https://reverseengineering.stackexchange.com/questions/27569/has-anyone-encountered-pngs-where-the-chunk-data-is-encrypted-compressed",
    "content": "I've come across some files which are used in a car's satellite navigation system. Looking at the files in a hex editor shows the <pre><code>‰PNG</code></pre> signature, but the chunks do not follow the format spec - for example:\nOffset(h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n\n00000000  05 00 10 00 43 50 52 4E 41 56 5F 32 36 02 00 00  ....CPRNAV_26...\n00000010  03 00 01 00 1C 00 00 00 08 01 00 00 4B 00 CA 3D  ............K.Ê=\n00000020  FC 06 35 54 38 25 56 C8 1F 50 E9 06 04 58 85 5E  ü.5T8%VÈ.Pé..X…^\n00000030  8C 91 E1 AD 84 DF 60 49 FC 01 61 FF 47 A9 D5 6A  Œ‘á.„ß`Iü.aÿG©Õj\n00000040  B5 B2 06 48 65 0D D0 FA BE C3 D3 0E A1 EF 3B BC  µ².He.Ðú¾ÃÓ.¡ï;¼\n00000050  EF F0 BE C3 73 0E A1 EF 3B BC EF F0 BE C3 73 0E  ïð¾Ãs.¡ï;¼ïð¾Ãs.\n00000060  A1 DB E1 0F 58 E4 3E 89 50 4E 47 0D 0A 1A 0A 00  ¡Ûá.Xä>‰PNG.....  // PNG begins here\n00000070  00 00 0D 49 48 44 52 F0 E0 08 02 B2 E1 7C 5E 00  ...IHDRðà..²á|^.  // IHDR chunk indicated as 13 (0x0D) bytes, yet this is clearly not the case\n00000080  01 73 52 47 42 00 AE CE 1C E9 06 62 4B 47 44 00  .sRGB.®Î.é.bKGD.\n00000090  FF A0 BD A7 93 09 70 48 59 73 0B 11 01 7F 64 5F  ÿ ½§“.pHYs....d_\n000000A0  91 07 74 49 4D 45 07 E0 02 18 07 12 13 CC F8 BA  ‘.tIME.à.....Ìøº\n000000B0  BA B6 49 44 41 54 78 DA ED D2 C1 0D 04 00 31 C4  º¶IDATxÚíÒÁ...1Ä\n000000C0  FE 2B 33 83 AF B4 23 5C 2E A7 27 E0 8B 92 00 43  þ+3ƒ¯´#\\.§'à‹’.C\n000000D0  83 A1 C1 D0 60 68 0C 0D 86 06 43 83 A1 C1 D0 18  ƒ¡ÁÐ`h..†.Cƒ¡ÁÐ.\n000000E0  1A 0C 0D 86 06 31 34 18 1A 63 68 30 34 C6 30 8D  ...†.14..ch04Æ0.\n000000F0  60 86 AB 05 8F 4F 03 C2 58 19 85 B6 00 49 45 4E  `†«..O.ÂX.…¶.IEN\n00000100  44 AE 42 60 82 00 00 00                          D®B`‚...\nAs you can see, several standard PNG chunk names are present (<pre><code>sRGB</code></pre>, <pre><code>bKGD</code></pre>, <pre><code>IDAT</code></pre>, etc.) however the data between them appears to be compressed/encrypted.\nMy observations so far:\n\nbytes <pre><code>0x14-17</code></pre> seem to be a DWORD indicating the custom header size (<pre><code>0x1C</code></pre> or 28 bytes)\nbytes <pre><code>0x1C-1D</code></pre> seem to be a WORD indicating the size of the data between themselves and where the actual PNG header begins (<pre><code>0x4B00</code></pre> or 75 bytes, including the 2 size bytes) - this might be the compressed data table/dictionary\nfiles are aligned to 4 byte blocks with <pre><code>0x00</code></pre>\nof the 2,196 compressed PNG files, exactly half have the same <pre><code>IHDR</code></pre> data: <pre><code>F0 E0 08 02 B2 E1 7C 5E 00 01</code></pre>; the other half have <pre><code>01 90 88 08 02 E0 58 21 6D</code></pre>\nsimilarly, half of the files' compressed data/dictionaries begin with the same 22 bytes: <pre><code>FC 06 31 46 85 53 68 85 84 F9 95 6E 40 80 55 E8 C5 18 19 DE 4A F8</code></pre>; the other half begin with <pre><code>FC 06 35 54 38 25 56 C8 1F 50 E9 06 04 58 85 5E 8C 91 E1 AD 84</code></pre> - note how every file begins with <pre><code>FC 03 3x xx</code></pre>\n\n\nUpdate 2: I've created a GitHub repository with my progress so far, for anyone who's willing to take a look.\nUpdate 1: After digging around, I've managed to find a copy of the firmware with the symbols included (available here: https://www.mediafire.com/file/a0u7k2m87aj1jp6/Files.zip/file) and I'm pretty sure I've located the correct function for decompressing the files: <pre><code>cpr_tclDecompressAlgorithm::bDecompressData</code></pre>.\nUnfortunately, I'm not able to make a great deal of sense of it, but what I can see from the symbols is that:\n\na couple of custom structs are used in the decompression method, <pre><code>cpr_tclCodeTable</code></pre> and <pre><code>cpr_tclCodeTableEntry</code></pre>\nthe structs are then used with methods called <pre><code>cpr_tclCodeTable::iu32SearchIndexOfCode</code></pre> and <pre><code>cpr_tclCodeTable::corfoGetCodeEntry</code></pre>\ndecompression begins by calling <pre><code>cpr_tclDecompressAlgorithm::u32GetNextBits</code></pre> to read 32 bits / 4 bytes\nthe return value from <pre><code>u32GetNextBits</code></pre> is used with <pre><code>& 3</code></pre> and right shifted 2 bits, which indicates the first two bits are used as some kind of flag\n\nI will post IDA's pseudocode of the function below, but I'm not expecting anyone to spend a great deal of time on this - I just wondered if anyone can recognise what's happening here, e.g. Huffman, LZSS, etc.\n<pre><code>int __fastcall cpr_tclDecompressAlgorithm::bDecompressData(int a1, int a2, int a3, size_t a4, unsigned int a5, int a6)\n{\n  int v7; // r8\n  unsigned int v10; // r5\n  int v11; // r9\n  void *v12; // r0\n  unsigned int v13; // r8\n  unsigned int v14; // r0\n  const cpr_tclCodeTable *CodeTable; // r11\n  unsigned int v16; // r6\n  unsigned int v17; // r7\n  unsigned int v18; // r0\n  int v19; // r0\n  int v20; // r2\n  int v21; // r3\n  int v22; // r5\n  int v23; // r0\n  int v24; // r7\n  unsigned int v25; // r1\n  int v26; // r3\n  _BYTE *v27; // r0\n  size_t v28; // r6\n  __int16 v29; // r12\n  int v30; // r2\n  int v31; // r5\n  int v32; // r0\n  unsigned int v33; // r10\n  int v34; // r3\n  _BYTE *v35; // r1\n  int v36; // r0\n  unsigned int v37; // r12\n  int v38; // r3\n  void *v39; // r0\n  size_t v40; // r5\n  int v41; // r2\n  int result; // r0\n  int v43; // r3\n  int v44; // r2\n  _BYTE *v45; // r2\n  int v46; // r0\n  int v47; // r3\n  _BOOL4 v48; // r3\n  int v49; // r0\n\n  *(_DWORD *)(a1 + 16) = a4;\n  v7 = a2 & 3;\n  *(_DWORD *)(a1 + 12) = a3;\n  *(_DWORD *)(a1 + 4) = a2;\n  *(_DWORD *)(a1 + 8) = a2;\n  if ( (a2 & 3) != 0 )\n  {\n    v49 = trc_szGetFileName(\n            \"/opt/bosch/DI_SWNAVI_13.2C5P10/di_swnavi/components/dapi/devicemanager/devicehandler/compression/cpr_decompression.cpp\");\n    trc_tclGlobalTrace::vTraceLevel1(21504, 332, v49, \"CPR read access to unaligned adress 0x%x\", a2);\n    return 0;\n  }\n  cpr_tclDecompressAlgorithm::vInterpreteHeader((cpr_tclDecompressAlgorithm *)a1, a5);\n  v10 = a5 - *(_DWORD *)(a1 + 48);\n  if ( a4 < a5 )\n  {\n    if ( a4 <= v10 )\n    {\n      *(_DWORD *)(a1 + 48) = v7;\n      v10 = a4;\n      v11 = 1;\n      goto LABEL_7;\n    }\n    *(_DWORD *)(a1 + 48) = a4 - v10;\n  }\n  v11 = v7;\nLABEL_7:\n  v12 = *(void **)(a1 + 12);\n  v13 = (unsigned int)v12 + v10;\n  if ( !v10 )\n    goto LABEL_34;\n  if ( a6 == 3 )\n  {\n    v14 = cpr_tclDecompressAlgorithm::u32GetNextBits((cpr_tclDecompressAlgorithm *)a1, 0x20u);\n    CodeTable = (const cpr_tclCodeTable *)(*(_DWORD *)a1 + 44 * (v14 & 3));\n    v16 = v14 >> 2;\n    v17 = 2;\n    cpr_tclDecompressAlgorithm::vInit((cpr_tclDecompressAlgorithm *)a1, CodeTable);\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        if ( *(_DWORD *)(a1 + 12) >= v13 )\n          goto LABEL_34;\n        v18 = cpr_tclCodeTable::iu32SearchIndexOfCode(CodeTable, v16);\n        v19 = cpr_tclCodeTable::corfoGetCodeEntry(CodeTable, v18);\n        v20 = *(_DWORD *)(v19 + 12);\n        v21 = *(unsigned __int8 *)(v19 + 16);\n        v22 = v19;\n        v17 += v21;\n        v16 >>= v21;\n        if ( v20 != 3 )\n          break;\n        v23 = cpr_tclDecompressAlgorithm::u32GetNextBits((cpr_tclDecompressAlgorithm *)a1, v17);\n        v24 = *(unsigned __int8 *)(v22 + 17);\n        v25 = v23 | v16;\n        v26 = (v23 | v16) & ~(-1 << v24);\n        v27 = *(_BYTE **)(a1 + 12);\n        v28 = (unsigned __int16)(v26 + *(_WORD *)(v22 + 2));\n        v29 = *(_WORD *)(v22 + 6);\n        v30 = *(_DWORD *)(a1 + 44);\n        v31 = *(unsigned __int8 *)(v22 + 18);\n        if ( v13 < (unsigned int)&v27[v28] )\n        {\n          if ( v11 != 1 )\n          {\n            v32 = trc_szGetFileName(\n                    \"/opt/bosch/DI_SWNAVI_13.2C5P10/di_swnavi/components/dapi/devicemanager/devicehandler/compression/cpr\"\n                    \"_decompression.cpp\");\n            trc_tclGlobalTrace::vTraceLevel1(\n              21504,\n              253,\n              v32,\n              \"CPR Overwrite Copy n=%d wpos=0x%x epos=0x%x\",\n              v28,\n              *(_DWORD *)(a1 + 12),\n              v13);\nLABEL_24:\n            result = 0;\n            goto LABEL_35;\n          }\n          v28 = (unsigned __int16)(v13 - (_WORD)v27);\n        }\n        v33 = v25 >> v24;\n        v34 = -(unsigned __int16)(v29 + (((v25 >> v24) & ~(-1 << v31)) << v30));\n        v35 = &v27[-(unsigned __int16)(v29 + (((v25 >> v24) & ~(-1 << v31)) << v30))];\n        if ( v28 == 2 )\n        {\n          *v27 = v27[v34];\n          *(_BYTE *)(*(_DWORD *)(a1 + 12) + 1) = v35[1];\n        }\n        else\n        {\n          memcpy(v27, v35, v28);\n        }\n        v17 = v31 + v24;\n        *(_DWORD *)(a1 + 12) += v28;\n        v16 = v33 >> v31;\n      }\n      if ( v20 == 2 )\n      {\n        v36 = cpr_tclDecompressAlgorithm::u32GetNextBits((cpr_tclDecompressAlgorithm *)a1, v17);\n        v17 = *(unsigned __int8 *)(v22 + 17);\n        v37 = v36 | v16;\n        v38 = (v36 | v16) & ~(-1 << v17);\n        v39 = *(void **)(a1 + 12);\n        v40 = (unsigned __int16)(v38 + *(_WORD *)(v22 + 2));\n        if ( v13 < (unsigned int)v39 + v40 )\n        {\n          if ( v11 != 1 )\n          {\n            v41 = trc_szGetFileName(\n                    \"/opt/bosch/DI_SWNAVI_13.2C5P10/di_swnavi/components/dapi/devicemanager/devicehandler/compression/cpr\"\n                    \"_decompression.cpp\");\n            trc_tclGlobalTrace::vTraceLevel1(\n              21504,\n              291,\n              v41,\n              \"CPR Overwrite Lit n=%d wpos=0x%x epos=0x%x\",\n              v40,\n              *(_DWORD *)(a1 + 12),\n              v13);\n            goto LABEL_24;\n          }\n          v40 = (unsigned __int16)(v13 - (_WORD)v39);\n        }\n        v16 = v37 >> v17;\n        memcpy(v39, *(const void **)(a1 + 8), v40);\n        v43 = *(_DWORD *)(a1 + 12) + v40;\n        v44 = *(_DWORD *)(a1 + 8) + v40;\n      }\n      else\n      {\n        v45 = *(_BYTE **)(a1 + 12);\n        if ( (_BYTE *)v13 == v45 )\n        {\n          v46 = trc_szGetFileName(\n                  \"/opt/bosch/DI_SWNAVI_13.2C5P10/di_swnavi/components/dapi/devicemanager/devicehandler/compression/cpr_d\"\n                  \"ecompression.cpp\");\n          trc_tclGlobalTrace::vTraceLevel1(\n            21504,\n            306,\n            v46,\n            \"CPR Overwrite Lit1 n=1 wpos=0x%x epos=0x%x\",\n            *(_DWORD *)(a1 + 12),\n            v13);\n          goto LABEL_24;\n        }\n        *v45 = **(_BYTE **)(a1 + 8);\n        v43 = *(_DWORD *)(a1 + 12) + 1;\n        v44 = *(_DWORD *)(a1 + 8) + 1;\n      }\n      *(_DWORD *)(a1 + 12) = v43;\n      *(_DWORD *)(a1 + 8) = v44;\n    }\n  }\n  if ( a6 == 1 )\n  {\n    memcpy(v12, *(const void **)(a1 + 4), v10);\n    result = 1;\n    *(_DWORD *)(a1 + 12) += v10;\n  }\n  else\n  {\nLABEL_34:\n    result = 1;\n  }\nLABEL_35:\n  v47 = *(_DWORD *)(a1 + 48);\n  v48 = v47 != 0;\n  if ( result != 1 )\n    v48 = 0;\n  if ( v48 )\n  {\n    memset(*(void **)(a1 + 12), 0, *(_DWORD *)(a1 + 48));\n    result = 1;\n  }\n  return result;\n}\n</code></pre>\n",
    "votes": "2",
    "answers": 1,
    "views": "381",
    "tags": [
        "decompress",
        "binary-format"
    ],
    "user": "user7290573",
    "time": "May 19, 2021 at 23:52",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "Have you got any access to a piece of software doing the reading and/or writing? It's usually easier to reason about file formats (or deviations thereof) with that information. Also, is a sample of what you encountered available for us to inspect?\n",
            "time": null
        },
        {
            "user": "user7290573",
            "text": "@0xC0000022L unfortunately I don't have access to the software as it's a touchscreen car sat nav, however it seems it may be possible to root it which may provide some insight.  The files are from a \"Nissan Connect 3\" SD card - one of the few plaintext files mentions <pre><code>USED_COMPRESSION{ '5' }</code></pre> which could perhaps be something like gzip.  Here are a few samples: mediafire.com/file/7qtrkm290xrt0vi/Nissan.rar/file\n",
            "time": null
        },
        {
            "user": "0xC0000022L",
            "text": "Thanks. Can't make head or tails of it. Perhaps someone else will chime in and can help.\n",
            "time": null
        },
        {
            "user": "user7290573",
            "text": "No worries - appreciate the effort :)\n",
            "time": null
        },
        {
            "user": "user7290573",
            "text": "@0xC0000022L as luck would have it, I've come across a link to the software that decompresses these files: mediafire.com/file/i6wedcfhvpzdzza/DAPIAPP.OUT/file - fortunately the symbols are included in the file, too, and I can see a method <pre><code>cpr_tclDecompressAlgorithm::bDecompressData</code></pre> which is surely responsible for the decompression.  After taking a quick glance, however, it looks complex. It'll take me a while to understand this - just thought I'd share what I found.\n",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "To answer my own question, this appears to be a custom compression format by Bosch, the manufacturer of the car head unit.\nI have been successful in decompressing all of the PNG files; my solution can be found on GitHub here.\nIt would have been impossible to reverse engineer the compression format without disassembling the firmware as the data at the beginning of the file is used to retrieve values from a hardcoded \"code table\".\n",
            "votes": "1",
            "user": "user7290573",
            "time": "Dec 10, 2021 at 17:28",
            "is_accepted": true,
            "comments": []
        }
    ]
}