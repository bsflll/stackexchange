{
    "title": "IDA PRO and Dos Load Exec",
    "link": "https://reverseengineering.stackexchange.com/questions/4366/ida-pro-and-dos-load-exec",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to reverse some DOS game in IDA pro (5.0 demo). I get stuck when it tries to load the overlay file. Is it possible to load the 2nd executable into the original namespace?</p>\n<p>It has already setup the video, interrupt, and some jump tables for common routines.</p>\n<p>I think I tried this years ago, and just dumped the full 1meg of ram via DosBox. It broke the segments etc however.</p>\n<hr/>\n<pre><code>seg001:0672                 mov     ax, bx\nseg001:0674                 sub     ax, offset string_of_space ;\nseg001:0677                 mov     byte_108CA, al\nseg001:067A                 mov     bx, offset param_block\nseg001:067D                 mov     dx, cs:filename\nseg001:0682                 mov     ax, 4B00h\nseg001:0685                 mov     cs:saved_ss, ss\nseg001:068A                 mov     cs:saved_sp, sp\nseg001:068F                 int     21h             ; DOS - 2+ - LOAD OR EXECUTE     (EXEC)\nseg001:068F                                         ; DS:DX -&gt; ASCIZ filename\nseg001:068F                                         ; ES:BX -&gt; parameter block\nseg001:068F                                         ; AL = subfunc: load &amp; execute     program\nseg001:0691                 cli\nseg001:0692                 mov     ss, cs:saved_ss\nseg001:0697                 assume ss:nothing\nseg001:0697                 mov     sp, cs:saved_sp\n</code></pre>\n</div>",
    "votes": "3",
    "answers": 1,
    "views": "1k",
    "tags": [
        "ida",
        "decompilation",
        "x86"
    ],
    "user": "anthonyn",
    "time": "Aug 10, 2014 at 9:52",
    "comments": [
        {
            "user": "Guntram Blohm",
            "text": "<span class=\"comment-copy\">Do you want to (static) <i>analyze</i>, or (dynamic) <i>debug</i> the file(s)? Since the 2nd program gets loaded by the dos exec call, it's being run in it's own context, and with a bit of luck, doesn't use the 1st one much, so you can just make a second project of it.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Pending a native IDA solution, I could solve this for myself with a C program that used the following procedure:</p>\n<ol>\n<li>Read the <em>base</em> executable into memory;</li>\n<li>Read the <em>overlay</em> into memory. Note that this is a regular executable, in its own right.</li>\n<li>In the <em>base</em> executable, adjust the following EXE header items:<br/>\na. set <code>bytes_in_last_block</code> to <code>0</code>,<br/>\nb. add the <code>blocks_in_file</code> from the overlay to the base's,<br/>\nc. add the <code>num_relocs</code> from the overlay to the base's.</li>\n<li>Calculate the <em>new</em> executable size; this is the total number of <code>blocks_in_file</code> * 512 - <code>original_header_paragraphs</code>*16. You need this number for the new stack segment <code>ss</code>.</li>\n<li>The new <code>header_paragraphs</code> size - that is, the original one plus the relocations from the overlay - is going to be <code>reloc_table_offset + 4*num_relocs</code>. Make sure to round up to paragraph size, <code>16</code>.</li>\n</ol>\n<p>At this point the new header should be complete. Write it to a new file. The main executable's relocation table should be unchanged, and you can write it as well.</p>\n<p>The <em>overlay's</em> relocation table then needs to be adjusted.</p>\n<p>The relocation table itself contains a <code>segment:offset</code> pair for each relocation that points into the binary executable image to the position where a zero-based segment value is stored (i.e., the value for \"the first segment\" would be <code>0000h</code>, and when loaded, the <em>actual</em> segment is added to this value).</p>\n<p>Since you added data to the executable part, you need to adjust the linear offset into the file; add the size of the original executable code (which should be rounded upwards to a 512-byte long page). Read the <em>segment</em> at this position, add the size of the original executable code in <em>paragraphs</em>, and write it back. Then add the size of the original executable code to the <code>segment</code> part of the original relocation. Do this for each relocation in the overlay's table.</p>\n<p>After adjusting the overlay's relocation table, write this to your output file, immediately followed by the original executable's <em>data</em> (which is totally unchanged). Then add the changed overlay data to the output file.</p>\n<p>One thing to note is that the executable I tested with (only one!) stored a very small stack in the executable as well. I cannot tell if that's usual or not; I had to remove the saved stack from the 'main' code, and add it again after the combined main code + overlay code.</p>\n<hr/>\n<h3>Important note!</h3>\n<p>This procedure worked for me because the program I tested it on uses dynamically-loaded overlays. The main program loads the overlay and copies a number of data and code addresses into the main <code>dseg</code> segment. After that, it calls the overlaid code through these pointers. The overlaid code used <code>ds</code> \"as usual\", it simply used the main's <code>dseg</code>.</p>\n<p>Of course, now the \"initialization\" routine did not get called, these pointers to the overlaid routines are uninitialized and you have to find out manually what gets copied to where. But at least all code can be loaded into IDA in one go.</p>\n<h3>Will it still run?</h3>\n<p>Of course it will. The main code calls <code>LOAD/EXEC</code>, the overlay gets loaded, pointers get copied, and All is Well. The only thing is that the main executable is suddenly a whole lot larger .. but that extra part is never seen nor used by the original code. (Naturally, the main executable may now be so large that there is no more memory left to load overlays.)<br/>\nThe purpose of this exercise was <em>not</em> to remove the need to <em>load</em> the overlays, only to be able to disassemble the entire thing as one binary.</p>\n<p>You can download the C source here: <a href=\"http://www.jongware.com/binaries/combine_exe_ovl.zip\" rel=\"noreferrer\">http://www.jongware.com/binaries/combine_exe_ovl.zip</a><br/>\n- be warned, it's a pretty dirty hackish piece of code, so it comes with <em>no warranties</em>.</p>\n</div>",
            "votes": "6",
            "user": "Jongware",
            "time": "Aug 15, 2014 at 23:29",
            "is_accepted": false,
            "comments": []
        }
    ]
}