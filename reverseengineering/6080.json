{
    "title": "How to detect thumb mode in ARM disassembly?",
    "link": "https://reverseengineering.stackexchange.com/questions/6080/how-to-detect-thumb-mode-in-arm-disassembly",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I try to build a small disassembler for ARM, and I would like to know how do <code>objdump</code> manage to sort out the normal mode instructions (32-bits instruction wide) from the thumb mode instructions (16-bits instruction wide) without having to look at the <code>t</code> flag in the CPSR.</p>\n<p>But first, let us build a small example and make some experiments on it. </p>\n<p>I wrote this small piece of ARM assembly (<code>gas</code> syntax) as basis example:</p>\n<pre><code>.arm\n    mov fp, #0\n    moveq   r1, r0\n.thumb\n    mov r0, #0\n    mov fp, r0\n</code></pre>\n<p>Then, I cross-compiled it like this:</p>\n<pre><code>$&gt; arm-none-eabi-gcc -Wall -Wextra -mlittle-endian -c -o arm_sample arm_sample.s\n</code></pre>\n<p>And, here is the output of <code>objdump</code> on the ARM object file:</p>\n<pre><code>$&gt; objdump -d ./arm32_mov\n\n./arm32_mov:     file format elf32-littlearm\n\nDisassembly of section .text:\n00000000 &lt;.text&gt;:\n   0:   e3a0b000    mov fp, #0\n   4:   01a01000    moveq   r1, r0\n   8:   2000        movs    r0, #0\n   a:   4683        mov fp, r0\n</code></pre>\n<p>But, when I run my tool, I get:</p>\n<pre><code> warning: decoder says at (0x8,0):'strmi r2, [r3], r0' : Unknown mnemonic\n   0:   00 b0 a0 e3                 mov fp, #0\n   4:   00 10 a0 01                 moveq   r1, r0\n   8:   ...\n</code></pre>\n<p>My tool is based on <code>libopcodes</code> (exactly like <code>objdump</code>), so the third instruction is just interpreted as still in 32-bits mode and the two thumb mode instructions are just interpreted as one 32-bits instruction which gives <code>strmi r2, [r3], r0</code>.</p>\n<p>My question is that I don't understand how <code>objdump</code> knows that there is a switch between normal mode to thumb mode. Before discovering this, I thought that this information was only available at execution time though the value of the <code>t</code> flag in the CPSR status register.</p>\n<p>I tried to look at the code of <code>objdump</code> but, I didn't see any architecture dependent cases to treat the case of the ARM thumb mode. So, this is still a mystery to me... </p>\n<p>Any suggestion is welcome !</p>\n<p><strong>EDIT</strong></p>\n<p>In fact, I worked on an object file (compiled with <code>-c</code> option), so there is not so much symbols. But, here is a more detailed output obtained through <code>objdump</code>:</p>\n<pre><code>$&gt; objdump -x ./arm32_mov\n\n./arm32_mov:     file format elf32-littlearm\n./arm32_mov\narchitecture: armv4t, flags 0x00000010:\nHAS_SYMS\nstart address 0x00000000\nprivate flags = 5000000: [Version5 EABI]\n\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         0000000c  00000000  00000000  00000034  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .data         00000000  00000000  00000000  00000040  2**0\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  00000000  00000000  00000040  2**0\n                  ALLOC\n  3 .ARM.attributes 00000016  00000000  00000000  00000040  2**0\n                  CONTENTS, READONLY\nSYMBOL TABLE:\n00000000 l    d  .text  00000000 .text\n00000000 l    d  .data  00000000 .data\n00000000 l    d  .bss   00000000 .bss\n00000000 l    d  .ARM.attributes    00000000 .ARM.attributes\n</code></pre>\n<p>And, here is the output of <code>readelf</code>:</p>\n<pre><code>$&gt; readelf -a ./arm32_mov\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              REL (Relocatable file)\n  Machine:                           ARM\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          0 (bytes into file)\n  Start of section headers:          148 (bytes into file)\n  Flags:                             0x5000000, Version5 EABI\n  Size of this header:               52 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           40 (bytes)\n  Number of section headers:         8\n  Section header string table index: 5\n\nSection Headers:\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\n  [ 1] .text             PROGBITS        00000000 000034 00000c 00  AX  0   0  4\n  [ 2] .data             PROGBITS        00000000 000040 000000 00  WA  0   0  1\n  [ 3] .bss              NOBITS          00000000 000040 000000 00  WA  0   0  1\n  [ 4] .ARM.attributes   ARM_ATTRIBUTES  00000000 000040 000016 00      0   0  1\n  [ 5] .shstrtab         STRTAB          00000000 000056 00003c 00      0   0  1\n  [ 6] .symtab           SYMTAB          00000000 0001d4 000070 10      7   7  4\n  [ 7] .strtab           STRTAB          00000000 000244 000007 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n\nThere are no section groups in this file.\nThere are no program headers in this file.\nThere are no relocations in this file.\nThere are no unwind sections in this file.\n\nSymbol table '.symtab' contains 7 entries:\n   Num:    Value  Size Type    Bind   Vis      Ndx Name\n     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 00000000     0 SECTION LOCAL  DEFAULT    1 \n     2: 00000000     0 SECTION LOCAL  DEFAULT    2 \n     3: 00000000     0 SECTION LOCAL  DEFAULT    3 \n     4: 00000000     0 NOTYPE  LOCAL  DEFAULT    1 $a\n     5: 00000008     0 NOTYPE  LOCAL  DEFAULT    1 $t\n     6: 00000000     0 SECTION LOCAL  DEFAULT    4 \n\nNo version information found in this file.\nAttribute Section: aeabi\nFile Attributes\n  Tag_CPU_arch: v4T\n  Tag_ARM_ISA_use: Yes\n  Tag_THUMB_ISA_use: Thumb-1\n</code></pre>\n<p><strong>SOLUTION (Ian Cook)</strong></p>\n<pre><code>$ objdump --syms --special-syms ./arm32_mov\n\n./arm32_mov:     file format elf32-littlearm\n\nSYMBOL TABLE:\n00000000 l    d  .text  00000000 .text\n00000000 l    d  .data  00000000 .data\n00000000 l    d  .bss   00000000 .bss\n00000000 l       .text  00000000 $a   &lt;-- ARM code\n00000008 l       .text  00000000 $t   &lt;-- Thumb code\n00000000 l    d  .ARM.attributes    00000000 .ARM.attributes\n</code></pre>\n<p>Just to be sure, I interleaved arm code, thumb code and arm code again. Here is the dump:</p>\n<pre><code>$&gt; objdump --syms --special-syms ./arm32_mov\n\n./arm32_mov:     file format elf32-littlearm\n\nSYMBOL TABLE:\n00000000 l    d  .text  00000000 .text\n00000000 l    d  .data  00000000 .data\n00000000 l    d  .bss   00000000 .bss\n00000000 l       .text  00000000 $a\n00000008 l       .text  00000000 $t\n0000000c l       .text  00000000 $a\n00000000 l    d  .ARM.attributes    00000000 .ARM.attributes\n</code></pre>\n<p>You can see that the ARM symbol is present twice at <code>0x0</code> and <code>0xc</code> and are surrounding the thumb symbol.</p>\n</div>",
    "votes": "12",
    "answers": 3,
    "views": "15k",
    "tags": [
        "disassembly",
        "assembly",
        "arm"
    ],
    "user": "perror",
    "time": "Aug 16, 2014 at 9:23",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<span class=\"comment-copy\">dump the symbol table</span>",
            "time": null
        },
        {
            "user": "perror",
            "text": "<span class=\"comment-copy\">In fact, I don't have a lot of symbols because I just wrote directly in assembly and did not linked the final object file (I also did it, but with the exact same result. But, I took the shortest working example).</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>An ARM object file should contain symbols identifying the regions that are arm code (<code>$a</code>), thumb code (<code>$t</code>) and literal data (<code>$d</code>).</p>\n<p>You can see these as symbols #4 and #5 in your read-elf output.\ni.e. offset <code>0</code> is arm, offset <code>8</code> is thumb</p>\n<p>obj-dump will output these symbols too if you use the<code>--special-syms</code>option.</p>\n<p>Reading the <a href=\"http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044e/IHI0044E_aaelf.pdf\" rel=\"noreferrer\">ARM ELF ABI</a> will help you understand what's going on.</p>\n<p>If you are planning to try to disassemble ARM code in an Apple (Mach-O) executable or in a firmware blob then you'll have to use another technique as these symbols won't be present.</p>\n</div>",
            "votes": "11",
            "user": "perror",
            "time": "Aug 16, 2014 at 9:10",
            "is_accepted": true,
            "comments": [
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">Excellent. I, indeed, found the symbols you are talking about in my example file. Thanks !</span>",
                    "time": null
                },
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">Just to know about the other executable formats, you said Mach-O doesn't have such a symbol, but what about Microsoft Windows PE format ? Does it store such information in the symbols as well ?</span>",
                    "time": null
                },
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">@perror: IMAGE_FILE_MACHINE_ARMNT assumes Thumb-2. The older ones (for WinCE) use the bit 0, I think.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This problem is solved in the case when code mapping symbols (<code>$a</code>, <code>$t</code>, <code>$d</code>) are available. However, it's still possible to get (almost) perfect disassembly for Thumb-2 even when symbols are not available.</p>\n<p>A promising technique is speculative disassembly which has been discussed in this <a href=\"http://dx.doi.org/10.1145/2968455.2968505\" rel=\"nofollow noreferrer\">paper</a>. The tool, Spedi, is open sourced <a href=\"https://github.com/abenkhadra/spedi\" rel=\"nofollow noreferrer\">here</a>. It outperforms IDA Pro at least on the limited set of benchmarks used. Spedi can also be instructed to use ARM code mapping symbols, if available, to get the ground truth.</p>\n<p>This tool can be enhanced with the ideas discussed in this <a href=\"http://dl.acm.org/citation.cfm?id=2555729.2555748\" rel=\"nofollow noreferrer\">paper</a> to address your case of mixed mode disassembly even when symbols are not available.</p>\n</div>",
            "votes": "4",
            "user": "Codoka",
            "time": "May 22, 2017 at 9:20",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>When compiling C/C++ code, you can also detect the ARM/thumb status for a function by looking at the symbol table. The lowest bit of the address is set to 1 for Thumb and 0 for ARM instructions. To see this, you can use <code>readelf --symWhen using</code>objdump -t<code>and</code>readelf`, though.</p>\n<pre><code>$ readelf --syms foo.elf |grep strlen$\n  4460: 08000195    16 FUNC    GLOBAL DEFAULT    2 strlen\n$ objdump -t foo.elf |grep strlen$\n  08000194 g     F .text  00000010 strlen\n</code></pre>\n<p>Note that the actual address is 8000194 (32-bit aligned), but the symbol table entry (as shown by readelf) says 9000195 (with the LSB set to indicate thumb).</p>\n<p>This approach will only tell you the ARM/thumb status at the start of a function, to see any transitions inside a function you will still need to look at the <code>$t</code> and <code>$a</code> symbols as documented in other answers.</p>\n<p>The meaning of this LSB is defined in the <a href=\"http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044e/IHI0044E_aaelf.pdf\" rel=\"nofollow noreferrer\">ARM ELF ABI</a>:</p>\n<blockquote>\n<p>5.5.3 Symbol Values</p>\n<p>In addition to the normal rules for symbol values the following rules shall also apply to symbols of type STT_FUNC:</p>\n<ul>\n<li>If the symbol addresses an Arm instruction, its value is the address of the instruction (in a relocatable object, the offset of the instruction from the start of the section containing it).</li>\n<li>If the symbol addresses a Thumb instruction, its value is the address of the instruction with bit zero set (in a relocatable object, the section offset with bit zero set).</li>\n<li>For the purposes of relocation the value used shall be the address of the instruction (st_value &amp; ~1).</li>\n</ul>\n<p>Note: This allows a linker to distinguish Arm and Thumb code symbols without having to refer to the map. An Arm symbol will always have an even value, while a Thumb symbol will always have an odd value. However, a linker should strip the discriminating bit from the value before using it for relocation.</p>\n</blockquote>\n</div>",
            "votes": "0",
            "user": "Matthijs Kooijman",
            "time": "Dec 20, 2019 at 10:51",
            "is_accepted": false,
            "comments": []
        }
    ]
}