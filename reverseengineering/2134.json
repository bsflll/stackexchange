{
    "title": "Get the function prototypes from an unknown .dll",
    "link": "https://reverseengineering.stackexchange.com/questions/2134/get-the-function-prototypes-from-an-unknown-dll",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have an unknown .dll from another program which I want to work with. With <a href=\"http://www.nirsoft.net/utils/dll_export_viewer.html\">DLL Export Viewer</a> I was able to find the exported functions.</p>\n<p><img alt=\"enter image description here\" src=\"https://i.sstatic.net/qIDYL.png\"/></p>\n<p>But to call them I need the information about the parameters and the return type. </p>\n<ul>\n<li>Is there an easy way to identify them in the disassembly?</li>\n<li>Do tools exist which can extract those prototypes, or help me in a way?</li>\n</ul>\n</div>",
    "votes": "23",
    "answers": 1,
    "views": "36k",
    "tags": [
        "windows",
        "dll"
    ],
    "user": "samuirai",
    "time": "May 29, 2013 at 21:00",
    "comments": [
        {
            "user": "Dmytro",
            "text": "<span class=\"comment-copy\">Pretty sure your best bet is to dump all the names of  symbols of exported by the module, then have a spider crawl google, generating header files, and seeing the first signature that doesn't cause a segfault. Otherwise you're forced to assume the check whether the symbol looks like a cdecl/stdcall function at assembly level and analyze it. This will work often, but not all functions return to caller(they can jump to a helper that carries on and might return to caller), and not all functions say what they expect as input(they can take pointers to difficult to determine structures).</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><strong>Note:</strong> I am assuming 32bit x86 on Windows, your question unfortunately doesn't state for certain. But since it's Windows and you don't explicitly mention x64 this was the sanest assumption I could make.</p>\n<p>First off, try to search for the function names with a search engine. Don't just settle for a single search engine. Failing that, inspect whatever came in the package with the DLL. Are there import LIBs included? If so, use these to provide clues (may or may not work).</p>\n<h2>Otherwise ...</h2>\n<p>Most disassemblers (read the tag wiki <a class=\"post-tag\" href=\"/questions/tagged/tools\" rel=\"tag\" title=\"show questions tagged 'tools'\">tools</a>) will readily show you exported functions. So <em>locating</em> them won't be a problem at all. They will also usually be shown with their exported names.</p>\n<p>From the output your screenshot shows, it looks like the names aren't <a href=\"https://en.wikipedia.org/wiki/Name_mangling\" rel=\"noreferrer\">mangled/decorated</a>. This suggests - but is <em>not</em> conclusive <em>proof</em> - that the functions use the <code>stdcall</code> <a href=\"https://en.wikipedia.org/wiki/Calling_convention\" rel=\"noreferrer\">calling convention</a> (better yet read <a href=\"http://code.google.com/p/corkami/wiki/CallingConventions\" rel=\"noreferrer\">this one by Ange</a>, one of the moderators pro temp here). Now I don't know how much you know, but since you attempt RCE you are probably well-versed in calling conventions. If not let's sum it up like this: calling conventions govern how (order, alignment) and by what means (registers, stack) parameters get passed to functions. We'll get back to this in a moment. If you are on x64 Windows and the DLL is 64bit as well, you can rely on the Microsoft x64 calling convention (read <a href=\"https://en.wikipedia.org/wiki/X86_calling_conventions\" rel=\"noreferrer\">this article</a>).</p>\n<h2>Now there are two main routes you can take</h2>\n<h3>Route 1 - analyze a program using the DLL</h3>\n<p>If you happen to have a program that uses the DLL in question, you can use a debugger or disassembler to find out both the calling convention and the number of parameters passed. Simply look out for <code>call</code> instructions referencing the exported DLL functions and find <code>mov</code> or <code>push</code> instructions in front. If you happen to come across <code>cdecl</code> functions, the stack pointer (<code>esp</code>) will be adjusted again after the <code>call</code>. It's possible this is the case (see below for an example), but as unlikely as the various compiler-specific <code>fastcall</code> variants, since <code>stdcall</code> provides the broadest possible compatibility.</p>\n<p>The methods outlined below in the second approach will also explain some of the concepts introduced here in greater detail.</p>\n<h3>Route 2 - analyzing the DLL itself</h3>\n<p>If you happen to have IDA and you analyze a 32bit DLL, chances are that IDA already identified the number of parameters and the calling convention using its heuristics. Let me demonstrate (using <code>sqlite3.dll</code>). In the Exports tab find a function you're interested in and double-click it. This will take you to the address where the function starts (here <code>sqlite3_open</code>).</p>\n<p><img alt=\"enter image description here\" src=\"https://i.sstatic.net/jdRup.png\"/></p>\n<p>As you can see IDA readily found that the function takes two arguments (you can look at <a href=\"http://www.sqlite.org/c3ref/open.html\" rel=\"noreferrer\">the SQLite3 docs</a> to verify this finding). However, there is another thing here. After the <code>call sqlite3_open_v2_0</code> we can see that the stack pointer is adjusted by 10h (=16) thereby cleaning up four parameters. Looking at the <code>push</code> instructions before the <code>call</code> we can see that indeed four 32bit (i.e. DWORD) parameters are passed via the stack.\nSince there is no further cleanup on part of the function <code>sqlite3_open</code> itself, it is now clear that it is likely following the C calling convention (<code>cdecl</code>) as well. Again we can verify the finding (a benefit you won't have) by looking at the documentation. And indeed since no explicit calling convention is given, you end up defaulting to <code>cdecl</code>. The single <code>retn</code> (some disassemblers will show <code>ret</code>), meaning <code>return</code>, also doesn't clean up the stack, since otherwise it would look like <code>retn 8</code> or similar.</p>\n<p>This is a rather small function, but even with the circumstantial information we are able to deduce a lot about it.</p>\n<p>Now for something <code>stdcall</code>, a case you are more likely to encounter as mentioned before. And why not go for something famous, like, say, <code>kernel32.dll</code> from Windows 7? Again, I'll take a trivial function as it is better to showcase the points. Note that I told IDA not to make use of the debug symbols from Microsoft and to skip using FLIRT signatures. This means some of the good stuff that kicks in by default is being suppressed to show how to identify what's going on. Look:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.sstatic.net/nZ9Di.png\"/></p>\n<p>The green lines are uninteresting for our case, but you'll encounter them a lot. It is commonly found in several compilers and <code>ebp</code> is commonly referred to as \"frame pointer\" (frame as in stack frame), basically an offset on which to base access to the stack variables. You can see a typical use in the line <code>push [ebp+arg_0]</code>. IDA figured this out and shows us <code>Attributes: bp-based frame</code>.</p>\n<p>We see no adjustment of the stack pointer after <code>call sub_77E29B80</code>, so it looks like that (internal) function follows the <code>stdcall</code> calling convention as well. However, the <code>ret 4</code> hints that the callee (i.e. the function <code>AddAtomA</code> in this case) is meant to clean up the stack, which means we can exclude <code>cdecl</code> as a possibility. It's four bytes because that is the \"natural\" size on a 32bit system. You can also see from my inline comments, that parameters are passed on the stack in reverse. But you should know such things anyway before engaging in RCE, otherwise read up in the above linked articles and in some books such as <a href=\"https://reverseengineering.stackexchange.com/a/1755/245\">those here</a>.</p>\n<p>In this particular case we could dare to make another assumption, but it could bite us. Say this was Microsoft's <code>fastcall</code> convention (keep in mind that they vary by compiler), then the registers <code>ecx</code> and <code>edx</code> would be used, followed by arguments passed on the stack. This means that in our case we might want to assume that this can't be the case, because those registers aren't saved before calling <code>sub_77E29B80</code>. This is a good argument for machine-generated code such as this one. However, were this hand-optimized code, the programmer could rely on the knowledge about the calling convention and skip saving/restoring the registers before/after the <code>call</code>. Still, in this case hand-optimized code would be less likely (or unlikely) to make use of the frame pointer. It's three instructions that aren't strictly needed to do the job. So arguing like this - even without prior knowledge - we could now set out to write a little program using the prototype:</p>\n<pre><code>int __stdcall AddAtomA(void* unknown)\n</code></pre>\n<p>and use a debugger to see <em>what</em> gets passed. It's generally a tedious process, but a lot of the process - especially finding the number of parameters - can likely be scripted. Also, once you have a single function figured out, it's likely that the calling convention would be the same (exceptions exist, of course) throughout the DLL. Just make sure you analyze a function taking at least one parameter, otherwise you won't be able to distinguish between <code>stdcall</code> and <code>cdecl</code> from the circumstantial data.</p>\n<h3>Route X - the ugly one</h3>\n<p>You can also simply use <code>dumpbin</code> or a similar tool to script the creation of a test program. This test program would then call the function, check the stack pointer before and after and could thereby distinguish between <code>stdcall</code> and <code>cdecl</code>. You could also play tricks like passing 20 arguments on the stack (if you want to assume <code>stdcall</code> for the experiment) and see how much of that your callee cleaned up. There are loads of possibilities to simply try instead of analyze. But you'll get better (more reliable) results with the first two approaches.</p>\n<p>If you need to build an import LIB because you don't want to use <code>GetProcAddress</code>, see <a href=\"https://stackoverflow.com/a/15117763/476371\">this answer by me over on StackOverflow</a>. It shows how to build an import LIB  just from the DLL.</p>\n<h2>Conclusion</h2>\n<p>The methods won't differ too much with other disassemblers, I just needed to show things in a way you can reproduce them, that's why I went with IDA. The freeware edition of IDA will likely be sufficient (32bit, PE, x86) - keep in mind it's not permissible for commercial use, though.</p>\n<p>Screenshots taken from IDA 6.4.</p>\n</div>",
            "votes": "31",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": true,
            "comments": []
        }
    ]
}