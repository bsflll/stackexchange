{
    "title": "Is it possible to hook CPU instructions without severe performance impact?",
    "link": "https://reverseengineering.stackexchange.com/questions/13613/is-it-possible-to-hook-cpu-instructions-without-severe-performance-impact",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have been working on some unpackers, and I noticed that at their end, they mostly use this:</p>\n<pre><code>mov edx, [ebp+oep]\ncall edx ; now, you're at the OEP of the original binary\n</code></pre>\n<p>Or this:</p>\n<pre><code>mov ecx, [ebp+oep]\njmp ecx\n</code></pre>\n<p>Or this:</p>\n<pre><code>mov eax, [ebp+oep]\npush eax\nret\n</code></pre>\n<p>Knowing that, with a quick hook on absolute jumps/calls you'd unpack stuff in literally seconds. Apart from that, some software uses <code>cpuid</code> and <code>rdstc</code> to identify you, while protecting the assembly heavily with a lot of obfuscation. Put an \"instruction breakpoint\" on either, and you just bypassed everything faster than your eye blinks!</p>\n<p>Is what I'm saying possible, without severe performance hits? I am aware of tracing, but that's really really slow so it's not an option.</p>\n<p>Edit: I am aware of the existence of hypervisors, I just have no idea if they fit my situation, and if so, I wouldn't know how to apply those techniques to work, so any pointers, even if Google keywords, would be great.</p>\n</div>",
    "votes": "3",
    "answers": 1,
    "views": "2k",
    "tags": [
        "assembly",
        "breakpoint",
        "hooking",
        "hypervisor"
    ],
    "user": null,
    "time": "Oct 4, 2018 at 4:25",
    "comments": [
        {
            "user": "peter ferrie",
            "text": "<span class=\"comment-copy\">you can put a physical breakpoint somewhere like that, but it might be detected by the program.  Using a hypervisor-level debugger, you can place a virtual breakpoint, and the performance is good, but the hypervisor might be detected by the program.  There is no single solution.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<h1>Writing an hypervisor</h1>\n<p>The best way to currently do this is by creating a micro-hypervisor, exploiting technologies originally created to support faster virtualization to monitor usermode as well as kernelmode code. This became quite a common replacement for AVs once <code>SSDT</code> hooking was protected by Microsoft using patch-guard. Additionally, a few security companies sprung out, using hypervisors and micro-kernels to protect and separate different components of the OS (an example is <a href=\"https://www.bromium.com/\" rel=\"nofollow noreferrer\">Bromium</a>), and Microsoft recently announced their <a href=\"https://blogs.windows.com/msedgedev/2016/09/27/application-guard-microsoft-edge/#f0wG5LXKQPklAx2D.97\" rel=\"nofollow noreferrer\">Application Guard</a> which uses the same technique and actually installs an hypervisor when windows is installed.</p>\n<h2>Technical implementation</h2>\n<p>Although setting up an  hypervisor might seem like a silver bullet, it has many disadvantages:</p>\n<ol>\n<li>Although most CPUs today support hypervisors, not all do.</li>\n<li>Windows does not yet support nested-virtualization and is installing a hypervisor. Nexted virtualization has multiple complications and makes the hypervisor development process more complex. There can only be one hypervisor unless the first one installed supports nesting.</li>\n<li>Virtualization software heavily relies on virtualization support by the CPU, and running a VM and a hypervisored host might become tricky. Same goes for running a hypervisor inside a virtual machine (so you can debug it properly). <a href=\"https://4sysops.com/archives/how-to-run-hyper-v-under-vmware-workstation/\" rel=\"nofollow noreferrer\">This</a> is a decent explanation of how to do that in VMWare.</li>\n</ol>\n<p>Today, there are several open source hypervisors available, most for experimentation purposes and don't include a lot of actual features past the infrastructure needed to set up a functional hypervisor.</p>\n<p>Here are some of those open source proof of concepts, that could be used as a starting point:</p>\n<ol>\n<li><a href=\"https://github.com/hzqst/Syscall-Monitor\" rel=\"nofollow noreferrer\">https://github.com/hzqst/Syscall-Monitor</a></li>\n<li><a href=\"https://github.com/ionescu007/SimpleVisor\" rel=\"nofollow noreferrer\">https://github.com/ionescu007/SimpleVisor</a></li>\n<li><a href=\"https://github.com/asamy/ksm\" rel=\"nofollow noreferrer\">https://github.com/asamy/ksm</a></li>\n<li><a href=\"https://github.com/tandasat/HyperPlatform\" rel=\"nofollow noreferrer\">https://github.com/tandasat/HyperPlatform</a></li>\n</ol>\n<h1>overwriting IVT/IDT/SSTD</h1>\n<p>Hooking the <a href=\"https://en.wikipedia.org/wiki/Interrupt_vector_table\" rel=\"nofollow noreferrer\">Interrupt Vector Table</a>, <a href=\"https://en.wikipedia.org/wiki/Interrupt_descriptor_table\" rel=\"nofollow noreferrer\">Interrupt Descriptor Table</a> or the <a href=\"https://en.wikipedia.org/wiki/System_Service_Descriptor_Table\" rel=\"nofollow noreferrer\">System Service Dispatch Table</a> was very common in the not so distant past. Although this does not give the same granularity a hypervisor has and you won't be able to detect specific instructions, it was common practice that was partially replaced by hypervisors to get low level monitoring not provided by the OS.</p>\n<p>The basic idea behind it is to override the list of addresses a CPU executes when certain interrupts are triggered. This is usually the OS's responsibility to handle interrupts and how many low level functionality is provided by the OS (such as managing memory and permissions, paging, multiple task support, input/output with peripherals etcetera). This technique was made somewhat irrelevant on certain OSes using techniques like <a href=\"https://en.wikipedia.org/wiki/Kernel_Patch_Protection\" rel=\"nofollow noreferrer\">PatchGuard</a>.</p>\n<h1>An <code>rdtsc</code> trick</h1>\n<p>The <code>rtdsc</code> instruction is a bit special in a way not may other instructions are. Quoted from <a href=\"http://x86.renejeschke.de/html/file_module_x86_id_278.html\" rel=\"nofollow noreferrer\">here</a>:</p>\n<blockquote>\n<p>When in protected or virtual 8086 mode, the time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction as follows. When the TSD flag is clear, the RDTSC instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0. </p>\n</blockquote>\n<p>It is special because it has it's own disabling control bit(\"time stamp disable\") in <code>CR4</code>. When that control bit is set, only kernelmode code is allowed to execute the <code>rdtsc</code> instruction, but what's more interesting is that when this control bit is set, using <code>rdtsc</code> from usermode will trigger a <a href=\"https://en.wikipedia.org/wiki/General_protection_fault\" rel=\"nofollow noreferrer\">General Protection Fault</a>, thus making such instructions detectable by the kernel.</p>\n</div>",
            "votes": "3",
            "user": "NirIzr",
            "time": "Apr 14, 2017 at 16:06",
            "is_accepted": false,
            "comments": [
                {
                    "user": "phuclv",
                    "text": "<span class=\"comment-copy\">Windows does support <a href=\"https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/nested-virtualization\" rel=\"nofollow noreferrer\">nested virtualization</a>. Not sure the exact time but at least since <a href=\"https://www.interfacett.com/blogs/nested-virtualization-in-windows-10-what-is-it-and-how-to-enable-it/\" rel=\"nofollow noreferrer\">before this answer</a></span>",
                    "time": null
                }
            ]
        }
    ]
}