{
    "title": "Reverse engineering 16-bit checksum algorithm for 433Mhz RF remote control",
    "link": "https://reverseengineering.stackexchange.com/questions/27474/reverse-engineering-16-bit-checksum-algorithm-for-433mhz-rf-remote-control",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm stuck trying to figure out how to calculate the two last checksum bytes (16-bits) of these packets. The remaining data fields are understood, and it is just the two last bytes that I am current unable to generate properly.</p>\n<p>Below is a dump of many learned (recorded) packets from the retail/original remote control with correct checksum(CRC?) values at the end (the last two bytes). The format of this listing is comma separated bytes printed in decimal format.</p>\n<pre><code>196,215,0,14,197,176,7,50,1,155,165,1,133,220\n196,215,0,14,197,176,7,50,2,155,165,1,30,0\n196,215,0,14,197,176,7,50,2,155,165,2,46,99\n196,215,0,14,197,176,7,50,2,155,165,2,46,99\n196,215,0,14,197,176,7,50,3,155,165,2,88,215\n196,215,0,14,197,176,7,50,4,155,165,17,43,168\n196,215,0,14,197,176,7,50,5,155,165,17,93,28\n196,215,0,14,197,176,7,50,5,155,165,17,93,28\n196,215,0,14,197,176,7,50,5,155,165,17,93,28\n196,215,0,14,197,176,7,50,5,155,165,18,109,127\n196,215,0,14,197,176,7,50,6,155,165,18,246,163\n196,215,0,14,197,176,7,50,6,155,165,18,246,163\n196,215,0,14,197,176,7,50,8,155,165,33,82,201\n196,215,0,14,197,176,7,50,8,155,165,33,82,201\n196,215,0,14,197,176,7,50,8,155,165,33,82,201\n196,215,0,14,197,176,7,50,9,155,165,34,20,30\n196,215,0,14,197,176,7,50,9,155,165,34,20,30\n196,215,0,14,197,176,7,50,9,155,165,34,20,30\n196,215,0,14,197,176,7,50,11,155,165,176,90,141\n196,215,0,14,197,176,7,50,16,155,165,49,222,156\n196,215,0,14,197,176,7,50,16,155,165,49,222,156\n196,215,0,14,197,176,7,50,16,155,165,50,238,255\n196,215,0,14,197,176,7,50,18,155,165,66,125,0\n196,215,0,14,197,176,7,50,19,155,165,66,11,180\n196,215,0,14,197,176,7,50,19,155,165,66,11,180\n196,215,0,14,197,176,7,50,19,155,165,65,59,215\n196,215,0,14,197,176,7,50,19,155,165,65,59,215\n196,215,0,14,197,176,7,50,21,155,165,82,62,28\n196,215,0,14,197,176,7,50,21,155,165,82,62,28\n196,215,0,14,197,176,7,50,22,155,165,81,149,163\n196,215,0,14,197,176,7,50,22,155,165,81,149,163\n196,215,0,14,197,176,7,50,23,155,165,176,14,24\n196,215,0,14,197,176,7,50,23,155,165,176,14,24\n196,215,0,14,197,176,7,50,24,155,165,176,218,246\n196,215,0,14,197,176,7,50,24,155,165,176,218,246\n196,215,0,14,197,176,7,50,27,155,165,160,83,27\n196,215,0,14,197,176,7,50,30,155,165,161,255,127\n196,215,0,14,197,176,7,50,34,155,165,162,172,199\n196,215,0,14,197,176,7,50,37,155,165,192,177,14\n196,215,0,14,197,176,7,50,42,155,165,192,101,224\n196,215,0,14,197,176,7,50,45,155,165,100,193,163\n196,215,0,14,197,176,7,50,48,155,165,96,163,6\n196,215,0,14,197,176,7,50,50,155,165,96,78,110\n196,215,0,14,197,176,7,50,52,155,165,100,41,115\n196,215,0,14,197,176,7,50,53,155,165,101,79,230\n196,215,0,14,197,176,7,50,53,155,165,105,142,106\n196,215,0,14,197,176,7,50,54,155,165,106,37,213\n196,215,0,14,197,176,7,50,55,155,165,107,67,64\n196,215,0,14,197,176,7,50,55,155,165,108,51,167\n196,215,0,14,197,176,7,50,55,155,165,109,35,134\n196,215,0,14,197,176,7,50,56,155,165,110,199,11\n196,215,0,14,197,176,7,50,56,155,165,110,199,11\n196,215,0,14,197,176,7,50,57,155,165,110,177,191\n196,215,0,14,197,176,7,50,57,155,165,110,177,191\n196,215,0,14,197,176,7,50,57,155,165,110,177,191\n196,215,0,14,197,176,7,50,58,155,165,109,26,0\n196,215,0,14,197,176,7,50,58,155,165,108,10,33\n196,215,0,14,197,176,7,50,59,155,165,107,12,114\n196,215,0,14,197,176,7,50,59,155,165,106,28,83\n196,215,0,14,197,176,7,50,59,155,165,105,44,48\n196,215,0,14,197,176,7,51,0,155,165,104,164,182\n196,215,0,14,197,176,7,51,0,155,165,103,85,89\n196,215,0,14,197,176,7,51,1,155,165,102,51,204\n196,215,0,14,197,176,7,51,1,155,165,101,3,175\n196,215,0,14,197,176,7,51,1,155,165,100,19,142\n196,215,0,14,197,176,7,51,2,155,165,99,248,181\n196,215,0,14,197,176,7,51,2,155,165,98,232,148\n196,215,0,14,197,176,7,51,3,155,165,97,174,67\n196,215,0,14,197,176,7,51,3,155,165,97,174,67\n196,215,0,14,197,176,7,51,3,155,165,97,174,67\n196,215,0,14,197,176,7,51,4,155,165,97,255,110\n196,215,0,14,197,176,7,51,4,155,165,97,255,110\n196,215,0,14,197,176,7,51,7,155,165,96,116,147\n196,215,0,14,197,176,7,51,9,155,165,113,212,217\n196,215,0,14,197,176,7,51,12,155,165,112,120,189\n196,215,0,14,197,176,7,51,15,155,165,113,243,64\n196,215,0,14,197,176,7,51,16,155,165,114,12,106\n196,215,0,14,197,176,7,51,16,155,165,115,28,75\n196,215,0,14,197,176,7,51,16,155,165,116,108,172\n196,215,0,14,197,176,7,51,17,155,165,117,10,57\n196,215,0,14,197,176,7,51,17,155,165,118,58,90\n196,215,0,14,197,176,7,51,17,155,165,119,42,123\n196,215,0,14,197,176,7,51,18,155,165,119,177,167\n196,215,0,14,197,176,7,51,18,155,165,119,177,167\n196,215,0,14,197,176,7,51,19,155,165,119,199,19\n196,215,0,14,197,176,7,51,19,155,165,119,199,19\n196,215,0,14,197,176,7,51,19,155,165,119,199,19\n196,215,0,14,197,176,7,51,20,155,165,118,134,31\n196,215,0,14,197,176,7,51,20,155,165,117,182,124\n196,215,0,14,197,176,7,51,20,155,165,116,166,93\n196,215,0,14,197,176,7,51,21,155,165,115,160,14\n196,215,0,14,197,176,7,51,21,155,165,114,176,47\n196,215,0,14,197,176,7,51,21,155,165,113,128,76\n196,215,0,14,197,176,7,51,22,155,165,113,27,144\n196,215,0,14,197,176,7,51,22,155,165,113,27,144\n196,215,0,14,197,176,7,51,22,155,165,113,27,144\n196,215,0,14,197,176,7,51,22,155,165,113,27,144\n196,215,0,14,197,176,7,51,23,155,165,113,109,36\n196,215,0,14,197,176,7,51,26,155,165,112,68,131\n196,215,0,14,197,176,7,51,30,155,165,176,87,62\n</code></pre>\n<p>Data format:</p>\n<p><strong>196,215,0,REMOTESERIAL_hibyte,REMOTESERIAL_lobyte,176,TIME_HOUR,TIME_MINUTE,TIME_SECOND,ALARM_HOUR|(ALARM_ENABLE&lt;&lt;7),ALARM_MINUTE,COMMAND,CHECKSUM1,CHECKSUM2</strong></p>\n<p>The two first bytes (196,215) are probably a 16-bit sync word [magic value]. There is a preamble in front with 4 times 0xAA bytes to sync the receiver clock, but I don't think that is part of the checksum as the data is used to sync the receiver and thus can often be garbled before the receiver AGC stabilizes. In any case those initial values are static and will not change the checksum values from packet to packet.</p>\n<p>There is an RTC (Real Time Clock) chip inside the remote and each packet contains HH:MM:SS time, so that is responsible for changing the checksum values often even though the previous command is repeated. I have never seen only one of the checksum values change alone. When there is a change in the packet data, both checksum bytes always seem to change, not just one of them.</p>\n<p>The chip used in the remote is a ChipCon CC1050 (433MHz). According to the datasheet this chip does not have CRC support built-in, unlike later models like the CC1101. The CRC algorithm for that and other chips are detailed in Design Note DN502:\n<a href=\"https://www.ti.com/lit/an/swra111e/swra111e.pdf?ts=1618523904103\" rel=\"nofollow noreferrer\">https://www.ti.com/lit/an/swra111e/swra111e.pdf?ts=1618523904103</a></p>\n<p>I have tried this algorithm (and two other CRC16 algorithms I found online) with the packet data and various portions of it, with and without the preamble and sync words to no avail. I did this also with a brute force of all 65536 possible initial values for the 16-bit CRC, to no avail.</p>\n<p>I hope someone can figure this out, because I have tried many different approaches but seem to be hitting my head in the wall at the moment. :)</p>\n</div>",
    "votes": "4",
    "answers": 1,
    "views": "427",
    "tags": [
        "crc",
        "remote",
        "checksum"
    ],
    "user": "KevinD",
    "time": "Apr 15, 2021 at 22:07",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I finally figured it out myself. I used the <strong>CRC RevEng</strong> utility obtained from here:\n<a href=\"https://reveng.sourceforge.io/\" rel=\"nofollow noreferrer\">https://reveng.sourceforge.io/</a></p>\n<p>..to find the algorithm was <strong>CRC-16/XMODEM</strong> with polynomial <strong>0x1021</strong> and initial value <strong>0</strong>. That was actually one of the algorithms I had tried earlier, and I had brute-forced the polynomial, but not the initial value which I had at something else from the CRC16 example source I had obtained online.</p>\n<p>Here is the <em>reveng</em> command line I used to detect the algorithm. I supplied 6 samples on the command line, and later tried the suggested algorithm on all recorded samples and it all matches.</p>\n<pre><code>abcde@ub18:~/reveng-2.1.1$ ./reveng -w 16 -q 40000000 -s c4d7000ec5b00732019ba50185dc c4d7000ec5b00732029ba5011e00 c4d7000ec5b00732029ba5011e00 c4d7000ec5b00732029ba5011e00 c4d7000ec5b00732029ba5011e00 c4d7000ec5b00732029ba5011e00\nwidth=16  poly=0x1021  init=0x0000  refin=false  refout=false  xorout=0x0000  check=0x31c3  residue=0x0000  name=\"CRC-16/XMODEM\"\n</code></pre>\n</div>",
            "votes": "3",
            "user": "KevinD",
            "time": "Apr 15, 2021 at 23:49",
            "is_accepted": false,
            "comments": []
        }
    ]
}