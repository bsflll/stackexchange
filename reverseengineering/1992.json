{
    "title": "What is PLT/GOT?",
    "link": "https://reverseengineering.stackexchange.com/questions/1992/what-is-plt-got",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>From time to time, when disassembling x86 binaries, I stumble on\nreference to <code>PLT</code> and <code>GOT</code>, especially when calling procedures from a\ndynamic library.</p>\n<p>For example, when running a program in <code>gdb</code>:</p>\n<pre><code>(gdb) info file\nSymbols from \"/home/user/hello\".\nLocal exec file: `/home/user/hello', file type elf64-x86-64.\nEntry point: 0x400400\n    0x0000000000400200 - 0x000000000040021c is .interp\n    0x000000000040021c - 0x000000000040023c is .note.ABI-tag\n    0x000000000040023c - 0x0000000000400260 is .note.gnu.build-id\n    0x0000000000400260 - 0x0000000000400284 is .hash\n    0x0000000000400288 - 0x00000000004002a4 is .gnu.hash\n    0x00000000004002a8 - 0x0000000000400308 is .dynsym\n    0x0000000000400308 - 0x0000000000400345 is .dynstr\n    0x0000000000400346 - 0x000000000040034e is .gnu.version\n    0x0000000000400350 - 0x0000000000400370 is .gnu.version_r\n    0x0000000000400370 - 0x0000000000400388 is .rela.dyn\n    0x0000000000400388 - 0x00000000004003b8 is .rela.plt\n    0x00000000004003b8 - 0x00000000004003c6 is .init\n =&gt; 0x00000000004003d0 - 0x0000000000400400 is .plt\n    0x0000000000400400 - 0x00000000004005dc is .text\n    0x00000000004005dc - 0x00000000004005e5 is .fini\n    0x00000000004005e8 - 0x00000000004005fa is .rodata\n    0x00000000004005fc - 0x0000000000400630 is .eh_frame_hdr\n    0x0000000000400630 - 0x00000000004006f4 is .eh_frame\n    0x00000000006006f8 - 0x0000000000600700 is .init_array\n    0x0000000000600700 - 0x0000000000600708 is .fini_array\n    0x0000000000600708 - 0x0000000000600710 is .jcr\n    0x0000000000600710 - 0x00000000006008f0 is .dynamic\n =&gt; 0x00000000006008f0 - 0x00000000006008f8 is .got\n =&gt; 0x00000000006008f8 - 0x0000000000600920 is .got.plt\n    0x0000000000600920 - 0x0000000000600930 is .data\n    0x0000000000600930 - 0x0000000000600938 is .bss\n</code></pre>\n<p>And, then when disassembling (<code>puts@plt</code>):</p>\n<pre><code>(gdb) disas foo\nDump of assembler code for function foo:\n   0x000000000040050c &lt;+0&gt;: push   %rbp\n   0x000000000040050d &lt;+1&gt;: mov    %rsp,%rbp\n   0x0000000000400510 &lt;+4&gt;: sub    $0x10,%rsp\n   0x0000000000400514 &lt;+8&gt;: mov    %edi,-0x4(%rbp)\n   0x0000000000400517 &lt;+11&gt;:    mov    $0x4005ec,%edi\n=&gt; 0x000000000040051c &lt;+16&gt;:    callq  0x4003e0 &lt;puts@plt&gt;\n   0x0000000000400521 &lt;+21&gt;:    leaveq\n   0x0000000000400522 &lt;+22&gt;:    retq\nEnd of assembler dump.\n</code></pre>\n<p>So, what are these GOT/PLT ?</p>\n</div>",
    "votes": "143",
    "answers": 2,
    "views": "133k",
    "tags": [
        "x86",
        "binary-analysis",
        "elf",
        "amd64"
    ],
    "user": "perror",
    "time": "May 3, 2013 at 9:07",
    "comments": [
        {
            "user": "Mellowcandle",
            "text": "<span class=\"comment-copy\">I suggest reading the book Linkers and Loaders, excellent book about the subject. the manuscripts are freely available here: <a href=\"http://www.iecc.com/linker/\" rel=\"nofollow noreferrer\">iecc.com/linker</a></span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>PLT stands for Procedure Linkage Table which is, put simply, used to call external procedures/functions whose address isn't known in the time of linking, and is left to be resolved by the dynamic linker at run time.</p>\n<p>GOT stands for Global Offsets Table and is similarly used to resolve addresses. Both PLT and GOT and other relocation information is explained in greater length in <a href=\"https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html\" rel=\"noreferrer\">this article</a>.</p>\n<p>Also, Ian Lance Taylor, the author of <a href=\"https://en.wikipedia.org/wiki/Gold_%28linker%29\" rel=\"noreferrer\">GOLD</a> has put up <a href=\"https://www.airs.com/blog/index.php?s=Linkers\" rel=\"noreferrer\">an article series</a> on his blog which is totally worth reading (<strong>twenty</strong> parts!):</p>\n<ul>\n<li><a href=\"https://www.airs.com/blog/archives/38\" rel=\"noreferrer\">Linkers part 1: Intro</a> [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/38\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/39\" rel=\"noreferrer\">Linkers part 2: Intro II</a> [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/39\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/40\" rel=\"noreferrer\">Linkers part 3: Intro III</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/40\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/41\" rel=\"noreferrer\">Linkers part 4: Shared libraries</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/41\" rel=\"noreferrer\">archived</a>] ... PLT and GOT first introduced</li>\n<li><a href=\"https://www.airs.com/blog/archives/42\" rel=\"noreferrer\">Linkers part 5: Shared libraries Redux</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/42\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/43\" rel=\"noreferrer\">Linkers part 6: Relocations</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/43\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/44\" rel=\"noreferrer\">Linkers part 7: Thread-Local storage</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/44\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/45\" rel=\"noreferrer\">Linkers part 8: ELF Format</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/45\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/46\" rel=\"noreferrer\">Linkers part 9: Symbol versions</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/46\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/47\" rel=\"noreferrer\">Linkers part 10: Parallel linking</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/47\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/48\" rel=\"noreferrer\">Linkers part 11: Archives</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/48\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/49\" rel=\"noreferrer\">Linkers part 12: Symbol resolution</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/49\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/50\" rel=\"noreferrer\">Linkers part 13: Symbol versions Redux</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/50\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/51\" rel=\"noreferrer\">Linkers part 14: Link Time Optimization</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/51\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/52\" rel=\"noreferrer\">Linkers part 15: COMDAT sections</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/52\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/53\" rel=\"noreferrer\">Linkers part 16: C++ Template instantiation</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/53\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/54\" rel=\"noreferrer\">Linkers part 17: Warning symbols</a>  [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/54\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/55\" rel=\"noreferrer\">Linkers part 18: Incremental linking</a> [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/55\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/56\" rel=\"noreferrer\">Linkers part 19: Misc</a> [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/56\" rel=\"noreferrer\">archived</a>]</li>\n<li><a href=\"https://www.airs.com/blog/archives/57\" rel=\"noreferrer\">Linkers part 20: Gold</a> [<a href=\"https://web.archive.org/web/20230000000000*/https://www.airs.com/blog/archives/57\" rel=\"noreferrer\">archived</a>]</li>\n</ul>\n</div>",
            "votes": "144",
            "user": "0xC0000022L",
            "time": "Feb 1, 2023 at 15:04",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Let me summarize the links given at <a href=\"https://reverseengineering.stackexchange.com/a/1993/12321\">https://reverseengineering.stackexchange.com/a/1993/12321</a> without going into serious disasembly analysis for now. </p>\n<p>When the Linux kernel + dynamic linker is going to run a binary with <code>exec</code>, it traditionally just dumped the ELF section into a known memory location specified by the linker during link time.</p>\n<p>So, whenever your coded:</p>\n<ul>\n<li>referenced a global variable inside your code</li>\n<li>called a function from inside your code</li>\n</ul>\n<p>the compiler + linker could just hardcode the address into the assembly and everything would work.</p>\n<p>However, how can we do it when dealing with shared libraries, which must necessarily get loaded at potentially different addresses every time to avoid conflicts between two shared libraries?</p>\n<p>The naive solution would be to keep relocation metadata on the final executable, <a href=\"https://stackoverflow.com/questions/3322911/what-do-linkers-do\">much like the actual linker does</a> and whenever the program is loaded, have the dynamic linker go over every single access and patch it up with the right address.</p>\n<p>However, this would be too time consuming, since there could be a lot of references to patch on a program, and then that program would take a long time to start running.</p>\n<p>The solution, as usual, is to add another level of indirection: the GOT and PLT, which are two extra chunks of memory setup by the compilation system + dynamic linker.</p>\n<p>After the program is launched, the dynamic linker checks the address of shared libraries, and hacks up the GOT and PLT so that it will point correctly to the required shared library symbols:  </p>\n<ul>\n<li><p>whenever a global variable of a shared library is accessed by your program, the compiler + linker emits instead two memory accesses:</p>\n<pre><code>mov    0x200271(%rip),%rax        # 200828 &lt;_DYNAMIC+0x1a0&gt;\nmov    (%rax),%eax\n</code></pre>\n<p>The first one load the true address of the variable from the GOT, which the dynamic linker previously set, into <code>rax</code>.</p>\n<p>The second indirect access actually accesses the variable indirectly through the address from <code>rax</code>.</p></li>\n<li><p>for code, things are a bit more complicated.</p>\n<p>Whenever a function from a shared library is called, the linker makes us jump to an address in the PLT.</p>\n<p>The first time the function is called, the PLT code uses offsets stored in the GOT to decide the actual final location of the function, and then:</p>\n<ul>\n<li>stores this pre-calculated value</li>\n<li>jumps there</li>\n</ul>\n<p>The next times the function is called, the value has already been calculated, so it just jumps there directly.</p>\n<p>Due to this lazy resolution mechanism:</p>\n<ul>\n<li>programs can start running quickly even if the shared libraries have a lot of symbols</li>\n<li>we can replace functions on the fly by playing with the <code>LD_PRELOAD</code> variable</li>\n</ul></li>\n</ul>\n<p>Nowadays, <a href=\"https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld\">position independent executables (PIE)</a> are the default on distros such as Ubuntu 18.04.</p>\n<p>Much like shared libraries, these executables are compiled so that they can be placed at a random position in memory whenever they are executed, in order to make certain vulnerabilities harder to exploit.</p>\n<p>Therefore, it is not possible to hardcode absolute function and variable addresses anymore in that case. Executables must either:</p>\n<ul>\n<li>user instruction pointer relative addressing if those are available on the assembly language, e.g.:\n\n<ul>\n<li>ARMv8:\n\n<ul>\n<li><code>B</code> does 26-bit jumps, <code>B.cond</code> 19-bit</li>\n<li><a href=\"https://stackoverflow.com/questions/28638981/howto-write-pc-relative-adressing-on-arm-asm/54480999#54480999\">\"LDR (literal)\"</a> does 19-bit loads</li>\n<li><code>ADR</code> calculates 21-bit relative addresses that other instructions can use</li>\n</ul></li>\n</ul></li>\n<li>use the GOT / PLT otherwise</li>\n</ul>\n</div>",
            "votes": "39",
            "user": "leocrimson",
            "time": "May 20, 2020 at 7:32",
            "is_accepted": false,
            "comments": []
        }
    ]
}