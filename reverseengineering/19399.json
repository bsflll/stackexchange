{
    "title": "Prevent game from pausing on lost focus (Fallout New Vegas)",
    "link": "https://reverseengineering.stackexchange.com/questions/19399/prevent-game-from-pausing-on-lost-focus-fallout-new-vegas",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to modify a game (Fallout New Vegas) to not show a pause menu when the window loses focus.\nI thought of two approaches:</p>\n<ul>\n<li><p>Find the code that is called when focus changes and nop the call which would show the pause menu.</p></li>\n<li><p>Find the code which determines whether the game is focussed and nop that</p></li>\n</ul>\n<p>There is already a reliable way to patch the game's executable at runtime, however I am unsure of the best way to locate the code called when the game loses focus.</p>\n<p>I tried using cheat engine to find the variables that represent whether the game is focussed, however when checking the code around the variable I couldn't find anything that calls the menu to open.</p>\n<p>Any ideas on how to approach this?</p>\n</div>",
    "votes": "4",
    "answers": 2,
    "views": "614",
    "tags": [
        "disassembly"
    ],
    "user": "Stewart",
    "time": "Sep 19, 2018 at 16:36",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Wouldn't it be great if there was a way to filter through functions that have been called vs. ones that haven't, such that you could weed out the thousands of useless function calls and hone in on one of interest? Lucky for us, you can do such a thing!</p>\n<p>Buried in Cheat Engine is an incredibly powerful tool called <strong>Ultimap</strong> (as well as its successor, <strong>Ultimap 2</strong>). It's CPU-dependent, unfortunately, so if you're not running an Intel processor, then you're out of luck (but don't stop reading if that's the case; I mention a few other things in this answer).</p>\n<p>Ultimap and Ultimap 2 (in Cheat Engine's main window, click the <code>Memory view</code> button -&gt; <code>Tools</code> -&gt; <code>Ultimap</code> or <code>Ultimap 2</code>) are functionally the same, but operate in very different ways. I made a video on Ultimap awhile back, so <a href=\"https://www.youtube.com/watch?v=Es-ziVPhrNs\" rel=\"nofollow noreferrer\">I encourage you to watch it</a> since there's a lot to it. There's <a href=\"https://www.youtube.com/watch?v=T5sXoEEPFBQ\" rel=\"nofollow noreferrer\">another video by someone else</a> that does a great job of explaining Ultimap as well, which you may find of use.</p>\n<p>Ultimap 2 doesn't need DBVM to work (which is fantastic), but you do need to be on a current-gen Intel CPU since <a href=\"https://software.intel.com/en-us/blogs/2013/09/18/processor-tracing\" rel=\"nofollow noreferrer\">Intel PT</a> is the crux of Ultimap 2 working.</p>\n<p>That aside, <a href=\"http://split-code.com/cda.html\" rel=\"nofollow noreferrer\">CDA (aka FunctionHacker)</a>, goes about filtering function calls in a different (and awesome, timeline-based) way, but only works with 32-bit applications. <a href=\"https://www.youtube.com/watch?v=P0UXR861WYM\" rel=\"nofollow noreferrer\">Here is an excellent video</a> on how to use it, made by the guy who created the program.</p>\n<p>I suspect there's also a way to use <a href=\"https://vicarius.io/blog/wtf-is-frida/\" rel=\"nofollow noreferrer\">Frida</a> to discover and filter function calls, but I'm not well-versed enough with it yet to know if it's feasible or not, so this may or may not be worth the mention.</p>\n<p>Past that, you can try enumerating DLLs/symbols via Cheat Engine to find meaningful symbol names with which to explore. In Cheat Engine's main window, click the <code>Memory view</code> button -&gt; <code>View</code> -&gt; <code>Enumerate DLL's and Symbols</code>, and then see what you see. I've also done a video on that topic which <a href=\"https://www.youtube.com/watch?v=U8_3lCp1nas\" rel=\"nofollow noreferrer\">you can find here</a> if you'd like to see it in action.</p>\n<p>Lastly, there's the direction it sounds like you were headed in, except you may now need to now utilize back-tracing. <a href=\"https://reverseengineering.stackexchange.com/questions/18322/backtracing-where-a-register-gets-initialized/18862\">Click here</a> to read my answer to another question, in which I detail exactly what can do to trace your way up through the <code>CALL</code> chain, of which you can try brute-forcing your way up through to find the primary caller (after you do a trace, go to each caller up the chain, NOP the <code>CALL</code> and possibly anything pushed to the stack that might unbalance it farther down, see what happens; rinse and repeat). Also consider what I mention in that answer about utilizing the <code>Dissect Code</code> feature of Cheat Engine, by which you can find xrefs, strings, functions, etc. to explore!</p>\n<p>Some games can be a bear with what you're trying to do, as pausing can be controlled by many different mechanisms (functions, threads, etc.). If you can find a boolean within a byte that completely controls pausing, great! If you can find a string from the menu, then back-trace from there to ultimately find when/where the menu is drawn and game is paused, awesome! But just be aware that you might be going down a rabbit hole that requires you to handle multiple function calls, memory addresses, and much more. Good luck!</p>\n</div>",
            "votes": "4",
            "user": "dsasmblr",
            "time": "Sep 19, 2018 at 20:38",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I recommend you to use differential debugging. You can do it <a href=\"https://www.hex-rays.com/products/ida/support/tutorials/pin/pin_tutorial.pdf\" rel=\"nofollow noreferrer\">with IDA</a> or with other tools like <a href=\"https://github.com/google/binnavi\" rel=\"nofollow noreferrer\">BinNavi</a> (if your target is a 32bits one). Basically, you have to do the following:</p>\n<ol>\n<li>Record an initial trace since the beginning of the game, do things in the game and then exit from the game's menu.</li>\n<li>Record a new trace and, this time, put the window out of the focus.</li>\n<li>Diff the previous 2 traces and see where is the new code that was executed specifically at the 2nd trace.</li>\n</ol>\n</div>",
            "votes": "0",
            "user": "joxeankoret",
            "time": "Sep 20, 2018 at 11:19",
            "is_accepted": false,
            "comments": []
        }
    ]
}