{
    "title": "How can I quickly tell which ARM Thumb version a particular piece of code is using?",
    "link": "https://reverseengineering.stackexchange.com/questions/31275/how-can-i-quickly-tell-which-arm-thumb-version-a-particular-piece-of-code-is-usi",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm working with an ARM processor: an STM32F407VGT6 board, which IIUC powers a 32-bit Arm® Cortex®-M4. I need to inspect the binary weight of some instruction, so I used <code>objdump</code> like this:</p>\n<pre><code>arm-none-eabi-objdump -b binary --adjust-vma=0x08000000 --start-address=0x08000002 \\\n  -marm --disassembler-options=force-thumb -D binary_program.bin &gt; /tmp/binary_program-bin.s\n</code></pre>\n<p>First, I tested a loop of instructions like this:</p>\n<pre><code>adds    r0, r0, #255\n</code></pre>\n<p>and I got in the <code>.s</code> file</p>\n<pre><code> 80002e4:   30ff        adds    r0, #255    ; 0xff\n</code></pre>\n<p>After a <strong>long</strong> search in <a href=\"https://developer.arm.com/documentation/ddi0487/latest\" rel=\"nofollow noreferrer\">the ARM manual</a> (and I hope I found the correct one), I could map that binary as:</p>\n<pre><code>instruction: 001_10_000_11111111\nbit mask:    111_11_198_76543210\n             543_21_0\n</code></pre>\n<p>where</p>\n<ul>\n<li><code>111</code> = \"Add, subtract, compare, move (one low register and immediate)\", page F3-7301</li>\n<li><code>10</code> = \"ADD, ADDS (immediate)\", version T2 is at page F5-7453</li>\n<li><code>000</code> = <code>r0</code>, source and destination register</li>\n<li><code>11111111</code> = 255, the immediate operand</li>\n</ul>\n<p>This, IIUC, is <strong>Thumb-2</strong>. So far so good, but the problem is that other instructions, which are not representable with Thumb-2, get mapped to <strong>Thumb-3</strong>, like</p>\n<pre><code>adds    r0, r0, #256\n</code></pre>\n<p>which becomes</p>\n<pre><code> 80002e4:   f510 7080   adds.w  r0, r0, #256    ; 0x100\n</code></pre>\n<p>Obviously this is no more T2, and the bit encoding should be something like</p>\n<pre><code>      i 0 op1  S Rn   0 imm3 Rd   imm8\n11110_1_0_1000_1_0000_0_111__0000_10000000\n33222_2_2_2222_2_1111_1_111__1198_76543210\n10987_6_5_4321_0_9876_5_432__10\n</code></pre>\n<p>as reported at \"Data-processing (modified immediate)\", pages F3-7310 and F3-7311. This lead me to pages F5-7452 to 55, \"ADD, ADDS (immediate)\".\nSearching a lot, I found it should be T3: the mnemonic matches (<code>adds.w</code>). This would mean the processor expands the bits <code>11:0</code> like this:</p>\n<ol>\n<li>it concatenates a <code>1</code> with the bits <code>6:0</code>, <code>1 0000000</code></li>\n<li>extends with <code>0</code>s to get a 32 bit word: <code>00000000000000000000000010000000</code></li>\n<li>it rotates right the integer of the amount specified in bits <code>11:7</code>, which is <code>11111</code>, or 31, getting <code>00000000000000000000000100000000 = 256</code>.</li>\n</ol>\n<p>The point is, since I'm using the same compiler for both the codes, and they end up to use different ISAs to translate the instructions, <strong>how can I tell which one is which</strong>, without dwelling the depths of the ARM manual every time?</p>\n<p>Thanks!</p>\n</div>",
    "votes": "3",
    "answers": 0,
    "views": "81",
    "tags": [
        "disassembly",
        "binary-analysis",
        "arm",
        "binary-format",
        "thumb2"
    ],
    "user": "Alessandro Bertulli",
    "time": "Dec 14, 2022 at 16:19",
    "comments": [],
    "answers_data": []
}