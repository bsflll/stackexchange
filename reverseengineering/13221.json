{
    "title": "Decoding an unknown image format with \"DREK\" signature (*.drk)",
    "link": "https://reverseengineering.stackexchange.com/questions/13221/decoding-an-unknown-image-format-with-drek-signature-drk",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>There are some unknow images, which I would like to decode to <code>RRGGBBAA</code> format. It was a really hard work, but at the moment I can somewhat understand, that which part of the binary is responsible for what. But I'm stuck at the end, and I have no idea how to continue it. This is what I've found out:</p>\n<p>I know, that the size of the first image is a 9*3.</p>\n<p>There is some kind of table at the begining of the file:</p>\n<pre><code>0x08 0x08 0x10\n0x08 0x08 0x08\n0x00 0x00 0x00\n0x10 0x10 0x18\n0x18 0x18 0x20\n0x10 0x14 0x18\n0x08 0x08 0x10\n</code></pre>\n<p>And this is the image data:</p>\n<pre><code>0x09 0x00 0x03 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01 0x00 0x00 0x00\n0x0c 0x00 0x00 0x00 0x00 0x01 0x03 0x09 0x01 0x01 0x02 0x11 0x01 0x01 0x02 0x02\n0x01 0x0f 0x0f 0x03 0x0a 0x03 0x08 0x05 0x08 0x04 0x08 0x03 0x09 0x00 0x09 0x00\n0x0c 0x00 0x02\n</code></pre>\n<p>The number of elements in the table can be divided by three, so I think it is some kind of RRGGBB palette.</p>\n<p>But I have no idea, how to decode the imagedata. It's size is not 9*3, so It may be compressed. It is a really small image, and I think that this is why the compression made the binary bigger than it was before.</p>\n<hr/>\n<p><strong>Edit:</strong></p>\n<p>I've uploaded this file here: <a href=\"https://ulozto.net/!Rku8rxNXT/2npflecb3-drk\" rel=\"nofollow noreferrer\">Download file</a></p>\n<p>I've colored it, to better understand it's structure.</p>\n<p>The first part of the file:</p>\n<p><a href=\"https://i.sstatic.net/nKsPT.png\" rel=\"nofollow noreferrer\"><img alt=\"hex1\" src=\"https://i.sstatic.net/nKsPT.png\"/></a></p>\n<ul>\n<li>The red section is just some kind of file signature.</li>\n<li>The brown part is the file length in bytes. (1107)</li>\n<li>The green shows, how many images are stored in the file (currently one)</li>\n<li>The blue part shows, where the table begins ( 0x60 = at the 96th byte)</li>\n<li>The grey part shows, how long the content in the table is. Currently it's 7, so the table has 7*3 = 21 bytes, the other values are <code>CD</code></li>\n<li>The table is marked with purple</li>\n</ul>\n<p>The second part of the file:</p>\n<p><a href=\"https://i.sstatic.net/QUmGw.png\" rel=\"nofollow noreferrer\"><img alt=\"hex2\" src=\"https://i.sstatic.net/QUmGw.png\"/></a></p>\n<ul>\n<li>The blue part is the header of the image.</li>\n<li>The yellow part shows, how long the image is (51bytes)</li>\n<li>The red is the image width, and the brown is the height (3*9)</li>\n<li>The 8 zero bytes (selected with green) are the same in each file.</li>\n</ul>\n<hr/>\n<p>I've uploaded two more files.</p>\n<ul>\n<li>A similar small file: <a href=\"https://ulozto.net/!k1PYzGbkU/2npflecb7-drk\" rel=\"nofollow noreferrer\">Download</a></li>\n<li>And a bigger one: <a href=\"https://ulozto.net/!jEHtP2HjJ/nstrtfond-drk\" rel=\"nofollow noreferrer\">Download</a></li>\n</ul>\n<p>The bigger file has a resolution of 800*600 And I suspect it is this one (screenshot):</p>\n<p><a href=\"https://i.sstatic.net/fdX9v.png\" rel=\"nofollow noreferrer\"><img alt=\"bacground\" src=\"https://i.sstatic.net/fdX9v.png\"/></a></p>\n<p>At the beginning (from <code>3C0</code>), only the the first two or three bytes are set in each 4 byte group. From <code>0xD28</code>, I cannot recognise any pattern.</p>\n<hr/>\n<p><strong>Edit2:</strong></p>\n<p>Spektre's code works with most of the files. But there are some small icons, with transparency, which look distorted.</p>\n<p>For example this icon: <a href=\"https://ulozto.net/!UX8on1tX2/nblaz30s-drk\" rel=\"nofollow noreferrer\">Download</a></p>\n<p>And this is how it looks like, over a brownish background: </p>\n<p><a href=\"https://i.sstatic.net/ORcYo.png\" rel=\"nofollow noreferrer\"><img alt=\"icon\" src=\"https://i.sstatic.net/ORcYo.png\"/></a></p>\n<p>In this case, the scanlines are not fixed-width. And the unknown <code>252</code> flags at the beginning of each scanline, and <code>254</code> flags after every 32bytes are also different.</p>\n<p>I can recognise patterns and symmetry in the binary, but I haven't figured out yet, how it works.</p>\n<p>I've colored the scanlines of the icon's imagedata, to have a better overview:</p>\n<p><a href=\"https://i.sstatic.net/njdSu.png\" rel=\"nofollow noreferrer\"><img alt=\"icon hex\" src=\"https://i.sstatic.net/njdSu.png\"/></a></p>\n<p>Many of them starts with, and all of them ends with <code>0x02</code></p>\n<hr/>\n<p><strong>Edit3:</strong></p>\n<p>I uploaded some images, with screenshots:</p>\n<ul>\n<li>Snowy mountain: <a href=\"http://ulozto.net/!xLAKJmuzx/mountain-zip\" rel=\"nofollow noreferrer\">Download</a></li>\n<li>Three icons: <a href=\"https://ulozto.net/!Ns6WZEmrR/images-zip\" rel=\"nofollow noreferrer\">Download</a></li>\n</ul>\n<p>I uploaded two more images, which I found distorted. The first is an icon, which is almost perfect. And the second one is a dragon, which is barely recognisable.  Unfortunately I cannot provide screenshots for this two: <a href=\"http://ulozto.net/!bqqUUskzx/images2-zip\" rel=\"nofollow noreferrer\">Download</a></p>\n<p>I implemented the core algorithm ( from <a href=\"https://reverseengineering.stackexchange.com/a/13224/16846\">Spektre's answer</a> ) in JS. It can be found, and edited online here: <a href=\"https://jsfiddle.net/zz20qkgw/5/\" rel=\"nofollow noreferrer\">JSFiddle link</a></p>\n<hr/>\n<p><strong>Edit4:</strong></p>\n<p>I've made some progress with the mountain, and the dragon.</p>\n<p>I think, that the first 7 bits of the flag byte shows, on which x coordinate the line starts ( ´xstart = flag&gt;&gt;1;´ ). The least significant bit is a switch, which marks, that the line has this offset or not. You can try/edit the current code here: <a href=\"https://jsfiddle.net/zz20qkgw/5/\" rel=\"nofollow noreferrer\">JSFiddle link</a></p>\n<p>The result is this:</p>\n<p><a href=\"https://i.sstatic.net/cU72X.png\" rel=\"nofollow noreferrer\"><img alt=\"mountain_progress\" src=\"https://i.sstatic.net/cU72X.png\"/></a></p>\n<p>The expected result would be similar to this (which is not far):</p>\n<p><a href=\"https://i.sstatic.net/LzkC0.png\" rel=\"nofollow noreferrer\"><img alt=\"mountain\" src=\"https://i.sstatic.net/LzkC0.png\"/></a></p>\n<p>The distorted parts around the mountain are shadow/transparency, but I still wasn't be able to find any marks/flags about where the blocks with alpha values start and end.</p>\n<hr/>\n<p><strong>Edit5:</strong></p>\n<p>I think, I've found a pattern in the mountain image. After the flag byte, the next byte <strong>may</strong> show, (<code>flag2&gt;&gt;1</code>), how many <code>(Color, Alpha)</code> blocks are at the beginning of the line.</p>\n<p>The left side of the mountain looks slightly better now:</p>\n<p><a href=\"https://i.sstatic.net/SAy6T.png\" rel=\"nofollow noreferrer\"><img alt=\"mountain left\" src=\"https://i.sstatic.net/SAy6T.png\"/></a></p>\n<p><em>Unfortunately this change breaks the other images</em></p>\n</div>",
    "votes": "16",
    "answers": 2,
    "views": "3k",
    "tags": [
        "binary-analysis",
        "file-format",
        "unpacking",
        "decompress",
        "binary-diagnosis"
    ],
    "user": "Iter Ator",
    "time": "Apr 13, 2017 at 12:49",
    "comments": [
        {
            "user": "user10070",
            "text": "<span class=\"comment-copy\">I take it you don't know what the image actually looks like or anything? Without a header byte string, this will be tough to crack.</span>",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "<span class=\"comment-copy\">Is this all data in the file? Do you have more samples? (Preferably available for downloading.)</span>",
            "time": null
        },
        {
            "user": "Iter Ator",
            "text": "<span class=\"comment-copy\">I updated the question with more info, and downloadable samples</span>",
            "time": null
        },
        {
            "user": "Iter Ator",
            "text": "<span class=\"comment-copy\">@Spektre I will look at it in detail as soon as arrived home</span>",
            "time": null
        },
        {
            "user": "Iter Ator",
            "text": "<span class=\"comment-copy\">@Spektre The integer at <code>0x388-0x38B</code> points everywhere to <code>0x3C0</code>. The integer from <code>0x38C-0x38F</code> shows, where the image data ends. The 16bit integers at <code>0x3C0</code> and <code>0x3C2</code> are width and height again. And the bytes from <code>0x3C4-0x3C7</code> are always zero. As I see, only the <code>0x37C-0x383</code> part - which is still unknown - is different in almost every image.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I was able to decode the images. <em>Spektre</em> did a great job detecting the files structure, and the debug view was really helpful in the process. I implemented the algorithm in JS, and the source code is available here: <a href=\"https://github.com/K-Adam/DrekDecoder\" rel=\"nofollow noreferrer\">https://github.com/K-Adam/DrekDecoder</a></p>\n<h2>Summary</h2>\n<p>Each line starts with a flag byte. It tells the decoder how many pixels to write and which mode to use. There are three possible write modes:</p>\n<ul>\n<li>Opaque</li>\n<li>Transparent</li>\n<li>Skip</li>\n</ul>\n<p>In opaque mode each pixel is represented by one byte, which references an RGB color in the palette. In transparent mode, the pixels are pairs of bytes: [Alpha, ColorIndex]</p>\n<p>After each sequence a control byte follows. Its structure is different from the flag byte, and also different in each writing mode. This control byte will tell how many pixels to write and which mode to use next, or if the end of the line is reached.</p>\n<h2>Details</h2>\n<p><strong>Flag byte</strong></p>\n<p>If the flag is zero <code>(flag == 0x0)</code>, then the line is empty.</p>\n<p>If the LSB is set <code>(flag &amp; 0b1)</code> then there is an offset at the beginning of the line, and the decoder will start in <em>Skip</em> mode. The rest of the bits will represent the length of the offset <code>(flag &gt;&gt; 1) + 1</code></p>\n<p>If the second bit is set then transparent, otherwise opaque mode will be used:</p>\n<pre><code>mode = (flag &amp; 0b10) ? Transparent : Opaque\n</code></pre>\n<p>The number of pixels can be found in the 5 MSB <code>(flag &gt;&gt; 3) + 1</code></p>\n<p><strong>Skip mode</strong></p>\n<p>The decoder will simply write <code>n</code> empty pixels to the output. The next byte will be a control byte.</p>\n<p>If LSB is set, then the decoder will switch to transarent mode. The other 7 bits represent the number of transparent pixels.</p>\n<p>If the three LSB is <code>0b100</code> then the decoder will continue in <em>Skip</em> mode, otherwise it will change to <em>Opaque</em> mode. The other bits represent the number of pixels <code>(vv &gt;&gt; 3) + 1</code></p>\n<p><strong>Opaque mode</strong></p>\n<p>Each data byte references an RGB color in the palette.</p>\n<p>If the LSB is set, then the decoder will switch to transparent mode for <code>(v1 &gt;&gt; 1) + 1</code> pixels. Otherwise the three LSB of the control byte is the flag:</p>\n<ul>\n<li>0b000 End of line</li>\n<li>0b110 Continue in opaque mode</li>\n<li>0b100 Switch to skip mode</li>\n</ul>\n<p>The rest is the number of pixels <code>(v1 &gt;&gt; 3) + 1</code>.</p>\n<p><strong>Transparent mode</strong></p>\n<p>The transparent blocks are represented by sequence of pairs: [Alpha, Color]. The 5 MSB of the alpha byte is the transparency (0-32). The color byte references an RGB color in the palette.</p>\n<p>The two LSB of the control byte is a flag:</p>\n<ul>\n<li>0b10 End of the line</li>\n<li>0b11 Switch to opaque mode</li>\n<li>0b01 Switch to skip mode</li>\n<li>0b00 Continue in transparent mode</li>\n</ul>\n<p>The rest of the bits is the number of pixels <code>(v1 &gt;&gt; 2) + 1</code>, except for transparent mode, where it is <code>(v1 &gt;&gt; 3) + 1</code></p>\n<h2>Decoding process</h2>\n<p>Since the colors are referenced by index, two bytes are needed to represent a transparent pixel. By looking at the bottom-left part of the mountain, it was clear from those alternating patterns, that it has to be transparent there. The colors around the round icons were also not right, so I suspected that the outer pixels are half transparent as well.</p>\n<p>In the large image <code>0xFE</code> appears after each 32 bytes. It does not reference a color from the palette, so it has to be some kind of control byte.</p>\n<p>Then I started to write down the bytes in binary, where the color seemed not right. I grouped these values by where by where they appear, and then I spotted, that the least significant bits are similar on the boundary of transparent and opaque regions.</p>\n<p>After further analysis, when I was able to decode the smaller icons by hand, I implemented the algorithm, and tested it for larger ones. From there, it was easy to eliminate the remaining anomalies in the result.</p>\n</div>",
            "votes": "4",
            "user": "K-Adam",
            "time": "Aug 22, 2019 at 14:55",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><strong>[Complete ReEdit3] further progress &amp; shortening the text to fit the 30KB limit</strong></p>\n<p>First some input how I got here (for future readers trying to do the same for different format).</p>\n<ol>\n<li><p><strong>Image Data size</strong></p>\n<p>Comparing provided background image to its raw image size <code>xs*ys</code> reveal direct dependence Which implies no compression or one that has always the same pixel to data ratio. I was assuming No compression.</p></li>\n<li><p><strong>Image Data align.</strong></p>\n<p>First numbers are <code>DWORD</code> aligned with zero padding. By closer look it is always <code>DWORD[ys]</code> so that is implying some info per each <strong>ScanLine</strong>. The numbers are increasing with constant step. For <code>800x600</code> image With step <code>826</code> Implying it is <strong>ScanLine</strong> directory containing relative offsets. Tests confirms it:</p>\n<p><a href=\"https://i.sstatic.net/ctbqP.png\" rel=\"nofollow noreferrer\"><img alt=\"patterns\" src=\"https://i.sstatic.net/ctbqP.png\"/></a></p>\n<p>The small images are too small to see any details so I ignore them completely.</p>\n<p>The vertical lines are the <code>26 BYTES</code> inconsistency with <code>xs</code> starting from first <code>BYTE</code> of <strong>ScanLine</strong> containing some kind of info. After more taught and pixel measuring these lines appears each <code>33 BYTES</code> probably containing some <strong>flag</strong> info (like: tile highlight,transparency or effect masks). If skipped The result is closer:</p>\n<p><a href=\"https://i.sstatic.net/6A9pN.png\" rel=\"nofollow noreferrer\"><img alt=\"colors\" src=\"https://i.sstatic.net/6A9pN.png\"/></a></p></li>\n<li><p><strong>Colors</strong></p>\n<p>I simply took your <strong>ScreenShot</strong> and compare first decoded pixel with its. Find the color index in palette matching the color from each image and spotted the difference is simple increment. So I firstly increment the color index while decoding And result was good. After some research I found out that palette data has <code>257</code> colors instead of assumed <code>256</code> at first so I change the palette offset to compensate (no need for color index change anymore) Implying the first color entry (skipped by offset change) is some kind of special color (see bullet <strong>#1</strong>). Latter I deduced it is not color at all and does not belong to palette data but to header data. Now the result is:</p>\n<p><a href=\"https://i.sstatic.net/Yfc8u.png\" rel=\"nofollow noreferrer\"><img alt=\"final output\" src=\"https://i.sstatic.net/Yfc8u.png\"/></a></p>\n<p>If I would not spot the color dependency then I would do histogram for decoded and screenshot image and then analyze dependency on most occuring colors indexes hoping to spot some pattern. </p></li>\n<li><p><strong>Comparison</strong></p>\n<p>I pixel match the decoded image with your <strong>ScreenShot</strong> but the images are not matching. Possibly some post processing or lighting was applied to it or there is some mistake in the decoding. It is hard to decide as I have no access to the original App and or knowledge of its inner workings. You should check more Images to see if there are some artifacts or not. The small images are unusable as you do not know the content and also the size is small for any significant details to reveal ...</p></li>\n<li><p><strong>Transparent images</strong></p>\n<p>Well <strong>Iter Ator</strong> spotted that some files are not decoded properly and deduced that it has something to do with transparency (as the images was icons and later also sprites). So some more in depth analysis was take in place to make some progress. </p>\n<p>After some thinking and looping in circles I create special debug views so I can see encoded image data , reference screenshot and the corresponding palette colors in some convenient way to spot patterns or dependency. The result was something like this:</p>\n<p><a href=\"https://i.sstatic.net/sj9MW.png\" rel=\"nofollow noreferrer\"><img alt=\"manual color cross-reference\" src=\"https://i.sstatic.net/sj9MW.png\"/></a></p>\n<p>I simply render each pixel/BYTE of data as square with color corresponding to the palette entry and render the hex code inside. I render encoded <strong>ScanLine</strong> and screenshot <strong>ScanLine</strong> below (with cross matched color code from image palette printed inside. Then I painfully cross-reference both <strong>ScanLines</strong> in Paint and after comparing all the icons I got start deducing encoding format. The gaps means some kind of flag or prefix, sequence or special command. After implementing these rules into decoder then suddenly the images got looking much better. </p>\n<p>I got in a state where all the icons I got was pixel perfect but after more images came in (sprites) it was obvious that some codes may be variable and more in depth analysis of the chunks in file is needed to search for some code table or dictionary.</p>\n<p>To help with the analysis I rewrite the decoder debug view to separate class with capability to recognize perfect color match (square) and close color match (circle) to better asses the codes on non transparent pixels first.</p>\n<p><a href=\"https://i.sstatic.net/trIRs.png\" rel=\"nofollow noreferrer\"><img alt=\"better debug view\" src=\"https://i.sstatic.net/trIRs.png\"/></a></p>\n<p>I started with rules like this:</p>\n<p>From it I deduced this (not fully OK see the code for actual state):</p>\n<p>first 2 Bytes are flags\n03 unknonw flag/command skip flag can follow!</p>\n<ul>\n<li><p>also end sequence 23 (flag and pixel follows as 01)\n02 end of scanline\n01 flag and pixel follows, end of sequence (if not in first 5 pixels)\nstart of sequence:  13,17,23,27,2B\npixel follows:      0D,0F,12,15,16,18,1A,1C,1D,1E\nflag or pixel follows:  06,07,0C,0E?,10</p></li>\n<li><p>sequence can not start as first pixel otherwise it is pixel</p></li>\n<li>sequence can stop after 5 pixels already done else 01/03 is just pixel</li>\n</ul>\n<p>I improved it much more later directly in the decoder</p></li>\n<li><p><strong>ScanLine offsets</strong> </p>\n<p>As I find out if the first BYTE of <strong>ScanLine</strong> was used as offset for transparent images some of the images looks much better. <strong>Ite Ator</strong> found out that it is the offset and LSB bit is switch of this capability. I found out that  if the first BYTE of first <strong>ScanLine</strong> is <code>0xFC</code> then it is not transparent image and the decoding is described in first bullets. I introduced <code>mode 0/1</code> variable to recognize this in the decoder. And The offset is active only in mode 1 (transparency). Also I found out that the <code>offset=(flag&gt;&gt;1)+1</code> as it makes more sense from encoding efficiency side (test confirms it was correct assumption).</p></li>\n<li><p><strong>File chunks</strong></p>\n<p>In search for missing code table or dictionary I started to dissect the file-format (each BYTE that is not used yet). After some coding and analysis I added another debug output to decoder that creates text for each file/frame in aligned form so I can easily compare between all the images I got as comparing in two ro more hex-views is not very convenient.</p>\n<p>Here the header data:</p>\n<pre><code>file                          K  E  R  D              file_size        frames image_ofs                                                                                                                                                                                                   palette_ofs used_colors\ndragon              00000000: 4B 45 52 44 C8 00 00 00 A1 BF 01 00 01 00 0B 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 2E 00 0A 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 00 01 00 00 18 CD CD CD \nmountain            00000000: 4B 45 52 44 C8 00 00 00 58 8C 01 00 01 00 02 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 56 8A 01 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 00 01 00 00 18 CD CD CD \nicon0               00000000: 4B 45 52 44 C8 00 00 00 4F 05 00 00 01 00 01 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 5A 00 00 00 18 CD CD CD \nicon1               00000000: 4B 45 52 44 C8 00 00 00 4F 05 00 00 01 00 01 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 59 00 00 00 18 CD CD CD \nicon2               00000000: 4B 45 52 44 C8 00 00 00 4D 05 00 00 01 00 01 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 50 00 00 00 18 CD CD CD \nicon3               00000000: 4B 45 52 44 C8 00 00 00 46 0B 00 00 01 00 01 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 00 01 00 00 18 CD CD CD \nback                00000000: 4B 45 52 44 C8 00 00 00 78 9D 07 00 01 00 01 00 60 03 00 00 01 00 00 00 54 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 60 00 00 00 00 01 00 00 18 CD CD CD \n</code></pre>\n<p>And here the ImageData:</p>\n<pre><code>file                                                                    frame sz          xs          ys                                                                                                                                                                                                                      xs    ys                \ndragon              00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 04 25 00 00 B2 00 00 00 5B 00 00 00 E5 FF FF FF B3 FF FF FF 00 00 00 00 C0 03 00 00 C4 28 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD B2 00 5B 00 00 00 00 00 \n                    000028C4: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 02 00 A1 26 00 00 B6 00 00 00 5B 00 00 00 DD FF FF FF B4 FF FF FF 00 00 00 00 24 29 00 00 C5 4F 00 00 60 03 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 B6 00 5B 00 00 00 00 00 \n                    00004FC5: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 03 00 57 27 00 00 C4 00 00 00 5E 00 00 00 D6 FF FF FF B1 FF FF FF 00 00 00 00 25 50 00 00 7C 77 00 00 C4 28 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C4 00 5E 00 00 00 00 00 \n                    0000777C: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 04 00 26 28 00 00 BF 00 00 00 64 00 00 00 D3 FF FF FF AA FF FF FF 00 00 00 00 DC 77 00 00 02 A0 00 00 C5 4F 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BF 00 64 00 00 00 00 00 \n                    0000A002: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 05 00 70 29 00 00 C3 00 00 00 67 00 00 00 D0 FF FF FF A6 FF FF FF 00 00 00 00 62 A0 00 00 D2 C9 00 00 7C 77 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C3 00 67 00 00 00 00 00 \n                    0000C9D2: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 06 00 DA 29 00 00 C6 00 00 00 6C 00 00 00 CF FF FF FF A2 FF FF FF 00 00 00 00 32 CA 00 00 0C F4 00 00 02 A0 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C6 00 6C 00 00 00 00 00 \n                    0000F40C: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 07 00 33 2A 00 00 C5 00 00 00 6F 00 00 00 D1 FF FF FF 9F FF FF FF 00 00 00 00 6C F4 00 00 9F 1E 01 00 D2 C9 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C5 00 6F 00 00 00 00 00 \n                    00011E9F: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 08 00 1A 2B 00 00 C0 00 00 00 6C 00 00 00 D4 FF FF FF A2 FF FF FF 00 00 00 00 FF 1E 01 00 19 4A 01 00 0C F4 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 00 6C 00 00 00 00 00 \n                    00014A19: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 09 00 59 29 00 00 BE 00 00 00 68 00 00 00 DA FF FF FF A7 FF FF FF 00 00 00 00 79 4A 01 00 D2 73 01 00 9F 1E 01 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BE 00 68 00 00 00 00 00 \n                    000173D2: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 0A 00 E5 26 00 00 B5 00 00 00 62 00 00 00 E1 FF FF FF AB FF FF FF 00 00 00 00 32 74 01 00 17 9B 01 00 19 4A 01 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 B5 00 62 00 00 00 00 00 \n                    00019B17: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 0B 00 CA 23 00 00 AB 00 00 00 5A 00 00 00 EA FF FF FF B3 FF FF FF 00 00 00 00 77 9B 01 00 41 BF 01 00 D2 73 01 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 00 5A 00 00 00 00 00 \nmountain            00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 A7 BA 00 00 37 01 00 00 D3 00 00 00 00 00 00 00 C9 FF FF FF 00 00 00 00 C0 03 00 00 67 BE 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD 00 00 00 00 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 37 01 D3 00 00 00 00 00 \n                    0000BE67: 00 00 00 00 00 00 00 00 00 00 00 00 08 00 02 00 2B C7 00 00 3C 01 00 00 DD 00 00 00 FC FF FF FF C4 FF FF FF 00 00 00 00 C7 BE 00 00 F2 85 01 00 60 03 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 3C 01 DD 00 00 00 00 00 \nicon0               00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 2F 01 00 00 0D 00 00 00 0D 00 00 00 11 00 00 00 F9 FF FF FF 00 00 00 00 C0 03 00 00 EF 04 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 0D 00 0D 00 00 00 00 00 \nicon1               00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 2F 01 00 00 0D 00 00 00 0D 00 00 00 11 00 00 00 F9 FF FF FF 00 00 00 00 C0 03 00 00 EF 04 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 0D 00 0D 00 00 00 00 00 \nicon2               00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 2D 01 00 00 0D 00 00 00 0D 00 00 00 11 00 00 00 F9 FF FF FF 00 00 00 00 C0 03 00 00 ED 04 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 0D 00 0D 00 00 00 00 00 \nicon3               00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 26 07 00 00 26 00 00 00 26 00 00 00 05 00 00 00 ED FF FF FF 00 00 00 00 C0 03 00 00 E6 0A 00 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 26 00 26 00 00 00 00 00 \nback                00000360: 00 00 00 00 00 00 00 00 00 00 00 00 08 CD 01 00 58 99 07 00 20 03 00 00 58 02 00 00 08 00 00 00 B4 FD FF FF 00 00 00 00 C0 03 00 00 18 9D 07 00 00 00 00 00 00 CD CD CD 00 00 00 00 04 CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 20 03 58 02 00 00 00 00 \n</code></pre>\n<p>revealing the structure better. I found out some things from this like frame index and the ImageData align is to <code>0x0360</code> instead of <code>0x0370</code> I assumed before this. Also <code>0xCD</code> pattern is present only for first frames and not at all positions. The file-format is like this:</p>\n<pre><code>Offset              DataType                Meaning\n--------------------------------------------------------\nHeader (0x0000):\n0x0000              char[4]                 `DREK` Signature\n0x0008              DWORD                   whole file size\n0x000E              WORD                    number of frames\n0x0010              DWORD                   ImageData offset from start of file 0x0360\n0x0054              DWORD                   Palette offset from start of file 0x0060\n0x0058              DWORD                   used_colors from Palette (rest are set to (CD,CD,CD))\n--------------------------------------------------------\nPalette: (0x060)\n+0x0000             BYTE[768]               RGB palette\n--------------------------------------------------------\nImageData (0x0360)\n+0x000E             WORD                    frame 1,2,3,4,...\n+0x0010             DWORD                   sz (ImageData size - 0x60)\n+0x0014             DWORD                   xs\n+0x0018             DWORD                   ys\n+0x0060             WORD                    xs\n+0x0064             WORD                    ys\n+0x0068             DWORD[ys]               ScanLine offsets relative to end of this table (0x0068 + ys*4)\n+0x0068+(ys*4)      BYTE[sz-68-(ys*4)]      ScanLineData\n+0x0060+sz                                  Next frame ImageData if frame&lt;frames\n</code></pre></li>\n</ol>\n<p><strong>Now finally The decoder</strong></p>\n<p>The code was written in Borlands <strong>BDS2006 C++</strong> using <strong>VCL</strong> <code>TBitmap</code> and <code>AnsiString</code> So you need to rewrite it to your kind of gfx access and strings your programming environment supports. If you need help with the meaning of the gfx code see:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/a/21699076/2521214\">gfx rendering in C++</a></li>\n</ul>\n<p>Also File access functions may have a bit different name. I commented the code a bit but it should be obvious anyway. At least for those that already did things like this.</p>\n<p>The defines just switch between debug and normal decoding. If not present then you do not need the debug image class <code>img</code> at all. To keep this simple and also in 30KB limit I removed the code for the debug draw class (those who want/need it look in the edit history). That means ignoring all the <code>_debug_draw</code> defines ...</p>\n<p>Now the icons defined pixels are decoded correctly. But I did a lot of assumptions and may not work on all images. I would need more examples with ScreenShots to make it more robust. The codes itself should encode alpha channel and may be also position/offset.</p>\n<p>I changed few codes and now I am temporarily ignoring the <code>0x02</code> end of <code>ScanLine</code> which make mess when not properly decoded codes are present. Also I added few special cases I found out. The x-offset for mode1 is also present.</p>\n<p>In the code find line:</p>\n<pre><code>// image data (decoded)\n</code></pre>\n<p>That is where main decoding is. The decoding variables are:</p>\n<ul>\n<li><code>_pixel</code> - next <code>BYTE</code> is pixel</li>\n<li><code>_sequence</code> - sequence of pixels follows (ending by <code>0x01</code> or <code>0x03</code> if more then 5 pixels rendered)</li>\n<li><code>_stop</code> - end of scanline marked by <code>0x02</code></li>\n<li><code>seq</code> - just counter of how many pixels in sequence has been processed</li>\n</ul>\n<p>In comments some of the codes are marked <code>// OK</code> those are not conflicting and straightforward. The rest of comments means what codes are following:</p>\n<ul>\n<li><code>pXX</code> means pixel <code>0xXX</code></li>\n<li><code>cXX</code> means code  <code>0xXX</code></li>\n<li><code>?XX</code> means not sure if pixel or code</li>\n<li><code>?pXX</code> means most likely pixel <code>0xXX</code></li>\n</ul>\n<p>The Transparent ScanLine data starts after first BYTE so do not skip 2 BYTEs just one !!!</p>\n<p>Here some previews:</p>\n<p><a href=\"https://i.sstatic.net/HR8Q6.png\" rel=\"nofollow noreferrer\"><img alt=\"new previews\" src=\"https://i.sstatic.net/HR8Q6.png\"/></a></p>\n<p>And the Dragon frames:</p>\n<p><a href=\"https://i.sstatic.net/Xskyl.png\" rel=\"nofollow noreferrer\"><img alt=\"dragon frames\" src=\"https://i.sstatic.net/Xskyl.png\"/></a></p>\n<p><strong>The C++ source for the decoder:</strong></p>\n<pre><code>#ifdef _debug_save\nAnsiString dbg_hdr=\"file                          K  E  R  D              file_size        frames image_ofs                                                                                                                                                                                                   palette_ofs used_colors\\r\\n\";\nAnsiString dbg_img=\"                                                                        frame sz          xs          ys                                                                                                                                                                                                                      xs    ys                \\r\\n\";\n#endif\nvoid load_drk(Graphics::TBitmap *bmp,AnsiString name)\n    {\n    AnsiString s,fnam;\n    fnam=name.SubString(1,name.Length()-4);\n\n    // variables\n    BYTE *dat;\n    int hnd,adr,adr0,siz;\n    int i,x,y,xs,ys,sz,mode,frame,frames;\n    DWORD *p,*dir,pal[256],r,g,b,a;\n    // allow direct pixel access\n    bmp-&gt;HandleType=bmDIB;\n    bmp-&gt;PixelFormat=pf32bit;\n    // read file into memory\n    hnd=FileOpen(name,fmOpenRead);\n    if (hnd&lt;0) return;\n    siz=FileSeek(hnd,0,2);\n        FileSeek(hnd,0,0);\n    dat=new BYTE[siz];\n    if (dat==NULL) { FileClose(hnd); return; }\n    FileRead(hnd,dat,siz);\n    FileClose(hnd);\n    // decode\n    for (;;)\n        {\n        #ifdef _debug_save\n        // save frames to bmp\n        s=fnam+\"                    \";\n        s=s.SubString(1,20);\n        dbg_hdr+=s;\n        dbg_img+=s;\n        dbg_hdr+=\"00000000: \"; for (i=0;i&lt;0x60;i++) { s=s.sprintf(\"%X \",dat[i]); while (s.Length()&lt;3) s=\"0\"+s; dbg_hdr+=s; }\n        dbg_hdr+=\"\\r\\n\";\n        #endif\n\n        // signature\n        if (siz&lt;0x3C8) break;\n        if (((DWORD*)(dat))[ 0]!='DREK') break;\n        if (((DWORD*)(dat))[ 2]!=   siz) break;\n        // palette\n        for (adr=0x060,i=0;i&lt;256;i++)\n            {\n            b=dat[adr]; adr++;\n            g=dat[adr]; adr++;\n            r=dat[adr]; adr++;\n            pal[i]=(r&lt;&lt;16)|(g&lt;&lt;8)|(b);\n            }\n        // frames\n        frames=((WORD*)(dat+0x0E))[0];\n        adr0  =((DWORD*)(dat))[4];\n        for (frame=0;frame&lt;frames;adr0+=sz+0x60,frame++)\n            {\n            adr=adr0;\n            // resolution\n            if (adr0+0x60&gt;siz) break;\n            sz=((DWORD*)(dat+adr))[4];\n            xs=((DWORD*)(dat+adr))[5];\n            ys=((DWORD*)(dat+adr))[6];\n            if (adr0+0x60+sz&gt;siz) break;\n            bmp-&gt;SetSize(xs,ys);\n\n            #ifdef _debug_save\n            // save frames to bmp\n            if (frame) dbg_img+=\"                    \";\n            s=s.sprintf(\"%X: \",adr0); while (s.Length()&lt;10) s=\"0\"+s; dbg_img+=s;\n            for (i=adr0;i&lt;adr0+0x68;i++) { s=s.sprintf(\"%X \",dat[i]); while (s.Length()&lt;3) s=\"0\"+s; dbg_img+=s; }\n            dbg_img+=\"\\r\\n\";\n            #endif\n\n            // scanline table\n            dir=new DWORD[ys+1];\n            if (dir==NULL) break;\n            adr+=0x68;\n            for (y=0;y&lt;ys;y++)\n             dir[y]=adr+(ys&lt;&lt;2)+((DWORD*)(dat+adr))[y];\n            dir[ys]=adr0+sz+0x68;\n\n            #ifdef _debug_draw\n            // set size and palette of debug image\n            img.resize(xs,ys);\n            for (i=0;i&lt;256;i++) img.rgb_pal[i]=pal[i];\n            // copy reference data to debug image\n            for (y=0;y&lt;ys;y++) img.p[y].ref=\"\";\n            if ((png-&gt;Height)&amp;&amp;(png-&gt;Width))\n                {\n                Graphics::TBitmap *qqq=new Graphics::TBitmap;\n                qqq-&gt;Assign(png);\n                qqq-&gt;HandleType=bmDIB;\n                qqq-&gt;PixelFormat=pf32bit;\n                for (y=0;(y&lt;qqq-&gt;Height)&amp;&amp;(y&lt;ys);y++)\n                    {\n                    img.p[y].ref=\"\";\n                    img.p[y].cmp=\"\";\n                    p=(DWORD*)qqq-&gt;ScanLine[y];\n                    for (x=0;(x&lt;qqq-&gt;Width)&amp;&amp;(x&lt;xs);x++)\n                        {\n                        for (a=0,b=256,g=768;a&lt;256;a++)\n                            {\n                            r=rgb_absdistance(p[x],pal[a]);\n                            if (g&gt;r) { g=r; b=a; }\n                            } a=b;\n                        if (g) g='1'; else g='0';\n                        img.p[y].ref+=char(BYTE(a));\n                        img.p[y].cmp+=char(BYTE(g));\n                        }\n                    }\n                delete qqq;\n                }\n            // copy encoded data to debug image\n            for (y=0;y&lt;ys;y++)\n                {\n                adr=dir[y];\n                img.p[y].adr=adr;\n                img.p[y].enc=\"\";\n                img.p[y].dec=\"\";\n                img.p[y].spc=\"\";\n                for (;adr&lt;dir[y+1];adr++)\n                 img.p[y].enc+=char(BYTE(dat[adr]));\n                }\n            #endif\n\n            // image data (decoded)\n            a=dat[dir[0]];\n            mode=0; if (a!=0xFC) mode=1;\n            for (y=0;y&lt;ys;y++)\n                {\n                adr=dir[y];                     // get actual ScanLine offset in file\n                p=(DWORD*)bmp-&gt;ScanLine[y];     // get actual ScanLine pointer in bmp\n                int _sequence=0;\n                int _pixel=0;\n                int _stop=0;\n                int seq=0;\n                for (x=0;x&lt;xs;x++) p[x]=0; x=0;\n\n                if (mode==1)\n                    {\n                    // 1st ScanLine BYTE (x-offset)\n                    a=dat[adr]; adr++;\n                    if (BYTE(a&amp;1)==1)\n                        {\n                        x=(a&gt;&gt;1)+1;\n                        #ifdef _debug_draw\n                        for (i=0;i&lt;x;i++) img.p[y].spc+='\\0';\n                        #endif\n                        }\n                    // 2nd ScanLine BYTE special cases\n                    a=dat[adr];\n                    if (a==0x0D) adr++; \n                    }\n                for (a=0;adr&lt;dir[y+1];)\n                    {\n                    if (mode==0)\n                        {\n                        a=dat[adr]; adr++;              // color index\n                        if (int(x&amp;31)==0)\n                            {\n                            r=a;                        // flag\n                            a=dat[adr]; adr++;          // color index\n                            }\n                        }\n                    if (mode==1) for (;;)\n                        {\n                        a=dat[adr]; adr++;              // color index\n                        if (_pixel) { _pixel=false; break; }\n                        if (_sequence) { seq++; if (seq&lt;6) break; }\n                        // commands\n                        if (a==0x01)\n                            {\n                            a=dat[adr]; adr++;\n                            _pixel=true; _sequence=false;\n                            //if (a==0x07) { adr++; _pixel=false; }\n                            continue;\n                            }\n                        if (a==0x03)\n                            {\n                            if (!_sequence)\n                                {\n                                if (dat[adr]==0x18) _pixel=1;\n                                continue;\n                                }\n                            if (_sequence==0x2B) break;\n                            a=dat[adr]; adr++;\n                            _pixel=true; _sequence=false;\n                            //if (a==0x07) { adr++; _pixel=false; }\n                            continue;\n                            }\n                        if (_sequence) break;\n                        // unused: 0A,14,1F,20,21,22,24,25,26,28,29,2A,2C+\n                        // flag/color prefix\n    //                  if((a==0x02)&amp;&amp;(adr&gt;dir[y]+3)) { _stop=true; break; }    // end of ScanLine\n                        if (a==0x04) { _pixel=1; continue; }    // ?? ?p18 p47 ?p47\n                        if (a==0x05) { _pixel=1; continue; }    // ?? ?18 ?09\n                        if (a==0x06) { _pixel=1; continue; }    // ?? ?p18 ?p47\n                        if (a==0x07) { _pixel=1; continue; }    // ?? ?18 ?46 ?47\n                        if (a==0x08) { _pixel=1; continue; }    // ?? ?09\n                        if (a==0x09) { _pixel=0; continue; }    // ?? ?p02 !!!!!!!!!!!\n                        if (a==0x0B) { _pixel=1; continue; }    // ?? ?p02\n                        if (a==0x0C) { _pixel=1; continue; }    // OK p1D\n                        if (a==0x0D)                            // ?? c04 p23 ?c06 p05 p12\n                            {\n                            _pixel=0;\n                            if (dat[adr]==0x02) _pixel=1;\n                            if (dat[adr]==0x05) _pixel=1;   // p47 c0D p05 | c0D c05 p09\n                            if (dat[adr]==0x12) _pixel=1;\n                            if (dat[adr]==0x23) _pixel=1;\n                            continue;\n                            }\n                        if (a==0x0E) { _pixel=1; continue; }    // OK p24 p26 p16\n                        if (a==0x0F) { _pixel=1; continue; }    // OK p0F\n                        if (a==0x10) { _pixel=1; continue; }    // OK p04\n                        if (a==0x11) { _pixel=1; continue; }    // ?? ?p02\n                        if (a==0x12) { _pixel=1; continue; }    // OK p27\n                        if (a==0x15) { _pixel=1; continue; }    // OK p16\n                        if (a==0x16) { _pixel=1; continue; }    // OK p16\n                        if (a==0x18) { _pixel=1; continue; }    // OK p00 p02\n                        if (a==0x19)                            // ?? p1B\n                            {\n                            _pixel=1;\n                            if (dat[adr]==0x01) _pixel=0;\n                            continue;\n                            }\n                        if (a==0x1A) { _pixel=1; continue; }    // OK p05 p04\n                        if (a==0x1B) { _pixel=1; continue; }    // OK p1F\n                        if (a==0x1C) { _pixel=1; continue; }    // OK p10\n                        if (a==0x1D) { _pixel=1; continue; }    // OK p33 p1E p14\n                        if (a==0x1E) { _pixel=1; continue; }    // OK p34 p50 p13\n\n                        // test from dragon and mountain\n                        if (a==0x49) { _pixel=1; continue; }    // ?? ?p02\n                        if (a==0xE3) { _pixel=1; continue; }    // ?? p18\n                        if (a==0xD7) { _pixel=1; continue; }    // ?? pBC\n                        if (a==0xDA) { _pixel=1; continue; }    // ?? ?p02\n\n                        // sequence start\n                        if (a==0x13) { seq=0; _sequence=a; } // 03\n                        if (a==0x17) { seq=0; _sequence=a; } // 01\n                        if (a==0x23) { seq=0; _sequence=a; } // 01 03\n                        if (a==0x27) { seq=0; _sequence=a; } // 01\n                        if (a==0x2B) { seq=0; _sequence=a; } // 01 !03 03\n                        if (_sequence)\n                            {\n                            if (adr==dir[y]+3) { _sequence=false; break; }\n                            continue;\n                            }\n                        break;\n                        }\n                    if (_stop) break;\n                    if (x&gt;xs) break;\n                    if ((mode==1)&amp;&amp;((a==0xFE)||(a==0xFF))) { a=dat[adr]; adr++; }   // shadows?\n\n                    if ((x&gt;=0)&amp;&amp;(x&lt;xs)) p[x]=pal[a]; x++;\n                    #ifdef _debug_draw\n                    // copy decoded data to debug image\n                    img.p[y].dec+=char(BYTE(a));\n                    #endif\n                    }\n                }\n            delete[] dir; dir=NULL;\n            #ifdef _debug_save\n            // save frames to bmp\n            s=frame;\n            while (s.Length()&lt;3) s=\"0\"+s;\n            png-&gt;Assign(bmp);\n            png-&gt;SaveToFile(\"decoded_\"+fnam+\"_\"+s+\".png\");\n            #endif\n            }\n        img.compute();\n        break;\n        }\n    delete[] dat;\n    }\n</code></pre>\n</div>",
            "votes": "24",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">The comments have been <a href=\"http://chat.stackexchange.com/rooms/44406/discussion-on-answer-by-spektre-decoding-an-unknown-image-format-with-drek-sig\">moved to chat</a>; please do not use comments for extended discussions.</span>",
                    "time": null
                }
            ]
        }
    ]
}