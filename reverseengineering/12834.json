{
    "title": "Randomly picking up a x86 register for an instruction",
    "link": "https://reverseengineering.stackexchange.com/questions/12834/randomly-picking-up-a-x86-register-for-an-instruction",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I came around a piece of malware which i am analyzing and have found that it uses some kind of math to randomly selecting a register for a specific instruction</p>\n<p>Which i don't understand how this operation is calculated depend on what?</p>\n<p>Here is an example of what i mean</p>\n<p>let's say that i wanted to randomly pick up a register for the instruction</p>\n<pre><code>ADD DWORD PTR DS:[0],EAX\n</code></pre>\n<p>We know the opcode for this instruction is 01 <strong>05</strong> 00 00 00 00</p>\n<p>The bold number represents the register for this instruction</p>\n<p>05 == EAX\n0D == ECX</p>\n<p>To better explain this here is the instruction with all the registers</p>\n<pre><code>0041580B    0105 00000000   ADD DWORD PTR DS:[0],EAX\n00415811    010D 00000000   ADD DWORD PTR DS:[0],ECX\n00415817    0115 00000000   ADD DWORD PTR DS:[0],EDX\n0041581D    011D 00000000   ADD DWORD PTR DS:[0],EBX\n00415823    0125 00000000   ADD DWORD PTR DS:[0],ESP\n00415829    012D 00000000   ADD DWORD PTR DS:[0],EBP\n0041582F    0135 00000000   ADD DWORD PTR DS:[0],ESI\n00415835    013D 00000000   ADD DWORD PTR DS:[0],EDI\n</code></pre>\n<p>The malware uses a register index starting from 0 (EAX) till 7 (EDI)</p>\n<p>The number is get SHLed first with the number 3 then it is ORed with 5 to get the right register opcode. So my question is how the author came to the conclusion of that?</p>\n<p>I would say that SHL REG,3 equals REG*8 that is the number of max registers? but why do we need to OR it with 05? is it because the starting opcode of this instruction is 05?</p>\n<p>Does anybody have a better explanation for this? or any hint words for a better comprehend?</p>\n</div>",
    "votes": "11",
    "answers": 1,
    "views": "890",
    "tags": [
        "assembly",
        "x86",
        "malware",
        "register"
    ],
    "user": "RCECoder",
    "time": "Dec 30, 2016 at 20:01",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>To better understand this, you need to study instruction encoding formats i.e. x86 for this question.</p>\n<p>An x86 instruction looks like this</p>\n<pre><code>+----------------------+--------+--------+-----+--------------+-----------+\n| Instruction prefixes | Opcode | ModR/M | SIB | Displacement | Immediate |\n+----------------------+--------+--------+-----+--------------+-----------+\n|          0-4         |   1-3  |   0-1  | 0-1 |      0-4     |    0-4    |\n+----------------------+--------+--------+-----+--------------+-----------+\n</code></pre>\n<p>The numbers on the second row indicates the length in bytes of the corresponding part.</p>\n<p>For the instruction,</p>\n<pre><code>010D 00000000   ADD DWORD PTR DS:[0],ECX\n</code></pre>\n<p>there is no instruction prefix.\nThe opcode for <code>ADD</code> is <code>01</code> (<a href=\"http://x86.renejeschke.de/html/file_module_x86_id_5.html\" rel=\"nofollow noreferrer\">Check here</a>)</p>\n<p>The second byte of the instruction i.e <code>ModR/M</code>is <code>0D</code>.\nThe <code>ModR/M</code> byte provides addressing information about the instruction. It specifies whether an operand is in a register or in memory; if it is in memory, then fields within the byte specify the addressing mode to be used.</p>\n<p>The <code>ModR/M</code> byte can be broken down into</p>\n<pre><code>+-----+------------+-----+\n| Mod | Reg/Opcode | R/M |\n+-----+------------+-----+\n|  2  |      3     |  3  |\n+-----+------------+-----+\n</code></pre>\n<p>Here the numbers on the second row indicates the length in bits of the corresponding parts.</p>\n<p>The <code>Mod</code> field (2 bits) combines with the <code>R/M</code> field (3 bits) to form 32 possible values 8 registers and 24 addressing modes.</p>\n<p>The <code>Reg/Opcode</code> field (3 bits) specifies either a register number or three more bits of opcode information; the <code>r/m</code> field (3 bits) can specify a register as the location of an operand, or it can form part of the addressing-mode encoding in combination with the <code>Mod</code> field.</p>\n<p>Now, convert the <code>ModR/M</code> i.e <code>0D</code> to binary. You would get.</p>\n<pre><code>+-----+------------+-----+\n| Mod | Reg/Opcode | R/M |\n+-----+------------+-----+\n|  00 |     001    | 101 |\n+-----+------------+-----+\n</code></pre>\n<p>The <code>Mod</code> and <code>R/M</code> fields are <code>00</code> and <code>101</code> respectively. This indicates displacement only addressing mode. See the table below.</p>\n<p><a href=\"https://i.sstatic.net/mGqsS.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/mGqsS.png\"/></a> </p>\n<p><strong>For all the instructions this mode of addressing is used, hence the reason for  <code>OR</code>ing with 5 (in binary 101) to set that particular bit pattern.</strong></p>\n<p>Coming to the <code>Reg/Opcode</code> field, this indicates a register. \n<br/><code>001</code> is the register index for <code>ECX</code>. </p>\n<p>For the first instruction i.e\n<br/><code>0105 00000000   ADD DWORD PTR DS:[0],EAX</code>\n<br/>this field is <code>000</code> standing for <code>EAX</code>. You can check by converting <code>05</code> to binary.</p>\n<p>See more in the table below taken from <a href=\"http://www.c-jump.com/CIS77/CPU/x86/X77_0060_mod_reg_r_m_byte.htm\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p><a href=\"https://i.sstatic.net/Ljow1.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/Ljow1.png\"/></a></p>\n<p><strong>So basically the register value was <code>SHL</code>ed with 3 to move it to the correct position. The Reg/Opcode field is 3 bits from the right.</strong></p>\n<p>Finally the last 4 bytes are <code>00000000</code>. This represents the displacement which is zero in this example.</p>\n</div>",
            "votes": "18",
            "user": "0xec",
            "time": "Jun 12, 2016 at 18:49",
            "is_accepted": true,
            "comments": []
        }
    ]
}