{
    "title": "How to identify method order in disassembled C++ object",
    "link": "https://reverseengineering.stackexchange.com/questions/29126/how-to-identify-method-order-in-disassembled-c-object",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Here are some chunks:</p>\n<pre><code>  v13 = cocos2d::FileUtils::getInstance(v9);\n  (*(void (__fastcall **)(char *))(*(_DWORD *)v13 + 64))(&amp;v46);\n\n  v19 = cocos2d::FileUtils::getInstance(fileHandle);\n  v21 = *(void (__fastcall **)(char *, int, unsigned __int8 *))(*(_DWORD *)v19 + 28);\n  v21(&amp;v44, v20, &amp;v42);\n\n  v23 = cocos2d::FileUtils::getInstance(v22),\n  v24 = (cocos2d::FileUtils *)(*(int (**)(void))(*(_DWORD *)v23 + 152))(),\n</code></pre>\n<p>cocos2d is an open source project, and I have downloaded it, but I have no idea how to determine what the order of the methods are.  So, how do I identify what method 28, 64, or 152 really is?  (Dead-listings only, can't execute the code to find the answer).</p>\n</div>",
    "votes": "0",
    "answers": 2,
    "views": "238",
    "tags": [
        "disassembly",
        "c++"
    ],
    "user": "FrankRizzo",
    "time": "Aug 11, 2021 at 1:11",
    "comments": [
        {
            "user": "mindoverflow",
            "text": "<span class=\"comment-copy\">This looks more like a decompilation, but that's besides the point. Is this snippet from the library/dll itself or from a program written using the library?</span>",
            "time": null
        },
        {
            "user": "FrankRizzo",
            "text": "<span class=\"comment-copy\">The above is a Hex Rays \"Pseudo-C\" decompilation of some code from an .SO that has statically linked against the Cocos2D library.  I've picked up a little more information about it.  This is the method used to call virtual C++ methods.  But the question still remains.  How do I work out WHICH virtual C++ method these refer to.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I presume the binary is fully optimized and stripped of debug info<br/>\nMy answer pertains to a windows binary (<strong>ex getinst.exe</strong>) but the generic concept applies to elf (<strong>ex foo.so</strong> )</p>\n<p>some base presumptions about cocos2d from google are</p>\n<ol>\n<li>appears to be 32 bit only</li>\n<li>FileUtils appears to be a singleton implementation judging by the use of getInstance() and google</li>\n</ol>\n<p><a href=\"https://cocos2d-x.org/reference/native-cpp/V3.0alpha0/dc/d69/classcocos2d_1_1_file_utils.html#a290ffa656af77bffd9c938add78d2e06\" rel=\"nofollow noreferrer\">FileUtils* s_sharedFileUtils<br/>\nstaticprotected<br/>\nThe singleton pointer of FileUtils.</a></p>\n<p>shown below is a bare minimum <strong>proof of concept</strong> singleton c++ code</p>\n<pre><code>:\\&gt;type getinst.cpp\n#include &lt;iostream&gt;\nusing namespace std;\nclass Singleton\n{\n        static Singleton *instance;\n        Singleton() {}\npublic:\n        static Singleton *getInstance()\n        {\n                if (!instance)\n                        instance = new Singleton;\n                return instance;\n        }\n        virtual void funcone() { cout &lt;&lt; \"funcone\\n\"; }\n        virtual void functwo() { cout &lt;&lt; \"functwo\\n\"; }\n        virtual void functre() { cout &lt;&lt; \"functre\\n\"; }\n        virtual void funcfor() { cout &lt;&lt; \"funcfor\\n\"; }\n};\nSingleton *Singleton::instance = nullptr;\nint main()\n{\n        Singleton *s = s-&gt;getInstance();\n        s-&gt;funcone();\n        s-&gt;functwo();\n        s-&gt;functre();\n        s-&gt;funcfor();\n        return 0;\n}\n</code></pre>\n<p>compilation and linking with vs2017 as 32bit (x86) Full Optimization and nodebuginfo</p>\n<pre><code>:\\&gt;type complink.bat\ncl /W4 /analyze:autolog- /EHsc /Ox /nologo getinst.cpp /link /release\n</code></pre>\n<p>contents of Directory pre and post compilation and execution of compiled binary</p>\n<pre><code>:\\&gt;ls -lg\ntotal 5\n-rw-r--r-- 1 197121  69 Aug 15 09:43 complink.bat\n-rw-r--r-- 1 197121 603 Aug 15 09:24 getinst.cpp\n\n:\\&gt;complink.bat\n\n:\\&gt;cl /W4 /analyze:autolog- /EHsc /Ox /nologo getinst.cpp /link /release\ngetinst.cpp\n\n:\\&gt;ls -lg\ntotal 261\n-rw-r--r-- 1 197121     69 Aug 15 09:43 complink.bat\n-rw-r--r-- 1 197121    603 Aug 15 09:24 getinst.cpp\n-rwxr-xr-x 1 197121 183808 Aug 15 09:49 getinst.exe\n-rw-r--r-- 1 197121  76677 Aug 15 09:49 getinst.obj\n\n:\\&gt;getinst.exe\nfuncone\nfunctwo\nfunctre\nfuncfor\n</code></pre>\n<p>lets dig into disassembly / find The RTTI / rename / etc</p>\n<p>using a hex editor search for pattern \"<strong>.?A</strong>\"<br/>\nI am using xxd a Commandline hex dumper</p>\n<p>also I am providing a partial name <strong>.?AVSing</strong> to illustrate the point<br/>\nbut on an unknown binary  you maybe forced to analyze all the results of <strong>.?A</strong></p>\n<pre><code>:\\&gt;xxd -g 4 getinst.exe |grep -B 1 -i \".?AVSing\"\n0002a8e0: 676f7279 40737464 40400000 8cf44100  gory@std@@....A.\n0002a8f0: 00000000 2e3f4156 53696e67 6c65746f  .....?AVSingleto\n</code></pre>\n<p>the Address of Partial Mangled class name Starts at 0x2a8f8<br/>\n( &amp;StartofPattern + 4) == ( 0x2a8f4 + 4 ) == <strong>Singleton@@</strong></p>\n<pre><code>:\\&gt;xxd -s 0x2a8f8 -l 16 getinst.exe\n0002a8f8: 5369 6e67 6c65 746f 6e40 4000 8cf4 4100  Singleton@@...A. \n</code></pre>\n<p>Prepend ??_7 and Append 6B@ to this partial Mangled name<br/>\npass the conacatenated string to <strong>undname.exe</strong> or <strong>c++filt</strong> or <a href=\"https://demangler.com\" rel=\"nofollow noreferrer\">demangler.com</a> to get a Demangled or undecorated Name</p>\n<pre><code>:\\&gt;undname ??_7Singleton@@6B@\nMicrosoft (R) C++ Name Undecorator\nCopyright (C) Microsoft Corporation. All rights reserved.\n\nUndecoration of :- \"??_7Singleton@@6B@\"\nis :- \"const Singleton::`vftable'\" \n</code></pre>\n<p>This Class name is part of a Structure Called _TypeDescriptor\n<a href=\"https://www.geoffchappell.com/studies/msvc/language/predefined/\" rel=\"nofollow noreferrer\">https://www.geoffchappell.com/studies/msvc/language/predefined/</a></p>\n<pre><code>typedef struct _TypeDescriptor\n{\n    const void *pVFTable;\n    void *spare;\n    char name []; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n} _TypeDescriptor;\n</code></pre>\n<p>which is a member of another structure</p>\n<pre><code>typedef const struct _s__RTTICompleteObjectLocator {\n    unsigned long signature;\n    unsigned long offset;\n    unsigned long cdOffset;\n    _TypeDescriptor *pTypeDescriptor; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n    __RTTIClassHierarchyDescriptor *pClassDescriptor;\n} __RTTICompleteObjectLocator;\n</code></pre>\n<p>find the cross references to these two structures<br/>\nif the offset member is == 0 (SINGLE INHERITANCE)<br/>\nthe vtable follows the __RTTICompleteObjectLocator with methods</p>\n<p>from the dump above</p>\n<pre><code> _TypeDescriptor.name       = 0x2a8f4\n _TypeDescriptor.spare      = 0x2a8f0\n  _TypeDescriptor.pVFTable  = (FO) 0x2a8ec -&gt; 0x42baec (VA)\n  FO = FileOffset ,VA = VirtualAddress\n  VA == python -c \"print(hex(0x2a8ec-0x29e00+0x42b000))\" \n</code></pre>\n<p>find xref to 0x42baec There Are 2 xrefs</p>\n<pre><code>  :\\&gt;xxd -g4 getinst.exe | grep ecba4200\n00027e90: 00000000 00000000 ecba4200 a08c4200  ..........B...B.\n00027eb0: b88c4200 00000000 ecba4200 00000000  ..B.......B.....\n</code></pre>\n<p>From First Cross Reference</p>\n<pre><code>__RTTICompleteObjectLocator-&gt;pTypeDescriptor    = 0x27e98\n__RTTICompleteObjectLocator.cdOffset            = 0x27e94\n__RTTICompleteObjectLocator.offset              = 0x27e90\n__RTTICompleteObjectLocator.signature           = 0x27e8c\n</code></pre>\n<p>find cross reference  to VA of 0x27e8c</p>\n<pre><code>dumpbin /SECTION:.rdata getinst.exe\n\nSECTION HEADER #2\n  .rdata name\n    EA7E virtual size\n   1C000 virtual address (0041C000 to 0042AA7D)\n    EC00 size of raw data\n   1B200 file pointer to raw data (0001B200 to 00029DFF)\n\n\npython -c \"print(hex(0x27e8c-0x1b200+0x41c000))\"\n0x428c8c\n\n:\\&gt;xxd -g4 getinst.exe | grep 8c8c4200\n0001b470: 66626974 20736574 00000000 8c8c4200  fbit set......B.\n</code></pre>\n<p>the methods follow 0x1b47c at 0x1b480</p>\n<pre><code>:\\&gt;xxd -g 4 -s 0x1b480 -l 64  getinst.exe\n0001b480: 50204000 90204000 70204000 30204000  P @.. @.p @.0 @.\n0001b490: 66756e63 6f6e650a 00000000 66756e63  funcone.....func\n0001b4a0: 74776f0a 00000000 66756e63 7472650a  two.....functre.\n0001b4b0: 00000000 66756e63 666f720a 00000000  ....funcfor.....\n</code></pre>\n<p>4 methods</p>\n<pre><code>0x402050 \n0x402090\n0x402070\n0x402030\n</code></pre>\n<p>disasm of the methods</p>\n<pre><code>:\\&gt;dumpbin /disasm /range:0x402030,0x4020b0 getinst.exe\n\n  00402030: 68 B4 C2 41 00     push        41C2B4h == 0x1b4b4 == funcfor\n  00402035: 68 48 BE 42 00     push        42BE48h\n  0040203A: E8 E1 F0 FF FF     call        00401120\n  0040203F: 83 C4 08           add         esp,8\n  00402042: C3                 ret\n  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  00402050: 68 90 C2 41 00     push        41C290h  \n  :\\&gt;python -c \"print(hex(0x1b490-0x1b200+0x41c000))\"\n    0x41c290  \n   :\\&gt;dumpbin /rawdata /range:0x41c290,0x41c29f getinst.exe\n  0041C290: 66 75 6E 63 6F 6E 65 0A 00 00 00 00 66 75 6E 63  funcone.....func\n  \n  00402055: 68 48 BE 42 00     push        42BE48h\n  0040205A: E8 C1 F0 FF FF     call        00401120\n  0040205F: 83 C4 08           add         esp,8\n  00402062: C3                 ret\n  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  00402070: 68 A8 C2 41 00     push        41C2A8h == 0x1b4a8 == functre\n  00402075: 68 48 BE 42 00     push        42BE48h\n  0040207A: E8 A1 F0 FF FF     call        00401120\n  0040207F: 83 C4 08           add         esp,8\n  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  00402090: 68 9C C2 41 00     push        41C29Ch == 0x1b492 == functwo\n  00402095: 68 48 BE 42 00     push        42BE48h\n  0040209A: E8 81 F0 FF FF     call        00401120\n  0040209F: 83 C4 08           add         esp,8\n  004020A2: C3                 ret\n  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n</code></pre>\n<p>the 4 methods retrieved without symbol information using basic tools and manual fishing.</p>\n<p>hope you can apply this to your cocos2d</p>\n</div>",
            "votes": "1",
            "user": "blabb",
            "time": "Aug 15, 2021 at 23:05",
            "is_accepted": false,
            "comments": [
                {
                    "user": "FrankRizzo",
                    "text": "<span class=\"comment-copy\">This is BY FAR the most incredible answer I've ever seen here.  The amount of work required is STAGGERING!  The <i>ONLY</i> thing that makes it less than 100% ideal for my question is that my instance is in a Linux .SO compiled for ARM.  :-\\</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>If you are using IDA Pro, there are plugins to reconstruct the RTTI (runtime type identification) of the classes you are interested in. Take a look at <a href=\"https://github.com/medigate-io/ida_medigate\" rel=\"nofollow noreferrer\">medigate</a>. There are other similar plugins as well which you can find on the web.</p>\n</div>",
            "votes": "0",
            "user": "Jack",
            "time": "Aug 27, 2021 at 6:07",
            "is_accepted": false,
            "comments": []
        }
    ]
}