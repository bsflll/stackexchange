{
    "title": "Having hard time analyzing stripped code",
    "link": "https://reverseengineering.stackexchange.com/questions/25410/having-hard-time-analyzing-stripped-code",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This is my first time doing RE on a statically linked and stripped binary with ghidra. And I'm having a really hard time analyzing what function does what just by looking the decompiled code present by ghidra.</p>\n<p>Ghidra recognised the binary language ID as <code>ARM:LE:32:v8</code> and I'm especially stuck on this function:</p>\n<pre><code>undefined8 ToSolve1(uint *param_1,uint *param_2,int param_3,uint param_4)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  byte *pbVar3;\n  byte *pbVar4;\n  uint *puVar5;\n  uint *puVar6;\n  byte *pbVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  byte bVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  uint uVar15;\n  uint uVar16;\n  bool bVar17;\n  bool bVar18;\n  \n  if (param_2 &lt; param_1) {\n    param_2 = (uint *)((int)param_2 + param_3);\n    param_1 = (uint *)((int)param_1 + param_3);\n    iVar8 = param_3 + -4;\n    iVar10 = iVar8;\n    if (param_3 &lt; 4) goto LAB_0003ba2c;\n    uVar13 = (uint)param_1 &amp; 3;\n    if (uVar13 != 0) {\n      bVar11 = *(byte *)(uint *)((int)param_2 + -1);\n      *(byte *)(uint *)((int)param_1 + -1) = bVar11;\n      puVar2 = (uint *)((int)param_1 + -1);\n      puVar1 = (uint *)((int)param_2 + -1);\n      if (1 &lt; uVar13) {\n        bVar11 = *(byte *)(uint *)((int)param_2 + -2);\n        *(byte *)(uint *)((int)param_1 + -2) = bVar11;\n        puVar2 = (uint *)((int)param_1 + -2);\n        puVar1 = (uint *)((int)param_2 + -2);\n      }\n      param_2 = puVar1;\n      param_1 = puVar2;\n      if (2 &lt; uVar13) {\n        param_2 = (uint *)((int)param_2 + -1);\n        bVar11 = *(byte *)param_2;\n      }\n      param_4 = (uint)bVar11;\n      if (2 &lt; uVar13) {\n        param_1 = (uint *)((int)param_1 + -1);\n        *(byte *)param_1 = bVar11;\n      }\n      iVar10 = iVar8 - uVar13;\n      bVar17 = iVar8 &lt; (int)uVar13;\n      iVar8 = iVar10;\n      if (bVar17) goto LAB_0003ba2c;\n    }\n    uVar13 = (uint)param_2 &amp; 3;\n    if (uVar13 == 0) {\n      iVar9 = iVar8 + -8;\n      if (7 &lt; iVar8) {\n        iVar8 = iVar8 + -0x1c;\n        iVar10 = iVar8;\n        if (0x13 &lt; iVar9) {\n          do {\n            uVar16 = param_2[-2];\n            uVar14 = param_2[-3];\n            uVar13 = param_2[-4];\n            param_1[-1] = param_2[-1];\n            param_1[-2] = uVar16;\n            param_1[-3] = uVar14;\n            param_1[-4] = uVar13;\n            puVar2 = param_2 + -5;\n            uVar14 = param_2[-6];\n            uVar13 = param_2[-7];\n            param_2 = param_2 + -8;\n            param_4 = *param_2;\n            param_1[-5] = *puVar2;\n            param_1[-6] = uVar14;\n            param_1[-7] = uVar13;\n            param_1 = param_1 + -8;\n            *param_1 = param_4;\n            iVar8 = iVar10 + -0x20;\n            bVar17 = 0x1f &lt; iVar10;\n            iVar10 = iVar8;\n          } while (bVar17);\n        }\n        if (iVar8 + 0x10 &lt; 0 == SCARRY4(iVar8,0x10)) {\n          puVar2 = param_2 + -1;\n          uVar14 = param_2[-2];\n          uVar13 = param_2[-3];\n          param_2 = param_2 + -4;\n          param_4 = *param_2;\n          param_1[-1] = *puVar2;\n          param_1[-2] = uVar14;\n          param_1[-3] = uVar13;\n          param_1 = param_1 + -4;\n          *param_1 = param_4;\n          iVar8 = iVar8 + -0x10;\n        }\n        iVar9 = iVar8 + 0x14;\n        if (iVar9 &lt; 0 == SCARRY4(iVar8,0x14)) {\n          puVar2 = param_2 + -1;\n          uVar13 = param_2[-2];\n          param_2 = param_2 + -3;\n          param_4 = *param_2;\n          param_1[-1] = *puVar2;\n          param_1[-2] = uVar13;\n          param_1 = param_1 + -3;\n          *param_1 = param_4;\n          iVar9 = iVar8 + 8;\n        }\n      }\n      iVar10 = iVar9 + 8;\n      if (iVar10 &lt; 0 == SCARRY4(iVar9,8)) {\n        if (iVar10 &lt; 4) {\n          param_2 = param_2 + -1;\n          param_4 = *param_2;\n        }\n        if (iVar9 + 4 &lt; 0 == SBORROW4(iVar10,4)) {\n          puVar2 = param_2 + -1;\n          param_2 = param_2 + -2;\n          uVar13 = *param_2;\n          param_1[-1] = *puVar2;\n          param_1 = param_1 + -2;\n          *param_1 = uVar13;\n          iVar10 = iVar9;\n        }\n        else {\n          param_1 = param_1 + -1;\n          *param_1 = param_4;\n          iVar10 = iVar9 + 4;\n        }\n      }\n      goto LAB_0003ba2c;\n    }\n    param_2 = (uint *)((uint)param_2 &amp; 0xfffffffc);\n    uVar14 = *param_2;\n    if (1 &lt; uVar13) {\n      if (uVar13 == 2) {\n        if (iVar8 &lt; 0xc) {\nLAB_0003bb4c:\n          do {\n            uVar13 = uVar14 &lt;&lt; 0x10;\n            param_2 = param_2 + -1;\n            uVar14 = *param_2;\n            param_1 = param_1 + -1;\n            *param_1 = uVar13 | uVar14 &gt;&gt; 0x10;\n            iVar10 = iVar8 + -4;\n            bVar17 = 3 &lt; iVar8;\n            iVar8 = iVar10;\n          } while (bVar17);\n        }\n        else {\n          iVar8 = iVar8 + -0xc;\n          do {\n            iVar9 = iVar8;\n            uVar13 = uVar14 &lt;&lt; 0x10;\n            uVar15 = param_2[-1];\n            uVar12 = param_2[-2];\n            uVar16 = param_2[-3];\n            param_2 = param_2 + -4;\n            uVar14 = *param_2;\n            param_1[-1] = uVar13 | uVar15 &gt;&gt; 0x10;\n            param_1[-2] = uVar15 &lt;&lt; 0x10 | uVar12 &gt;&gt; 0x10;\n            param_1[-3] = uVar12 &lt;&lt; 0x10 | uVar16 &gt;&gt; 0x10;\n            param_1 = param_1 + -4;\n            *param_1 = uVar16 &lt;&lt; 0x10 | uVar14 &gt;&gt; 0x10;\n            iVar8 = iVar9 + -0x10;\n          } while (0xf &lt; iVar9);\n          iVar10 = iVar9 + -4;\n          iVar8 = iVar10;\n          if (iVar10 &lt; 0 == SCARRY4(iVar9 + -0x10,0xc)) goto LAB_0003bb4c;\n        }\n        param_2 = (uint *)((int)param_2 + 2);\n        goto LAB_0003ba2c;\n      }\n      if (iVar8 &lt; 0xc) {\nLAB_0003bae0:\n        do {\n          uVar13 = uVar14 &lt;&lt; 8;\n          param_2 = param_2 + -1;\n          uVar14 = *param_2;\n          param_1 = param_1 + -1;\n          *param_1 = uVar13 | uVar14 &gt;&gt; 0x18;\n          iVar10 = iVar8 + -4;\n          bVar17 = 3 &lt; iVar8;\n          iVar8 = iVar10;\n        } while (bVar17);\n      }\n      else {\n        iVar8 = iVar8 + -0xc;\n        do {\n          iVar9 = iVar8;\n          uVar13 = uVar14 &lt;&lt; 8;\n          uVar15 = param_2[-1];\n          uVar12 = param_2[-2];\n          uVar16 = param_2[-3];\n          param_2 = param_2 + -4;\n          uVar14 = *param_2;\n          param_1[-1] = uVar13 | uVar15 &gt;&gt; 0x18;\n          param_1[-2] = uVar15 &lt;&lt; 8 | uVar12 &gt;&gt; 0x18;\n          param_1[-3] = uVar12 &lt;&lt; 8 | uVar16 &gt;&gt; 0x18;\n          param_1 = param_1 + -4;\n          *param_1 = uVar16 &lt;&lt; 8 | uVar14 &gt;&gt; 0x18;\n          iVar8 = iVar9 + -0x10;\n        } while (0xf &lt; iVar9);\n        iVar10 = iVar9 + -4;\n        iVar8 = iVar10;\n        if (iVar10 &lt; 0 == SCARRY4(iVar9 + -0x10,0xc)) goto LAB_0003bae0;\n      }\n      param_2 = (uint *)((int)param_2 + 3);\n      goto LAB_0003ba2c;\n    }\n    if (iVar8 &lt; 0xc) {\nLAB_0003bbb8:\n      do {\n        uVar13 = uVar14 &lt;&lt; 0x18;\n        param_2 = param_2 + -1;\n        uVar14 = *param_2;\n        param_1 = param_1 + -1;\n        *param_1 = uVar13 | uVar14 &gt;&gt; 8;\n        iVar10 = iVar8 + -4;\n        bVar17 = 3 &lt; iVar8;\n        iVar8 = iVar10;\n      } while (bVar17);\n    }\n    else {\n      iVar8 = iVar8 + -0xc;\n      do {\n        iVar9 = iVar8;\n        uVar13 = uVar14 &lt;&lt; 0x18;\n        uVar15 = param_2[-1];\n        uVar12 = param_2[-2];\n        uVar16 = param_2[-3];\n        param_2 = param_2 + -4;\n        uVar14 = *param_2;\n        param_1[-1] = uVar13 | uVar15 &gt;&gt; 8;\n        param_1[-2] = uVar15 &lt;&lt; 0x18 | uVar12 &gt;&gt; 8;\n        param_1[-3] = uVar12 &lt;&lt; 0x18 | uVar16 &gt;&gt; 8;\n        param_1 = param_1 + -4;\n        *param_1 = uVar16 &lt;&lt; 0x18 | uVar14 &gt;&gt; 8;\n        iVar8 = iVar9 + -0x10;\n      } while (0xf &lt; iVar9);\n      iVar10 = iVar9 + -4;\n      iVar8 = iVar10;\n      if (iVar10 &lt; 0 == SCARRY4(iVar9 + -0x10,0xc)) goto LAB_0003bbb8;\n    }\n    param_2 = (uint *)((int)param_2 + 1);\nLAB_0003ba2c:\n    iVar8 = iVar10 + 4;\n    if (iVar8 != 0) {\n      bVar18 = SBORROW4(iVar8,2);\n      bVar17 = iVar10 + 2 &lt; 0;\n      pbVar7 = (byte *)((int)param_2 + -1);\n      bVar11 = *pbVar7;\n      pbVar3 = (byte *)((int)param_1 + -1);\n      *pbVar3 = bVar11;\n      if (1 &lt; iVar8) {\n        pbVar7 = (byte *)((int)param_2 + -2);\n        bVar11 = *pbVar7;\n      }\n      if (bVar17 == bVar18) {\n        pbVar3 = (byte *)((int)param_1 + -2);\n        *pbVar3 = bVar11;\n      }\n      if (iVar8 != 2 &amp;&amp; bVar17 == bVar18) {\n        pbVar7 = pbVar7 + -1;\n        bVar11 = *pbVar7;\n      }\n      if (iVar8 != 2 &amp;&amp; bVar17 == bVar18) {\n        pbVar3 = pbVar3 + -1;\n        *pbVar3 = bVar11;\n      }\n      return CONCAT44(pbVar3,pbVar7);\n    }\n    return CONCAT44(param_1,param_2);\n  }\n  if (param_2 == param_1) {\n    return CONCAT44(param_1,param_2);\n  }\n  iVar8 = param_3 + -4;\n  puVar2 = param_1;\n  iVar10 = iVar8;\n  if (param_3 &lt; 4) goto LAB_0003b7ec;\n  if (((uint)param_1 &amp; 3) == 0) {\n    uVar13 = (uint)param_2 &amp; 3;\n    puVar1 = param_1;\n  }\n  else {\n    iVar10 = -((uint)param_1 &amp; 3);\n    iVar9 = iVar10 + 4;\n    bVar18 = SBORROW4(iVar9,2);\n    bVar17 = iVar10 + 2 &lt; 0;\n    bVar11 = *(byte *)param_2;\n    *(byte *)param_1 = bVar11;\n    puVar2 = (uint *)((int)param_2 + 1);\n    if (1 &lt; iVar9) {\n      puVar2 = (uint *)((int)param_2 + 2);\n      bVar11 = *(byte *)(uint *)((int)param_2 + 1);\n    }\n    puVar1 = (uint *)((int)param_1 + 1);\n    if (bVar17 == bVar18) {\n      puVar1 = (uint *)((int)param_1 + 2);\n      *(byte *)(uint *)((int)param_1 + 1) = bVar11;\n    }\n    param_2 = puVar2;\n    if (iVar9 != 2 &amp;&amp; bVar17 == bVar18) {\n      param_2 = (uint *)((int)puVar2 + 1);\n      bVar11 = *(byte *)puVar2;\n    }\n    param_4 = (uint)bVar11;\n    puVar2 = puVar1;\n    if (iVar9 != 2 &amp;&amp; bVar17 == bVar18) {\n      puVar2 = (uint *)((int)puVar1 + 1);\n      *(byte *)puVar1 = bVar11;\n    }\n    iVar10 = iVar8 - iVar9;\n    if (iVar8 &lt; iVar9) goto LAB_0003b7ec;\n    uVar13 = (uint)param_2 &amp; 3;\n    iVar8 = iVar10;\n    puVar1 = puVar2;\n  }\n  if (uVar13 == 0) {\n    iVar9 = iVar8 + -8;\n    if (7 &lt; iVar8) {\n      iVar8 = iVar8 + -0x1c;\n      if (0x13 &lt; iVar9) {\n        do {\n          iVar10 = iVar8;\n          puVar5 = param_2;\n          puVar2 = puVar1;\n          uVar13 = puVar5[1];\n          uVar14 = puVar5[2];\n          uVar16 = puVar5[3];\n          *puVar2 = *puVar5;\n          puVar2[1] = uVar13;\n          puVar2[2] = uVar14;\n          puVar2[3] = uVar16;\n          param_4 = puVar5[4];\n          uVar13 = puVar5[5];\n          uVar14 = puVar5[6];\n          uVar16 = puVar5[7];\n          param_2 = puVar5 + 8;\n          puVar2[4] = param_4;\n          puVar2[5] = uVar13;\n          puVar2[6] = uVar14;\n          puVar2[7] = uVar16;\n          puVar1 = puVar2 + 8;\n          iVar8 = iVar10 + -0x20;\n        } while (0x1f &lt; iVar10);\n        if (iVar10 + -0x10 &lt; 0 == SCARRY4(iVar8,0x10)) {\n          param_4 = *param_2;\n          uVar13 = puVar5[9];\n          uVar14 = puVar5[10];\n          uVar16 = puVar5[0xb];\n          param_2 = puVar5 + 0xc;\n          *puVar1 = param_4;\n          puVar2[9] = uVar13;\n          puVar2[10] = uVar14;\n          puVar2[0xb] = uVar16;\n          puVar1 = puVar2 + 0xc;\n          iVar8 = iVar10 + -0x30;\n        }\n      }\n      bVar18 = SCARRY4(iVar8,0x14);\n      iVar9 = iVar8 + 0x14;\n      bVar17 = iVar9 &lt; 0;\n      do {\n        if (bVar17 == bVar18) {\n          param_4 = *param_2;\n          uVar13 = param_2[1];\n          uVar14 = param_2[2];\n          param_2 = param_2 + 3;\n          *puVar1 = param_4;\n          puVar1[1] = uVar13;\n          puVar1[2] = uVar14;\n          puVar1 = puVar1 + 3;\n          bVar18 = SBORROW4(iVar9,0xc);\n          iVar9 = iVar9 + -0xc;\n          bVar17 = iVar9 &lt; 0;\n        }\n      } while (bVar17 == bVar18);\n    }\n    iVar10 = iVar9 + 8;\n    puVar2 = puVar1;\n    if (iVar10 &lt; 0 == SCARRY4(iVar9,8)) {\n      if (iVar10 &lt; 4) {\n        param_4 = *param_2;\n        param_2 = param_2 + 1;\n      }\n      if (iVar9 + 4 &lt; 0 == SBORROW4(iVar10,4)) {\n        uVar13 = *param_2;\n        uVar14 = param_2[1];\n        param_2 = param_2 + 2;\n        *puVar1 = uVar13;\n        puVar1[1] = uVar14;\n        puVar2 = puVar1 + 2;\n        iVar10 = iVar9;\n      }\n      else {\n        puVar2 = puVar1 + 1;\n        *puVar1 = param_4;\n        iVar10 = iVar9 + 4;\n      }\n    }\n    goto LAB_0003b7ec;\n  }\n  puVar5 = (uint *)((uint)param_2 &amp; 0xfffffffc) + 1;\n  uVar14 = *(uint *)((uint)param_2 &amp; 0xfffffffc);\n  if (uVar13 &lt; 3) {\n    if (uVar13 == 2) {\n      puVar6 = puVar5;\n      if (iVar8 &lt; 0xc) {\nLAB_0003b910:\n        do {\n          uVar13 = uVar14 &gt;&gt; 0x10;\n          puVar5 = puVar6 + 1;\n          uVar14 = *puVar6;\n          puVar2 = puVar1 + 1;\n          *puVar1 = uVar13 | uVar14 &lt;&lt; 0x10;\n          iVar10 = iVar8 + -4;\n          bVar17 = 3 &lt; iVar8;\n          puVar1 = puVar2;\n          puVar6 = puVar5;\n          iVar8 = iVar10;\n        } while (bVar17);\n      }\n      else {\n        iVar8 = iVar8 + -0xc;\n        do {\n          iVar9 = iVar8;\n          uVar13 = uVar14 &gt;&gt; 0x10;\n          uVar16 = *puVar5;\n          uVar12 = puVar5[1];\n          uVar15 = puVar5[2];\n          uVar14 = puVar5[3];\n          puVar5 = puVar5 + 4;\n          *puVar1 = uVar13 | uVar16 &lt;&lt; 0x10;\n          puVar1[1] = uVar16 &gt;&gt; 0x10 | uVar12 &lt;&lt; 0x10;\n          puVar1[2] = uVar12 &gt;&gt; 0x10 | uVar15 &lt;&lt; 0x10;\n          puVar1[3] = uVar15 &gt;&gt; 0x10 | uVar14 &lt;&lt; 0x10;\n          puVar1 = puVar1 + 4;\n          iVar8 = iVar9 + -0x10;\n        } while (0xf &lt; iVar9);\n        iVar10 = iVar9 + -4;\n        puVar2 = puVar1;\n        puVar6 = puVar5;\n        iVar8 = iVar10;\n        if (iVar10 &lt; 0 == SCARRY4(iVar9 + -0x10,0xc)) goto LAB_0003b910;\n      }\n      param_2 = (uint *)((int)puVar5 + -2);\n      goto LAB_0003b7ec;\n    }\n    puVar6 = puVar5;\n    if (iVar8 &lt; 0xc) {\nLAB_0003b8a4:\n      do {\n        uVar13 = uVar14 &gt;&gt; 8;\n        puVar5 = puVar6 + 1;\n        uVar14 = *puVar6;\n        puVar2 = puVar1 + 1;\n        *puVar1 = uVar13 | uVar14 &lt;&lt; 0x18;\n        iVar10 = iVar8 + -4;\n        bVar17 = 3 &lt; iVar8;\n        puVar1 = puVar2;\n        puVar6 = puVar5;\n        iVar8 = iVar10;\n      } while (bVar17);\n    }\n    else {\n      iVar8 = iVar8 + -0xc;\n      do {\n        iVar9 = iVar8;\n        uVar13 = uVar14 &gt;&gt; 8;\n        uVar16 = *puVar5;\n        uVar12 = puVar5[1];\n        uVar15 = puVar5[2];\n        uVar14 = puVar5[3];\n        puVar5 = puVar5 + 4;\n        *puVar1 = uVar13 | uVar16 &lt;&lt; 0x18;\n        puVar1[1] = uVar16 &gt;&gt; 8 | uVar12 &lt;&lt; 0x18;\n        puVar1[2] = uVar12 &gt;&gt; 8 | uVar15 &lt;&lt; 0x18;\n        puVar1[3] = uVar15 &gt;&gt; 8 | uVar14 &lt;&lt; 0x18;\n        puVar1 = puVar1 + 4;\n        iVar8 = iVar9 + -0x10;\n      } while (0xf &lt; iVar9);\n      iVar10 = iVar9 + -4;\n      puVar2 = puVar1;\n      puVar6 = puVar5;\n      iVar8 = iVar10;\n      if (iVar10 &lt; 0 == SCARRY4(iVar9 + -0x10,0xc)) goto LAB_0003b8a4;\n    }\n    param_2 = (uint *)((int)puVar5 + -3);\n    goto LAB_0003b7ec;\n  }\n  puVar6 = puVar5;\n  if (iVar8 &lt; 0xc) {\nLAB_0003b97c:\n    do {\n      uVar13 = uVar14 &gt;&gt; 0x18;\n      puVar5 = puVar6 + 1;\n      uVar14 = *puVar6;\n      puVar2 = puVar1 + 1;\n      *puVar1 = uVar13 | uVar14 &lt;&lt; 8;\n      iVar10 = iVar8 + -4;\n      bVar17 = 3 &lt; iVar8;\n      puVar1 = puVar2;\n      puVar6 = puVar5;\n      iVar8 = iVar10;\n    } while (bVar17);\n  }\n  else {\n    iVar8 = iVar8 + -0xc;\n    do {\n      iVar9 = iVar8;\n      uVar13 = uVar14 &gt;&gt; 0x18;\n      uVar16 = *puVar5;\n      uVar12 = puVar5[1];\n      uVar15 = puVar5[2];\n      uVar14 = puVar5[3];\n      puVar5 = puVar5 + 4;\n      *puVar1 = uVar13 | uVar16 &lt;&lt; 8;\n      puVar1[1] = uVar16 &gt;&gt; 0x18 | uVar12 &lt;&lt; 8;\n      puVar1[2] = uVar12 &gt;&gt; 0x18 | uVar15 &lt;&lt; 8;\n      puVar1[3] = uVar15 &gt;&gt; 0x18 | uVar14 &lt;&lt; 8;\n      puVar1 = puVar1 + 4;\n      iVar8 = iVar9 + -0x10;\n    } while (0xf &lt; iVar9);\n    iVar10 = iVar9 + -4;\n    puVar2 = puVar1;\n    puVar6 = puVar5;\n    iVar8 = iVar10;\n    if (iVar10 &lt; 0 == SCARRY4(iVar9 + -0x10,0xc)) goto LAB_0003b97c;\n  }\n  param_2 = (uint *)((int)puVar5 + -1);\nLAB_0003b7ec:\n  iVar8 = iVar10 + 4;\n  if (iVar8 != 0) {\n    bVar18 = SBORROW4(iVar8,2);\n    bVar17 = iVar10 + 2 &lt; 0;\n    bVar11 = *(byte *)param_2;\n    *(byte *)puVar2 = bVar11;\n    pbVar3 = (byte *)((int)param_2 + 1);\n    if (1 &lt; iVar8) {\n      pbVar3 = (byte *)((int)param_2 + 2);\n      bVar11 = *(byte *)((int)param_2 + 1);\n    }\n    pbVar7 = (byte *)((int)puVar2 + 1);\n    if (bVar17 == bVar18) {\n      pbVar7 = (byte *)((int)puVar2 + 2);\n      *(byte *)((int)puVar2 + 1) = bVar11;\n    }\n    pbVar4 = pbVar3;\n    if (iVar8 != 2 &amp;&amp; bVar17 == bVar18) {\n      pbVar4 = pbVar3 + 1;\n      bVar11 = *pbVar3;\n    }\n    if (iVar8 != 2 &amp;&amp; bVar17 == bVar18) {\n      *pbVar7 = bVar11;\n    }\n    return CONCAT44(param_1,pbVar4);\n  }\n  return CONCAT44(param_1,param_2);\n}\n</code></pre>\n<p>My best guess for now is it is doing some kind of encoding and it might be a standard glibc function as it is called many times throughout the code.</p>\n<p>This function is usally called with parameter like follows:</p>\n<pre><code>ToSolve1(auStack55,(uint *)&amp;DAT_000543f4,0xe,uVar10);\nToSolve1(auStack55,(uint *)&amp;DAT_0005489c,0xe,uVar10);\nToSolve1((uint *)&amp;DAT_0004f602,&amp;local_1c,4,(uint)&amp;DAT_0004f680);\nToSolve1(param_1,&amp;DAT_0004f5f8,0xe,(uint)puVar4);\n</code></pre>\n<p>Hope someone can give me a nudge on what this function is.\nIf possible, I would like to learn about if there are any resources out there that can help me improve the skills of recognizing standard function signatures.</p>\n</div>",
    "votes": "0",
    "answers": 1,
    "views": "1k",
    "tags": [
        "arm",
        "ghidra",
        "functions"
    ],
    "user": "Jimmy.D",
    "time": "Jun 27, 2020 at 15:54",
    "comments": [
        {
            "user": "multithr3at3d",
            "text": "<span class=\"comment-copy\">Sometimes dynamic analysis helps here. If you can set a breakpoint when the function is called, examine the inputs, and the examine the results after returning, you may figure out what it is doing without dealing with the above mess</span>",
            "time": null
        },
        {
            "user": "Jimmy.D",
            "text": "<span class=\"comment-copy\">@multithr3at3d Great advice! Unfortunately I'll have to solve this question first because the binary which this function came from is preventing me from accessing system shell. (Kinda like a custom shell thingy) I'm doing RE on this binary hoping to find away to get system shell.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>For starters you could start by geting rid of most of the casts then start carving out the stack and heap structs where possible, then try to change the name of variables where possible to more type oriented ones, this will show most of the \"duplicate\" variables.</p>\n<p>Then start following the main flow following labels and maybe change their name to what specific position mignt represet, like <code>fail_exit</code> or <code>success_exit</code> etc</p>\n<p>Allso, is allways good to have the basic std structs defined if the source was compiled with c++.</p>\n<p>e.g</p>\n<pre><code>struct std_vector{\n  void* begin;\n  void* end;\n  void* capacity;\n} \n\nstruct std_tree_node_base{\n       std_tree_node_base* left;\n       std_tree_node_base* parent;\n       std_tree_node_base* right;\n       char color;\n       char isNil;\n       short pad1;\n       //here will be the payload of the node, padded if needed\n }\n\n //red-black tree used to implement std::map, std::set\n struct std_tree{\n      std_tree_node_base*    head;\n      __int64                size;\n }\n\n struct std_list_node{\n      std_list_node* next;\n      std_list_node* prev;\n      //node payload here\n }\n\n struct std_list{\n      std_list_node* head;\n      __int64        size;\n }\n\n //same for std::wstring but using wchar_t* \n struct std_string {\n       char*    _Begin;\n       char*    _End;\n       __int64  _MySize;\n       __int64  _MyReserved;\n }\n</code></pre>\n<p>And maybe switch to IDA as its has a lot better decompiler than Ghidra.\nI think you can get the freeware version on their website, should suffice.</p>\n<p>Good Luck!</p>\n</div>",
            "votes": "0",
            "user": "Balan Narcis",
            "time": "Jun 27, 2020 at 17:32",
            "is_accepted": true,
            "comments": [
                {
                    "user": "multithr3at3d",
                    "text": "<span class=\"comment-copy\">Whether IDA has a better decompiler is rather subjective in this case. Also, don't think the free version includes an ARM decompiler.</span>",
                    "time": null
                },
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">@multithr3at3d IDA does not include any decompiler. You can purchase it as a plugin and it costs approximately twice as much as the basic product. Personally I have found decompilers more confusing than helpful. They help in very specific circumstances and when they are interactive enough, but oftentimes I'll be faster sifting through assembly and only when I find an algorithm it pays off to have a decompiler at hand.</span>",
                    "time": null
                }
            ]
        }
    ]
}