{
    "title": "Import table vs Import Address Table",
    "link": "https://reverseengineering.stackexchange.com/questions/16870/import-table-vs-import-address-table",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>What's the difference between the Import Table and the Import Address Table?</p>\n</div>",
    "votes": "7",
    "answers": 2,
    "views": "18k",
    "tags": [
        "binary-analysis",
        "x86",
        "pe"
    ],
    "user": "Trey",
    "time": "Nov 30, 2017 at 12:39",
    "comments": [
        {
            "user": "julian",
            "text": "<span class=\"comment-copy\">Duplicate of <a href=\"https://stackoverflow.com/questions/32841368/whats-the-difference-between-the-import-table-import-adress-table-and-import\">What's the difference between the import table, import adress table, and import name table?</a>. Also  RTFM. Hence the down vote.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><em>As general, I recommend reading the <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx\" rel=\"noreferrer\">PE Format documentation</a> on MSDN regarding the PE structure.</em> </p>\n<h2>Import Table</h2>\n<p>The Import Table is actually called \"Import Directory Table\" and contains entries for every DLL which is loaded by the executable. Each entry contains, among other, Import Lookup Table (ILT) and Import Address Table (IAT)</p>\n<p>To quote from the PE format specs about <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx#import_directory_table\" rel=\"noreferrer\">Import Directory Table</a>:</p>\n<blockquote>\n<p><strong>Import Directory Table</strong><br/>\n  The import information begins with the import directory table, which describes the remainder of the import\n  information. The import directory table contains address information\n  that is used to resolve fixup references to the entry points within a\n  DLL image. The import directory table consists of an array of import\n  directory entries, one entry for each DLL to which the image refers.\n  The last directory entry is empty (filled with null values), which\n  indicates the end of the directory table. Each import directory entry\n  has the following format:</p>\n<pre><code>Offset    Size    Field\n0         4       Import Lookup Table RVA\n4         4       Time/Date Stamp\n8         4       Forwarder Chain\n12        4       Name RVA\n16        4       Import Address Table RVA\n</code></pre>\n</blockquote>\n<hr/>\n<h2>Import Address Table</h2>\n<p>The Import Address Table is comprised of function pointers, ans is used to get the addresses of functions when the DLLs are loaded. A compiled application was designed so that all API calls will not use direct hardcoded addresses but rather work through a function pointer. The pointer table can be accessed in several ways -- either directly by a <em>call</em> to <code>[pointer address]</code> or by the <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx#import_lookup_table\" rel=\"noreferrer\">\"Import Lookup Table\"</a> and the <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx#hint_name_table\" rel=\"noreferrer\">\"Hint/Name Table\"</a>.</p>\n<p>Let's quote again from the PE specs about the <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx#import_address_table\" rel=\"noreferrer\">\"Import Address Table\"</a>:</p>\n<blockquote>\n<p><strong>Import Address Table</strong><br/>\n  The structure and content of the import address table are identical to those of the import lookup table, until\n  the file is bound. During binding, the entries in the import address\n  table are overwritten with the 32-bit (for PE32) or 64-bit (for PE32+)\n  addresses of the symbols that are being imported. These addresses are\n  the actual memory addresses of the symbols, although technically they\n  are still called \"virtual addresses.\" The loader typically processes\n  the binding.</p>\n</blockquote>\n<hr/>\n<h2>References:</h2>\n<ul>\n<li><a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx\" rel=\"noreferrer\">PE Format specifications</a></li>\n<li><a href=\"http://sandsprite.com/CodeStuff/Understanding_imports.html\" rel=\"noreferrer\">Understanding the Import Address Table</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Portable_Executable\" rel=\"noreferrer\">Wikipedia: Portable Executable</a></li>\n<li><a href=\"https://stackoverflow.com/a/32845334#7193722\">SO answer</a></li>\n</ul>\n</div>",
            "votes": "17",
            "user": "evandrix",
            "time": "Jun 15, 2020 at 12:30",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>First, beside “yours” two tables, I introduce a <em>third</em> one, the <strong>Import Lookup Table</strong>.</p>\n<p>Side by side with the <strong>Import Address Table</strong>, these two tables look like in this simplified picture:</p>\n<p><a href=\"https://i.sstatic.net/dPx9f.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/dPx9f.png\"/></a></p>\n<p>This picture shows the situation in your executable file on <strong>disk</strong>. They are totally identical, with the exactly same lists of the API function names (more precisely, <em>pointers</em> to the displayed names), in the exactly same order.</p>\n<hr>\n<p>Now, the loader loads your executable and maps all required DLLs (Dynamic-Link Libraries) into your virtual memory space.</p>\n<p>After finishing it and some calculations, the loader already knows addresses of all your imported functions.</p>\n<p>So it <strong>replaces</strong> the names of your imported functions in the second table (Import Address Table) with their addresses, and the situation in <strong>memory</strong> becomes different:</p>\n<p><a href=\"https://i.sstatic.net/nCbGR.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/nCbGR.png\"/></a></p>\n<hr>\n<p>On the other hand, the Import Table, more precisely <strong>Import Directory Table</strong>, is a gateway to these 2 tables.</p>\n<p>It is an array (a table) of entries, one entry (a row) for every imported library.<br>\nA simplified picture of it is here:</br></p>\n<p><a href=\"https://i.sstatic.net/W6Nfl.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/W6Nfl.png\"/></a></p>\n<p>Every row consist of 5 double words (pointers). Important are only 3 of them, the first (a pointer to the ILT), the last (a pointer to the IAT), and the last but one (identifying the row by the name of DLL; so it's a pointer to the DLL's name in the fourth involved table, the <strong>Hint/Name Table</strong>).</p>\n<p>So its cooperation with other two tables looks like this:</p>\n<p><a href=\"https://i.sstatic.net/P4qzX.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/P4qzX.png\"/></a></p>\n<p>(I omitted the fourth table, the mentioned <em>Hint/Name Table</em> with names of all imported functions and names of all imported libraries, too.)</p>\n<hr/>\n<p><strong>Note:</strong> I intentionally omitted <em>zero-filled separating rows</em> in my pictures, and I didn't deal with <em>imports by ordinal</em> (for the sake of simplicity to emphasize ideas).</p>\n</hr></hr></div>",
            "votes": "9",
            "user": "MarianD",
            "time": "Oct 14, 2021 at 17:56",
            "is_accepted": false,
            "comments": []
        }
    ]
}