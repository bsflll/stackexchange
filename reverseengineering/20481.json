{
    "title": "Why does vmt hooking not work with instance member in the following case?",
    "link": "https://reverseengineering.stackexchange.com/questions/20481/why-does-vmt-hooking-not-work-with-instance-member-in-the-following-case",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><strong>Why does the function not get hooked when called with instance member obj.myFunc() ?</strong></p>\n<pre><code>class Myclass\n{\n\npublic:\n    virtual void myFunc() = 0;\n\n};\nclass Derived : public Myclass\n{\npublic:\n    void myFunc()\n    {\n        std::cout &lt;&lt; \"Actual method is called\" &lt;&lt; std::endl;\n    }\n};\n\n    void __fastcall hk_myFunc(void* thisPtr, int edx)\n    {\n        std::cout &lt;&lt; \"Hooked method is called\" &lt;&lt; std::endl;\n    }\n\ntypedef void(__thiscall *fPtr)();\n\nint main()\n{\n    Derived* ptr = new Derived();\n    ptr-&gt;myFunc();// Output : Actual method is called.\n    void** vTPtr = *(reinterpret_cast&lt;void ***&gt;(ptr));\n    DWORD oldProtection;\n    VirtualProtect(vTPtr, 4, PAGE_EXECUTE_READWRITE, &amp;oldProtection);\n    *vTPtr = reinterpret_cast&lt;fPtr&gt;(&amp;hk_myFunc);\n    VirtualProtect(vTPtr, 4, oldProtection, 0);\n    ptr-&gt;myFunc(); //Output: Hooked method is called\n    Derived obj = *ptr;\n    obj.myFunc(); // Output : Actual method is called. Why ??\n    return 0;\n}\n</code></pre>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "144",
    "tags": [
        "function-hooking",
        "hooking"
    ],
    "user": "kk ll",
    "time": "Jan 27, 2019 at 15:19",
    "comments": [
        {
            "user": "Milhous",
            "text": "<span class=\"comment-copy\">Have you tried disassembling the output and looking at the differences?</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The problem is the way you reference this object with a new pointer.</p>\n<pre><code>Derived obj = *ptr;\n</code></pre>\n<p>This actually creates a new object utilizing the data of the old object. Yay! C++!</p>\n<p><a href=\"https://i.sstatic.net/Ev6Nc.png\" rel=\"nofollow noreferrer\"><img alt=\"IDA Decompilation\" src=\"https://i.sstatic.net/Ev6Nc.png\"/></a></p>\n<p>In line 27 you can see that a new object is generated by calling a constructor. If you have a look at the disassembly, you'll see the vtable is not used for the function call. Hence you end up with the non-modified function.</p>\n<p><a href=\"https://i.sstatic.net/n9QHa.png\" rel=\"nofollow noreferrer\"><img alt=\"disassembly\" src=\"https://i.sstatic.net/n9QHa.png\"/></a></p>\n<p>Btw, when you change the line referenced above to</p>\n<pre><code>(*ptr).myFunc();\n</code></pre>\n<p>The output works as expected</p>\n</div>",
            "votes": "2",
            "user": "Nordwald",
            "time": "Jan 30, 2019 at 5:40",
            "is_accepted": true,
            "comments": []
        }
    ]
}