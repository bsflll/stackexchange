{
    "title": "Need help to reverse engineer a dog collar transmitter",
    "link": "https://reverseengineering.stackexchange.com/questions/19671/need-help-to-reverse-engineer-a-dog-collar-transmitter",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have a Petrainer PET998DRU shock collar (similar to <a href=\"https://rads.stackoverflow.com/amzn/click/B00W6UVROK\" rel=\"nofollow noreferrer\">this one</a>) that got partially chewed up by the dog it is supposed to train. I salvaged it to the point where I have the following buttons:</p>\n<ul>\n<li>Mode (to select light, beep, vibrate, and zap</li>\n<li>Activate (to send appropriate stimulation)</li>\n<li>Up arrow (to increase the amount of stim)</li>\n</ul>\n<p>The display does not work so I don't know what the setting (which stim and how much) is on other than trial and error.</p>\n<p>I have followed the method on here: <a href=\"http://brettleaver.com/collar/\" rel=\"nofollow noreferrer\">http://brettleaver.com/collar/</a> to get as far as I have gotten but the protocol differs on this model and I have only been able to figure out the device ID and the stim type (I think). I can replay the packets on a separate 433Mhz transmitter and the collar responds appropriately but I want to figure out the whole packet. The amount of stim is what I need helping decoding.</p>\n<p><strong>Logic for beep</strong>\n<a href=\"https://i.sstatic.net/08buD.png\" rel=\"nofollow noreferrer\"><img alt=\"Image for beep (no duration is encoded by design)\" src=\"https://i.sstatic.net/08buD.png\"/></a></p>\n<p>I decoded this as <code>0xDF 7E DE ED 7F D6 AB</code>\nIf this is wrong, then please let me know because it may give me a clue as to why I can't figure out the rest.</p>\n<p><strong>Logic for zap</strong>\n<a href=\"https://i.sstatic.net/aBYSv.png\" rel=\"nofollow noreferrer\"><img alt=\"Image for zap (unknown duration)\" src=\"https://i.sstatic.net/aBYSv.png\"/></a></p>\n<p>I decoded this as <code>0x‭DF DE DE ED 6F 7A AA C0‬</code>. The last bits to finish up the last octet are assumed to be logic 0's. Maybe this assumption is wrong though.</p>\n<p>I decoded the other packets similarly but I won't post all the images.</p>\n<p>EDIT: I have since gotten captures of vibrates and zaps where I know the duration is 0.</p>\n<ul>\n<li>Light: <code>0xDE FE DE ED 7F D5 AB</code></li>\n<li>Beep: <code>0xDF 7E DE ED 7F D6 AB</code></li>\n<li>Zap: <code>0x‭DF DE DE ED 7F EA AB‬</code></li>\n<li>Vibrate <code>0x‭DF BE DE ED 7F DA AB</code></li>\n</ul>\n<p>All the packets except the Light start out with <code>0XDF</code>. The next position (7, F, D, or B) seems to determine stim type. The next 5 are always<code>0xE DE ED</code> so that seems to determine the device ID. All the characters after that are encoding the duration of the zap or buzz and then something to do with a checksum of some sort.</p>\n<p>Here is what I got for the buzz stim in sequential order. After recording each one, I incremented by one and then sent the command again:</p>\n<ul>\n<li><code>0x‭DF BE DE ED</code> <strong><code>7F AD 55 80</code></strong></li>\n<li><code>0x‭DF BE DE ED</code> <strong><code>7F 6D 55 80</code></strong></li>\n<li><code>0x‭DF BE DE ED</code> <strong><code>7F 56 AA C0</code></strong></li>\n<li><code>0x‭DF BE DE ED</code> <strong><code>7E ED 55 80</code></strong></li>\n<li><code>0x‭DF BE DE ED</code> <strong><code>7E D6 AA C0</code></strong>\n...</li>\n</ul>\n<p>An interesting thing I found is that one of the following patterns are always present but I can't figure out the significance:</p>\n<ul>\n<li><code>0x__ _B 55 60</code></li>\n<li><code>0x__ _D 55 80</code></li>\n<li><code>0x__ _6 AA C0</code></li>\n<li><code>0x__ _5 AA B0</code></li>\n</ul>\n<p>EDIT: Another interesting thing to note is that there is never 2 consecutive zeros. </p>\n<p>Assuming I haven't made a huge mistake from the beginning (this is my first attempt at reverse engineering something), does anyone see an obvious encoding scheme or checksum that is being used?</p>\n<p>My end goal is to code up a new 433MHz transmitter and make it controllable with a yet to be made mobile app.</p>\n</div>",
    "votes": "9",
    "answers": 1,
    "views": "1k",
    "tags": [
        "encodings",
        "binary-diagnosis"
    ],
    "user": "dreed75",
    "time": "Oct 24, 2018 at 3:09",
    "comments": [
        {
            "user": "Biswapriyo",
            "text": "<span class=\"comment-copy\">Hardware reverse engineering may help.</span>",
            "time": null
        },
        {
            "user": "dreed75",
            "text": "<span class=\"comment-copy\">Meaning, analyze the transmitter hardware and do a dump of its firmware?</span>",
            "time": null
        },
        {
            "user": "user202729",
            "text": "<span class=\"comment-copy\">This sounds like a lot of effort in comparison with buying a new one. :)</span>",
            "time": null
        },
        {
            "user": "user202729",
            "text": "<span class=\"comment-copy\">By the way, can you explain how the thing is supposed to work? Not everyone knows what a pet trainer is. (so there is a part that receives the signal, and another part which is like a remote controller, that has some buttons broken because of the dog, right?)</span>",
            "time": null
        },
        {
            "user": "user202729",
            "text": "<span class=\"comment-copy\">Also: What are you trying to do? (\"simulate\" broken buttons? If so which one?)</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<h2>Answer</h2>\n<p>Consider a \"gap\" to be a \"low\" interval between two consecutive \"high\" interval, ignoring the first longest one. Then, a bit <code>1</code> corresponds to a long gap, and a bit <code>0</code> corresponds to a short gap.</p>\n<p><a href=\"https://i.sstatic.net/7kFKe.png\" rel=\"nofollow noreferrer\"><img alt=\"\" src=\"https://i.sstatic.net/7kFKe.png\"/></a></p>\n<p>Therefore, the messages decoded that way are:</p>\n<pre><code>88 14 4b 00 ee   : Light\n84 14 4b 00 de   : Beep\n81 14 4b 00 7e   : Zap\n82 14 4b 00 be   : Vibrate\n82 14 4b 01 be   : Buzz stim in sequential order\n82 14 4b 02 be\n82 14 4b 03 be\n82 14 4b 04 be\n82 14 4b 05 be\n82 14 4b 06 be\n82 14 4b 07 be\n82 14 4b 08 be\n</code></pre>\n<p>That follows the exact same pattern as described at <a href=\"http://brettleaver.com/collar/\" rel=\"nofollow noreferrer\">http://brettleaver.com/collar/</a>, except that the remote UID is <code>14 4b</code> instead of <code>20 89</code>.</p>\n<p>(quoting the link above:</p>\n<blockquote>\n<p>Now we can easily decode what the remote is sending! After changing the settings several times and looking at how it changes the transmission, it became clear what the signal represented.</p>\n<p><code><b>8</b>1 20 89 32 7e</code><br/>\nThis will be set to <code>8</code> if the remote is on channel 1<br/>\nThis will be set to <code>f</code> if the remote is on channel 2</p>\n<p><code>8<b>1</b> 20 89 32 7e</code><br/>\nThis will be set to <code>1</code> when the remote is requesting a shock<br/>\nThis will be set to <code>2</code> when the remote is requesting a vibration<br/>\nThis will be set to <code>4</code> when the remote is requesting a beep<br/>\nThis will be set to <code>8</code> when the remote is requesting an LED flash</p>\n<p><code>81 <b>20 89</b> 32 7e</code><br/>\nThese bytes represent the UID of the remote, and never change.</p>\n<p><code>81 20 89 <b>32</b> 7e</code><br/>\nThis byte represents the intensity of the vibration/shock.<br/>\nThe collar will ignore anything above 100</p>\n<p><code>81 20 89 32 <b>7</b>e</code><br/>\nThis will be set to <code>7</code> when the remote is requesting a shock<br/>\nThis will be set to <code>B</code> when the remote is requesting a vibration<br/>\nThis will be set to <code>D</code> when the remote is requesting a beep<br/>\nThis will be set to <code>E</code> when the remote is requesting an LED flash</p>\n<p><code>81 20 89 32 7<b>e</b></code><br/>\nThis will be set to <code>E</code> if the remote is on channel 1<br/>\nThis will be set to <code>0</code> if the remote is on channel 2</p>\n<p><code>81 20 89 32 <b>7e</b></code><br/>\nThis last byte is equal to the first byte, but with its bits reversed and inverted. I think it’s some kind of error checking mechanism, as the collar will ignore all transmissions where this isn’t the case.</p>\n</blockquote>\n<p>)</p>\n<hr/>\n<h2>Derivation</h2>\n<p>Consider the signal in binary:</p>\n<pre>\n110111111011111011011110111011010111111110<b><i>101101010101011</i></b>0000000\n110111111011111011011110111011010111111101<b><i>101101010101011</i></b>0000000\n1101111110111110110111101110110101111111010<b><i>101101010101011</i></b>000000\n110111111011111011011110111011010111111011<b><i>101101010101011</i></b>0000000\n1101111110111110110111101110110101111110110<b><i>101101010101011</i></b>000000\n1101111110111110110111101110110101111110101<b><i>101101010101011</i></b>000000\n11011111101111101101111011101101011111101010<b><i>101101010101011</i></b>00000\n110111111011111011011110111011010111110111<b><i>101101010101011</i></b>0000000\n</pre>\n<p>Note how the <code><b><i>bold italic</i></b></code> part appear in all of the sequences, and not in a fixed place? That leads me to suspect that the message has a variable length, and the trailing zeroes doesn't matter.</p>\n<p>The common prefix of all the messages is <code>11011111101111101101111011101101011111</code>. We will cut out this part, but leave a <code>1</code> in the message -- the reason will be apparent later.</p>\n<p>The remaining part is:</p>\n<pre><code>11110\n11101\n111010\n11011\n110110\n110101\n1101010\n10111\n</code></pre>\n<p>Note that this is supposed to be (a part of) an increasing, consecutive number sequence.</p>\n<p>From OP's observation (there are no two consecutive zeroes), and note that there are 3 pairs in the data above where the latter one is the former one with a <code>0</code> appended, I guess that a <code>0</code> is encoded as a <code>10</code> and a <code>1</code> is encoded as a <code>1</code> (or vice versa).</p>\n<p>Replacing <code>10</code> with <code>1</code> gives:</p>\n<pre><code>1110\n1101\n1100\n1011\n1010\n1001\n1000\n0111\n</code></pre>\n<p>Looks good enough. This counts in decreasing order, so we have to negate the bits (<code>0</code> is encoded as <code>1</code>, <code>1</code> is encoded as <code>10</code>).</p>\n<p>It's obvious that the bits come in decreasing significance (most significant bit first). Because the value represented is from 1 to 100, the 3 previous bits are also a part of the value.</p>\n<p>I also suspect that</p>\n<p><a href=\"https://i.sstatic.net/lx5mQ.png\" rel=\"nofollow noreferrer\"><img alt=\"\" src=\"https://i.sstatic.net/lx5mQ.png\"/></a></p>\n<p>is only a start-of-transmission mark and does not contribute to the data,  because it's larger than all the others.</p>\n</div>",
            "votes": "4",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": [
                {
                    "user": "dreed75",
                    "text": "<span class=\"comment-copy\">Thanks for that. Do you really think they designed it that complex? Does this encoding somehow make it a more robust transmission? I'll code up a converter where I can give it an input of an actual number and it will output the above encoding. Then I'll try other numbers from 0-100 and see if the collar responds.</span>",
                    "time": null
                },
                {
                    "user": "dreed75",
                    "text": "<span class=\"comment-copy\">Great clue user202729! I went ahead and decoded the entire bitstream following your example (1=0, 10=1) and also ignored that first bit. The values I got are exactly the same as the values at <a href=\"http://brettleaver.com/collar/\" rel=\"nofollow noreferrer\">brettleaver.com/collar</a> except my device ID is 14 4B. If you want to edit your answer to clear that up, I'll accept your answer. Any idea why they encoded it that way? Maybe it's just to make reverse engineering difficult :).</span>",
                    "time": null
                }
            ]
        }
    ]
}