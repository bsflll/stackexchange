{
    "title": "Impossible to execute a program with radare2 : TO DO continue",
    "link": "https://reverseengineering.stackexchange.com/questions/20187/impossible-to-execute-a-program-with-radare2-to-do-continue",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to crack a crackme. I already catch the flag because I seen the string variable which represants flag. I would like to catch the flag on an other way, I want to set a breakpoint when there is a comparison of the string. I want to use radare2.</p>\n<p>When I use the <em>dc</em> command to run the program which should stop to breakpoint I set up, I have the message <em>TO DO continue</em>. I don't know why. I expected a message in the form :</p>\n<pre><code>string 1 : TheStringIEnter string 2 : TheFlagOfTheChallenge\n</code></pre>\n<p>This is the commands I execute :</p>\n<pre><code>radare 2 -d ch1.bin\ns sym.main\naaa\npdf\nVV\n:\n:&gt; db 0x08048705\n:&gt; dc\nTODO continue\n:&gt; \n</code></pre>\n<p>This is the output of pdf command :</p>\n<pre><code>[0x0804869d]&gt; pdf\n/ (fcn) main 155\n|   main (int argc, char **argv, char **envp);\n|           ; var int local_ch @ ebp-0xc\n|           ; var int local_8h @ ebp-0x8\n|           ; var int local_4h @ esp+0x4\n|           ; DATA XREF from entry0 (0x8048507)\n|           0x0804869d      8d4c2404       lea ecx, [local_4h]         ; 4\n|           0x080486a1      83e4f0         and esp, 0xfffffff0\n|           0x080486a4      ff71fc         push dword [ecx - 4]\n|           0x080486a7      55             push ebp\n|           0x080486a8      89e5           mov ebp, esp\n|           0x080486aa      51             push ecx\n|           0x080486ab      83ec24         sub esp, 0x24               ; '$'\n|           0x080486ae      c745f8418804.  mov dword [local_8h], str.123456789 ; 0x8048841 ; \"123456789\"\n|           0x080486b5      c704244c8804.  mov dword [esp], str.       ; [0x804884c:4]=0x23232323 ; \"############################################################\"\n|           0x080486bc      e807feffff     call sym.imp.puts           ; int puts(const char *s)\n|           0x080486c1      c704248c8804.  mov dword [esp], str.welcome_to_challenge ; [0x804888c:4]=0x20202323 ; \"##        Welcome to this challenge        ##\"\n|           0x080486c8      e8fbfdffff     call sym.imp.puts           ; int puts(const char *s)\n|           0x080486cd      c70424cc8804.  mov dword [esp], str.       ; [0x80488cc:4]=0x23232323 ; \"############################################################\\n\"\n|           0x080486d4      e8effdffff     call sym.imp.puts           ; int puts(const char *s)\n|           0x080486d9      c704240c8904.  mov dword [esp], str.please_enter_pass: ; [0x804890c:4]=0x69756556 ; \"Please enter the password : \"\n|           0x080486e0      e8b3fdffff     call sym.imp.printf         ; int printf(const char *format)\n|           0x080486e5      8b45f4         mov eax, dword [local_ch]\n|           0x080486e8      890424         mov dword [esp], eax\n|           0x080486eb      e80effffff     call sym.getString\n|           0x080486f0      8945f4         mov dword [local_ch], eax\n|           0x080486f3      8b45f8         mov eax, dword [local_8h]\n|           0x080486f6      89442404       mov dword [local_4h], eax\n|           0x080486fa      8b45f4         mov eax, dword [local_ch]\n|           0x080486fd      890424         mov dword [esp], eax\n|           0x08048700      e8d3fdffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)\n|           0x08048705      85c0           test eax, eax\n|       ,=&lt; 0x08048707      7515           jne 0x804871e\n|       |   0x08048709      8b45f8         mov eax, dword [local_8h]\n|       |   0x0804870c      89442404       mov dword [local_4h], eax\n|       |   0x08048710      c70424308904.  mov dword [esp], str.good_job:__s ; [0x8048930:4]=0x6e656942 ; \"Good job ! You just pass the challenge with the pass : %s!\\n\"\n|       |   0x08048717      e87cfdffff     call sym.imp.printf         ; int printf(const char *format)\n|      ,==&lt; 0x0804871c      eb0c           jmp 0x804872a\n|      ||   ; CODE XREF from main (0x8048707)\n|      |`-&gt; 0x0804871e      c70424708904.  mov dword [esp], str.bad__password. ; [0x8048970:4]=0x6d6d6f44 ; \"Bad password.\"\n|      |    0x08048725      e89efdffff     call sym.imp.puts           ; int puts(const char *s)\n|      |    ; CODE XREF from main (0x804871c)\n|      `--&gt; 0x0804872a      b800000000     mov eax, 0\n|           0x0804872f      83c424         add esp, 0x24               ; '$'\n|           0x08048732      59             pop ecx\n|           0x08048733      5d             pop ebp\n|           0x08048734      8d61fc         lea esp, [ecx - 4]\n\\           0x08048737      c3             ret\n[0x0804869d]&gt; \n</code></pre>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "6k",
    "tags": [
        "binary-analysis",
        "decompilation",
        "radare2",
        "breakpoint"
    ],
    "user": null,
    "time": "Dec 24, 2018 at 13:41",
    "comments": [
        {
            "user": "sudhackar",
            "text": "<span class=\"comment-copy\">I think there are issues already open for this. Disable ESIL emulation and don't open in debug mode. Use <code>doo</code> in normal mode for <code>dc</code> to work</span>",
            "time": null
        },
        {
            "user": "user26834",
            "text": "<span class=\"comment-copy\">Ok, I executed the doo command and it works : radare2 ch1.bin <code>aaa s sym.main pdf ood db 0x08048705 dc</code> Now, radare2 show me this message : <code>hit breakpoint at: 8048705</code>. How can I print the two strings which are compared.</span>",
            "time": null
        },
        {
            "user": "sudhackar",
            "text": "<span class=\"comment-copy\">Can you share the binary?</span>",
            "time": null
        },
        {
            "user": "user26834",
            "text": "<span class=\"comment-copy\">Sure, this is the link of the challenge : <a href=\"https://www.root-me.org/fr/Challenges/Cracking/ELF-0-protection\" rel=\"nofollow noreferrer\">root-me.org/fr/Challenges/Cracking/ELF-0-protection</a></span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Here's how you do it with debugging.</p>\n<pre><code>$ r2 ch1.bin\n[0x080484f0]&gt; aaa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n[x] Analyze function calls (aac)\n[x] Analyze len bytes of instructions for references (aar)\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan)\n[x] Type matching analysis for all functions (afta)\n[x] Use -AA or aaaa to perform additional experimental analysis.\n[0x080484f0]&gt; doo\nProcess with PID 18337 started...\nFile dbg:///tmp/ch1.bin  reopened in read-write mode\n= attach 18337 18337\n18337\n[0xf7f6fc70]&gt; pdf @ sym.main ~strcmp\nâ”‚           0x08048700      e8d3fdffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)\n</code></pre>\n<p>Set a breakpoint at the <code>strcmp</code> call and continue execution.</p>\n<pre><code>[0xf7f6fc70]&gt; s 0x08048700\n[0x08048700]&gt; db 0x08048700\n[0x08048700]&gt; dc\n############################################################\n##        Bienvennue dans ce challenge de cracking        ##\n############################################################\n\nVeuillez entrer le mot de passe : test\nhit breakpoint at: 8048700\n</code></pre>\n<p>Use <code>pxr</code> to dump <code>esp</code> with flags and information about addresses.</p>\n<pre><code>[0x08048700]&gt; pxr@esp~:0..5\n0xfff45270  0x09075570  pU.. @esp eax (test)\n0xfff45274  0x08048841  A... (.rodata) (/tmp/ch1.bin) str.123456789 program R X 'xor dword [edx], esi' 'ch1.bin' (123456789)\n0xfff45278  0xfff452a8  .R.. stack R W 0x0 --&gt;  edi\n0xfff4527c  0x08048769  i... (.text) (/tmp/ch1.bin) sym.__libc_csu_init program R X 'lea eax, [ebx - 0xe8]' 'ch1.bin'\n0xfff45280  0x00000000  .... edi\n[0x08048700]&gt;\n</code></pre>\n<p>Stack top points to our input <code>test</code> passed as first param to <code>strcmp</code>. The next <code>dword</code> points to the second param at <code>0x08048841</code> string 123456789.</p>\n<p>Since <code>strcmp</code> is a library function you can use <code>ltrace</code> to do the same.</p>\n<pre><code>$ ltrace ./ch1.bin\n__libc_start_main(0x804869d, 1, 0xffbe8304, 0x8048750 &lt;unfinished ...&gt;\nputs(\"################################\"...############################################################\n)                                               = 61\nputs(\"##        Bienvennue dans ce cha\"...##        Bienvennue dans ce challenge de cracking        ##\n)                                               = 61\nputs(\"################################\"...############################################################\n\n)                                               = 62\nprintf(\"Veuillez entrer le mot de passe \"...)                                             = 34\nmalloc(2)                                                                                 = 0x9352570\ngetchar(2, 0, 0xffbe8258, 0xf7d792f6Veuillez entrer le mot de passe : test\n)                                                     = 116\nrealloc(0x9352570, 2)                                                                     = 0x9352570\ngetchar(0x9352570, 2, 0xffbe8258, 0xf7d792f6)                                             = 101\nrealloc(0x9352570, 3)                                                                     = 0x9352570\ngetchar(0x9352570, 3, 0xffbe8258, 0xf7d792f6)                                             = 115\nrealloc(0x9352570, 4)                                                                     = 0x9352570\ngetchar(0x9352570, 4, 0xffbe8258, 0xf7d792f6)                                             = 116\nrealloc(0x9352570, 5)                                                                     = 0x9352570\ngetchar(0x9352570, 5, 0xffbe8258, 0xf7d792f6)                                             = 10\nstrcmp(\"test\", \"123456789\")                                                               = 1\nputs(\"Dommage, essaye encore une fois.\"...Dommage, essaye encore une fois.\n)                                               = 33\n+++ exited (status 0) +++\n</code></pre>\n<p>TBF you don't need to debug it at all and just static analysis would do.</p>\n<pre><code>[0x080484f0]&gt; pdf @ sym.main~strcmp\nâ”‚           0x08048700      e8d3fdffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)\n[0x080484f0]&gt; s 0x08048700\n[0x08048700]&gt; pd-10\nâ”‚           0x080486d9      c704240c8904.  mov dword [esp], str.Veuillez_entrer_le_mot_de_passe_: ; [0x804890c:4]=0x69756556 ; \"Veuillez entrer le mot de passe : \" ; const char *format\nâ”‚           0x080486e0      e8b3fdffff     call sym.imp.printf         ; int printf(const char *format)\nâ”‚           0x080486e5      8b45f4         mov eax, dword [s1]\nâ”‚           0x080486e8      890424         mov dword [esp], eax\nâ”‚           0x080486eb      e80effffff     call sym.getString\nâ”‚           0x080486f0      8945f4         mov dword [s1], eax\nâ”‚           0x080486f3      8b45f8         mov eax, dword [local_8h]\nâ”‚           0x080486f6      89442404       mov dword [s2], eax         ; const char *s2\nâ”‚           0x080486fa      8b45f4         mov eax, dword [s1]\nâ”‚           0x080486fd      890424         mov dword [esp], eax        ; const char *s1\n[0x08048700]&gt;\n</code></pre>\n<p>Now we know the arguments to <code>strcmp</code> : <code>s1</code> and <code>local_8h</code>. <code>s1</code> was populated with a call to <code>sym.getString</code>, so thats probably our input and hence <code>local_8h</code> is the string we need to find to match.</p>\n<p>We'll see where it was used//modified (read/write) in the function. Use afv(R/W)</p>\n<pre><code>[0x08048700]&gt; afv?\nUsage: afv  [rbs]\n| afvr[?]                       manipulate register based arguments\n| afvb[?]                       manipulate bp based arguments/locals\n| afvs[?]                       manipulate sp based arguments/locals\n| afv*                          output r2 command to add args/locals to flagspace\n| afvR [varname]                list addresses where vars are accessed (READ)\n| afvW [varname]                list addresses where vars are accessed (WRITE)\n| afva                          analyze function arguments/locals\n| afvd name                     output r2 command for displaying the value of args/locals in the debugger\n| afvn [new_name] ([old_name])  rename argument/local\n| afvt [name] [new_type]        change type for given argument/local\n| afv-([name])                  remove all or given var\n</code></pre>\n<p>Use this on <code>local_8h</code></p>\n<pre><code>[0x08048700]&gt; afvR local_8h\n  local_8h  0x80486f3,0x8048709\n[0x08048700]&gt; afvW local_8h\n  local_8h  0x80486ae\n</code></pre>\n<p>At 0x80486ae it was written to or initialized.</p>\n<pre><code>[0x08048700]&gt; pd3 @ 0x80486ae \nâ”‚           0x080486ae      c745f8418804.  mov dword [local_8h], str.123456789 ; 0x8048841 ; \"123456789\"\nâ”‚           0x080486b5      c704244c8804.  mov dword [esp], str.       ; [0x804884c:4]=0x23232323 ; \"############################################################\" ; const char *s\nâ”‚           0x080486bc      e807feffff     call sym.imp.puts           ; int puts(const char *s)\n[0x08048700]&gt; \n</code></pre>\n<p>Here r2 resolved the address 0x8048841 to a string 123456789</p>\n</div>",
            "votes": "3",
            "user": "sudhackar",
            "time": "Dec 27, 2018 at 11:29",
            "is_accepted": true,
            "comments": []
        }
    ]
}