{
    "title": "Different disassembly for the same function?",
    "link": "https://reverseengineering.stackexchange.com/questions/11789/different-disassembly-for-the-same-function",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have this code:</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\nprintf(\"a=%d; b=%d; c=%d\", 1, 2, 3);\nreturn 0;\n};</code></pre>\n<p>I compile it with <code>gcc -g 3arg.cpp</code>. Disassemble with <code>objdump -d -M intel a.out</code>. In the output there is exactly one function named <code>_init</code> and it is disassembled like this:</p>\n<pre><code>00000000004003e0 &lt;_init&gt;:\n  4003e0:       48 83 ec 08             sub    rsp,0x8\n  4003e4:       48 8b 05 0d 0c 20 00    mov    rax,QWORD PTR [rip+0x200c0d]        # 600ff8 &lt;_DYNAMIC+0x1d0&gt;\n  4003eb:       48 85 c0                test   rax,rax\n  4003ee:       74 05                   je     4003f5 &lt;_init+0x15&gt;\n  4003f0:       e8 3b 00 00 00          call   400430 &lt;__gmon_start__@plt&gt;\n  4003f5:       48 83 c4 08             add    rsp,0x8\n  4003f9:       c3                      ret</code></pre>\n<p>This is <code>gdb</code> output:</p>\n<pre><code>$ gdb -q a.out\nReading symbols from a.out...done.\n(gdb) disassemble _init\nDump of assembler code for function _init:\n   0x00000000004003e0 &lt;+0&gt;:  sub    $0x8,%rsp\n   0x00000000004003e4 &lt;+4&gt;:  mov    0x200c0d(%rip),%rax        # 0x600ff8\n   0x00000000004003eb &lt;+11&gt;: test   %rax,%rax\n   0x00000000004003ee &lt;+14&gt;: je     0x4003f5 &lt;_init+21&gt;\n   0x00000000004003f0 &lt;+16&gt;: callq  0x400430 &lt;__gmon_start__@plt&gt;\n   0x00000000004003f5 &lt;+21&gt;: add    $0x8,%rsp\n   0x00000000004003f9 &lt;+25&gt;: retq   \nEnd of assembler dump.\n(gdb) break _init\nBreakpoint 1 at 0x4003e0\n(gdb) run\nStarting program: [redacted]/a.out \n\nBreakpoint 1, _init (argc=1, argv=0x7fffffffdf68, envp=0x7fffffffdf78) at ../csu/init-first.c:52\n52  ../csu/init-first.c: No such file or directory.\n(gdb) disassemble _init\nDump of assembler code for function _init:\n=&gt; 0x00007ffff7a36c20 &lt;+0&gt;:  push   %r13\n   0x00007ffff7a36c22 &lt;+2&gt;:  push   %r12\n   0x00007ffff7a36c24 &lt;+4&gt;:  mov    %edi,%r12d\n   0x00007ffff7a36c27 &lt;+7&gt;:  push   %rbp\n   0x00007ffff7a36c28 &lt;+8&gt;:  mov    %rsi,%rbp\n   0x00007ffff7a36c2b &lt;+11&gt;: push   %rbx\n[etc.]</code></pre>\n<p>Why is the last disassembly different? It's not even the same data disassembled in a different way (As seen when comparing the <code>objdump</code> output with output of <code>gdb</code> command <code>x/10b $rip</code> when the breakpoint has been hit). If it's a different <code>_init</code> function: </p>\n<ul>\n<li>how can I put a breakpoint at the one that's seen in the <code>objdump</code> output and the first disassembly in <code>gdb</code>?</li>\n<li>why did <code>gdb</code> say Breakpoint 1 was at <code>0x4003e0</code> and then stopped at a different function?</li>\n</ul>\n</div>",
    "votes": "4",
    "answers": 1,
    "views": "1k",
    "tags": [
        "disassembly",
        "gdb",
        "objdump"
    ],
    "user": "user14742",
    "time": "Jan 23, 2017 at 10:34",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>To arrive to your <code>_init</code> function just continue execution. This will stop once again in the intended place.</p>\n<pre><code>    gdb -q test.out\n    Reading symbols from test.out...done.\n    (gdb) b _init\n    Breakpoint 1 at 0x4003e0\n    (gdb) run\n    Starting program: /home/[censored]/stk/test.out \n\n    Breakpoint 1, _init (argc=1, argv=0x7fffffffe008, envp=0x7fffffffe018) at ../csu/init-first.c:52\n    52  ../csu/init-first.c: No such file or directory.\n    (gdb) bt\n    #0  _init (argc=1, argv=0x7fffffffe008, envp=0x7fffffffe018) at ../csu/init-first.c:52\n    #1  0x00007ffff7dea0fd in call_init (l=0x7ffff7ff74c0, argc=argc@entry=1, argv=argv@entry=0x7fffffffe008, env=env@entry=0x7fffffffe018) at dl-init.c:64\n    #2  0x00007ffff7dea223 in call_init (env=&lt;optimized out&gt;, argv=&lt;optimized out&gt;, argc=&lt;optimized out&gt;, l=&lt;optimized out&gt;) at dl-init.c:36\n    #3  _dl_init (main_map=0x7ffff7ffe1c8, argc=1, argv=0x7fffffffe008, env=0x7fffffffe018) at dl-init.c:126\n    #4  0x00007ffff7ddb30a in _dl_start_user () from /lib64/ld-linux-x86-64.so.2\n    #5  0x0000000000000001 in ?? ()\n    #6  0x00007fffffffe364 in ?? ()\n    #7  0x0000000000000000 in ?? ()\n    (gdb) c\n    Continuing.\n\n    Breakpoint 1, 0x00000000004003e0 in _init ()\n    (gdb) bt\n    #0  0x00000000004003e0 in _init ()\n    #1  0x0000000000400593 in __libc_csu_init ()\n    #2  0x00007ffff7a36e55 in __libc_start_main (main=0x40052d &lt;main&gt;, argc=1, argv=0x7fffffffe008, init=0x400560 &lt;__libc_csu_init&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdff8)\n        at libc-start.c:246\n    #3  0x0000000000400469 in _start ()\n    (gdb) info shared\n    From                To                  Syms Read   Shared Object Library\n    0x00007ffff7ddaae0  0x00007ffff7df54e0  Yes         /lib64/ld-linux-x86-64.so.2\n    0x00007ffff7a344a0  0x00007ffff7b79583  Yes         /lib/x86_64-linux-gnu/libc.so.6\n    (gdb) x/10i $pc\n=&gt; 0x4003e0 &lt;_init&gt;:    sub    $0x8,%rsp\n   0x4003e4 &lt;_init+4&gt;:  mov    0x200c0d(%rip),%rax        # 0x600ff8\n   0x4003eb &lt;_init+11&gt;: test   %rax,%rax\n   0x4003ee &lt;_init+14&gt;: je     0x4003f5 &lt;_init+21&gt;\n   0x4003f0 &lt;_init+16&gt;: callq  0x400430 &lt;__gmon_start__@plt&gt;\n   0x4003f5 &lt;_init+21&gt;: add    $0x8,%rsp\n   0x4003f9 &lt;_init+25&gt;: retq \n(gdb) info breakpoints\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   &lt;MULTIPLE&gt;         \n    breakpoint already hit 2 times\n1.1                         y     0x00000000004003e0 &lt;_init&gt;\n1.2                         y     0x00007ffff7a36c20 in _init at ../csu/init-first.c:52\n</code></pre>\n<p>According to information about shared libraries, it stopped first time in address area of <code>libc.so</code>, which looks like also has <code>_init</code> function, which caused <code>gdb</code> to set this breakpoint there too (see breakpoint definition at the end of the listing).</p>\n<p>If you want to set a breakpoint in your specific address, you can use</p>\n<pre><code> b *address\n</code></pre>\n<p>notation. If you want to set a breakpoint on a specific function from specific source file you can use something like </p>\n<pre><code>(gdb) break test.c:call1\n</code></pre>\n<p>The same thing is discussed a bit deeper <a href=\"https://stackoverflow.com/questions/31379422/why-is-init-from-glibcs-csu-init-first-c-called-before-start-even-if-start-i\">here</a> .</p>\n<p>Good luck.</p>\n</div>",
            "votes": "10",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": []
        }
    ]
}