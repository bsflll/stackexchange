{
    "title": "How to handle flags that affect instruction decoding in IDA processor modules?",
    "link": "https://reverseengineering.stackexchange.com/questions/22423/how-to-handle-flags-that-affect-instruction-decoding-in-ida-processor-modules",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am writing a processor module for the Oki6620* architecture. Like ARM's Thumb mode or m7700's M flag, this architecture has a special flag that affects instruction decoding, named DD (Data Descriptor). </p>\n<p>For a POC, I have a global flag to my IDA processor definition, and change the DD flag depending on the instruction analysed. However, due to IDA's multithreading when analysing/decoding instructions (notify_ana/notify_emu/etc), this clearly doesn't work well.</p>\n<p>Even worse, when clicking around in IDA on random instructions, said instructions sometimes get changed randomly because the current DD flag's value is different from when the instruction was first analysed.</p>\n<p>My two main questions are:</p>\n<ul>\n<li>m7700 and ARM both have an <strong>option to set the flag from the interface</strong> (Alt+G, if I'm not mistaken), and I'm looking for a way to implement this in my module too. Does anybody know how to do that ?</li>\n<li>Also, I'd be interested in input on <strong>how one would handle correctly this DD flag depending on the thread actually running</strong> (keep DD values in an array, for each block of code between two DD-value-changing instruction ? things like that)</li>\n</ul>\n<p><a href=\"https://mycomputerninja.com/~jon/www.pgmfi.org/twiki/pub/Library/66kAssemblerDocs/Oki_66201_Instruction_Manual.pdf\" rel=\"nofollow noreferrer\">Here is a PDF</a> explaining the ISA and processor info. My current code (draft of course) is available on <a href=\"https://github.com/P1kachu/oki-66207-processor\" rel=\"nofollow noreferrer\">github</a>.</p>\n<p>Thank you very much in advance.</p>\n</div>",
    "votes": "3",
    "answers": 1,
    "views": "330",
    "tags": [
        "ida"
    ],
    "user": "P1kachu",
    "time": "Oct 30, 2019 at 4:35",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>First of all, IDA kernel can perform an instruction emulation step in any order (usually consecutive, that's why sometimes you are getting the results that you expect) in accordance with their SDK documentation:</p>\n<blockquote>\n<p>The second step, the emulation, is called for each instruction.<br/>\nThis step must make necessary changes to the database,   plan analysis\nof subsequent instructions, track register   values, memory contents,\netc. Please keep in mind that the kernel may call   the emulation step\nfor any address in the program - there is no   ordering of addresses.\nUsually, the emulation is called   for consecutive addresses but this\nis not guaranteed.</p>\n</blockquote>\n<p>Overall, I see a number of issues with your code, that prevent it from operating correctly. I won't be digging deep in each one of them, just provide a quick overview and some hints:</p>\n<ol>\n<li>You are trying to store the data about the flags in your own global variables. This is wrong, since IDA is completely unaware of it. Therefore, you should utilize IDAs structures for that.</li>\n</ol>\n<p>For example, the DD flag that you are talking about affects just the size of the operands, utilized in the specific instruction. Therefore, this information should be stored in the <code>insn_t</code> object. The closest example would be arc processor module (it is written in C, but it is really easy to understand) from the official IDA SDK, specifically, this part:</p>\n<pre><code>// fix operand size for byte or word loads/stores\ninline void fix_ldst(insn_t &amp;insn)\n{\n  if ( insn.itype == ARC_ld || insn.itype == ARC_st )\n  {\n    switch ( insn.auxpref &amp; aux_zmask )\n    {\n      case aux_b:\n        insn.Op2.dtype = dt_byte;\n        break;\n      case aux_w:\n        insn.Op2.dtype = dt_word;\n        break;\n    }\n  }\n}\n</code></pre>\n<p>The information about the flags is stored in <code>insn.auxpref</code> in this case. You can work your way from there, looking further into the implementation of flag set/clear routines in the same module.</p>\n<hr/>\n<ol start=\"2\">\n<li>You've defined dozens and dozens of the same instructions in <code>INSN_DEFS</code>. Even after processing in <code>init_instructions</code> you would end up with duplicate entries. Take a look, for example, on <code>add</code> instruction. The only difference is actually operands and their sizes. You should've defined just one add instruction with 2 arbitrary operands, for example, like that:</li>\n</ol>\n<p><code>{\"add\", CF_CHG1|CF_USE2}</code></p>\n<p>All the further processing (number of operands, their values, DD flag, etc.) should be performed in <code>ana</code> and <code>emu</code> modules.</p>\n<p>So, you should introduce quite a lot of code changes in order for this processor module to become operational.</p>\n</div>",
            "votes": "1",
            "user": "none32",
            "time": "Mar 5, 2023 at 12:49",
            "is_accepted": false,
            "comments": []
        }
    ]
}