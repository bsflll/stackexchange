{
    "title": "How to debug using OpenWatcom's debugger?",
    "link": "https://reverseengineering.stackexchange.com/questions/2185/how-to-debug-using-openwatcoms-debugger",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><a href=\"http://www.openwatcom.org\" rel=\"nofollow\">OpenWatcom's</a> debugger just executes the binary instead of single-stepping through it, when I attempt the following steps:</p>\n<ol>\n<li><code>File-&gt;Open</code>, select executable</li>\n<li><code>Run-&gt;Trace Into</code></li>\n</ol>\n<p>This attempt <a href=\"http://chat.stackexchange.com/transcript/message/9732918#9732918\">is on Windows XP</a>.</p>\n<p>How do I single step through a program using OpenWatcom's debugger?</p>\n</div>",
    "votes": "3",
    "answers": 1,
    "views": "2k",
    "tags": [
        "windows",
        "debuggers"
    ],
    "user": "heinrich5991",
    "time": "Jun 12, 2013 at 7:18",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Okay, Windows XP, OpenWatcom. I am using OpenWatcom 1.9. When trying to reproduce your problem, I used <code>calc.exe</code> from Windows XP for which there are no Watcom debug symbols available (only the PDB format from Microsoft, which Watcom doesn't support <em>at all</em>).</p>\n<p>When dismissing the open dialog from your first step, we get the assembly view like this. I am returning from that call (<code>Run -&gt; Until Return</code>) a few times and realize that the call stack shows I am still in the loader phase.</p>\n<p><img alt=\"enter image description here\" src=\"https://i.sstatic.net/LjloV.png\"/></p>\n<p>The most logical thing to do now would be to break at either <code>kernel32!BaseThreadInitThunk</code> which is basically <em>the</em> entry point for any Win32 thread, including the very first in a process, but isn't exported (and, remember, we have no symbols). For a writeup on the startup process, see <a href=\"http://abdelrahmanogail.wordpress.com/2010/11/05/thread-basics/\" rel=\"nofollow noreferrer\">here</a> or the \"Windows Internals\" book. The next possible candidate would be <code>ntdll!RtlUserThreadStart</code> which also isn't exported and therefore unavailable.</p>\n<p>So, assuming you really have no modern debugger (WinDbg, cdb, let alone IDA, Hopper and friends) available, and don't want to use <a href=\"http://live.sysinternals.com/livekd.exe\" rel=\"nofollow noreferrer\"><code>livekd.exe</code> from SysInternals</a> (which however requires a recent <code>dbghelp.dll</code>) the only method that seems to be reasonable is to load your target executable into an editor (<a href=\"http://www.ntcore.com/exsuite.php\" rel=\"nofollow noreferrer\">CFF Explorer comes to mind</a>) and put an <code>int3</code> (<code>cc</code>) instruction at the entry point or simply move the entry point elsewhere. In my case I chose to overwrite the <code>push 70h</code> (<code>6A 70</code>) with <code>int3; nop</code> (<code>CC 90</code>). That enabled me to break at the beginning of the program (not considering TLS callbacks or anything like that, though).</p>\n<p>Another less intrusive method is to use the above mentioned CFF Explorer or really any suitable tool to give you the VA of the entry point. Since we're talking about Windows XP we need not worry about ASLR or anything like that. </p>\n<p><img alt=\"enter image description here\" src=\"https://i.sstatic.net/Z8YPK.png\"/></p>\n<p>The entry point in our case is at RVA <code>0x12475</code>, which the Address Converter translates to:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.sstatic.net/Henkx.png\"/></p>\n<p>VA <code>0x1012475</code>. Sweet. Now we can try to let OpenWatcom stop at this address. Setting a bpx at this address (<code>Break -&gt; View All -&gt; Rightclick -&gt; New</code>, enter address) and then pressing <kbd>F5</kbd> (for \"Go\") to skip the startup phase for the process gets us straight to the entry point.</p>\n<p><img alt=\"enter image description here\" src=\"https://i.sstatic.net/ZFfzH.png\"/></p>\n<p>From there we can use <kbd>F8</kbd> for further single-stepping. And I'm sure similar to the experience we shared during the startup phase, any little thing that changed since the debugger was last adjusted to a more recent OS will trip you (or rather the OW debugger) up. Short of switching debuggers, you might want to make heavy use of <code>Break -&gt; On Debug Message</code>, but even that seemed of little use when I tried it.</p>\n<h1>Conclusion</h1>\n<p>It's possible, but heck it's tedious and it may fall short of your needs at any point.</p>\n<p>Quite frankly, some debuggers are better left alone when no source is available (assembly debugging). Admittedly I am not as familiar with the Watcom debugger as with GDB or WinDbg, but I've used it in the past and found it pure horror <em>with</em> symbols. That impression will likely only get worse <em>without</em> symbols. I find myself confirmed in that sense from looking into the issue you were experiencing.</p>\n<h2>20th century debugging</h2>\n<p>OpenWatcom, while still being \"developed\" is old. Its roots are in the old Sybase product Watcom, which had a broad following. Problem is, that this product existed even before Windows 2000. So I don't think you can expect a lot from it, as most people these days are using compilers and debuggers with better support. Be it WinDbg or be it GDB if you happen to use MinGW or something like that.</p>\n</div>",
            "votes": "5",
            "user": "0xC0000022L",
            "time": "Jun 4, 2013 at 1:58",
            "is_accepted": true,
            "comments": []
        }
    ]
}