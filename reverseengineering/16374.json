{
    "title": "Kernel debug - internet explorer in kernelmode?",
    "link": "https://reverseengineering.stackexchange.com/questions/16374/kernel-debug-internet-explorer-in-kernelmode",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>My setup: Windows 10 with <code>windbg</code> and target machine is Windows 7 N SP1. I'm debugging via com (i know it's slow ;).</p>\n<p>So I get the process list with <code>!process</code>, one active process is Internet Explorer: </p>\n<pre><code>kd&gt;!process 0 0\n\n&gt;PROCESS fffffa8001a3db30\n&gt;SessionId: 2  Cid: 07e0    Peb: 7efdf000  ParentCid: 0a90\n&gt;DirBase: 2cc0a000  ObjectTable: fffff8a002007620  HandleCount: 561.\n&gt;\n&gt;Image: iexplore.exe\n</code></pre>\n<p>After that, I want to see in which mode the process is running. So I looked at the content of the PDE at the U/S flags. </p>\n<pre><code>kd&gt; !pte FFFFF6FB7EA00068\n                                       VA fffff6fd4000d000\n&gt;PXE at FFFFF6FB7DBEDFA8    PPE at FFFFF6FB7DBF5000    PDE at FFFFF6FB7EA00068    PTE at FFFFF6FD4000D4D0\n&gt;contains 0000000004000863  contains 0000000004001863  contains 000000007FC009E3  contains 0000000000000000\n&gt;pfn 4000      ---DA--KWEV  pfn 4001      ---DA--KWEV  **pfn 7fc00     -GLDA--*K*WEV**  LARGE PAGE pfn 7fc9a\n</code></pre>\n<p>The usermode/kernelmode flag is set to K. That says, that iexplorer.exe is running in kernelmode. Why? I thought those aplications are running in usermode.</p>\n</div>",
    "votes": "4",
    "answers": 2,
    "views": "653",
    "tags": [
        "windows",
        "debugging",
        "windbg",
        "kernel-mode",
        "kernel"
    ],
    "user": "Joschi",
    "time": "Feb 28, 2018 at 12:50",
    "comments": [
        {
            "user": "Lieven Keersmaekers",
            "text": "<span class=\"comment-copy\">You are mixing up things. 99% of threads of every usermode process eventually transitions into kernel mode for file i/o, sockets, memory management and whatnot. Note that the transition of a thread's call stack from user to kernelmode is a well defined (security) boundary. You can't call any kernelmode functions directly.</span>",
            "time": null
        },
        {
            "user": "Igor Skochinsky",
            "text": "<span class=\"comment-copy\">@LievenKeersmaekers please try to avoid posting answers in comments, it's better to post an actual answer.</span>",
            "time": null
        },
        {
            "user": "Lieven Keersmaekers",
            "text": "<span class=\"comment-copy\">@IgorSkochinsky - impov, it's not fleshed out enough to serve as an answer and I don't have enough expertise on the subject to write a complete answer but I'll definitely take note!</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>What you have listed in your question isn't going to tell you what mode a process is executing in, and there's a couple things wrong with the thought process.</p>\n<p>The <a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-pte\" rel=\"nofollow noreferrer\">help docs</a> for <code>!pte</code> specify that the command takes a Virtual Address and displays PTE and PDE information about that address. The output of this command is kind of unintuitive because in actuality the PTE/PDE entries are physical addresses but Windows also maps them to kernel Virtual Kernel addresses as well.</p>\n<p>In your output specifically the virtual address that you're analyzing  is <code>VA fffff6fd4000d000</code>. What the output is showing is that the PXE entry for this Virtual Address is at the <strong>physical</strong> address 4000000 (this is given by the <code>pfn</code> entry and the lower portion is masked off for flags and etc), and is mapped at the <strong>virtual</strong> address <code>FFFFF6FB7DBEDFA8</code>.</p>\n<p>So then the next part is why does the output show that the pages are kernel mode. Based on what you're doing the address you got from !address is <code>fffffa8001a3db30</code>. Without going into too much detail about the internals of the kernel this address is the virtual address for an <code>EPROCESS</code> object which is a kernel data structure used to manage processes on the system. Additionally, every object the kernel allocates has a header prepended to it that the system uses for reference counting and and some other management functionality.</p>\n<p>You can see this header structure in windbg using the dt command: <code>dt _OBJECT_HEADER</code> and on x64 you'll notice that this structure is 0x30 bytes big. So the address of the actual EPROCESS is <code>fffffa8001a3db30</code> but the base of the allocation includes the header which is <code>fffffa8001a3db00</code>.</p>\n<p>So basically what you're doing when you run that <code>!pte</code> command is analyzing the page table entries for the kernel <strong>EPROCESS object</strong> but as I said in the last paragraph this is only a structure that the kernel allocates and uses to manage resources for the system, so this address is <strong>always</strong> going to be a kernel mode address.</p>\n<p>To do what you actually want to do you want to use the following commands:</p>\n<ul>\n<li><code>.process /p /r &lt;iexplore.exe address from !process&gt;</code> - this puts you\nin the process context of internet explorer, which basically means\nall the usermode stuff (virtual memory and handles) that windbg\naccesses are valid for that process </li>\n<li><code>!dml_proc &lt;iexplorer address\nfrom !process&gt;</code> or <code>!process &lt;iexploer address from !process</code> - this\ngives you information about the threads that are running in that\nprocess  </li>\n<li>From there if you use !dml_proc you can click the links to\nget thread stacks, or !process will just dump all threads out for you</li>\n</ul>\n<p>Now, if you follow the above you'll get the stack trace for each thread. From there you can see where it's executing based on what module it's in. In particular, if you see <code>nt!KiSystemServiceCopyEnd</code> on the callstack that means that the thread has transitioned into kernel mode and is doing something.</p>\n<p>However that being said I'm still not sure what you want to achieve since as one of the comments on your post mentions all threads are going to transition to kernel mode all the time anyway because basically everything that happens on your system happens in kernel mode.</p>\n</div>",
            "votes": "1",
            "user": "Fewmitz",
            "time": "Mar 1, 2018 at 4:20",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>On the pte command you use an address from where did you get that address <strong>FFFFF6FB7EA00068</strong>   &lt;&lt;&lt;&lt;&lt;</p>\n<p>If it is a virtual address does it truly belong to the active process context ?</p>\n<p>are you in the process context of iexplore.exe ??<br/>\n<code>(did you do .process /p /r EPROC_ADDR )</code></p>\n<p>just doing .process /p /r changes only the display in windbg and the actual underlying process may not be equal to the current process context   </p>\n<p>did you check if the process contexts <strong>DirectoryTableBase (DirBase)</strong>  and register <strong>cr3</strong> matches or not ??   </p>\n<p>if they don't match you might be looking at some spurious address that belongs to some other process context which might have the same virtual address    </p>\n<p>if it didnt match you may need to do <strong>.process /i</strong> and execute the target with <strong>g or f5</strong> </p>\n<p>this makes windbg debug the underlying process invasively and when it rebreaks<br/>\nafter a few seconds the process you are interested in (iexplore.exe in your case)<br/>\nwill be set as active process context and page table entries are decoded with    respect to active process context<br/>\n<strong>( register cr3 and   @$proc-&gt;Pcb.DirectoryTableBase will match and show same DirBase)</strong></p>\n<p>only when you are truly sure you have an active  process context your question might make a reproducible query </p>\n<p>a sample </p>\n<p>target and host both are win7 sp1 32 bits (target is a vm)<br/>\nwindbg version is latest rtm as on the day of posting </p>\n<pre><code>Microsoft (R) Windows Debugger Version 10.0.16299.15 X86\n</code></pre>\n<p>target broken into windbg using ctrl+break</p>\n<pre><code>checking current cr3\nkd&gt; r cr3\ncr3=00185000\n</code></pre>\n<p>checking for iexplore.exe process instance</p>\n<pre><code>kd&gt; !process 0 0 iexplore.exe\nPROCESS 841f3c08  SessionId: 1  Cid: 059c    Peb: 7ffdf000  ParentCid: 0774\n    DirBase: 096de000  ObjectTable: 92aed4d0  HandleCount: 419.\n    Image: iexplore.exe\n\nPROCESS 841ce5d8  SessionId: 1  Cid: 0784    Peb: 7ffdf000  ParentCid: 059c\n    DirBase: 0db73000  ObjectTable: 8b221ba0  HandleCount: 350.\n    Image: iexplore.exe\n</code></pre>\n<p>command to see if iexplore module is available </p>\n<pre><code>kd&gt; lm m iexp*\nBrowse full module list\nstart    end        module name\n\nUnable to enumerate user-mode unloaded modules, Win32 error 0n30\n</code></pre>\n<p>no windbg is  not in the correct process context<br/>\nlets ask it to get into correct process context<br/>\nkeep in mind this is a display and not the targets state<br/>\nsee .cache (windbg refreshes the display from its cached<br/>\ndata)</p>\n<p>you can notice module iexplore.exe is now available for inspection   </p>\n<pre><code>kd&gt; .process /p /r 841ce5d8\nImplicit process is now 841ce5d8\n.cache forcedecodeuser done\nLoading User Symbols\n\nkd&gt; lm m iexp*\nBrowse full module list\nstart    end        module name\n00af0000 00b96000   iexplore   (deferred)             \nkd&gt; x iexplore!wWinMain\n00af12a3          iexplore!wWinMain (&lt;no parameter info&gt;)\n</code></pre>\n<p>but the !pte for a virtual address in this<br/>\ncached process context space is invalid  because we are not in<br/>\nactive process context ( register cr3 and DirBase dont match)<br/>\nto get into active process context windbg should<br/>\nbe debugging the targets process invasively<br/>\nwhich is possible only if we do a .process /i     </p>\n<pre><code>kd&gt; !pte iexplore!wWinMain\n                 VA 00af12a3\nPDE at C0300008         PTE at C0002BC4\ncontains 00000000\nnot valid\n\n\nkd&gt; r cr3\ncr3=00185000\n\nkd&gt; ?? @$proc-&gt;Pcb.DirectoryTableBase\nunsigned long 0xdb73000\n</code></pre>\n<p>lets ask windbg to invasively debug iexplore.exe and<br/>\nbreak when the process context is active   </p>\n<pre><code>kd&gt; .process /i /p /r /P 841ce5d8\nYou need to continue execution (press 'g' &lt;enter&gt;) for the context\nto be switched. When the debugger breaks in again, you will be in\nthe new process context.\nkd&gt; g\nBreak instruction exception - code 80000003 (first chance)\nnt!RtlpBreakWithStatusInstruction:\n8289dd00 cc              int     3\n</code></pre>\n<p>now you can see both the register context and Dirbase matches</p>\n<pre><code>kd&gt; r cr3\ncr3=0db73000\n\nkd&gt; ?? @$proc-&gt;Pcb.DirectoryTableBase\nunsigned long 0xdb73000\n\nkd&gt; !pte iexplore!wWinMain\n                 VA 00af12a3\nPDE at C0300008         PTE at C0002BC4\ncontains 0DD71867       contains 07B5F005\npfn dd71  ---DA--UWEV   pfn 7b5f  -------UREV\n\npte enties are valid now \n</code></pre>\n<p>you can further match va to physical page contents as below</p>\n<pre><code>kd&gt; !pte iexplore!wWinMain\n                 VA 00af12a3\nPDE at C0300008         PTE at C0002BC4\ncontains 0DD71867       contains 07B5F005\npfn dd71  ---DA--UWEV   pfn 7b5f  -------UREV\n\nkd&gt; db iexplore!wWinMain l 20\n00af12a3  8b ff 55 8b ec 81 ec 30-01 00 00 a1 50 c0 af 00  ..U....0....P...\n00af12b3  33 c5 89 45 fc 53 56 57-be 88 c5 af 00 56 e8 cb  3..E.SVW.....V..\n\n\nkd&gt; $$ from the !pte above we know pfn is at 7b5f \nkd&gt; $$ we can confirm if this is the right physical page with either \nkd&gt; $$ !vtop 0 va or simply adding the last 3 bytes of our va to the pfn \nkd&gt; $$and dump the physical page \n</code></pre>\n<p>dump of physical address contents </p>\n<pre><code>kd&gt; !db 7b5f2a3 l20\n# 7b5f2a3 8b ff 55 8b ec 81 ec 30-01 00 00 a1 50 c0 af 00 ..U....0....P...\n# 7b5f2b3 33 c5 89 45 fc 53 56 57-be 88 c5 af 00 56 e8 cb 3..E.SVW.....V..\n</code></pre>\n<p>as seen virtual address content and physical page contents match<br/>\nbut lets look for a string that might be unique and reconfirm</p>\n<pre><code>kd&gt; s -a iexplore!wWinMain L?100000 \"Internet Explorer_Server\"\n00bb7df8  49 6e 74 65 72 6e 65 74-20 45 78 70 6c 6f 72 65  Internet Explore\nkd&gt; da /c 100 bb7df8\n00bb7df8  \"Internet Explorer_Server\"\n\nkd&gt; !pte bb7df8\n                 VA 00bb7df8\nPDE at C0300008         PTE at C0002EDC\ncontains 0DD71867       contains 0D7B1025\npfn dd71  ---DA--UWEV   pfn d7b1  ----A--UREV\n\nkd&gt; !db d7b1df8 l 20\n# d7b1df8 49 6e 74 65 72 6e 65 74-20 45 78 70 6c 6f 72 65 Internet Explore\n# d7b1e08 72 5f 53 65 72 76 65 72-00 00 00 00 00 00 00 00 r_Server........\n\nkd&gt; !vtop 0 bb7df8\nX86VtoP: Virt 0000000000bb7df8, pagedir 000000000db73000\nX86VtoP: PDE 000000000db73008 - 0dd71867\nX86VtoP: PTE 000000000dd71edc - 0d7b1025\nX86VtoP: Mapped phys 000000000d7b1df8\nVirtual address bb7df8 translates to physical address d7b1df8.\n</code></pre>\n</div>",
            "votes": "2",
            "user": "blabb",
            "time": "Mar 1, 2018 at 4:41",
            "is_accepted": false,
            "comments": []
        }
    ]
}