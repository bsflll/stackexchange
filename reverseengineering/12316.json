{
    "title": "Fixing corrupt ELF header field \"e_shnum\" for use in GDB",
    "link": "https://reverseengineering.stackexchange.com/questions/12316/fixing-corrupt-elf-header-field-e-shnum-for-use-in-gdb",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>If the ELF header which usually can be read using <code>readelf</code> has been manually manipulated, let's say by increasing the value for the \"Size of section headers\" the binary still can be executed and works well.</p>\n<p>However, this manipulation seems to trip up reverse engineering tools like GDC and GDB gives me the error: <code>not in executable format: File format not recognized</code>.</p>\n<p>Is there a way to fix the ELF header without knowing the original value of \"Size of section headers\" in order to be able again to analyze the file using <em>standard tools</em>?</p>\n<h1>Detailed info:</h1>\n<p>GDB is failing to run the binary because it says the file is <code>not in executable format : File format not recognized</code> but it works outside the GDB. The same things happen with the <code>libbfd</code> parser, it can't parse because file format is not recognized. The fact is I only change the number of section headers.</p>\n<h2>Code</h2>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(\"Hello World!\\n\");\n    return 0;\n}\n</code></pre>\n<p>Build by invoking <code>make hello</code> or on a 64-bit system <code>make CFLAGS=-m32 hello</code>.</p>\n<h2>ELF header before</h2>\n<pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x8048320\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          4472 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         30 &lt;-- notice me!\n  Section header string table index: 27\n</code></pre>\n<h2>ELF header after</h2>\n<pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x8048320\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          4472 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         52 &lt;-- already changed!\n  Section header string table index: 27\n</code></pre>\n<p>GDB will output,</p>\n<blockquote>\n<p>not in executable format: File format not recognized</p>\n</blockquote>\n<p>But if I run it outside of GDB,</p>\n<pre><code>$ ./hello output:\nHello World!\n</code></pre>\n<p>So is there either a method to fix the value for <code>e_shnum</code> <strong>without</strong> knowing the correct value, or a workaround so I can debug this file in GDB?</p>\n</div>",
    "votes": "7",
    "answers": 2,
    "views": "14k",
    "tags": [
        "gdb",
        "elf",
        "crackme"
    ],
    "user": "Fakhri Zulkifli",
    "time": "Nov 21, 2018 at 1:01",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>In this particular case, repairing the header can be automated. Since the section header string table is present, the original value of <code>e_shnum</code> can be found by counting the number of strings in the table.</p>\n<p>Original:</p>\n<pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x3e0\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          6056 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         29  &lt;-----------------\n  Section header string table index: 28\n</code></pre>\n<p>Corrupted:</p>\n<pre><code>$ readelf -h hello\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x3e0\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          6056 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         9\n  Size of section headers:           40 (bytes)\n  Number of section headers:         52  &lt;------------------\n  Section header string table index: 28\nreadelf: Error: Reading 2080 bytes extends past end of file for section headers\nreadelf: Error: Reading 7216 bytes extends past end of file for dynamic string table\n</code></pre>\n<p>Reading the section header string table:</p>\n<blockquote>\n<pre><code>#!/usr/bin/python3\n\nfrom elftools.elf.elffile import ELFFile\n\nwith open('hello', 'rb') as f:\n    elffile = ELFFile(f)\n    print(\"original e_shnum:\\t\" + str(len(elffile.get_section(28).data().decode('ascii').split('\\x00')) + 1))\n</code></pre>\n</blockquote>\n<p>When run against the binary with the corrupted header, the output is as follows:</p>\n<pre><code>$ python3 recover_e_shnum.py \noriginal e_shnum:   29\n</code></pre>\n<p>This script will repair the header automatically:</p>\n<blockquote>\n<pre><code>#!/usr/bin/python3\n\nfrom elftools.elf.elffile import ELFFile\nfrom struct import pack\n\nwith open('hello', 'rb+') as f:\n    elffile = ELFFile(f)\n    e_shnum = len(elffile.get_section(28).data().decode('ascii').split('\\x00')) + 1 \n    f.seek(48)\n    f.write(pack('h', e_shnum))\n</code></pre>\n</blockquote>\n</div>",
            "votes": "3",
            "user": "julian",
            "time": "Jan 1, 2020 at 2:54",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I recreated your binary and then used Radare to <a href=\"https://reverseengineering.stackexchange.com/a/19924/22669\">corrupt the header exactly as you did</a>, changing the number of section headers to 52.</p>\n<pre><code>r2 -w a.out -1c's 0; pfo elf64; .pf.elf_header.shnum=52'\n</code></pre>\n<p>This only generated a warning with subsequent invocations of <code>readelf</code>.</p>\n<pre><code>$ readelf -h a.out \nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x1050\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          14624 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         11\n  Size of section headers:           64 (bytes)\n  Number of section headers:         52\n  Section header string table index: 28\nreadelf: Error: Reading 3328 bytes extends past end of file for section headers\n</code></pre>\n<p>But I got the similar error from GDB,</p>\n<blockquote>\n<p>not in executable format: file truncated</p>\n</blockquote>\n<p>And, if I try to debug that file, I get</p>\n<blockquote>\n<p>No executable file specified.</p>\n</blockquote>\n<p>I could go back to the original easily with</p>\n<pre><code>r2 -w a.out -c's 0; pfo elf64; .pf.elf_header.shnum=52'\n</code></pre>\n<p>However to answer your question about tooling,</p>\n<ul>\n<li>Radare works with it even if the header is set to 52. You can still debug it.</li>\n<li><p>You can get gdb to work if the header is less than the original <code>shnum</code>, for instance setting it to <code>1</code> will only warn you,</p>\n<blockquote>\n<p>BFD: warning: /tmp/a.out has a corrupt string table index - ignoring</p>\n</blockquote>\n<p>but you can still debug the program.</p></li>\n</ul>\n</div>",
            "votes": "2",
            "user": "Evan Carroll",
            "time": "Nov 20, 2018 at 22:59",
            "is_accepted": false,
            "comments": []
        }
    ]
}