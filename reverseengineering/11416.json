{
    "title": "Unrecognized procedures in IDA Pro",
    "link": "https://reverseengineering.stackexchange.com/questions/11416/unrecognized-procedures-in-ida-pro",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>for hobby I'm just trying to reverse and old DOS game executable.</p>\n<p>I'm quite new with reversing so I'm having hard time understanding some bits about IDA Pro. I let the program choose the best-fit strategy to disassemble the executable and it seems to work fine but some procedures are left unrecognized (marked in red) as in the picture:</p>\n<p><a href=\"https://i.sstatic.net/ksgSR.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/ksgSR.png\"/></a></p>\n<p>Now I see that I can explicitly mark this as a function but then I'm not able to find any xref to it (also because I guess IDA would already have turned them into procedures if it was the case).</p>\n<p>So I was wondering what is the exact purpose of these functions, are they called by dynamically generating the address to them or what? Like a <code>CALL</code> instruction to the content of a register.</p>\n<p>A side question: I see that the binary had been split into 4 segments category:</p>\n<ul>\n<li>code (clear intent)</li>\n<li>data (clear intent)</li>\n<li>stub</li>\n<li>overlay</li>\n</ul>\n<p>While the first two, coming from a C/C++ environment are quite clear I'm trying to understand exactly what the other two are.</p>\n<p>If I understood it correctly stub segments are just bridges to procedures which are far from the current executing segment, while overlay segments are segments which are replaced at runtime over the same piece of memory to let the program work with much more code than the addressable space. Is there any good tutorial about this kind of memory management in the old times?</p>\n</div>",
    "votes": "2",
    "answers": 2,
    "views": "2k",
    "tags": [
        "ida",
        "dos"
    ],
    "user": "Jack",
    "time": "Nov 27, 2015 at 15:07",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<h1>Unused functions in executables</h1>\n<p>There are various explanations for that.</p>\n<p>Obfuscation, as Itsbriany said, but i don't think that was much of a thing in old DOS executables.</p>\n<p>Unneeded library functions. If your code links in, for example, the math library (those old processors typically didn't have math coprocessors for floating point), you'll typically get all of the math emulation. Your program might use <code>sqrt</code> for distance calculations, but never use <code>sin</code>, <code>cos</code> and similar trigonometrics, but they get linked in anway.</p>\n<p>Function pointers. If your original C program had something like    <code>int (*funcs())[]={func1, func2, func3};</code> <code>int result=(func[index])();</code>\nand these are the <em>only</em> references to <code>func1</code>, <code>func2</code> and <code>func3</code>, then ida won't recognize them as being used. However, you'd find a data xref in them.</p>\n<p>C++ object methods, although when C++ started getting used, 32 bit processors were already common and you'd compile your program to a 32 bit binary using a dos extender. If methods never get called directly, only through the vtable of a class, then the same thing applies as with function pointers.</p>\n<p>Debugging functions in the original source code that just never get called in the finished binary. If the programmer did something like</p>\n<pre><code>#ifdef DEBUG\nsome_function(parm1, parm2, another_parm);\n#endif\n</code></pre>\n<p>and forgot to put <code>some_function</code> into <code>#ifdef</code> as well, then the finished binary will still have <code>some_function</code>, but no call to it.</p>\n<p>More than one programmer working on independent parts of the code. One programmer might have been assigned to the task of reading/writing a config file, and he implemented <code>read_config()</code> and <code>write_config()</code>. Later, someone decided that the game should only use <code>read_config()</code>, and the configuration part should be done in a separate setup program. If both functions are in the same source file, they'll be compiled  into - and linked in from - one single object file anyway.</p>\n<h1>Overlays in old dos programs</h1>\n<p>I don't know about a good tutorial, but here's basic info about overlays:</p>\n<p>You needed to identify parts of your code that didn't require each other when running. For example, your program might have a bunch of functions to navigate a world map, a different bunch of functions to navigate a dungeon, and a third bunch of functions to interact with a shopkeeper.</p>\n<p>You'd compile those separately, so you get 4 files: <code>main_game.exe</code>, <code>world.ovl</code>, <code>dungeon.ovl</code>, and <code>shopkeeper.ovl</code>. (Oops, there was an 8 character limit to filenames.) <code>main_game.exe</code> would be loaded into low ram, and calculate a segment for the overlays to load in - all at the same address. The easiest way to do this is make a segment that has only one variable, which gets loaded last - the address of that variable would be the address to load the overlays to. Let's name it <code>overlay_start</code>.</p>\n<p>To connect the main .exe to the overlays, each of the overlays would have a jump table at the start. For example, in world.ovl:</p>\n<pre><code>0000 jmp show_world_map\n0004 jmp draw_player_on_world_map\n0008 jmp draw_enemies_on_world_map\n....\n</code></pre>\n<p>and in dungeon.ovl:</p>\n<pre><code>0000 jmp show_dungeon_map\n....\n</code></pre>\n<p>Now you needed a bunch of functions to link into your main program to call these overlay functions, which all looked basically the same:</p>\n<pre><code>extern int (*overlay_start())[];\n\nvoid show_world_map() { load_overlay(\"world.ovl\"); overlay_start[0](); }\nvoid draw_player_on_world_map() { load_overlay(\"world.ovl\"); overlay_start[1](); }    \nvoid draw_enemies_on_world_map() { load_overlay(\"world.ovl\"); overlay_start[2](); }\n\nvoid show_dungeon_map() { load_overlay(\"dungeon.ovl\"); overlay_start[0](); }\n....\n\nvoid load_overlay(char *filename) {\n    /* omitting all the error checking, loops for more than 64KB, etc.) */\n    FILE *fp=fopen(filename, \"rb\");\n    fread(overlay_start, 1, SOME_LARGE_NUMBER, fp);\n    fclose(fp);\n}\n</code></pre>\n<p>(I omitted the function parameters in this example to keep it concise).</p>\n<p>Depending on your compiler, much of that could be auto-generated. And these functions, possibly including the <code>load_overlay</code> function, is typically what goes into the <code>stub</code> section. It's just a bunch of functions that keep the linker happy when linking <code>main_game.exe</code>, make sure the correct overlay is loaded, call the intended function, then return.</p>\n</div>",
            "votes": "5",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Jack",
                    "text": "<span class=\"comment-copy\">Thanks, I think I got it clear, actually I think the whole game just runs in real mode and pages are swapped accordingly by the OS (DOS). The game is said to require 2.7Mb of EMS, I studied a little the mechanics behind this. Is it possible that everything is just in real mode (so no extenders) and overlays are just swapped from EMS to conventional memory on requests made from the executable to DOS?</span>",
                    "time": null
                },
                {
                    "user": "Guntram Blohm",
                    "text": "<span class=\"comment-copy\">DOS doesn't handle EMS; instead, your EMS device driver does that. Which means you can't have DOS load the overlay into EMS directly, you still have to do it yourself. But of course, that's just a <code>load_overlay</code> function that's a bit more sophisticated. a) when an overlay gets loaded that's already in EMS, load it from there; b) when an overlay gets loaded that isn't in EMS, load it from disk; c) when an overlay is \"unloaded\", copy it to EMS first. This avoids some gory stuff as well like static variables being reset to 0 every time the overlay gets reloaded, and it provides a great speedup.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The code you are looking at is likely packed because it has that <a href=\"http://www.sevagas.com/Code-segment-encryption\" rel=\"nofollow\"><strong>stub</strong> segment</a>. </p>\n<p>Software vendors and malware authors pack their executables to make reverse engineering more difficult since most of the binary will appear as \"compressed\" data (non-machine instructions). Only the very first instructions should be apparent and will likely not be in the .text segment.</p>\n<p>If that is the case, then the binary will unpack itself during execution. This unpacking procedure will \"decompress\" the \"compressed\" data and reveal more valid machine instructions which will later be executed. The unpacking stub could also set global variables or dynamically allocate memory that will potentially hold function pointers to that procedure you are looking at.</p>\n<p>Additionally, the code in the <strong>.stub</strong> segment should contain many mathematical instructions such as <strong>xor reg1, reg2</strong> (where reg1 and reg2 differ), <strong>shr</strong>, <strong>shl</strong>, <strong>ror</strong>, <strong>rol</strong>, etc... with many jumps.</p>\n<p>Again, you are not seeing any xrefs to that function because IDA cannot find that subroutine called in the disassembly because it is possibly referenced by a global variable or via a dynamic allocation on the heap during the unpacking procedure.</p>\n<p>There is also a small possibility that the authors of that executable forgot to call that procedure. </p>\n</div>",
            "votes": "1",
            "user": "itsbriany",
            "time": "Nov 28, 2015 at 0:44",
            "is_accepted": false,
            "comments": []
        }
    ]
}