{
    "title": "Is there a way to debug an elf file that runs with no problems with damaged header?",
    "link": "https://reverseengineering.stackexchange.com/questions/15238/is-there-a-way-to-debug-an-elf-file-that-runs-with-no-problems-with-damaged-head",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>My question is general, but to have an example to work with, let us take one from <a href=\"http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html\" rel=\"nofollow noreferrer\" title=\"Whirlwind Tutorial\">Whirlwind Tutorial</a>. </p>\n<pre><code>; tiny.asm\nBITS 32\n          org     0x00010000\n          db      0x7F, \"ELF\"             ; e_ident\n          dd      1                                       ; p_type\n          dd      0                                       ; p_offset\n          dd      $$                                      ; p_vaddr \n          dw      2                       ; e_type        ; p_paddr\n          dw      3                       ; e_machine\n          dd      _start                  ; e_version     ; p_filesz\n          dd      _start                  ; e_entry       ; p_memsz\n          dd      4                       ; e_phoff       ; p_flags\n_start:\n          mov     bl, 42                  ; e_shoff       ; p_align\n          xor     eax, eax\n          inc     eax                     ; e_flags\n          int     0x80\n          db      0\n          dw      0x34                    ; e_ehsize\n          dw      0x20                    ; e_phentsize\n          db      1                       ; e_phnum\n                                          ; e_shentsize\n                                          ; e_shnum\n                                          ; e_shstrndx\n\nfilesize      equ     $ - $$  ; tiny.asm\n</code></pre>\n<p>To get a binary compile with <code>nasm -f bin -o tiny nasm.asm;chmod +x tiny</code>. Executable in it self, is a bit of tiny monster. It is smaller than ELF header, yet contains ELF header, program header and program code - yet Linux (at least on my 64 Debian) runs it. </p>\n<p>I would like to be able to debug this types files that have (intentionally or not) damaged/incorrect elf header. Is there a tool to fix elf header? Is there debugger that will manage to run this file?</p>\n<p>What I tried is to get entry point: <code>readelf -h tiny</code> but <code>readelf</code> refuses even to look at the file: <code>readelf: Error: tiny: Failed to read file header</code>. <code>objdump</code> is no better.  </p>\n<p>Running <code>rabin2 -e tiny</code> we get entry address (with some warnings):</p>\n<pre><code>[Entrypoints]\nvaddr=0x00010020 paddr=0x00010020 baddr=0x00000000 laddr=0x00000000 haddr=0x00000018 type=program\n</code></pre>\n<p>I managed to get some dissasembly using <code>radare2 tiny</code> and <code>pd</code> command:</p>\n<pre><code> [0x00010020]&gt; pd\n        ;-- entry0:\n        0x00010020      b32a           mov bl, 0x2a                ; '*' ; 42\n        0x00010022      31c0           xor eax, eax\n        0x00010024      40             inc eax\n        0x00010025      cd80           int 0x80\n        0x00010027      003400         add byte [eax + eax], dh\n        0x0001002a      2000           and byte [eax], al\n        ;-- section_end.uphdr:\n        0x0001002c  ~   01ff           add edi, edi\n</code></pre>\n<p>Next I tried <code>gdb tiny</code>, <code>lldb tiny</code> but neither worked. Free version 5.0 of IDA stops at infinite loop. </p>\n<p>So is there a way to repair elf in automatic/semi-automatic way? Or maybe some other trick that would allow debugging this (or similar) binary? One idea that comes to my mind is to patch entry point with instruction that loops and attach <code>gdb</code>. Would that work?</p>\n<p>If no tool for repairing elf exists, which files in kernel source contain code responsible for loading binary?</p>\n</div>",
    "votes": "4",
    "answers": 1,
    "views": "3k",
    "tags": [
        "debugging",
        "linux",
        "elf"
    ],
    "user": "Tahtisilma",
    "time": "Apr 27, 2017 at 11:39",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<span class=\"comment-copy\">try padding it with zeroes</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Several options are available for analyzing ELF binaries with damaged or corrupted headers. These include, but are not limited to:</p>\n<ul>\n<li>Using a <code>ptrace</code>-based debugger such as Radare2 (but definitely not gdb)</li>\n<li>Emulation e.g. via the <a href=\"https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/sample_x86.py\" rel=\"nofollow noreferrer\">Unicorn emulation framework</a></li>\n<li>Repairing the header, which may involve rebuilding the binary</li>\n</ul>\n<p>This particular binary is a challenge for standard tools for a few reasons:</p>\n<ul>\n<li>The program header table overlaps the ELF header rather than lying outside of it.</li>\n<li>There are no sections, and the fields having to do with sections are overwritten by\nthe program header table and so - from the perspective of tools that parse section information - contain nonsense values. BFD-based tools such   as <code>objdump</code> and GDB rely on section information being present and correct, so they will fail even if all of the other fields contain correct information.</li>\n<li>The entry point lies inside the ELF header, meaning there is executable code inside the header</li>\n</ul>\n<h2>Using a ptrace-based debugger</h2>\n<p>Radare2 is able to attach to the process:</p>\n<pre><code>$ r2 -d tiny-i386 \nProcess with PID 6756 started...\n= attach 6756 6756\nbin.baddr 0x00010000\nUsing 0x10000\nWarning: Cannot initialize program headers\nWarning: Cannot initialize section headers\nWarning: Cannot initialize strings table\nWarning: Cannot initialize dynamic strings\nWarning: Cannot initialize dynamic section\nWarning: read (init_offset)\nasm.bits 32\n[0x00010020]&gt; pd 5\n            ;-- eip:\n            0x00010020      b32a           mov bl, 0x2a                ; '*' ; 42\n            0x00010022      31c0           xor eax, eax\n            0x00010024      40             inc eax\n            0x00010025      cd80           int 0x80\n            0x00010027      003400         add byte [eax + eax], dh\n[0x00010020]&gt;\n</code></pre>\n<p>For such a small program, something like r2 seems rather heavyweight. There are only 7 bytes of instructions.</p>\n<p>One can also roll their own ptrace-based debugger. A good guide for this can be found\nat <a href=\"https://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1\" rel=\"nofollow noreferrer\">How debuggers work: Part 1 - Basics </a>.</p>\n<h2>Emulation</h2>\n<p>Emulation is easy in this case since the program is so simple. Emulation is a good solution for this kind of challenge since no information is needed besides the offsets of the first and last instructions. This information can be retrieved manually from a hex dump without needing to parse the header at all.</p>\n<p>Here is a script for emulating the binary in the question:</p>\n<pre><code>#!/usr/bin/python3\n\nfrom unicorn import *\nfrom unicorn.x86_const import *\nfrom capstone import *\nimport struct\n\n\nBASE = 0x100000\nSTACK_ADDR = 0x0\nSTACK_SIZE = 1024 * 1024\n\ndef read(name):\n   with open(name, 'rb') as f:\n      return f.read()\n\n#https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/shellcode.py\n# callback for tracing instructions\ndef hook_code(uc, address, size, user_data):\n    instruction = uc.mem_read(address, size)    # read this instruction code from memory\n    md = user_data\n    for i in md.disasm(instruction, address):\n        print(\"&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x, disassembly:\\t%s\\t%s\" %(i.address, i.size, i.mnemonic, i.op_str))\n\n\n# callback for tracing Linux interrupt\ndef hook_intr(uc, intno, user_data):\n    # only handle syscall\n    if intno != 0x80:\n        print(\"got interrupt %x ???\" %intno);\n        uc.emu_stop()\n        return\n\n    eax = uc.reg_read(UC_X86_REG_EAX)\n    eip = uc.reg_read(UC_X86_REG_EIP)\n\n    print(\"&gt;&gt;&gt; 0x%x: INTERRUPT: 0x%x, EAX = 0x%x\" %(eip, intno, eax))\n\n    uc.emu_stop()\n\n\n\ndef main():\n\n    mu = Uc(UC_ARCH_X86, UC_MODE_32)    # initialize emulation engine class\n    mu.mem_map(BASE, STACK_SIZE)    # allocate space at base address\n    mu.mem_map(STACK_ADDR, STACK_SIZE)  # allocate space for stack\n\n    mu.mem_write(BASE, read(\"./tiny_binaries/tiny-i386\"))   # write file to memory\n    mu.reg_write(UC_X86_REG_ESP, STACK_ADDR + STACK_SIZE - 1)   # initialize stack\n\n    md = Cs(CS_ARCH_X86, CS_MODE_32)    # initialize disassembler engine class\n\n    # add hooks\n    mu.hook_add(UC_HOOK_CODE, hook_code, md)    # pass disassembler engine to hook\n    mu.hook_add(UC_HOOK_INTR, hook_intr)\n\n    mu.emu_start(BASE + 0x20, BASE + 0x27)\n\n    print(\"&gt;&gt;&gt; Emulation Complete.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p>The following output is produced by the emulated execution of the binary:</p>\n<pre><code>$ ./emulate_tiny-i386.py \n&gt;&gt;&gt; Tracing instruction at 0x100020, instruction size = 0x2, disassembly:   mov bl, 0x2a\n&gt;&gt;&gt; Tracing instruction at 0x100022, instruction size = 0x2, disassembly:   xor eax, eax\n&gt;&gt;&gt; Tracing instruction at 0x100024, instruction size = 0x1, disassembly:   inc eax\n&gt;&gt;&gt; Tracing instruction at 0x100025, instruction size = 0x2, disassembly:   int 0x80\n&gt;&gt;&gt; 0x100025: INTERRUPT: 0x80, EAX = 0x1\n&gt;&gt;&gt; Emulation Complete.\n</code></pre>\n<p>A full write-up can be found here: <a href=\"https://binaryresearch.github.io/2019/09/17/Analyzing-ELF-Binaries-with-Malformed-Headers-Part-1-Emulating-Tiny-Programs.html\" rel=\"nofollow noreferrer\">Analyzing ELF Binaries with Malformed Headers Part 1 - Emulating Tiny Programs</a>. Full disclosure: I'm the author of the article.</p>\n<h2>Repairing the Header</h2>\n<p>Since the entirety of the program is contained within the header, repairing it means rebuilding the binary. The program header table must be separated from the ELF header, the code then must be appended to the end of the program header table, and finally the entry point must be recalculate to point to the new offset of the first instruction in the binary. In this particular case, this can be done relatively straightforwardly using a tool called <code>lepton</code> (I am the developer). Here is the script to accomplish rebuilding the binary:</p>\n<pre><code>#!/usr/bin/python3\n\nfrom lepton import *\n\ndef main():\n    # create new headers\n    with open(\"tiny-i386\", \"rb\") as f:\n        elf_file = ELFFile(f, new_header=True)\n\n    # recompose binary\n    with open(\"repaired_tiny-i386\", \"wb\") as f:\n        f.write(elf_file.recompose_binary())    # this moves the program header out of the file\n                                                # header and recalculates the entry point\n    print(\"\\n\\tRepaired header field values:\\n\")\n    elf_file.ELF_header.print_fields()          # call once entry point has been recalculated\n\n\nif __name__==\"__main__\":\n    main()\n</code></pre>\n<p>After being rebuilt, <code>readelf</code> can successfully parse the new binary:</p>\n<pre><code>$ readelf -h repaired_tiny-i386 \nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x10054\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          0 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         1\n  Size of section headers:           0 (bytes)\n  Number of section headers:         0\n  Section header string table index: 0\n\n$ readelf -l repaired_tiny-i386 \n\nElf file type is EXEC (Executable file)\nEntry point 0x10054\nThere is 1 program header, starting at offset 52\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  LOAD           0x000000 0x00010000 0x00030002 0x10020 0x10020 R   0xc0312ab3\n</code></pre>\n<p>The runtime behavior of the new file is identical to the original:</p>\n<pre><code>$ strace ./repaired_tiny-i386 \nexecve(\"./repaired_tiny-i386\", [\"./repaired_tiny-i386\"], 0x7ffd19a0f1b0 /* 52 vars */) = 0\nstrace: [ Process PID=5822 runs in 32 bit mode. ]\nexit(42)                                = ?\n+++ exited with 42 +++\n</code></pre>\n<p>More details, information and examples can be found in the <a href=\"https://github.com/BinaryResearch/lepton\" rel=\"nofollow noreferrer\">description of the <code>lepton</code> repository</a>.</p>\n<h2>Conclusion</h2>\n<p>In general, if the binary executes, it should be possible to attach <code>ptrace</code>. GDB, however, is very brittle and is easy to render useless. Emulation seems to be the most robust solution, since parsing the ELF header is largely unecessary and one can hook any instruction executed (total control, essentially). </p>\n<p>On a final note, a detailed presentation of how the kernel loads ELF programs can be found in the LWN article <a href=\"https://lwn.net/Articles/631631/\" rel=\"nofollow noreferrer\">How programs get run: ELF binaries</a>. Included in the discussion are links to relevant code in the kernel.</p>\n</div>",
            "votes": "4",
            "user": "julian",
            "time": "Oct 1, 2019 at 16:58",
            "is_accepted": false,
            "comments": []
        }
    ]
}