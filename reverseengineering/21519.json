{
    "title": "Find flag from GO binary challenge [closed]",
    "link": "https://reverseengineering.stackexchange.com/questions/21519/find-flag-from-go-binary-challenge",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<div>\n<aside class=\"s-notice s-notice__info post-notice js-post-notice mb16\" role=\"status\">\n<div class=\"d-flex fd-column fw-nowrap\">\n<div class=\"d-flex fw-nowrap\">\n<div class=\"flex--item wmn0 fl1 lh-lg\">\n<div class=\"flex--item fl1 lh-lg\">\n<div>\n<b>Closed.</b> This question is <a href=\"/help/closed-questions\">off-topic</a>. It is not currently accepting answers.\n                                \n                            </div>\n</div>\n</div>\n</div>\n</div>\n<hr class=\"my12 outline-none baw0 bb bc-blue-400\"/>\n<div class=\"fw-nowrap fc-black-500\">\n<div class=\"d-flex fd-column lh-md\">\n<div class=\"mb0 d-flex\">\n<div class=\"flex--item mr8\">\n<svg aria-hidden=\"true\" class=\"svg-icon iconLightbulb\" height=\"18\" viewbox=\"0 0 18 18\" width=\"18\"><path d=\"M15 6.38A6.5 6.5 0 0 0 7.78.04h-.02A6.5 6.5 0 0 0 2.05 5.6a6.3 6.3 0 0 0 2.39 5.75c.49.39.76.93.76 1.5v.24c0 1.07.89 1.9 1.92 1.9h2.75c1.04 0 1.92-.83 1.92-1.9v-.2c0-.6.26-1.15.7-1.48A6.3 6.3 0 0 0 15 6.37M4.03 5.85A4.5 4.5 0 0 1 8 2.02a4.5 4.5 0 0 1 5 4.36 4.3 4.3 0 0 1-1.72 3.44c-.98.74-1.5 1.9-1.5 3.08v.1H7.2v-.14c0-1.23-.6-2.34-1.53-3.07a4.3 4.3 0 0 1-1.64-3.94M10 18a1 1 0 0 0 0-2H7a1 1 0 1 0 0 2z\"></path></svg>\n</div>\n<p> Questions asking for help <b>reverse-engineering a specific system</b> are off-topic unless they demonstrate an understanding of the concepts involved and clearly identify a specific problem.</p>\n</div>\n<div class=\"mb0 mt6 d-flex\">\n<p class=\"ml24 pl2\">Closed <span class=\"relativetime\" title=\"2019-07-03 21:55:22Z\">5 years ago</span>.</p>\n</div>\n<div class=\"ml24 pl2\">\n</div>\n</div>\n</div>\n<div class=\"mt24 d-flex gsx gs8\">\n<a class=\"s-btn s-btn__outlined flex--item js-post-notice-edit-post\" href=\"/posts/21519/edit\">\n                        Improve this question\n                    </a>\n</div>\n</aside>\n</div>\n<p>I have GO binary file from challenge (that already over).</p>\n<p>I spent around 3 days to find the flag without results.</p>\n<p>I'm trying to load the file with gdb and using the following command:</p>\n<p>First, Trying to find the entry point:</p>\n<pre><code>info files\n</code></pre>\n<p>After I got the entry point I did <code>break *&lt;ENTRYPOINTADDR&gt;</code>\nThen <code>layout asm</code> and then I just try to figure when I need to add break point before the print that ask me to enter a password.</p>\n<p>Also trying with <code>info frame</code> and <code>show registers</code> and to print the values but nothing found.</p>\n<p>I just want to learn how to find the flag from this ELF file</p>\n<p>I would love to know how to solve it</p>\n<p><a href=\"https://ufile.io/fz0q1ay3\" rel=\"nofollow noreferrer\">GO binary File</a></p>\n</div>",
    "votes": "0",
    "answers": 2,
    "views": "2k",
    "tags": [
        "patch-reversing"
    ],
    "user": "user28772",
    "time": "5 years ago",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Since you have already spent a lot of time on it, I will just show you how to solve it step by step. I recommend you to repeat steps I'm describing, since the best way to learn is to practice.</p>\n<h1>Tool</h1>\n<p>I will use <a href=\"https://github.com/radare/radare2\" rel=\"nofollow noreferrer\">radare2</a> for solving this challenge, but it's of course possible to use other tools as well. The reason I chose it is simple: it recognises <code>go</code> library functions, so it will be easier to find <em>interesting</em> parts of the executable.</p>\n<h1>Static analysis</h1>\n<p>At the beginning, we have to find out where to start our analysis. Run:</p>\n<pre><code>r2 -c aei -d revengme\n</code></pre>\n<p>to open this program in <em>debug mode</em> in <code>radare2</code>. Then type <code>aaa</code> to analyse entire binary. It may take some time; just wait until it finishes.</p>\n<p>Now, to go to the <code>main</code> function, type:</p>\n<pre><code>s sym.go.main.main\n</code></pre>\n<p>You may now see its contents by typing <code>pdf</code>. You will see several library functions there. Since, at this point we know only that the program prints something and waits for some input, it's natural to look for routines performing these tasks. To find every call to functions printing output, you can use <code>radare2</code> internal <code>grep</code> like so:</p>\n<pre><code>pdf ~print\n</code></pre>\n<p>, to search for <code>'print'</code> pattern in the <code>pdf</code> output. You may do the same thing with <em>Read</em> to see only one reference to <code>sym.go.bufio.__Reader_.ReadLine</code>.</p>\n<p>Since analysing program control flow is easier in <code>graph mode</code>, let us switch to it by typing <code>V!</code> and then <code>G</code>. You will see something like this:</p>\n<p><a href=\"https://i.sstatic.net/1z1U9.jpg\" rel=\"nofollow noreferrer\"><img alt=\"r2GraphMode\" src=\"https://i.sstatic.net/1z1U9.jpg\"/></a></p>\n<p>and you may navigate using arrows to see the rest of the graph. In the image above, we can spot two interesting functions: <code>sym.go.bufio.__Reader_.ReadLine</code> as stated previously and <code>sym.go.main.ObfStr</code> that suggests that most important strings are <em>obfuscated</em> as we could have expected.</p>\n<p>Now, after reading user input the program has to somehow check if it's valid. So we are looking for the fragment responsible for it.\n<a href=\"https://i.sstatic.net/QySDA.jpg\" rel=\"nofollow noreferrer\"><img alt=\"checkingForStringValidity\" src=\"https://i.sstatic.net/QySDA.jpg\"/></a></p>\n<p>On the image above, you may spot a call to <code>sym.go.runtime.memequal</code> that seems to do this job. You may see its signature <a href=\"https://golang.org/pkg/runtime/?m=all#memequal\" rel=\"nofollow noreferrer\">here</a>, but it basically takes two pointers to memory regions and the length to compare them. Additionally, it is only called when value in <code>rcx</code> is equal to <code>[rsp+20h]</code> as shown in the upper rectangle.</p>\n<p>Hence, we may conclude that <code>[rsp+20h]</code> actually contains the length of the password we are trying to obtain. <strong>In fact we see even more</strong>: we know where the addresses of strings being compared are stored! These are <code>[rsp]</code> and <code>[rsp+8h]</code> respectively. And that is the end of our static analysis. We may now proceed to dynamic one.</p>\n<h1>Dynamic analysis</h1>\n<p>We run <code>radare2</code> in debug mode to be able to dynamically analyse the program and now we will do so.</p>\n<p>We just put the breakpoints where we want to see actual memory stored on the stack. We have to know two things:</p>\n<ol>\n<li>What is expected length of our string.</li>\n<li>And how it looks like.</li>\n</ol>\n<p>Hence our points of interest are those two presented on the second image. Since it isn't position independent code, their addresses will not change throughout different executions. These are:</p>\n<ul>\n<li><code>0x00488e99</code></li>\n<li><code>0x00488f68</code></li>\n</ul>\n<p>To put breakpoints there, use <code>db address</code> command. To continue execution until they are hit, use <code>dc</code>. You will be prompted to write the password, but write anything - at this moment we only want to get the expected length of the string. After the first breakpoint is hit, run <code>V!</code> once again to see:\n<a href=\"https://i.sstatic.net/0n3O4.jpg\" rel=\"nofollow noreferrer\"><img alt=\"r2StackView\" src=\"https://i.sstatic.net/0n3O4.jpg\"/></a>\nOn the upper right corner you can see the stack contents. Now we are only interested in length, so <code>[rsp+20h]</code>. The value stored there is displayed in the third row - it is <code>0x26</code>, so the password contains <code>38</code> characters.</p>\n<p>Now, type <code>ood</code> to restart the application (it will preserve the breakpoints however). Since you know that the password length is <code>38</code> just type <code>38</code> random characters when you are prompted to. Then, when you hit the second breakpoint, you may read the stack contents once again and you will see the addresses of two strings: one that you have just typed, and the second, desired one.</p>\n<p><strong>Important note:</strong> the pointers will be shown in <em>little endian</em> format, so starting with the least significant byte and ending with the most significant one.</p>\n<p>You will be interested in <code>0xc000018240</code>, that contains the string you are looking for, that is:</p>\n<pre><code>BSidesTLV{revenge is best served cold}\n</code></pre>\n<p><strong>Note2:</strong> To cause <code>radare2</code> to treat <code>n</code> specific bytes as data in current location, you can use <code>Cd n</code> command.</p>\n</div>",
            "votes": "3",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>bart1e answered your question right \nthis is just an extension to his answer with a different tool <strong>ghidra</strong> and reversing purely statically without running the binary.</p>\n<p>golang uses a <a href=\"https://science.raphael.poss.name/go-calling-convention-x86-64.html\" rel=\"nofollow noreferrer\">different approach to calling functions</a> it provides a memory slot in stack for arguments to the functions as well as multiple values it can return from a function </p>\n<p>for example a function can return a sum and product of two integers in the same function like   </p>\n<p><code>func doMagic (x,y) { return x+y ,x*y )</code> </p>\n<p>so roughly the disassembly will look like<br/>\n( it is just a simplification of details not absolute syntax or exact types are used )</p>\n<p>it just tries to reiterate how golang uses <strong>stack</strong><br/>\ninstead of traditional <strong>x64 abi registers or x86 abi memory / stack for arguments</strong> and conventional<br/>\n<strong>returns in rax/eax</strong> </p>\n<pre><code>mov [stack] , x\nmov [stack] , y\nmov [stack] , &amp;fret1\nmov [stack] , &amp;fret2\ncall doMagic\n\nand inside doMagic \nt1 = x \nt2 = y\nt3 = t1  + t2\nt4 = t1  * t2\nfret1 = t3\nfret2 = t4\nret\n</code></pre>\n<p>so reading around I found <a href=\"https://rednaga.io/2016/09/21/reversing_go_binaries_like_a_pro/\" rel=\"nofollow noreferrer\">golang embeds the function names and its address in <code>.gopclntab</code></a> section and was fooling around with renaming the functions and successfully renamed the functions with this hack of script below but the decompilation was still looking a horrible mess</p>\n<pre><code>from ghidra import *\nmem = currentProgram.getMemory()\nstart = mem.getBlock(\".gopclntab\").getStart()\nprovider = ghidra.app.util.bin.MemoryByteProvider(mem,start)\nbread = ghidra.app.util.bin.BinaryReader(provider,True)\nnumfun = bread.readInt(8)\nfor i in range(0x10,numfun*0x10,0x10):  \n    faddr = bread.readInt(bread.readInt(i+8))\n    fname = bread.readAsciiString(bread.readInt(bread.readInt(i+8) + 8))\n    print( \"creating function at \" + hex(faddr) + \"\\t\" + fname )\n    removeFunctionAt(toAddr(faddr))\n    createFunction(toAddr(faddr),fname)\n</code></pre>\n<p>so i scoured around and hit upon a GitHub entry by <a href=\"https://github.com/felberj/gotools\" rel=\"nofollow noreferrer\">felberj a ghidra script for golang</a> </p>\n<p>downloaded the script for 9.04 version copied it to ghidra/extension dir as instructed \nin the project window did File-&gt;installExtension and restarted ghidra</p>\n<p>now i imported the binary again this time making sure i used the newly added golang language entry instead of default gcc x64 ghidra proposes </p>\n<p>and apart from renaming functions this extension also decoded the return types and changed the storage type of arguments to custom storage and assigned proper stack address to all the arguments and return values.</p>\n<p>now the decompilation of main.main was looking a bit more readable  </p>\n<pre><code>void main.main(void)\n\n{\n\n  byte Wrong [17];\n  byte EPas [20];\n  byte good [30];\n  byte Ans [38];\n  byte retry [40];\n\n\n  ppbVar1 = *(in_FS_OFFSET + 0xfffffff8) + 0x10;\n  if (good + 4 &lt; *ppbVar1 || good + 4 == *ppbVar1) {\n    runtime.morestack_noctxt();\n    main.main();\n    return;\n  }\n  EPas._0_8_ = 0xc5d38ad8cfdec4ef;EPas._8_4_ = 0xda8ad8df;EPas._12_4_ = 0xddd9d9cb;\n  EPas._16_4_ = 0x90ced8c5;\n  Wrong[0] = 0xf9; Wrong._1_4_ = 0xc2dec7c5;Wrong._5_4_ = 0x8acdc4c3;Wrong._9_4_ = 0xdd8ad9c3;\n  Wrong._13_4_ = 0xcdc4c5d8;\n  Ans._0_6_ = 0xd9cfcec3f9e8;  Ans._6_2_ = 0xe6fe;  Ans._8_2_ = 0xd1fc;  Ans._10_4_ = 0xcfdccfd8;\n  Ans._14_4_ = 0x8acfcdc4;  Ans._18_4_ = 0xc88ad9c3;  Ans._22_4_ = 0x8aded9cf;  Ans._26_4_ = 0xdcd8cfd9;\n  Ans._30_4_ = 0xc98acecf;  Ans._34_4_ = 0xd7cec6c5;\n  good._0_4_ = 0x8adfc5f3;  good._4_4_ = 0xc9cbd8e9;  good._8_4_ = 0x8acecfc1;  good._12_2_ = 0xdec3;\n  good._14_2_ = 0x8a86;  good._16_2_ = 0x8aeb;  good._18_4_ = 0xc5d8cfe2;  good._22_4_ = 0x8ad9c38a;\n  good._26_4_ = 0xc4d8c5c8;\n  retry._0_8_ = 0xc5fd8ade8dc4c5ee;  retry._8_4_ = 0x86d3d8d8;  retry._12_4_ = 0xc6cff88a;\n  retry._16_4_ = 0x8a86d2cb;  retry._20_4_ = 0xc6c3c2e9;  retry._24_4_ = 0xc4cb8ac6;\n  retry._28_4_ = 0xd8fe8ace;  retry._32_4_ = 0xcbc28ad3;  retry._36_4_ = 0xd8cfced8;\n\n  uStack224 = 0x14;\n  rVar3 = main.ObfStr(EPas,0x14,0x14);\n  uStack0000000000000020 = SUB168(rVar3,0);\n  uStack0000000000000028 = SUB168(rVar3 &gt;&gt; 0x40,0);\n  uStack0000000000000018 = runtime.convTstring(in_stack_fffffffffffffe10,in_stack_fffffffffffffe18);\n  pdStack232 = &amp;DAT_0049a600;\n  puVar7 = 0x1;\n  lVar9 = 1;\n  fmt.Fprint(&amp;PTR_DAT_004d3a60,DAT_0055b7f0,&amp;pdStack232,1,1);\n  uStack152 = DAT_0055b7e8;\n  apuStack96[0] = 0x0;\n  FUN_00451d15();\n  lVar5 = 0x1000;\n  lVar6 = 0x1000;\n  runtime.makeslice(&amp;DAT_0049a740,0x1000,0x1000);\n  puStack184 = 0x0;\n  puVar8 = puVar7;\n  FUN_00451d15();\n  uStack176 = 0x1000;\n  uStack168 = 0x1000;\n  ppuStack160 = &amp;PTR_DAT_004d3a40;\n  uStack112 = 0xffffffffffffffff;\n  uStack104 = 0xffffffffffffffff;\n  puStack184 = puVar7;\n  apuStack96[0] = puVar7;\n  FUN_0045207a();\n  rVar2 = bufio.(*Reader).ReadLine(apuStack96);\n  uStack0000000000000010 = SUB488(rVar2,0);\n  uStack0000000000000018 = SUB488(rVar2 &gt;&gt; 0x40,0);\n  uStack0000000000000020 = SUB488(rVar2 &gt;&gt; 0x80,0);\n  uStack0000000000000028 = SUB488(rVar2 &gt;&gt; 0xc0,0);\n  if (lStack480 != 0) {\n    uStack208 = 0x11;\n    rVar3 = main.ObfStr(Wrong,0x11,0x11);\n    uStack0000000000000020 = SUB168(rVar3,0);\n    uStack0000000000000028 = SUB168(rVar3 &gt;&gt; 0x40,0);\n    uStack0000000000000018 = runtime.convTstring(puVar8,lVar9);\n    if (lStack480 != 0) {\n      lStack480 = *(lStack480 + 8);\n    }\n    pdStack216 = &amp;DAT_0049a600;\n    puVar8 = 0x2;\n    lVar9 = 2;\n    lStack200 = lStack480;\n    rVar4 = fmt.Fprintln(&amp;PTR_DAT_004d3a60,DAT_0055b7f0,&amp;pdStack216,2,2);\n    uStack0000000000000040 = SUB248(rVar4 &gt;&gt; 0x80,0);\n  }\n  rVar3 = main.ObfStr(Ans,0x26,0x26);\n  uStack0000000000000020 = SUB168(rVar3,0);\n  uStack0000000000000028 = SUB168(rVar3 &gt;&gt; 0x40,0);\n  if ((lVar9 == lVar6) &amp;&amp;\n     (uStack0000000000000020 = runtime.memequal(lVar5,puVar8,lVar6), puVar8 != '\\0')) {\n    uStack240 = 0x1e;\n    rVar3 = main.ObfStr(good,0x1e,0x1e);\n    uStack0000000000000020 = SUB168(rVar3,0);\n    uStack0000000000000028 = SUB168(rVar3 &gt;&gt; 0x40,0);\n    uStack0000000000000018 = runtime.convTstring(puVar8,lVar9);\n    pdStack248 = &amp;DAT_0049a600;\n    fmt.Fprintln(&amp;PTR_DAT_004d3a60,DAT_0055b7f0,&amp;pdStack248,1,1);\n    return;\n  }\n  uStack256 = 0x28;\n  rVar3 = main.ObfStr(retry,0x28,0x28);\n  uStack0000000000000020 = SUB168(rVar3,0);\n  uStack0000000000000028 = SUB168(rVar3 &gt;&gt; 0x40,0);\n  uStack0000000000000018 = runtime.convTstring(puVar8,lVar9);\n  pdStack264 = &amp;DAT_0049a600;\n  fmt.Fprintln(&amp;PTR_DAT_004d3a60,DAT_0055b7f0,&amp;pdStack264,1,1);\n  return;\n}\n</code></pre>\n<p>so as you can see it prints a string Enter password \nreads a line \ncompares the entered pass with a obfuscated (simple xor with byte 0xaa ) actual password \nand prints good , you are a hero \nor prints wrong retry</p>\n<p>the deobfuscation routine is main.obfstr() it takes a bytearray and length to xor \nand returns a xorred string back</p>\n<p>based on these observations we can write a simple  xor script </p>\n<p>that takes an address the byte to xor and length and xor the results to get the pass without running the binary</p>\n<p>here is naive xor script (na√Øve because it ran for me the one time i tested in my machine and can have innumerable unanticipated corner case bugs)</p>\n<pre><code>#Desc xors a memory block of len unsigned bytes with a single unsigend byte like (0xff ^ 0xaa)\n#@author      blabb \n#@category    _NEW_\n#@keybinding  \n#@menupath    none\n#@toolbar     \n\nimport ghidra\ndef hexdump( a ):\n    for j in range(0,len(a),16):\n        for i in range(j,j+16,1):\n            if( i &lt; len(a)):\n                print ( \"%02x \" % a[i]),\n            else:\n                print ( \"%02x \" % 0 ),  \n        for i in range(j,j+16,1):\n            if( i &lt; len(a)):\n                print ( \"%c\" % chr( a[i] ) ),\n            else:\n                print ( \" \" ),\n        print(\"\\n\")\n\nbaseaddr = askAddress( \"XOR MEMORY\",\"Enter Base Addreess\")\nxorby    = askInt    ( \"XOR MEMORY\",\"Enter Byte to xor with\")\nxorlen   = askInt    ( \"XOR MEMORY\",\"enter length of xor block\")\nres = []\nprovider = ghidra.app.util.bin.MemoryByteProvider(currentProgram.getMemory(),baseaddr)\nbr =       ghidra.app.util.bin.BinaryReader(provider,True)\nfor i in range(0,xorlen,1):\n    res.append((br.readUnsignedByte(i) ^ xorby))\nhexdump(res)\n</code></pre>\n<p>running this and providing the memory address for password 0x4d3ae0,xorbyte 0xaa,len 0x26 </p>\n<p>we can easily get the password </p>\n<pre><code>xormem.py&gt; Finished!\nxormem.py&gt; Running...\n42  53  69  64  65  73  54  4c  56  7b  72  65  76  65  6e  67  B S i d e s T L V { r e v e n g \n\n65  20  69  73  20  62  65  73  74  20  73  65  72  76  65  64  e   i s   b e s t   s e r v e d \n\n20  63  6f  6c  64  7d  00  00  00  00  00  00  00  00  00  00    c o l d }                     \n\nxormem.py&gt; Finished!\n</code></pre>\n</div>",
            "votes": "1",
            "user": "blabb",
            "time": "Jun 25, 2019 at 7:17",
            "is_accepted": false,
            "comments": []
        }
    ]
}