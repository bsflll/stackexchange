{
    "title": "How does ECC work with nandwrite/nanddump in mtd-utils?",
    "link": "https://reverseengineering.stackexchange.com/questions/10975/how-does-ecc-work-with-nandwrite-nanddump-in-mtd-utils",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am working on a device which has a NAND flash chip in TSOP48, a SK Hynix H27U1G8F2BTR (1Gbit/128Mbyte, 2048byte (+ 64byte spare) pages, 128K blocks).</p>\n<p>I have desoldered the chip and dumped the contents to a file. This file contains the OOB (out-of-band) data as well, resulting in a 138412032byte file.</p>\n<p>I create a new simulated NAND MTD device using:</p>\n<pre><code>modprobe nandsim first_id_byte=0xad second_id_byte=0xf1 third_id_byte=0x00 fourth_id_byte=0x1d\n</code></pre>\n<p>Which results in a device with the correct parameters:</p>\n<pre><code>$mtdinfo /dev/mtd0\nmtd0\nName:                           NAND simulator partition 0\nType:                           nand\nEraseblock size:                131072 bytes, 128.0 KiB\nAmount of eraseblocks:          1024 (134217728 bytes, 128.0 MiB)\nMinimum input/output unit size: 2048 bytes\nSub-page size:                  512 bytes\nOOB size:                       64 bytes\nCharacter device major/minor:   90:0\nBad blocks are allowed:         true\nDevice is writable:             true\n</code></pre>\n<p>I can now write my image to mtd using <code>nandwrite</code>, with the <code>-o</code> option to indicate that the dump contains OOB information:</p>\n<pre><code>nandwrite -o /dev/mtd0 with_oob.bin\n</code></pre>\n<p>Then I can dump the image using <code>nanddump</code>:</p>\n<pre><code>nanddump /dev/mtd0 -f without_oob.bin\n</code></pre>\n<p>This results in a 134217728byte file without OOB data. This file is sensible (as in, contains file systems I can mount).</p>\n<p>A few times, when playing around, I have seen ECC errors when running <code>nanddump</code>. </p>\n<p>How does this combination of <code>nandsim</code>, <code>nandwrite</code> and <code>nandddump</code> decide which ECC scheme to use? The flash is from a TI AM335 system, and as far as I know, the ECC scheme is decided by a combination of the processor and OS. How do these utilities know what to do?</p>\n</div>",
    "votes": "6",
    "answers": 1,
    "views": "12k",
    "tags": [
        "flash"
    ],
    "user": "Cybergibbons",
    "time": "Sep 27, 2015 at 5:33",
    "comments": [
        {
            "user": "Jason Geffner",
            "text": "<span class=\"comment-copy\">You might have better luck asking on <a href=\"http://electronics.stackexchange.com/\">electronics.stackexchange.com</a> instead of here.</span>",
            "time": null
        },
        {
            "user": "Cybergibbons",
            "text": "<span class=\"comment-copy\">I think I will try to move it over if I get nothing here. I've tried a few other places and the answers have been don't know or \"read the code\" (which is great, but I still can't work out how it works).</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>First of all the ECC scheme used does not necessaryly have to be the for all the flash erase blocks. There are ususally 3 different types of flash partitions used and for every type the method to specify the used ECC code differs:</p>\n<ol>\n<li>The one that are accessed by the ROM bootcode</li>\n<li>The ones that are accessed by the bootloader (usually u-boot)</li>\n<li>The ones that are accessed by the operating system (assuming you are using Linux)</li>\n</ol>\n<p>In general the use of a specific ECC method is limited by the OOB size of the flash. <em>The AM335x_U-Boot_User's_Guide</em> (cannot post link here because of reputation) explains it in sections <em>BCH Flash OOB Layout</em> and the example matches to the flash chip you are using. The 64 bytes per 2k page effectively limit the usable ECC algorithms to BCH8, BCH4 or HAMMING codes.</p>\n<blockquote>\n<p>BCH Flash OOB Layout</p>\n<p>For any ECC scheme we need to add some extra data while writing so as to detect and correct (if possible) the errors introduced by the NAND part. In case of BCH scheme some bytes are needed to store the ECC related info.</p>\n<p>The section of NAND memory where addition info like ECC data is stored is referred to as Out Of Band or OOB section.</p>\n<p>The first 2 bytes are used for Bad block marker – 0xFFFF =&gt; Good block</p>\n<p>The next ‘N’ bytes is used for BCH bytes</p>\n<p>N = B * Number of 512-byte sectors in a page</p>\n<p>B = 8 bytes per 512 byte sector in BCH4\n     B = 14 bytes per 512 byte sector in BCH8\n     B = 26 bytes per 512 byte sector in BCH16</p>\n<p>So for a 2k page-size NAND flash with 64-byte OOB size, we will use BCH8. This will consume 2 + (14*4) = 58 bytes out of 64 bytes available. </p>\n</blockquote>\n<h3>ECC used by ROM bootcode</h3>\n<p>The AM335x processor's ROM bootcode decides which ECC scheme to use for NAND flash depending on the mechanism expalined in the AM335x technical reference manual chapter 26.1.7.4 NAND</p>\n<blockquote>\n<p>ECC Correction\n  The default ECC correction applied is BCH 8b/sector using the GPMC and ELM hardware.\n  For device ID codes D3h, C3h, D5h, C5h, D7h, C7h, DEh, CEh when manufacturer code (first ID byte) is\n  98h the Cell type information is checked in the 4th byte of ID data. If it is equal to 10b then the ECC\n  correction applied is BCH 16b/sector.\n  In addition ECC computation done by the ROM can be turned off completely by using SYSBOOT[9]. This\n  is particularly useful when interfacing with NAND devices that have built in ECC engines.</p>\n</blockquote>\n<p>Other ways to control the ECC behavior are ONFI or and I2C EEPROM but the H27U1G8F2BTR datasheet does not mention ONFI so I guess it is not supported by the flash chip.</p>\n<p>So basically BCH8 or BCH16 or no ECC mechanism is used for the first 128K the ROM bootloader reads from NAND flash.</p>\n<h3>ECC used by the bootloader</h3>\n<p>The bootloader decides this on his own. For example for U-boot this information is compiled into u-boot and the first level bootloader (SPL/MLO) as well. The information is controlled by U-Boot configuration settings set at compile time. Recent versions of U-boot can switch the ecc at runtime using the nandecc command.</p>\n<h3>ECC used by the OS</h3>\n<p>The selection is completely OS specific. For Linux embedded systems using AM335x processors I know that this information is passed into the kernel using the device tree.</p>\n<h3>Which ECC method does nandsim use</h3>\n<p>There is a parameter called <em>bch</em> which can be passed to the nandsim module\nto select an ecc code. From the code I guess It is initialized to zero so it won't use any ECC code. So it seems that nandsim can use BCH8 and BCH16 but only one for the whole flash that is simulated.</p>\n<p><code>modprobe nandsim bch=8 first_id_byte=0xad second_id_byte=0xf1 third_id_byte=0x00 fourth_id_byte=0x1d\n</code></p>\n<h3>Which ECC method does nanddump/nandwrite use</h3>\n<p>Again, this depends on the OS/Linux you used to dump the flash. Similar to the nandsim module real mtd drivers have ways to specify the used ECC scheme (kernel parameters, device tree). But you can instruct nanddump to ignore the ECC information, too.</p>\n<h3>References</h3>\n<ul>\n<li>AM335x technical reference manual <a href=\"http://www.ti.com/lit/gpn/am3359\" rel=\"noreferrer\">http://www.ti.com/lit/gpn/am3359</a></li>\n<li>bch Linux Kernel parameter for nandsim <a href=\"http://lxr.free-electrons.com/source/drivers/mtd/nand/nandsim.c#L175\" rel=\"noreferrer\">http://lxr.free-electrons.com/source/drivers/mtd/nand/nandsim.c#L175</a></li>\n<li>The AM335x_U-Boot_User's_Guide</li>\n</ul>\n</div>",
            "votes": "6",
            "user": "bshm",
            "time": "Jun 18, 2016 at 10:09",
            "is_accepted": false,
            "comments": []
        }
    ]
}