{
    "title": "What purpose of mov %esp,%ebp?",
    "link": "https://reverseengineering.stackexchange.com/questions/2073/what-purpose-of-mov-esp-ebp",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>When execution enters a new function by performing call  I do often see this code template (asm list generated by Gnu Debugger when in debugging mode):</p>\n<pre><code>0x00401170  push   %ebp\n0x00401171  mov    %esp,%ebp\n0x00401173  pop    %ebp\n</code></pre>\n<p>So what's the purpose of moving esp to ebp?</p>\n</div>",
    "votes": "19",
    "answers": 2,
    "views": "24k",
    "tags": [
        "disassembly"
    ],
    "user": "PaulD",
    "time": "Mar 3, 2014 at 10:46",
    "comments": [
        {
            "user": "cb88",
            "text": "<span class=\"comment-copy\">Dunno if these sort of things are on topic here? Anyway see here: <a href=\"http://stackoverflow.com/questions/2515598/push-ebp-movlesp-ebp\">stackoverflow.com/questions/2515598/push-ebp-movlesp-ebp</a></span>",
            "time": null
        },
        {
            "user": "Robert Mason",
            "text": "<span class=\"comment-copy\">I think yes, albeit very basic, as disassembly questions are on topic.  Furthermore, there are reasons to use frame pointers that are more related to reverse engineering (e.g. debugging, runtime code analysis) than others (e.g. easy to implement alloca(), ease of remembering offsets)</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Moving <code>esp</code> into <code>ebp</code> is done as a debugging aid and in some cases for exception handling.  <code>ebp</code> is often called the frame pointer.  With this in mind, think of what happens if you call several functions.  <code>ebp</code> points to a block of memory where you pushed the old <code>ebp</code>, which itself points to another saved <code>ebp</code>, etc.  Thus, you have a linked list of stack frames.  From these, you can look at the return addresses (which are always 4 bytes above the frame pointer in the stack frame) to find out what line of code called a stack frame in question.  The instruction pointer can tell you the location of current execution.  This allows you to generate a <a href=\"https://en.wikipedia.org/wiki/Stack_trace\">stacktrace</a> which is useful for debugging by showing the flow of execution throughout a program.</p>\n<p>As a practical example consider the following code:</p>\n<pre><code>void foo();\nvoid bar();\nvoid baz();\nvoid quux();\n\nvoid foo() {\n    bar();\n}\n\nvoid bar() {\n    baz();\n    quux();\n}\n\nvoid baz() {\n    //do nothing\n}\n\nvoid quux() {\n    *(int*)(0) = 1; //SEGFAULT!\n}\n\nint main() {\n    foo();\n    return 0;\n}\n</code></pre>\n<p>This generates the following assembly (with Debian gcc 4.7.2-4 <code>gcc -m32 -g test.c</code>, snipped):</p>\n<pre><code>080483dc &lt;foo&gt;:\n 80483dc:   55                      push   %ebp\n 80483dd:   89 e5                   mov    %esp,%ebp\n 80483df:   83 ec 08                sub    $0x8,%esp\n 80483e2:   e8 02 00 00 00          call   80483e9 &lt;bar&gt;\n 80483e7:   c9                      leave  \n 80483e8:   c3                      ret    \n\n080483e9 &lt;bar&gt;:\n 80483e9:   55                      push   %ebp\n 80483ea:   89 e5                   mov    %esp,%ebp\n 80483ec:   83 ec 08                sub    $0x8,%esp\n 80483ef:   e8 07 00 00 00          call   80483fb &lt;baz&gt;\n 80483f4:   e8 07 00 00 00          call   8048400 &lt;quux&gt;\n 80483f9:   c9                      leave  \n 80483fa:   c3                      ret    \n\n080483fb &lt;baz&gt;:\n 80483fb:   55                      push   %ebp\n 80483fc:   89 e5                   mov    %esp,%ebp\n 80483fe:   5d                      pop    %ebp\n 80483ff:   c3                      ret    \n\n08048400 &lt;quux&gt;:\n 8048400:   55                      push   %ebp\n 8048401:   89 e5                   mov    %esp,%ebp\n 8048403:   b8 00 00 00 00          mov    $0x0,%eax\n 8048408:   c7 00 01 00 00 00       movl   $0x1,(%eax)\n 804840e:   5d                      pop    %ebp\n 804840f:   c3                      ret    \n\n08048410 &lt;main&gt;:\n 8048410:   55                      push   %ebp\n 8048411:   89 e5                   mov    %esp,%ebp\n 8048413:   83 e4 f0                and    $0xfffffff0,%esp\n 8048416:   e8 c1 ff ff ff          call   80483dc &lt;foo&gt;\n 804841b:   b8 00 00 00 00          mov    $0x0,%eax\n 8048420:   c9                      leave  \n 8048421:   c3                      ret    \n</code></pre>\n<p>Note that <code>leave</code> is the same as:</p>\n<pre><code>mov %ebp, %esp\npop %ebp\n</code></pre>\n<p>With this in mind, and the standard-ish C calling convention on x86, we know that the stack at the segfault is going to look like:</p>\n<ol>\n<li><em>top of main's stack frame</em></li>\n<li><em>stack space for main - in this case, enough to align on 16 bytes</em></li>\n<li><code>0x0804841b</code> <em>return address for</em> <code>call foo</code></li>\n<li><em>pointer to <code>1.</code></em></li>\n<li><em>stack space for foo</em></li>\n<li><code>0x080483e7</code> <em>return address for</em> <code>call bar</code></li>\n<li><em>pointer to <code>4.</code></em></li>\n<li><em>stack space for bar</em></li>\n<li><code>0x080483f9</code> <em>return address for</em> <code>call quux</code></li>\n<li><em>pointer to <code>7.</code></em></li>\n<li><em>stack space for quux</em></li>\n</ol>\n<p>The instruction pointer will be <code>0x08048408</code>. <code>ebp</code> will point to <em><code>10.</code></em>.</p>\n<p>At this point, the processor generates an exception, which the operating system processes.  It then sends <code>SIGSEGV</code> to the process, which obligingly terminates and dumps core.  You then bring up the core dump in gdb with <code>gdb -c core</code>, and you type in <code>file a.out</code> and <code>bt</code>, and it gives you in response:</p>\n<pre><code>#0  0x08048408 in quux () at test.c:20\n#1  0x080483f9 in bar () at test.c:12\n#2  0x080483e7 in foo () at test.c:7\n#3  0x0804841b in main () at test.c:24\n</code></pre>\n<p><code>#0</code> is generated from the instruction pointer.  Then, it goes to <code>ebp</code> (10), looks at the previous item on the stack (9), and generates <code>#1</code>.  It follows <code>ebp</code> (i.e. <code>mov %ebp, (%ebp)</code>) to (7), and looks 4 bytes above that (6) to generate <code>#2</code>.  It finally follows (7) to (4) and looks at (3) to generate <code>#3</code>.</p>\n<p><strong>Note:</strong>  This is but one way of doing such stack tracing.  GDB is very, very smart, and can perform the stack trace even when you use <code>-fomit-frame-pointer</code>.  However, in a very basic implementation this is probably the simplest way to generate a stack trace.</p>\n</div>",
            "votes": "25",
            "user": "Robert Mason",
            "time": "May 22, 2013 at 15:40",
            "is_accepted": true,
            "comments": [
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">why not use <code>gcc -S</code> in the first place and get annotated code?</span>",
                    "time": null
                },
                {
                    "user": "Robert Mason",
                    "text": "<span class=\"comment-copy\">I wanted to have real memory addresses that would match up with a stack trace in a live program.  I also think objdump/gdb examples fit the rev-eng theme better.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I like Robert explanation, it has a very good example, but.. I think it misses the point of which is the real purpose of this instruction.  </p>\n<blockquote>\n<p>is done as a debugging aid and in some cases for exception handling</p>\n</blockquote>\n<p>Well.. not really, not only. It is part of the standard function prologue for x86 (32 bit), and it is the (common) technique to set up a function stack frame, so that parameters and locals are accessible as fixed offsets of <code>ebp</code>, which is, after all, the *B*ase frame *P*ointer.</p>\n<p>Making <code>ebp</code> equal to <code>esp</code> at function entry, you will have a fixed, relative pointer inside the stack, that will not change for the lifetime of your function, and you will able to access parameters and locals as (fixed) positive and (fixed) negative offsets, respectively, to <code>ebp</code>.</p>\n<p>You can or cannot see this standard prologue in release, optimized code: optimizers can do (and often do) FPO (frame pointer optimization) to get rid of <code>ebp</code> and just use <code>esp</code> inside your function to access params and locals. This is much trickier (I would not do it by hand) as <code>esp</code> can vary during the function lifetime, and therefore a parameter, for example, can be accessed using 2 different offsets at two distinct points in the code.</p>\n</div>",
            "votes": "23",
            "user": "microtherion",
            "time": "May 25, 2013 at 21:03",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Robert Mason",
                    "text": "<span class=\"comment-copy\">That is true, however in a large amount of compiled code the stack pointer <i>doesn't</i> change over the duration of the function as the compiler just subs once and uses fixed offsets vice push/pop.  For purposes of reverse engineering I'm much more interested in what ebp can tell me about the structure of the program than how it makes the programmer's life easier (especially in compiled code).</span>",
                    "time": null
                },
                {
                    "user": "Robert Mason",
                    "text": "<span class=\"comment-copy\">That being said, thanks for filling the (rather gaping) hole I left in my explanation.</span>",
                    "time": null
                }
            ]
        }
    ]
}