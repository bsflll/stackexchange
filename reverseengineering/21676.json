{
    "title": "Find Target to Call Dword Ptr in 16-bit Windows with IDA Pro",
    "link": "https://reverseengineering.stackexchange.com/questions/21676/find-target-to-call-dword-ptr-in-16-bit-windows-with-ida-pro",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Looking for suggestions on steps that could be used to identify what code would get executed at call dword ptr es:[bx+0Ch] from static analysis. </p>\n<pre><code>cseg04:3044 loc_105D4:                              ; CODE XREF: cseg04:2F10↑j\n    cseg04:3044                 push    0\n    cseg04:3046                 push    34h ; '4'\n    cseg04:3048                 les     bx, ppMalloc\n    cseg04:304C                 push    es\n    cseg04:304D                 push    bx\n    cseg04:304E                 les     bx, es:[bx]\n    cseg04:3051                 call    dword ptr es:[bx+0Ch]\n    cseg04:3055                 add     sp, 8\n    cseg04:3058                 mov     si, ax\n    cseg04:305A                 mov     [bp-6], dx\n    cseg04:305D                 or      dx, ax\n    cseg04:305F                 jnz     short loc_105F8\n</code></pre>\n<p>ppMalloc section:</p>\n<pre><code>eg70:3612 ppMalloc        dd 0                    ; DATA XREF: cseg04:3048↑r\ndseg70:3612                                         ; sub_145C0+24↑r ...\ndseg70:3616 ; ATOM word_10CA26\ndseg70:3616 word_10CA26     dw 0                    ; DATA XREF: sub_4637E:loc_463B1↑r\ndseg70:3616                                         ; sub_4637E+3A↑r ...\ndseg70:3618 word_10CA28     dw 0                    ; DATA XREF: sub_CE2A+1↑o\ndseg70:3618                                         ; cseg03:2F9C↑o ...\ndseg70:361A                 db    0\ndseg70:361B                 db    0\ndseg70:361C                 db    0\ndseg70:361D                 db    0\ndseg70:361E                 db    0\ndseg70:361F                 db    0\ndseg70:3620                 db    0\ndseg70:3621                 db    0\ndseg70:3622                 db    0\ndseg70:3623                 db    0\ndseg70:3624                 db    0\ndseg70:3625                 db    0\ndseg70:3626 unk_10CA36      db    0                 ; DATA XREF: sub_CE2A+A↑o\ndseg70:3626                                         ; cseg03:2F93↑o ...\ndseg70:3627                 db    0\ndseg70:3628                 db    0\ndseg70:3629                 db    0\ndseg70:362A                 db    0\ndseg70:362B                 db    0\ndseg70:362C                 db    0\ndseg70:362D                 db    0\ndseg70:362E                 db    0\ndseg70:362F                 db    0\ndseg70:3630                 db    0\ndseg70:3631                 db    0\ndseg70:3632                 dw 0\n</code></pre>\n</div>",
    "votes": "0",
    "answers": 2,
    "views": "414",
    "tags": [
        "ida",
        "windows"
    ],
    "user": "chentiangemalc",
    "time": "Jul 15, 2019 at 1:29",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>My guess is that <code>ppMalloc</code> is a pointer to an instance of the <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/objidl/nn-objidl-imalloc\" rel=\"nofollow noreferrer\"><code>IMalloc</code></a> COM interface (e.g. it was initialized by a call to <code>CoGetMalloc</code>), which means the the first pointer in it (loaded by the <code>les</code> instruction) is the VTable which has the following methods. </p>\n<p>First three are inherited from IUnknown, the parent of all COM objects:</p>\n<hr/>\n<p>+00 QueryInterface </p>\n<p>+04 AddRef</p>\n<p>+08 Release</p>\n<hr/>\n<p>Followed by the methods of IMalloc proper:</p>\n<hr/>\n<p>+0C <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/objidl/nf-objidl-imalloc-alloc\" rel=\"nofollow noreferrer\">Alloc</a></p>\n<p>+10 DidAlloc</p>\n<p>+14 Free</p>\n<p>+18 GetSize</p>\n<p>+1C HeapMinimize</p>\n<p>+20 Realloc </p>\n<hr/>\n<p>So the code is probably calling <code>IMalloc::Malloc</code> to allocate 0x34 bytes, pointer to which is returned in the <code>ax:dx</code> register pair. </p>\n</div>",
            "votes": "2",
            "user": "Igor Skochinsky",
            "time": "Jul 17, 2019 at 16:43",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>We cannot deduce it from the fragment of code you have provided (unless we are @Igor Skochinsky of course). However, we can notice a few things:</p>\n<ul>\n<li><code>ppMalloc</code> contains the address of dynamically allocated array of function pointers</li>\n<li>the function called by <code>call [bx+0Ch]</code> takes three arguments passed by stack: <code>0</code>, <code>34h</code> (offset?) and a pointer to the address of that dynamically allocated array (that is the address of <code>ppMalloc</code> pointer)</li>\n<li>at line <code>3051</code> <code>es:bx</code> points to the first element of that array and <code>es:[bx+0Ch]</code> is fourth element in it</li>\n<li>depending on the value returned (in <code>dx:ax</code>) the jump at the last line will or won't be performed (<code>or dx, ax</code> checks whether <code>dx:ax</code> is <code>0</code> or not)</li>\n</ul>\n<p>If you have any doubts the comments to the disassembly given below should clarify them.</p>\n<pre><code>cseg04:3044                 push    0 ; push first argument\ncseg04:3046                 push    34h ; '4' ; push the second one\ncseg04:3048                 les     bx, ppMalloc ; es:bx = ppMalloc\ncseg04:304C                 push    es\ncseg04:304D                 push    bx ; push es:bx (ppMalloc)\ncseg04:304E                 les     bx, es:[bx] ; es:bx = *ppMalloc (that is the value stored at dseg70:3612, i.e. pointer to array of function pointers, i.e. pointer to the first element of that array)\ncseg04:3051                 call    dword ptr es:[bx+0Ch] ; call arrayOfFunctionPointers[3] - fourth entry as each entry is probably of dword size\ncseg04:3055                 add     sp, 8 ; restore previous sp value\ncseg04:3058                 mov     si, ax ; si = (returned result) % 2^16\ncseg04:305A                 mov     [bp-6], dx ; [bp-6] = (returned result) / 2^16\ncseg04:305D                 or      dx, ax ; will be 0 &lt;=&gt; (dx = 0 and ax = 0)\ncseg04:305F                 jnz     short loc_105F8\n</code></pre>\n</div>",
            "votes": "2",
            "user": "bart1e",
            "time": "Jul 17, 2019 at 17:44",
            "is_accepted": false,
            "comments": []
        }
    ]
}