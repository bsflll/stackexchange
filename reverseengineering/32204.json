{
    "title": "How can I tell ghidra what structure an address register points to?",
    "link": "https://reverseengineering.stackexchange.com/questions/32204/how-can-i-tell-ghidra-what-structure-an-address-register-points-to",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am reversing a raw bare-metal binary firmware for a tricore processor (TC1762/TC1766).\nIn many functions i'm currently reversing there is access to offsets of the address stored in the a0 register. Therefore a0 points to a definable stucture, that i analysed an defined in the Data Type Manager.</p>\n<p>Examples of access:</p>\n<p>Reading from the structure:</p>\n<pre><code>result = functionCall(*(int *)(a0 + 0x1478),1);\n</code></pre>\n<p>Writing to the structure:</p>\n<pre><code>*(undefined4 *)(a0 + 0x147c) = timeOfLastRequest;\n</code></pre>\n<p>The structure I setup to use:\n<a href=\"https://i.sstatic.net/8atAu.png\" rel=\"nofollow noreferrer\"><img alt=\"Defined the offsets and names as they are accessed\" src=\"https://i.sstatic.net/8atAu.png\"/></a></p>\n<p>Now I want to tell ghidra, to handle a0 as a pointer to this struct. If a0 was just a pointer variable this would work as intented and would make \"a0 + 0x1478\" something like instanceOfCounter-&gt;currentNumber.</p>\n<p>Trying to set a type to a0 will result in an UnsupportedOperationException:\nDatabase supports global memory variables only\njava.lang.UnsupportedOperationException: Database supports global memory variables only</p>\n<p>I am sure there is a way to do this correctly since it would improve the readability of the disassembly so much and would just feel right. I just can't find a way to do this.</p>\n<p>I understand that the context, that a0 points to this struct is probably limited, so this might need to be assigned only for the context of a defined function or something.\nAppreciate any hint</p>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "619",
    "tags": [
        "disassembly",
        "ghidra",
        "firmware-analysis",
        "register",
        "type-reconstruction"
    ],
    "user": "user103675",
    "time": "Aug 24, 2023 at 12:58",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>In Windows Assuming code as below is compiled without debugging info (no PDB)  and loaded in ghidra.</p>\n<p>disabled analysis on loading.</p>\n<p>followed label entry to find the address of function main</p>\n<p>went to main (0x140001000) and hit D to Disassemble and hit F to create a Function</p>\n<pre><code>#include &lt;windows.h&gt;\n#include &lt;winternl.h&gt;\n#include &lt;stdio.h&gt;\nint main(void)\n{\n    PPEB mypeb = (PPEB)__readgsqword(0x60);\n    PRTL_USER_PROCESS_PARAMETERS proparm = mypeb-&gt;ProcessParameters;\n    printf(\"%S\\n\", proparm-&gt;ImagePathName.Buffer);\n}\n</code></pre>\n<p>the decompiled function main would look as below with fuzzy pointer arithmetics and ugly casts</p>\n<pre><code>   undefined8\nFUN_140001000(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  longlong unaff_GS_OFFSET;\n  \n  FUN_1400010a0((longlong)&amp;DAT_1400132e0,\n                *(undefined8 *)(*(longlong *)(*(longlong *)(unaff_GS_OFFSET + 0x60) + 0x20) + 0x68),\n                param_3,param_4);\n  return 0;\n}\n</code></pre>\n<p>there are three pointer arithmetic</p>\n<ol>\n<li>(unaff_GS_OFFSET + 0x60)</li>\n<li>(unaff_GS_OFFSET + 0x60) + 0x20)</li>\n<li>(unaff_GS_OFFSET + 0x60) + 0x20) + 0x68)</li>\n</ol>\n<p>so there must be three unknown structs/artifacts/something/anything...</p>\n<p>lets start making this ugliness go away by adding structures</p>\n<p>In DataTypeManager Select the binary -&gt; right click -&gt;new -&gt;structure</p>\n<p><a href=\"https://i.sstatic.net/DmRsV.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/DmRsV.png\"/></a></p>\n<p>create a new structure name it as <strong>unknown_struct_1</strong> for now<br/>\nunder Description add a comment <code>using only offset 0x60</code><br/>\nenter <strong>0x100</strong> arbitrarily as size</p>\n<p>create 2 more structs the same way <strong>unknown_struct_2</strong><br/>\n<strong>using offset 0x20 only</strong></p>\n<p><strong>unknown_struct_3</strong><br/>\n<strong>using offset 0x68 only</strong></p>\n<p>edit unknown_struct_1 go to offset 0x60 and embed a pointer to unknown_struct_2 and give a Name say \"Needs Name 1\"</p>\n<p>edit unknown_struct_2 go to offset 0x20 and embed a pointer to unknown_struct_3 and give a Name say \"Needs Name 2\"</p>\n<p>after this select the longlong type of GS_OFFSET right click and retype the variable as pointer to unknown_struct_1<br/>\nthe decompilation will improve to</p>\n<pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  FUN_1400010a0((longlong)&amp;DAT_1400132e0,\n                *(undefined8 *)&amp;unaff_GS_OFFSET-&gt;NeedsName_1-&gt;NeedsName2-&gt;field_0x68,param_3,param_4\n               );\n  return 0;\n}\n</code></pre>\n<p>now following 1400132e0 you get a tell tale sign of printf format string</p>\n<pre><code>                        DAT_1400132e0                                   XREF[1]:     FUN_140001000:140001029(*)  \n   1400132e0 25                     ??         25h    %\n   1400132e1 53                     ??         53h    S\n   1400132e2 0a                     ??         0Ah\n</code></pre>\n<p>create a terminated c string at that address right click -&gt; data -&gt; terminatedcstring</p>\n<pre><code>                         s_%S_1400132e0                                  XREF[1]:     FUN_140001000:140001029(*)  \n   1400132e0 25 53 0a 00            ds         \"%S\\n\"\n   1400132e4 00                     ??         00h\n</code></pre>\n<p>the decompilation will further improve to</p>\n<pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  FUN_1400010a0((longlong)\"%S\\n\",\n                *(undefined8 *)&amp;unaff_GS_OFFSET-&gt;NeedsName_1-&gt;NeedsName2-&gt;field_0x68,param_3,param_4\n               );\n  return 0;\n}\n</code></pre>\n<p>change the function signature of 0x1400010a0 to int __cdecl printf(char * formtstring,...) a vararg function</p>\n<p>you will have a still better decompilation</p>\n<pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  printf(\"%S\\n\",*(undefined8 *)&amp;unaff_GS_OFFSET-&gt;NeedsName_1-&gt;NeedsName2-&gt;field_0x68);\n  return 0;\n}\n</code></pre>\n<p><a href=\"https://i.sstatic.net/FNTQ3.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/FNTQ3.png\"/></a></p>\n<p>the format string is %S so it must be printing a wide string (wchar_t *) or probably the buffer in a UNICODE_STRING structure</p>\n<p>lets now go to the unknown_struct_3 at offset 0x68 embed a UNICODE_STRING * and give it a name</p>\n<p><a href=\"https://i.sstatic.net/C2J7q.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/C2J7q.png\"/></a></p>\n<p>now the decompilation is almost nearer to the final shape</p>\n<pre><code>{\n  unknown_struct_1 *unaff_GS_OFFSET;\n  \n  printf(\"%S\\n\",unaff_GS_OFFSET-&gt;NeedsName_1-&gt;NeedsName2-&gt;Some_wide_string);\n  return 0;\n</code></pre>\n<p>now after further reverse engineering  you can infer unaff_GS_OFFSET is pointer to _TEB -&gt;<br/>\nwhose 0ffset 0x60 Contains pointer to _PEB (Process Environemnt Block) -&gt;<br/>\nwhose offset 0x20 contains a pointer to RTL_USER_PROCESS_PARAMETER -&gt;<br/>\nwhose offset 0x68 contains a pointer to Unicode_string  ImagePathName  -&gt;\nwhose offset 0x8 contains a pointer to wchar_t</p>\n<p>so we need to shift the UNICODE_STRING * to 0x60 as UNICODE_STRING struct  so that the member Buffer a wchar_t* will be  at offset 0x68.</p>\n<pre><code>0:000&gt; dt ntdll!_TEB ProcessEnvironmentBlock-&gt;ProcessParameters-&gt;ImagePathName.Buffer\n   +0x060 ProcessEnvironmentBlock                                          :\n      +0x020 ProcessParameters                                                :\n         +0x060 ImagePathName                                                    :\n            +0x008 Buffer                                                           : Ptr64 Wchar\n0:000&gt;\n</code></pre>\n<p>just rename the unknowns and need names</p>\n<p><a href=\"https://i.sstatic.net/Q3WBr.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/Q3WBr.png\"/></a><a href=\"https://i.sstatic.net/bSFxR.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/bSFxR.png\"/></a></p>\n<p>and you have a clean decompilation after changing the function signature of main to int main (void)</p>\n<pre><code>int main(void)\n\n{\n  TEB *MyTeb;\n  \n  printf(\"%S\\n\",(MyTeb-&gt;ProcessEnvironmentBlock-&gt;ProcessParameters-&gt;ImagePathName).Buffer);\n  return 0;\n}\n</code></pre>\n</div>",
            "votes": "2",
            "user": "blabb",
            "time": "Aug 25, 2023 at 17:42",
            "is_accepted": false,
            "comments": [
                {
                    "user": "user103675",
                    "text": "<span class=\"comment-copy\">This is a great description of a nice workflow including the definition and assigning of structures. I think I am so far aware of how this works. My requirement is, that I need to assign a defined struct to a register used directly (a0 in this case). Its not a variable on stack or heap or alike.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">You mean you dont want to have a clean decompilation but  disassembly showing. [foo+ blah.bar] instead of [rbp+0x68]. No ghidra doesnt do it at the moment <a href=\"https://github.com/NationalSecurityAgency/ghidra/issues/2303\" rel=\"nofollow noreferrer\">there is an open issue in github iirc requesting such a feature</a></span>",
                    "time": null
                }
            ]
        }
    ]
}