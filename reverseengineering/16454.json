{
    "title": "Struggling between syscall or sysenter ( Windows )",
    "link": "https://reverseengineering.stackexchange.com/questions/16454/struggling-between-syscall-or-sysenter-windows",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>As I understand, from windows XP, there is a <code>sysenter</code> instruction introduced, instead of <code>int 2e</code> interrupt.</p>\n<p>But on win 10 there is <code>syscall</code> instruction used in ntdll. So is the <code>sysenter</code> used only for x86 windows systems? And <code>syscall</code> only for x64 bit systems?</p>\n</div>",
    "votes": "11",
    "answers": 3,
    "views": "9k",
    "tags": [
        "windows",
        "x86",
        "x86-64",
        "operating-systems",
        "system-call"
    ],
    "user": "PastaAlaCarbonara",
    "time": "Dec 29, 2023 at 2:39",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The Intel and AMD instruction sets are similar but not identical.</p>\n<p>There are many examples of that: FMA3/FMA4, AMD-V and VT-x (and their extensions), etc.</p>\n<p>The fast system call interface is yet another difference.</p>\n<ul>\n<li><p>Intel supports <code>SYSENTER</code> in all modes<sup>1</sup> - Legacy Mode (or, on the few 32-bit only Intel CPUs, simply Protected Mode), Long Mode and Compatibility Mode. (It doesn't work in Real Mode, obviously, and the from now on I'm ignoring it.)</p></li>\n<li><p>Intel supports <code>SYSCALL</code> only in 64-bit Long Mode<sup>2</sup> (not compat. mode). It also requires setting a bit in some MSR.</p></li>\n<li><p>AMD supports <code>SYSENTER</code> only in Legacy Mode<sup>3</sup>, not in any of the Long Mode submodes.</p></li>\n<li><p>AMD supports <code>SYSCALL</code> in all modes<sup>4</sup>.</p></li>\n</ul>\n<p>So as the <a href=\"http://wiki.osdev.org/SYSENTER\" rel=\"noreferrer\">OSDEV page on the topic says</a>:</p>\n<ul>\n<li>In 64-bit Long Mode - only <code>SYSCALL</code> works on both ISAs. (<code>SYSENTER</code> doesn't work on AMD.)</li>\n<li>In Legacy Mode - only <code>SYSENTER</code> works on both ISAs. (<code>SYSCALL</code> doesn't work on Intel.)</li>\n<li>There's no single instruction that works on both Intel and AMD in Compatibility Mode (<code>SYSENTER</code> doesn't work on AMD and <code>SYSCALL</code> doesn't work on Intel), but there's no need for one. A 32-bit kernel will stay in Legacy Mode after boot.</li>\n</ul>\n<hr/>\n<p><sup>1</sup> <a href=\"https://software.intel.com/sites/default/files/managed/7c/f1/253667-sdm-vol-2b.pdf\" rel=\"noreferrer\">Intel® 64 and IA-32 architectures software developer's manual volume 2B: Instruction set reference, M-U</a>, p. 4-668</p>\n<p><sup>2</sup> <a href=\"https://software.intel.com/sites/default/files/managed/7c/f1/253667-sdm-vol-2b.pdf\" rel=\"noreferrer\">Intel® 64 and IA-32 architectures software developer's manual volume 2B: Instruction set reference, M-U</a>, p. 4-666</p>\n<p><sup>3</sup> <a href=\"http://support.amd.com/TechDocs/24594.pdf\" rel=\"noreferrer\">AMD64 Architecture Programmer’s Manual Volume 3: General-Purpose and System Instructions</a>, p. 423</p>\n<p><sup>4</sup> <a href=\"http://support.amd.com/TechDocs/24594.pdf\" rel=\"noreferrer\">AMD64 Architecture Programmer’s Manual Volume 3: General-Purpose and System Instructions</a>, p. 419</p>\n</div>",
            "votes": "16",
            "user": "conio",
            "time": "Oct 9, 2017 at 1:26",
            "is_accepted": false,
            "comments": [
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">Comments have been <a href=\"https://chat.stackexchange.com/rooms/150411/discussion-on-answer-by-conio-struggling-between-syscall-or-sysenter-windows\">moved to chat</a>.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>64-bit user-space always uses <code>syscall</code>, across all x86-64 OSes.</p>\n<p>32-bit user-space under a 32-bit Windows kernel uses <code>sysenter</code> if available.</p>\n<p>WoW64 (32-bit user-space aka Windows, on a 64-bit kernel aka Windows64) uses a <code>call far</code> into a 64-bit ntdll which uses 64-bit <code>syscall</code>.</p>\n<p>Some other OSes, such as Linux, do enter a 64-bit kernel directly from 32-bit user-space, with <code>sysenter</code> or <code>syscall</code> depending on which the CPU supports (via the VDSO which the kernel maps into the address-space of user-space processes).  See <a href=\"https://stackoverflow.com/questions/77678700/calling-system-api-from-32-bit-processes-under-linux-64-bit/77680771#77680771\">Calling system API from 32-bit processes under Linux 64-bit</a> for more details on <code>syscall</code> vs. <code>sysenter</code> and which modes they're available in on different CPUs, and the fact that legacy-mode (32-bit kernel) <code>syscall</code> is so badly designed (from a Linux kernel perspective at least) that Linux doesn't use it even if that means a fallback to <code>int 0x80</code>.</p>\n<hr>\n<p>WoW64's <code>call far</code> / <code>retf</code> nearly doubles the cost of getting into the kernel and back for 32-bit user-space (compared to <code>sysenter</code>), but isn't a big fraction of the total time for most system calls.  This has always seemed like an inefficient design to me, so I wonder if they chose it only because there's no single instruction that works from 32-bit compat mode under a 64-bit kernel on both Intel and AMD x86-64 CPUs.  Or it there's useful stuff that can be done in user-space to avoid calling into the kernel at all, but only with 64-bit code?</p>\n<p>A faster system-call instruction is something that OS devs do care about, e.g. <a href=\"https://devblogs.microsoft.com/oldnewthing/20041215-00/?p=37003\" rel=\"nofollow noreferrer\">Raymond Chen's blog</a> about how on 386, the illegal instruction trap was the fastest way into the kernel so Windows used that.</p>\n<p>A <code>call far [mem]</code> / <code>retf</code> pair on i7-6700k Skylake takes 220 core clock cycles when measured in a simple microbenchmark loop.  From 32-bit user-space to 64-bit user-space, or from 32 to 32 costs the same.  <a href=\"https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1BMFSlgCNaAT1JL6yAngGVG6AMKpaAVxYMQANlJXABk8BkwAOR9zTGIQAFYNUgAHVAVCJwYPb18AlLSMgVDwqItYhKS7TAdMoQImYgJsnz9AqpqBOoaCYsjo8sTbesbm3LbhnrC%2BsrjEgEpbVC9iZHYOAFIAZgAhLe2AahMWAFpaMIBrfeOGffWAJjuAEgJ7u4A6I9u7/3v/ffqFOclAQrsh9lx9slYlR9gp6iDjscxLRjl4lMQrpgAedjshaKhkOdSGhBJhVARjgoAO6EZAITAKYnJLzHFh4YDEJiOASM5JMYCYY5UJheWgERnIKx4hmkcychh0mVhOHELwdBiMryoZIKAD6eFMXkw6A%2BDBsWp1uuIWLw1pN1sc1t1Cnx4tIFr1ZOqXgIxreBAQ1qY6CuxDu%2BzeAHpXs9XusNABBeNJnZ7fbMBQsK5UTC0KibcO%2BuH47UfTPJvZp2gh1m5qj6zYADj%2Bx1Q/wZBBLyXbxdQpdQFdTO3%2BJiBWNB4Mh0Nh8KuSNoKLRsUx2Nx%2BMJxNkZIp1Np9IlzNZ7M53I1KX5guFordkuljOVBFV6s12r1BoURpNhnNr91XuQPp%2BgGQboOQ6AAI5vGyvq6h6sryoqCihhCUZFp2fbJBWiZYFeYr7NatAVnc8RLrCLDdGI7IMMmlHAAwLAYJgkKBPs/iSFhCbAPi5hiPszoTMm/HdCAyb7GJkJogg%2BwaKomybOJCkKWmMl3PJBr7MUXiqGAHBIQWxzmIQ%2BxLsQlJ8qs%2BxoFgsKYMAbCCGmhA6UhDBtsKcKxGAYCieJzIKFJaE%2BWJDEAG5idUqikPsDKYYmCmhYpmDmMkUVcBo6UZRoNFnHRrHsYmbxdiJiZpuJogLtJsmbCAaGKWmmmqMZShIW4QhbAAIjJcn7PwGImWZTAWWxBlGQxWCDgcZXIpVck1R2dXDncjXlbQPUNJCj5cP4IAFiO5wMvskh3I2llSvQjKwm2dxSNFg0IEFlnTcKGLrPE2wRa97ULQcS2PRVz23G9bAsJ9e0HZIkgaKdd5RQoV13FDmB3Q9K1rS9b0ffE7UPVgYJJbFCYKdoDAAF4Rl2yZvK4xVJnF4mqCQ0XmJFSWqA9CVI5FELfXxuoRAASn%2BqhGT1xCoFmkZosQkZhHiXhYJGRySwwBoEOguoFm89102JYQgjJjZQ4ptzDgoViesLBAQBocwcbRNwFsmhninlyZoTTYlprj%2BFMI1xsmwcAbqVSSzVvsuOMYcSEECH%2BwPk%2Bp5xw7dwjSCY2YLDbZQsQMJoF4pLEEhJI0MQWZUkxwCoCC9LWkneWp/s6c%2BQ6VAcfc8R4DCWUlUOuy95Ww6HA4Xi8dnMLWh%2BYpIVQYtZiwViN3dUxRXgADsxz%2BKv6WXDSAb7NgyjKB1PEGAqmC6mPJDkWfE0D3399pgI%2BwJisUkAOIRHIkYNVF%2B3EOEq1DAhjHvsEKsR0hP38G8eIHFsTAgnBCEBcIuRzmRKidEK5RxrgJESEkvpySUl3ohJkLI2Qci5JkXkF4hQiinsSM6SoNSPjVKeF8lp3yflND%2BS0/5AImmAkjUCeAIJQUIOfOCcpDCITEqhDsFMSpxWUNCK%2BUimJ5wLjOLk09GY6Vkb2bUOkaYPWNlwUgXA7gAE43ir3kiwJQYJVx4hwf7FxLj7jyXElwN4GV9huGUIoYyjgzgk2NK4pSOswkKSNgpPB25CF7gOpEuqqkonePSvsSM9iklhOMUk6JZVDxkJPJQ7Jxt3GpJ8Zk6opS3EROydzBSfIBQ0OvEhGpZSUniQ0G8RsjZ4gZKye0uqdTpCQzuKQRsmwLGkHiH042t5zpDJyZ0sSmwekWNXvsN%2BAAJMmSzwmE39v4JIGVSCbHiJIY28cWElP2V8DxYlukaG5sqG42dob0CScY0x8Q0qkA0L0iZFiHniQ9PqQ0fpvxLPKZ4t4clNlvyqWCO53yZl/IBYEVe/h%2BmKTBbw30/DAyCOyTCsSXj4VbKRXc24dTPEnPSv835VyRHQXEa%2BFFKz9iNh6fEcMABZKlKLaViUGKczYkgGniUkQqfc1KlIrIhm8YiFj9gCsGfsji/svFcE2OleImxV6r36fYgQ6Bo54DYNFAwOpjSapMW8cxFjJAWOOekk1DAzVNViLk6SaTMo%2BPdZ6s2CgiLxFcJ3DgCxaCcHiLwPwHAtCkFQJwBMphMAWGsJdZYFl3E8FIAQTQkaFjnB2tyixLqNmbH8HcGxqlGzEX0JwSQcbC1Js4LwBQIAkgFoTZG0gcBYAwEQCgcWyQ6CxHIJQNALAx30DiBmFg11jmmJoGKcBlBzCtsMswYgVhOB5u3Q0KwAB5cw2hqg9rzdO%2ByBBj0MGsK2rA5gvDADcMiTt3BeBYGvlxNYib8DWhqGAj9ib8VrDzXrXMraziSN3R4LArbHwWv3X2qgBhgAKAAGp4EwFSY9UJ415v4IIEQYh2BSBkIIRQKh1C9tILoUxp9jBpozTYGDnbIALG1KwzgQorX5juLwVAYDiDEGEQyeACx2inhcB60YfhxVBA9b0UoMQ4jTNSOkU88mdrSE04UBgKn%2BjqdsLmC9tQJg6cU9Jiz3QjMzBANM5BIxPAtF00MOzUxVPlAsVJpYKxyNRpjS2ujyaOD7AiAmIQfL9jvC2t4iEEBcCEEZrmuYvAe1aDmMWiQDLo0cGbaQFgIBV5xYeDqiGsyuBcGBeM%2BNiawsdq7fmwtCwB3DqWAQZkBBJ0QGnbO2IERWBrFUM2DelzgDIDBDqpVvBjQpbE%2BgPQxHhDlXI9IFb1G1CtoY6QKknJkgoaCxwWNpB6tCc4Men03X9ioBhJF6LsWHVQOefsCAHgZ3jpeqpLg6WWu9uy6QekwZygQGO4V4rNaemGubPEC5XBekaH8IC87baOBNe7a1nL/gvHpV1d8A13wsUI8bRwTYIWGvtv%2B1l47gmzutsa9TotpARMQL8JIIAA\" rel=\"nofollow noreferrer\">NASM source with <code>perf</code> results</a> for a static Linux executable I used to test by running <code>perf</code> on the whole program.  With basically no startup overhead, and running enough iterations to run for over a second, this gives pretty accurate measurements.</p>\n<p>A do-nothing system call with an invalid syscall number (EAX=-1) takes 1209 cycles on the same system, Linux kernel 6.5 with Spectre + Meltdown mitigation, including swapping page tables.  So an extra call far + retf is about 18% extra cost for a do-nothing system call in the best case with caches hot.</p>\n<p>I also tested <code>call far</code> / 64-bit <code>syscall</code> / <code>retf</code> (1439 cycles) vs. <code>int 0x80</code> (1772 cycles) vs. <code>sysenter</code> (1305 cycles), average cost in a tight loop.  This is on x86-64 Linux 6.5 on my i7-6700k Skylake, with EAX=-1, so it returns <code>-ENOSYS</code> without dispatching to a <code>sys_whatever</code> function, but still does a bunch of stuff inside the kernel.  (It's optimized for the case of system calls that don't error, so it doesn't check that until it's ready to dispatch to a handler function.)  So WoW64's strategy is better than using <code>int 0x2e</code>, at least on Skylake and probably most CPUs.  But it's worse than using <code>sysenter</code> on CPUs that support that from compat mode.</p>\n<p>The 134 cycle delta between the WoW64 strategy and <code>sysenter</code> isn't as big as <code>call far</code> / <code>retf</code> alone, so maybe 32-bit <code>sysenter</code> is slower than 64-bit <code>syscall</code>, or the Linux kernel internals are different for compat-mode system calls vs. native 64-bit syscalls.</p>\n<hr/>\n<p><code>call far</code> / <code>retf</code> was somewhat less slow on older CPUs (when 32-bit code was even more common on Windows), for example <a href=\"https://agner.org/optimize/\" rel=\"nofollow noreferrer\">Agner Fog</a> measured <code>call far [mem]</code> at 79 cycles on Nehalem (microcoded as 47 uops), plus <code>retf</code> taking 120 cycles, for a total of 199 cycles for a pair.  Or 153 for call far+retf on Core 2.  But only 33 cycles in AMD K8 and K10.  Agner didn't measure <code>call far</code> or <code>retf</code> for CPUs newer than that.</p>\n<p>32-bit code is still not rare on Windows, where some projects are built around binary-only DLLs.  The software ecosystem around other OSes is less binary-centric, and some current Linux distros are even considering disabling running 32-bit executables in the kernel, at least by default.</p>\n</hr></div>",
            "votes": "3",
            "user": "Peter Cordes",
            "time": "Dec 19, 2023 at 23:27",
            "is_accepted": false,
            "comments": [
                {
                    "user": "conio",
                    "text": "<span class=\"comment-copy\">Wow, great answer. Really knowledgeable. There's quite a lot of information here. Could you cite a <i>reputable</i> source that says that \"32-bit code is still not rare on Windows\" and <i>how common</i> is it? I've spent quite some time looking for <i>public</i> data on this and couldn't find any. On my machine I have 9/405 processes that are 32-bit (4 of those belong to VMware Workstation), which doesn't sounds like a lot. I might actually describe 9 out of 405 as \"rare\". But my machine probably doesn't represent the entire world, and I'm sure you have better data available. Mind you sharing it?</span>",
                    "time": null
                },
                {
                    "user": "Peter Cordes",
                    "text": "<span class=\"comment-copy\">@conio: I could be wrong about that!  I was under the impression that a decent amount of 3rd-party software was still 32-bit only, but maybe that's changed in the past several years.  My Linux desktop has zero 32-bit processes, normal for GNU/Linux systems.  In any case, when the WoW64 design-decisions were being made in the early 2000s, 32-bit software was absolutely widespread, and they expected 32-bit user-space to be important for years.  It's probably not worth changing now, but it's interesting to evaluate the choices of different OSes.</span>",
                    "time": null
                },
                {
                    "user": "Peter Cordes",
                    "text": "<span class=\"comment-copy\">@conio: In chat linked under your answer, you claimed that it was common for OSes to deprecate 32-bit user-space entirely.  Yes, x86-64 macOS did that for example, and Linux is starting to, but this is a Windows question.  Stack Overflow questions about how to use a 32-bit DLL still get asked in 2023, so people are still actively developing code but wanting to use a 32-bit DLL they have.  Google <code>site:stackoverflow.com 32-bit dll 64-bit</code> (filter to this year) to find Qs like <a href=\"https://stackoverflow.com/q/75951175\">How to link against x86 .lib on x64 machine with rustc (64 bit) on Windows?</a></span>",
                    "time": null
                },
                {
                    "user": "Peter Cordes",
                    "text": "<span class=\"comment-copy\">@conio: And re: Visual Studio (the IDE itself) being 32-bit for performance reasons (or because the codebase took a lot of work to get it 64-bit clean?), that was a true fact for many years. It only changed in 2022!  Before that, no 64-bit version was available!  A 2010 MS blog attempted to justify it (<a href=\"https://web.archive.org/web/20160309232651/http://blogs.msdn.com/b/ricom/archive/2009/06/10/visual-studio-why-is-there-no-64-bit-version.aspx\" rel=\"nofollow noreferrer\">web.archive.org/web/20160309232651/http://blogs.msdn.com/b/…</a>).  But <a href=\"https://stackoverflow.com/q/2516436\">Visual Studio 64 bit?</a> on SO has lots of comments from people unimpressed with a 4GiB limit.</span>",
                    "time": null
                },
                {
                    "user": "Peter Cordes",
                    "text": "<span class=\"comment-copy\">@conio: So WoW64 was necessary for one of MS's own flagship apps until 2022. I think that's sufficient evidence of it being relevant.  The major selling point of x86 has historically been backwards-compatibility, and the Windows + x86 software ecosystem has always been more binary-centric than most, and encumbered with legacy binaries that people don't have source for.  As well as some new binaries being built as 32-bit.  That's getting rarer, but due to 32-bit DLLs it's not going away any time soon.  It's implausible that MS would drop WoW64 this decade.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><code>syscall</code> (created by AMD) and <code>sysenter</code> (created by Intel) are competing implementations of fast switch-to-ring0 instructions.  For compatibility, x64 systems support both types.  That wasn't deemed to be necessary for 32-bit systems.</p>\n</div>",
            "votes": "-1",
            "user": "0xC0000022L",
            "time": "Dec 19, 2023 at 10:29",
            "is_accepted": false,
            "comments": [
                {
                    "user": "conio",
                    "text": "<span class=\"comment-copy\">This is wrong. And mentioned in the links I put in my comment on the question. In Long Mode, <code>SYSCALL</code> is the only one supported both on AMD64 and on Intel 64. The AMD manual says explicitly on the page on <code>SYSENTER</code> \"An invalid-opcode exception occurs if this instruction is used in long mode. Software should use the SYSCALL (and SYSRET) instructions in long mode.\"</span>",
                    "time": null
                }
            ]
        }
    ]
}