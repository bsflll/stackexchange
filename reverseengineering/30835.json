{
    "title": "Programmatically Find COM Object Method Offset in Image from Method Name",
    "link": "https://reverseengineering.stackexchange.com/questions/30835/programmatically-find-com-object-method-offset-in-image-from-method-name",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>What is a way to lookup a COM method offset with an image, just based on the module name and method name.</p>\n<p>For example want to find \"Exec\" method in \"WScript.Shell\" In this scenario we know the method is in wshom.ocx. In this case it is relatively easy to find with the public symbols.</p>\n<p>We can find the vtable :</p>\n<pre><code>.text:7B471070 ; const CWshShell::`vftable'{for `IWshShell3'}\n.text:7B471070 ??_7CWshShell@@6BIWshShell3@@@ dd offset ?QueryInterface@CWshExec@@UAGJABU_GUID@@PAPAX@Z\n.text:7B471070                                         ; DATA XREF: CWshShell::Create(IUnknown *)+74↓o\n.text:7B471070                                         ; CWshShell::`scalar deleting destructor'(uint)+B↓o\n.text:7B471070                                         ; CWshExec::QueryInterface(_GUID const &amp;,void * *)\n.text:7B471074                 dd offset ?AddRef@CWebPreviewDispatch@@EAGKXZ ; CWebPreviewDispatch::AddRef(void)\n.text:7B471078                 dd offset ?Release@?$CAggregatedUnknown@$02@@UAGKXZ ; CAggregatedUnknown&lt;3&gt;::Release(void)\n.text:7B47107C                 dd offset ?GetTypeInfoCount@CWshExec@@UAGJPAI@Z ; CWshExec::GetTypeInfoCount(uint *)\n.text:7B471080                 dd offset ?GetTypeInfo@CWshShell@@UAGJIKPAPAUITypeInfo@@@Z ; CWshShell::GetTypeInfo(uint,ulong,ITypeInfo * *)\n.text:7B471084                 dd offset ?GetIDsOfNames@CWshShell@@UAGJABU_GUID@@PAPAGIKPAJ@Z ; CWshShell::GetIDsOfNames(_GUID const &amp;,ushort * *,uint,ulong,long *)\n.text:7B471088                 dd offset ?Invoke@CWshShell@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ; CWshShell::Invoke(long,_GUID const &amp;,ulong,ushort,tagDISPPARAMS *,tagVARIANT *,tagEXCEPINFO *,uint *)\n.text:7B47108C                 dd offset ?get_SpecialFolders@CWshShell@@UAGJPAPAUIWshCollection@@@Z ; CWshShell::get_SpecialFolders(IWshCollection * *)\n.text:7B471090                 dd offset ?get_Environment@CWshShell@@UAGJPAUtagVARIANT@@PAPAUIWshEnvironment@@@Z ; CWshShell::get_Environment(tagVARIANT *,IWshEnvironment * *)\n.text:7B471094                 dd offset ?Run@CWshShell@@UAGJPAGPAUtagVARIANT@@1PAH@Z ; CWshShell::Run(ushort *,tagVARIANT *,tagVARIANT *,int *)\n.text:7B471098                 dd offset ?Popup@CWshShell@@UAGJPAGPAUtagVARIANT@@11PAH@Z ; CWshShell::Popup(ushort *,tagVARIANT *,tagVARIANT *,tagVARIANT *,int *)\n.text:7B47109C                 dd offset ?CreateShortcut@CWshShell@@UAGJPAGPAPAUIDispatch@@@Z ; CWshShell::CreateShortcut(ushort *,IDispatch * *)\n.text:7B4710A0                 dd offset ?ExpandEnvironmentStringsA@CWshShell@@UAGJPAGPAPAG@Z ; CWshShell::ExpandEnvironmentStringsA(ushort *,ushort * *)\n.text:7B4710A4                 dd offset ?RegRead@CWshShell@@UAGJPAGPAUtagVARIANT@@@Z ; CWshShell::RegRead(ushort *,tagVARIANT *)\n.text:7B4710A8                 dd offset ?RegWrite@CWshShell@@UAGJPAGPAUtagVARIANT@@1@Z ; CWshShell::RegWrite(ushort *,tagVARIANT *,tagVARIANT *)\n.text:7B4710AC                 dd offset ?RegDelete@CWshShell@@UAGJPAG@Z ; CWshShell::RegDelete(ushort *)\n.text:7B4710B0                 dd offset ?LogEvent@CWshShell@@UAGJPAUtagVARIANT@@PAG1PAF@Z ; CWshShell::LogEvent(tagVARIANT *,ushort *,ushort *,short *)\n.text:7B4710B4                 dd offset ?AppActivate@CWshShell@@UAGJPAUtagVARIANT@@0PAF@Z ; CWshShell::AppActivate(tagVARIANT *,tagVARIANT *,short *)\n.text:7B4710B8                 dd offset ?SendKeys@CWshShell@@UAGJPAGPAUtagVARIANT@@@Z ; CWshShell::SendKeys(ushort *,tagVARIANT *)\n.text:7B4710BC                 dd offset ?Exec@CWshShell@@UAGJPAGPAPAUIWshExec@@@Z ; CWshShell::Exec(ushort *,IWshExec * *)\n.text:7B4710C0                 dd offset ?get_CurrentDirectory@CWshShell@@UAGJPAPAG@Z ; CWshShell::get_CurrentDirectory(ushort * *)\n.text:7B4710C4                 dd offset ?put_CurrentDirectory@CWshShell@@UAGJPAG@Z ; CWshShell::put_CurrentDirectory(ushort *)\n</code></pre>\n<p>In this case offset at 7B4710BC points to the method I'm looking into. However I'm trying to more generally resolve this when there are no symbols available.</p>\n<p>Analyzing the following with WinDbg:</p>\n<pre><code>\"C:\\WINDOWS\\syswow64\\WindowsPowerShell\\v1.0\\powershell.exe\" -Command \"$obj = New-Object -ComObject WScript.Shell;$obj.Exec('notepad')\"\n</code></pre>\n<p>Found that <strong>C:\\WINDOWS\\Microsoft.Net\\assembly\\GAC_MSIL\\System.Management.Automation\\v4.0_3.0.0.0__31bf3856ad364e35\\System.Management.Automation.dll</strong> has a method <code>System.Management.Automation.ComInterop.ComTypeDesc.TryGetFunc(System.String, System.Management.Automation.ComInterop.ComMethodDesc ByRef)</code></p>\n<p>Which is taking \"Exec\" as the first parameter, and seems to internally use a hash table to find the method, but couldn't see how the hash table is initially populated.</p>\n<p>Eventually the function is called via Oleaut32!DispCallFunc which seems to have a function definition like:</p>\n<pre><code>HRESULT __stdcall DispCallFunc(\n        void *pvInstance,\n        ULONG_PTR oVft,\n        CALLCONV cc,\n        VARTYPE vtReturn,\n        UINT cActuals,\n        VARTYPE *prgvt,\n        VARIANTARG **prgpvarg,\n        VARIANT *pvargResult)\n</code></pre>\n<p>In this case pvInstance is pointing to the vfTable in the COM object, and oVft is the offset for the specific target method.</p>\n<p>Essentially I am trying to work out how do I calculate the vftable offset for \"WScript.Shell\" (with the module name already known)(, and oVft offset for method i.e. \"Exec\", even without symbols for a COM method.</p>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "101",
    "tags": [
        "windows",
        "com"
    ],
    "user": "chentiangemalc",
    "time": "Aug 30, 2022 at 13:58",
    "comments": [
        {
            "user": "Remko",
            "text": "<span class=\"comment-copy\">If there is a typelib you can obtain an <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/oaidl/nn-oaidl-itypelib\" rel=\"nofollow noreferrer\"><code>ITypeLib</code></a> interface using <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/oleauto/nf-oleauto-loadtypelibex\" rel=\"nofollow noreferrer\"><code>LoadTypeLibEx</code></a>. <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/oaidl/nf-oaidl-itypeinfo-addressofmember\" rel=\"nofollow noreferrer\"><code>ITypeInfo::AddressOfMember</code></a> might do what you need?</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>In your example, the Exec method is actually implemented in IWshShell3 as can be seen in the typelib:</p>\n<pre><code>[Guid(\"41904400-be18-11d3-a28b-00104bd35090\")]\ninterface IWshShell3\n{\n   /* Methods */\n   int Run(string Command, [Optional] Object&amp; WindowStyle, [Optional] Object&amp; WaitOnReturn);\n   int Popup(string Text, [Optional] Object&amp; SecondsToWait, [Optional] Object&amp; Title, [Optional] Object&amp; Type);\n   object CreateShortcut(string PathLink);\n   string ExpandEnvironmentStrings(string Src);\n   object RegRead(string Name);\n   void RegWrite(string Name, Object&amp; Value, [Optional] Object&amp; Type);\n   void RegDelete(string Name);\n   bool LogEvent(Object&amp; Type, string Message, [Optional] string Target);\n   bool AppActivate(Object&amp; App, [Optional] Object&amp; Wait);\n   void SendKeys(string Keys, [Optional] Object&amp; Wait);\n   WshExec Exec(string Command);\n   /* Properties */\n   IWshCollection SpecialFolders { get; }\n   IWshEnvironment Environment([Optional] Object&amp; Type) { get; }\n   string CurrentDirectory { get; set; }\n}\n</code></pre>\n<p>With the following quick test code I was able to get an offset for the methods:</p>\n<pre><code>procedure Main;\nconst\n  Filename: String = 'C:\\Windows\\SysWOW64\\wshom.ocx';\n  MethodName: PChar = 'Exec';\n  CLSID_WshShell3: TGuid = '{41904400-BE18-11D3-A28B-00104BD35090}';\nvar\n  tlib: ITypeLib;\n  hr: HRESULT;\n  i: Integer;\n  tinfo: ITypeInfo;\n  typeattrib: PTypeAttr;\n  j: Integer;\n  FuncDesc: PFuncDesc;\n  Name: WideString;\n  OffSet: DWORD;\nbegin\n  CoInitialize(nil);\n\n  OleCheck(LoadTypeLibEx(PChar(Filename), REGKIND_NONE, tlib));\n\n  for i := 0 to tlib.GetTypeInfoCount-1 do\n  begin\n    hr := tlib.GetTypeInfo(i, tinfo);\n    if Succeeded(hr) then\n    begin\n      hr := tinfo.GetTypeAttr(typeattrib);\n      if Succeeded(hr) then\n      begin\n        if IsEqualGuid(CLSID_WshShell3, typeattrib.guid) then\n        begin\n          WriteLn('Found IWshShell3');\n          for j := 0 to typeattrib.cFuncs-1 do\n          begin\n            hr := tinfo.GetFuncDesc(j, FuncDesc);\n            if Succeeded(hr) then\n            begin\n              hr := tinfo.GetDocumentation(FuncDesc.memid, @Name, nil, nil, nil);\n              if Succeeded(hr) then\n              begin\n               OffSet := j * SizeOf(Pointer);\n               WriteLn(Format('Found Method %s at Offset: %d', [Name, Offset]));\n                end;\n\n                tinfo.ReleaseFuncDesc(FuncDesc);\n              end;\n\n            end;\n          end;\n\n        tinfo.ReleaseTypeAttr(typeattrib);\n      end;\n    end;\n  end;\n\nend;\n</code></pre>\n<p>Output:</p>\n<pre><code>Found IWshShell3\nFound Method QueryInterface at Offset: 0\nFound Method AddRef at Offset: 4\nFound Method Release at Offset: 8\nFound Method GetTypeInfoCount at Offset: 12\nFound Method GetTypeInfo at Offset: 16\nFound Method GetIDsOfNames at Offset: 20\nFound Method Invoke at Offset: 24\nFound Method SpecialFolders at Offset: 28\nFound Method Environment at Offset: 32\nFound Method Run at Offset: 36\nFound Method Popup at Offset: 40\nFound Method CreateShortcut at Offset: 44\nFound Method ExpandEnvironmentStrings at Offset: 48\nFound Method RegRead at Offset: 52\nFound Method RegWrite at Offset: 56\nFound Method RegDelete at Offset: 60\nFound Method LogEvent at Offset: 64\nFound Method AppActivate at Offset: 68\nFound Method SendKeys at Offset: 72\nFound Method Exec at Offset: 76\nFound Method CurrentDirectory at Offset: 80\nFound Method CurrentDirectory at Offset: 84\n</code></pre>\n<p>Probably need to do more checking but hopefully this gives you a start and of course, a typelib is needed. The Offset is the offset from the Interface pointer.</p>\n</div>",
            "votes": "2",
            "user": "Remko",
            "time": "Aug 29, 2022 at 13:38",
            "is_accepted": true,
            "comments": []
        }
    ]
}