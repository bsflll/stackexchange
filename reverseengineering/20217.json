{
    "title": "Can Machine Learning be used to develop better reverse engineering tools? [duplicate]",
    "link": "https://reverseengineering.stackexchange.com/questions/20217/can-machine-learning-be-used-to-develop-better-reverse-engineering-tools",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<div>\n<aside class=\"s-notice s-notice__info post-notice js-post-notice mb16\" role=\"status\">\n<div class=\"d-flex fd-column fw-nowrap\">\n<div class=\"d-flex fw-nowrap\">\n<div class=\"flex--item wmn0 fl1 lh-lg\">\n<div class=\"flex--item fl1 lh-lg\">\n<div>\n<b>This question already has answers here</b>:\n                                \n                            </div>\n</div>\n</div>\n</div>\n<div class=\"flex--item mb0 mt4\">\n<a dir=\"ltr\" href=\"/questions/18866/can-ai-be-used-to-write-better-decompilers-disassemblers\">Can AI be used to write better decompilers/disassemblers? [closed]</a>\n<span class=\"question-originals-answer-count\">\n                                (4 answers)\n                            </span>\n</div>\n<div class=\"flex--item mb0 mt8\">Closed <span class=\"relativetime\" title=\"2019-01-04 13:01:55Z\">6 years ago</span>.</div>\n</div>\n</aside>\n</div>\n<p>So i googled this but other than some papers i couldnt find any reverse engineering tool that was built using machine learning</p>\n<p>I'm not an expert in machine learning and deep learning but it seems rational to think that considering we have billions of open source codes out there, we can use them so our \"machine\" can learn how the assembly and executable of these codes look like and just study on them, mastering the art of reversing, and therefore building a tool this way that can reverse any given program with a great accuracy </p>\n<p>Now is this doable or am i missing something here? is there any tool built this way or on its way to coming out? what are your thoughts on this? is better reversing tool even needed or is there  already a great reversing tool that can do the job with the best accuracy possible? </p>\n</div>",
    "votes": "3",
    "answers": 2,
    "views": "4k",
    "tags": [
        "disassembly",
        "tools",
        "disassemblers",
        "machine-code"
    ],
    "user": "John P",
    "time": "6 years ago",
    "comments": [
        {
            "user": "Oded Ben Dov",
            "text": "<span class=\"comment-copy\">This article discusses this: <a href=\"https://www.researchgate.net/publication/287463203_Automating_Reverse_Engineering_with_Machine_Learning_Techniques\" rel=\"nofollow noreferrer\">researchgate.net/publication/…</a></span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>If you consider genetic algorithms as a type of machine learning, here’s an interesting post on using it to create an assembler from opcodes and disassembler:</p>\n<p><a href=\"https://binary.ninja/2018/06/19/fast-track-to-assembler-writing.html\" rel=\"nofollow noreferrer\">A Fast Track To Assembler Writing</a></p>\n<p>You can also check Joxean Koret’s experience on using ML to match binaries to source code, including with machine learning:</p>\n<p><a href=\"https://docs.google.com/presentation/d/1ifvugStGL7Qc8xSFeYXp2MGQ6jQGOOMSolBrJy8kCMY/mobilepresent\" rel=\"nofollow noreferrer\">https://docs.google.com/presentation/d/1ifvugStGL7Qc8xSFeYXp2MGQ6jQGOOMSolBrJy8kCMY/mobilepresent</a></p>\n<p><a href=\"https://github.com/joxeankoret/pigaios\" rel=\"nofollow noreferrer\">https://github.com/joxeankoret/pigaios</a></p>\n</div>",
            "votes": "3",
            "user": "Igor Skochinsky",
            "time": "Apr 10, 2019 at 14:17",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<blockquote>\n<p>we can use them so our \"machine\" can learn how the assembly and\n  executable of these codes look like and just study on them, mastering\n  the art of reversing, and therefore building a tool this way that can\n  reverse any given program with a great accuracy</p>\n</blockquote>\n<p>This is a pipe dream for several reasons:</p>\n<ol>\n<li><p>Reliably differentiating between code and data in an executable binary is an undecidable problem. Data can be embedded in code, and the same sequence of bytes may be disassembled in different ways. Furthermore, code may be self-modifying. See </p>\n<ul>\n<li><a href=\"https://reverseengineering.stackexchange.com/questions/2580/why-is-disassembly-not-an-exact-science\">Why is disassembly not an exact science?</a></li>\n<li><a href=\"https://reverseengineering.stackexchange.com/questions/8328/soundness-of-arm-disassembly\">Soundness of ARM disassembly</a></li>\n</ul></li>\n<li><p>Function start detection in stripped binaries is an undecidable problem.</p>\n<ul>\n<li><a href=\"https://binary.ninja/2017/11/06/architecture-agnostic-function-detection-in-binaries.html\" rel=\"nofollow noreferrer\">Architecture Agnostic Function Detection in Binaries</a></li>\n</ul></li>\n<li><p>Compilation is a lossy process, particularly when optimization takes place. Therefore decompilation cannot be fully automated and requires human decision making.</p>\n<ul>\n<li><blockquote>\n<p>Certainly, full automatic decompilation of arbitrary machine-code\n  programs is not possible, it is an undecidable problem like most\n  problems of program transformation. So, from the point of view of\n  theory no algorithm exists for  decompilation of all possible\n  programs. However, this (obvious) answer has no practical importance —\n  many problems are undecidable or NP-complete yet there exist\n  algorithms giving precise or approximate solutions for practical\n  important cases. Thus the challenges of decompilation are in\n  identification of subclasses of low-level programs and developing\n  methods and algorithms targeted for these particular classes. The\n  methods may even ask a human expert for help at key points. [ 1 ]</p>\n</blockquote></li>\n<li><blockquote>\n<p>Certainly, fully automated decompilation of arbitrary machine-code programs is not possible -- this problem is theoretically equivalent to the Halting Problem, an undecidable problem in Computer Science. What this means is that automatic (no expert intervention) decompilation cannot be achieved for all possible programs that are ever written. Further, even if a certain degree of success is achieved, the automatically generated program will probably lack meaningful variable and function names as these are not normally stored in an executable file (except when stored for debugging purposes). [ 2 ]</p>\n</blockquote></li>\n<li><a href=\"https://softwareengineering.stackexchange.com/questions/229761/why-cant-native-machine-code-be-easily-decompiled\">Why can't native machine code be easily decompiled?</a></li>\n</ul></li>\n<li><p>Machine learning - in this case, supervised learning - can simplistically be thought of  as using algorithms to construct models from data, and the constructed model is then used for prediction or classification. When we say that an algorithm is is learning from data, it means that an algorithm is building a mathematical model by optimizing a loss function for the given data. There is no mind, no thought, no thinking machine. Algorithms do not look at anything, nor do they study anything.</p></li>\n</ol>\n<p><hr/>\n1) <a href=\"https://pdfs.semanticscholar.org/541d/cc3c558d8e53377886bc755f693d9fe2a582.pdf\" rel=\"nofollow noreferrer\">C Decompilation: Is It Possible?</a></p>\n<p>2) <a href=\"http://www.program-transformation.org/Transform/DecompilationPossible\" rel=\"nofollow noreferrer\">Is Decompilation Possible?</a></p>\n</div>",
            "votes": "1",
            "user": "julian",
            "time": "Dec 30, 2018 at 2:19",
            "is_accepted": false,
            "comments": []
        }
    ]
}