{
    "title": "Reversing a 3D file format from 2001",
    "link": "https://reverseengineering.stackexchange.com/questions/13331/reversing-a-3d-file-format-from-2001",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This is a korean MMORPG released back in 2001. The game and the company no longer exists. I've been analyzing the file formats as a personal project for awhile now. </p>\n<p>I have already decoded the textures and script files. I only have 2 more files left to decode: <code>.ani</code> and <code>.obj</code>. With the extensions, I would guess that the <code>.ani</code> contains the animation and <code>.obj</code> contains the 3d models. As the title of my question would suggest. I'm currently working on the <code>.obj</code> file. </p>\n<h2>What I Know</h2>\n<p><code>.obj</code> files are actually archives that contains one or more models. But exclusively 3D models (biped) because the textures are found on another archive with the extension <code>.t16</code> or <code>.tex</code>.</p>\n<p>I'll take the 22nd model inside the file <code>def.obj</code> as an example. I have also taken it out of the archive and saved it as a file called `def_022.obj.</p>\n<p>From here on, I'll call the 22nd model <code>Armor of Eagle</code>. The next image is the texture for the <code>Armor of Eagle</code> found on <code>def.t16</code>:</p>\n<p><a href=\"https://i.sstatic.net/OXODV.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/OXODV.jpg\"/></a></p>\n<p>The Armor of Eagle in-game:</p>\n<p><a href=\"https://i.sstatic.net/8ttpa.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/8ttpa.png\"/></a></p>\n<p>A <code>def_inf.txt</code> file has this related line:</p>\n<pre><code>filename    LODstep polycnt\narmor_eagle 0       313     // eagle = index 22\n</code></pre>\n<p>In general, the structure of <code>.obj</code> is:</p>\n<pre><code>06 00 00 00 03 00     // don't know what\n3C 00                 // total number of models in this list\n01 00 9E 00 00 00 9E 00 00 00 78 00 00 00 78 00 00 00 // the first model on the list with 0x9E polygons and 0x78 verticies\n01 00 64 00 00 00 64 00 00 00 61 00 00 00 61 00 00 00 // the 2nd model\n....... // continues until you reach the end of the headers\n....... // then the bodies start, actual 3d data\n</code></pre>\n<p>This is how the headers looks:</p>\n<p><a href=\"https://i.sstatic.net/duJ5J.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/duJ5J.png\"/></a></p>\n<ul>\n<li>Cyan: \n\n<ul>\n<li>39 01 00 00 = 313 polygon count</li>\n<li>18 01 00 00 = 280 vertex count</li>\n<li>AD 00 6B 00 = unknown</li>\n</ul></li>\n</ul>\n<h2>About def_022.obj</h2>\n<p>The face indices start at <code>0x4C [00 00 01 00...]</code><br/>\nand by the looks of it ends at <code>0x7A2 [...A2 00 A3 00]</code></p>\n<p>I was using the tool called <code>hex2obj 0.24c</code> but didn't have any luck in guessing the starting points of the vertices and uv list.</p>\n<p><a href=\"https://i.sstatic.net/xiRGV.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/xiRGV.png\"/></a></p>\n<ul>\n<li>Yellow: seems to me that it is the chunk marker. (because all files start with it)</li>\n<li>Light Blue: is a uint16 seq no., +1 for every model inside the <code>def.obj</code>. And it also corresponds to the index of its texture (on the texture archive).</li>\n<li>Dark Green: is the face indices.</li>\n</ul>\n<h2>The Question</h2>\n<ul>\n<li>How do I go forward?  </li>\n<li>How do I find the address where the UV starts? (<em>books? articles? resources?</em>)</li>\n<li>Lastly, how do I know where the vertices start?</li>\n</ul>\n<p>This is all considering that I just analyze the binary and not debug the client itself to see how the client is taking the data.</p>\n<h2>UPDATE</h2>\n<p>I noticed a few new things on the file I'm analyzing <code>def_022.obj</code>. A bytearray gets repeated a lot of times. Although, I'm still not sure of the significance YET. <code>00 00 80 3F</code> is also the bytes that each model start with, which I thought was the chunk marker:</p>\n<p><a href=\"https://i.sstatic.net/7JIx3.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/7JIx3.png\"/></a></p>\n<ul>\n<li>Yellow: is the repeated bytes. You'll also notice that it is usually preceded by the byte <code>0x3F</code> or <code>0x3E</code> and followed by <code>0x0C</code> and <code>0x0D</code> and then 3 bytes of <code>0x00</code>. This pattern gets repeated 185 times.</li>\n<li>Cyan: is the area containing the face indices.</li>\n<li>Upon further research I found out that <code>3f80 0000 = 1</code> or <code>0000 803f = 1</code> for little endian. But still don't know the significance, I'm going to dig deeper.</li>\n</ul>\n<p>Based on the notes Mr @RadLexus has kindly provided. I was also able to plot the vertices and imported into blender:</p>\n<p><a href=\"https://i.sstatic.net/mzEjq.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/mzEjq.png\"/></a></p>\n<p>Added the normals and UV:</p>\n<pre><code>v -13.531700 37.445000 2.338600\nvn -0.687800 0.725000 -0.036200\nvt 0.583800 0.086300\n</code></pre>\n<p>Then I tried adding the faces:</p>\n<pre><code>f 1 2 3\nf 1 3 4\nf 5 6 7\nf 5 7 8\nf 9 10 11\n...\n</code></pre>\n<p><a href=\"https://i.sstatic.net/rvS6x.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/rvS6x.png\"/></a></p>\n<p>But still can't figure out how to apply the textures.</p>\n<h2>UPDATE</h2>\n<p>So I tried changing my <code>.obj</code> file to include a few more info about the face values like (just duplicated the value as x/x/x):</p>\n<pre><code>f 1/1/1 2/2/2 3/3/3\nf 1/1/1 3/3/3 4/4/4\nf 5/5/5 6/6/6 7/7/7\n</code></pre>\n<p>I finally got this:</p>\n<p><a href=\"https://i.sstatic.net/44PDX.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/44PDX.png\"/></a></p>\n<p>Although it's still wrong, I guess I'm a bit closer.</p>\n<h2>FINAL UPDATE</h2>\n<p>Have figured it out. Although, I still don't know what the unknown1 and unknown2 are but it looks good enough:</p>\n<p><a href=\"https://i.sstatic.net/BHvh8.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/BHvh8.png\"/></a></p>\n<hr/>\n<blockquote>\n<p>Note: I know almost nothing about 3D file formats. Other than the basic components of a 3D object.</p>\n</blockquote>\n<p><a href=\"http://www.mediafire.com/download/i3yi7ol4cii5mtr/obj_file.zip\" rel=\"nofollow noreferrer\">Download Related Files Here</a></p>\n</div>",
    "votes": "6",
    "answers": 1,
    "views": "3k",
    "tags": [
        "binary-analysis",
        "file-format",
        "hex"
    ],
    "user": "majidarif",
    "time": "Aug 25, 2016 at 19:43",
    "comments": [
        {
            "user": "Jongware",
            "text": "<span class=\"comment-copy\">Can you add a link to original files to download and inspect?</span>",
            "time": null
        },
        {
            "user": "majidarif",
            "text": "<span class=\"comment-copy\">@RadLexus thank you for your interest. I've added updated the question to include a link to the related files. I've also included related scripts I wrote for extracting data.</span>",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "<span class=\"comment-copy\">Just FYI: you <i>are</i> on the right track with those 'repeated sequences'. Look up how a 4-byte float is stored. Recognizing these is a huge and important step in reversing a 3D format.</span>",
            "time": null
        },
        {
            "user": "majidarif",
            "text": "<span class=\"comment-copy\">@RadLexus I'm digging more into it. But I'm still not sure what the pattern is about. Although, a quick search showed that <code>3f80 0000 = 1</code> or <code>0000 803f</code> in little endian (which is what the file uses).</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><em>Some preliminary notes only – may evolve into a complete answer.</em></p>\n<hr/>\n<p>My approach was the following. Clearly, the numbers at the end are floating point numbers. Also, they are not <em>all</em> floating point; the sequence <code>0C 00 00 00</code> a few bytes in is <em>not</em> a reasonable floating point number. Counting off to the next \"unreasonable\" value (which happened to be <code>0C 00 00 00</code> again, but there are other values as well) told me the <em>stride</em> of this data was <code>28</code> bytes. (Which is 40 in decimal, but for documentation I strongly prefer hex.) If you have a capable hex viewer of which you can adjust the view width, you can see that this is correct if you set its view width to 40 characters.</p>\n<p>Counting back from the end in 40-byte steps gave me the most likely starting point of this sequence.</p>\n<p>The digits right before it are clearly at least 2-byte (unsigned short), and sort of increase from the start to the end. As this is a 3D model, I had a strong hunch they form <em>triangle data</em>, so at least they should contain <code>a</code>, <code>b</code>, and <code>c</code> vertex indices, and possibly additional triangle attributes. This turned out, by trial and error, to be not the case. (The \"trial and error\" consisted of dumping them into a display program. As that worked straight away, further numerical investigations were unnecessary.)</p>\n<p>Since this information is (1) enough to display an object, and (2) covers all of the data in the file apart from the few bytes at the start – which can be anything – I went on writing a full display program.</p>\n<hr/>\n<p>The first <code>004A</code> bytes are unknown. They contain some floating point numbers (<code>00 00 80 3F</code> is <code>1.0</code>, as a little endian 4 byte floating point number), and they could be anything. (A scale is likely.)</p>\n<p>The next 2 bytes form the number <code>0016</code>, which is in decimals <code>22</code>. This could be the internal 'object number'.</p>\n<p>Then, starting at <code>004C</code>, <code>113h</code> (313, in decimal) <em>triangle definitions</em> follow. A single triangle definition consists of 3 unsigned short indices <code>a</code>,<code>b</code>,<code>c</code>, which point to 3 <em>coordinates</em>. The largest index in this list is <code>0117</code>, a significant number!</p>\n<p>Right after this, <code>0118</code> <em>3D points</em> follow. Each 3D point has the following structure:</p>\n<pre><code>float x\nfloat y\nfloat z\nfloat unknown (usually 1.0?)\nunsigned int unknown\nfloat normal_x\nfloat normal_y\nfloat normal_z\nfloat u   \\\nfloat v   / correct; see bottom update\n</code></pre>\n<p>Affirming that the 3 <code>normal_*</code> variables indeed form a normal can be done by adding their squares together; they should hover around a value of <code>1.0</code>. That is correct for the first hundred or so of these coordinates, up to 3 decimals of accuracy:</p>\n<pre><code>1.000004\n1.000080\n0.999935\n1.000076\n0.999936\n(and so on)\n</code></pre>\n<p>Adding up the sizes of all coordinate elements leads to a total size of <code>28</code> bytes (40, in decimal), and:</p>\n<ol>\n<li>the remaining part of the file is a multiple of this;</li>\n<li>dividing the size of the remaining part by <code>28</code> results in <code>118</code> (280, in decimal).</li>\n</ol>\n<p>The significance of the 'highest index' in the triangle list is therefore proven :) They are indeed coordinate indices.</p>\n<p>Where do these numbers <code>139h</code> and <code>118h</code> come from? They appear in the header part of the entire file!</p>\n<p>Here is the proof that the first 3 elements are indeed <em>x</em>, <em>y</em>, and <em>z</em>. I plotted <em>x</em> and <em>y</em> only, with <em>y</em> inverted (negative towards the bottom of the screen). You can clearly recognize the 'body' part of your in-game image.</p>\n<p><a href=\"https://i.sstatic.net/kJQgG.png\" rel=\"nofollow noreferrer\"><img alt=\"a wireframe body\" src=\"https://i.sstatic.net/kJQgG.png\"/></a></p>\n<hr/>\n<p>Not <em>all</em> coordinates are quite the same. The <code>unknown_1</code> float value is <code>1.000</code> for the first 173 coordinates, then jumps to other values for the remainders. Similarly, the integer <code>unknown_2</code> hovers between values from <code>4</code> to <code>43</code> for these, and then jumps to a much higher value. This needs some further investigation.</p>\n<hr/>\n<p>The <code>u</code>,<code>v</code> values can be mapped onto the source image directly. They are expressed in a floating point range from <code>0..1</code> so you need to multiply them by the source image's width and height. Here is an image of that:</p>\n<p><a href=\"https://i.sstatic.net/pVv4j.png\" rel=\"nofollow noreferrer\"><img alt=\"texture coordinates\" src=\"https://i.sstatic.net/pVv4j.png\"/></a></p>\n<p>The unused parts of the image are presumably used by other 3D models.</p>\n</div>",
            "votes": "4",
            "user": "Jongware",
            "time": "Aug 23, 2016 at 22:42",
            "is_accepted": true,
            "comments": [
                {
                    "user": "majidarif",
                    "text": "<span class=\"comment-copy\">I'm starting to understand the format. Although, I'm confused about UV and mapping the texture. And also how to guess what part is the face indices if the \"scrambled alphabet\" isn't recognizable.</span>",
                    "time": null
                },
                {
                    "user": "Jongware",
                    "text": "<span class=\"comment-copy\">@majidarif: My idea about <code>u</code>,<code>v</code> was correct, see the update. I'm not sure what you mean with \"scrambled alphabet\" though. Are you referring to the original hex dump?</span>",
                    "time": null
                },
                {
                    "user": "majidarif",
                    "text": "<span class=\"comment-copy\">Thanks, I'll try the update about the <code>u</code>,<code>v</code> now. About the <code>scrambled alphabet</code>, I read somewhere that the easiest way to find the <code>face indices</code> is by finding a segment of <code>scrambled alphabets</code> as shown <a href=\"http://www11.pic-upload.de/img/27103613/hex2obj_tut.jpg\" rel=\"nofollow noreferrer\">here</a>. But I'm just thinking what if that's not the case? Is there a more concrete definition of the <code>face indices</code>? Like, maybe, values that are between 1-255 only?</span>",
                    "time": null
                },
                {
                    "user": "majidarif",
                    "text": "<span class=\"comment-copy\">When you say <code>u</code>,<code>v</code>, when using <code>.obj</code> is it the <code>vp</code>? I can't make it work on my end. This is how I did it: <code>\"vt %f %f\" % (u*width, v*height)</code>, I'm not sure if this is what you meant by multiplying by the source image dimensions.</span>",
                    "time": null
                },
                {
                    "user": "Jongware",
                    "text": "<span class=\"comment-copy\">@majidarif: multiplying is only necessary when your library does not already do it for you. Reading a few topics on <a href=\"https://blender.stackexchange.com\">Blender</a> seems to suggest it's not necessary, but of course you could ask on there and refer to this question.</span>",
                    "time": null
                }
            ]
        }
    ]
}