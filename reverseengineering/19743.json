{
    "title": "Reverse Engineering And Rendering Old Image Format .CEL",
    "link": "https://reverseengineering.stackexchange.com/questions/19743/reverse-engineering-and-rendering-old-image-format-cel",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I want to reverse engineer <a href=\"https://files.fm/u/yq8fg87w\" rel=\"nofollow noreferrer\">titltext.cel </a>.CEL image format and render this in SDL2.\nI happen to know a little bit about the CEL file that I am working with. I know it is supposed to be a sprite-sheet of the alphabet and some symbols.</p>\n<p>The .CEL image format is a format that is very stripped with very little header information. </p>\n<p>Googleing leads me to a few <a href=\"http://www.geocities.ws/fantasydiablo/cel_spec.html\" rel=\"nofollow noreferrer\">.CEL Specifications</a> <a href=\"https://github.com/krisives/ReDiablo/wiki/Cel-format\" rel=\"nofollow noreferrer\">.CEL Specifications 2</a>  documents which seem to have the idea , but I think is lacking for loading more than a few frames. From the documentation I can kind of tell how many frames are in a CEL image and where the first frame starts. </p>\n<p>Knowing where the first frame starts I thought I could bypass the stripped image header</p>\n<p><strong>IMAGE HEADER:</strong></p>\n<pre><code>37 00 00 00 E4 00 00 00 78 03 00 00 D6 05 00 00 \n18 08 00 00 B2 0A 00 00 02 0D 00 00 F8 0E 00 00 \n9D 11 00 00 07 14 00 00 4D 15 00 00 CB 16 00 00 \n04 19 00 00 9E 1A 00 00 1E 1E 00 00 ED 20 00 00 \n59 24 00 00 4C 26 00 00 78 29 00 00 E7 2B 00 00 \n1C 2E 00 00 18 30 00 00 AF 32 00 00 EC 34 00 00 \nBF 38 00 00 88 3B 00 00 8F 3D 00 00 EE 3F 00 00 \n4B 41 00 00 8E 43 00 00 D6 45 00 00 B4 47 00 00 \n06 4A 00 00 28 4C 00 00 E9 4D 00 00 4C 50 00 00 \n67 52 00 00 A9 55 00 00 09 57 00 00 D6 58 00 00 \n37 5C 00 00 19 5F 00 00 56 60 00 00 F4 61 00 00 \nA1 63 00 00 5D 64 00 00 93 65 00 00 B6 66 00 00 \n59 67 00 00 6A 68 00 00 7F 69 00 00 86 6A 00 00 \n70 6B 00 00 13 6C 00 00 A2 6C 00 00 8A 6E 00 00 \n45 70 00 00\n</code></pre>\n<p><strong>After the Image Header / Start of the first frame.</strong></p>\n<pre><code>D2 D2 D2 D2 D2 D2 D2 D2 D2 F9 03 F5 F4 F4 F3 03 F4 F4 F5\nEC FD 07 F5 F5 F5 F5 F5 ED ......\n</code></pre>\n<p>&gt;</p>\n<p>As per documentation , the first DWORD is the amount of FRAMES in the .CEL . \nThis is 0x37 which is 55 in decimal which seems accurate. From what I understand the rest is just frame locations . Each frame from what I understand is supposed to have a Width of 45 and a Height 46 Pixels. Since the image is 8 bit colour this means it would be 1 byte for each colour. </p>\n<p>Also,  I have heard that these old image types are called palettes or something to help alter the colour.</p>\n<pre><code>#include &lt;SDL2/SDL.h&gt;\n#include &lt;SDL2/SDL_image.h&gt;\n#include &lt;SDL2/SDL_mixer.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;errno.h&gt;\n\n\nSDL_Window *window; // SDL MAIN WINDOW\nSDL_Renderer *renderer;\nSDL_Texture *texture;\n\n\nint SCREEN_WIDTH = 1920;\nint SCREEN_HEIGHT = 1080;\nSDL_Event e;\nbool quit = false;\n\n\n/** 32-bit in-memory backbuffer surface */\nSDL_Surface *surface;\n/** 8-bit surface wrapper around #gpBuffer */\nSDL_Surface *pal_surface;\n/** Currently active palette */\nSDL_Palette *palette;\nSDL_Texture* texture;\n\n\nFILE* CELFILE;\n\nunsigned char CELBuffer [3000];\n\n// The CEL dementions I am trying to open are \n// W 46 Height 45 Width 55 FRAMES\nvoid LoadCEL (char * Path){\n\n\nCELFILE = fopen(Path, \"rb\"); \n\n\nint CELHEADERSIZE = 228;\nint CELFRAMESIZE  = 2070;    \n\n//The Header Appears to be 228 bytes in size.  I want to put a frame into CELBuffer \n//  \n// I am assuming to get the size of the first framee I need a size of 2017 (45 * 55) ;\n\n    unsigned char c;\n\n    for (int i = 0;  i &lt; (CELFRAMESIZE+CELHEADERSIZE) ; i++){\n        if(i &gt; CELHEADERSIZE ){\n        c  = fgetc(CELFILE);\n\n        CELBuffer[i] = c;\n        printf(\"CELFILE HEADR %02x \\n\" ,CELBuffer[i]  &amp; 0xff);\n\n        }\n\n    }   \n\n    void *  pCELBuffer = CELBuffer; \n    surface = SDL_CreateRGBSurfaceFrom( pCELBuffer , 45, 55, 8,1 ,0, 0, 0, 0xff); \n    texture = SDL_CreateTextureFromSurface(renderer, surface);\n\n}\n\nvoid Create_SDL_Window()\n{\n\n    SDL_Init(SDL_INIT_EVERYTHING);\n    IMG_Init(IMG_INIT_PNG);\n        window = SDL_CreateWindow(\"Test Window\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n    renderer = SDL_CreateRenderer(window, -1, 0);\n    printf(\"Window And Renderer Created!\\n\");\n}\n\n\nint main(){\n\nLoadCEL(\"/home/james/Desktop/titltext.cel\");\n\nCreate_SDL_Window();\nprintf(\"THIS WORKD\\n\");\n\n\nwhile (!quit){  \n        SDL_RenderPresent(renderer);\n\n\nwhile (SDL_PollEvent(&amp;e)){\n    //If user closes the window\n    if (e.type == SDL_QUIT){\n        quit = true;\n    }\n    //If user presses any key\n    if (e.type == SDL_KEYDOWN){\n    //  quit = true;\n    }\n    //If user clicks the mouse\n    if (e.type == SDL_MOUSEBUTTONDOWN){\n    /// quit = true;\n        }\n    }   \n    SDL_RenderClear(renderer);\n    //renderTexture(image, renderer, x, y);\n    SDL_RenderPresent(renderer);\n\n}\n</code></pre>\n<p>}</p>\n<p>Any help is much appreciated.</p>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "339",
    "tags": [
        "binary-analysis",
        "file-format"
    ],
    "user": "LUser",
    "time": "Oct 28, 2018 at 9:36",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Won't be able to tell you what exactly is the <code>CEL</code> format but from what I can see:</p>\n<ul>\n<li>the offsets into frames suggest that frames are about 600 bytes long (<code>0x378-0xe4=660</code>, <code>0x5d6-0x378=606</code>, etc)</li>\n<li>since the image dimensions are 45*46=2070, each frame must be compressed to fit to 600 bytes</li>\n<li>it's an old game (and as you mentioned using a palette), after the decompression one pixel is represented as one byte. Each byte is an index into a palette table.</li>\n<li>palette table doesn't seem to be stored in the <code>CEL</code> file and the game stores the palette separately. Palette is an array with length 256 elements, each element storing 3 values for R, G and B. Complete palette is 768 bytes but it's possible the game stores only subsets of the full palette. It can be that e.g. indices 1-127 are for sprites and 128-255 are for background. There's no hard rule how a game decides to use palette. It's also possible that each level uses a different palette. Search for <code>PAL</code> files or files 768 bytes long, they might be the right palettes for you.</li>\n<li>the first documentation describes how to decompress the frame, follow paragraph \"5.3 Commands\"</li>\n</ul>\n<p>Commands in you case:</p>\n<ul>\n<li><code>0xd2</code>: <code>0x100-0xd2=</code>46 transparent pixels (46 is the width so the full scanline is transparent)</li>\n<li><code>0xd2</code>: <code>0x100-0xd2=</code>46 transparent pixels</li>\n<li>...</li>\n<li><code>0xf9</code>: <code>0x100-0xf9=</code>7 transparent pixels, this is an incomplete scanline, more pixels to follow...</li>\n<li><code>0x03</code>: block command, not sure based on the doc, but it looks like that <code>3+1</code> bytes are pixel data (`0xf5, 0xf4, 0xf4, 0xd4). All block commands aremy guess and I might be completely wrong.</li>\n<li><code>0x03</code>: block command, <code>3+1</code> bytes are pixel data (<code>0xf4, 0xf4, 0xf5, 0xec</code>)</li>\n<li><code>0xfd</code>: <code>0x100-0xfd=</code>3 transparent pixels</li>\n<li><code>0x07</code>: block command?, <code>7+1</code> bytes are pixel data (<code>0xf5, ...,</code>0xf3`)</li>\n<li><code>0x06</code>: block command?, <code>6+1</code> bytes are pixel data (<code>0xf4, ...,</code>0xef`)</li>\n<li><code>0xfe</code>: <code>0x100-0xfe=</code>2 transparent pixels</li>\n<li>etc.</li>\n</ul>\n<p>Once you manage to process all commands, you have the indices into that palette table. Even if you don't have the palette you can pretend it's a grayscale image and render the image like that. You should be able to recognise the shape of sprites.</p>\n<p>The decompression algorithm, especially the block commands seem to be the tricky bits so probably what you could do is to download some Diablo editors and try to supply your own sprites to see how your sprites get compressed.</p>\n<p>If that fails or it's too much work you can always disassemble the game or even the editors to see how they decompress <code>CEL</code> files.</p>\n<p><strong>EDIT</strong>: <a href=\"https://github.com/krisives/ReDiablo/blob/master/ReDiablo/Data/GfxLoader.cs#L30\" rel=\"nofollow noreferrer\">This tool</a> seems to be loading <code>CEL</code> files and would help you understand the format. See <code>readFrame()</code> and <code>readFrame2()</code> functions. These don't seems to care about block commands but at the same time don't seem to work 100% with your file (just reading the source code). Looks like you have plenty to investigate. :)</p>\n<p>It also contains <a href=\"https://github.com/krisives/ReDiablo/blob/master/ReDiablo/diablo.pal\" rel=\"nofollow noreferrer\">a palette file</a> you could use.</p>\n</div>",
            "votes": "1",
            "user": "zxxc",
            "time": "Oct 28, 2018 at 20:51",
            "is_accepted": true,
            "comments": [
                {
                    "user": "LUser",
                    "text": "<span class=\"comment-copy\">Awesome work. I think I understand this better. I will try to knock it out.</span>",
                    "time": null
                }
            ]
        }
    ]
}