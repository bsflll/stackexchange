{
    "title": "Passing parameter using data at return address (read from stack) in NEC 78K0R",
    "link": "https://reverseengineering.stackexchange.com/questions/2787/passing-parameter-using-data-at-return-address-read-from-stack-in-nec-78k0r",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am working on some disassembly from an NEC 78K0R. Most functions have parameters passed in registers, but there are some functions that have compile time defined parameters passed using a method I have not seen before.</p>\n<p>Execution of instructions is from flash.</p>\n<p>The function, 0x4c4, is called as follows:</p>\n<pre><code>027d9        fdc404      CALL            !4C4H\n027dc        02          ?               ?\n027dd        75          MOV             D,A\n</code></pre>\n<p>The return address is set to 0x27dc and put into the stack.</p>\n<p>The function itself is as follows:</p>\n<pre><code>// Entry point from call\n004c4        c1          PUSH            AX\n004c5        c3          PUSH            BC\n004c6        c5          PUSH            DE\n004c7        c7          PUSH            HL\n\n// Get the stack pointer into HL\n004c8        aef8        MOVW            AX,SP\n004ca        16          MOVW            HL,AX\n004cb        c7          PUSH            HL\n\n// Preserve the ES (extended segment) register used for addressing\n004cc        8efd        MOV             A,ES\n004ce        c1          PUSH            AX\n\n// Retreive SP + 0x0A - this is the ES part of the return address\n004cf        8c0a        MOV             A,[HL+0AH] \n004d1        9efd        MOV             ES,A\n\n// Retreive SP + 0x8 - this is the lower two bytes of return address\n004d3        ac08        MOVW            AX,[HL+8H] \n004d5        16          MOVW            HL,AX\n\n// Take the contents of memory from the return address into A\n004d6        118b        MOV             A,ES:[HL]\n\n// Not relevant to question\n004d8        74          MOV             E,A\n004d9        c0          POP             AX\n004da        9efd        MOV             ES,A\n004dc        5500        MOV             D,#0H\n\n// HL is the original return address - shift up one to skip to instruction and store back into stack\n004de        a7          INCW            HL\n004df        17          MOVW            AX,HL\n004e0        c6          POP             HL\n004e1        bc08        MOVW            [HL+8H],AX\n</code></pre>\n<p>So, in short - the parameter 02 is stored in the flash memory in the next address. This is retrieved by using the return address from the stack, and then the return address in the stack in incremented by one so that we get to the next real instruction.</p>\n<p>The function shifts about the contents of the stack, but I do not think this is material to the problem.</p>\n<p>I've not seen this method used before - it's rather curious. I can't work out why it would be done - that's a lot of instructions required, as compared to doing:</p>\n<pre><code>MOV A,#2\nCALL !4c4H\n&lt;use A as parameter&gt;\n</code></pre>\n<p>Has anyone got any insights to why this has been done like this?</p>\n<p><strong>Edit</strong></p>\n<p>As requested, the entire function:</p>\n<pre><code>004c4        c1          PUSH            AX\n004c5        c3          PUSH            BC\n004c6        c5          PUSH            DE\n004c7        c7          PUSH            HL\n    004c8        aef8        MOVW            AX,SP\n    004ca        16          MOVW            HL,AX\n    004cb        c7          PUSH            HL\n        004cc        8efd        MOV             A,ES\n        004ce        c1          PUSH            AX\n            004cf        8c0a        MOV             A,[HL+0AH] \n            004d1        9efd        MOV             ES,A\n            004d3        ac08        MOVW            AX,[HL+8H] \n            004d5        16          MOVW            HL,AX\n            004d6        118b        MOV             A,ES:[HL]\n            004d8        74          MOV             E,A\n        004d9        c0          POP             AX\n        004da        9efd        MOV             ES,A\n        004dc        5500        MOV             D,#0H\n        004de        a7          INCW            HL\n        004df        17          MOVW            AX,HL\n    004e0        c6          POP             HL\n    004e1        bc08        MOVW            [HL+8H],AX\n    004e3        17          MOVW            AX,HL\n    004e4        25          SUBW            AX,DE\n    004e5        bef8        MOVW            SP,AX\n    004e7        c5          PUSH            DE\n        004e8        14          MOVW            DE,AX\n        004e9        320c00      MOVW            BC,#0CH\n        004ec        8b          MOV             A,[HL]\n        004ed        99          MOV             [DE],A\n        004ee        a7          INCW            HL\n        004ef        a5          INCW            DE\n        004f0        b3          DECW            BC\n        004f1        6171        XOR             A,A\n        004f3        616a        OR              A,C\n        004f5        616b        OR              A,B\n        004f7        dff3        BNZ             $4ECH\n    004f9        c2          POP             BC\n    004fa        aef8        MOVW            AX,SP\n    004fc        040c00      ADDW            AX,#0CH\n    004ff        14          MOVW            DE,AX\n    00500        3620fe      MOVW            HL,#0FE20H\n    00503        fd6104      CALL            !461H\n00506        c6          POP             HL\n00507        c4          POP             DE\n00508        c2          POP             BC\n00509        c0          POP             AX\n0050a        d7          RET      \n</code></pre>\n<p>Sub 461 called from above:</p>\n<pre><code>            00461        c1          PUSH            AX\n            00462        c3          PUSH            BC\n        00463        61dd        PUSH            PSW\n            00465        17          MOVW            AX,HL\n            00466        25          SUBW            AX,DE\n            00467        de18        BNC             $481H\n            00469        37          XCHW            AX,HL\n            0046a        03          ADDW            AX,BC\n            0046b        37          XCHW            AX,HL\n            0046c        35          XCHW            AX,DE\n            0046d        03          ADDW            AX,BC\n            0046e        35          XCHW            AX,DE\n            0046f        61cd        POP             PSW\n            00471        b7          DECW            HL\n            00472        b5          DECW            DE\n            00473        8b          MOV             A,[HL]\n            00474        99          MOV             [DE],A\n            00475        b3          DECW            BC\n            00476        6171        XOR             A,A\n            00478        616a        OR              A,C\n            0047a        616b        OR              A,B\n            0047c        dff3        BNZ             $471H\n        0047e        ee1000      BR              $!491H\n        00481        61cd        POP             PSW\n        00483        c5          PUSH            DE \n        00484        c7          PUSH            HL\n            00485        8b          MOV             A,[HL]\n            00486        99          MOV             [DE],A\n            00487        a7          INCW            HL\n            00488        a5          INCW            DE\n            00489        b3          DECW            BC\n            0048a        13          MOVW            AX,BC\n            0048b        6168        OR              A,X\n            0048d        dff6        BNZ             $485H\n        0048f        c6          POP             HL\n        00490        c4          POP             DE\n    00491        c2          POP             BC\n    00492        c0          POP             AX\n    00493        d7          RET  \n</code></pre>\n<p>And also the pre/post of the call:</p>\n<pre><code>024fe        c5          PUSH            DE\n024ff        fdc404      CALL            !4C4H\n02502        06          \n02503        9d24        MOV             0FFE24H,A\n02505        33          XCHW            AX,BC\n02506        bd20        MOVW            0FFE20H,AX\n</code></pre>\n</div>",
    "votes": "4",
    "answers": 1,
    "views": "220",
    "tags": [
        "disassembly",
        "nec-78k0r"
    ],
    "user": "Cybergibbons",
    "time": "Sep 13, 2013 at 17:26",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This approach (function call followed by data) is very often used to implement switches/table jumps, especially on platforms with limited flash space (so they prefer to not inline switch code but use a helper routine). I've seen it done on ARM, 8051 and some other CPUs. Since the switch data (values and offsets) is not going to change, it makes sense to put it into the code flash space.</p>\n<p><strong>EDIT</strong>: thanks for the full listing. So apparently that value is used to decrement SP, then 12 bytes of saved registers are copied there, then something else happens in <code>sub 461H</code>.</p>\n<p>At a guess, this sets up the caller's function frame (allocates space for local vars). As to why it's a code byte and not a direct argument, I have only one theory: to save flash space because only one byte is necessary as opposed to the <code>MOV</code> (at least 2 bytes) or <code>MOV + PUSH</code> (at least 3 bytes) instructions.</p>\n<p>I'd suggest finding out which compiler was used for this code (Renesas? KPIT?) and searching for this function in runtime libraries. The symbols should help here.</p>\n<p><strong>EDIT2</strong>: sub 461 seems to be <code>memmove(DE, HL, BC)</code> with copy direction detection. So it's copying N bytes from FE20 into the newly allocated stack space. Weird stuff.</p>\n</div>",
            "votes": "3",
            "user": "Igor Skochinsky",
            "time": "Sep 13, 2013 at 21:27",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Cybergibbons",
                    "text": "<span class=\"comment-copy\">Ok - I can understand it if we are looking at jump table as it will be a significant number of parameters. However, this is just a single parameter, a single byte. The microcontroller has 128KB of flash - not huge but large for the type of device.</span>",
                    "time": null
                },
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">Are you sure it's indeed a single byte and not just your disassembler skipping one byte and restarting disassembly from next valid instruction? Maybe paste the rest of the function to see what it does.</span>",
                    "time": null
                },
                {
                    "user": "Cybergibbons",
                    "text": "<span class=\"comment-copy\">I'm running it in a simulator and also on the hardware with debug and seeing it return to the normal return address + 1, as well as my interpretation saying that. Code added above.</span>",
                    "time": null
                },
                {
                    "user": "Cybergibbons",
                    "text": "<span class=\"comment-copy\">Double checked - if using the interactive simulator or hardware debug, as soon as it returns to a incorrectly diassembled instruction, it re-aligns to correct itself. It's certainly what it is doing, just can't work out why.</span>",
                    "time": null
                },
                {
                    "user": "peter ferrie",
                    "text": "<span class=\"comment-copy\">on the Apple II, this technique saved on symbol space during compilation, by avoiding the need to declare any labels for the data that were copied.  Perhaps something similar here?</span>",
                    "time": null
                }
            ]
        }
    ]
}