{
    "title": "Concept of location local variables in memory using disassembly window and registers?",
    "link": "https://reverseengineering.stackexchange.com/questions/3898/concept-of-location-local-variables-in-memory-using-disassembly-window-and-regis",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm trying to understand how to locate local variables in memory. I have disassembled a c code and I have the address of the instructions. I want the memory location where that variable is stored. I tried to access the instruction address of i in c code but the variable is not located there. I think it is located at a \"offset\" from the base pointer. But I don't know about the concept of offset. Any help will be appreciated.</p>\n<p>C code:</p>\n<pre><code>int main()\n{\n    int i = 10;\n    int j = -1;\n    int k = 4;\n    int l = 9;\n    int m;\n\n    m = (i-j) + (k-l);\n}\n</code></pre>\n<p>Disassembled code</p>\n<pre><code>int main()\n{\n003E13A0  push        ebp  \n003E13A1  mov         ebp,esp  \n003E13A3  sub         esp,0FCh  \n003E13A9  push        ebx  \n003E13AA  push        esi  \n003E13AB  push        edi  \n003E13AC  lea         edi,[ebp-0FCh]  \n003E13B2  mov         ecx,3Fh  \n003E13B7  mov         eax,0CCCCCCCCh  \n003E13BC  rep stos    dword ptr es:[edi]  \n    int i = 10;\n003E13BE  mov         dword ptr [i],0Ah  \n    int j = -1;\n003E13C5  mov         dword ptr [j],0FFFFFFFFh  \n    int k = 4;\n003E13CC  mov         dword ptr [k],4  \n    int l = 9;\n003E13D3  mov         dword ptr [l],9  \n    int m;\n\n    m = (i-j) + (k-l);\n003E13DA  mov         eax,dword ptr [i]  \n003E13DD  sub         eax,dword ptr [j]  \n003E13E0  mov         ecx,dword ptr [k]  \n003E13E3  sub         ecx,dword ptr [l]  \n003E13E6  add         eax,ecx  \n003E13E8  mov         dword ptr [m],eax  \n}\n003E13EB  xor         eax,eax  \n003E13ED  pop         edi  \n003E13EE  pop         esi  \n003E13EF  pop         ebx  \n003E13F0  mov         esp,ebp  \n003E13F2  pop         ebp  \n003E13F3  ret\n</code></pre>\n<p>Registers</p>\n<pre><code>EAX = 001A9478 EBX = 7EFDE000 ECX = 001A8868 EDX = 00000001 ESI = 00000000 EDI = 00000000 EIP = 00BE13A0 ESP = 003BF990 EBP = 003BF9DC EFL = 00000214 \n</code></pre>\n</div>",
    "votes": "2",
    "answers": 3,
    "views": "963",
    "tags": [
        "disassembly",
        "c"
    ],
    "user": "Pete",
    "time": "Mar 18, 2014 at 16:51",
    "comments": [
        {
            "user": "avgvstvs",
            "text": "<span class=\"comment-copy\">For the record, it would be *incredibly) helpful in the future for you to provide the exact compiler, OS, and compile options you used, as well as providing the precise commands you used to create your disassembly.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm not sure why this question was down-voted. I'm going to answer it from a generic standpoint as it might be a bit off-topic for the RE group.</p>\n<p>Anyway, you need to spend some time understand <a href=\"http://en.wikipedia.org/wiki/Assembly_language\" rel=\"nofollow\">assembly instruction format</a> for your processor architecture. From looking at the disassembly above, you have the information you need but you'll (1) need to understand the format of each instruction and (2) need a debugger. A debugger works with a processor to extract run-time information about the register set. In addition to understanding assembly instruction format, you will need to review the processor registers. You'll want to set breakpoints (see debugger instructions) and check the Program Counter often.</p>\n<p><b>If you try to add C instructions to read out memory values, you will change the entire assembly offset! In other words, by adding an instruction, you may change the location of the value.</b> </p>\n<p>One helpful piece of info: when working with C (and other languages) there is typically several instructions used to setup the stack and for arguments passed in to the function. Once you get an understanding of what each instruction is you'll begin to see the pattern emerge.</p>\n<p>You can also put some known instructions in your code to help you trace through it. For example, maybe do some printfs and see what those look like. Or add instructions to add 0xBE to 0xAD and look for those values in the produced code.</p>\n</div>",
            "votes": "2",
            "user": "bitsdanceforme",
            "time": "Mar 18, 2014 at 20:23",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>While you could accomplish a similar result by using gdb's \"disassemble main\" command, I chose to write your example (with one minor alteration), compile it with mingw (no flags/options) and disassemble it with the trial version of IDA Pro:</p>\n<pre><code>.text:00401334 ; =============== S U B R O U T I N E =======================================\n.text:00401334\n.text:00401334 ; Attributes: bp-based frame\n.text:00401334\n.text:00401334 ; void main()\n.text:00401334                 public _main\n.text:00401334 _main           proc near               ; CODE XREF: ___mingw_CRTStartup+F8p\n.text:00401334\n.text:00401334 var_4           = dword ptr -4\n.text:00401334\n.text:00401334                 push    ebp\n.text:00401335                 mov     ebp, esp\n.text:00401337                 push    ebx\n.text:00401338                 and     esp, 0FFFFFFF0h ; Logical AND\n.text:0040133B                 sub     esp, 20h        ; Integer Subtraction\n.text:0040133E                 call    ___main         ; Call Procedure\n.text:00401343                 mov     dword ptr [esp+1Ch], 0Ah\n.text:0040134B                 mov     dword ptr [esp+18h], 0FFFFFFFFh\n.text:00401353                 mov     dword ptr [esp+14h], 4\n.text:0040135B                 mov     dword ptr [esp+10h], 9\n.text:00401363                 mov     eax, [esp+18h]\n.text:00401367                 mov     edx, [esp+1Ch]\n.text:0040136B                 mov     ecx, edx\n.text:0040136D                 sub     ecx, eax        ; Integer Subtraction\n.text:0040136F                 mov     eax, [esp+10h]\n.text:00401373                 mov     edx, [esp+14h]\n.text:00401377                 mov     ebx, edx\n.text:00401379                 sub     ebx, eax        ; Integer Subtraction\n.text:0040137B                 mov     eax, ebx\n.text:0040137D                 add     eax, ecx        ; Add\n.text:0040137F                 mov     [esp+0Ch], eax\n.text:00401383                 mov     ebx, [ebp+var_4]\n.text:00401386                 leave                   ; High Level Procedure Exit\n.text:00401387                 retn                    ; Return Near from Procedure\n.text:00401387 _main           endp\n</code></pre>\n<p>The key point here in understanding offsets is that its all based on the program's base address, which can be different depending on your platform.  Understanding base address is a processor, language, and OS-specific problem.  For windows binaries, do some googling on PE Headers.  (That will explain the .text.)  Generally speaking offsets mean \"how many bytes from the beginning of the program/function call.\"  Convention holds that an \"int\" (in C languages\" is 4 bytes (32b) and that's why you usually see variables like yours placed 4B apart from each other.  Notice the offsets by your variable declarations:</p>\n<p>.text:00401343                 mov     dword ptr [esp+1Ch], 0Ah\n.text:0040134B                 mov     dword ptr [esp+18h], 0FFFFFFFFh\n.text:00401353                 mov     dword ptr [esp+14h], 4\n.text:0040135B                 mov     dword ptr [esp+10h], 9</p>\n<p>Each variable is 4B off from each other.  Do you get the hint about offsets yet?  </p>\n<p>Offsets have alot to do with \"esp,\" traditionally the \"stack pointer.\"  </p>\n<p>So when you see the line:</p>\n<pre><code>.text:00401343                 mov     dword ptr [esp+1Ch], 0Ah\n</code></pre>\n<p>You're looking at the data that's at the address that is \"1Ch\" away from \"esp.\" (Get familiar with HEX arithmetic.  Google.)  </p>\n<p>The \".text\" that you see is telling you what the instructions are at that particular offset in the \".text\" portion of the program.  (Google.  PE headers again.)  </p>\n<p>I know that I haven't completely answered your question, but if you're doing binary analysis, you really DO need to get used to wide swaths of ambiguity... reverse engineering isn't like programming in a high-level language at all.  There's no concept of a data type, only a data type inferred by looking at the surrounding instructions.  Its ugly, and its beautiful at the same time.   </p>\n<p>[EDIT]</p>\n<p>I altered your program thusly:</p>\n<pre><code>void main()\n{\n    int i = 10;\n    int j = -1;\n    int k = 4;\n    int l = 9;\n    int m;\n\n    m = (i-j) + (k-l);\n\n}\n</code></pre>\n<p>If you start a C program with \"int main(){..}\" you really must at least have return 0;.  </p>\n<p>Since you didn't have that, I altered the program to return void.  </p>\n</div>",
            "votes": "2",
            "user": "avgvstvs",
            "time": "Mar 19, 2014 at 2:34",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>in the code you posted all the variables <code>i,j,k,l,m</code> are <code>local</code> variables    </p>\n<p>they will all be located at an address below base pointer ie from [ebp-4] onwards   </p>\n<pre><code>use .cpp instead of c and make use of some advanatges of c++ in a c program like \nnot having to make declaration of variables at the start \n</code></pre>\n<p>if you need to access them in your own program you can use the following helper code<br/>\nthis prints </p>\n<pre><code>all the registers  5 dwords above base pointer namely arguments to the    \nfunction and 5 dwords below the base pointer namely Locals   \n</code></pre>\n<p>this is a <code>naked</code> function so it uses the ebp of the function from which it is called in your case the ebp constructed by main</p>\n<pre><code>#include &lt;stdio.h&gt;\n\n    char regs_5args_and_5locs[] = \n    { \n        \"==========Registers===================\\n\"\n        \"eax = %08x\\n\"\n        \"ebx = %08x\\n\"\n        \"ecx = %08x\\n\"\n        \"edx = %08x\\n\"\n        \"esi = %08x\\n\"\n        \"edi = %08x\\n\"\n        \"esp = %08x\\n\"\n        \"ebp = %08x\\n\"\n        \"==========Arguments===================\\n\"\n        \"1rg = %08x\\n\"\n        \"2rg = %08x\\n\"\n        \"3rg = %08x\\n\"\n        \"4rg = %08x\\n\"\n        \"5rg = %08x\\n\"\n        \"==========Locals===================\\n\"\n        \"1lo = %08x\\n\"\n        \"2lo = %08x\\n\"\n        \"3lo = %08x\\n\"\n        \"4lo = %08x\\n\"\n        \"5lo = %08x\\n\"\n        \"===================================\\n\"\n    };\n __declspec (naked) void regsargsnlocs(void)\n{\n    __asm\n    {\n        pushad\n            pushfd\n            push [ebp-0x14]\n        push [ebp-0x10]\n        push [ebp-0x0c]\n        push [ebp-0x08]\n        push [ebp-0x04] \n        push [ebp+0x14]\n        push [ebp+0x10] \n        push [ebp+0x0c]\n        push [ebp+0x08]\n        push [ebp+0x04]\n        push ebp\n            push esp\n            push edi\n            push esi\n            push edx\n            push ecx\n            push ebx\n            push eax\n            lea eax, regs_5args_and_5locs\n            push eax        \n            call printf\n            add esp,0x4c\n            popfd\n            popad\n            retn\n    }   \n}\n\n\nvoid main()\n{\n    regsargsnlocs();    \n    int i = 10;\n    int j = -1;\n    int k = 4;\n    int l = 9;\n    int m;\n    regsargsnlocs();\n    m = (i-j) + (k-l);\n   regsargsnlocs();\n}\n</code></pre>\n<p>the result as follows you can notice \ni= 0xa ,j= -0x1,k= 0x4,l=0x9 ,m = 0x6 in the locals on the 2nd and 3rd invocation respectively</p>\n<pre><code>\\locvar&gt;locvar.exe\n==========Registers===================\neax = 000339e8\nebx = 7ffd4000\necx = 00000001\nedx = 0041dcf0\nesi = 00000000\nedi = 2d6648b4\nesp = 0013ff10\nebp = 0013ff78\n==========Arguments===================\n1rg = 004013ca\n2rg = 00000001\n3rg = 000339c8\n4rg = 000339e8\n5rg = 4b9239ba\n==========Locals===================\nthe locals have not been assigned yet we printed prior to them \nnotice this is a cpp program not c which wont allow you a function \nbefore declaration of variables\n1lo = 004039a1 \n2lo = 00402d5b \n3lo = 0013ff80 \n4lo = 004039a1\n5lo = 004086a8\n===================================\n==========Registers===================\neax = 000339e8\nebx = 7ffd4000\necx = 00000001\nedx = 0041dcf0\nesi = 00000000\nedi = 2d6648b4\nesp = 0013ff10\nebp = 0013ff78\n==========Arguments===================\n1rg = 004013ca\n2rg = 00000001\n3rg = 000339c8\n4rg = 000339e8\n5rg = 4b9239ba\n==========Locals===================\n1lo = 0000000a   i\n2lo = 00000004   k\n3lo = 00000009   l\n4lo = 004039a1    m not calculated yet\n5lo = ffffffff   j\n===================================\n==========Registers===================\neax = 00000006\nebx = 7ffd4000\necx = fffffffb\nedx = 0041dcf0\nesi = 00000000\nedi = 2d6648b4\nesp = 0013ff10\nebp = 0013ff78\n==========Arguments===================\n1rg = 004013ca\n2rg = 00000001\n3rg = 000339c8\n4rg = 000339e8\n5rg = 4b9239ba\n==========Locals===================\n1lo = 0000000a\n2lo = 00000004\n3lo = 00000009\n4lo = 00000006   m calculated here 3rd invocation\n5lo = ffffffff\n===================================\n</code></pre>\n</div>",
            "votes": "2",
            "user": "blabb",
            "time": "Mar 20, 2014 at 21:16",
            "is_accepted": false,
            "comments": []
        }
    ]
}