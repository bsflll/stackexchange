{
    "title": "How are obfuscators detected?",
    "link": "https://reverseengineering.stackexchange.com/questions/8921/how-are-obfuscators-detected",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm guessing that tools like PeiD detect packers by looking for signatures inside the packed binary and by measuring the entropy. Is there any other work that tries to determine if a binary is obfuscated in some way based on some property of the binary? Would this be able to detect control flow obfuscations as in the case of ollvm?</p>\n</div>",
    "votes": "7",
    "answers": 2,
    "views": "2k",
    "tags": [
        "obfuscation",
        "unpacking"
    ],
    "user": null,
    "time": "May 17, 2015 at 22:08",
    "comments": [
        {
            "user": "Dominik Antal",
            "text": "<span class=\"comment-copy\">I'm sure in case of .NET each obfuscation software has some unique \"footprint\" on the binary produced. If glancing on the binary is not an option :)</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I wouldn't say that obfuscation detection is strictly related to entropy.\nWhen I detected obfuscated code areas I did it by simple statistical comparison of probabilities of appearances of specific assembly commands.</p>\n<p>For example number of jump related commands will be significantly larger in a binary with control flow obfuscation.\nNumber of arithmetic related commands will be significantly larger in a binary with opaque predicates.\nNumber of some specific code sequences such as <code>jmp $+5</code> or <code>push addr; ret</code> will be significantly larger when such an obfuscations are applied.</p>\n<p>These heuristics usually working pretty well on the code which is not packed (packed code, however, can be detected by entropy measurement and existence of segments related to well known packers or with unknown meaning).</p>\n</div>",
            "votes": "8",
            "user": "w s",
            "time": "May 18, 2015 at 5:45",
            "is_accepted": false,
            "comments": [
                {
                    "user": "joxeankoret",
                    "text": "<span class=\"comment-copy\">One of the tricks I use to detect obfuscation is to count the number of functions and the number of basic blocks and then check the exit basic blocks to determine if the \"exit instructions\" make any sense.</span>",
                    "time": null
                },
                {
                    "user": "w s",
                    "text": "<span class=\"comment-copy\">Counting (number of function prologues + number of function epilogues)/(code size) may be also good heuristic.</span>",
                    "time": null
                },
                {
                    "user": "w s",
                    "text": "<span class=\"comment-copy\">Generally speaking there a lot of different metrics which can be relatively simply accounted. Relation between code and data sizes, number of jumps, number of ALU ops, number of load/store operations related to code size - all this may give a lot of information. Using the famous triad of multidimensional statistics (factor, discriminant and cluster analysis) on a these metrics should give a good detection ratio.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I think that, in general, it may be difficult to distinguish obfuscated code from code generated by a compiler that is either extremely bad or extremely good.</p>\n<ul>\n<li>A compiler that does a lousy job of code generation/optimization will generate all sorts of unnecessary/dead instructions.  </li>\n<li>As examples of high levels of optimization leading to difficult-to-understand code, consider <a href=\"http://courses.cs.washington.edu/courses/cse501/15sp/papers/massalin.pdf\" rel=\"nofollow\">Massalin's work on superoptimizers</a>, and GCC's use SSE2 instructions and/or aggressive instruction scheduling, e.g., under <strong>gcc -Ofast</strong>.  Switch statements lead to <a href=\"http://www.nextmovesoftware.com/technology/SwitchOptimization.pdf\" rel=\"nofollow\">all sorts of interesting code generation possibilities</a> that may look a lot like obfuscation.</li>\n</ul>\n<p>Extreme cases of obfuscation are relatively esay to detect.  But an obfuscator that's trying to be stealthy will not be easy to detect.</p>\n</div>",
            "votes": "2",
            "user": "debray",
            "time": "May 19, 2015 at 20:04",
            "is_accepted": false,
            "comments": []
        }
    ]
}