{
    "title": "8086 Function Calling Conventions",
    "link": "https://reverseengineering.stackexchange.com/questions/26002/8086-function-calling-conventions",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am reversing an old DOS game from 1989. What are the function calling conventions for the 16-bit 8086 processor that is used to run this type of program?</p>\n<h2>How it works on Windows x64</h2>\n<p>By function calling conventions, I mean, what registers are used to pass what function parameters? Example:</p>\n<p><code>int test(int a, int b, int c, int d, int e, int f, int g) {}</code></p>\n<p>In Windows x64, this would correspond to</p>\n<p><code>rcx, rdx, r8, r9, [stack], [stack], [stack]</code></p>\n<h2>How it works on 8086</h2>\n<p>I took a quick look at the <a href=\"https://en.wikipedia.org/wiki/X86_calling_conventions\" rel=\"nofollow noreferrer\">X86 calling conventions Wikipedia article</a>, and 8086 looks more complicated than x64. It looks like there are different kinds of calls <code>cdecl, fastcall, etc.</code>, and each type of call has its own conventions.</p>\n<p><a href=\"https://i.sstatic.net/ZQneU.png\" rel=\"nofollow noreferrer\"><img alt=\"8086 calling conventions table\" src=\"https://i.sstatic.net/ZQneU.png\"/></a></p>\n<p>A quick peek in Ghidra at an old MZ executable confirms that multiple types occur in the same binary.</p>\n<p><a href=\"https://i.sstatic.net/gSAuU.png\" rel=\"nofollow noreferrer\"><img alt=\"Ghidra function calling conventions\" src=\"https://i.sstatic.net/gSAuU.png\"/></a></p>\n<h2>Questions</h2>\n<ul>\n<li>Can somebody provide a summary of the different types of 8086 calling conventions, their use cases, and the registers they use?</li>\n<li>Which type is most common?</li>\n<li><code>cdecl</code> has an empty register column in the above table... does that mean it passes everything on the stack?</li>\n<li>Do these \"right to left\" conventions push everything onto the stack in reverse? g to a instead of a to g?</li>\n<li>What is Ghidra <code>stdcall, regcall, thiscall</code>? Does one of these correspond to <code>fastcall</code> in the Wikipedia table?</li>\n</ul>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "2k",
    "tags": [
        "ghidra",
        "calling-conventions"
    ],
    "user": "RedDragonWebDesign",
    "time": "Sep 29, 2020 at 3:32",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Calling conventions are compiler specific, meaning they are specified by the compiler manufacturer like Microsoft, and not by the 8086 manufacturer like Intel. In case you program in Assembler or build your own compiler, you can apply your own method to pass function parameters.</p>\n<p>Nevertheless, in the C/C++ world, there are mainly the __cdecl and the __stdcall conventions.</p>\n<p><strong>cdecl</strong>: Parameters on the stack, rightmost parameter first (RTL). cdecl calls need slightly more code than stdcall, because the caller has to cleanup the stack after the call. Thus, when reversing you might make a guess about the programming language from how the stack is cleaned after a function call.</p>\n<p><strong>Pascal</strong>: Convention originally used by the Pascal programming language, parameters on the stack, leftmost parameter first. The Win32 API calls (it is a C interface) were all tagged with the PASCAL keyword.</p>\n<p><strong>stdcall</strong>: same as Pascal</p>\n<p>Both (cdecl and stdcall) are the widely used, as everybody uses C Compilers and the Win32 API is also very common (although not everybody uses it...). I do not know if other compilers use the same keywords. It might be noted that using a DLL in your software you must know the calling convention of its API, as it must match the one of the caller. This is a frequent cause of trouble when using DLLs you didn't create yourself.</p>\n<p>The Ghidra variants <strong>16near</strong> and <strong>16far</strong> of these two are to indicate the segmented memory model (in contrast to a flat memory model) of the 8086 architecture. 16near indicates intra segment (within 64k), and 16far indicates inter segment (call into another 64k segment). These have their origin in the 8086 architecture, where different assembler calls for near and far calls are present.</p>\n<p><strong>thiscall</strong> indicates a call to a member function (method) of a C++ class in the Microsoft compiler. In the 32-bit world, the ECX register holds the \"this\" pointer in that case. Don't know if this existed already in 16-bit world. MS released their first C++ compiler in 1992, thus you will not be bothered with your game with __thiscall (if built with a MS compiler).</p>\n<p>Not sure about the exact meaning of <strong>regcall</strong> and <strong>fastcall</strong>, but I also assume a parameter transfer in registers.</p>\n<p>Please read all this with a grain of salt, the 16-Bit times are (at least on PCs) long gone. And if you don't bother to google about these items, you surely will find a wealth of information.</p>\n</div>",
            "votes": "4",
            "user": "josh",
            "time": "Oct 1, 2020 at 1:05",
            "is_accepted": false,
            "comments": []
        }
    ]
}