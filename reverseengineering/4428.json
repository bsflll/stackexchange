{
    "title": "Where the pointer to virtual function table is located?",
    "link": "https://reverseengineering.stackexchange.com/questions/4428/where-the-pointer-to-virtual-function-table-is-located",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I used to think that the pointer to the Virtual Function Table (VFT, also Virtual Method Table, VMT) is the very first 32-bit word of the object binary representation.</p>\n<p>But now I see a VFT whose index is 13 (!!!!), that is, offset=0x34. (I write \"index\" because the code to invoke the Qt function <code>o.metaObject()</code> is <code>((func***)o)[13][0](o)</code>). OMG, what is going on? Why the VFT address is located... where?</p>\n<p>EDIT (after complaints that the question is unclear):</p>\n<p>Each object with virtual functions has a pointer to the Virtual Function Table. Usually, this is the very first 32-bit value in the object's binary representation (and may be accessed as <code>((void**)objAddr)[0]</code>). But in the example below the offset of VMT pointer is not 0! (Function names may be demangled by <a href=\"http://linux.die.net/man/1/c++filt\" rel=\"nofollow\"><code>c++filt</code></a>; for readability, the class names have been shortened to <code>Abc</code> and <code>Xyz</code>):</p>\n<pre><code>.text:02EF171C _ZN3XyzC2EP7QObject ; constructor Xyz::Xyz(QObject*), r0 = objAddr, r1 = QObject addr\n.text:02EF171C                 PUSH.W          {R4-R8,LR}\n.text:02EF1720                 MOV             R4, R0\n.text:02EF1722                 LDR             R5, =(_GLOBAL_OFFSET_TABLE_ - 0x02EF1730)\n.text:02EF1724                 MOV             R7, R1\n.text:02EF1726                 BL.W            _ZN4AbcdC2EP7QObject ; superclass_constructor(objAddr)\n.text:02EF172A ; ---------------------------------------------------------------------------\n.text:02EF172A                 LDR             R3, =(_ZTVN3XyzE_ptr - 0x27E4BE0) ; vtable for Xyz\n.text:02EF172C                 ADD             R5, PC ; _GLOBAL_OFFSET_TABLE_\n.text:02EF172E                 MOV             R6, R4\n.text:02EF1730                 MOV             R1, R7\n.text:02EF1732                 LDR             R3, [R5,R3] ; _ZTVN3XyzE_ptr ; pointer to vtable for Xyz\n.text:02EF1734                 ADDS            R3, #8 ; *_ptr points to the (-2)nd element of VMT\n.text:02EF1736                 STR.W           R3, [R6],#0x34 ; OOPS! the offset is 0x34 !!!\n</code></pre>\n<p><em>I want to be able to locate the pointer to VMT for any object,</em> but as the example above shows, the pointer to VMT is not necessarily <code>((void**)objAddr)[0]</code>.</p>\n<p>So the question is:</p>\n<p>1) <strong><em>why the VMT pointer is in the middle of the object's binary representation?</em></strong> There must be something specific about this place.</p>\n<p>2) <strong><em>how do I find out where the VMT pointer actually is?</em></strong> (Ideally, at run-time given the object address. I have the code to tell a valid address from an invalid one. I'm interested in GCC for Android/ARM, although techniques for different platforms may turn out to be applicable.)</p>\n<p>PS the code to detect a valid address on Android is:</p>\n<pre><code>#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\nint isValidPtr(const void*p, int len) {\n    if (!p) { return 0; }\n    int ret = 1;\n    int nullfd = open(\"/dev/random\", O_WRONLY); // does not work with /dev/null !!!\n    if (write(nullfd, p, len) &lt; 0) {\n        ret = 0; /* Not OK */\n    }\n    close(nullfd);\n    return ret;\n}\n</code></pre>\n<p>UPDATE</p>\n<p>In the following example, the VMT offset is 0:</p>\n<pre><code>class Base {\npublic:\n  int x,y;\n};\nclass Derived: public Base {\npublic:\n  int z;\n  Derived();\n  virtual int func();\n  virtual int func2();\n};\n</code></pre>\n<p>Coercion from <code>Base*</code> to <code>Derived*</code> compiles to: <code>SUBS R0, #4</code></p>\n<pre><code>int test3(Base*b) {\n    Derived*d = (Derived*)b;\n    int r = addDerived(*d);\n    return r;\n}\n\n ; test3(Base *)\n _Z5test3P4Base\n CBZ             R0, loc_1C7A\n SUBS            R0, #4\n B.W             _Z10addDerivedR7Derived ;\n</code></pre>\n<p>UPDATE2</p>\n<p>I tried</p>\n<pre><code>struct Cls2 {\n    unsigned x[13];\n    Derived d;\n    Cls2();\n};\n</code></pre>\n<p>and here's the disassembly:</p>\n<pre><code>.text:00001CE2 _ZN4Cls2C2Ev ; Cls2::Cls2(void)\n.text:00001CE2                 PUSH            {R4,LR}\n.text:00001CE4                 MOV             R4, R0\n.text:00001CE6                 ADD.W           R0, R0, #0x34\n.text:00001CEA                 BL              _ZN7DerivedC2Ev ; Derived::Derived(void)\n.text:00001CEE                 MOV             R0, R4\n.text:00001CF0                 POP             {R4,PC}\n</code></pre>\n<p>That is, the VFT pointer of <code>Cls2::d</code> will indeed be at offset 0x34, but there's no <code>STR.W R3,[R6],#0x34</code>, so it is not #2 suggested by Willem Hengeveld.</p>\n<p>BUT if we comment out the constructor,</p>\n<pre><code>struct Cls2 {\n    unsigned x[13];\n    Derived d;\n//    Cls2();\n};\n</code></pre>\n<p>in</p>\n<pre><code>int testCls2() {\n    Cls2 c;\n    return c.d.func2();\n}\n</code></pre>\n<p>we get</p>\n<pre><code>.text:00001C9E _Z8testCls2v\n.text:00001C9E var_18          = -0x18\n.text:00001C9E                 PUSH            {LR}\n.text:00001CA0                 SUB             SP, SP, #0x4C\n.text:00001CA2                 ADD             R0, SP, #0x50+var_18\n.text:00001CA4                 BL              _ZN7DerivedC2Ev ; Derived::Derived(void)\n.text:00001CA8                 ADD             R0, SP, #0x50+var_18\n.text:00001CAA                 BL              _ZN7Derived5func2Ev ; Derived::func2(void)\n.text:00001CAE                 ADD             SP, SP, #0x4C\n.text:00001CB0                 POP             {PC}\n</code></pre>\n<p>which is very similar to the original code\nBUT in my case the VMT <code>vtable for Xyz</code> is written from <code>Xyz::Xyz()</code> and not from the enclosing function.</p>\n</div>",
    "votes": "4",
    "answers": 2,
    "views": "5k",
    "tags": [
        "c++",
        "arm",
        "virtual-functions",
        "gcc"
    ],
    "user": "18446744073709551615",
    "time": "May 27, 2014 at 6:19",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<span class=\"comment-copy\">Show the code/asm/whatever. It's not clear what you mean by \"index\".</span>",
            "time": null
        },
        {
            "user": "Willem Hengeveld",
            "text": "<span class=\"comment-copy\">the call to Derived::Derived(void) could have been inlined with the right optimization flags.</span>",
            "time": null
        },
        {
            "user": "DCoder",
            "text": "<span class=\"comment-copy\">Based on the way you keep editing your question, you might want to read through <a href=\"http://smile.amazon.com/dp/0201834545/\" rel=\"nofollow noreferrer\"><i>Inside The C++ Object Model</i></a>. It contains a lot more information than can be given in a single answer.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I can think of 2 cases where a VMT is not in the first word of an object:</p>\n<ul>\n<li>using multiple inheritance</li>\n<li>when the an object has a member variable which has virtual methods</li>\n</ul>\n<h2>multiple inheritance</h2>\n<pre><code>struct base1 {\n    uint32_t x[12];\n    virtual void m1() { }\n};\n\n\nstruct base2 {\n    virtual void m2() { }\n};\n\nstruct cls : base1, base2 {\n};\n</code></pre>\n<p>now the VMT of base2 is at offset 0x34</p>\n<h2>virtual member</h2>\n<pre><code>struct cls2 {\n    uint32_t x[13];\n    base2   b;\n};\n</code></pre>\n<p>now also the VMT of base2 is at offset 0x34</p>\n</div>",
            "votes": "5",
            "user": "Willem Hengeveld",
            "time": "May 26, 2014 at 10:47",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The code to detect and print virtual function table pointers is:</p>\n<pre><code>int isIdentifier(const char* s) { // true if points to [0-9a-zA-Z_]*\\x00\n    if(!isValidPtr(s,0x10)) { return 0; }\n    if(!s[0]) { return 0; }\n    int i;\n    for (i=0; s[i] &amp;&amp; i&lt;512; i++) {\n        if( i/0x10 &amp;&amp; i%0x10 == 0 &amp;&amp; !isValidPtr(s,0x10)) { return 0; }\n        unsigned char c = s[i];\n        if ('0'&lt;=c &amp;&amp; c&lt;='9' || 'a'&lt;=c &amp;&amp; c &lt;= 'z' || 'A'&lt;=c &amp;&amp; c &lt;= 'Z' || '_' == c) {\n        } else {\n            return 0;\n        }\n    }\n    return !s[i];\n}\n\nchar* isVftPtr(void*addr) { // returns addr of mangled class name (prefix it with _Z to demangle with c++filt)\n    unsigned int* vmtaddr = isValidPtr(addr,4)\n                     &amp;&amp; 0 == (3 &amp; *(int*)addr)\n                     &amp;&amp; isValidPtr(*(int**)addr,4)\n                     ? *(unsigned int**)addr\n                     : (void*)0;\n    if (vmtaddr\n      &amp;&amp;isValidPtr(vmtaddr-2,0x20)\n     ) {\n        char**ptypeinfo = ((char***)vmtaddr)[-1];\n        if (isValidPtr(ptypeinfo,4)\n          &amp;&amp;isValidPtr((char***)ptypeinfo[0]-1,8)\n          &amp;&amp;isValidPtr(((char***)ptypeinfo[0])[-1],8)\n          &amp;&amp;isValidPtr(((char***)ptypeinfo[0])[-1][1],0x20)\n          &amp;&amp;isIdentifier(ptypeinfo[1])\n        ) {\n            return !strncmp(((char***)ptypeinfo[0])[-1][1], \"N10__cxxabiv\",12) ? ptypeinfo[1] : 0;\n        }\n    }\n    return 0;\n}\n// Usage example: printVfts(\"pThis\", pThis, -8, 0x400)\nvoid printVfts(const char*tag, void* addr, int from, int upto) {\n    void** start = addr+from;\n    void** end = addr+upto;\n    DLOG(\"{ %s ====== printVfts %p (%p..%p)\", tag, addr,start,end);\n    void**p;\n    char*n = 0;\n    for(p=addr;p&lt;end;p++) {\n        if (n = isVftPtr(p)) {\n            DLOG(\"vft at %p [off=0x%x] _Z%s\",p,(unsigned)p - (unsigned)addr, n);\n        }\n    }\n    DLOG(\"} %s ====== printVfts %p\", tag, addr);\n}\n</code></pre>\n<p>The code worked on Android/ARM.</p>\n<p>The function <code>isValidPtr()</code> is given in the question, the logging macro is given below:</p>\n<pre><code>#include &lt;android/log.h&gt;\n#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG  , \"~~~~~~\", __VA_ARGS__)\n#define DLOG(...) __android_log_print(ANDROID_LOG_DEBUG  , \"~~~~~~\", __VA_ARGS__)\n</code></pre>\n<p><strong>And, finally:</strong> <code>printVfts()</code> showed that there is another VFT pointer at offset 0.</p>\n</div>",
            "votes": "1",
            "user": "18446744073709551615",
            "time": "May 27, 2014 at 10:42",
            "is_accepted": false,
            "comments": []
        }
    ]
}