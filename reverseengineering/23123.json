{
    "title": "Reverse engineering the IBM BSC (Bisync) protocol",
    "link": "https://reverseengineering.stackexchange.com/questions/23123/reverse-engineering-the-ibm-bsc-bisync-protocol",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to connect to an old piece of communication controller which use the IBM BSC synchronous protocol but I have problems to get the CRC right.</p>\n<p><strong>Background</strong></p>\n<p>The protocol itself is described quite well in this document: </p>\n<p><a href=\"http://bitsavers.trailing-edge.com/pdf/ibm/datacomm/GA27-3004-2_General_Information_Binary_Synchronous_Communications_Oct70.pdf\" rel=\"nofollow noreferrer\">http://bitsavers.trailing-edge.com/pdf/ibm/datacomm/GA27-3004-2_General_Information_Binary_Synchronous_Communications_Oct70.pdf</a></p>\n<p>The sending communication processor is using the Motorola MC6852 chip. But the chip doesn't have hardware crc circuitry so there are software inside the comm. processor that does crc.</p>\n<p>The actual communication controller is described here: <a href=\"http://storage.datormuseum.se/u/96935524/Datormusuem/Alfaskop/Alfaskop_System_41_Reference_Manual_IBM3270_Emulation.pdf\" rel=\"nofollow noreferrer\">http://storage.datormuseum.se/u/96935524/Datormusuem/Alfaskop/Alfaskop_System_41_Reference_Manual_IBM3270_Emulation.pdf</a></p>\n<p>Page 89 and onwards describes its use of BSC.</p>\n<p>Then since this piece of equipment is IBM 3274 model C compatible this manual is applicable: <a href=\"http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/3274/GA23-0061-1_3274_Control_Unit_Description_and_Programmers_Guide_Jan84.pdf\" rel=\"nofollow noreferrer\">http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/3274/GA23-0061-1_3274_Control_Unit_Description_and_Programmers_Guide_Jan84.pdf</a></p>\n<p>Page 159 and onwards has essentially the same information as the other document.</p>\n<p><strong>Actual Messages</strong></p>\n<p>I have captured two messages sent by actual communication processor. Please note that the messages are coded in EBCDIC and not ASCII. These are responses to a POLL message. Page 172 and 175 in the IBM document above:</p>\n<p>32 01 6C D9 02 40 40 40 70 03 26 88\nand\n32 01 6C D9 02 40 C8 40 50 03 0D 28</p>\n<p>From my reading of the IBM document the CRC algorithm will reset when it sees a 01 (SOH) or 02 (STX)  and then accumulate until it sees a 03 (ETX). A SOH followed by a STX will not reset CRC again at the STX, though. Essentially this means that the CRC bytes in the messages above are the 2688 and 0D28. There is a leading SYN (32) but that is not included in the CRC calculation since it is before the SOH character. The message used for CRC calculation is then:\n6C D9 02 40 40 40 70 03 and  6C D9 02 40 C8 40 50 03 respectively. The SOH is not part of the calculation, however the trailing ETX just before the CRC is part of the CRC calculation.</p>\n<p>The messages above are received by an Intel 8274 chip. No CRC checking was done in the Intel chip though. </p>\n<p>Since the Intel 8274 chip do include a CRC checker/generator I should be able to both generate correctly formatted messages and to receive messages for further checking and investigation. I will pursue this path a bit to see if I could both receive and send using the 8274 chip and what CRC values that are generated.</p>\n<p>The 8274 chip itself supports two CRC algorithms. CRC-16 and CCITT CRC-16. My understanding is that IBM used CRC-16 with the polynomial X^16+X^15+X^2+1. I.e 8005. What initial value for crc was used is not described anywhere what I can see. A good guess though would be 0000h or possibly ffffh.</p>\n<p>The situation is that I would like to use a small STM32 micro controller to handle the BSC communications. I successfully had the program to achieve sync with the incoming data and extracted correctly formatted messages. But obviously communication would not work unless I can get the CRC calculation correct. WIP: <a href=\"https://github.com/MattisLind/alfaskop_emu/tree/master/Utils/BSCGateway\" rel=\"nofollow noreferrer\">https://github.com/MattisLind/alfaskop_emu/tree/master/Utils/BSCGateway</a></p>\n<p><strong>CRC reveng troubles</strong></p>\n<p>I have tried crc reveng tool to calculate CRC digits but I cannot get a match with the data above. Neither can I use crc reveng to search for an algorithm. It constantly reports that no models where found.</p>\n<p>Generating CRC using crc reveng with above messages as data in and polynomial 8005 doesn't give the corresponding output CRC data. I tried several initial values for CRC and also tested various variants of options for bit order but no match.</p>\n<p>Then I tried a few CRC algorithms in C found on internet. They all gave the same CRC value on the above messages but non of them matched the values in the messages neither the output from crc reveng.</p>\n<p>It is very likely that I have done something wrong when applying crc reveng, but I cannot figure out what.</p>\n<p><strong>Another test of crc reveng</strong></p>\n<p>Just to get a better understanding of crc reveng I tried a sample message where the input data buffer, initial CRC value and output CRC value was well known: <a href=\"https://stackoverflow.com/questions/23638939/crc-16-ibm-reverse-lookup-in-c\">https://stackoverflow.com/questions/23638939/crc-16-ibm-reverse-lookup-in-c</a></p>\n<p>The code in the first answer by Mark Adler give a result which is matching what is mentioned in the Maxim article. But I cannot recreate it in crc reveng, unfortunately.</p>\n<p>Hints on what I am doing wrong, please!</p>\n</div>",
    "votes": "3",
    "answers": 2,
    "views": "409",
    "tags": [
        "serial-communication",
        "crc"
    ],
    "user": "Mattis Lind",
    "time": "Jan 31, 2020 at 8:54",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>If you have known data and a known CRC, and an unknown value (like the initial CRC value or the final XOR value), you can always loop through all possible values and find those that give you the answer you want.  It might not be practical for 32-bit CRCs, but for 8- and 16-bit CRCs it shouldn't take too long to run.</p>\n<p>You'll need at least two sets of known data to get more accurate values though, as many of the possible 65,536 values will give the right answer for a single message.  But with two, very few values will produce the right CRC for both messages.  Just generate both CRCs in a loop, and if both produce the right result then print the values used and continue with the next ones.  With luck, at the end you'll have the correct constants used by that implementation - assuming the rest of the algorithm is correct of course!</p>\n<p>Also, make sure your CRC implementation is handling word sizes correctly, e.g. a 16-bit implementation on a 32-bit architecture could accidentally be using bits above 15 that were just lost on the original 16-bit architecture.</p>\n<p>I haven't used CRC RevEng before, but it sounds like this is what it does, so I'm not sure why you are getting no results.  In your case the algorithm seems to be pretty well defined, but I just reverse engineered an algorithm that was documented as being CRC-8, but actually it seemed more like a checksum rather than a full on CRC algorithm, and was 16-bit not 8-bit, so you can't always trust the documentation!  Possibly if the algorithm is nonstandard in some way this is why CRC RevEng can't pick it up.</p>\n</div>",
            "votes": "4",
            "user": "Malvineous",
            "time": "Jan 27, 2020 at 20:25",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Mattis Lind",
                    "text": "<span class=\"comment-copy\">Thank you for your  input! By some help from a guy named Peter I found out that the first message had a transmission error. He then showed that the polynom 8005 with initial value 0000 is the correct one.</span>",
                    "time": null
                },
                {
                    "user": "Malvineous",
                    "text": "<span class=\"comment-copy\">Glad you found a solution!  Probably a good idea to write your own separate answer here and tick it as the solution, so the question gets marked as having been answered.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><strong>SOLUTION</strong></p>\n<p>I got help from a guy named Peter. He gave me a piece of test code in C. The CRC algorithm looked pretty similar to the ones I already tried. But what was important was that he pointed out that the first sample message most likely had a bit error.</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint crc16(unsigned char *ptr, int count)\n{\n    unsigned int crc;\n    char i;\n\n    crc = 0x0000;\n    while (--count &gt;= 0)\n    {\n        crc = crc ^ (unsigned int) *ptr++;\n        i = 8;\n        do\n        {\n            if (crc &amp; 0x0001)\n                crc = (crc &gt;&gt; 1) ^ 0xA001;  /* 0x8005 bit reversed */\n            else\n                crc = (crc &gt;&gt; 1);\n        } while(--i);\n    }\n    return (crc);\n}\n\nvoid main()\n{                   \n                     /* 32  01  6C  D9  02  40  40  40  70  03  26  88 */\n\n   unsigned char data1[] = {0x6c, 0xd9, 0x02, 0x40, 0x40, 0x40, 0x50, 0x03};\n\n                     /* 32  01  6C  D9  02  40  C8  40  50  03  0D  28 */\n\n   unsigned char data2[] = {0x6c, 0xd9, 0x02, 0x40, 0xc8, 0x40, 0x50, 0x03};\n\n   printf(\"crc sent: 8826 computed: %4.4x\\n\", crc16(data1, sizeof(data1)));\n\n   printf(\"crc sent: 280d computed: %4.4x\\n\", crc16(data2, sizeof(data2)));\n\n   return;\n}\n</code></pre>\n<p>And when testing the first corrected message and the second message using crc reveng it finds the algorithm</p>\n<pre><code>$ ./reveng -w 16  -s 6cd90240c84050030d28\n./reveng: warning: you have only given 1 sample\n./reveng: warning: to reduce false positives, give 4 or more samples\nwidth=16  poly=0x8005  init=0x0000  refin=true  refout=true  xorout=0x0000  check=0xbb3d  residue=0x0000  name=\"CRC-16/ARC\"\nMattisMacBook:reveng-2.1.0 mattis$ ./reveng -w 16  -s 6CD90240404070032688\n./reveng: warning: you have only given 1 sample\n./reveng: warning: to reduce false positives, give 4 or more samples\n./reveng: no models found\n$ ./reveng -w 16  -s 6CD90240404050032688\n./reveng: warning: you have only given 1 sample\n./reveng: warning: to reduce false positives, give 4 or more samples\nwidth=16  poly=0x8005  init=0x0000  refin=true  refout=true  xorout=0x0000  check=0xbb3d  residue=0x0000  name=\"CRC-16/ARC\"\n</code></pre>\n<p>Then I tried getting crc reveng to do the same calculation as the code Peter provided above. It took a while to get the options right.\nFor some reason I had to specify the polynom in the reverse bit order to make it work.</p>\n<pre><code>$ ./reveng -w 16 -P a001 -i 0000  -x 0000  -l  -d \nwidth=16  poly=0x8005  init=0x0000  refin=true  refout=true  xorout=0x0000  check=0xbb3d  residue=0x0000  name=(none)\n$ ./reveng -w 16 -P a001 -i 0000  -x 0000  -l  -c 6CD9024040405003\n2688\n</code></pre>\n<p><strong>Conclusion and lessons learnt</strong></p>\n<p>I never thought there could be errors in received data. That was stupid. It is not maybe likely on 9600 bps connection but can happen. Then I was too focused on testing both messages at the same time and never saw that the second message actually returned OK CRC, although it had the bytes swapped.</p>\n<p>So lessons for myself is: </p>\n<ol>\n<li>Have more samples so that transmission errors can be spotted more easily </li>\n<li>Don't assume that all messages are correct.</li>\n<li>crc reveng has many options that at first sight can be hard to get right - keep trying!</li>\n</ol>\n<p>Thanks to everyone that has helped!</p>\n</div>",
            "votes": "4",
            "user": "Mattis Lind",
            "time": "Jan 30, 2020 at 13:42",
            "is_accepted": true,
            "comments": []
        }
    ]
}