{
    "title": "Understanding disassembly information from Visual Studio's dumpbin and GNU's objdump",
    "link": "https://reverseengineering.stackexchange.com/questions/30421/understanding-disassembly-information-from-visual-studios-dumpbin-and-gnus-obj",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I usually write my code on Windows, and there are two different types of development environments, each providing their own tools to view the assembly code of an object file(<code>*.obj</code>) or executable (<code>*.exe</code>).</p>\n<p>If I am working with Visual Studio build system from command line, the <code>dumpbin /disasm file.obj</code> command can generate disassemble a binary file. A snippet of a disassembly from an executable, produced by <code>dumpbin</code> :</p>\n<pre><code>  000000014000E712: 41 81 F0 6E 74 65  xor         r8d,6C65746Eh\n                    6C\n  000000014000E719: 41 81 F1 47 65 6E  xor         r9d,756E6547h\n                    75\n  000000014000E720: 44 8B D2           mov         r10d,edx\n  000000014000E723: 8B F0              mov         esi,eax\n  000000014000E725: 33 C9              xor         ecx,ecx\n  000000014000E727: 41 8D 43 01        lea         eax,[r11+1]\n  000000014000E72B: 45 0B C8           or          r9d,r8d\n  000000014000E72E: 0F A2              cpuid\n  000000014000E730: 41 81 F2 69 6E 65  xor         r10d,49656E69h\n                    49\n  000000014000E737: 89 04 24           mov         dword ptr [rsp],eax\n</code></pre>\n<p>However, if I am working with the GNU toolkit (I mean mingw64, which works with native windows binaries), then running <code>objdump -D file.obj</code> gives a disassembly like this:</p>\n<pre><code>   14000e712:   41 81 f0 6e 74 65 6c    xor    $0x6c65746e,%r8d\n   14000e719:   41 81 f1 47 65 6e 75    xor    $0x756e6547,%r9d\n   14000e720:   44 8b d2                mov    %edx,%r10d\n   14000e723:   8b f0                   mov    %eax,%esi\n   14000e725:   33 c9                   xor    %ecx,%ecx\n   14000e727:   41 8d 43 01             lea    0x1(%r11),%eax\n   14000e72b:   45 0b c8                or     %r8d,%r9d\n   14000e72e:   0f a2                   cpuid  \n   14000e730:   41 81 f2 69 6e 65 49    xor    $0x49656e69,%r10d\n   14000e737:   89 04 24                mov    %eax,(%rsp)\n</code></pre>\n<p>Now, it is immediately clear that both are providing the same information. However, I want to know what the numbers on the left column mean (e.g. <code>14000e712</code>)? Also why is the instruction written differently (e.g. on the first line, <code>dumpbin</code> writes <code>r8d,6C65746Eh</code>, while <code>objdump</code> writes <code>$0x6c65746e,%r8d</code>). Why is this, and what do the different representations mean? Additionally dumpbin seems to write extra information such as <code>dword ptr</code> that <code>objdump</code> doesn't write.</p>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "2k",
    "tags": [
        "disassembly",
        "windows",
        "assembly",
        "objdump"
    ],
    "user": "S R Maiti",
    "time": "May 20, 2022 at 9:59",
    "comments": [
        {
            "user": "fpmurphy",
            "text": "<span class=\"comment-copy\"><code>dumpbin</code> is using what is known as Intel (dis)assembly syntax. <code>By default, objdump</code>, being a GNU utility is using what is known as AT&amp;T (dis)assembly syntax. If you want <code>objdump</code> to display output in Intel syntax, add <code>-Mintel</code> to your <code>objdump</code> command line.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Let's break it down. The first and most obvious difference is Intel syntax (<code>dumpbin</code>) vs. AT&amp;T syntax (<code>objdump</code>) for the output you give. That's be the part of your question:</p>\n<blockquote>\n<p>Also why is the instruction written differently (e.g. on the first line, dumpbin writes <code>r8d,6C65746Eh</code>, while objdump writes <code>$0x6c65746e,%r8d</code>). Why is this, and what do the different representations mean?</p>\n</blockquote>\n<p>However, <code>objdump</code> lets you choose between the two and just defaults to AT&amp;T (aka <code>att</code>). Excerpt from the <code>man</code> page:</p>\n<pre><code>\"intel\"\n\"att\"\n    Select between intel syntax mode and AT&amp;T syntax mode.\n</code></pre>\n<p>So you could simply use: <code>objdump -D -M intel ...</code> (also <code>-Mintel</code>) to get way closer to the output from <code>dumpbin</code>.</p>\n<p>However, a comparison of the syntax variants can be found <a href=\"https://en.wikipedia.org/wiki/X86_assembly_language#Syntax\" rel=\"nofollow noreferrer\">on Wikipedia</a>. <a href=\"http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html\" rel=\"nofollow noreferrer\">This dated overview</a> may also help. The most important difference is that Intel syntax places the target first and the source last, whereas with AT&amp;T it's the opposite.</p>\n<p>Let's take the instruction you gave:</p>\n<ul>\n<li>Intel: <code>xor r8d,6C65746Eh</code>\n<ul>\n<li><code>xor</code> instruction</li>\n<li>(first) target operand is <code>r8d</code> (lower 32-bit of the <code>r8</code> register)</li>\n<li>(second) source operand is a literal <code>6C65746Eh</code> (the hexadecimal is denoted via the trailing <code>h</code> here)</li>\n</ul>\n</li>\n<li>AT&amp;T: <code>xor $0x6c65746e,%r8d</code>\n<ul>\n<li><code>xor</code> instruction</li>\n<li>(first) source operand is a literal <code>$0x6c65746e</code> (the hexadecimal is denoted via the leading <code>0x</code> here, IIRC <code>$</code> is for literals/addresses)</li>\n<li>(second) target operand is <code>%r8d</code> (lower 32-bit of the <code>r8</code> register)</li>\n</ul>\n</li>\n</ul>\n<p>NB: This is largely a matter of taste. Binutils (the set of tools around <code>objdump</code>) and others like GDB default to AT&amp;T syntax, but you can tell them to use the Intel syntax. Most of the disassembly I work with is Intel syntax, but it's good to be aware of the two syntax variants and know how they compare.</p>\n<blockquote>\n<p>However, I want to know what the numbers on the left column mean (e.g. 14000e712)?</p>\n</blockquote>\n<p>Those are the addresses. You probably know that executables typically take a different form when mapped into memory than on disk and that address implies two things:</p>\n<ol>\n<li>it pretends that the image is mapped at base address 0x140000000</li>\n<li>0x14000e712 is simply an address with offset 0xe712 <em>into</em> the mapped image</li>\n</ol>\n<p>Edit 1: Oh and perhaps one word about this <code>mov dword ptr [rsp],eax</code> versus <code>mov %eax,(%rsp)</code> business. I find the Intel syntax more readable, since it doesn't make be think where the syntax can give the clue. \"Write DWORD to address pointed to by <code>rsp</code>, fair enough\". However, I suppose the reasoning behind the more concise AT&amp;T syntax is that the knowledge about the operation's size (DWORD) can be deduced from the operand (<code>eax</code>) and so it simply leaves out the more or less cosmetic hint of <code>dword ptr</code>.</p>\n</div>",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "May 20, 2022 at 10:03",
            "is_accepted": true,
            "comments": []
        }
    ]
}