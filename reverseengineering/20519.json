{
    "title": "Tracing calls, rets and instructions with Intel Pin",
    "link": "https://reverseengineering.stackexchange.com/questions/20519/tracing-calls-rets-and-instructions-with-intel-pin",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am writing a Pin tool with the following functionality:</p>\n<ol>\n<li>It has to record instructions with arguments. (works well)</li>\n<li>It has to record memory access operations associated with instructions. (works well)    </li>\n<li>It has to record a name of a function that is being called (if the name is available from external library). This functionality is based on calltrace.cpp from examples provided with Intel Pin. (Partially works well)       </li>\n<li>It has to record where a return instruction has landed (a function name, or, a main module of an instrumented executable). E.g. funcA is called, then funcB is called from funcA, then return from funcB lands in funcA. Recording of rets to functions partially works well, however I have no idea how to record return to the main module.</li>\n</ol>\n<p>Before providing a source code let me describe what (as I think) is wrong with the output of a tool that I get.</p>\n<ol>\n<li>Recording begins with a set of instructions that ends with return to a function that has not been called (or at least my PinTool didn't record it).</li>\n</ol>\n<blockquote>\n<p>[mov esp, esi]</p>\n<p>[pop ebx]</p>\n<p>R</p>\n<p>[pop edi]</p>\n<p>R</p>\n<p>[pop esi]</p>\n<p>R</p>\n<p>[pop ebp]</p>\n<p>R</p>\n<p>[ret 0x10]</p>\n<p>R</p>\n<p>InDirect RETURN to[RtlAnsiCharToUnicodeChar]</p>\n</blockquote>\n<ol start=\"2\">\n<li>Sometimes it records names of the functions that are called without corresponding call instruction:</li>\n</ol>\n<blockquote>\n<p>[push 0x77736e7c]</p>\n<p>W</p>\n<p>[push dword ptr [ebp-0x110]]</p>\n<p>RW</p>\n<p>[call 0x7779a490]</p>\n<p>W</p>\n<p>[LdrGetProcedureAddress]</p>\n<p>[LdrGetProcedureAddressForCaller]</p>\n<p>[RtlAcquireSRWLockExclusive]</p>\n</blockquote>\n<ol start=\"3\">\n<li>Similar is for rets. Even more sometimes it records return to the same function twice in a row (but it should not).</li>\n</ol>\n<blockquote>\n<p>[call 0x777a8b60]</p>\n<p>W</p>\n<p>[RtlRetrieveNtUserPfn]</p>\n<p>InDirect RETURN to[RtlDeactivateActivationContextUnsafeFast]</p>\n</blockquote>\n<p>////OR////</p>\n<blockquote>\n<p>[mov ecx, dword ptr [edi]]</p>\n<p>R</p>\n<p>[call 0x7777e531]</p>\n<p>W</p>\n<p>[RtlAddAccessAllowedAce]</p>\n<p>[RtlAcquireSRWLockExclusive]</p>\n<p>InDirect RETURN to[RtlAddAccessAllowedAce]</p>\n<p>[RtlReleaseSRWLockExclusive]</p>\n<p>InDirect RETURN to[RtlAddAccessAllowedAce]</p>\n<p>InDirect RETURN to[RtlAddAccessAllowedAce]</p>\n<p>[mov esi, eax]</p>\n</blockquote>\n<p>I feel like there is something fundamentally wrong in the way I handle these calls and rets \"decoding\". Can someone point me to where am I exactly wrong? Also two secondary questions.</p>\n<p>1)  How to record return to the main module of an executable based on the instruction?</p>\n<p>2) Is there a way to get values of IARG_BRANCH_TARGET_ADDR and IARG_BRANCH_TAKEN outside of INS_InsertCall (or similar) functions?</p>\n<p>Thank you.</p>\n<p>The source code is below.</p>\n<pre><code>#include &lt;stdio.h&gt;\n//#include &lt;chrono&gt;\n#include \"pin.H\"\n#include &lt;string&gt;\n#include &lt;exception&gt;\n\nFILE * ftrace;\nlong long icount=0;\nlong long ilimit=1000000;\nBOOL print_args=false;\n\n\nstring invalid = \"invalid_rtn\";\nconst string *Target2String(ADDRINT target)\n{\n    string name = RTN_FindNameByAddress(target);\n    if (name == \"\")\n        return &amp;invalid;\n    else\n        return new string(name);\n}\n\nVOID  do_call_args(const string *s, ADDRINT arg0)\n{\n    fprintf(ftrace, \"\\n[%s]\\n\", (*s).c_str()); //(INS_Disassemble(ins)).c_str()\n    fflush(ftrace);\n}\n\n/* ===================================================================== */\n\nVOID  do_call_args_indirect(ADDRINT target, BOOL taken, ADDRINT arg0)\n{\n    if (!taken) return;\n\n    const string *s = Target2String(target);\n    do_call_args(s, arg0);\n\n    if (s != &amp;invalid)\n        delete s;\n}\n\n/* ===================================================================== */\n\nVOID  do_call(const string *s)\n{\n    fprintf(ftrace, \"\\n[%s]\\n\", (*s).c_str()); //(INS_Disassemble(ins)).c_str()\n    fflush(ftrace);\n}\n\nVOID  do_ret(const string *s)\n{\n    fprintf(ftrace, \"\\nDirect RETURN to[%s]\\n\", (*s).c_str()); //(INS_Disassemble(ins)).c_str()\n    fflush(ftrace);\n}\n\n/* ===================================================================== */\n\nVOID  do_call_indirect(ADDRINT target, BOOL taken)\n{\n    if (!taken) return;\n\n    const string *s = Target2String(target);\n    do_call(s);\n\n    if (s != &amp;invalid)\n        delete s;\n}\n\nVOID  do_ret_indirect(ADDRINT target, BOOL taken)\n{\n    if (!taken) return;\n\n    const string *s = Target2String(target);\n    fprintf(ftrace, \"\\nInDirect RETURN to[%s]\\n\", (*s).c_str()); //(INS_Disassemble(ins)).c_str()\n    fflush(ftrace);\n\n    if (s != &amp;invalid)\n        delete s;\n}\n\n\nVOID Instruction(INS ins, VOID *v)\n{\n\n    //start = std::chrono::high_resolution_clock::now();\n    UINT32 memOperands = INS_MemoryOperandCount(ins);\n\n    fprintf(ftrace, \"\\n[%s]\\n\", (INS_Disassemble(ins)).c_str()); //(INS_Disassemble(ins)).c_str()\n    fflush(ftrace);\n    if (INS_IsCall(ins))\n    {\n        if (INS_IsDirectBranchOrCall(ins))\n        {\n            const ADDRINT target = INS_DirectBranchOrCallTargetAddress(ins);\n\n\n            INS_InsertPredicatedCall(ins, IPOINT_BEFORE, AFUNPTR(do_call_args),\n                IARG_PTR, Target2String(target), IARG_FUNCARG_CALLSITE_VALUE, 0, IARG_END);\n\n        }\n        else\n        {\n            INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(do_call_indirect),\n                IARG_BRANCH_TARGET_ADDR, IARG_BRANCH_TAKEN, IARG_END);\n        }\n    }\n    else\n    {\n        if (INS_IsRet(ins))\n        {\n            if (INS_IsDirectBranchOrCall(ins))\n            {\n                const ADDRINT target = INS_DirectBranchOrCallTargetAddress(ins);\n\n\n                INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(do_ret),\n                    IARG_PTR, Target2String(target), IARG_FUNCARG_CALLSITE_VALUE, 0, IARG_END);\n\n            }\n            else\n            {\n                INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(do_ret_indirect),\n                    IARG_BRANCH_TARGET_ADDR, IARG_BRANCH_TAKEN, IARG_END);\n            }\n        }\n        else\n        {\n            // sometimes code is not in an image\n            RTN rtn = INS_Rtn(ins);\n\n            // also track stup jumps into share libraries\n            if (RTN_Valid(rtn) &amp;&amp; !INS_IsDirectBranchOrCall(ins) &amp;&amp; \".plt\" == SEC_Name(RTN_Sec(rtn)))\n            {\n                if (print_args)\n                {\n                    INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(do_call_args_indirect),\n                        IARG_BRANCH_TARGET_ADDR, IARG_BRANCH_TAKEN, IARG_FUNCARG_CALLSITE_VALUE, 0, IARG_END);\n                }\n                else\n                {\n                    INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(do_call_indirect),\n                        IARG_BRANCH_TARGET_ADDR, IARG_BRANCH_TAKEN, IARG_END);\n\n                }\n            }\n        }\n    }\n\n\n\n        for (UINT32 memOp = 0; memOp &lt; memOperands; memOp++)\n        {\n\n            if (INS_MemoryOperandIsRead(ins, memOp))\n            {\n                fprintf(ftrace, \"R\");\n                icount++;\n\n            }\n\n            if (INS_MemoryOperandIsWritten(ins, memOp))\n            {\n\n                fprintf(ftrace, \"W\");\n                icount++;\n\n            }\n        }\n\n}\nVOID Fini(INT32 code, VOID *v)\n{    fprintf(ftrace, \"\\n\");\n    fclose(ftrace);\n}\nINT32 Usage()\n{\n    PIN_ERROR( \"This Pintool prints a trace of memory addresses\\n\"\n              + KNOB_BASE::StringKnobSummary() + \"\\n\");\n    return -1;\n}\nKNOB&lt;string&gt; KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"o\", \"pinatrace2.out\", \"specify output file name\");\n\nKNOB&lt;long long&gt; KnobInsLimit(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"i\", \"1000\", \"specify instruction limit\");\n\nKNOB&lt;BOOL&gt;   KnobPrintArgs(KNOB_MODE_WRITEONCE, \"pintool\", \"a\", \"0\", \"print call arguments \");\n\nint main(int argc, char *argv[])\n{\n    PIN_InitSymbols();\n    if (PIN_Init(argc, argv)) return Usage();   \n    ilimit=KnobInsLimit.Value();   \n    ftrace = fopen(KnobOutputFile.Value().c_str(), \"w\");\n    print_args = KnobPrintArgs.Value();\n    INS_AddInstrumentFunction(Instruction, 0);\n    //TRACE_AddInstrumentFunction(Trace, 0);\n    PIN_AddFiniFunction(Fini, 0);   \n    PIN_StartProgram();\n\n    return 0;\n}\n</code></pre>\n</div>",
    "votes": "1",
    "answers": 0,
    "views": "3k",
    "tags": [
        "instrumentation",
        "pintool",
        "system-call",
        "tracing"
    ],
    "user": "aGGeRReS",
    "time": "Jan 31, 2019 at 9:28",
    "comments": [
        {
            "user": "aGGeRReS",
            "text": "<span class=\"comment-copy\">A partial solution to my question one could be the following: <code>RTN insRoutine = INS_Rtn(ins); SEC insSection = RTN_Sec(insRoutine); IMG insImage = SEC_Img(insSection);</code>  Then apply filtering (or marking) with <code>IMG_IsMainExecutable(insImage)</code></span>",
            "time": null
        },
        {
            "user": "Ahmad Alawneh",
            "text": "<span class=\"comment-copy\">any luck solving the issue? it's painful</span>",
            "time": null
        }
    ],
    "answers_data": []
}