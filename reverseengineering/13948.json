{
    "title": "How to find Bootloader Load Address?",
    "link": "https://reverseengineering.stackexchange.com/questions/13948/how-to-find-bootloader-load-address",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I've followed the tutorial found at: <a href=\"http://www.devttys0.com/2011/05/reverse-engineering-firmware-linksys-wag120n/\" rel=\"nofollow noreferrer\">http://www.devttys0.com/2011/05/reverse-engineering-firmware-linksys-wag120n/</a></p>\n<p>I've loaded the uboot image into IDA, but I'm not sure how to determine the load address. I've looked through start.S for a general idea of how things work, but was unable to apply that when looking at the image. </p>\n<p>I found another tutorial describing how to determine the load address (<a href=\"https://sviehb.wordpress.com/2011/09/09/reverse-engineering-an-obfuscated-firmware-image-e02-analysis/\" rel=\"nofollow noreferrer\">https://sviehb.wordpress.com/2011/09/09/reverse-engineering-an-obfuscated-firmware-image-e02-analysis/</a>) but could not find the corresponding memory address of the .bss initialization loop in the uboot image.</p>\n<p>Any help would be greatly appreciated! If you have any tips on determining the load address that would be awesome too.</p>\n<p>Thanks</p>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "6k",
    "tags": [
        "ida",
        "firmware",
        "embedded",
        "mips"
    ],
    "user": "HKC",
    "time": "Nov 17, 2016 at 1:09",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><strong>Download link:</strong> <a href=\"http://www.linksys.com/pl/support-article?articleNum=156227\" rel=\"nofollow noreferrer\">WAG120N Downloads</a></p>\n<p><strong>Firmware binary:</strong> </p>\n<pre><code>$ md5sum WAG120N-EU-ANNEXB-ETSI-1.00.19-code.bin\n52d6fa830e31ff96289f8aa41ac713af  WAG120N-EU-ANNEXB-ETSI-1.00.19-code.bin\n</code></pre>\n<p><strong>Version:</strong> Annex B - Version:  1.00.19 (ETSI) Latest Date:  11/17/2014</p>\n<p><strong>Signature scan output:</strong></p>\n<pre><code>$ binwalk WAG120N-EU-ANNEXB-ETSI-1.00.19-code.bin\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n9660          0x25BC          U-Boot version string, \"U-Boot 1.1.5-2.0 (Jul 22 2009 - 14:05:28)\"\n9708          0x25EC          CRC32 polynomial table, big endian\n11012         0x2B04          uImage header, header size: 64 bytes, header CRC: 0xF5170888, created: 2009-07-22 06:05:29, image size: 47540 bytes, Data Address: 0x80400000, Entry Point: 0x80400000, data CRC: 0x84EF8694, OS: Linux, CPU: MIPS, image type: Firmware Image, compression type: lzma, image name: \"u-boot image\"\n11076         0x2B44          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 147212 bytes\n65434         0xFF9A          Sercomm firmware signature, version control: 1, download control: 256, hardware ID: \"YQZ\", hardware version: 0x0, firmware version: 0x9, starting code segment: 0x100, code size: 0x7300\n65497         0xFFD9          Sercomm firmware signature, version control: 0, download control: 0, hardware ID: \"\", hardware version: 0x0, firmware version: 0x2700, starting code segment: 0x1A9C, code size: 0x3D0\n72028         0x1195C         Sercomm firmware signature, version control: 29184, download control: 24933, hardware ID: \"d ok..!!\", hardware version: 0x7266, firmware version: 0x2578, starting code segment: 0xA78, code size: 0x0\n196608        0x30000         uImage header, header size: 64 bytes, header CRC: 0xED45C533, created: 2014-11-04 09:41:33, image size: 577083 bytes, Data Address: 0x80002000, Entry Point: 0x801B2040, data CRC: 0x5AFA7402, OS: Linux, CPU: MIPS, image type: OS Kernel Image, compression type: lzma, image name: \"MIPS Linux-2.4.31-Amazon_SE-3.6.]\"\n196672        0x30040         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 1986560 bytes\n851968        0xD0000         Squashfs filesystem, big endian, lzma compression, version 2.1, size: 2991870 bytes, 748 inodes, blocksize: 65536 bytes, created: 2014-11-04 09:42:21\n</code></pre>\n<p>According to the signature scan, the u-boot image is of <code>image type: Firmware Image</code> and data address and entry point is <code>0x80400000</code>.</p>\n<p>How should this information be interpreted? Let us begin with a description of  <a href=\"http://www.denx.de/wiki/DULG/UBootImages\" rel=\"nofollow noreferrer\">U-Boot image formats</a>:\n<a href=\"https://i.sstatic.net/n1NiM.png\" rel=\"nofollow noreferrer\"><img alt=\"U-Boot Image formats\" src=\"https://i.sstatic.net/n1NiM.png\"/></a></p>\n<p>From <a href=\"https://github.com/u-boot/u-boot/blob/master/include/image.h\" rel=\"nofollow noreferrer\">include/image.h</a>:</p>\n<p>On line 230:</p>\n<pre><code>* \"Firmware Images\" are binary images containing firmware (like\n*      U-Boot or FPGA images) which usually will be programmed to\n*      flash memory.\n</code></pre>\n<p>The image header:</p>\n<pre><code>/*\n * Legacy format image header,\n * all data in network byte order (aka natural aka bigendian).\n */\ntypedef struct image_header {\n    __be32      ih_magic;       /* Image Header Magic Number    */\n    __be32      ih_hcrc;        /* Image Header CRC Checksum    */\n    __be32      ih_time;        /* Image Creation Timestamp     */\n    __be32      ih_size;        /* Image Data Size              */\n    __be32      ih_load;        /* Data  Load  Address          */\n    __be32      ih_ep;          /* Entry Point Address          */\n    __be32      ih_dcrc;        /* Image Data CRC Checksum      */\n    uint8_t     ih_os;          /* Operating System             */\n    uint8_t     ih_arch;        /* CPU architecture             */\n    uint8_t     ih_type;        /* Image Type                   */\n    uint8_t     ih_comp;        /* Compression Type             */\n    uint8_t     ih_name[IH_NMLEN];  /* Image Name               */\n} image_header_t;\n</code></pre>\n<p>Image info:</p>\n<pre><code>typedef struct image_info {\n    ulong       start, end;             /* start/end of blob */\n    ulong       image_start, image_len; /* start of image within blob, len of image */\n    ulong       load;                   /* load addr for the image */\n    uint8_t     comp, type, os;         /* compression, type of image, os type */\n    uint8_t     arch;                   /* CPU architecture */\n} image_info_t;\n</code></pre>\n<p>Information about the load address is stored in the uImage header and this is what is output in a signature scan by <code>binwalk</code>. In this case it is <code>0x8040000</code>.</p>\n<p>see also: </p>\n<p><a href=\"https://reverseengineering.stackexchange.com/questions/11096/reverse-engineering-mips-bootloader\">Reverse Engineering MIPS Bootloader</a></p>\n<p><a href=\"http://www.johnloomis.org/microchip/pic32/memory/memory.html\" rel=\"nofollow noreferrer\">MIPS Address Space</a></p>\n<p><a href=\"http://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8\" rel=\"nofollow noreferrer\">Reverse Engineering VxWorks Firmware: WRT54Gv8</a></p>\n<p><a href=\"http://www.isysop.com/unpacking-and-repacking-u-boot-uimage-files/\" rel=\"nofollow noreferrer\">Unpacking and repacking U-Boot uImage files</a></p>\n<p><a href=\"http://www.linuxjournal.com/content/handy-u-boot-trick\" rel=\"nofollow noreferrer\">A Handy U-Boot Trick</a></p>\n<p><a href=\"http://www.nulltrace.org/2013/04/mips-bootstrapping.html\" rel=\"nofollow noreferrer\">MIPS Bootstrapping</a></p>\n</div>",
            "votes": "5",
            "user": "Community",
            "time": "Apr 13, 2017 at 12:49",
            "is_accepted": false,
            "comments": []
        }
    ]
}