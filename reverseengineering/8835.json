{
    "title": "IL for decompiler to human-readable format",
    "link": "https://reverseengineering.stackexchange.com/questions/8835/il-for-decompiler-to-human-readable-format",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>After writing my own disassembler, I am now looking to making its assembly listing more human readable, e.g. from an (artificial) example</p>\n<pre><code>push    ebp\nmov     ebp, esp\nsub     esp, 10h\nmov     eax, dword ptr [55431824h]\nimul    eax, dword ptr [ebp+8]\nadd     eax, dword ptr [ebp+0ch]\nmov     dword ptr [ebp-4], eax\nmov     eax, dword ptr [ebp-4]\nleave\nret     10h\n</code></pre>\n<p>via (<code>&gt;</code> marks an auto-recognized prologue/epilogue):</p>\n<pre><code>&gt;push    ebp\n&gt;mov     ebp, esp\n&gt;sub     esp, 10h\n\n mov     eax, dword ptr [_global_55431824]\n imul    eax, dword ptr [arg_0]\n add     eax, dword ptr [arg_4]\n mov     dword ptr [local_4], eax\n mov     eax, dword ptr [local_4]\n\n&gt;leave\n&gt;ret     10h\n</code></pre>\n<p>towards</p>\n<pre><code>eax = 10\neax *= arg_0\neax += arg_4\nlocal_4 = eax\neax = local_4\nreturn\n</code></pre>\n<p>At this point, each pseudo instruction is still tied to its original disassembled representation. When printing out, I can scan for certain sequences and so I replace the first two lines with</p>\n<pre><code>eax = 10 * arg_0\n</code></pre>\n<p>and then just skip printing the next line. However, there is a limit to how far I can get with that. Concatenating the next operation, which would lead to</p>\n<pre><code>eax = 10 * arg_0 + arg_4\n</code></pre>\n<p>requires to look ahead <strong>two</strong> instructions, <em>and</em> would only work for this specific combination of <code>mov</code>, <code>imul</code>, and <code>add</code>, while assuring the same destination register is still targeted and the intermediate instructions have no lasting effect on other registers.</p>\n<p>The goal is to end up with something like this:</p>\n<pre><code>local_4 = 10 * arg_0 + arg_4\neax = local_4\nreturn\n</code></pre>\n<p>where obviously <code>eax</code> is specifically assigned a value before a <code>return</code>, so the last line can be</p>\n<pre><code>return eax\n</code></pre>\n<p>and finally the entire construction can be collapsed into</p>\n<pre><code>return 10 * arg_0 + arg_4\n</code></pre>\n<p>(which is very close to what I started with in the original trivial C program). I am struggling with the internal representation of composite lines such as the last one. The otherwise very reliable decompiler page <a href=\"http://www.backerstreet.com/decompiler/creating_statements.php\" rel=\"noreferrer\">backerstreet.com/creating_statements</a> casually switches between raw assembler and C-like compound statements:</p>\n<pre><code>if(!expr1 &amp;&amp; !expr2)\n  ...\n</code></pre>\n<p>without explaining how this intermediate step is stored in memory and can create the output string.</p>\n<p>What type of intermediate storage form should I be looking at, which (a) can be constructed from the original disassembled instructions, (b) can have its elements combined and rearranged, and (c) can be translated into human-readable output such as the last line?</p>\n<p>It may be worth mentioning that I am not aiming to create the Definitive Universal Decompiler :) My test input was compiled with an ancient version (most likely pre-1993) of Delphi Pascal, but while its assembly is not really optimized and fairly readable to begin with, I'd still like to go the extra mile and make my computer do what it does best and make it yet easier to understand the code.</p>\n<hr/>\n<h3>A longer real world example</h3>\n<p>Below is some actual disassembly. The basic block number is followed by a dominator bit set (the <code>loops</code> hex number; I generate them but have not used that data yet). The <code>ENTRY</code> and <code>EXIT</code> numbers are to basic blocks again and used to generate a .dot view of the function.</p>\n<pre><code>; ## BLOCK 0; loops: 01; EXIT to 1, 4\n401966A8    (  0)  8B 15 42201590       mov     edx,dword ptr [42201590]\n401966AE    (  0)  8B 12                mov     edx,dword ptr [edx]\n401966B0    (  0)  80 BA 39 01 00 00 02 cmp     byte ptr [edx+139h],2\n401966B7    (  0)  75 11                jnz     label_4\n\n; ## BLOCK 1; loops: 03; ENTER from 0; EXIT to 2, 4\n401966B9    (  0)  83 78 24 02          cmp     dword ptr [eax+24h],2\n401966BD    (  0)  7D 0B                jge     label_4\n\n; ## BLOCK 2; loops: 07; ENTER from 1; EXIT to 3=RET\n401966BF    (  0)  BA 02 00 00 00       mov     edx,2\n401966C4    (  0)  2B 50 24             sub     edx,dword ptr [eax+24h]\n401966C7    (  0)  8B C2                mov     eax,edx\n\n; ## BLOCK 3 (epilog); loops: 0F; ENTER from 2\n401966C9          &gt;C3                   retn    \n\n; ## BLOCK 4; loops: 11; ENTER from 0, 1; EXIT to 5, 7\n                        label_4:\n401966CA    (  0)  8B 15 42201590       mov     edx,dword ptr [42201590]\n401966D0    (  0)  8B 12                mov     edx,dword ptr [edx]\n401966D2    (  0)  80 BA 39 01 00 00 01 cmp     byte ptr [edx+139h],1\n401966D9    (  0)  75 0D                jnz     label_7\n\n; ## BLOCK 5; loops: 31; ENTER from 4; EXIT to 6, 7\n401966DB    (  0)  83 78 24 00          cmp     dword ptr [eax+24h],0\n401966DF    (  0)  75 07                jnz     label_7\n\n; ## BLOCK 6; loops: 71; ENTER from 5; EXIT to 8=RET\n401966E1    (  0)  B8 01 00 00 00       mov     eax,1\n401966E6    (  0)  EB 02                jmp     label_8\n\n; ## BLOCK 7; loops: 91; ENTER from 4, 5; EXIT to 8=RET\n                        label_7:\n401966E8    (  0)  33 C0                xor     eax,eax\n\n; ## BLOCK 8 (epilog); loops: 0111; ENTER from 6, 7\n                        label_8:\n401966EA          &gt;C3                   retn    \n\n401966EB                align 4\n</code></pre>\n<p>This is the .dot image; clear <code>if</code>s are yellow, and the nodes contain their dominator bit sets so I can try and make sense of them (a TO-DO as yet). This explains the <em>flow</em> but you cannot see how much <em>code</em> each node represents.</p>\n<p><img alt=\"function flow\" src=\"https://i.sstatic.net/NBPCo.png\"/></p>\n<p>The disassembly gets parsed into the following pseudo-code. Some notes are <code><b>manually added</b></code>.</p>\n<pre>; #### PARSED\n401966A8    (  0)       edx = Main.UnitList@20551314 ;\n401966AE    (  0)       edx = (dword)[edx] ;\n401966B0    (  0)       if ((byte)[edx + 139h] != 2) goto label_4 ;\n\n401966B9    (  0)       if ((dword)[eax + 24h] &gt;= 2) goto label_4 ;\n\n401966BF    (  0)       edx = 2 ;\n401966C4    (  0)       edx -= (dword)[eax + 24h] ;\n401966C7    (  0)       return edx ; <b>MOV EAX,.. where an exit block follows</b>\n\n                        return ;  <b>.. and this line is generated by the actual exit block</b>\n\n                    label_4:\n401966CA    (  0)       edx = Main.UnitList@20551314 ;\n401966D0    (  0)       edx = (dword)[edx] ;\n401966D2    (  0)       if ((byte)[edx + 139h] != 1) goto label_7 ;\n\n401966DB    (  0)       if ((dword)[eax + 24h] != 0) goto label_7 ;\n\n401966E1    (  0)       eax = 1 ;\n401966E6    (  0)       return ;  <b>this was a jump-to-exit-block, so missed</b>\n\n                    label_7:\n401966E8    (  0)       eax = 0 ; <b>this was a XOR, not a MOV, so missed</b>\n\n                    label_8:\n                        return ;\n</pre>\n<p>The loss in verbosity is already worth the effort: from 21 lines of code to 16 lines, even though the lookahead to check if EAX got written to right before a <code>RET</code> failed twice.</p>\n<p>Yet, it is obvious that the two successive <code>if</code>s at <code>401966B0</code> can be combined into a single one, with an OR. Inverting the condition, that whole block can be a single <code>if</code> and braced up to the <code>return</code>, removing <code>label_4</code>.<br/>\nThe manipulation of <code>edx</code> from <code>401966BF</code> onwards can be concatenated into a single <code>return</code> statement.<br/>\nAlso, the <code>if</code> conditions at <code>401966D2</code> can be combined into a single one and put inside an <code>if</code> block. Since there is a <code>return</code> at its end, an <code>else</code> is not necessary there. Manually reconstructed:</p>\n<pre><code>401966A8    (  0)       edx = Main.UnitList@20551314 ;\n401966AE    (  0)       edx = (dword)[edx] ;\n401966B0    (  0)       if ((byte)[edx + 139h] == 2 &amp;&amp;\n401966B9    (  0)           (dword)[eax + 24h] &lt; 2)\n                        {\n401966BF    (  0)           return 2 - (dword)[eax + 24h] ;\n                        }\n\n401966CA    (  0)       edx = Main.UnitList@20551314 ;\n401966D0    (  0)       edx = (dword)[edx] ;\n401966D2    (  0)       if ((byte)[edx + 139h] == 1 &amp;&amp;\n401966DB    (  0)          (dword)[eax + 24h] == 0)\n                        {\n401966E1    (  0)           return 1 ;\n                        }\n\n401966E8    (  0)       return 0 ;\n</code></pre>\n<p>reducing the original 21 lines to a mere 11. Furthermore, register value propagation resolves the references to the global class <code>Main.UnitList</code>. I manually created names for its elements; <code>401966A8</code> and forwards collapses into</p>\n<pre><code>401966B0    (  0)       if (Main.UnitList.flag == 2 &amp;&amp;\n401966B9    (  0)           Main.UnitList.count &lt; 2)\n</code></pre>\n<p>which makes the code practically readable.</p>\n<p><sup>Accessing <code>eax</code> before it gets written is not an error here. The function is a class function, and <code>eax</code> points to a class instance, so <code>(dword)[eax + 24h]</code> reads a data member of the structure. <code>Main.UnitList</code> is a pointer to a globally declared class instance, since it points into the BSS.</sup></p>\n</div>",
    "votes": "8",
    "answers": 2,
    "views": "1k",
    "tags": [
        "disassembly",
        "decompilation"
    ],
    "user": "Jongware",
    "time": "May 8, 2015 at 9:48",
    "comments": [
        {
            "user": "Guntram Blohm",
            "text": "<span class=\"comment-copy\">What you're trying to do is <i>very</i> hard. Consider how long the Hex-Rays decompilers have been developed, and how much manual tuning the results need.</span>",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "<span class=\"comment-copy\">@GuntramBlohm: well I cannot but agree with that. The next step, from registers and 'local' variable to 'actual' variables, is within my capabilities (tracking the life time of each registers), but then I end up with a list of singular operations, which I want to concatenate – at least for the trivial cases. That needs an IL, conceptually separated from the original assembly.</span>",
            "time": null
        },
        {
            "user": "yaspr",
            "text": "<span class=\"comment-copy\">Indeed, as @GuntramBlohm stated, decompilation isn't for the faint of heart. But, it is doable, though you'll have to make difficult choices. Check out McSema (<a href=\"http://blog.trailofbits.com/2014/08/07/mcsema-is-officially-open-source/\" rel=\"nofollow noreferrer\">blog.trailofbits.com/2014/08/07/…</a>), it does a remarkable job transforming x86 assembly into LLVM IR. Keep in mind that what you're trying to do requires the extensive use of heuristics &amp; pattern matching.</span>",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "<span class=\"comment-copy\">@yaspr: that looks good! Yes, as my target is fairly limited (I added a paragraph about that), I may look in to pattern matching. The compiler that was used was an oldie, no fancy optimizations – here and there not even (humanly) obvious ones.</span>",
            "time": null
        },
        {
            "user": "yaspr",
            "text": "<span class=\"comment-copy\">@Jongware Well, I kind of noticed the stack operations which most modern compilers would've avoided; my thought was either this is -O0 code or an old compiler.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>For creating \"humanly\" readable expressions, i'd use an <a href=\"http://cas.ee.ic.ac.uk/people/ccb98/teaching/ee2_software_engineering/Lecture10-Parsing2.pdf\" rel=\"nofollow noreferrer\">arithmetic parse tree</a>. In fact, one separate parse tree for each of the registers and memory locations that are involved.</p>\n<p>Every assignment copies the root of the target tree to the destination tree.</p>\n<p>Every arithmetic operation creates a new root containing the operation, with the operands as the left &amp; right child. The resulting tree is assigned to the target of the arithmetic operation.</p>\n<p>Your example builds up like this:</p>\n<p><img alt=\"example parse trees\" src=\"https://i.sstatic.net/24L2k.png\"/></p>\n<p>From there, emitting the resulting formula is just a ltr tree walk. You'll probably want to simplify your expression first; you can replace an operator that has two constant subnodes with the operation result, and you might want to transform your tree by moving constants down where possible, like this:</p>\n<pre><code>              eax\n               |\n              add\n               |\n     +---------+--------+\n     |                  |\n    add                 5\n     |                  \n+----+-------+          \n|            |\n2           ebx\n\n\n              eax\n               |\n              add\n               |\n     +---------+--------+\n     |                  |\n    add                ebx\n     |                  \n+----+-------+         \n|            |\n2            5\n\n              eax\n               |\n              add\n               |\n     +---------+--------+\n     |                  |\n     7                 ebx\n</code></pre>\n<p>Google for \"expression tree\" and \"constant folding\" for more resources on this.</p>\n<p>Mind that trees might be \"self-referencing\", especially in loops; the loop control variable will be seen at the top node, and somewhere down the tree as well. This is actually a good way to identify loop variables.</p>\n<p>I'd probably start with trying to recognize basic blocks (everything that doesn't contain a jmp instruction or destination), and then build and dump the expression trees for these basic blocks. If you get this working well, you might continue by identifying stuff that stretches over several blocks, but is constant in some of them, like loops, to find out what's being built over the whole function.</p>\n<p><strong>EDIT: Another example, which shows how to treat register moves</strong></p>\n<p>A raw register move just copies the tree from the source register to the destination register. This is from an old watcom C program, compiled when <code>imul</code> was slow, and a series of shift/add instructions was faster; the compiler calculates var*45 here:</p>\n<pre><code>mov eax, [var]\nmov edx, eax      &lt;-- tree copy here (not much of a tree, however)\nshl edx, 2\nadd eax, edx\nmov edx, eax      &lt;-- tree copy again\nshl eax, 3\nadd eax, edx\n</code></pre>\n<p><img alt=\"arithmetic example var*45\" src=\"https://i.sstatic.net/YVM9G.png\"/></p>\n</div>",
            "votes": "3",
            "user": "Guntram Blohm",
            "time": "May 8, 2015 at 6:32",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Jongware",
                    "text": "<span class=\"comment-copy\">Thanks for the excellent example. I already have the Basic Blocks (improved since <a href=\"http://reverseengineering.stackexchange.com/questions/2895/delphi-pascal-try-except-finally-block\">my last question on those</a>), and they help a lot in deciding variable scope. Since variables need cleaning up anyway, could that be done by storing the raw register moves in this same tree and then cleaning up the branches?</span>",
                    "time": null
                },
                {
                    "user": "Guntram Blohm",
                    "text": "<span class=\"comment-copy\">Added another example. A raw register move translates to the tree being copied from the source to the destination. At the end, each register has a tree that has the register value (<code>edx</code>, not shown in the last step, still has <code>var*5</code>), and each tree depends on input variables only (there's no <code>edx</code> in the last representation of <code>eax</code>, even though it was used in the calculation). After cleaning up the <code>eax</code> tree, you have <code>var mul 45</code>.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>What you're describing here is essentially the same as a static binary translator that uses a high level language such as C as its output target rather than a specific architecture.  It's not quite as advanced a mechanism as decompiling but it has proven quite effective in restricted domains such as arcade video games. (eg <a href=\"http://vide.malban.de/vectrex-programs/vecfever\" rel=\"nofollow noreferrer\">http://vide.malban.de/vectrex-programs/vecfever</a> )  There have been a few of these written; I have code for work in progress that does this for 6809, 6502, z80 and Cinematronic CPUs for example (though probably not immediately usable - it's a coming-together of four separate background projects with no great urgency).  Anyway feel free to poke around and see if there's anything here that is helpful to you: <a href=\"http://gtoal.com/SBTPROJECT/\" rel=\"nofollow noreferrer\">http://gtoal.com/SBTPROJECT/</a> (the 6809 one is probably the cleanest code if you're just browsing and not actually running it)</p>\n<p>There's a bit of a writeup of the overall method at <a href=\"http://gtoal.com/sbt/\" rel=\"nofollow noreferrer\">http://gtoal.com/sbt/</a></p>\n<p>Output looks something like this:</p>\n<pre><code>            //        LDA   $FFFF,X                 ; 0431: A6 1F         \n      A = memory[(UINT16)(X + 0xffff)];\n  //  N = A;\n  //  Z = A;\n  //  V = 0;\n\n            //        LEAU  ,X                      ; 0433: 33 84         \n      U = X;\n\n            //        LDX   #$0EC8                  ; 0435: 8E 0E C8      \n      X = 0x0ec8;\n  //  Z = X;\n  //  N = (X) &gt;&gt; 8;\n  //  V = 0;\n</code></pre>\n<p>(the commented out lines are due to optimisation of redundant stores)</p>\n<p>Rather than output functional code for execution, you could satisfy the OP's request by outputting comments that describe in detail what the operations are doing.</p>\n<p>Other practical translators have been written by David Welch, Norbert Keher, Thomas Sontowski and others.  There is also Project Orion which is a multi-person multi-target translator headed up by Neil Bradley (respected emulator author) and several other members of the Orion mailing list - that translator had working front ends for 6502 and z80, with 68000 and 6809 also being under development, and built an internal AST (Abstract Syntax Tree, much as described in one of the earlier answers in this thread) in order to output cleaner and more efficient code to a variety of back ends including C.  (There is also some academic work produced by Christina Cifuentes et al.)</p>\n<p>Graham</p>\n<p>PS When the output is a generic IR (Internal Representation) such as C or LLVM's internal IR, as opposed to when you produce binary directly, or indirectly by outputting asm for a specific architecture) the technique is properly called \"Compiled Instruction Set Simulation\" - but most people just call it static binary translation.</p>\n</div>",
            "votes": "1",
            "user": "Graham Toal",
            "time": "Apr 16, 2020 at 9:43",
            "is_accepted": false,
            "comments": []
        }
    ]
}