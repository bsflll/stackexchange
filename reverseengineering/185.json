{
    "title": "How do I add functionality to an existing binary executable?",
    "link": "https://reverseengineering.stackexchange.com/questions/185/how-do-i-add-functionality-to-an-existing-binary-executable",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I want to add some functionality to an existing binary file. The binary file was created using <code>gcc</code>. </p>\n<ul>\n<li>Do I need to decompile the binary first, even though I sufficiently understand the functioning of the program ? </li>\n<li>How should I go about adding the necessary code ?</li>\n<li>Do I need any tools to be able to do this ?</li>\n</ul>\n</div>",
    "votes": "48",
    "answers": 8,
    "views": "34k",
    "tags": [
        "linux",
        "c",
        "executable",
        "hll-mapping"
    ],
    "user": "asheeshr",
    "time": "Apr 5, 2013 at 13:25",
    "comments": [
        {
            "user": "Remko",
            "text": "<span class=\"comment-copy\">for what platform eg windows, linux?</span>",
            "time": null
        },
        {
            "user": "sw.",
            "text": "<span class=\"comment-copy\">What is the functionality that you want to add? because depending on that there are different approaches. For example for automating a GUI you use a different technique that for example changing a database engine.</span>",
            "time": null
        },
        {
            "user": "Ciro Santilli OurBigBook.com",
            "text": "<span class=\"comment-copy\"><a href=\"http://stackoverflow.com/questions/4309771/disassembling-modifying-and-then-reassembling-a-linux-executable\" title=\"disassembling modifying and then reassembling a linux executable\">stackoverflow.com/questions/4309771/…</a></span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>There are several broad ways in which you could do this.</p>\n<ol>\n<li><p>Dynamic instrumentation</p>\n<p>Tools such as <a href=\"http://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool\">PIN</a>, <a href=\"http://valgrind.org/\">Valgrind</a>, or <a href=\"http://www.dynamorio.org/\">DynamoRIO</a> allow you to dynamically change the behavior of a program.  For instance, you can add calls to new functions at particular addresses, intercept library calls and change them, and much more.</p>\n<p>The downside is that dynamic instrumentation often has high overhead.</p></li>\n<li><p>Static instrumentation</p>\n<p>You can also try to statically modify the program to add the desired behavior.  One challenge is that you often need to muck around with the executable file format.  Some tools, such as <code>elfsh</code> from the <a href=\"http://www.eresi-project.org/\">ERESI</a> project exist for this, but I have found them buggy and difficult to use.</p>\n<p>Another strategy for static instrumentation is to \"recompile\".  You can do this by decompiling the program, modifying the source code, and recompiling.  In theory, you could also use a tool like <a href=\"http://bap.ece.cmu.edu\">BAP</a> to lift the program to IL, modify it, and then re-compile it using LLVM.  However, the current version is probably not mature enough for this.</p></li>\n<li><p>Dynamic loading</p>\n<p>You can use <code>LD_PRELOAD</code> to override functions that are going to be dynamically linked.  This is a nice option when you want to change the behavior of a library function.  Naturally, it does not work on statically linked binaries, or for static functions.</p></li>\n<li><p>Binary patching</p>\n<p>You can often make simple changes to a binary using a hex-editor.  For instance, if there is a function call or branch you would like to skip, you can often replace it with <code>nop</code> instructions.  If you need to add a large amount of new code, you will probably need to use something like <code>elfsh</code> from the <a href=\"http://www.eresi-project.org/\">ERESI</a> project to help you resize the binary.</p></li>\n</ol>\n</div>",
            "votes": "39",
            "user": "Ed McMan",
            "time": "Mar 23, 2013 at 15:47",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Very often, you can change the behavior of a program by carefully hooking into it. Whether you can add the functionality you want this way depends on how the program is constructed. It helps if the program comes in the form of one main executable plus several libraries.</p>\n<p>You can hook into any call that the program makes to shared libraries by linking your own library in first, with <code>LD_PRELOAD</code>. Write a library that defines a function <code>foo</code>, and set the environment variable <code>LD_PRELOAD</code> to the path to your compiled (<code>.so</code>) library when you start the program: then the program will call your <code>foo</code> instead of the one it intends. You can call the original <code>foo</code> function from your replacement by obtaining a pointer to it with <code>dlsym()</code>.</p>\n<p>Here are a few examples and tutorials:</p>\n<ul>\n<li><a href=\"http://www.technovelty.org/c/using-ld_preload-to-override-a-function.html\">Using LD_PRELOAD to override a function</a> — a minimal source code example</li>\n<li><a href=\"http://www.linuxjournal.com/article/7795\">Modifying a Dynamic Library Without Changing the Source Code</a></li>\n<li><a href=\"http://fluxius.handgrep.se/2011/10/31/the-magic-of-ld_preload-for-userland-rootkits/\">The magic of LD_PRELOAD for Userland Rootkits</a></li>\n<li><a href=\"https://nf.nci.org.au/training/talks/lca2009.pdf\">Fun with LD_PRELOAD</a> (a long and detailed presentation)</li>\n</ul>\n<p>Some examples of programs that use <code>LD_PRELOAD</code>:</p>\n<ul>\n<li><a href=\"https://github.com/fakechroot/fakechroot\">fakechroot</a>, <a href=\"http://plasticfs.sourceforge.net/\">PlasticFS</a> — rewrite the file names used by the program</li>\n<li><a href=\"http://perens.com/FreeSoftware/ElectricFence/\">Electric Fence</a>, <a href=\"http://valgrind.org/\">Valgrind</a> — detect bad heap usage by overriding <code>malloc</code></li>\n<li><a href=\"http://freecode.com/projects/libshape\">Libshape</a> — limit the network bandwidth</li>\n<li><a href=\"http://kde-apps.org/content/show.php?content=36077\">KGtk</a> — use KDE dialog boxes in a Gtk program</li>\n</ul>\n<p>The limitation of <code>LD_PRELOAD</code> is that you can only intercept function calls that are resolved at runtime (dynamic linking). If you want to intercept an internal call, you'll have to resort to heavier-weight techniques (modifying the executable on-disk, or in-memory with <code>ptrace</code>).</p>\n</div>",
            "votes": "18",
            "user": "Gilles 'SO- stop being evil'",
            "time": "Mar 23, 2013 at 14:53",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<blockquote>\n<p>I want to add some functionality to an existing binary file.</p>\n</blockquote>\n<p>So in general these four bigger Questions apply to modifying an Executeable:</p>\n<p><strong>The first basic Question posed:</strong> \nIs the Program wary of Code Modifications (Self-Checking, Anti-Debug-Tricks, Copy protection, ...)?</p>\n<p>If so: </p>\n<ol><li>Is it even possible to remove/circumevent these protections (e.g. unpacking, if it is packed) easily</li>\n<li>Is it worth the time to do so?</li></ol>\n<p><strong>The second Question is:</strong><br/>\nCan you find out, which Compiler/Language was used to produce the executeable?</p>\n<p>More Details are better, but most basic constructs (<code>if</code> and other control-structures) should map quite similarly over a variety of compilers.</p>\n<p>This is related to a previous <a href=\"https://reverseengineering.stackexchange.com/questions/11/what-hints-in-machine-code-can-point-me-to-the-compiler-which-was-used-to-genera/\" title=\"reverseengineering.stackexchange.com -- Detecting the used Compiler via hints in Machine Code &amp; does this Help?\">Question on the RE-Stackexchange</a>.</p>\n<p><strong>The third Question is:</strong><br/>\nHow is the user interface implemented (CLI, Win32-Window Controls, Custom, ...)?</p>\n<p>If this is known:<br/>\nCan you figure out the mapping of common HLL-Constructs (Menues, Dropdown-Menues, Checkboxes, ...) in conjunction with the used Compiler/Language that you want to modify?</p>\n<p><strong>The fourth and biggest Question is:</strong><br/>\nHow can you create the desired functionality in the Program?</p>\n<p>In essence this can require quite a bit of reverse engineering, to find out how to best hook into the program without upsetting it.</p>\n<p>Central Point: How can you utilize existing internal API's to reach your Goal, without breaking Stuff (like CRTL+Z, Versioning, Recovery features)?<ul><li>existing Datastructures (and how are they related?)</li>\n<li>existing Functions (Parameters, Parameter-Format, ...)\n<ul><li>What does it do?</li><li>What else can it do?</li><li>What does it REALLY do?</li><li>...</li></ul></li>\n<li>existing Processes (= How the program goes about internally, stepwise to implement similar features) <ul><li>What functions are called, in which order?</li><li>Which Data-Structures are utilized?</li></ul></li>\n<li>Where is the Meat of the feature/program (the data, e.g. the main painting area, and how does it relate internally?)</li>\n<li>Stuff to look out for (if it concerns the desired feature):<ul><li>Journaling</li><li>Recovery Features</li><li>Versioning</li></ul></li>\n<li>How is Metadata handled (e.g. Shutter speed, f-Stops, ...), that is related to the desired Feature.</li></ul></p>\n<p><b>Example projects:</b></p>\n<ul><li>Building a new kind of painting tool into a graphics program (without plugin-API).</li>\n<li>Extending the plugin-API of a program.</li>\n<li>Building a plugin-API into a program without one.</li>\n<li>Adding a new save/export-format for files (if there is no way to convert the output-format into a desired format, or if crucial information is missing in the exported files).</li>\n<li>Adding a new import-format (if there is no way to convert the input-format into a importable-format or if some information is not correctly imported).</li>\n<li>Extending Mspaint with a colour search-and-replace tool (within a selection, or in the whole picture)</li><li>Adding Proxy Support/Basic Proxy-Authentication to a Program.</li><li>Adding (new) Command line switches to a program that expose new/existing Features.</li><li>Adding a API for Remote Procedure-Calls to Manage the Operations of the Programm externally.</li><li>Adding Scripting-Support to automate often repeated Operations (If there is no plugin-/scripting-API to begin with) or support batch processing.</li></ul>\n<p><strong>Regarding wrapped Code &amp; Decompilers:</strong><br/>\nI will not talk about wrapped Code in other Languages that is packaged with a VM / an Interpreter (Py2Exe, Java 2 Exe, ...), or uses an installed one (JVM, C#). There are pretty good Decompilers for some of those cases. After a successful decompilation it pretty much boils down to defeating the Code Obfuscation (if there is one).</p>\n<p><strong>Regarding C/C++-Decompilers:</strong><br/>\nI cannot talk about C/C++-Decompilers, though it would boil down to best-effort HLL-Remapping (for stuff the Decompiler did not get) and Code-Deobfuscation (if it was compiled without Symbols) provided there is no further Protection in the Executeable.</p>\n<p><strong>Reccommendation regarding HLL-mapping:</strong><br/>\nIn essence a big part of this Question concerns \"HLL mapping\" (High level language mapping (in machine code)) of and the modification of these constructs in the corresponding machine code. </p>\n<p>I found an excellent downloadable starting course, that uses \"IDA Free\", on this Topic <a href=\"http://binary-auditing.com/\" rel=\"nofollow noreferrer\" title=\"Free IDA Pro Binary Auditing Training Material for University Lectures\">here</a> (binary-auditing.com).</p>\n</div>",
            "votes": "7",
            "user": "Community",
            "time": "Apr 13, 2017 at 12:49",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>(Slightly outdated, but as that wasn't mentioned previously in this thread)</p>\n<p>Long ago, I spend months extending a software with only the binary.</p>\n<ul>\n<li>I used IDA for analysis and SoftICE for live debugging. Decompiling is not required if you can understand the target at opcode/bytecode level.</li>\n<li><p>Then, because it was an x86 PE binary, I used Tasm and Iczelion's <strong>Code Snippet Creator</strong>: It's not a famous tool anymore, but it allowed to use Tasm transparently and re-inject code, with PE transformations, etc...</p>\n<p>It added code at EntryPoint, so I did my own patches manually, then jumped to original EntryPoint.</p></li>\n</ul>\n<p>A bit old-school now - I'd probably inject a DLL these days - but it certainly worked.</p>\n<p>And at least, it gives you full control via ASM, while keeping maintainability via automated patching.</p>\n</div>",
            "votes": "7",
            "user": "Ange",
            "time": "Mar 26, 2013 at 10:45",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>You do not need to decompile the binary. If you understand what changes you want to make, and those changes can be made by only modifying the binary file or its dependencies, then you can just make those modifications on disk or in memory. </p>\n<p>You have a few choices on how to effect the modification itself. </p>\n<p>You could use LD_PRELOAD to have the linker load a shared object before the binary runs. Then you don't need to modify the binary on disk at all. This is kind of what valgrind does, it loads as a shared object but then begins dynamic binary instrumentation. </p>\n<p>You could use <a href=\"http://valgrind.org/info/tools.html\" rel=\"nofollow\">valgrind</a>. Valgrind would allow you to dynamically re-write the program and modify its behavior arbitrarily. Valgrind is a dynamic binary instrumentation program that allows its tools to edit the program while it executes. If you just want to change program behavior this might work, but valgrind also incurs a global slowdown and if you wanted to patch and redistribute a program, it probably is not ideal. </p>\n<p>You could also use tools like <a href=\"http://www.eresi-project.org/\" rel=\"nofollow\">elfsh/eresi</a> to insert new code into the program. Those tools should take care of the act of injecting your code with relation to stuff like the ELF program header. There is a concept of \"ELF infector\" that you could google for, where your injected code becomes the new program entry point, does something, then jumps to the old program entry point. </p>\n</div>",
            "votes": "6",
            "user": "Lizz",
            "time": "Apr 6, 2013 at 17:43",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<h1>Doing that on Windows</h1>\n<p>Although this question focuses on Linux, where personally I would go with the easy <code>LD_PRELOAD</code> method as outlined in other answers, Windows knows a similar mechanism that in fact has been abused in the more recent past (also see alternative approaches below). I used that method to \"crack\" one dongle system.</p>\n<p>Enter ...</p>\n<h2>DLL placement (aka preloading, aka hijacking) attacks</h2>\n<p>The name has been given to the method fairly recently when it turned out that placing DLLs on remote shares and then navigating to shares in, say a media player, would result in the media player loading the remote DLL instead of a local version. This is by design. Changing it now would break hundreds if not thousands of applications.</p>\n<p>This has been addressed by Microsoft <a href=\"https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order\" rel=\"nofollow noreferrer\">in certain ways</a>, although the only real solution is proper implementation on the application side. But then, many developers haven't even grasped NT security even though we have to deal with it ever since Windows 2000 became the first consumer OS based on the NT platform.</p>\n<h3>What does it have to do with your described goal?</h3>\n<p>Adding functionality doesn't necessarily imply that you patch the executable on-disk. You can also do it in memory.</p>\n<h3>How can you leverage it?</h3>\n<p>Whenever an application uses a DLL, and you can tell the load order with <a href=\"https://www.dependencywalker.com/\" rel=\"nofollow noreferrer\">Dependency Walker</a> or under a debugger, you can pick one of the DLLs it imports and replace that (in its current location) or placing another DLL in a path that precedes the existing DLL in the load order.</p>\n<p>An alternative method is to change the name of the imported DLLs. In rare cases (well known DLLs, for example) this is the only viable method to load an alternative DLL and may still fail for certain special cases.</p>\n<h3>Limitations</h3>\n<p>If the used DLL exists in the first location in the DLL search order, you'll literally have to replace the file on disk, unless you rename the import as briefly mentioned above.</p>\n<h3>Implementations</h3>\n<p>A manual approach can be used for DLLs with only few exported symbols. The easiest would be to create a module definition file from the the DLL and from that create a DLL with only function forwarders. This way your placed DLL would get loaded already and would simply pass through the calls.</p>\n<p>However, this approach will fail with exported variables (as opposed to functions).</p>\n<p>Here's a simple Python script based on <a href=\"https://github.com/erocarrera/pefile\" rel=\"nofollow noreferrer\"><code>pefile</code></a> which I wrote for <a href=\"https://stackoverflow.com/a/15117763/476371\">another answer over at StackOverflow</a>:</p>\n<pre><code>import os\nimport sys\nimport re\n\ndef main(pename):\n    from pefile import PE\n    print \"Parsing %s\" % pename\n    pe = PE(pename)\n    modname = os.path.basename(pename)\n    libname = re.sub(r\"(?i)^.*?([^\\\\/]+)\\.(?:dll|exe|sys|ocx)$\", r\"\\1.lib\", modname)\n    defname = libname.replace(\".lib\", \".def\")\n    print \"Writing module definition file %s for %s\" % (defname, modname)\n    f = open(defname, \"w\") # want it to throw, no sophisticated error handling here\n    f.write(\"LIBRARY %s\\n\\n\" % modname)\n    f.write(\"EXPORTS\\n\")\n    numexp = 0\n    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:\n        if exp.name:\n            numexp += 1\n            f.write(\"\\t%s\\n\" % exp.name)\n    print \"Wrote %s with %d exports\" % (defname, numexp)\n    print \"\\n\\nUse this to create the export lib:\\n\\tlib /def:%s /out:%s\" % (defname, libname)\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        sys.stderr.write(\"ERROR:\\n\\tSyntax: fakelib &lt;dllfile&gt;\\n\")\n        sys.exit(1)\n    sys.exit(main(sys.argv[1]))\n</code></pre>\n<p>You could adjust it to create <a href=\"https://devblogs.microsoft.com/oldnewthing/20060719-24/?p=30473\" rel=\"nofollow noreferrer\">function forwarders</a> instead of a simple module definition with exported names.</p>\n<p>So this way you can shuttle your code into the target application and go from there.</p>\n<h2>Alternative approaches</h2>\n<p>Instrumentation and hooking have been mentioned already. <a href=\"https://www.microsoft.com/en-us/research/project/detours/?from=http://research.microsoft.com/en-us/projects/detours/\" rel=\"nofollow noreferrer\">Detours</a> is an often mentioned example of hooking with an inconvenient EULA for most practical purposes. Refer to the existing answers for this kind of approach.</p>\n<p>You can also use the <a href=\"https://docs.microsoft.com/en-US/windows/win32/dlls/secure-boot-and-appinit-dlls\" rel=\"nofollow noreferrer\"><code>AppInit_DLL</code></a> registry value to inject a DLL early on. Or you could write a little launcher with a debugger loop and use <a href=\"https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/a329t4ed%28v=vs.100%29\" rel=\"nofollow noreferrer\"><code>Image File Execution Options</code></a> to have your target launch your debugger first. A debugger can also influence the DLL loading or simply intercept - conveniently - calls at the boundary between executable and DLLs.</p>\n<p>Trivia: this (<code>Image File Execution Options</code>) is how Process Explorer replaces Task Manager when you choose the option inside Process Explorer.</p>\n<hr/>\n<p>You'll notice how you can sort these approaches into the categories <a href=\"https://reverseengineering.stackexchange.com/a/192/245\">Ed McMan mentioned in his answer</a> already. However, I'll leave that as an exercise to the reader :)</p>\n</div>",
            "votes": "6",
            "user": "Glorfindel",
            "time": "Jul 20, 2022 at 8:43",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I did this with Notepad.exe on Windows. I wanted to add one top-menu item to open calc.exe just for fun (I know your question is tagged Linux and gcc compiler, but the idea is probably the same).</p>\n<p>So I used <a href=\"http://www.angusj.com/resourcehacker/\" rel=\"nofollow\">Resource Hacker</a> tool to add Calc menu and opened notepad.exe on <a href=\"http://debugger.immunityinc.com/\" rel=\"nofollow\">Immunity Debugger</a> looking for some space in the code where I could put my <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms687393%28v=vs.85%29.aspx\" rel=\"nofollow\">WinExec</a> shellcode. Initially I didn't change the executable, I had to look at the program in memory to find some space where I could paste my assembly instructions without crashing notepad.</p>\n<p>Once I found enough space (changing original code by eliminating some not required assembly instructions or even optimizing them) I opened notepad.exe on <a href=\"http://www.chmaas.handshake.de/delphi/freeware/xvi32/xvi32.htm\" rel=\"nofollow\">XVI Hex Editor</a> and searched for the opcodes that was running on Immunity. I mean, the debugger was running some opcodes right? I just searched for a sequence of opcodes to be sure I was at the right piece of the software that I wanted to change and pacthed it with my shellcode (now this is not assembly code but the \"compiled\" assembly - machine code)</p>\n<p>Again: I know your question is tagged Linux and gcc compiler, but maybe someone could point out some tools in Linux to achieve the same I did on Windows. The idea is probably the same.</p>\n</div>",
            "votes": "3",
            "user": "jyz",
            "time": "Mar 23, 2013 at 15:43",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>\"ptrace()\" was casually mentioned by Giles.   But I think it deserved a whole section by itself.   \"ptrace()\" is a system call API provided by OS (Linux and all UNIX have it, and so do Windows) to exert debug control over another process.   When you used PTRACE_ATTACH (as part of ptrace()) to attach to another process, the kernel will pause the CPU running that process completely, allowing you to make changes to ANY part of the process: CPU, any registers, any part of that process memory etc.   That is how dynamic inline hooking work.    (ptrace() attach, modify binary in-memory, and then ptrace() unattached).   As far as I know, all dynamic modification of another process has to use ptrace() - as that is the only mechanism provided by kernel to guarantee integrity via system call at this point.</p>\n<p>But recently similar API like utrace() is popping up, and so\ninline hooking is also theoretically possible:</p>\n<p><a href=\"http://landley.net/kdocs/ols/2007/ols2007v1-pages-215-224.pdf\" rel=\"nofollow noreferrer\">http://landley.net/kdocs/ols/2007/ols2007v1-pages-215-224.pdf</a></p>\n<p>For kernel hooking, there are many methods:   syscall, interrupt, and inline hooking.   This is for interrupt hooking:</p>\n<p><a href=\"http://mammon.github.io/Text/linux_hooker.txt\" rel=\"nofollow noreferrer\">http://mammon.github.io/Text/linux_hooker.txt</a></p>\n<p>When the CPU is in STOP mode, basically you can do anything you like to the CPU/memory space/register - just make sure you restore back to its original state before returning to the original address where it stopped.</p>\n<p>And if you use library inject technique, you can implement any functionalities - calling remote libraries, remote shell etc:</p>\n<p><a href=\"https://attack.mitre.org/techniques/T1055/001/\" rel=\"nofollow noreferrer\">https://attack.mitre.org/techniques/T1055/001/</a></p>\n<p><a href=\"https://stackoverflow.com/questions/24355344/inject-shared-library-into-a-process\">https://stackoverflow.com/questions/24355344/inject-shared-library-into-a-process</a></p>\n<p><a href=\"https://backtrace.io/blog/backtrace/elf-shared-library-injection-forensics/\" rel=\"nofollow noreferrer\">https://backtrace.io/blog/backtrace/elf-shared-library-injection-forensics/</a></p>\n</div>",
            "votes": "2",
            "user": "Peter Teoh",
            "time": "Dec 12, 2020 at 6:05",
            "is_accepted": false,
            "comments": []
        }
    ]
}