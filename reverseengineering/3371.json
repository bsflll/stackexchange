{
    "title": "Reversing Apple Airport Express firmware updates",
    "link": "https://reverseengineering.stackexchange.com/questions/3371/reversing-apple-airport-express-firmware-updates",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Apple provides firmware updates for their Airport products through 'Airport Utility'. Firmware files can be downloaded with the help of ~/Library/Application\\ Support/Apple/AirPort/Firmware/version.xml which contains all products and their available firmware versions:</p>\n<pre><code>            ...\n    &lt;dict&gt;\n        &lt;key&gt;location&lt;/key&gt;\n        &lt;string&gt;http://apsu.apple.com/data/115/041-9815.20130814.1Rver/7.6.4.basebinary&lt;/string&gt;\n        &lt;key&gt;newest&lt;/key&gt;\n        &lt;true/&gt;\n        &lt;key&gt;productID&lt;/key&gt;\n        &lt;string&gt;115&lt;/string&gt;\n        &lt;key&gt;sizeInBytes&lt;/key&gt;\n        &lt;integer&gt;5674968&lt;/integer&gt;\n        &lt;key&gt;sourceVersion&lt;/key&gt;\n        &lt;string&gt;76400.10&lt;/string&gt;\n        &lt;key&gt;version&lt;/key&gt;\n        &lt;string&gt;7.6.4&lt;/string&gt;\n    &lt;/dict&gt;\n    &lt;dict&gt;\n        &lt;key&gt;location&lt;/key&gt;\n        &lt;string&gt;http://apsu.apple.com/data/115/041-9696.20130207.Ch5g6/7.6.3.basebinary&lt;/string&gt;\n        &lt;key&gt;productID&lt;/key&gt;\n        &lt;string&gt;115&lt;/string&gt;\n        &lt;key&gt;sizeInBytes&lt;/key&gt;\n        &lt;integer&gt;5674344&lt;/integer&gt;\n        &lt;key&gt;sourceVersion&lt;/key&gt;\n        &lt;string&gt;76300.7&lt;/string&gt;\n        &lt;key&gt;version&lt;/key&gt;\n        &lt;string&gt;7.6.3&lt;/string&gt;\n    &lt;/dict&gt;\n    &lt;dict&gt;\n        &lt;key&gt;location&lt;/key&gt;\n        &lt;string&gt;http://apsu.apple.com/data/115/041-0311.20130207.aaWs/7.6.2.basebinary&lt;/string&gt;\n        &lt;key&gt;productID&lt;/key&gt;\n        &lt;string&gt;115&lt;/string&gt;\n        &lt;key&gt;sizeInBytes&lt;/key&gt;\n        &lt;integer&gt;5627396&lt;/integer&gt;\n        &lt;key&gt;sourceVersion&lt;/key&gt;\n        &lt;string&gt;76200.16&lt;/string&gt;\n        &lt;key&gt;version&lt;/key&gt;\n        &lt;string&gt;7.6.2&lt;/string&gt;\n    &lt;/dict&gt;\n            ...\n</code></pre>\n<p>For the Airport Express (model A1392, productID 115, see <a href=\"http://wikidevi.com/wiki/Apple_AirPort_Express_Base_Station_A1392_%28MC414LL/A%29\">WikiDevi</a>, <a href=\"http://weblog.rogueamoeba.com/2012/06/19/airport-express-disassembly/\">Teardown by Rogue Amoeba</a>) there are 3 firmware versions: 7.6.2, 7.6.3 and 7.6.4 (current).</p>\n<p>I downloaded all 3 versions and used binwalk (v1.2.2-1) on them. They seem to be encrypted:</p>\n<pre><code>$ binwalk -H 7.6.3.basebinary\n\nDECIMAL     HEX         HEURISTIC ANALYSIS\n\n-------------------------------------------------------------------------------------------------------------------\n\n0           0x0         High entropy data, best guess: encrypted, size: 5673944, 0 low entropy blocks\n</code></pre>\n<hr/>\n<p>Examining different firmware files revealed their common structure.</p>\n<p>Offset 0-D: static string APPLE-FIRMWARE</p>\n<p>Offset E: static hex 00</p>\n<p>Offset F: firmware format version (?) (8 bit signed) hex 2D =&gt; format 45 (7.5.x firmwares have format version 44, 7.7.x firmwares have format version 46)</p>\n<p>Offset 10-12: static hex 00 00 00</p>\n<p>Offset 13: product ID (8 bit signed) hex 73 =&gt; product ID 115</p>\n<p>Offset 14: Firmware Major Version (8 bit signed) hex 07 =&gt; major version 7 (aka 7.x)</p>\n<p>Offset 15: Firmware Minor Version (8 bit signed) hex 63 =&gt; minor version 63 (aka x.63)</p>\n<p>Offset 16-1F: checksum or size for following part?</p>\n<p>Offset 20-2D: static string APPLE-FIRMWARE</p>\n<p>Offset 2E: static hex 00</p>\n<p>Offset 2F: firmware format version (?) (8 bit signed) hex 2D =&gt; format 45 (7.5.x firmwares have format version 44, 7.7.x firmwares have format version 46)</p>\n<p>Offset 30-32: static hex 00 00 00</p>\n<p>Offset 33: product ID (8 bit signed) hex 73 =&gt; product ID 115</p>\n<p>Offset 34: Firmware Major Version (8 bit signed) hex 07 =&gt; major version 7 (aka 7.x)</p>\n<p>Offset 35: Firmware Minor Version (8 bit signed) hex 63 =&gt; minor version 63 (aka x.63)</p>\n<p>Offset 36-3F: checksum or size for following part?</p>\n<p>Offset 40-12F: boot code?\n344FE72ADE3CC2202D6A221A3B67B6075B0F13CA37F5DCCAE5ED626BAE0B4655E618766D703B5190CCD578BCF06D6C9ECD97265B962F49478BE1E9FDE8160E5CCDC09B0C975A3D271D988791258ACC6E679A1556F01C2100DDD0B35E8DA388119C35AC8765DB5DC6AAD6E3D7232D47B4EFA97B32AEF6FF77EDB43946103187342DF68BE88D6B005DAF7CC212777C4FA7FEFD3FD299088EE73EC6FAB1596A92835E4E2450750D9AB5F86780464E341CBFE61E7B8F224285CB3D47D3891AD614B1ABD04DB3DACE7622B22355752F29FF7C5492635F9B99F966759DA4070F23B1D20E197F72BDAFA2B36B567C8E756147A2</p>\n<hr/>\n<p>Do you have any idea on how to go forward?</p>\n<p>What kind of encryption could have been used? Apple seems to use AES for Iphone and AppleTV firmware.</p>\n</div>",
    "votes": "9",
    "answers": 3,
    "views": "3k",
    "tags": [
        "firmware",
        "encryption"
    ],
    "user": "kaazoo",
    "time": "Jan 8, 2014 at 7:45",
    "comments": [
        {
            "user": "w s",
            "text": "<span class=\"comment-copy\">Why do you think that it is encrypted ?</span>",
            "time": null
        },
        {
            "user": "kaazoo",
            "text": "<span class=\"comment-copy\">Because binwalk finds no content sections in the firmware file and when you check for unknown compression/encryption based on entropy heuristics (-H switch), binwalk says it probably encrypted. There are only high entropy blocks and no low entropy blocks. From what I read LZMA compression can also look like this, but then you would find at least some kind of LZMA header which is missing.</span>",
            "time": null
        },
        {
            "user": "ipatch",
            "text": "<span class=\"comment-copy\">Great question. Have you made any progress with this?</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>If it is really encrypted you'll need to take the device apart, lift the ROM, read it and reverse engineer the code.\nThere is some prior work that was done in the area, see <a href=\"http://mafipulation.org/\" rel=\"nofollow\">here</a>\nThe owner of this site is maintaining <a href=\"https://github.com/abrasive/shairport\" rel=\"nofollow\">shairport</a>, it may be useful.</p>\n<p>There is a small chance that encrypted code is decrypted before sending the update  to the device (I personally don't believe it), so it would be good to look into the utility that actually reads the update file and updates the Airpot Express. </p>\n</div>",
            "votes": "1",
            "user": "w s",
            "time": "Jan 8, 2014 at 7:41",
            "is_accepted": false,
            "comments": [
                {
                    "user": "ipatch",
                    "text": "<span class=\"comment-copy\">I can confirm the firmware is encrypted and compressed.  You might want to look at this, <a href=\"http://hsorbo.no/2010/02/22/ax-part1/\" rel=\"nofollow noreferrer\">hsorbo.no/2010/02/22/ax-part1</a></span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>For anyone who comes here from google, I can indeed confirm these devices have their firmware encrypted and gzipped compressed.</p>\n<p>If you have any doubts about the above statement, check <a href=\"https://github.com/x56/airpyrt-tools\" rel=\"nofollow noreferrer\">this</a> out.</p>\n<p>Also, I put together a <a href=\"http://theairportwiki.com\" rel=\"nofollow noreferrer\">wiki</a> a while back documenting our findings about the AirPort family of products.</p>\n<p>Finally, I recently started tinkering with these devices again, and successfully built a NetBSD toolchain for the ARM Big Endian variant of these devices.  And if my memory serves me correctly this particular model of AirPort Express uses a MIPS Big Endian processor.</p>\n<p><strong>TL;DR</strong><br/> \nUse the above mentioned tools, and you can enable SSH on your AirPort device and it will persist.  And come join us in #theairportwiki on freenode.net when you get a chance.</p>\n<p>cheers üçª<br/>\nChris</p>\n</div>",
            "votes": "1",
            "user": "ipatch",
            "time": "Jan 17, 2018 at 6:19",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Like others have said, you might have to take the hardware route, and physically connect a Bus Pirate or similar device to dump the firmware.  When the device is running, you will get a decrypted firmware dump.</p>\n<p>Here's a series about this with an airport express, it's taken from this blog: <a href=\"http://www.hsorbo.no/\" rel=\"nofollow noreferrer\">http://www.hsorbo.no/</a> but i will copy and paste the whole thing here because i don't trust this blog to stay online.  I've pieced in some photos using archive.org as well. Unfortunately the link to the key at the end is a dead link.</p>\n<h1>Reverse engineering the Airport Express Part 1</h1>\n<p>For quite some time I‚Äôve wanted to reverse engineer the airport express base station. There are two reasons for this. The first is that within this firmware are the private Airtunes keys. The second and more important part, at least for me, is that it is almost identical to a wrt54g plus it adds usb and sound-card. Getting linux/openwrt running on this would be wicked cool. The main issue with reversing apples firmwares for these access points is that they are encrypted and the airport express decrypts the firmware when flashing so you can‚Äôt really do anything fun with the firmware-update files.</p>\n<p>A time back I posted on twitter that I needed a broken airport expresss! I go really lucky, a friend of mine saw the tweet and gave me his broken airport. I disassembled it and found out that the flash was AT45DB321B, which is nice because Atmel keeps their datasheet public, the not so good news was that it was BGA-mounted and my old soldering station wasn‚Äôt up for this. Everybody knows I‚Äôm a real ebay-whore, so I went to ebay and ordered this excellent hakko rework-station clone (YIHUA 852D+). This had the hot-air-gun that I needed. Here is a short video when I‚Äôm detaching the IC:</p>\n<p>After desoldering I glued it to a breadboard and hooked up some wires, this was a bit tricky as this is quite small.</p>\n<p>Photo of flash [missing from blog]</p>\n<p>After everything was hooked up, I attached it to my Bus Pirate and after a lot of trial and error managed to communicate with the chip.</p>\n<p>Photo of my desk [missing from blog]</p>\n<p>Finally i wrote this small python-script that dumped the content of the chip.</p>\n<p>I‚Äôm now in the possession of the unencrypted firmware for airport express, but still there are a lot of stuff remaing. The firmware is compressed, and I have had no success brute-force inflating it, so I may have to start reverse-engineering the bootloader just to get to the uncompressed firmware. Another option could be running it under qemu, the decompression-part that is, should be fairly generic MIPS-code. A third option would be to flash it on my wrt54g and do jtag-debugging, if I‚Äôm really lucky I‚Äôd get serial-port and bootloader on the linksys.</p>\n<p>There are a lot for options going forward, I‚Äôll post a new blog-entry when I make further progress. Please excuse the bad language in this post, I don‚Äôt want to spend time on grammar now that I have this very sexy binary blob right in front of me.</p>\n<p>Happy hacking!</p>\n<h1>Reverse engineering the Airport Express Part 2</h1>\n<p>23 February 2010\nYesterday I was analyzing my firmware-dump and I couldn‚Äôt make sense of very much. One thing that got my attention was that scattered around the firmware-dump were a lot of 0xFF. I Found a pattern, and I tried to convince myself that this was some sort of container or padding between important chunks of data. Then as the night approached BOOM, it hit me. The pattern was like this: 512 bytes of data, 16 bytes of 0xFF, 512 bytes of data and 16 bytes of 0xFF. This was significant and here is the problem/solution.</p>\n<p>The flash chip on AT45DB321B is like a book with 8192 pages and 528 letters on each page. When I dumped it my program just read through the book carefully noting every letter. Now the airport express doesn‚Äôt do it this way, the airport just turns to the page it wants and reads what is needed (random access). Now there is one other limitation, the Airport Express doesn‚Äôt read more than 512 letters from each page. This means that he doesn‚Äôt care about the last 16 letters I have been carefully putting into my dump/analysis. I Fixed this and my brute-force decopression-program (15 line python script) found both the bootloader and the main firmware. Their md5-sums are: ff4c561a6dcce8686749594d84ff4e7d and 7db70daf035f085eb455d8de3c2099fb. A guy name James seems to have done the deployment of this firmware :) I think all that remains now is spending time with IDA Pro. I need to get a memory alignment as the start address of memory seems to be 0x8000000 + some offset.</p>\n<p>A screenshot of the strings-window in IDA Pro (strings used in the Airtunes authentication):</p>\n<p><a href=\"https://i.sstatic.net/QQPsO.png\" rel=\"nofollow noreferrer\"><img alt=\"Screenshot of strings\" src=\"https://i.sstatic.net/QQPsO.png\"/></a></p>\n<p>I really think this discovery makes for part 2 as I now am pretty sure the rest is doable, albeit time consuming.</p>\n<p>PS. I had to replace every occurence of dump with firmware-dump as the text became very questionable</p>\n<h1>Reverse engineering the Airport Express Part 3</h1>\n<p>26 February 2010\nA small update. Memory alignment took a few hours. I did this by dumping a lot of the string offsets in the firmware using standard unix console tools: strings -n 10 -o | grep \"Audio\" | awk '{print $2}' I then wrote a IDA script that dumped all load operation offsets, made a second script that brute-forced matching the offsets. The best match was 0x80010000 and not to anybody‚Äôs surprise this made IDA pro very happy and she started auto analyzing the firmware. Here is a screen shot of the memory-offsets:</p>\n<p><a href=\"https://i.sstatic.net/IlUgl.png\" rel=\"nofollow noreferrer\"><img alt=\"IDA memory\" src=\"https://i.sstatic.net/IlUgl.png\"/></a></p>\n<p>Here is a in-action screen shot of IDA:</p>\n<p><a href=\"https://i.sstatic.net/sNeFr.png\" rel=\"nofollow noreferrer\"><img alt=\"IDA action\" src=\"https://i.sstatic.net/sNeFr.png\"/></a></p>\n<p>I‚Äôve done a good amount of reversing and everything is going well, still have no ETA on anything though. Subscribe to the blog or check back after the weekend if you are curious.</p>\n<h1>Reverse engineering the Airport Express Part 4</h1>\n<p>11 April 2011\nThe RAOP/Airtunes key is here <a href=\"http://static.hsorbo.no/0xff/airtunes.pem\" rel=\"nofollow noreferrer\">http://static.hsorbo.no/0xff/airtunes.pem</a> Although i have had the key for quite some time it was first made public here: <a href=\"http://www.mafipulation.org/blagoblig/2011/04/08#shairport\" rel=\"nofollow noreferrer\">http://www.mafipulation.org/blagoblig/2011/04/08#shairport</a></p>\n</div>",
            "votes": "0",
            "user": "Do Not Track Me",
            "time": "Jun 3, 2016 at 21:20",
            "is_accepted": false,
            "comments": []
        }
    ]
}