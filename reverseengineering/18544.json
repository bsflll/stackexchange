{
    "title": "Trying to understand this construct in Dbgv.sys driver for DbgView tool",
    "link": "https://reverseengineering.stackexchange.com/questions/18544/trying-to-understand-this-construct-in-dbgv-sys-driver-for-dbgview-tool",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm trying to reverse the <code>Dbgv.sys</code> (x86 kernel driver) for the <a href=\"https://docs.microsoft.com/en-us/sysinternals/downloads/debugview\" rel=\"nofollow noreferrer\">DbgView tool</a>. It has this <code>sub_10D4A</code> function that is called almost at the beginning of the driver's <code>DriverEntry</code> function. It goes as such:</p>\n<p><a href=\"https://i.sstatic.net/tdZHp.png\" rel=\"nofollow noreferrer\"><img alt=\"sub_10D4A snippet\" src=\"https://i.sstatic.net/tdZHp.png\"/></a></p>\n<p>The relevant piece of disassembly:</p>\n<pre><code>.text:00010D64                 mov     eax, ds:KeNumberProcessors\n.text:00010D69                 mov     al, [eax]\n.text:00010D6B                 cmp     al, 40h ; '@'\n.text:00010D6D                 movsx   eax, al\n.text:00010D70                 jl      short loc_10D74\n.text:00010D72                 mov     eax, [eax] ; &lt;-- line pointed out\n</code></pre>\n<p>What I don't understand is the construct that is pointed by the red arrow. If <code>KeNumberProcessors</code> global variable is larger than or equal to 64 CPU cores (or 40h) it will execute <code>mov eax, [eax]</code> instruction, which will try to read a DWORD from an address that is a number of CPUs, say <code>40h</code>, which makes no sense.</p>\n<p>Wouldn't it result in a BSOD?\nWhat's the intention there?</p>\n</div>",
    "votes": "12",
    "answers": 3,
    "views": "1k",
    "tags": [
        "windows",
        "debugging",
        "kernel-mode",
        "kernel"
    ],
    "user": "MikeF",
    "time": "Jun 18, 2018 at 20:35",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I still think this will create a BSOD, what's more I think that this is <strong>deliberate</strong>. It makes perfect sense to assume that this is deliberate once piecing all the puzzle pieces together. The source incompatibility will inevitably force that the developer notices the change of type for <code>KeNumberProcessors</code> from <code>PCCHAR</code> to <code>CCHAR</code>. The likeliest error is: <code>error C2100: illegal indirection</code>.</p>\n<p>According to the PE header the file was created using WDK 7600.16385.1 (OS version), targeting XP (subsystem version), assuming we can trust best practices having been used to create the driver. However, the driver <em>does</em> run on Windows 2000 Professional (with SP4) as I verified. This is possible whenever the author is careful enough not to use functions unavailable on Windows 2000, but available at compile and link time for the nominal target.</p>\n<p>Okay, so say you have an old driver targeting pre-XP Windows versions. You'll write this (some more code was necessary to force this code not to be optimized away):</p>\n<pre><code>CCHAR nCpus = *KeNumberProcessors;\nPVOID lpBuf = ExAllocatePool(NonPagedPool, nCpus * 7);\n</code></pre>\n<p>when building this for Windows 2000 (free) as target (using WDK 6001.18002), we get for the line assigning <code>nCpus</code> and the subsequent one:</p>\n<pre><code>.text:00010519                 mov     eax, ds:__imp__KeNumberProcessors\n; opcodes unrelated to processor number\n.text:0001052E                 movsx   eax, byte ptr [eax]\n.text:00010531                 imul    eax, 7\n.text:00010534                 push    edi\n.text:00010535                 push    eax             ; NumberOfBytes\n.text:00010536                 push    ebx             ; PoolType\n.text:00010537                 call    ds:__imp__ExAllocatePool@8 ; ExAllocatePool(x,x)\n.text:0001053D                 mov     [ebp+lpBuf], eax\n</code></pre>\n<p>and when targeting Windows XP using the WDK 7600.16385.1 we get an error during compilation:</p>\n<pre><code>KNPs.cpp(102) : error C2100: illegal indirection\n</code></pre>\n<p>... which we fix by removing the <code>*</code> that dereferences <code>KeNumberProcessors</code>, which then gives us a successful compilation and the following code:</p>\n<pre><code>.text:00010519                 mov     eax, ds:__imp__KeNumberProcessors\n; opcodes unrelated to processor number\n.text:0001052E                 movsx   eax, byte ptr [eax]\n.text:00010531                 imul    eax, 7\n.text:00010534                 push    edi\n.text:00010535                 push    eax             ; NumberOfBytes\n.text:00010536                 push    ebx             ; PoolType\n.text:00010537                 call    ds:__imp__ExAllocatePool@8 ; ExAllocatePool(x,x)\n.text:0001053D                 mov     [ebp+lpBuf], eax\n</code></pre>\n<p>that's <strong>identical</strong>. And there is no indication of anything like in the <code>.sys</code> for DebugView that would deliberately cause a BSOD.</p>\n<p>So my money is on: this is <em>meant</em> to cause a BSOD, knowing full well that this situation <a href=\"https://reverseengineering.stackexchange.com/a/18548/245\">could realistically never occur</a>.</p>\n<hr/>\n<p><strong>Original answer below:</strong></p>\n<p>With the information I could dig up, I concur. This code would seem to lead to an inevitable BSOD.</p>\n<p>Let's start by stating that the maximum available number of processors for Windows 2000 Server (Datacenter edition) was 32.</p>\n<p>Based on the declaration for <code>KeNumberProcessors</code>, which <em>is</em> by the way deprecated in favor of <a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-kequeryactiveprocessors\" rel=\"noreferrer\"><code>KeQueryActiveProcessors</code></a>:</p>\n<pre><code>#if (NTDDI_VERSION &gt;= NTDDI_VISTA)\nextern NTSYSAPI volatile CCHAR KeNumberProcessors;\n#elif (NTDDI_VERSION &gt;= NTDDI_WINXP)\nextern NTSYSAPI CCHAR KeNumberProcessors;\n#else\nextern PCCHAR KeNumberProcessors;\n#endif\n</code></pre>\n<p>that variable used to be a pointer prior to Windows XP. Looking at the above linked documentation you will find (relevant excerpts):</p>\n<blockquote>\n<p>The <code>KeNumberProcessors</code> kernel variable <strong>is obsolete in Windows Vista\n  with Service Pack 1 (SP1), Windows Server 2008, and later versions of\n  Windows.</strong> <code>KeNumberProcessors</code> does not appear in WDK headers for WDK\n  releases starting with Windows Vista SP1; however, the variable is\n  still exported from the kernel, <strong>so drivers built for earlier platforms\n  will not break</strong></p>\n</blockquote>\n<p>... and:</p>\n<blockquote>\n<p>Starting with Windows XP, <code>KeNumberProcessors</code> is an 8-bit integer value\n  that indicates the number of processors in the platform. In earlier\n  versions of Windows, <code>KeNumberProcessors</code> <strong>is a pointer to an 8-bit\n  integer value that indicates the number of processors in the platform</strong>.</p>\n</blockquote>\n<p>Now, while I certainly may not have <em>all</em> the answers that the folks from Sysinternals/Microsoft have by glancing at the Windows source code, my guess is the following. This was meant to be a clever trick - relying on circumstantial knowledge - to accommodate <em>both</em> Windows XP and newer (where the variable is a <code>CCHAR</code>) <em>as well as</em> prior Windows versions, where it's a <code>PCCHAR</code>.</p>\n<p>Older MSDN documentation is even more verbose:</p>\n<blockquote>\n<p><strong>Change in the Definition of KeNumberProcessors</strong>\n  The kernel variable <code>KeNumberProcessors</code> indicates the number of active CPUs in the system\n  on which a driver is running. In the Microsoft Windows XP versions of\n  ntddk.h and wdm.h, the definition of <code>KeNumberProcessors</code> has been\n  changed from a pointer to a value. The Microsoft® Windows® 2000\n  definition of this variable required that <code>KeNumberProcessors</code> be\n  dereferenced (for example, <code>*KeNumberProcessors</code>). As a result of the\n  changed definition of this variable, drivers built in the Windows XP\n  build environment must not dereference this variable (for example,\n  <code>KeNumberProcessors</code>).</p>\n<p>Drivers that fail to use <code>KeNumberProcessors</code> correctly <strong>will get an\n  \"illegal indirection\" error at compile time.</strong></p>\n<p>Note that regardless of the declaration used, drivers that properly\n  reference <code>KeNumberProcessors</code> according to the environment in which\n  they are built will work properly on both Windows 2000 and Windows XP.\n  Thus, for instance, a driver built in the Windows 2000 build\n  environment that dereferences <code>KeNumberProcessors</code> will get the proper\n  value for this variable when the driver is run on either Windows 2000\n  or Windows XP.</p>\n</blockquote>\n<p>Problem seems to be that they seem to have gotten it wrong, if I am not all mistaken. There's, however, also a chance they got it right and I am lacking some vital information they have access to :)</p>\n<p>You can test the scenario with MSVC by using:</p>\n<pre><code>DWORD_PTR KeNumberProcessors = 0x80564321;\nDWORD_PTR dsKeNumberProcessors = (DWORD_PTR)&amp;KeNumberProcessors;\n__asm {\n    push eax\n    mov eax, dsKeNumberProcessors\n    mov al, [eax] // only affects AL -&gt; AL := 0x21\n    cmp al, 0x40\n    movsx eax, al // garbles EAX\n    pop eax\n};\n</code></pre>\n<p>Stepping through it gives you a clue as to what's going on. I have to admit the <code>movsx</code> throws me off here.</p>\n<h2>Here's how I think it may have been meant to work</h2>\n<p>Read the byte at the address specified by <code>KeQueryActiveProcessors</code>. See if it's a value smaller than 0x40 and if so, stick with the interpretation as byte.</p>\n<p>If bigger than 0x40, which happens whenever the least significant byte of the (Little Endian) <strong>address</strong> <em>contained in</em> <code>KeQueryActiveProcessors</code> (i.e. on Windows prior to XP) is big enough, we <em>may</em> assume that this is in fact a pointer and dereference it.</p>\n<p><strong>NB:</strong> re-read it: the least significant byte. So it's not the 0x80 in the base address of the kernel (the kernel is loaded at an address higher than 0x80000000) that matters here. For Windows 2000 I have found the following values for the least significant byte:</p>\n<ul>\n<li>0x70 (ntkrnlpa.exe, SP4)</li>\n<li>0xF0 (ntoskrnl.exe, SP4)</li>\n<li>0xC8 (ntkrnlpa.exe, RTM)</li>\n<li><strong>0x30</strong> (ntoskrnl.exe, RTM)</li>\n</ul>\n<p>I didn't check any other kernel version, though. Problem here is that we already have a value smaller than 0x40 among the lot.</p>\n<p>By the way: having an address beyond 0x40 could reasonably be enforced by having the byte be a member of a struct that is page-aligned.</p>\n<p>Now the part that would <em>in any case</em> destroy this scenario is the <code>movsx</code> (sign extend). It overwrites what could have been the address of the <code>CCHAR</code> unconditionally, thereby creating a bogus address that should for all practical purposes cause a BSOD.</p>\n<p>Anyway, the mechanism behind this may have been meant to be something like with the resources IDs which can be 16-bit unsigned integers or pointers to zero-terminated strings with the resource name.</p>\n</div>",
            "votes": "10",
            "user": "0xC0000022L",
            "time": "Jun 18, 2018 at 11:01",
            "is_accepted": false,
            "comments": [
                {
                    "user": "MikeF",
                    "text": "<span class=\"comment-copy\">Thanks. Can't upvote it yet because of the reputation. One question that comes to mind, wouldn't <code>movsx</code> sign extend <code>0x80</code> into '0xFFFFFF80`? Which would not be a \"good\" kernel address either.</span>",
                    "time": null
                },
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">That's the point. The <code>movsx</code> seems to be the actual cause why this code looks like it always generates a BSOD. Would be interesting to look at this mechanism in a debugger on Windows 2000 and 2003 and compare.</span>",
                    "time": null
                },
                {
                    "user": "MikeF",
                    "text": "<span class=\"comment-copy\">Yeah. The oldest OS I can go is WinXP in a VM. Although, this is not an old driver. I'm getting it now from the Sysinternals page when I download DbgView. Link in my OP.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>By definition, 32 bit systems cannot have more than 64 CPU cores (either virtual or physical). This is a hard limit on Microsoft's side for reasons unknown. One can assume those limitations are related to implementation details of the kernel such as the number of CPU core structures, etc.</p>\n<p>Since this is a 32bit driver it'll only be allowed to run in a 32 bit windows version. Because of the limitation induced by Microsoft, drivers need not support more than 64 cores themselves, allowing / requiring a driver to handle these error conditions and unexpected situations to be using a BSOD.</p>\n<blockquote>\n<p>If <code>KeNumberProcessors</code> global variable is larger than or equal to 64 CPU cores (or 40h) it will execute <code>mov eax, [eax]</code> instruction, which will try to read a DWORD from an address that is a number of CPUs, say <code>40h</code>, which makes no sense.</p>\n</blockquote>\n<p>Although your description is roughly accurate, there's another minor detail that makes this flow impossible you've neglected to note. Without it, this flow could've been functional.</p>\n<p>That is the single assembly instruction just between the comparison and conditional jump: <code>movsx eax, al</code>. A move with sign extend from a <code>al</code> to <code>eax</code>. It makes <em>sure</em> EAX will not be a valid address to read from.</p>\n</div>",
            "votes": "5",
            "user": "NirIzr",
            "time": "Jun 18, 2018 at 9:09",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Yep seems like there'll be BSOD, but everybody is lucky to have KeNumberProcessors &lt;= 0x40, so it never happens.</p>\n</div>",
            "votes": "0",
            "user": "Anton Kukoba",
            "time": "Jun 18, 2018 at 8:07",
            "is_accepted": false,
            "comments": [
                {
                    "user": "MikeF",
                    "text": "<span class=\"comment-copy\">Thanks. Can't upvote it yet :( So I guess by definition if a system has more than 64 cores, they will be separated into groups, correct? <code>KeNumberProcessors</code> though seems like an old global variable that was used to determine the number of cores (now <code>KeQueryActiveProcessors()</code> function is recommended instead.) But would <code>KeNumberProcessors</code> cut off counting at 64 or is it a bug in that driver? Also I'm trying to twist my head into a pretzel trying to understand what C construct could've produced such an asm sequence?</span>",
                    "time": null
                }
            ]
        }
    ]
}