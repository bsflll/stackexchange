{
    "title": "Why is there no call to strcpy in assembly?",
    "link": "https://reverseengineering.stackexchange.com/questions/23538/why-is-there-no-call-to-strcpy-in-assembly",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I try to better understand assembly and currently playing around with some compiled c snippets.\nI have the following snippet:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char b[] = \" a nice nice long string\";\n\n    char c[100];\n    strcpy(c, b);\n    printf(\"Hello World %s\\n\", c);\n    strcpy(c, \" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n}\n</code></pre>\n<p>After compiling it with <code>gcc hello_world.c -o hello_world</code> and opening it in gdb the assembly code of the main function looks like this:</p>\n<pre><code>   0x00000000000006fa &lt;+0&gt;:     push   rbp\n   0x00000000000006fb &lt;+1&gt;:     mov    rbp,rsp\n   0x00000000000006fe &lt;+4&gt;:     sub    rsp,0x90\n   0x0000000000000705 &lt;+11&gt;:    mov    rax,QWORD PTR fs:0x28\n   0x000000000000070e &lt;+20&gt;:    mov    QWORD PTR [rbp-0x8],rax\n   0x0000000000000712 &lt;+24&gt;:    xor    eax,eax\n   0x0000000000000714 &lt;+26&gt;:    movabs rax,0x206563696e206120\n   0x000000000000071e &lt;+36&gt;:    movabs rdx,0x6e6f6c206563696e\n   0x0000000000000728 &lt;+46&gt;:    mov    QWORD PTR [rbp-0x90],rax\n   0x000000000000072f &lt;+53&gt;:    mov    QWORD PTR [rbp-0x88],rdx\n   0x0000000000000736 &lt;+60&gt;:    movabs rax,0x676e697274732067\n   0x0000000000000740 &lt;+70&gt;:    mov    QWORD PTR [rbp-0x80],rax\n   0x0000000000000744 &lt;+74&gt;:    mov    BYTE PTR [rbp-0x78],0x0\n   0x0000000000000748 &lt;+78&gt;:    lea    rdx,[rbp-0x90]\n   0x000000000000074f &lt;+85&gt;:    lea    rax,[rbp-0x70]\n   0x0000000000000753 &lt;+89&gt;:    mov    rsi,rdx\n   0x0000000000000756 &lt;+92&gt;:    mov    rdi,rax\n   0x0000000000000759 &lt;+95&gt;:    call   0x5b0 &lt;strcpy@plt&gt;\n   0x000000000000075e &lt;+100&gt;:   lea    rax,[rbp-0x70]\n   0x0000000000000762 &lt;+104&gt;:   mov    rsi,rax\n   0x0000000000000765 &lt;+107&gt;:   lea    rdi,[rip+0xe8]        # 0x854\n   0x000000000000076c &lt;+114&gt;:   mov    eax,0x0\n   0x0000000000000771 &lt;+119&gt;:   call   0x5d0 &lt;printf@plt&gt;\n   0x0000000000000776 &lt;+124&gt;:   lea    rax,[rbp-0x70]\n   0x000000000000077a &lt;+128&gt;:   movabs rsi,0x4141414141414120\n   0x0000000000000784 &lt;+138&gt;:   movabs rdi,0x4141414141414141\n   0x000000000000078e &lt;+148&gt;:   mov    QWORD PTR [rax],rsi\n   0x0000000000000791 &lt;+151&gt;:   mov    QWORD PTR [rax+0x8],rdi\n   0x0000000000000795 &lt;+155&gt;:   movabs rdx,0x4141414141414141\n   0x000000000000079f &lt;+165&gt;:   movabs rcx,0x4141414141414141\n   0x00000000000007a9 &lt;+175&gt;:   mov    QWORD PTR [rax+0x10],rdx\n   0x00000000000007ad &lt;+179&gt;:   mov    QWORD PTR [rax+0x18],rcx\n   0x00000000000007b1 &lt;+183&gt;:   mov    BYTE PTR [rax+0x20],0x0\n   0x00000000000007b5 &lt;+187&gt;:   mov    eax,0x0\n   0x00000000000007ba &lt;+192&gt;:   mov    rcx,QWORD PTR [rbp-0x8]\n   0x00000000000007be &lt;+196&gt;:   xor    rcx,QWORD PTR fs:0x28\n   0x00000000000007c7 &lt;+205&gt;:   je     0x7ce &lt;main+212&gt;\n   0x00000000000007c9 &lt;+207&gt;:   call   0x5c0 &lt;__stack_chk_fail@plt&gt;\n   0x00000000000007ce &lt;+212&gt;:   leave\n   0x00000000000007cf &lt;+213&gt;:   ret\n</code></pre>\n<p>I think i understand which part is doing what. \nBut some things are not clear to me.</p>\n<ol>\n<li>strcpy is only called once and only when the second argument is a variable. Why is ther no call for the second strcopy?</li>\n<li>printf is called with a string and a second arg. The string is loaded from rip+0xe8. Why is the string provided to the second strcopy not loaded in the same fashion? It is \"hardcoded\" with in the moveabs instructions.</li>\n</ol>\n<p>Is this due to some compiler optimization? Can someone elaborate?</p>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "761",
    "tags": [
        "assembly",
        "c",
        "gdb"
    ],
    "user": "joachim",
    "time": "Mar 26, 2020 at 15:26",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<pre><code>import binascii\nprint(binascii.hexlify(b\" a nice nice long string\"))\nprint(binascii.hexlify(b\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"))\n</code></pre>\n<p>you can find both the string in your listing </p>\n<pre><code>b'2061206e696365206e696365206c6f6e6720737472696e67'\nb'41414141414141414141414141414141414141414141414141414141414141'\n</code></pre>\n<p>first string</p>\n<pre><code>0x0000000000000714 &lt;+26&gt;:    movabs rax,0x206563696e206120\n0x000000000000071e &lt;+36&gt;:    movabs rdx,0x6e6f6c206563696e\n0x0000000000000736 &lt;+60&gt;:    movabs rax,0x676e697274732067\n</code></pre>\n<p>second string </p>\n<pre><code> 0x000000000000077a &lt;+128&gt;:   movabs rsi,0x4141414141414120\n 0x0000000000000784 &lt;+138&gt;:   movabs rdi,0x4141414141414141\n 0x000000000000078e &lt;+148&gt;:   mov    QWORD PTR [rax],rsi\n 0x0000000000000791 &lt;+151&gt;:   mov    QWORD PTR [rax+0x8],rdi\n 0x0000000000000795 &lt;+155&gt;:   movabs rdx,0x4141414141414141\n 0x000000000000079f &lt;+165&gt;:   movabs rcx,0x4141414141414141\n</code></pre>\n<p>first time you give it an address which is unknown at compile time so compiler is forced to use the function (dynamic arguments)   </p>\n<p>second time you give a CONSTANT String which can be split and put into the c<br/>\n(static argument)   </p>\n<p>or if you provide a very very big string it can take the address and do a repmovsq    </p>\n<pre><code>strcpy(d, \" lshdgfdghsdfghsdfghsdfhgsdfhgsdfhgshsfur4tye36346asdgxzcvgaewt34t sg afeaerwbhtyhswrtwqee5t6e67redhfdxbw45bh hhjljuhlfjsdhlksjdghsdlkjfhgsldkjfghlskjdghlkjsdhggkjsdhgksdjhgskdjhglsdkjhgfskjdhfgsdkjhfgkjsdfhgskdjhfgsdk;ljhg;djkgsjhg;dsljkhf;ljg;dljg;jh\");\n}\n</code></pre>\n<p>using repmovsq</p>\n<pre><code>mov     eax, OFFSET FLAT:.LC1\nmov     ecx, 31\nmov     rdi, rdx\nmov     rsi, rax\nrep movsq\n\n.LC1:\n        .string \" lshd\n</code></pre>\n<p>just to confirm remove the b[] = line and put strcpy(c,const string ); you will see the compiler has eliminated the .plt entry also and will convert the \nstrcpy to __builtin_memcpy()</p>\n<pre><code> __builtin_memcpy (&amp;c, \" a nice nice long string\", 25);\n  printf (\"Hello World %s\\n\", &amp;c);\n  __builtin_memcpy (&amp;c, \" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", 33);\n</code></pre>\n<p>compile with -fno-builtin and you will get both strcpy</p>\n<pre><code>.LC0:\n        .string \"Hello World %s\\n\"\n.LC1:\n        .string \" AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\nmain:\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 144\n        movabs  rax, 2334381286331801888\n        movabs  rdx, 7957697952982722926\n        mov     QWORD PTR [rbp-32], rax\n        mov     QWORD PTR [rbp-24], rdx\n        movabs  rax, 7453010373645639783\n        mov     QWORD PTR [rbp-16], rax\n        mov     BYTE PTR [rbp-8], 0\n        lea     rdx, [rbp-32]\n        lea     rax, [rbp-144]\n        mov     rsi, rdx\n        mov     rdi, rax\n        call    strcpy\n        lea     rax, [rbp-144]\n        mov     rsi, rax\n        mov     edi, OFFSET FLAT:.LC0\n        mov     eax, 0\n        call    printf\n        lea     rax, [rbp-144]\n        mov     esi, OFFSET FLAT:.LC1\n        mov     rdi, rax\n        call    strcpy\n        mov     eax, 0\n        leave\n        ret\n</code></pre>\n<p>you can read about various other __builtins <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#Other-Builtins\" rel=\"nofollow noreferrer\">here</a></p>\n</div>",
            "votes": "4",
            "user": "blabb",
            "time": "Mar 26, 2020 at 18:41",
            "is_accepted": false,
            "comments": []
        }
    ]
}