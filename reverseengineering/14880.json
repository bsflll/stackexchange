{
    "title": "basic reversing question about local variable",
    "link": "https://reverseengineering.stackexchange.com/questions/14880/basic-reversing-question-about-local-variable",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I do not understand the following:</p>\n<p>in a very simple dummy C function:</p>\n<pre><code>void vulnerable_function(char* string) { \n    char buffer[100];\n}\n</code></pre>\n<p>When I use <code>gdb</code> to disassemble it, I obtain:</p>\n<pre><code>0x08048464 &lt;+0&gt;:  push   %ebp\n0x08048465 &lt;+1&gt;:  mov    %esp,%ebp\n0x08048467 &lt;+3&gt;:  sub    $0x88,%esp\n</code></pre>\n<p>I really do not understand why the stack pointer is decremented by 0x88. </p>\n<p>I believed that it would be <code>0x64</code> instead of <code>0x88</code>. Can you explain it please?</p>\n<p>Thank you very much!</p>\n</div>",
    "votes": "8",
    "answers": 2,
    "views": "2k",
    "tags": [
        "disassembly",
        "x86"
    ],
    "user": "David Labay",
    "time": "Mar 11, 2017 at 22:01",
    "comments": [
        {
            "user": "Vido",
            "text": "<span class=\"comment-copy\">can you add more info about your executable like <code>file ./executable</code></span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>There are several factors involved in how much space is allocated by the compiler for a function's stack frame on the process runtime stack:</p>\n<ul>\n<li>space required for saving copies of arguments to the function in the stack frame</li>\n<li>space required for storing local variables in the stack frame</li>\n<li>Stack alignment to a 16-byte boundary (GCC default for i386 architecture)</li>\n</ul>\n<h2>Background</h2>\n<h3>The i386 ABI</h3>\n<p><strong>Stack Frame Specification</strong></p>\n<p>The specification for the stack frame on x86 machines is given in Chapter 3: \"Low-Level System Information\" in the <a href=\"http://refspecs.linux-foundation.org/elf/abi386-4.pdf\" rel=\"noreferrer\">System V Application Binary Interface Intel386 Architecture Processor Supplement, Fourth Edition</a> in the section titled \"Function Calling Sequence\".</p>\n<p>Note:</p>\n<blockquote>\n<p>Within this specification, the term <em>halfword</em> refers to a 16-bit object, the term <em>word</em> refers to a 32-bit object, and the term <em>doubleword</em> refers to a 64-bit object.</p>\n</blockquote>\n<p>Here are relevant excerpts:</p>\n<ul>\n<li><blockquote>\n<p>The stack is word aligned.  Although the architecture does not require any \n  alignment of the stack, software convention and the operating system requires that the stack be aligned on a word boundary.</p>\n</blockquote></li>\n<li><blockquote>\n<p>An argument’s size is increased, if necessary, to make it a multiple of words. This may require tail padding, depending on the size of the argument.</p>\n</blockquote></li>\n<li><blockquote>\n<p>Other areas depend on the compiler and the code being compiled.  The standard calling sequence does not define a maximum stack frame size, nor does\n  it restrict how a language system uses the ‘‘unspecified’’ area of the standard stack frame.</p>\n</blockquote></li>\n</ul>\n<p>The \"unspecified\" area in a stack frame is the space created for local variables and where arguments to the function are copied to. This space is managed by the compiler.</p>\n<p>Here is a diagram from the ABI:\n<a href=\"https://i.sstatic.net/qBKgx.png\" rel=\"noreferrer\"><img alt=\"Standard Stack Frame, i386\" src=\"https://i.sstatic.net/qBKgx.png\"/></a></p>\n<p><strong>Alignment</strong></p>\n<p>It is the compiler that manages stack frames, and in order for a stack frame to be aligned the alignment of variables within the stack frame must also be known.   </p>\n<p>Alignment of variables depends on their type and the architecture of the CPU.\nThis is also specified in the ABI:\n<a href=\"https://i.sstatic.net/z40Xp.png\" rel=\"noreferrer\"><img alt=\"Fundamental types, i386\" src=\"https://i.sstatic.net/z40Xp.png\"/></a></p>\n<p>There are conventions that pertain specifically to the alignment of arrays, structures and unions:</p>\n<blockquote>\n<p>Aggregates (structures and arrays) and unions assume the alignment of their most strictly aligned component.  The size of any object, including aggregates and unions, is always a multiple of the object’s alignment.  An array uses the same alignment as its elements.  Structure and union objects can require padding to meet size and alignment constraints.  The contents of any padding is undefined. </p>\n</blockquote>\n<p>However, on i386 architecture systems, GCC aligns the stack to a 16-byte boundary by default:</p>\n<blockquote>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.5.3/gcc/i386-and-x86_002d64-Options.html\" rel=\"noreferrer\"><code>-mpreferred-stack-boundary=num</code></a><br/>\n     Attempt to keep the stack boundary aligned to a 2 raised to num byte boundary. If <code>-mpreferred-stack-boundary</code> is not specified, the default is 4 (16 bytes or 128 bits). </p>\n</blockquote>\n<p>This means that the compiler allocates 16 bytes of space on the stack frame for variables whose type sizes are less than 16 bytes. For example, even though an <code>int</code> is 4 bytes on an i386 system, the compiler would still allocate 16 bytes of space on the stack frame for it.</p>\n<h2>The stack frame for vulnerable_function()</h2>\n<p>Let us analyze how the compiler allocates space on a function's stack frame with 2 simple examples: a function with a <code>char</code> pointer local variable and a function with a 100-byte <code>char</code> array.</p>\n<p>A function called <code>pointer_test</code> with <code>char</code> pointer local variable:</p>\n<pre><code>void pointer_test(void) {\n    char *i = \"test\";\n}\n</code></pre>\n<p>Assembly code generated by <code>gcc</code> + <code>as</code>:</p>\n<pre><code>Dump of assembler code for function pointer_test:\n   0x080483db &lt;+0&gt;:     push   %ebp\n   0x080483dc &lt;+1&gt;:     mov    %esp,%ebp\n   0x080483de &lt;+3&gt;:     sub    $0x10,%esp  &lt;-- 16 bytes of space created for 4-byte pointer\n   0x080483e1 &lt;+6&gt;:     movl   $0x8048480,-0x4(%ebp)\n   0x080483e8 &lt;+13&gt;:    nop\n   0x080483e9 &lt;+14&gt;:    leave  \n   0x080483ea &lt;+15&gt;:    ret  \n</code></pre>\n<p>Here we see that 16 bytes of space were allocated for a 4-byte pointer.</p>\n<p>A function called <code>char_array_test</code> with a char array local variable:</p>\n<pre><code>void char_array_test(void) {\n    char buffer[100];\n}\n</code></pre>\n<p>Assembly code generated by <code>gcc</code> + <code>as</code>:</p>\n<pre><code>Dump of assembler code for function char_array_test:\n   0x0804844b &lt;+0&gt;:     push   %ebp\n   0x0804844c &lt;+1&gt;:     mov    %esp,%ebp\n   0x0804844e &lt;+3&gt;:     sub    $0x78,%esp  &lt;-- 120 bytes of space created for 100-byte array\n   0x08048451 &lt;+6&gt;:     mov    %gs:0x14,%eax\n   0x08048457 &lt;+12&gt;:    mov    %eax,-0xc(%ebp)\n   0x0804845a &lt;+15&gt;:    xor    %eax,%eax\n   0x0804845c &lt;+17&gt;:    nop\n   0x0804845d &lt;+18&gt;:    mov    -0xc(%ebp),%eax\n   0x08048460 &lt;+21&gt;:    xor    %gs:0x14,%eax\n   0x08048467 &lt;+28&gt;:    je     0x804846e &lt;char_array_test+35&gt;\n   0x08048469 &lt;+30&gt;:    call   0x8048310 &lt;__stack_chk_fail@plt&gt;\n   0x0804846e &lt;+35&gt;:    leave  \n   0x0804846f &lt;+36&gt;:    ret\n</code></pre>\n<p>Here we see that 120 bytes of space were allocated for a 100-byte array.    </p>\n<p>In the case of <code>void vulnerable_function(char *string)</code>, space in the stack frame must be allocated by <code>gcc</code> for a 4-byte pointer and a 100-byte array. </p>\n<ul>\n<li>As we observed above in <code>pointer_test()</code>, since <code>gcc</code> aligns allocated space to 16-byte boundaries by default,  16 bytes of space are also allocated on the stack frame for the 4-byte pointer<code>char *string</code>, the argument to the function.</li>\n<li>We observed above in <code>char_array_test()</code> that <code>gcc</code> allocates 120 bytes of space for a 100 byte array (120 is not a multiple of 16, so this is not aligned with a 16-byte boundary. I do not know why the compiler does this). Likewise, the compiler allocates 120 bytes of space for <code>char buffer[100]</code> in <code>vulnerable_function()</code>. </li>\n</ul>\n<p><strong>0x10 bytes for <code>string</code> + 0x78 bytes for <code>buffer[100]</code> = 0x88</strong>\n<br/>\n<br/></p>\n<h3>Resources</h3>\n<p><a href=\"https://godbolt.org/\" rel=\"noreferrer\">Compiler Explorer</a> is an interactive compiler that runs in your browser. Playing around with it is much faster than constantly recompiling code and disassembling it.</p>\n<p><a href=\"http://refspecs.linux-foundation.org/elf/abi386-4.pdf\" rel=\"noreferrer\">The System V Application Binary Interface Intel386 Architecture Processor Supplement, Fourth Edition</a></p>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.5.3/gcc/i386-and-x86_002d64-Options.html\" rel=\"noreferrer\"> Intel 386 and AMD x86-64 Options for GCC</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl\" rel=\"noreferrer\"><code>cdecl</code> and x86 calling conventions</a> discusses calling conventions in x86 compilers</p>\n<p><a href=\"https://lwn.net/Articles/335942/\" rel=\"noreferrer\">Poke-a-hole and friends</a> is an\narticle that discusses how structures are padded in order to maintain alignment and how this changes across architectures.</p>\n<p><strong>related SO questions</strong></p>\n<p><a href=\"https://stackoverflow.com/questions/1061818/stack-allocation-padding-and-alignment\">Stack allocation, padding, and alignment</a></p>\n<p><a href=\"https://stackoverflow.com/questions/672461/what-is-stack-alignment?noredirect=1&amp;lq=1\">what is “stack alignment”?</a></p>\n</div>",
            "votes": "12",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>As SYS_V correctly cites in <a href=\"https://reverseengineering.stackexchange.com/a/14883/25222\">his answer</a>, the <a href=\"https://gcc.gnu.org/onlinedocs/gcc-8.2.0/gcc/x86-Options.html#index-mpreferred-stack-boundary-1\" rel=\"nofollow noreferrer\">GCC documentation</a> states that GCC will work to align the stack pointer to 16-byte boundaries by default.</p>\n<blockquote>\n<p><code>-mpreferred-stack-boundary=num</code></p>\n<p>Attempt to keep the stack boundary aligned to a 2 raised to num byte\n  boundary. If <code>-mpreferred-stack-boundary</code> is not specified,\n  the default is 4 (16 bytes or 128 bits).</p>\n</blockquote>\n<p>We find some reasoning as to why this is done as well (<strong>NB:</strong> On the 64-bit architecture, 16-byte alignment is mandatory):</p>\n<blockquote>\n<p>[A different value] leads to wrong code when functions compiled with 16 byte stack alignment (such as functions from a standard library) are called with misaligned stack. In this case, SSE instructions may lead to misaligned memory access traps [and] variable arguments are handled incorrectly for 16 byte aligned objects [...] You must build all modules [with the same value]. This includes the system libraries and startup modules.</p>\n</blockquote>\n<p>Note, however, that this is mostly about the stack <em>frame</em> (boundary), not necessarily the individual objects on the stack. This frame alignment happens not inside the function, but at the call site where you will see something like this (note the extra subtraction from <code>%esp</code>):</p>\n<pre><code> sub    $0xc,%esp                # pad stack by 12 bytes\n push   %eax                     # push 4-byte argument\n call   vulnerable_function\n</code></pre>\n<p>Nevertheless it makes sense to keep (some) objects aligned as well.</p>\n<p>In your example, you encounter 0x88 (=136) bytes allocated for the 100-byte buffer while SYS_V got 0x78 (=120) for the same. Note that both these values are congruent 8 modulo 16. This is chosen because at this point, your stack frame already includes two 4-byte values: the return address and the saved frame pointer. With these combined, you end up 16-byte-aligned after the allocation.</p>\n</div>",
            "votes": "4",
            "user": "pesco",
            "time": "Aug 3, 2018 at 12:47",
            "is_accepted": false,
            "comments": []
        }
    ]
}