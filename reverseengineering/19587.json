{
    "title": "Converting Assembly x64 code to C",
    "link": "https://reverseengineering.stackexchange.com/questions/19587/converting-assembly-x64-code-to-c",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have the following code:</p>\n<pre><code>0000000000400526 &lt;main&gt;:\n  400526:   55                      push   rbp\n  400527:   48 89 e5                mov    rbp,rsp\n  40052a:   48 83 ec 20             sub    rsp,0x20\n  40052e:   89 7d ec                mov    DWORD PTR [rbp-0x14],edi\n  400531:   48 89 75 e0             mov    QWORD PTR [rbp-0x20],rsi\n  400535:   c7 45 f4 4d 3c 2b 1a    mov    DWORD PTR [rbp-0xc],0x1a2b3c4d\n  40053c:   48 8d 45 f4             lea    rax,[rbp-0xc]\n  400540:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax\n  400544:   c7 45 f0 00 00 00 00    mov    DWORD PTR [rbp-0x10],0x0\n  40054b:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  40054f:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400552:   0f be c0                movsx  eax,al\n  400555:   c1 e0 18                shl    eax,0x18\n  400558:   89 c2                   mov    edx,eax\n  40055a:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  40055e:   48 83 c0 01             add    rax,0x1\n  400562:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400565:   0f be c0                movsx  eax,al\n  400568:   c1 e0 10                shl    eax,0x10\n  40056b:   09 c2                   or     edx,eax\n  40056d:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  400571:   48 83 c0 02             add    rax,0x2\n  400575:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400578:   0f be c0                movsx  eax,al\n  40057b:   c1 e0 08                shl    eax,0x8\n  40057e:   09 c2                   or     edx,eax\n  400580:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  400584:   48 83 c0 03             add    rax,0x3\n  400588:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  40058b:   0f be c0                movsx  eax,al\n  40058e:   09 d0                   or     eax,edx\n  400590:   89 45 f0                mov    DWORD PTR [rbp-0x10],eax\n  400593:   8b 55 f0                mov    edx,DWORD PTR [rbp-0x10]\n  400596:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]\n  400599:   89 c6                   mov    esi,eax\n  40059b:   bf 44 06 40 00          mov    edi,0x400644 ; \"a = %#x\\nb = %#x\\n\"\n  4005a0:   b8 00 00 00 00          mov    eax,0x0\n  4005a5:   e8 56 fe ff ff          call   400400 &lt;printf@plt&gt;\n  4005aa:   b8 00 00 00 00          mov    eax,0x0\n  4005af:   c9                      leave\n  4005b0:   c3                      ret\n  4005b1:   66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]\n  4005b8:   00 00 00\n  4005bb:   0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]\n</code></pre>\n<p>This is a segment of x64 assembly code, and I would like to rewrite this code into C. I've been reading Assembly books all day, and I'm still having some difficulty. I just want to understand what this code is doing. From messing around, I think that it performs some operations on an int (that's why I think the DWORD is there) and a long (that's why the QWORD is there). I think that this is true because I recompiled C code with those data structures and those words appeared in the Assembly equivalent, but I could be wrong.</p>\n<p>Any help is appreciated in decoding this code.'</p>\n<hr/>\n<p><strong>For Amigag:</strong> second segment of code</p>\n<pre><code>0000000000400966 &lt;my_tolower&gt;:\n  400966:   55                      push   rbp\n  400967:   48 89 e5                mov    rbp,rsp\n  40096a:   48 89 7d f8             mov    QWORD PTR [rbp-0x8],rdi\n  40096e:   eb 2d                   jmp    40099d &lt;my_tolower+0x37&gt;\n  400970:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  400974:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400977:   3c 40                   cmp    al,0x40\n  400979:   7e 1d                   jle    400998 &lt;my_tolower+0x32&gt;\n  40097b:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  40097f:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400982:   3c 5a                   cmp    al,0x5a\n  400984:   7f 12                   jg     400998 &lt;my_tolower+0x32&gt;\n  400986:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  40098a:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  40098d:   83 c0 20                add    eax,0x20\n  400990:   89 c2                   mov    edx,eax\n  400992:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  400996:   88 10                   mov    BYTE PTR [rax],dl\n  400998:   48 83 45 f8 01          add    QWORD PTR [rbp-0x8],0x1\n  40099d:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  4009a1:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  4009a4:   84 c0                   test   al,al\n  4009a6:   75 c8                   jne    400970 &lt;my_tolower+0xa&gt;\n  4009a8:   90                      nop\n  4009a9:   5d                      pop    rbp\n  4009aa:   c3                      ret    \n  4009ab:   0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]\n</code></pre>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "2k",
    "tags": [
        "disassembly",
        "assembly",
        "decompilation",
        "x86-64"
    ],
    "user": "Joey",
    "time": "Oct 10, 2018 at 0:57",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I believe the best tool for rewriting assembly to C is IDA Graph View, which is toggled with <kbd>space</kbd>.<br/>\nIt let you see the function as <a href=\"https://en.wikipedia.org/wiki/Basic_block\" rel=\"nofollow noreferrer\">Basic Blocks</a>, connected by control flow instructions. In this specific function, I cannot spot any jumps so you will see one long block.</p>\n<p>The first thing you usually see in a function is the function prologue which sets up the stack frame.</p>\n<pre><code>  400526:   55                      push   rbp\n  400527:   48 89 e5                mov    rbp,rsp\n  40052a:   48 83 ec 20             sub    rsp,0x20\n</code></pre>\n<p>second, as 64 bit calling convention suggests, the first parameters are passed by registers, other are passed on the stack.<br/>\nThe used registers are os-dependent (see table 5 at <a href=\"http://agner.org/optimize/calling_conventions.pdf\" rel=\"nofollow noreferrer\">Agner Fog calling conventions</a>).<br/>\nYou an see that the function probably gets 2 parameters (edi for 32 bit variable for <code>argc</code> and 64 bit for <code>argv</code>)</p>\n<p>You can see that a \"magic\" value (<code>0x1a2b3c4</code>) is saved in a local variable and a pointer to it is created. Note that when it's saved, it is stored as <a href=\"https://en.wikipedia.org/wiki/Endianness#Little-endian\" rel=\"nofollow noreferrer\">little-endian</a>, which means the order of bytes is reversed.</p>\n<pre><code>  400535:   c7 45 f4 4d 3c 2b 1a    mov    DWORD PTR [rbp-0xc],0x1a2b3c4d\n  40053c:   48 8d 45 f4             lea    rax,[rbp-0xc]\n  400540:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax\n</code></pre>\n<p>And his first byte is read to eax as a signed byte and multiplied by <code>2^0x18 (=2^24)</code>.\nThe fact that it's signed doesn't affect anything in this case, because the sign bit is always off (as <code>0x1a</code>, <code>0x2b</code>, <code>0x3c</code> and <code>0x4d</code> are all below 128)</p>\n<pre><code>  40054f:   0f b6 00                movzx  eax,BYTE PTR [rax]\n  400552:   0f be c0                movsx  eax,al\n  400555:   c1 e0 18                shl    eax,0x18\n</code></pre>\n<p>And in a similar way, a value is calculated using next bytes, multiplied by 0x10 (=16), 8 and 1 (implicitly) respectively. results are stored in edi, and <code>or</code>ed with the previous value.</p>\n<p>We can conclude that our function is something like that:</p>\n<pre><code>void main(int argc, char *argv[])\n{\n     int calculated_value;  // represents the use of edi to store the result\n     int magic_value = 0x1A2B3C4D;  // note that although i am using int, i mean uint32_t, a variable that has 4 bytes - a DWORD.\n     char *magic_ptr = (char *) &amp;magic_value;  // the values are read byte-by-byte, or char-by-char\n     calculated_value = magic_ptr[0] &lt;&lt; 24;\n     calculated_value |= magic_ptr[1] &lt;&lt; 16;\n     calculated_value |= magic_ptr[2] &lt;&lt; 8;\n     calculated_value |= magic_ptr[3];  // note that at the last or, the result is saved at eax as edi will soon be used to pass the first parameter to printf\n\n     printf(\"a = %#x\\nb = %#x\\n\", magic_value, calculated_value);\n}\n</code></pre>\n<p>So, what we can see is that the magic value is read back to a variable, while saving the little-endianness, which means we will get the reversed byte order if the <code>magic_value</code>.<br/>\nThus, we can expect the output to be:</p>\n<blockquote>\n<p>a = 0x1a2b3c4d<br/>\n  b = 0x4d3c2b1a</p>\n</blockquote>\n<hr/>\n<p>Also, as a general note, this code have could utilize loops to perform the read.</p>\n<pre><code>void main(int argc, char *argv[])\n{\n     int i;\n     int calculated_value = 0;  // represents the use of edi to store the result\n     int magic_value = 0x1A2B3C4D;  // note that although i am using int, i mean uint32_t, a variable that has 4 bytes - a DWORD.\n     char *magic_ptr = (char *) &amp;magic_value;  // the values are read byte-by-byte, or char-by-char\n     for(int i = 0; i &lt; 4; i++)\n     {\n         calculated_value &lt;&lt;= 8;\n         calculated_value = magic_ptr[i];\n     }\n     printf(\"a = %#x\\nb = %#x\\n\", magic_value, calculated_value);\n}\n</code></pre>\n<hr/>\n<p>EDIT: As to your second code.\nHere we can see jumps, so I created a graph view of the code. it makes reading it much easier.<br/>\nA bit of info on the graph: a green line means that the jump happens if a condition is met. A red line means that the jump happens if the condition is false. A blue line means that the jump is unconditional, it will always jump.<br/>\nLet's go through it and see what happens.</p>\n<p><a href=\"https://i.sstatic.net/XkMa6.png\" rel=\"nofollow noreferrer\"><img alt=\"A graph view of the second code\" src=\"https://i.sstatic.net/XkMa6.png\"/></a></p>\n<p>The first thing we get to see after the function prologue is a single parameter is saved at <code>rbp-0x8</code>.<br/>\nOn the block of <code>0x40099d</code> we can see that the input is probably <code>char *ptr</code>, it dereference the pointer and read it's value.<br/>\nFrom the <code>test al, al</code> we can assume that the value is a string (and not just binary data, it is <em>probably</em> related to user input) and we stop once we have read the null terminator (<code>\\x00</code> = 0).</p>\n<p>The next block we will check is <code>0x400970</code>. All it does is checking if the char pointed by <code>rbp-0x8</code> is smaller or equal to <code>0x40</code> (<code>0x40</code> is ascii for '@', <code>0x41</code> is 'A'). If it is, it <code>continue</code>s (the single-line block at <code>0x400998</code>).</p>\n<p>So far, our function is something like:</p>\n<pre><code>void my_tolower(char *str)\n{\n    while(str[i] != '\\x00')\n    {\n        if(str[i] &lt; 'A')  // as opposed to &lt;= '@'. I can't remember I saw a code ever caring about '@'.\n        {\n            str += 1;  // skipping the current character\n            continue;\n        }\n        // unknown code for now\n    }\n}\n</code></pre>\n<p>Looking at <code>0x40097b</code>, we can see a similar code, but it checks the character is smaller than <code>0x5A</code> (=ascii of <code>Z</code>). so we can write those conditions in a single if:</p>\n<pre><code>if(str[i] &lt; 'A' || str[i] &gt; 'Z')\n</code></pre>\n<p>Last block (<code>0x400986</code>). We now know that str[i] contains an upper-case letter.<br/>\nThe code takes the character and add <code>0x20</code> to it. <code>0x20</code> is ascii for <code></code> (space) and (<code>a</code> - <code>A</code>). It saves the result back to the string and continues.</p>\n<pre><code>  400992:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]\n  400996:   88 10                   mov    BYTE PTR [rax],dl\n</code></pre>\n<p>Looking at <code>0x4009a8</code>, no result is passed to <code>rax</code>, that means the function probably doesn't return a value.</p>\n<p>So, out functions look something like that:</p>\n<pre><code>void my_tolower(char *str)\n{\n    while(str[i] != '\\x00')\n    {\n        if(str[i] &lt; 'A' || str[i] &gt; 'Z')  // as opposed to &lt;= '@'. I can't remember I saw a code ever caring about '@'.\n        {\n            continue;\n        }\n        str[i] = str[i] + 'a' - 'A';\n        str += 1;\n    }\n}\n</code></pre>\n<p>We could also rewrite the function to show the single block that increments the pointer, which i believe is how the original code looked like. it makes more sense logically that we change the string if a condition was met, not if a condition is not met.</p>\n<pre><code>void my_tolower(char *str)  // name was taken from 4009a6 and the first line of function\n{\n    while(str[i] != '\\x00')\n    {\n        if(str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z')  // as opposed to &lt;= '@'. I can't remember I saw a code ever caring about '@'.\n        {\n            str[i] = str[i] + 'a' - 'A';\n        }\n        str += 1;  // this is the block at 400998, that always happen\n    }\n}\n</code></pre>\n</div>",
            "votes": "7",
            "user": null,
            "time": "Oct 11, 2018 at 4:41",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Joey",
                    "text": "<span class=\"comment-copy\">Thank you so much!! There is just one last segment of code that I'm having trouble deciphering. I've accepted your answer, though. I added it to the original post to see if you can help me? I do not have IDA Graph View (though, I saw it as a suggested application earlier) as it is pay-per-download, and I plan on using Assembly again.</span>",
                    "time": null
                },
                {
                    "user": "user22970",
                    "text": "<span class=\"comment-copy\">@stackofhay42 i've edited the answer</span>",
                    "time": null
                }
            ]
        }
    ]
}