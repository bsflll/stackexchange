{
    "title": "How to recover information stored in .ctors section?",
    "link": "https://reverseengineering.stackexchange.com/questions/6285/how-to-recover-information-stored-in-ctors-section",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Test is on x86, 32-bit Linux. I am using <code>g++</code> 4.6.3 and <code>objdump</code> 2.22</p>\n<p>Here is a simple C++ code I am working on:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nmain()\n{\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>When I compile it into assembly code using :</p>\n<pre><code>gcc -S hello.cc\n</code></pre>\n<p>I can find out a <code>ctors</code> section in the <strong>hello.s</strong> below:</p>\n<pre><code>.section    .ctors,\"aw\",@progbits\n.align 4\n.long   _GLOBAL__sub_I_main\n.weakref    _ZL20__gthrw_pthread_oncePiPFvvE,pthread_once\n.weakref    _ZL27__gthrw_pthread_getspecificj,pthread_getspecific\n.weakref    _ZL27__gthrw_pthread_setspecificjPKv,pthread_setspecific\n.weakref    _ZL22__gthrw_pthread_createPmPK14pthread_attr_tPFPvS3_ES3_,pthread_create\n.weakref    _ZL20__gthrw_pthread_joinmPPv,pthread_join\n.weakref    _ZL21__gthrw_pthread_equalmm,pthread_equal\n.weakref    _ZL20__gthrw_pthread_selfv,pthread_self\n.weakref    _ZL22__gthrw_pthread_detachm,pthread_detach\n.weakref    _ZL22__gthrw_pthread_cancelm,pthread_cancel\n.weakref    _ZL19__gthrw_sched_yieldv,sched_yield\n.weakref    _ZL26__gthrw_pthread_mutex_lockP15pthread_mutex_t,pthread_mutex_lock\n.weakref    _ZL29__gthrw_pthread_mutex_trylockP15pthread_mutex_t,pthread_mutex_trylock\n.weakref    _ZL31__gthrw_pthread_mutex_timedlockP15pthread_mutex_tPK8timespec,pthread_mutex_timedlock\n.weakref    _ZL28__gthrw_pthread_mutex_unlockP15pthread_mutex_t,pthread_mutex_unlock\n.weakref    _ZL26__gthrw_pthread_mutex_initP15pthread_mutex_tPK19pthread_mutexattr_t,pthread_mutex_init\n.weakref    _ZL29__gthrw_pthread_mutex_destroyP15pthread_mutex_t,pthread_mutex_destroy\n.weakref    _ZL30__gthrw_pthread_cond_broadcastP14pthread_cond_t,pthread_cond_broadcast\n.weakref    _ZL27__gthrw_pthread_cond_signalP14pthread_cond_t,pthread_cond_signal\n.weakref    _ZL25__gthrw_pthread_cond_waitP14pthread_cond_tP15pthread_mutex_t,pthread_cond_wait\n.weakref    _ZL30__gthrw_pthread_cond_timedwaitP14pthread_cond_tP15pthread_mutex_tPK8timespec,pthread_cond_timedwait\n.weakref    _ZL28__gthrw_pthread_cond_destroyP14pthread_cond_t,pthread_cond_destroy\n.weakref    _ZL26__gthrw_pthread_key_createPjPFvPvE,pthread_key_create\n.weakref    _ZL26__gthrw_pthread_key_deletej,pthread_key_delete\n.weakref    _ZL30__gthrw_pthread_mutexattr_initP19pthread_mutexattr_t,pthread_mutexattr_init\n.weakref    _ZL33__gthrw_pthread_mutexattr_settypeP19pthread_mutexattr_ti,pthread_mutexattr_settype\n.weakref    _ZL33__gthrw_pthread_mutexattr_destroyP19pthread_mutexattr_t,pthread_mutexattr_destroy\n</code></pre>\n<p>However, when I assembly the asm code, producing an exe file and use the <code>objdump</code> produce the <code>ctors</code> section's contain like this:</p>\n<pre><code>objdump -Dr -j .ctors hellocpp\n</code></pre>\n<p>All I can get is like this:</p>\n<pre><code>hellocpp:     file format elf32-i386\n\n\nDisassembly of section .ctors:\n\n08049efc &lt;__CTOR_LIST__&gt;:\n 8049efc:   ff                      (bad)  \n 8049efd:   ff                      (bad)  \n 8049efe:   ff                      (bad)  \n 8049eff:   ff 00                   incl   (%eax)\n\n08049f00 &lt;__CTOR_END__&gt;:\n 8049f00:   00 00                   add    %al,(%eax)\n ...\n</code></pre>\n<p>Currently I am trying to recover the content of some ELF binaries compiled from <code>c++</code> program..</p>\n<p>So I am wondering if there is a way to get the content of <code>ctors</code> which equals to what <code>g++</code> produced?</p>\n<h3>Update:</h3>\n<p>Thanks a lot for @Igor's help. But I am still trapped in looking for <code>class's</code> <code>constructor</code> and <code>destructor</code>  info from ELF binary.</p>\n<p>When evolving <code>class</code> definition, g++ would produce these info in the <code>.ctors</code> section:</p>\n<pre><code>    .globl  _ZN8ComputerC1Ev\n    .set    _ZN8ComputerC1Ev,_ZN8ComputerC2Ev\n    .globl  _ZN8ComputerD1Ev\n    .set    _ZN8ComputerD1Ev,_ZN8ComputerD2Ev\n</code></pre>\n<p>Generally <code>_ZN8ComputerC2Ev</code> is the name of a class's constructor while <code>_ZN8ComputerD2Ev</code> is its  destructor.</p>\n<p>However, I just can not find corresponding info in the <code>objdump</code> dumped <code>.ctors</code> or <code>.init_array</code> sections.. I also tried <code>.eh_frame</code> and <code>gcc_except_table</code>, but the information dumped is massive.. I can not figure out the meaning of those information..</p>\n<p>Could anyone give me guide?</p>\n</div>",
    "votes": "7",
    "answers": 2,
    "views": "4k",
    "tags": [
        "disassembly",
        "x86",
        "c++",
        "elf"
    ],
    "user": "lllllllllllll",
    "time": "Jun 17, 2020 at 9:54",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The <code>.ctors</code> section is a list of pointers terminated with -1 (0xFFFFFFFF), so it does not make sense to disassemble it. If you rearrange the bytes as data, you get:</p>\n<pre><code>__CTOR_LIST__: .long 0xffffffff\n__CTOR_END__:  .long 0x00000000\n</code></pre>\n<p>So, for whatever reason, the resulting exe does not actually use the <code>.ctors</code> section. I suspect the linker instead placed the pointers into the new-style <code>.init_array</code> section. Note that it is, again, a list of pointers, and not code.</p>\n<p><strong>Edit</strong>:</p>\n<p>The <code>.ctors</code> or <code>.init_array</code> sections only contain so-called <em>constructor functions</em> - functions that need to be executed at startup, before the <code>main()</code> itself. These are usually compiler-generated functions that perform construction of global objects (such as <code>cin</code>, <code>cout</code> etc.), or other startup-related tasks. You can, in fact, add your own functions to that list using <a href=\"https://stackoverflow.com/questions/2053029/how-exactly-does-attribute-constructor-work\"><code>__attribute__((constructor))</code></a>.</p>\n<p>What does <strong>not</strong> go there are general C++ class constructors - there is no need to execute those on startup. They will be called when and if you construct an object of a specific class - e.g. by declaring a variable or calling <code>operator new</code>.</p>\n</div>",
            "votes": "9",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": true,
            "comments": [
                {
                    "user": "lllllllllllll",
                    "text": "<span class=\"comment-copy\">Groovy! I dump the content of <code>.init_array</code> section and it contains the address of <code>_GLOBAL__sub_I_main</code> function!</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>As Igor stated, the <code>.ctors</code> section is a list of function pointers, ending with a sentinel value of <code>0xffffffff</code>. To see its contents, just do</p>\n<pre><code>$ objdump -s -j.ctors bar.so\n</code></pre>\n<p>But your assembly file only contains weak symbols. Those are foreign functions in other libraries, and are invoked when their libraries are loaded at runtime.</p>\n<p>For example, put this in a file <code>bar.cpp</code>:</p>\n<pre><code>class Foo {\npublic:\n  int i;\n\n  Foo(int n) : i(n) {\n  }\n};\n\nFoo global_foo(123);\n</code></pre>\n<p>Compile with</p>\n<pre><code>$ g++ -shared -fPIC bar.cpp -obar.so\n</code></pre>\n<p>The contents of the <code>.init_array</code> section is</p>\n<pre><code>$ objdump -s -j.init_array bar.so\n\nbar.so:     file format elf64-x86-64\n\nContents of section .init_array:\n 200820 ad060000 00000000                    ........        \n</code></pre>\n<p>There's a function pointer there, <code>0xad060000 00000000</code>. But you have to change its endianness, e.g. with Python:</p>\n<pre><code>&gt;&gt;&gt; import struct\n&gt;&gt;&gt; import binascii\n&gt;&gt;&gt; binascii.hexlify(struct.pack(\"&lt;Q\", 0xad06000000000000))\n'00000000000006ad'\n</code></pre>\n<p>Now list all symbols and grep for that address:</p>\n<pre><code>$ objdump -C --syms bar.so | grep 00000000000006ad\n00000000000006ad l     F .text  0000000000000015\n  [... on above line ...] global constructors keyed to bar.cpp\n</code></pre>\n<p>The disassembly for it,</p>\n<pre><code>$ objdump -C -d bar.so\n</code></pre>\n<p>shows</p>\n<pre><code>00000000000006ad &lt;global constructors keyed to bar.cpp&gt;:\n 6ad:   55                      push   %rbp\n 6ae:   48 89 e5                mov    %rsp,%rbp\n 6b1:   be ff ff 00 00          mov    $0xffff,%esi\n 6b6:   bf 01 00 00 00          mov    $0x1,%edi\n 6bb:   e8 ba ff ff ff          callq  67a &lt;__static_initialization_and_destruction_0(int, int)&gt;\n 6c0:   c9                      leaveq \n 6c1:   c3                      retq   \n</code></pre>\n<p>which jumps to <code>__static_initialization_and_destruction_0(int, int)</code>:</p>\n<pre><code>000000000000067a &lt;__static_initialization_and_destruction_0(int, int)&gt;:\n 67a:   55                      push   %rbp\n 67b:   48 89 e5                mov    %rsp,%rbp\n 67e:   48 83 ec 10             sub    $0x10,%rsp\n 682:   89 7d fc                mov    %edi,-0x4(%rbp)\n 685:   89 75 f8                mov    %esi,-0x8(%rbp)\n 688:   83 7d fc 01             cmpl   $0x1,-0x4(%rbp)\n 68c:   75 1d                   jne    6ab &lt;__static_initialization_and_destruction_0(int, int)+0x31&gt;\n 68e:   81 7d f8 ff ff 00 00    cmpl   $0xffff,-0x8(%rbp)\n 695:   75 14                   jne    6ab &lt;__static_initialization_and_destruction_0(int, int)+0x31&gt;\n 697:   be 7b 00 00 00          mov    $0x7b,%esi\n 69c:   48 8b 05 9d 03 20 00    mov    0x20039d(%rip),%rax        # 200a40 &lt;_DYNAMIC+0x1e8&gt;\n 6a3:   48 89 c7                mov    %rax,%rdi\n 6a6:   e8 f5 fe ff ff          callq  5a0 &lt;Foo::Foo(int)@plt&gt;\n 6ab:   c9                      leaveq \n 6ac:   c3                      retq   \n</code></pre>\n<p>which puts 123 (<code>0x7b</code>) on the stack and calls <code>Foo::Foo(int)</code>.</p>\n</div>",
            "votes": "5",
            "user": "csl",
            "time": "Jun 3, 2016 at 9:02",
            "is_accepted": false,
            "comments": []
        }
    ]
}