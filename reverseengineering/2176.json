{
    "title": "How to find arrays of objects (entities, enemies) in a game I'm reversing with Cheat Engine?",
    "link": "https://reverseengineering.stackexchange.com/questions/2176/how-to-find-arrays-of-objects-entities-enemies-in-a-game-im-reversing-with-c",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am reversing a game using Cheat Engine and OllyDBG, through this memory addresses within an FPS game  are read and monitored, these addresses will contain the coordinates(xyz) of enemies.</p>\n<p>My Objective is to find an address or a pattern that will allow me to loop through up to 32 enemies in order to read all their coordinates, in order to do this I have been attempting to find a pattern between each of their addresses with no luck. I have been able to collect 3 different enemy addresses, this information is useful but searching through 32 addresses is a task which requires more effort than I believe is necessary.</p>\n<p>As stated I have access to the first 3 enemy addresses and if from that information it is possible to trace back to the base either through Cheat Engine or other reverse engineering software the process would be appreciated.</p>\n<p>Ultimately my question is, is there a way to detect a pointer array in memory from one of its addresses, for example if if I have 3 enemy coordinates can I somehow trace the memory location back to an address that accesses all 32 enemy addresses whether it is by using cheat engine or another reversing tool.</p>\n</div>",
    "votes": "12",
    "answers": 2,
    "views": "17k",
    "tags": [
        "disassembly",
        "ollydbg",
        "debugging",
        "debuggers",
        "struct"
    ],
    "user": "Daniel Filipe",
    "time": "Oct 30, 2016 at 6:12",
    "comments": [
        {
            "user": "NirIzr",
            "text": "<span class=\"comment-copy\">Can you specify what you already know about the structures? Simple coordinate arrays? Complex datatypes? Do you know the language used?</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><em>(OP didn't specify if he knows how structures are laid out. Looks like he assumes they aren't complex. I'll answer a more general question to avoid locality issues by assuming the structures are somewhat complex)</em></p>\n<p>Few ways to find the other structures come to mind:</p>\n<h2>Scanning memory for signatures</h2>\n<p>Once you have a few examples of the structures, maybe the easiest way to find the other structure instances is to find matching constants in all three structures. Some values may be constant, represent properties that apply to all the enemy entities in a more high-level class inherited.</p>\n<h3>Pros:</h3>\n<ul>\n<li>This is easy to implement, can be done this Cheat Engine.</li>\n<li>in the general case it should survive program restarts, you won't need to find the three structures every time you run the game.</li>\n</ul>\n<h3>Cons:</h3>\n<ul>\n<li>not so robust. stuff might change between versions, data you think is constant may actually change in some cases you haven't looked at. </li>\n</ul>\n<h2>Pointer searching</h2>\n<p>There might be a pointer to each entity somewhere. you can just as easily search the memory for the addresses of the structures you found, and detect the array/structure that holds all of the entities. you could also walk trough arrays you find in the structures themselves, you might be looking at a linked list.</p>\n<h3>Pros:</h3>\n<ul>\n<li>easy to implement.</li>\n<li>will be a bit more robust than the previous method.</li>\n</ul>\n<h3>Cons:</h3>\n<ul>\n<li>you will still need to somehow find the first entities.</li>\n</ul>\n<h2>Finding the Constructor/constructor-like function</h2>\n<p>Either Object Oriented language like C++ or ObjC, or a procedural language like C, there must be a function that initiates the structure. usually it's easy to find - the first function called after the object is allocated, pretty distinctive assembly - mostly initialization code.</p>\n<p>If we're talking about OO code, finding the virtual function table or a similar construct will let you easily find the construction functions, walk trough inheritance and find at least a portion of the manipulating functions.</p>\n<p>After you get the Constructors you can easily get all the allocations, and see where pointers are being kept.</p>\n<h3>Pros:</h3>\n<ul>\n<li>quite robust</li>\n<li>better understanding of how entities are saved in memory.</li>\n</ul>\n<h3>Cons:</h3>\n<ul>\n<li>Static RE. usually harder to do (Get a good dis-assembler)</li>\n</ul>\n<h2>Reversing the structure</h2>\n<p>This one requires a bit more reversing work, but will let you find the best ways to search for the entities. Using Cheat Engine and IDA, manually map the structure, the elements/members, the functions that manipulate the structure.</p>\n<p>If there're any pointers involved, follow them and reverse other structures you encounter.</p>\n<h3>Pros:</h3>\n<ul>\n<li>Robust</li>\n<li>The right way to do what you want. Really understand what's going on. facilitate future abilities/features.</li>\n</ul>\n<h3>Cons:</h3>\n<ul>\n<li>more work, and harder to do. A lot of RE.</li>\n</ul>\n<h2>Note</h2>\n<p>for at-least some of the methods I mentioned finding the pointers to all entities while analyzing the program might only be the first step. You can search for references to the list itself and get a better way to automatically find the entities on each program restart. This eliminates some of the Cons.</p>\n</div>",
            "votes": "19",
            "user": "NirIzr",
            "time": "Sep 12, 2016 at 23:02",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>First Find the address you are looking for. Then cycle this:</p>\n<ol>\n<li>Find the base (the beginning of the record).</li>\n<li>Dissect the memory around this to recognize array or linked list.</li>\n<li>Search the memory for pointer to that base.</li>\n</ol>\n<p><strong>Example</strong>:</p>\n<p>Scan for parameter finding the address <code>30000032</code>.</p>\n<p>Find out the base of this record is <code>30000000</code>.</p>\n<p>Checking memory - nothing fancy around.</p>\n<p>Finding pointer to the base at <code>20000004</code>.</p>\n<p>Find out the base of the record is <code>20000000</code>.</p>\n<p>Checking memory - still nothing...</p>\n<p>Finding pointer to the base at <code>10000008</code>.</p>\n<p>Finding out the base is <code>10000000</code>.</p>\n<p>Checking memory - all pointers to objects I am looking for are 12 bytes away from each other. (Obviously this is some sort of collection.)</p>\n<p>Last memory scan for pointer to make sure I am not wrong at <code>0000040</code>.</p>\n<p>Find pointer to that collection, and right after it: count of the objects in the collection.</p>\n<p>Restart the game/computer few times to find a consistent pointer to that address.</p>\n<p>Reward myself with a beer for the good work.</p>\n<p><strong>How to find the base</strong>: I like to use the \"pointer scan\", and check the last offset. The smallest from the most commonly found, is usually the correct one.</p>\n<p>Sometimes, I am trying to find a record, at the beginning of allocated memory, and in this case I am sure something is base.</p>\n<p>Another trick is to find two one after another in memory, determine their \"max size\", and this means the base must be no further than this number back in the memory.</p>\n<p><strong>How to recognize collections</strong>: Most of them are EXTREMELY organized, with specific offset, or have pointers to same type of objects.</p>\n<p>Like if you have:</p>\n<pre><code>Pointer to Player 1 data,\n4 Bytes\n4 Bytes\nPointer to Player 2 data,\n4 Bytes\n4 Bytes\nPointer to Player 3 data\n</code></pre>\n<p>It should ring a bell.</p>\n<p>Keep in mind that such alignment may randomly happen in the source, so try to search for: Player 3 data, Player 3 data +/- 4, Player 3 data +/- 8. </p>\n<p>Anyway, if you find something like this, you are most likely really close.</p>\n<p>This works for me, hope it works for you guys too.</p>\n</div>",
            "votes": "3",
            "user": "dsasmblr",
            "time": "Sep 10, 2018 at 13:30",
            "is_accepted": false,
            "comments": []
        }
    ]
}