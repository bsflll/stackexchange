{
    "title": "Mixed 16/32-bit code reversing using IDA",
    "link": "https://reverseengineering.stackexchange.com/questions/2440/mixed-16-32-bit-code-reversing-using-ida",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to reverse engineer a binary blob I expect to transition from 16-bit real mode into 32-bit protected mode (it is boot time code), so I expect the code to contain code of both sorts.</p>\n<p>When I launch IDA, I am given the option of 16 or 32-bit code, but not mixed.</p>\n<p>How do I instruct IDA to attempt to disassemble data at a given address as 32-bit mode?</p>\n<p>I can using the 16-bit analyzer deduce the initial jump (unoriginally) and IDA happily analyses the code from there. I can see where the 32-bit code jumps to (far jump, so IDA doesn't try to analyze it), but IDA treats this as 16-bit when I hit <kbd>C</kbd>.</p>\n<p>Other than launching a 16, and a 32-bit dissasmbly session, can I do this in one?</p>\n</div>",
    "votes": "10",
    "answers": 2,
    "views": "9k",
    "tags": [
        "ida",
        "x86"
    ],
    "user": null,
    "time": "Jul 9, 2013 at 20:36",
    "comments": [
        {
            "user": "Willem Hengeveld",
            "text": "<span class=\"comment-copy\">The arm processor module can do exactly this. So i guess it is a feature that could be implemented in theory.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><strong>Ida Free 5</strong></p>\n<pre><code>Edit -&gt; Segments -&gt;CreateSegment\n</code></pre>\n<p>in the dialog</p>\n<pre><code>segment name  = seg001....seg00n\nstart         = &lt;start address viz 0x0A\nend           = &lt;end address viz 0x1e\nbase          = 0x0 \nclass         = some text viz 32one,32two,16three\nradio button  = 32 bit segment or 16 bit segment as needed\nclick yes to a cryptic dialog \n</code></pre>\n<p>example \nthe binary stream contains 16 bit dos puts routine and 32 bit random pushes intermixed</p>\n<pre><code>C:\\Documents and Settings\\Admin\\Desktop&gt;xxd -g 1 1632blob.bin\n0000000: b4 01 cd 21 88 c2 b4 02 cd 21 68 78 56 34 12 68  ...!.....!hxV4.h\n0000010: 0d d0 37 13 68 be ba 37 13 68 00 0d db ba b4 01  ..7.h..7.h......\n0000020: cd 21 88 c2 b4 02 cd 21 68 78 56 34 12 68 0d d0  .!.....!hxV4.h..\n0000030: 37 13 68 be ba 37 13 68 00 0d db ba b4 01 cd 21  7.h..7.h.......!\n0000040: 88 c2 b4 02 cd 21 68 78 56 34 12 68 0d d0 37 13  .....!hxV4.h..7.\n0000050: 68 be ba 37 13 68 00 0d db ba                    h..7.h....\n\nC:\\Documents and Settings\\Admin\\Desktop&gt;\n</code></pre>\n<p>loading this blob as binary file moving to <code>offset 0</code> and pressing <code>c</code> would disassemble all bytes as <code>16 bit</code> </p>\n<p>now you can move to <code>offset 0x0a</code> and create a <code>32 bit segment</code> with start as <code>0x0a end as 0x1e base as 0x0 class as 32one use 32bitsegment radio button</code> and press <code>c</code> again to create 32 bit disassembly</p>\n<p>see below</p>\n<pre><code>seg000:0000                ;\nseg000:0000                ; +-------------------------------------------------------------------------+\nseg000:0000                ; ¦     This file is generated by The Interactive Disassembler (IDA)        ¦\nseg000:0000                ; ¦     Copyright (c) 2010 by Hex-Rays SA, &lt;<a class=\"__cf_email__\" data-cfemail=\"98ebede8e8f7eaecd8f0fde0b5eaf9e1ebb6fbf7f5\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>&gt;           ¦\nseg000:0000                ; ¦                      Licensed to: Freeware version                      ¦\nseg000:0000                ; +-------------------------------------------------------------------------+\nseg000:0000                ;\nseg000:0000                ; Input MD5   : AEB17B9F8C4FD00BF2C04A4B3399CED1\nseg000:0000\nseg000:0000                ; ---------------------------------------------------------------------------\nseg000:0000\nseg000:0000                                .686p\nseg000:0000                                .mmx\nseg000:0000                                .model flat\nseg000:0000\nseg000:0000                ; ---------------------------------------------------------------------------\nseg000:0000\nseg000:0000                ; Segment type: Pure code\nseg000:0000                seg000          segment byte public 'CODE' use16\nseg000:0000                                assume cs:seg000\nseg000:0000                                assume es:seg005, ss:seg005, ds:seg005, fs:seg005, gs:seg005\nseg000:0000 B4 01                          mov     ah, 1\nseg000:0002 CD 21                          int     21h\nseg000:0004 88 C2                          mov     dl, al\nseg000:0006 B4 02                          mov     ah, 2\nseg000:0008 CD 21                          int     21h\nseg000:0008                seg000          ends\nseg000:0008\nseg001:0000000A                ; ---------------------------------------------------------------------------\nseg001:0000000A\nseg001:0000000A                ; Segment type: Regular\nseg001:0000000A                seg001          segment byte public '32one' use32\nseg001:0000000A                                assume cs:seg001\nseg001:0000000A                                ;org 0Ah\nseg001:0000000A                                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\nseg001:0000000A 68 78 56 34 12                 push    12345678h\nseg001:0000000F 68 0D D0 37 13                 push    1337D00Dh\nseg001:00000014 68 BE BA 37 13                 push    1337BABEh\nseg001:00000019 68 00 0D DB BA                 push    0BADB0D00h\nseg001:00000019                seg001          ends\nseg001:00000019\nseg002:001E                ; ---------------------------------------------------------------------------\nseg002:001E\nseg002:001E                ; Segment type: Pure code\nseg002:001E                seg002          segment byte public 'CODE' use16\nseg002:001E                                assume cs:seg002\nseg002:001E                                ;org 1Eh\nseg002:001E                                assume es:seg005, ss:seg005, ds:seg005, fs:seg005, gs:seg005\nseg002:001E B4 01                          mov     ah, 1\nseg002:0020 CD 21                          int     21h\nseg002:0022 88 C2                          mov     dl, al\nseg002:0024 B4 02                          mov     ah, 2\nseg002:0026 CD 21                          int     21h\nseg002:0026                seg002          ends\nseg002:0026\nseg003:00000028                ; ---------------------------------------------------------------------------\nseg003:00000028\nseg003:00000028                ; Segment type: Regular\nseg003:00000028                seg003          segment byte public '32two' use32\nseg003:00000028                                assume cs:seg003\nseg003:00000028                                ;org 28h\nseg003:00000028                                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\nseg003:00000028 68 78 56 34 12                 push    12345678h\nseg003:0000002D 68 0D D0 37 13                 push    1337D00Dh\nseg003:00000032 68 BE BA 37 13                 push    1337BABEh\nseg003:00000037 68 00 0D DB BA                 push    0BADB0D00h\nseg003:00000037                seg003          ends\nseg003:00000037\nseg004:003C                ; ---------------------------------------------------------------------------\nseg004:003C\nseg004:003C                ; Segment type: Pure code\nseg004:003C                seg004          segment byte public 'CODE' use16\nseg004:003C                                assume cs:seg004\nseg004:003C                                ;org 3Ch\nseg004:003C                                assume es:seg005, ss:seg005, ds:seg005, fs:seg005, gs:seg005\nseg004:003C B4 01                          mov     ah, 1\nseg004:003E CD 21                          int     21h\nseg004:0040 88 C2                          mov     dl, al\nseg004:0042 B4 02                          mov     ah, 2\nseg004:0044 CD 21                          int     21h\nseg004:0044                seg004          ends\nseg004:0044\nseg005:00000046                ; ---------------------------------------------------------------------------\nseg005:00000046\nseg005:00000046                ; Segment type: Regular\nseg005:00000046                seg005          segment byte public '32three' use32\nseg005:00000046                                assume cs:seg005\nseg005:00000046                                ;org 46h\nseg005:00000046                                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing\nseg005:00000046 68 78 56 34 12                 push    12345678h\nseg005:0000004B 68 0D D0 37 13                 push    1337D00Dh\nseg005:00000050 68 BE BA 37 13                 push    1337BABEh\nseg005:00000055 68 00 0D DB BA                 push    0BADB0D00h\nseg005:00000055                seg005          ends\nseg005:00000055\nseg005:00000055\nseg005:00000055                                end\n</code></pre>\n</div>",
            "votes": "7",
            "user": "blabb",
            "time": "Jul 10, 2013 at 5:09",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>You could either do it manually or create a custom loader module for your binary blob. What you need to do is separate code into 2 segments: 32-bit segment and 16-bit segment, and specify appropriate addressing mode. IDA supports 16, 32, 64 bit modes. If needed you could manually create 2 different code segments and change address mode manually by pressing <kbd>Alt</kbd>+<kbd>S</kbd> </p>\n<p>In order to incorporate it in a loader, you may utilize <code>getseg</code> and <code>set_segm_addressing</code> from <em>segment.hpp</em> out of <a href=\"https://www.hex-rays.com/products/ida/support/download.shtml\">IDA SDK</a>:</p>\n<pre><code>// Get pointer to segment by linear address\n//      ea - linear address belonging to the segment\n// returns: NULL or pointer to segment structure\n\ninline segment_t *getseg(ea_t ea) { return (segment_t *)(segs.get_area(ea)); } \n</code></pre>\n<p><p></p>\n<pre><code>// Change segment addressing mode (16, 32, 64 bits)\n// You must use this function to change segment addressing, never change\n// the 'bitness' field directly.\n// This function will delete all instructions, comments and names in the segment\n//      s      - pointer to segment\n//      bitness- new addressing mode of segment\n//                 2: 64bit segment\n//                 1: 32bit segment\n//                 0: 16bit segment\n// returns: 1-ok, 0-failure\n\nidaman bool ida_export set_segm_addressing(segment_t *s, size_t bitness);\n</code></pre>\n<p>Firstly, you will need to get a pointer to a segment structure using <code>getseg</code>. Thereafter, you could change segment addressing mode to 16 or 32 bit using <code>set_segm_addressing</code>. </p>\n</p></div>",
            "votes": "10",
            "user": "PSS",
            "time": "Jul 10, 2013 at 5:21",
            "is_accepted": false,
            "comments": []
        }
    ]
}