{
    "title": "How to print the value of register with Radare 2",
    "link": "https://reverseengineering.stackexchange.com/questions/20540/how-to-print-the-value-of-register-with-radare-2",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to solve this <a href=\"https://www.root-me.org/en/Challenges/Cracking/ELF-Ptrace\" rel=\"nofollow noreferrer\">ELF - Ptrace challenge</a>. I use <code>Radare 2</code>. This is the commands I execute to print the assembly code.</p>\n<pre><code>radare2 ch3.bin\n[0x080482f0]&gt; aaa\n[[anal.jmptbl] Missing cjmp bb in predecessor at 0x08057fca\n[anal.jmptbl] Missing cjmp bb in predecessor at 0x08057f4a\n[anal.jmptbl] Missing cjmp bb in predecessor at 0x0808fc43\n[anal.jmptbl] Missing cjmp bb in predecessor at 0x0808fc23\n[anal.jmptbl] Missing cjmp bb in predecessor at 0x0808fc63\n[anal.jmptbl] Missing cjmp bb in predecessor at 0x0808fc83\n[x] Analyze all flags starting with sym. and entry0 (aa)\n[x] Analyze function calls (aac)\n[x] Analyze len bytes of instructions for references (aar)\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan)\n[x] Type matching analysis for all functions (aaft)\n[x] Use -AA or aaaa to perform additional experimental analysis.\n\n[0xf7f0b049]&gt; pd 100 @ main\n            ;-- main:\n/ (fcn) sym.main 175\n|   int sym.main (int argc, char **argv, char **envp);\n|           ; var char *s @ ebp-0x16\n|           ; var int var_ch @ ebp-0xc\n|           ; var int var_4h @ ebp-0x4\n|           ; arg int arg_4h @ esp+0x4\n|           ; DATA XREF from entry0 (0x8048307)\n|           0x080483f0      8d4c2404       lea ecx, [arg_4h]           ; sym._nl_current_LC_MONETARY\n|           0x080483f4      83e4f0         and esp, 0xfffffff0\n|           0x080483f7      ff71fc         push dword [ecx - 4]\n|           0x080483fa      55             push ebp\n|           0x080483fb      89e5           mov ebp, esp\n|           0x080483fd      51             push ecx\n|           0x080483fe      83ec14         sub esp, 0x14\n|           0x08048401      c745f488280c.  mov dword [var_ch], str.ksuiealohgy ; 0x80c2888 ; \"ksuiealohgy\"\n|           0x08048408      6a00           push 0                      ; void*data\n|           0x0804840a      6a01           push 1                      ; ecx ; void*addr\n|           0x0804840c      6a00           push 0                      ; pid_t pid\n|           0x0804840e      6a00           push 0                      ; __ptrace_request request\n|           0x08048410      e85b060100     call sym.ptrace\n|           0x08048415      83c410         add esp, 0x10\n|           0x08048418      85c0           test eax, eax\n|       ,=&lt; 0x0804841a b    791a           jns 0x8048436\n|       |   0x0804841c      83ec0c         sub esp, 0xc\n|       |   0x0804841f      6894280c08     push str.Debugger_detect___..._Exit ; 0x80c2894 ; \"Debugger detect\\u00e9 ... Exit\" ; const char *s\n|       |   0x08048424      e8a70e0000     call sym.puts               ; int puts(const char *s)\n|       |   0x08048429      83c410         add esp, 0x10\n|       |   0x0804842c      b801000000     mov eax, 1\n|      ,==&lt; 0x08048431      e9c3000000     jmp loc.080484f9\n|      ||   ; CODE XREF from sym.main (0x804841a)\n|      |`-&gt; 0x08048436      83ec0c         sub esp, 0xc\n|      |    0x08048439      68b0280c08     push 0x80c28b0              ; const char *s\n|      |    0x0804843e      e88d0e0000     call sym.puts               ; int puts(const char *s)\n|      |    0x08048443      83c410         add esp, 0x10\n|      |    0x08048446      83ec0c         sub esp, 0xc\n|      |    0x08048449      68f0280c08     push str.Bienvennue_dans_ce_challenge_de_cracking ; 0x80c28f0 ; \"##        Bienvennue dans ce challenge de cracking        ##\" ; const char *s\n|      |    0x0804844e      e87d0e0000     call sym.puts               ; int puts(const char *s)\n|      |    0x08048453      83c410         add esp, 0x10\n|      |    0x08048456      83ec0c         sub esp, 0xc\n|      |    0x08048459      6830290c08     push 0x80c2930              ; const char *s\n|      |    0x0804845e      e86d0e0000     call sym.puts               ; int puts(const char *s)\n|      |    0x08048463      83c410         add esp, 0x10\n|      |    0x08048466      b86e290c08     mov eax, str.Password_:     ; 0x80c296e ; \"Password : \"\n|      |    0x0804846b      83ec0c         sub esp, 0xc\n|      |    0x0804846e      50             push eax\n|      |    0x0804846f      e8ec0a0000     call sym.__printf\n|      |    0x08048474      83c410         add esp, 0x10\n|      |    0x08048477      a19c540e08     mov eax, dword obj.stdin    ; obj._IO_stdin ; [0x80e549c:4]=0x80e5080 obj._IO_2_1_stdin\n|      |    0x0804847c      83ec04         sub esp, 4\n|      |    0x0804847f      50             push eax                    ; FILE *stream\n|      |    0x08048480      6a09           push 9                      ; 9 ; int size\n|      |    0x08048482      8d45ea         lea eax, [s]\n|      |    0x08048485      50             push eax                    ; char *s\n|      |    0x08048486      e8050b0000     call sym.fgets              ; char *fgets(char *s, int size, FILE *stream)\n|      |    0x0804848b      83c410         add esp, 0x10\n|      |    0x0804848e      8d0597840408   lea eax, loc._notng         ; 0x8048497\n|      |    0x08048494      40             inc eax\n\\      |    0x08048495      ffe0           jmp eax\n       |    ;-- _notng:\n       |    ; DATA XREF from sym.main (0x804848e)\n       |    0x08048497      b88a55ea8b     mov eax, 0x8bea558a\n       |    0x0804849c      45             inc ebp\n       |    0x0804849d      f4             hlt\n       |    0x0804849e      83c004         add eax, 4\n       |    0x080484a1      8a00           mov al, byte [eax]\n       |    0x080484a3      38c2           cmp dl, al\n       |,=&lt; 0x080484a5 b    753d           jne 0x80484e4\n       ||   0x080484a7      8a55eb         mov dl, byte [ebp - 0x15]\n       ||   0x080484aa      8b45f4         mov eax, dword [ebp - 0xc]\n       ||   0x080484ad      83c005         add eax, 5\n       ||   0x080484b0      8a00           mov al, byte [eax]\n       ||   0x080484b2      38c2           cmp dl, al\n      ,===&lt; 0x080484b4      752e           jne 0x80484e4\n      |||   0x080484b6      8a55ec         mov dl, byte [ebp - 0x14]\n      |||   0x080484b9      8b45f4         mov eax, dword [ebp - 0xc]\n      |||   0x080484bc      40             inc eax\n      |||   0x080484bd      8a00           mov al, byte [eax]\n      |||   0x080484bf      38c2           cmp dl, al\n     ,====&lt; 0x080484c1 b    7521           jne 0x80484e4\n     ||||   0x080484c3      8a55ed         mov dl, byte [ebp - 0x13]\n     ||||   0x080484c6      8b45f4         mov eax, dword [ebp - 0xc]\n     ||||   0x080484c9      83c00a         add eax, 0xa\n     ||||   0x080484cc      8a00           mov al, byte [eax]\n     ||||   0x080484ce      38c2           cmp dl, al\n    ,=====&lt; 0x080484d0 b    7512           jne 0x80484e4\n    |||||   0x080484d2      83ec0c         sub esp, 0xc\n    |||||   0x080484d5      687a290c08     push str.Good_password      ; 0x80c297a ; \"\\nGood password !!!\\n\"\n    |||||   0x080484da      e8f10d0000     call sym.puts               ; int puts(const char *s)\n    |||||   0x080484df      83c410         add esp, 0x10\n   ,======&lt; 0x080484e2      eb10           jmp 0x80484f4\n   ||||||   ; CODE XREFS from loc._notng (+0xe, +0x1d, +0x2a, +0x39)\n   |```-`-&gt; 0x080484e4 b    83ec0c         sub esp, 0xc\n   |   |    0x080484e7      688e290c08     push str.Wrong_password.    ; 0x80c298e ; \"\\nWrong password.\\n\"\n   |   |    0x080484ec      e8df0d0000     call sym.puts               ; int puts(const char *s)\n   |   |    0x080484f1      83c410         add esp, 0x10\n   |   |    ; CODE XREF from loc._notng (+0x4b)\n   `------&gt; 0x080484f4      b800000000     mov eax, 0\n|- loc.080484f9 8\n|   loc.080484f9 ();\n|      |    ; var int var_4h @ ebp-0x4\n|      |    ; CODE XREF from sym.main (0x8048431)\n|      `--&gt; 0x080484f9      8b4dfc         mov ecx, dword [var_4h]\n|           0x080484fc      c9             leave\n|           0x080484fd      8d61fc         lea esp, [ecx - 4]\n\\           0x08048500      c3             ret\n            0x08048501      90             nop\n            0x08048502      90             nop\n            0x08048503      90             nop\n            0x08048504      90             nop\n            0x08048505      90             nop\n            0x08048506      90             nop\n            0x08048507      90             nop\n            0x08048508      90             nop\n            0x08048509      90             nop\n            0x0804850a      90             nop\n            0x0804850b      90             nop\n</code></pre>\n<p>I can see that there is an anti-debugging technic at instruction <code>0x0804841a</code>, I can bypass it putting a break point and modifying eip adress on the fly.\nI can also see that there is several tests before print <em>Good Password!!!</em>\nI put all the breakpoints I need :</p>\n<pre><code>[0x00000000]&gt; ood\n[0x080482f0]&gt; db 0x0804841a\n[0x080482f0]&gt; db 0x080484a5\n[0x080482f0]&gt; db 0x80484e4\n[0x080482f0]&gt; db 0x080484c1\n[0x080482f0]&gt; db 0x080484d0\n[0x080482f0]&gt; dc\nchild stopped with signal 28\n[+] SIGNAL 28 errno=0 addr=0x00000000 code=128 ret=0\n[0x080482f0]&gt; dc\nhit breakpoint at: 804841a\n[0x0804841a]&gt; dr eip=0x08048436\n0x0804841a -&gt;0x08048436\n[0x0804841a]&gt; dc\n############################################################\n##        Bienvennue dans ce challenge de cracking        ##\n############################################################\n\nPassword : badpassword \nhit breakpoint at: 80484a5\n[0x080484a5]&gt; dr eip=0x080484a7\n0x080484a5 -&gt;0x080484a7\n[0x080484a5]&gt; dc\nhit breakpoint at: 80484e4\n[0x080484a5]&gt; dr eip=0x080484b6\n0x080484e4 -&gt;0x080484b6\n[0x080484a5]&gt; dc\nhit breakpoint at: 80484c1\n[0x080484a5]&gt; dr eip=0x080484c3\n0x080484c1 -&gt;0x080484c3\n[0x080484a5]&gt; dc\nhit breakpoint at: 80484d0\n[0x080484a5]&gt; ptr axt\n[0x080484a5]&gt; dr\neax = 0x080c2879\nebx = 0x00000000\necx = 0xffffffff\nedx = 0x080e6515\nesi = 0x08048bc0\nedi = 0x08048b20\nesp = 0xffe51480\nebp = 0xffe51498\neip = 0x080484d0\neflags = 0x00000297\noeax = 0xffffffff\n</code></pre>\n<p>Now, at this point (and for each conditinal previous tests), I would like to print the value of the stack or adresses to see exactly what is compared. My problem is I can't understant what values are compared in the first test for example :</p>\n<pre><code>   |    ; DATA XREF from sym.main (0x804848e)\n   |    0x08048497      b88a55ea8b     mov eax, 0x8bea558a\n   |    0x0804849c      45             inc ebp\n   |    0x0804849d      f4             hlt\n   |    0x0804849e      83c004         add eax, 4\n   |    0x080484a1      8a00           mov al, byte [eax]\n   |    0x080484a3      38c2           cmp dl, al\n   |,=&lt; 0x080484a5      753d           jne 0x80484e4\n</code></pre>\n<p>I think I use a bad way to solve this challenge because I modify each eip to print finally <em>Good Password!!!</em>, I can't see the password on the stack or something else. I use the command <code>pxr @ esp</code>.\nWhat is the content of <code>al</code> and <code>dl</code> ?</p>\n<p>I also tried to generate the source code with <code>Snowman</code> but it doesn't help me :</p>\n<pre><code>void fun_804849e(void** ecx) {\n    signed char dl2;\n    struct s2421* eax3;\n    int32_t ebp4;\n    int32_t ebp5;\n    int32_t ebp6;\n    int32_t ebp7;\n    int32_t ebp8;\n    int32_t ebp9;\n    int32_t v10;\n    int32_t v11;\n    int32_t v12;\n    int32_t v13;\n    int32_t v14;\n    int32_t v15;\n\n    if (dl2 != eax3-&gt;f4 || (*reinterpret_cast&lt;signed char*&gt;(ebp4 - 21) != (*reinterpret_cast&lt;struct s2422**&gt;(ebp5 - 12))-&gt;f5 || (*reinterpret_cast&lt;signed char*&gt;(ebp6 - 20) != (*reinterpret_cast&lt;struct s2423**&gt;(ebp7 - 12))-&gt;f1 || *reinterpret_cast&lt;signed char*&gt;(ebp8 - 19) != (*reinterpret_cast&lt;struct s2424**&gt;(ebp9 - 12))-&gt;f10))) {\n        _IO_puts(ecx, \"\\nWrong password.\\n\", v10, v11, v12, __return_address());\n    } else {\n        _IO_puts(ecx, \"\\nGood password !!!\\n\", v13, v14, v15, __return_address());\n    }\n}\n</code></pre>\n</div>",
    "votes": "3",
    "answers": 1,
    "views": "11k",
    "tags": [
        "binary-analysis",
        "radare2",
        "breakpoint",
        "stack",
        "crackme"
    ],
    "user": "Anonymous",
    "time": "Feb 3, 2019 at 13:27",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Printing the registry values in radare2 is quite simple.</p>\n<h2>All registers</h2>\n<p>You can print all the General Purpose registers using <code>dr</code>:</p>\n<pre><code>[0x55bea3305070]&gt; dr\nrax = 0x55bea3305070\nrbx = 0x00000000\nrcx = 0x7fd7ee4f7578\nrdx = 0x7ffd63b54428\nr8 = 0x7fd7ee4f8be0\nr9 = 0x7fd7ee4f8be0\nr10 = 0x00000001\nr11 = 0x00000000\nr12 = 0x55bea3306ae0\nr13 = 0x7ffd63b54410\nr14 = 0x00000000\nr15 = 0x00000000\nrsi = 0x7ffd63b54418\nrdi = 0x00000001\nrsp = 0x7ffd63b54338\nrbp = 0x55bea33176f0\nrip = 0x55bea3305070\nrflags = 0x00000246\norax = 0xffffffffffffffff\n</code></pre>\n<h2>Telescoping</h2>\n<p>You can get even more information using <code>drr</code> which will also perform telescoping for the registers:</p>\n<pre><code>[0x55bea3305070]&gt; drr\n   rax 0x55bea3305070      (.text) (/usr/bin/ls) rip program R X 'push r15' 'ls'\n   rbx 0x0                 r15\n   rcx 0x7fd7ee4f7578      (/usr/lib/libc-2.28.so) rcx library R W 0x7fd7ee4f8be0 --&gt;  (/usr/lib/libc-2.28.so) r9 library R W 0x0 --&gt;  r15\n   rdx 0x7ffd63b54428      rdx stack R W 0x7ffd63b54b6d --&gt;  stack R W 0x622f3d4c4c454853 (SHELL=/bin/bash) --&gt;  ascii\n    r8 0x7fd7ee4f8be0      (/usr/lib/libc-2.28.so) r9 library R W 0x0 --&gt;  r15\n    r9 0x7fd7ee4f8be0      (/usr/lib/libc-2.28.so) r9 library R W 0x0 --&gt;  r15\n   r10 0x1                 rdi\n   r11 0x0                 r15\n   r12 0x55bea3306ae0      (.text) (/usr/bin/ls) r12 program R X 'endbr64' 'ls'\n   r13 0x7ffd63b54410      r13 stack R W 0x1 --&gt;  rdi\n   r14 0x0                 r15\n   r15 0x0                 r15\n   rsi 0x7ffd63b54418      rsi stack R W 0x7ffd63b54b65 --&gt;  stack R W 0x736c2f6e69622f (/bin/ls) --&gt;  ascii\n   rdi 0x1                 rdi\n   rsp 0x7ffd63b54338      rsp stack R W 0x7fd7ee35d223 --&gt;  (/usr/lib/libc-2.28.so) library R X 'mov edi, eax' 'libc-2.28.so'\n   rbp 0x55bea33176f0      (.text) (/usr/bin/ls) rbp program R X 'endbr64' 'ls'\n   rip 0x55bea3305070      (.text) (/usr/bin/ls) rip program R X 'push r15' 'ls'\n    cs 0x33                ascii\nrflags 1PZI                rflags\n  orax 0xffffffffffffffff  orax\n    ss 0x2b                ascii\nfs_base 0x7fd7ee336740      (unk1) R W 0x7fd7ee336740\ngs_base 0x0                 r15\n    ds 0x0                 r15\n    es 0x0                 r15\n    fs 0x0                 r15\n    gs 0x0                 r15\n</code></pre>\n<h2>A specific register</h2>\n<p>You can print a specific register using <code>dr &lt;reg&gt;</code>.</p>\n<pre><code>[0x55bea3305070]&gt; dr rax\n0x55bea3305070\n</code></pre>\n<p>The registers <code>al</code> and <code>dl</code> are simply the lower 8 bits of the registers EAX and EDX respectively.</p>\n<pre><code>[0x55bea3305070]&gt; dr rax\n0x55bea3305070\n[0x55bea3305070]&gt; dr eax\n0xa3305070\n[0x55bea3305070]&gt; dr al\n0x00000070\n\n\n\n[0x55bea3305070]&gt; dr rdx\n0x7ffd63b54428\n[0x55bea3305070]&gt; dr edx\n0x63b54428\n[0x55bea3305070]&gt; dr dl\n0x00000028\n</code></pre>\n<h2>Further reading</h2>\n<p>I recommend reading the <a href=\"https://book.rada.re/\" rel=\"noreferrer\">radare2book</a>, and more specifically, the <a href=\"https://book.rada.re/debugger/registers.html\" rel=\"noreferrer\">chapter about Registers</a>.</p>\n</div>",
            "votes": "11",
            "user": "Ryan White",
            "time": "Dec 10, 2021 at 21:32",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Anonymous",
                    "text": "<span class=\"comment-copy\">Ok thanks, I thought there was a way to do it that would help me to solve the challenge, but no.</span>",
                    "time": null
                }
            ]
        }
    ]
}