{
    "title": "How can I decompile the CC2650 .hex file to C?",
    "link": "https://reverseengineering.stackexchange.com/questions/19543/how-can-i-decompile-the-cc2650-hex-file-to-c",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I want to decompile it to C, or at least assembly the CC2650 hex file (Bluetooth Low Energy Sensor Tag), that provide TI.</p>\n<p>My goal is to know the specific way used by CC2650 to generate the LTK.</p>\n<p>I'll appreciatte the answers.</p>\n</div>",
    "votes": "-1",
    "answers": 1,
    "views": "1k",
    "tags": [
        "disassembly",
        "assembly",
        "c",
        "bluetooth"
    ],
    "user": "sfl0r3nz05",
    "time": "Oct 4, 2018 at 16:41",
    "comments": [
        {
            "user": "julian",
            "text": "<span class=\"comment-copy\">What is the exact format of the CC2650 hex file - Intel hex? What is TI? What is LTK? Where can we obtain this file?</span>",
            "time": null
        },
        {
            "user": "sfl0r3nz05",
            "text": "<span class=\"comment-copy\">Sorry for not being so specific: 1. ARM Cortex-M3 2. TI: Texas Instrument 3. LTK: Long Term Key 4. Hex file: <a href=\"https://ufile.io/lyxf2\" rel=\"nofollow noreferrer\">ufile.io/lyxf2</a></span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>First, convert the file from Hex to a raw binary using <a href=\"http://www.keil.com/support/docs/275.htm\" rel=\"nofollow noreferrer\"><code>srec_cat</code></a> or <a href=\"https://stackoverflow.com/questions/26961795/converting-from-hex-to-bin-for-arm-on-linux\"><code>objcopy</code></a></p>\n<p>Then take a look at an entropy plot, a hex dump, and the output of <code>strings</code> to check the state of the converted file. Here is a snippet of a hex dump of the converted file:</p>\n<pre><code>$ hexdump -C -n 256 sensor.bin \n00000000  00 37 00 20 c9 0b 00 00  d9 0b 00 00 db 0b 00 00  |.7. ............|\n00000010  dd 0b 00 00 dd 0b 00 00  dd 0b 00 00 00 00 00 00  |................|\n00000020  00 00 00 00 00 00 00 00  00 00 00 00 dd 0b 00 00  |................|\n00000030  dd 0b 00 00 00 00 00 00  dd 0b 00 00 dd 0b 00 00  |................|\n00000040  dd 0b 00 00 dd 0b 00 00  dd 0b 00 00 dd 0b 00 00  |................|\n*\n000000c0  dd 0b 00 00 dd 0b 00 00  df f8 e8 13 09 68 c1 f3  |.............h..|\n000000d0  04 61 16 29 a8 bf 20 39  01 eb 20 71 49 1c 16 29  |.a.).. 9.. qI..)|\n000000e0  a8 bf 15 21 04 da 6f f0  09 02 91 42 b8 bf 11 46  |...!..o....B...F|\n000000f0  01 f0 1f 01 df f8 c0 23  41 f4 f8 51 11 80 df f8  |.......#A..Q....|\n00000100\n</code></pre>\n<p>Next, check to see if you can find the entry point and attempt to begin disassembly there for the given architecture. Beginning disassembly at offset <code>0xC0</code> seems like a good guess. I used <code>r2</code> to perform the disassembly (note that \"sensor.bin\" is the name I gave to the binary converted from the CC2650 Hex file):</p>\n<pre><code>$ r2 -a arm -b 16 sensor.bin       &lt;-------  for ARM Thumb instruction set arch\n -- SHALL WE PLAY A GAME?\n[0x00000000]&gt; s 0xc0               &lt;-------- seek to offset 0xC0\n[0x000000c0]&gt; pd                   &lt;-------- print disassembly \n            0x000000c0      dd0b           lsrs r5, r3, 0xf\n            0x000000c2      0000           movs r0, r0\n            0x000000c4      dd0b           lsrs r5, r3, 0xf\n            0x000000c6      0000           movs r0, r0\n            0x000000c8      dff8e813       ldr.w r1, [0x000004b8]      ; [0x4b8:4]=0x4008626e\n            0x000000cc      0968           ldr r1, [r1]\n            0x000000ce      c1f30461       ubfx r1, r1, 0x18, 5\n            0x000000d2      1629           cmp r1, 0x16\n        ,=&lt; 0x000000d4      a8bf           it ge\n        `-&gt; 0x000000d6      2039           subs r1, 0x20\n            0x000000d8      01eb2071       add.w r1, r1, r0, asr 28\n            0x000000dc      491c           adds r1, r1, 1\n            0x000000de      1629           cmp r1, 0x16\n        ,=&lt; 0x000000e0      a8bf           it ge\n        `-&gt; 0x000000e2      1521           movs r1, 0x15\n        ,=&lt; 0x000000e4      04da           bge 0xf0\n        |   0x000000e6      6ff00902       mvn r2, 9\n        |   0x000000ea      9142           cmp r1, r2\n       ,==&lt; 0x000000ec      b8bf           it lt\n       `--&gt; 0x000000ee      1146           mov r1, r2\n        `-&gt; 0x000000f0      01f01f01       and r1, r1, 0x1f\n            0x000000f4      dff8c023       ldr.w r2, [0x000004bc]      ; [0x4bc:4]=0x40090000\n            0x000000f8      41f4f851       orr r1, r1, 0x1f00\n            0x000000fc      1180           strh r1, [r2]\n            0x000000fe      dff8bc13       ldr.w r1, [0x000004c2]      ; [0x4c0:4]=0x432a0494\n            0x00000102      0968           ldr r1, [r1]\n            0x00000104      8907           lsls r1, r1, 0x1e\n        ,=&lt; 0x00000106      4fbf           iteee mi\n        `-&gt; 0x00000108      40f04060       orr r0, r0, 0xc000000\n            0x0000010c      0021           movs r1, 0\n            0x0000010e      dff8b023       ldr.w r2, [0x000004c6]      ; [0x4c4:4]=0x43200000\n            0x00000112      1160           str r1, [r2]\n            0x00000114      dff8ac13       ldr.w r1, [0x000004c8]      ; [0x4c8:4]=0x400ca000\n            0x00000118      c0f3c062       ubfx r2, r0, 0x1b, 1\n            0x0000011c      82f00102       eor r2, r2, 1\n            0x00000120      c0f38060       ubfx r0, r0, 0x1a, 1\n            0x00000124      0a60           str r2, [r1]\n            0x00000126      80f00100       eor r0, r0, 1\n            0x0000012a      8860           str r0, [r1, 8]\n            0x0000012c      7047           bx lr\n            0x0000012e      70b5           push {r4, r5, r6, lr}\n            0x00000130      0546           mov r5, r0\n            0x00000132      82b0           sub sp, 8\n            0x00000134      0846           mov r0, r1\n            0x00000136      00f0eef8       bl 0x316\n            0x0000013a      0246           mov r2, r0\n            0x0000013c      dff88843       ldr.w r4, [0x000004cc]      ; [0x4cc:4]=0x50001370\n            0x00000140      1821           movs r1, 0x18\n            0x00000142      00f060f8       bl 0x206\n            0x00000146      00f012f9       bl 0x36e\n            0x0000014a      80b2           uxth r0, r0\n            0x0000014c      0090           str r0, [sp]\n            0x0000014e      0023           movs r3, 0\n            0x00000150      40f2ff32       movw r2, 0x3ff\n            0x00000154      2c21           movs r1, 0x2c               ; ','\n            0x00000156      2046           mov r0, r4\n            0x00000158      00f031fa       bl 0x5be\n            0x0000015c      dff86c63       ldr.w r6, [0x000004d0]      ; [0x4d0:4]=0xfcffff\n            0x00000160      f068           ldr r0, [r6, 0xc]\n            0x00000162      c0f30d02       ubfx r2, r0, 0, 0xe\n            0x00000166      1c21           movs r1, 0x1c\n            0x00000168      00f04df8       bl 0x206\n            0x0000016c      7068           ldr r0, [r6, 4]\n            0x0000016e      00f0fc32       and r2, r0, 0xfcfcfcfc\n.\n.\n&lt;snip&gt;\n</code></pre>\n<p>The disassembly seems OK. I am not familiar with ARM assembly variants, however. The absence of invalid disassembly is a good sign.</p>\n<p>That should be enough information to get you started with your decompiler of choice. </p>\n</div>",
            "votes": "1",
            "user": "julian",
            "time": "Oct 4, 2018 at 18:49",
            "is_accepted": true,
            "comments": []
        }
    ]
}