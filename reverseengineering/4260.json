{
    "title": "Recursive traversal disassembling with Radare2?",
    "link": "https://reverseengineering.stackexchange.com/questions/4260/recursive-traversal-disassembling-with-radare2",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying  the recursive traversal disassembler of the <code>radare2</code> tool. But, I cannot use it properly.</p>\n<p>First, according to the <code>radare2</code> manual, we can use recursive traversal disassembler by using the <code>pdr</code>:</p>\n<pre><code>[0x00404890]&gt; pd?\nUsage: pd[f|i|l] [len] @ [addr]\n  pda  : disassemble all possible opcodes (byte per byte)\n  pdj  : disassemble to json\n  pdb  : disassemble basic block\n  pdr  : recursive disassemble across the function graph\n  pdf  : disassemble function\n  pdi  : like 'pi', with offset and bytes\n  pdl  : show instruction sizes\n</code></pre>\n<p>But I always get this error message:</p>\n<pre><code>Cannot find function at 0x004028c0\n</code></pre>\n<p>Here is a full session of <code>radare2</code> on the <code>ls</code> command with, first, a linear sweep disassembly and, then, an attempt of recursive traversal disassembly:</p>\n<pre><code>$&gt; radare2 /bin/ls\nsyntax error: error in error handling\nsyntax error: error in error handling\n[0x00404890]&gt; pd@main\n        ;-- main:\n        0x004028c0    4157         push r15\n        0x004028c2    4156         push r14\n        0x004028c4    4155         push r13\n        0x004028c6    4154         push r12\n        0x004028c8    55           push rbp\n        0x004028c9    4889f5       mov rbp, rsi\n        0x004028cc    53           push rbx\n        0x004028cd    89fb         mov ebx, edi\n        0x004028cf    4881ec88030. sub rsp, 0x388\n        ...\n        0x00402dff    8b0567772100 mov eax, [rip+0x217767] ; 0x0040a56c \n        0x00402e05    488b0d64772. mov rcx, [rip+0x217764] ; 0x0040a570 \n        0x00402e0c    83f801       cmp eax, 0x1\n        0x00402e0f    0f84de0d0000 jz 0x403bf3\n        0x00402e15    83f802       cmp eax, 0x2\n        0x00402e18    be0f384100   mov esi, 0x41380f\n        0x00402e1d    b80e384100   mov eax, str.vdir\n        0x00402e22    480f45f0     cmovnz rsi, rax\n        0x00402e26    488b3de3772. mov rdi, [rip+0x2177e3] ; 0x0040a610\n        0x00402e2d    48c70424000. mov qword [rsp], 0x0\n        0x00402e35    41b9bd384100 mov r9d, str.DavidMacKenzie\n        0x00402e3b    41b8cd384100 mov r8d, str.RichardM.Stallman\n[0x00404890]&gt; pdr@main\nCannot find function at 0x004028c0\n</code></pre>\n<p>In fact, I strongly suppose that I am missing a step here. It seems that we should first build the call graph of the program, but I didn't manage to find how to do it (I obviously have missed some documentation somewhere, sorry for that!). </p>\n<p>So, if somebody can give me a hint about it, I would be pleased !</p>\n</div>",
    "votes": "7",
    "answers": 1,
    "views": "6k",
    "tags": [
        "disassembly",
        "radare2"
    ],
    "user": "perror",
    "time": "May 4, 2014 at 17:15",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>In fact, you should first run a '<em>function</em>' analysis of the program. To better understand this type <code>a?</code>:</p>\n<pre><code>[0x00404890]&gt; a?\nUsage: a[?adfFghoprsx]\n a8 [hexpairs]    ; analyze bytes\n aa               ; analyze all (fcns + bbs)\n ad               ; analyze data trampoline (wip)\n ad [from] [to]   ; analyze data pointers to (from-to)\n ae [expr]        ; analyze opcode eval expression (see ao)\n af[bcsl?+-*]     ; analyze Functions\n aF               ; same as above, but using graph.depth=1\n ag[?acgdlf]      ; output Graphviz code\n ah[?lba-]        ; analysis hints (force opcode size, ...)\n ao[e?] [len]     ; analyze Opcodes (or emulate it)\n ap               ; find and analyze function preludes\n ar[?ld-*]        ; manage refs/xrefs\n as [num]         ; analyze syscall using dbg.reg\n at[trd+-*?] [.]  ; analyze execution Traces\n ax[-cCd] [f] [t] ; manage code/call/data xrefs\nExamples:\n f ts @ `S*~text:0[3]`; f t @ section..text\n f ds @ `S*~data:0[3]`; f d @ section..data\n .ad t t+ts @ d:ds\n</code></pre>\n<p>And, more precisely with an <code>af?</code>:</p>\n<pre><code>[0x00404890]&gt; af?\nUsage: af[?+-l*]\n af @ [addr]               ; Analyze functions (start at addr)\n af+ addr size name [type] [diff] ; Add function\n af- [addr]                ; Clean all function analysis data (or function at addr)\n afb 16                    ; set current function as thumb\n afbb fcnaddr addr size name [type] [diff] ; Add bb to function @ fcnaddr\n afl[*] [fcn name]         ; List functions (addr, size, bbs, name)\n afi [fcn name]            ; Show function(s) information (verbose afl)\n afr name [addr]           ; Rename name for function at address (change flag too)\n afs [addr] [fcnsign]      ; Get/set function signature at current address\n af[aAv][?] [arg]          ; Manipulate args, fastargs and variables in function\n afc @ [addr]              ; Calculate the Cyclomatic Complexity (starting at addr)\n af*                       ; Output radare commands\n</code></pre>\n<p>Then, start a '<em>functions</em>' analysis beginning at <code>main</code>:</p>\n<pre><code>[0x00404890]&gt; af@main\n</code></pre>\n<p>Then, you can run a recursive traversal disassembly:</p>\n<pre><code>[0x00404890]&gt; pdr@main\n/ (fcn) fcn.004028c0 7460\n|           ;-- main:\n|           0x004028c0    4157         push r15\n|           0x004028c2    4156         push r14\n|           0x004028c4    4155         push r13\n|           0x004028c6    4154         push r12\n|           0x004028c8    55           push rbp\n|           0x004028c9    4889f5       mov rbp, rsi\n|           0x004028cc    53           push rbx\n|           0x004028cd    89fb         mov ebx, edi\n|           0x004028cf    4881ec88030. sub rsp, 0x388\n|           0x004028d6    488b3e       mov rdi, [rsi]\n|           0x004028d9    64488b04252. mov rax, [fs:0x28]\n|           0x004028e2    48898424780. mov [rsp+0x378], rax\n|           0x004028ea    31c0         xor eax, eax\n|           0x004028ec    e8afad0000   call 0x40d6a0 ; (fcn.0040d69f)\n|              fcn.0040d69f(unk, unk, unk, unk, unk, unk)\n|           0x004028f1    be19694100   mov esi, 0x416919\n|           0x004028f6    bf06000000   mov edi, 0x6\n|               0x004028fb    e810feffff   call sym.imp.setlocale\n\n... clip ...\n\n--\n|           0x00402980    83e801       sub eax, 0x1\n|           0x00402983    7405         jz fcn.004038a8\n-[true]-&gt; 0x0040298a\n-[false]-&gt; 0x00402985\n--\n</code></pre>\n<p>You can also start radare2 with the <code>-A</code> option:</p>\n<blockquote>\n<p>-A : run 'aaa' command before prompt or patch to analyze all referenced code</p>\n</blockquote>\n<p>See also <a href=\"http://radare.today/posts/analysis-by-default/\" rel=\"nofollow\">http://radare.today/posts/analysis-by-default/</a></p>\n</div>",
            "votes": "6",
            "user": "Maijin",
            "time": "Jul 26, 2016 at 8:22",
            "is_accepted": true,
            "comments": [
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">What kind of analysis does perform the <code>af@func</code> command ? Could you elaborate a bit ?</span>",
                    "time": null
                },
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">From what I read, it build-up the call-graph of the program.</span>",
                    "time": null
                },
                {
                    "user": "jvoisin",
                    "text": "<span class=\"comment-copy\">It does a recursive function analysis starting from the <code>func</code> address.</span>",
                    "time": null
                }
            ]
        }
    ]
}