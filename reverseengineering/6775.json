{
    "title": "Why are those instructions generated?",
    "link": "https://reverseengineering.stackexchange.com/questions/6775/why-are-those-instructions-generated",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>After disassembling a program, I see the following asm code generated :</p>\n<pre><code>.text:004D5911 mov     [ebp+var_4], ecx\n.text:004D5914 mov     ecx, [ebp+var_4]\n.text:004D5917 test    ecx, ecx\n.text:004D5919 jnz     short loc_4D591F\n</code></pre>\n<p>I don't get why <code>[ebp+var_4]</code> is copied back to <code>ecx</code>.</p>\n<p>Is this an artifact (missed optimization) from the compiler which requires test to take registers as operands?</p>\n</div>",
    "votes": "8",
    "answers": 1,
    "views": "240",
    "tags": [
        "disassembly",
        "compilers"
    ],
    "user": "Eric",
    "time": "Dec 7, 2014 at 12:57",
    "comments": [
        {
            "user": "Guntram Blohm",
            "text": "<span class=\"comment-copy\">You answered your own question. Yes.</span>",
            "time": null
        },
        {
            "user": "Guntram Blohm",
            "text": "<span class=\"comment-copy\">This might also be part of a loop that starts at 4D5914, with the first instruction initializing the loop control variable. Though this seems unlikely, since a) the jnz jumps if cx is <i>not</i> zero, and b) this seems to be an IDA disassembly, and ida would have generated a loc_... label if there was a jump to this address.</span>",
            "time": null
        },
        {
            "user": "Fewmitz",
            "text": "<span class=\"comment-copy\">I've also seen compilers do this for alignment reasons. inside a particular section</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This is a common pattern in assembly generated by gcc at least. When it is not asked to optimize the generated code, the translation between C and asm is really straightforward. One statement in C produces a few lines of asm. Next statement: a few more lines of asm, and so on.</p>\n<p>In your case:</p>\n<pre><code>mov     [ebp+var_4], ecx\n</code></pre>\n<p>is probably the end of a line of C, while:</p>\n<pre><code>mov     ecx, [ebp+var_4]\n</code></pre>\n<p>is the beginning of the next one.</p>\n<p>These instructions are optimized out as soon as <code>-O1</code> (or higher) is provided.</p>\n</div>",
            "votes": "3",
            "user": "Celelibi",
            "time": "Dec 8, 2014 at 3:21",
            "is_accepted": false,
            "comments": [
                {
                    "user": "David Hoelzer",
                    "text": "<span class=\"comment-copy\">Optimization, as mentioned in this answer, will eliminate this oddity which you have correctly identified as a compiler artifact.  Things like these are quite useful for figuring out whether code was \"hand written\", compiled or, potentially, identifying which compiler was used to build a particular piece of code.</span>",
                    "time": null
                }
            ]
        }
    ]
}