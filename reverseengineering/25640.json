{
    "title": "Why can't you edit pseudo code?",
    "link": "https://reverseengineering.stackexchange.com/questions/25640/why-cant-you-edit-pseudo-code",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Dabbler in re here, so potentially a stupid question...\nI know ida, binary ninja, and ghidra are really powerful at generating pseudo code.\nFrom everything I've read pseudo code can't be edited in realtime but can be edited as assembly, I was just wondering why you couldn't do a similar process to the one below?</p>\n<ol>\n<li><p>decompile exe to fake code</p>\n</li>\n<li><p>make code template for compiling in c or c++</p>\n</li>\n<li><p>load fake code into template</p>\n</li>\n<li><p>compile basic template and stop at assembly code generation</p>\n</li>\n<li><p>copy assembly from halfway compiled c++ exe</p>\n</li>\n<li><p>auto replace halfway compiled code as assembly to ida assembly code</p>\n</li>\n</ol>\n<p>Alternatively,</p>\n<ol>\n<li><p>decompile exe to fake code</p>\n</li>\n<li><p>make code template for compiling in c or c++</p>\n</li>\n<li><p>load fake code into template</p>\n</li>\n<li><p>compile basic template and stop at assembly code generation</p>\n</li>\n<li><p>load the function into ida or such with pdb</p>\n</li>\n<li><p>generate fake code for your template exe</p>\n</li>\n<li><p>go to the function and get the assembly from there to copy and replace</p>\n</li>\n</ol>\n<p>I know this method wouldn't be fast... but I am surprised no one has tried a method like this as far as I'm aware? Am I just missing something obvious?</p>\n</div>",
    "votes": "3",
    "answers": 3,
    "views": "9k",
    "tags": [
        "ida",
        "ghidra"
    ],
    "user": "Spyindabox",
    "time": "Aug 13, 2020 at 13:33",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<span class=\"comment-copy\">Hi and welcome to RE.SE! IDA creates no pseudo-code. IDA is a pure disassembler. To get anything like pseudo-code you'll have to shell out twice the amount you pay for IDA itself for the Hex-Rays plugin (single architecture, for further architectures discounts apply) or you have to build and install something like the RetDec plugin.</span>",
            "time": null
        },
        {
            "user": "Heath Mitchell",
            "text": "<span class=\"comment-copy\">I'm working on this, which currently is just a proof of concept but shows that it's possible: <a href=\"https://www.reddit.com/r/ghidra/comments/sbqnwf/working_on_this_thing_to_let_you_modify_and/\" rel=\"nofollow noreferrer\">reddit.com/r/ghidra/comments/sbqnwf/â€¦</a></span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<blockquote>\n<p>From everything I've read pseudo code can't be edited in realtime but can be edited as assembly</p>\n</blockquote>\n<p>This is not entirely correct. Quite the opposite even: Decompilers cannot be perfect (the compilation step looses too much information). Hence they need some help by a human (the reverse engineer). Giving this help is, at least in my opinion, the most important step during reverse engineering: get data types right. Sure, renaming variables helps a lot with readability, but the decompiler doesn't really need it. Changing the type of a variable or function though, feeds information back into the decompiler, which then can run another pass and improve the result. This result can then again further be improved by the human. If I would need to name the most important step during static binary reverse engineering, I would call out this cycle: decompile, re-type, repeat.</p>\n<p>Now that we got this out of the way, I'll try to address the suggested steps you propose: I am not entirely sure I understand what you mean but I think a huge problem arises in step 2/4:</p>\n<blockquote>\n<p>make code template for compiling in c or c++</p>\n</blockquote>\n<p>code generated by a decompiler is not <em>really</em> C/C++ code. Formally, it only qualifies as pseudo-code that has a C-like syntax. The differences between valid C and \"decompiler C\" depends on your decompiler of course (Hex-Rays, Binary Ninja, Ghidra), but to give a simple examples (there are more, many of which are far more serious): If Ghidra's decompiler is not sure what data type a given variable is, it will assign the <a href=\"https://ghidra.re/ghidra_docs/api/ghidra/program/model/data/Undefined.html\" rel=\"noreferrer\">\"type\" <code>undefined</code></a>. This is not a valid data type in C of course, and hence cannot be compiled into an executable (i.e. step 4 fails).</p>\n</div>",
            "votes": "8",
            "user": "0xC0000022L",
            "time": "Aug 10, 2020 at 9:07",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>@born brings up some great points, but I do think it's definitely worth saying there's not much inherently <em>impossible</em> about the whole idea. Compiling and grabbing assembly is likely not the best bet, though.</p>\n<p>Passing the entire thing off as impossible is just not right. IDA clearly has potential in the area; Select psuedocode and click \"Copy to Assembly\". It'll generate comments in the assembly that map it to where the psuedocode functions come from.</p>\n<p>Here's a comparison of the three different relevant phases of a program; source, psuedocode, and ASM:</p>\n<p>Source (<code>clang -w -o test</code>) :</p>\n<pre><code>int main(void)\n{\n  printf(\"hello world\");\n}\n</code></pre>\n<p>Note the incorrect, but functional, use of <code>printf(\"string\")</code> instead of <code>printf(\"%s\", \"string\")</code>. This is another debate, but it'll screw up decompilation</p>\n<p>Decompilation By IDA (psuedocode):</p>\n<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  printf(\"hello world\", argv, envp);\n  return 0;\n}\n</code></pre>\n<p>This is just wrong. printf won't accept those values, it's expecting 0 extra arguments due to a lack of formatting \"%s\" strings in \"hello world\". A simple mistake has screwed up the psuedocode output.</p>\n<p>Disassembly by IDA (note some of these instructions might not be right)</p>\n<pre><code>push    rbp\nmov     rbp, rsp\nsub     rsp, 10h\n; 2:   printf(\"hello world\", argv, envp);\nlea     rdi, aHelloWorld ; \"hello world\"\nmov     al, 0\ncall    _printf\n; 3:   return 0;\nxor     ecx, ecx\nmov     [rbp+var_4], eax\nmov     eax, ecx\nadd     rsp, 10h\npop     rbp\nretn\n</code></pre>\n<p>Let's say you wanted to edit the string:<br/>\nSure, just edit the place it references. Oh, but you want one longer than 11 characters, so you'll need to find somewhere unused and map the string pointer to that address instead. That's complicated.</p>\n<p>The entire executable section of the program is 12 instructions long, too. You have almost no space to change anything, and <em>adding</em> stuff is an entirely different ballgame.</p>\n<p>Likely Reasons it hasn't been done</p>\n<ul>\n<li>One huge hangup is how unreliable psuedocode can be at times. Compare Hopper psuedocode to IDA/Ghidra's sometime for a great example. It's an educated guess, not a reliable one. Some don't even create variables, and trying to compile Hopper psuedocode is a waste of time.</li>\n<li>Most people needing to patch a binary want or need to patch the assembly. ASM works differently than C, and when you're patching, you need to be thinking more about how the assembly works than the C code that was used to create it.</li>\n<li>Most of the decompilers I know of are already fairly bad at patching assembly alone. An extremely basic hex editor does a much better job. IDA will give you a headache trying to patch more than 4 bytes</li>\n</ul>\n<p>I don't think it's anywhere near impossible though. Not by compiling for sure. But what you <em>could</em> try, is something like these:</p>\n<ul>\n<li><p>Track how the decompiler was able to map &lt;x assembly&gt; to &lt;y psuedocode&gt;, and whenever &lt;y psuedocode&gt; is changed, create binary patches for the &lt;x assembly&gt; that created it.</p>\n<ul>\n<li>This is arguably the \"best\" way to do it and will take a long time to write.</li>\n</ul>\n</li>\n<li><p>Replace a function call with a branch to your own code elsewhere (assuming space can be found). \"Cheat Engine\" (it's been a while since I've used windows, sorry) had something like this if I remember correctly. Maybe use a compiler to generate <em>that</em> function, then.</p>\n<ul>\n<li>This is the lazy way to do it, and might end up taking even more work making decompiler output compilable. Only IDA/Ghidra decompilation is close enough to be feasible. I've done this manually before.</li>\n</ul>\n</li>\n</ul>\n<p>Both of these require an understanding of assembly to verify the patches were correct; A wrong one will grind your program to a halt, and no tool doing this will be reliably correct.</p>\n<p>#2 still has flaws. I've spent 2+ hours perfecting decompilation/disassembly on a single function; everything in memory properly named, manually defined every struct, etc. Even with perfect decompilation, it still needs work to be compiled.</p>\n<p>Maybe you could do that work yourself in some complex script. This is a problem I'd recommend revisiting when you're experienced; it's a really interesting topic, and IDAPython might make it almost feasible.</p>\n</div>",
            "votes": "0",
            "user": "kat",
            "time": "Aug 13, 2020 at 9:18",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>for editing in every owning pseudo code do think psychology corelations of it and then you get the human meaning for those who didnt change indetity based on it\nonly for who didnt read</p>\n<p>but if code is not accessible (no pseudo code) you can make a dictionary of character to binary and to its functions on the cpu that have high performance on java or python(slow)</p>\n</div>",
            "votes": "-6",
            "user": "Noam lima",
            "time": "Aug 10, 2020 at 20:03",
            "is_accepted": false,
            "comments": []
        }
    ]
}