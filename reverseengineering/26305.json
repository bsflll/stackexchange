{
    "title": "How to change local_184h to skip past jump commands with Radare2?",
    "link": "https://reverseengineering.stackexchange.com/questions/26305/how-to-change-local-184h-to-skip-past-jump-commands-with-radare2",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to solve a CTF challenge but I am very much out of my depth and nothing online is helping me very much. This is what I'm working with currently</p>\n<pre><code>|           0x55b3fd508a41      4889e5         mov rbp, rsp                                                                                                   \n|           0x55b3fd508a44      4881ec900100.  sub rsp, 0x190                                                                                                 \n|           0x55b3fd508a4b      89bd7cfeffff   mov dword [local_184h], edi       ; argc                                                                       \n|           0x55b3fd508a51      4889b570feff.  mov qword [local_190h], rsi       ; argv                                                                       \n|           0x55b3fd508a58      64488b042528.  mov rax, qword fs:[0x28]       ; [0x28:8]=-1 ; '(' ; 40                                                        \n|           0x55b3fd508a61      488945f8       mov qword [local_8h], rax                                                                                      \n|           0x55b3fd508a65      31c0           xor eax, eax                                                                                                   \n|           0x55b3fd508a67      c78588feffff.  mov dword [local_178h], 0x2d       ; '-' ; 45                                                                  \n|           0x55b3fd508a71      c7858cfeffff.  mov dword [local_174h], 0x32       ; '2' ; 50                                                                  \n|           0x55b3fd508a7b      83bd7cfeffff.  cmp dword [local_184h], 1       ; rdi ; [0x1:4]=-1                                                             \n|       ,=&lt; 0x55b3fd508a82      0f8e77010000   jle 0x55b3fd508bff      ;[1]                                                                                   \n|       |   0x55b3fd508a88      488b8570feff.  mov rax, qword [local_190h]                                                                                    \n|       |   0x55b3fd508a8f      4883c008       add rax, 8                                                                                                     \n|       |   0x55b3fd508a93      488b00         mov rax, qword [rax]                                                                                           \n|       |   0x55b3fd508a96      488d35fb0200.  lea rsi, str.calc       ; 0x55b3fd508d98 ; \"calc\"                                                              \n|       |   0x55b3fd508a9d      4889c7         mov rdi, rax   \n</code></pre>\n<p>I am interested in the line <code>0x55b3fd508a7b</code>, what does <code>local_184h</code> mean? How do I edit this value in order to change the result of the upcoming <code>jle</code>? Or, how do I change the result of the <code>jle</code> command without having to change <code>local_184h</code>? I read that it checks the <a href=\"https://en.wikipedia.org/wiki/FLAGS_register\" rel=\"nofollow noreferrer\">sign flag</a> so I edited the <code>rflags</code> register to be <code>0x0080</code> less than it was, hoping that would change the outcome of the <code>jle</code> but it didn't.</p>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "202",
    "tags": [
        "x86",
        "radare2",
        "register"
    ],
    "user": "retsek680",
    "time": "Nov 14, 2020 at 21:38",
    "comments": [
        {
            "user": "sudhackar",
            "text": "<span class=\"comment-copy\">Are you using the radare2 debugger or gdb?</span>",
            "time": null
        },
        {
            "user": "retsek680",
            "text": "<span class=\"comment-copy\">@sudhackar Radare2 debugger</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>According to <a href=\"http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-1-manual.pdf\" rel=\"nofollow noreferrer\">Intel's manual</a></p>\n<pre><code>3.4.3.1\nStatus Flags\nThe status flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, such as the ADD, SUB, MUL, and DIV instructions. The status flag functions are:\nCF (bit 0) Carry flag — Set if an arithmetic operation generates a carry or a borrow out of the most- significant bit of the result; cleared otherwise. This flag indicates an overflow condition for unsigned-integer arithmetic. It is also used in multiple-precision arithmetic.\nPF (bit 2) Parity flag — Set if the least-significant byte of the result contains an even number of 1 bits; cleared otherwise.\nAF (bit 4) Auxiliary Carry flag — Set if an arithmetic operation generates a carry or a borrow out of bit 3 of the result; cleared otherwise. This flag is used in binary-coded decimal (BCD) arithmetic.\nZF (bit 6) Zero flag — Set if the result is zero; cleared otherwise.\nSF (bit 7) Sign flag — Set equal to the most-significant bit of the result, which is the sign bit of a signed integer. (0 indicates a positive value and 1 indicates a negative value.)\nOF (bit 11) Overflow flag — Set if the integer result is too large a positive number or too small a negativenumber (excluding the sign-bit) to fit in the destination operand; cleared otherwise. This flag indicates an overflow condition for signed-integer (two’s complement) arithmetic.\n</code></pre>\n<p>So to set individual flags you need to operate on the individual bits</p>\n<p>to clear <code>n</code>th bit in a <code>number</code></p>\n<pre><code>number &amp;= ~(1 &lt;&lt; n)\n</code></pre>\n<p>For SF n = 7, so to unset SF</p>\n<pre><code>eflags &amp;= ~(1 &lt;&lt; 7)\n</code></pre>\n<p>with this simple code</p>\n<pre><code>int main(int argc, char **argv) {\n    int in;\n    scanf(\"%d\", &amp;in);\n    if (in &gt; 10) {\n        puts(\"greater\");\n    } else {\n        puts(\"less\");\n    }\n    return 0;\n}\n</code></pre>\n<p>This can be achieved easily</p>\n<pre><code>[re] r2 -d test\nProcess with PID 17193 started...\n= attach 17193 17193\nbin.baddr 0x55c79226b000\nUsing 0x55c79226b000\nasm.bits 64\n[0x7fb03234b090]&gt; dcu sym.main\nContinue until 0x55c79226b83a using 1 bpsize\nhit breakpoint at: 0x55c79226b83a\n[0x55c79226b83a]&gt; pd20\n            ;-- main:\n            ;-- rax:\n            ;-- rip:\n            0x55c79226b83a      55             push rbp\n            0x55c79226b83b      4889e5         mov rbp, rsp\n            0x55c79226b83e      4883ec20       sub rsp, 0x20\n            0x55c79226b842      897dec         mov dword [rbp - 0x14], edi\n            0x55c79226b845      488975e0       mov qword [rbp - 0x20], rsi\n            0x55c79226b849      64488b042528.  mov rax, qword fs:[0x28]\n            0x55c79226b852      488945f8       mov qword [rbp - 8], rax\n            0x55c79226b856      31c0           xor eax, eax\n            0x55c79226b858      488d45f4       lea rax, [rbp - 0xc]\n            0x55c79226b85c      4889c6         mov rsi, rax\n            0x55c79226b85f      488d3dee0100.  lea rdi, [0x55c79226ba54] ; \"%d\"\n            0x55c79226b866      b800000000     mov eax, 0\n            0x55c79226b86b      e880feffff     call sym.imp.scanf\n            0x55c79226b870      8b45f4         mov eax, dword [rbp - 0xc]\n            0x55c79226b873      83f80a         cmp eax, 0xa            ; 10\n        ┌─&lt; 0x55c79226b876      7e0e           jle 0x55c79226b886\n        │   0x55c79226b878      488d3dd80100.  lea rdi, str.greater    ; 0x55c79226ba57 ; \"greater\"\n        │   0x55c79226b87f      e88cfeffff     call sym.imp.puts\n       ┌──&lt; 0x55c79226b884      eb0c           jmp 0x55c79226b892\n       │└─&gt; 0x55c79226b886      488d3dd20100.  lea rdi, str.less       ; 0x55c79226ba5f ; \"less\"\n[0x55c79226b83a]&gt; dcu 0x55c79226b876\nContinue until 0x55c79226b876 using 1 bpsize\n7\nhit breakpoint at: 0x55c79226b876\n[0x55c79226b876]&gt; dr eflags\n0x00000293\n[0x55c79226b876]&gt; dr eflags=0x213\n0x00000293 -&gt;0x00000213\n[0x55c79226b876]&gt; dc\ngreater\n(17193) Process exited with status=0x0\n</code></pre>\n<p>Here eflags was updated from 0x00000293 to 0x00000213 since</p>\n<pre><code>0x293&amp;~(1&lt;&lt;7) = 0x213 \n</code></pre>\n<p>The input was 7 but the output was \"Greater\" since <code>dr eflags=0x213</code> unset SF</p>\n<p>Similarly in the other direction, to set SF</p>\n<pre><code>eflags |= (1 &lt;&lt; 7)\n</code></pre>\n<p>For larger input it can be used to go to the smaller branch</p>\n<pre><code>[re] r2 -d test\nProcess with PID 23724 started...\n= attach 23724 23724\nbin.baddr 0x562ccba44000\nUsing 0x562ccba44000\nasm.bits 64\n[0x7f568eeaa090]&gt; dcu sym.main\nContinue until 0x562ccba4483a using 1 bpsize\nhit breakpoint at: 0x562ccba4483a\n[0x562ccba4483a]&gt; pd20\n            ;-- main:\n            ;-- rax:\n            ;-- rip:\n            0x562ccba4483a      55             push rbp\n            0x562ccba4483b      4889e5         mov rbp, rsp\n            0x562ccba4483e      4883ec20       sub rsp, 0x20\n            0x562ccba44842      897dec         mov dword [rbp - 0x14], edi\n            0x562ccba44845      488975e0       mov qword [rbp - 0x20], rsi\n            0x562ccba44849      64488b042528.  mov rax, qword fs:[0x28]\n            0x562ccba44852      488945f8       mov qword [rbp - 8], rax\n            0x562ccba44856      31c0           xor eax, eax\n            0x562ccba44858      488d45f4       lea rax, [rbp - 0xc]\n            0x562ccba4485c      4889c6         mov rsi, rax\n            0x562ccba4485f      488d3dee0100.  lea rdi, [0x562ccba44a54] ; \"%d\"\n            0x562ccba44866      b800000000     mov eax, 0\n            0x562ccba4486b      e880feffff     call sym.imp.scanf\n            0x562ccba44870      8b45f4         mov eax, dword [rbp - 0xc]\n            0x562ccba44873      83f80a         cmp eax, 0xa            ; 10\n        ┌─&lt; 0x562ccba44876      7e0e           jle 0x562ccba44886\n        │   0x562ccba44878      488d3dd80100.  lea rdi, str.greater    ; 0x562ccba44a57 ; \"greater\"\n        │   0x562ccba4487f      e88cfeffff     call sym.imp.puts\n       ┌──&lt; 0x562ccba44884      eb0c           jmp 0x562ccba44892\n       │└─&gt; 0x562ccba44886      488d3dd20100.  lea rdi, str.less       ; 0x562ccba44a5f ; \"less\"\n[0x562ccba4483a]&gt; dcu 0x562ccba44876\nContinue until 0x562ccba44876 using 1 bpsize\n100\nhit breakpoint at: 0x562ccba44876\n[0x562ccba44876]&gt; dr eflags\n0x00000216\n[0x562ccba44876]&gt; \"?vx eflags|(1 &lt;&lt; 7)\"\n0x00000296\n[0x562ccba44876]&gt; dr eflags=0x296\n0x00000216 -&gt;0x00000296\n[0x562ccba44876]&gt; dc\nless\n(23724) Process exited with status=0x0\n</code></pre>\n<p>Additionally looking at your disassembly's annotations it seems like you are analyzing the main function of the binary. Here we copy <code>argc</code> from edi to <code>local_184h</code></p>\n<pre><code>|           0x55b3fd508a4b      89bd7cfeffff   mov dword [local_184h], edi       ; argc\n</code></pre>\n<p>So if you start you binary with at least 1 argument it should work. Something like</p>\n<pre><code>$ r2 -d binary arg1 \n</code></pre>\n<p>should work</p>\n</div>",
            "votes": "2",
            "user": "sudhackar",
            "time": "Nov 18, 2020 at 13:52",
            "is_accepted": false,
            "comments": []
        }
    ]
}