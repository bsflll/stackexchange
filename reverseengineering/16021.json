{
    "title": "What compression algorithm is this?",
    "link": "https://reverseengineering.stackexchange.com/questions/16021/what-compression-algorithm-is-this",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I've reversed the following decompression algorithm from a game. It appears to be some variant of <a href=\"https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77\" rel=\"noreferrer\">LZ77</a>, however none of the descriptions of variants seem quite close enough what I've got. Is this a specific flavor of LZ77, and if not, how would I go about creating an equivalent compression method? The files have no header.</p>\n<pre><code>unsigned int decompress(uint8_t *decompressed, uint8_t *compressed)\n{\n    uint32_t distance, length, i, j;\n    uint8_t temp, *compressed_ptr = compressed,\n        *decompressed_ptr = decompressed, *backwards_ptr = NULL;\n\n    while (1)\n    {\n        temp = *(compressed_ptr++);\n        length = (temp &amp; 7) + 1;\n        distance = temp &gt;&gt; 3;\n\n        if (distance == 0x1E)\n            distance = *(compressed_ptr++) + 0x1E;\n        else if (distance &gt; 0x1E)\n        {\n            distance += *compressed_ptr;\n            distance += (*(++compressed_ptr) &lt;&lt; 8) + 0xFF;\n            compressed_ptr++;\n            if (distance == 0x1011D)\n                length--;\n        }\n\n        if (distance != 0)\n        {\n            memcpy(decompressed_ptr, compressed_ptr, distance);\n            decompressed_ptr += distance;\n            compressed_ptr += distance;\n        }\n\n        for (i = length; i &gt; 0; i--)\n        {\n            temp = *(compressed_ptr++);\n            length = temp &amp; 7;\n            distance = temp &gt;&gt; 3;\n\n            if (length == 0)\n            {\n                length = *(compressed_ptr++);\n                if (length == 0)\n                {\n                    return (uintptr_t)decompressed_ptr -\n                        (uintptr_t)decompressed;\n                }\n                length += 7;\n            }\n\n            if (distance == 0x1E)\n                distance = *(compressed_ptr++) + 0x1E;\n            else if (distance &gt; 0x1E)\n            {\n                distance += *compressed_ptr;\n                distance += (*(++compressed_ptr) &lt;&lt; 8) + 0xFF;\n                compressed_ptr++;\n            }\n\n            backwards_ptr = decompressed_ptr - distance - 1;\n            for (j = length; j &gt; 0; j--)\n                *(decompressed_ptr++) = *(backwards_ptr++);\n        }\n    }\n}\n</code></pre>\n</div>",
    "votes": "8",
    "answers": 2,
    "views": "1k",
    "tags": [
        "decompress"
    ],
    "user": "kirby",
    "time": "Aug 6, 2017 at 17:22",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>As you say it is an LZ77 style format, however I could not find a specific algorithm which it matches.  The compressed data forms a number of blocks, each of which contain at least one of some data, or some back references.</p>\n<h1>Format</h1>\n<p>Based on the code I've put together a listing of the data structure of the compressed data.</p>\n<h2>Block</h2>\n<p>The format of each block is as follows:</p>\n<pre><code>Section                | Length\n-----------------------|-------\nHeader                 | 1 to 3 Bytes (see header explanation)\nData                   | 0 to 0x1011D (65821) Bytes\nBack references        | 0 to 8 occurences of 1 to 4 Bytes (see back reference explanation)\n</code></pre>\n<h2>Header</h2>\n<p>The header is as follows:</p>\n<pre><code>Section                | Length\n-----------------------|-------\nNum Back References    | 3 bits\nData Length            | 5 bits\nAdditional Data Length | 0 to 2 Bytes\n</code></pre>\n<p>The number of back references is encoded into the first 3 bits as a 1 indexed number, allowing a number from 1 (<code>0b000</code>) to 8 (<code>0b111</code>).\nIn the case that more than 8 back references are required a data length of 0 can be set so you can have several consecutive blocks containing only back references.</p>\n<p>The data length is encoded into the next 5 bits.\nIf the data length is less than <code>0x1E</code> (30) then it is encoded directly into the top 5 bits of the header.\nIf it is between <code>0x1E</code> and <code>0x11E</code> (286) then a single additional byte will be used, this byte should be the length of the data - <code>0x11E</code>.\nIf it is between <code>0x11E</code> and <code>0x1011D</code> (65821) then two additional bytes are used as a 16 bit number, which should be the length of the data - <code>0x11E</code>.</p>\n<p>If the data length is the maximum possible (<code>0x1011D</code>) then the number of back references is reduced by one, allowing 0 back references.  This allows consecutive data sections without back references.</p>\n<h2>Back reference</h2>\n<p>The format of the back references is similar to that of the header:</p>\n<pre><code>Section                | Length\n-----------------------|-------\nData Length            | 3 bits\nData Distance          | 5 bits\nAdditional Data Length | 0 to 1 Byte\nAdditional Distance    | 0 to 2 Bytes\n</code></pre>\n<p>The length of data (in bytes) to which the reference refers is encoded into the first 3 bits, allowing length of 0 - 7.\nIf the length is greater than 7 then these 3 bits are set to 0 and an additional byte is added, containing the length - 7, this allows lengths of up to 262 bytes.</p>\n<p>The distance represents the position of the back reference, in bytes back from the current end of the decompressed data.  The distance and additional distance bytes are calculated in the same way as the Data Length in the header.</p>\n<p>When set, each back reference will copy the calculated data length in bytes from <code>current_position - distance - 1</code> to the output stream.</p>\n<p>There is a special case of a back reference with the length and additional length set to 0.  This signifies the end of the stream, and the decompressor will return.</p>\n<h1>Reasoning</h1>\n<p>The overall format of a block is reasonably evident from the code, however didn't really make sense until I'd worked out the reasoning behind the magic numbers.</p>\n<p>The interesting thing here was the special case of <code>distance = 0x1011D</code>.\nTo get to the branch which checks for that distance the distance from the intial <code>distance = temp &gt;&gt; 3;</code> must be greater than <code>0x1E</code>, so it must be <code>0x1F</code>, as no other value above <code>0x1E</code> would fit in the top 5 bits of <code>temp</code>.\nWith this information we can calculate the necessary values of the next 2 bytes (<code>a</code>, and <code>b</code>):</p>\n<pre><code>0x1011D = 0x1F + a + (b &lt;&lt; 8) + 0xFF\n0x1001E = 0x1F + a + (b &lt;&lt; 8)\n0x0FFFF = a + (b &lt;&lt; 8)\n</code></pre>\n<p>As <code>a</code> and <code>b</code> are 8 bit numbers they must necessarily both be <code>0xFF</code>.\nThus <code>0x1011D</code> is the largest possible value for <code>distance</code> at that point.</p>\n<p>The reasoning for the <code>length--</code> associated with the conditional becomes apparent: This allows for raw data blocks with no back references, for use in cases such as images or other poorly compressible data.</p>\n<p>Other than this, the range of numbers that the Data Length supports can be easily calculated by considering the result of setting <code>temp</code> to <code>0b11111???</code> and <code>0b11110???</code> and checking the maximum and minimum values of the following two bytes.</p>\n<p>Having understood the block header format the back reference format is fairly easy to understand, the main gotcha being that <code>length = 0</code> with a following byte of <code>0</code> ends the stream.</p>\n<h1>Writing a counterpart compression algorithm</h1>\n<p>If you do not need the files to fit in the same space as the original files then the easiest way to \"compress\" your own files is to ignore the actual compression features of the format, and do the bare minimum of creating maximum size data blocks until the final block, which will have a single back reference, that being the end of stream signal.  A quick implementation of this follows.</p>\n<pre><code>#include &lt;cstring&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;deque&gt;\n#include &lt;fstream&gt;\n#include &lt;iterator&gt;\n\nunsigned int decompress(uint8_t *decompressed, uint8_t *compressed)\n{\n    uint32_t distance, length, i, j;\n    uint8_t temp, *compressed_ptr = compressed,\n            *decompressed_ptr = decompressed, *backwards_ptr = NULL;\n\n    while (1)\n    {\n        temp = *(compressed_ptr++);\n        length = (temp &amp; 7) + 1;\n        distance = temp &gt;&gt; 3;\n\n        if (distance == 0x1E)\n            distance = *(compressed_ptr++) + 0x1E;\n        else if (distance &gt; 0x1E)\n        {\n            distance += *compressed_ptr;\n            distance += (*(++compressed_ptr) &lt;&lt; 8) + 0xFF;\n            compressed_ptr++;\n            if (distance == 0x1011D)\n                length--;\n        }\n\n        if (distance != 0)\n        {\n            std::memcpy(decompressed_ptr, compressed_ptr, distance);\n            decompressed_ptr += distance;\n            compressed_ptr += distance;\n        }\n\n        for (i = length; i &gt; 0; i--)\n        {\n            temp = *(compressed_ptr++);\n            length = temp &amp; 7;\n            distance = temp &gt;&gt; 3;\n\n            if (length == 0)\n            {\n                length = *(compressed_ptr++);\n                if (length == 0)\n                {\n                    return (uintptr_t)decompressed_ptr -\n                        (uintptr_t)decompressed;\n                }\n                length += 7;\n            }\n\n            if (distance == 0x1E)\n                distance = *(compressed_ptr++) + 0x1E;\n            else if (distance &gt; 0x1E)\n            {\n                distance += *compressed_ptr;\n                distance += (*(++compressed_ptr) &lt;&lt; 8) + 0xFF;\n                compressed_ptr++;\n            }\n\n            backwards_ptr = decompressed_ptr - distance - 1;\n            for (j = length; j &gt; 0; j--)\n                *(decompressed_ptr++) = *(backwards_ptr++);\n        }\n    }\n}\n\nstd::vector&lt;uint8_t&gt; compress(const std::vector&lt;uint8_t&gt;&amp; input)\n{\n    const uint32_t max_distance = 0x1011D;\n    std::vector&lt;uint8_t&gt; output;\n\n    auto input_it = input.begin();\n\n    // Repeat as many max length blocks as we can\n    auto remaining_input = std::distance(input_it, input.end());\n    while(remaining_input &gt; max_distance)\n    {\n        output.push_back(0xF8);\n        output.push_back(0xFF);\n        output.push_back(0xFF);\n        std::copy(input_it, input_it + max_distance, std::back_inserter(output));\n        input_it += max_distance;\n\n        remaining_input = std::distance(input_it, input.end());\n    }\n\n    // Add a final block with the remaining data\n    if(remaining_input &gt; 0x11D)\n    {\n        output.push_back(0xF8);\n        const uint16_t header_bytes = remaining_input - 0x11E;\n        output.push_back(header_bytes &amp; 0xFF);\n        output.push_back(header_bytes &gt;&gt; 8);\n        std::copy(input_it, input.end(), std::back_inserter(output));\n    }\n    else if(remaining_input &gt; 0x1D)\n    {\n        output.push_back(0xF0);\n        const uint8_t header_byte = remaining_input - 0x1E;\n        output.push_back(header_byte);\n        std::copy(input_it, input.end(), std::back_inserter(output));\n    }\n    else\n    {\n        const uint8_t header_byte = remaining_input &lt;&lt; 3;\n        output.push_back(header_byte);\n        std::copy(input_it, input.end(), std::back_inserter(output));\n    }\n\n    // Add a special case 0 length back reference to end the stream\n    output.push_back(0x00);\n    output.push_back(0x00);\n\n    return output;\n}\n\nint main(int argc, char* argv[])\n{\n    std::deque&lt;std::string&gt; args(argv, argv+argc);\n    args.pop_front();\n\n    if(args.empty())\n    {\n        std::cerr &lt;&lt; \"No input files!\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    for(const auto&amp; filename : args)\n    {\n        std::ifstream in_file(filename, std::ios::in | std::ios::binary);\n        if(!in_file.good())\n        {\n            std::cerr &lt;&lt; \"Bad input file: \" &lt;&lt; filename &lt;&lt; std::endl;\n            return 1;\n        }\n\n        std::cout &lt;&lt; \"Compressing \" &lt;&lt; filename &lt;&lt; std::endl;\n\n        std::vector&lt;uint8_t&gt; input(\n            (std::istreambuf_iterator&lt;char&gt;(in_file)),\n            (std::istreambuf_iterator&lt;char&gt;())\n        );\n\n        auto compressed = compress(input);\n        std::cout &lt;&lt; \"Compressed from \" &lt;&lt; input.size() &lt;&lt; \" to \" &lt;&lt; compressed.size() &lt;&lt; std::endl;\n\n        const std::string new_filename = filename + \".compres\";\n        std::ofstream out_file(new_filename);\n        out_file.write((char*)compressed.data(), compressed.size());\n        out_file.close();\n        std::cout &lt;&lt; \"Saved as \" &lt;&lt; new_filename &lt;&lt; std::endl;\n\n        const int buffer_length = 2000000;\n        uint8_t buffer[buffer_length];\n\n        const int size = decompress(buffer, compressed.data());\n\n        std::vector&lt;uint8_t&gt; regenerated;\n        regenerated.assign(buffer, buffer + size);\n\n        if(regenerated == input)\n            std::cout &lt;&lt; \"Regenerated file matches original.\" &lt;&lt; std::endl;\n        else\n            std::cout &lt;&lt; \"Regenerated file DOES NOT MATCH original!\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>Compile: <code>clang++ --std=c++14 -o fake_compress fake_compress.cpp</code></p>\n<p>And run:</p>\n<pre><code>$ ./fake_compress havok.xml\nCompressing havok.xml\nCompressed from 137261 to 137272\nSaved as havok.xml.compres\nRegenerated file matches original.\n</code></pre>\n</div>",
            "votes": "8",
            "user": "zed0",
            "time": "Aug 8, 2017 at 23:39",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Most general purpose LZ77-like formats are optimized for efficient  insertion of individual literal characters, and for the arbitrary sequence of literals and backward references - this is useful to achieve good compression rates on  natural language text as well on text-like binary data (executable code). They also have a notion of a sliding dictionary window to handle files or streams of arbitrary sizes.</p>\n<p>The routine in your question appears to handle a format adapted specifically for in-memory data (note the absence of a sliding window) with many (up to 8 in a row) consecutive references to the decompressed buffer, interspersed with occasional long strings that have to be copied literally. </p>\n<p>Note that there are only two ways to add characters to the decompressed stream: by literal copying using a memcpy call, and by copying in a loop using the backwards pointer. In other words, these two modes of operation are \"copying a (fairly long) dictionary from the compressed stream\", and \"reading references to the dictionary from the compressed stream and copying strings from the dictionary\". There is no special provision for individual literal characters.</p>\n<p>Any straightforward implementation of an LZ77 compression algorithm (a function of a character string into a stream of tokens \"literal character\" or \"distance/length\") would do. Then you'll be able to write a program to pack these tokens according to the limitation of the format (pay attention to the magic value 0x1011D). </p>\n<p>Alternatively, as you're unlikely to be limited by the media size, you may avoid the need to do any actual compression (the analog of compression level 0). For your purposes, it could be enough to represent all the data as a sequence of long literals, using the \"distance\" field for the length of literal string and setting the \"length\" field to 0 to indicate that there are no dictionary references following the literal string. Repeat until the data is exhausted.</p>\n</div>",
            "votes": "2",
            "user": "Leo B.",
            "time": "Aug 8, 2017 at 9:21",
            "is_accepted": false,
            "comments": []
        }
    ]
}