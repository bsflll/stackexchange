{
    "title": "How do I perform concolic execution with Angr and collect constraints on input?",
    "link": "https://reverseengineering.stackexchange.com/questions/19330/how-do-i-perform-concolic-execution-with-angr-and-collect-constraints-on-input",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have a program that takes a string (with some structure) as input. My aim is to collect information on what values each character in input is compared to as it gets parsed using <em>concolic execution</em>. What is the right way to go about it?</p>\n<p>My subject is a <a href=\"https://github.com/vrthra/expr-tdr\" rel=\"noreferrer\">simple recursive descent parser for expressions</a> and it accepts inputs of the form <code>1+(2*3)</code> etc.</p>\n<p>What I have tried so far:</p>\n<h3>Wrote a program that constructs an initial state with string arguments, executed it through stepping one at a time, and at the end, collect constraints.</h3>\n<pre><code>import sys\nimport angr\n\nclass Program:\n    def __init__(self, exe):\n        self.exe = exe\n        self.project = angr.Project(exe, load_options={'auto_load_libs': False})\n\n    def set_input(self, arg):\n        self.arg1 = arg\n\n        self.initial_state = self.project.factory.entry_state(\n                args=[self.exe, self.arg1],\n                # does not seem to startup the unicorn engine\n                add_options=angr.options.unicorn,\n                )\n\n    def run(self):\n        state = self.initial_state\n        while True:\n            succ = state.step()\n            if len(succ.successors) &gt; 1:\n                raise Exception('more successors %d' % len(succ.successors))\n            if not succ.successors: return state\n            state, = succ.successors\n\ndef main(exe, arg):\n    prog = Program(exe)\n    prog.set_input(arg)\n    res = prog.run()\n    print(\"constraints: %d\" % len(res.solver.constraints))\n    for i in res.solver.constraints:\n        print(i)\n    print('done')\n\nif __name__ == '__main__':\n    assert len(sys.argv) &gt;= 3\n    main(sys.argv[1], sys.argv[2])\n</code></pre>\n<p>When I execute this, I get zero constraints.</p>\n<h3>Using constrained symbolic arguments</h3>\n<p>I got the idea that I should make the arguments symbolic, and add constraints to each characters in the input, using state.add_constraints, and look for the constraints produced at the end.</p>\n<pre><code>import sys\nimport angr\nimport claripy\n\nclass Program:\n    ARG_PREFIX = 'sym_arg'\n    def __init__(self, exe):\n        self.exe = exe\n        self.project = angr.Project(exe, load_options={'auto_load_libs': False})\n\n    def set_input(self, arg):\n        # generate arg1 from individual characters.\n        self.arg1 = self.make_symbolic_char_args(arg)\n\n        self.initial_state = self.project.factory.entry_state(\n                args=[self.exe, self.arg1],\n                add_options=angr.options.unicorn,\n                # does not seem to affect the number of constraints created\n                # remove_options=angr.options.simplification\n                )\n        self.constrain_input_chars(self.initial_state, self.arg1a, arg)\n        self.string_terminate(self.initial_state, self.arg1a, arg)\n\n    def string_terminate(self, state, symarg, inarg):\n        state.add_constraints(symarg[len(inarg)] == 0)\n\n    def constrain_input_chars(self, state, symarg, sarg):\n        constraints = []\n        for i,a in enumerate(sarg):\n            state.add_constraints(symarg[i] == a)\n\n    def run(self):\n        state = self.initial_state\n        while True:\n            succ = state.step()\n            if len(succ.successors) &gt; 1:\n                raise Exception('more successors %d' % len(succ.successors))\n            if not succ.successors: return state\n            state, = succ.successors\n\n    def make_symbolic_char_args(self, instr, symbolic=True):\n        if not symbolic: return instr\n        input_len = len(instr)\n        largs = range(0, input_len+1)\n        arg1k = ['%s_%d' % (Program.ARG_PREFIX, i) for i in largs]\n        self.arg1h = {k:claripy.BVS(k, 8) for k in arg1k}\n        self.arg1a = [self.arg1h[k] for k in arg1k]\n        return reduce(lambda x,y: x.concat(y), self.arg1a)\n\n\ndef main(exe, arg):\n    prog = Program(exe)\n    prog.set_input(arg)\n    res = prog.run()\n    print(\"constraints: %d\" % len(res.solver.constraints))\n    for i in res.solver.constraints:\n        print(i)\n    print('done')\n\nif __name__ == '__main__':\n    assert len(sys.argv) &gt;= 3\n    main(sys.argv[1], sys.argv[2])\n</code></pre>\n<p>While this results in a large number of constraints at the end, I am at a loss how to interpret these constraints to what I want -- comparisons to input characters. The constraints are fairly complex, but there are lots duplicated portions in each item. Any advice on translating these constraints that look like below to actual character comparisons would be greatly appreciated.</p>\n<pre><code>...\n&lt;Bool (((if (sym_arg_0_0_8 == 0) then 0x0 else (if (sym_arg_1_1_8 == 0) then 0x1 else (if (sym_arg_2_2_8 == 0) then 0x2 else (if (sym_arg_3_3_8 == 0) then 0x3 else 0x4)))) + 0x7fffffffffeffd4) - 0x7fffffffffeffd4) == strlen_5_64&gt;\n&lt;Bool 0x1 &lt;= strlen_5_64&gt;\n&lt;Bool ((0#56 .. 0#7 .. __invert__((if ((sym_arg_0_0_8 == 40) &amp;&amp; (sym_arg_0_0_8[7:7] == 0)) then 1 else 0))) &amp; 0xff) != 0x0&gt;\n&lt;Bool (((if (sym_arg_0_0_8 == 0) then 0x0 else (if (sym_arg_1_1_8 == 0) then 0x1 else (if (sym_arg_2_2_8 == 0) then 0x2 else (if (sym_arg_3_3_8 == 0) then 0x3 else 0x4)))) + 0x7fffffffffeffd4) - 0x7fffffffffeffd4) == strlen_6_64&gt;\n&lt;Bool 0x1 &lt;= strlen_6_64&gt;\n&lt;Bool ((0#56 .. 0#7 .. (if ((sym_arg_0_0_8 == 49) &amp;&amp; (sym_arg_0_0_8[7:7] == 0)) then 1 else 0)) &amp; 0xff) != 0x0&gt;\n&lt;Bool (((if (sym_arg_0_0_8 == 0) then 0x0 else (if (sym_arg_1_1_8 == 0) then 0x1 else (if (sym_arg_2_2_8 == 0) then 0x2 else (if (sym_arg_3_3_8 == 0) then 0x3 else 0x4)))) + 0x7fffffffffeffd4) - 0x7fffffffffeffd4) == strlen_7_64&gt;\n&lt;Bool 0x2 &lt;= strlen_7_64&gt;\n&lt;Bool ((0#56 .. 0#7 .. (if ((sym_arg_1_1_8 == 49) &amp;&amp; (sym_arg_1_1_8[7:7] == 0)) then 1 else 0)) &amp; 0xff) == 0x0&gt;\n&lt;Bool (((if (sym_arg_0_0_8 == 0) then 0x0 else (if (sym_arg_1_1_8 == 0) then 0x1 else (if (sym_arg_2_2_8 == 0) then 0x2 else (if (sym_arg_3_3_8 == 0) then 0x3 else 0x4)))) + 0x7fffffffffeffd4) - 0x7fffffffffeffd4) == strlen_8_64&gt;\n&lt;Bool 0x2 &lt;= strlen_8_64&gt;\n...\n</code></pre>\n\nProblem: too slow\n\n<p>The above approach also takes too long to execute even for inputs a few characters long. I tried executing the above on <a href=\"https://github.com/vrthra/expr-tdr\" rel=\"noreferrer\">simple recursive descent parser for expressions</a> with input of a few characters: (<code>1+4/1+4/(1+4)</code>). It took more than 30 minutes to parse!, while the running the parser directly comes out in less than a second. I would be OK with that time if there was no other way out, but this being concolic, I cant shake the feeling that there must be a better way.</p>\n<h3>Using unconstrained symbolic arguments, but exploring my own</h3>\n<p>The idea is that I start with the input constraints such that each symbolic character equal to corresponding input. Then I provide my own path of execution such that only the paths that satisfy the input constraints are chosen for further execution. My idea was that since I do not start the original character constraints in the initial state, I can inspect the final state to determine other constraints that accumulated on each character.</p>\n<pre><code>import claripy\nimport sys\nimport angr\n\nclass Program:\n    ARG_PREFIX = 'sym_arg'\n    def __init__(self, exe):\n        self.exe = exe\n        self.project = angr.Project(exe, load_options={'auto_load_libs': False})\n\n    def set_input(self, arg):\n        # generate arg1 from individual characters.\n        self.arg1 = self.make_symbolic_char_args(arg)\n        self._constraints = []\n        self.constrain_input_chars(self.arg1a, arg)\n        self.string_terminate(self.arg1a, arg)\n        self.constraints = claripy.And(*self._constraints)\n        self.initial_state = self.project.factory.entry_state(\n                args=[self.exe, self.arg1],\n                add_options=angr.options.unicorn,\n                )\n\n    def string_terminate(self, symarg, inarg):\n        self._constraints.append(symarg[len(inarg)] == 0)\n\n    def constrain_input_chars(self, symarg, sarg):\n        for i,a in enumerate(sarg):\n            self._constraints.append(symarg[i] == a)\n\n    def get_satisfying_state(self, state):\n        succ = state.step()\n        if not succ.successors: return None\n        result = [i.satisfiable(extra_constraints=(self.constraints,)) for i in succ.successors]\n        assert len(result) == 1\n        return result[0]\n\n    def run(self):\n        state = self.initial_state\n        while True:\n            newstate = self.get_satisfying_state(state)\n            if not newstate: return state\n\n    def make_symbolic_char_args(self, instr, symbolic=True):\n        if not symbolic: return instr\n        input_len = len(instr)\n        largs = range(0, input_len+1)\n        arg1k = ['%s_%d' % (Program.ARG_PREFIX, i) for i in largs]\n        self.arg1h = {k:claripy.BVS(k, 8) for k in arg1k}\n        self.arg1a = [self.arg1h[k] for k in arg1k]\n        return reduce(lambda x,y: x.concat(y), self.arg1a)\n\ndef main(exe, arg):\n    prog = Program(exe)\n    prog.set_input(arg)\n    res = prog.run()\n    print(\"constraints: %d\" % len(res.solver.constraints))\n    for i in res.solver.constraints:\n        print(i)\n    print('done')\n\nif __name__ == '__main__':\n    assert len(sys.argv) &gt;= 3\n    main(sys.argv[1], sys.argv[2])\n</code></pre>\n<p>This again did not work, as it takes extremely long time to parse even a few characters.</p>\n\nOther options I have considered\n\n<ul>\n<li>Writing a memory hook that monitors when the input string memory is read from.\nBut this wont work for me because the characters may be copied before compared.</li>\n</ul>\n<p>I have read the <a href=\"https://docs.angr.io/\" rel=\"noreferrer\">angr docs</a> multiple times now and can't figure out what to do. I cant shake the feeling that it should be simpler as <em>angr</em> is a <em>symbolic execution engine</em> that supports <em>concolic execution</em>, and what I am doing is pretty much plain vanila <em>concolic execution</em>. What can I do next?</p>\n<p>Any help would be greatly appreciated!.</p>\n</div>",
    "votes": "5",
    "answers": 0,
    "views": "1k",
    "tags": [
        "binary-analysis",
        "python",
        "dynamic-analysis",
        "angr"
    ],
    "user": "Rahul Gopinath",
    "time": "Sep 13, 2018 at 13:01",
    "comments": [
        {
            "user": "YaFeng  Luo",
            "text": "<span class=\"comment-copy\">I also need a similar function. Triton may be a better choice for this regard. If you have got any solution?</span>",
            "time": null
        }
    ],
    "answers_data": []
}