{
    "title": "Behringer CRC8 algorithm",
    "link": "https://reverseengineering.stackexchange.com/questions/23099/behringer-crc8-algorithm",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The Behringer DEQ2496 audio device can have commands sent to it via MIDI, however they require a valid CRC code in order for the device to accept them.</p>\n<p>I have thus far been unable to work out how the CRC code is calculated.  The manual suggests it is CRC8 however I have not been able to configure a CRC8 algorithm to produce matching values.</p>\n<p>Here is some sample data, including valid CRC codes:</p>\n<ul>\n<li><a href=\"http://files.shikadi.net/malv/files/stackexchange/block-40.bin\" rel=\"nofollow noreferrer\">Block 0x0040</a></li>\n<li><a href=\"http://files.shikadi.net/malv/files/stackexchange/block-41.bin\" rel=\"nofollow noreferrer\">Block 0x0041</a></li>\n<li><a href=\"http://files.shikadi.net/malv/files/stackexchange/block-41.bin\" rel=\"nofollow noreferrer\">Block 0x0042</a></li>\n<li><a href=\"http://files.shikadi.net/malv/files/stackexchange/block-42.bin\" rel=\"nofollow noreferrer\">Block 0x0043</a></li>\n<li><a href=\"http://files.shikadi.net/malv/files/stackexchange/block-43.bin\" rel=\"nofollow noreferrer\">Block 0x0043</a></li>\n<li><a href=\"http://files.shikadi.net/malv/files/stackexchange/block-ff00.bin\" rel=\"nofollow noreferrer\">Block 0xFF00</a></li>\n</ul>\n<p>The DEQ2496 SysEx manual says of the layout of each of the above files:</p>\n<blockquote>\n<p><strong>blockdata</strong>: 7/8 coded: blockno_h, blockno_l, crc, data[256].</p>\n<p><strong>crc</strong>: crc8 checksum of blockno_h, blockno_l, data[256]</p>\n<p><strong>blockno</strong>: transferred 256 byte data block number (bits 21..15, 14..8 of flash offset); blocks 0-0x1f: boot loader; blocks 0x20..0x5ef: application; blocks 0x5f0-0x5ff: startup screen; blocks 0x600-0x67f: presets; blocks 0x680-0x69f: temporary buffers; blocks 0x6a0-0x7ff: hw configuration; block no 0xff00 shows text message data[0..52] on screen</p>\n<p><strong>data</strong>: data block</p>\n</blockquote>\n<p>I have taken care of the 7/8 coding, so now I have a block of 3+256 bytes, consisting of:</p>\n<ul>\n<li>Offset 0: 16-bit big endian integer, block number</li>\n<li>Offset 2: 8-bit integer, CRC (this is the value I am trying to calculate)</li>\n<li>Offset 3+: Actual data</li>\n</ul>\n<p>I've tried a couple of CRC algorithms (with and without a lookup table), written code to run through all possible 8-bit polynomials, initial and final XOR values, and yet I can't find any parameters that work for more than one block.</p>\n<p>Although the manual suggests the CRC byte itself is not included in the CRC calculation, I also tried leaving it in place and setting it to various values like <code>0x00</code> and <code>0xFF</code> however this didn't yield any results either.</p>\n<p>Is there anyone with more CRC knowledge than me who is able to figure out what they mean here by \"crc8 checksum\"?</p>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "217",
    "tags": [
        "crc"
    ],
    "user": "Malvineous",
    "time": "Jun 17, 2020 at 9:54",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Well thanks to @IgorSkochinsky who suggested in another question of mine to try a disassembler, I found a <a href=\"https://hub.docker.com/r/pf0camino/cross-bfin-elf\" rel=\"nofollow noreferrer\">Docker image that contained a Blackfin toolchain</a> which allowed me to use <code>objdump</code> to disassemble the code:</p>\n<pre><code>bfin-elf-objdump -D -b binary -mbfin bootloader.bin &gt; bootloader.disasm\n</code></pre>\n<p>After hastily consulting a manual on Blackfin assembler and poking around a bit, I was able to get a vague idea of what was going on, and I was able to find the CRC function, which turned out not to be a CRC function at all, but a DIY checksum.</p>\n<p>Using the disassembly as a reference, I was able to replicate the algorithm in my Javascript code:</p>\n<pre><code>function behringer_crc8(data) {\n    let crc = 0;\n    for (let b of data) {\n        for (let j = 0; j &lt; 8; j++) {\n            if (!((b ^ crc) &amp; 1)) crc ^= 0x19;\n            b &gt;&gt;= 1;\n            // Rotate (shift right, move lost LSB to new MSB)\n            crc = ((crc &amp; 1) &lt;&lt; 7) | (crc &gt;&gt; 1);\n        }\n    }\n    return crc ^ 0xbf;\n}\n</code></pre>\n<p>Comparing this code against the distributed firmware update shows that it is able to reproduce the CRC bytes correctly!</p>\n<p>It also turned out that despite the manual saying the two-byte block number prefix was included in the checksum, it turned out it wasn't, and only the 256-byte content is checksummed.</p>\n</div>",
            "votes": "3",
            "user": "Malvineous",
            "time": "Jan 26, 2020 at 9:57",
            "is_accepted": true,
            "comments": []
        }
    ]
}