{
    "title": "Force gcc to use more complex instructions",
    "link": "https://reverseengineering.stackexchange.com/questions/24980/force-gcc-to-use-more-complex-instructions",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am reverse engineering a piece of assembly. I am trying to write the equivalent code in C, however, when I compile my code, gcc prefers to use simple instructions instead of the complex ones that are used in my assembly. I was wondering if I can suggest or force gcc to use more complex instructions.</p>\n<p><strong>EDIT:</strong> I have already tried using the <code>-O</code> options but they will change lots of other variables and therefore, don't look like a good solution.</p>\n<p>You can find examples here:</p>\n<pre><code>// original assembly\nlea     rdx, [rax+0x20]\n\n// generated by gcc\nadd     rax, 0x20\nmov     rdx, rax\n\n// C code\n0x20+((uint8_t *)lParm1)  // long lParm1\n</code></pre>\n<pre><code>// original assembly\ntest    eax, eax\n\n// generated by gcc\nmov     [rbp-0x10], eax\ncmp     [rbp-0x10], 0x0\n\n// C code\nif (!iVar)  // int iVar\n</code></pre>\n<pre><code>// original assembly\nmov     eax, [rax+0x40]\n\n// generated by gcc\nadd     rax, 0x40\nmov     eax, [rax]\n\n// C code\n(float)*(int *)(lParm1 + 0x40)\n</code></pre>\n</div>",
    "votes": "0",
    "answers": 0,
    "views": "204",
    "tags": [
        "assembly",
        "decompilation",
        "gcc"
    ],
    "user": "Bat",
    "time": "May 11, 2020 at 14:07",
    "comments": [
        {
            "user": "sbluff",
            "text": "<span class=\"comment-copy\">can you please share the c code that generates that set of instructions?</span>",
            "time": null
        },
        {
            "user": "Robert",
            "text": "<span class=\"comment-copy\">Often the original code smaller (is only one command vs. two). Therefore you may try to enable optimization for code size via <code>-Os</code> parameter.</span>",
            "time": null
        },
        {
            "user": "Bat",
            "text": "<span class=\"comment-copy\">I have already tried that. The thing is that it more or less achieves what I want but then changes lots of other variables. Therefore, doesn't seem like a good option</span>",
            "time": null
        },
        {
            "user": "Robert",
            "text": "<span class=\"comment-copy\">Please edit your question and include in detail what you already tried and why it  is not a suitable solution.</span>",
            "time": null
        },
        {
            "user": "0xC0000022L",
            "text": "<span class=\"comment-copy\">Actually in order to achieve what you want, you need to have a toolchain (including not just compiler frontend and backend, but also assembler and linker - linker if you use LTO or similar) which can produce the desired code. And then, depending on those (and the specs file - try <code>gcc -dumpspecs</code>) you can use <code>-mtune</code>, <code>-mcpu</code> and <code>-march</code> as well as some more architecture-specific options to optimize for a CPU model and so on. However, your question should be clarified further ... also, you may want to look at RetDec and LLVM IR, perhaps?!</span>",
            "time": null
        }
    ],
    "answers_data": []
}