{
    "title": "How do I extract sprites and backgrounds from .BIN files? (dos game - 1988)",
    "link": "https://reverseengineering.stackexchange.com/questions/31985/how-do-i-extract-sprites-and-backgrounds-from-bin-files-dos-game-1988",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Does anyone know what tools should I use to extract the backgrounds and sprites of this very rare old game: Armorik the Viking?</p>\n<p>The files are in .BIN format. No idea how to open them. I tried Game Extractor and QuickBMS tools but they could not read the files.</p>\n<p>What type of BIN are these? The game is from 1988 and was released by InfoGrames.</p>\n<p>This is the game:</p>\n<p><a href=\"https://archive.org/download/msdos_Armorik_the_Viking_-_The_Eight_Conquests_1988/Armorik_the_Viking_-_The_Eight_Conquests_1988.zip\" rel=\"nofollow noreferrer\">https://archive.org/download/msdos_Armorik_the_Viking_-_The_Eight_Conquests_1988/Armorik_the_Viking_-_The_Eight_Conquests_1988.zip</a></p>\n<p>Many thanks in advance!</p>\n<p><a href=\"https://i.sstatic.net/F20b5.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/F20b5.png\"/></a></p>\n</div>",
    "votes": "2",
    "answers": 2,
    "views": "492",
    "tags": [
        "ida",
        "disassembly",
        "ghidra"
    ],
    "user": "Fab",
    "time": "Jun 19, 2023 at 22:50",
    "comments": [
        {
            "user": "Ali Rizvi-Santiago",
            "text": "<span class=\"comment-copy\">Unless you want to do some work to 100% confirm (as it's just a .COM file), screenshots of the game look like it's CGA. As per <a href=\"https://moddingwiki.shikadi.net/wiki/Raw_CGA_Data\" rel=\"nofollow noreferrer\">moddingwiki.shikadi.net/wiki/Raw_CGA_Data</a>, it's a pretty simple format with every pair of bits representing a color. To confirm it's CGA with reverse-engineering, though, you'd scan for \"INT 10h\" in the disassembly to identify all possible screen mode changes, and I'm pretty certain that they're using \"INT 21h\" to read the contents of those filenames.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>BACKS.BIN - backgrounds. You'll have to write a program to decode those images using your preferred programming language. Some info:</p>\n<ul>\n<li><p>All images are 320x200, 2 bits per pixel.</p>\n</li>\n<li><p>all images contain header - 8 bytes (4 values - 2 bytes per value, all header contain values 0,0-319,199)</p>\n</li>\n<li><p>Images are interlaced - first part of image contains only even rows, second - odd rows.</p>\n</li>\n<li><p>All images are packed with RLE compression, pseudocode:</p>\n<pre><code> while(!needExit) {\n\n     controlByte = getNextByte(data[position]);\n     position++;\n\n     if (controlByte == 0) {\n         needExit = true;\n     } else if (controlByte == 0x80) {\n         // change CGA plane\n         buffer = oddRows;\n     } else if ((controlByte &amp; 0x80) == 0) {\n         for (int i=0; i&lt;controlByte; i++) {\n             word = getNextTwoBytes(data, position + i*2);\n             buffer.write(word);\n         }\n         position += controlByte * 2;\n     } else {\n         controlByte = controlByte &amp; 0x7F;\n         word = getNextTwoBytes(data, position);\n         for (int i=0; i&lt;controlByte; i++) {\n             buffer.write(word);\n         }\n         position += 2;\n     }\n }\n</code></pre>\n</li>\n</ul>\n<p>MOTIFS.BIN - sprites. This file is not packed, so you can see/extract sprites with programs like \"Texture/Tiles finder\" (if they support CGA/2 bits per pixel modes).</p>\n<ul>\n<li><p>256 sprites of size 32x32 pixels</p>\n</li>\n<li><p>3 sprites of size 48x48 pixels</p>\n</li>\n<li><p>3 sprites of size 64x64 pixels</p>\n</li>\n<li><p>2 bits per pixel, CGA pal.</p>\n</li>\n<li><p>After each sprite lies its transparency mask, also 2 bits per pixel. If 2 bits in mask both set then corresponding pixel in sprite is transparent.</p>\n</li>\n</ul>\n<p><img alt=\"Example\" src=\"https://imgur.com/a/UEf75nF\"> - <a href=\"https://imgur.com/a/UEf75nF\" rel=\"nofollow noreferrer\">https://imgur.com/a/UEf75nF</a></img></p>\n</div>",
            "votes": "2",
            "user": "Max",
            "time": "Jun 28, 2023 at 22:02",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I tried to read the file BACKS.BIN but I can only view one image from the output_images.bin file generated by the following C++ code. It looks like the output file does not contain all the content from the input file BACKS.BIN; I'm not sure how to fix it. Any ideas on how to improve the below code? Many thanks!\nMy viewer is GBS as well.</p>\n<p>here it is: <a href=\"https://ibb.co/MhvhZZq\" rel=\"nofollow noreferrer\">https://ibb.co/MhvhZZq</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nconst int IMAGE_WIDTH = 320;\nconst int IMAGE_HEIGHT = 200;\nconst int HEADER_SIZE = 8;\n\nstruct ImageHeader {\n    int width;\n    int height;\n};\n\nbool getNextTwoBytes(const std::vector&lt;char&gt;&amp; data, int position, short&amp; word) {\n    if (position + 1 &gt;= data.size())\n        return false;\n\n    word = (static_cast&lt;uint8_t&gt;(data[position + 1]) &lt;&lt; 8) | static_cast&lt;uint8_t&gt;(data[position]);\n    return true;\n}\n\nbool extractAndDecompressImages(const std::string&amp; inputFilePath, const std::string&amp; outputFilePath) {\n    std::ifstream inputFile(inputFilePath, std::ios::binary);\n    if (!inputFile) {\n        std::cerr &lt;&lt; \"Error: Could not open input file.\\n\";\n        return false;\n    }\n\n    inputFile.seekg(0, std::ios::end);\n    std::streampos fileSize = inputFile.tellg();\n    inputFile.seekg(0, std::ios::beg);\n\n    int imageCount = static_cast&lt;int&gt;(fileSize / (HEADER_SIZE + IMAGE_WIDTH * IMAGE_HEIGHT));\n    if (imageCount == 0) {\n        std::cerr &lt;&lt; \"Error: Invalid input file format.\\n\";\n        return false;\n    }\n\n    std::ofstream outputFile(outputFilePath, std::ios::binary);\n    if (!outputFile) {\n        std::cerr &lt;&lt; \"Error: Could not create output file \" &lt;&lt; outputFilePath &lt;&lt; \"\\n\";\n        return false;\n    }\n\n    for (int i = 0; i &lt; imageCount; ++i) {\n        ImageHeader header;\n        inputFile.read(reinterpret_cast&lt;char*&gt;(&amp;header), sizeof(ImageHeader));\n\n        std::vector&lt;char&gt; compressedData(IMAGE_WIDTH * IMAGE_HEIGHT);\n        inputFile.read(compressedData.data(), compressedData.size());\n\n        std::vector&lt;char&gt; decompressedData;\n        decompressedData.reserve(IMAGE_WIDTH * IMAGE_HEIGHT * 2); // Reserve enough space to avoid reallocations\n\n        int position = 0;\n\n        while (position &lt; compressedData.size()) {\n            unsigned char controlByte = static_cast&lt;unsigned char&gt;(compressedData[position++]);\n            if (controlByte == 0) {\n                break;\n            } else if (controlByte == 0x80) {\n                // change CGA plane (not relevant for decompression)\n                // Assuming CGA plane change is already handled outside of decompression.\n            } else if ((controlByte &amp; 0x80) == 0) {\n                for (int i = 0; i &lt; controlByte; i++) {\n                    short word;\n                    if (!getNextTwoBytes(compressedData, position + i * 2, word)) {\n                        std::cerr &lt;&lt; \"Error: Invalid input file format.\\n\";\n                        return false;\n                    }\n                    decompressedData.insert(decompressedData.end(), {static_cast&lt;char&gt;(word &amp; 0xFF), static_cast&lt;char&gt;(word &gt;&gt; 8)});\n                }\n                position += controlByte * 2;\n            } else {\n                controlByte = controlByte &amp; 0x7F;\n                short word;\n                if (!getNextTwoBytes(compressedData, position, word)) {\n                    std::cerr &lt;&lt; \"Error: Invalid input file format.\\n\";\n                    return false;\n                }\n                for (int i = 0; i &lt; controlByte; i++) {\n                    decompressedData.insert(decompressedData.end(), {static_cast&lt;char&gt;(word &amp; 0xFF), static_cast&lt;char&gt;(word &gt;&gt; 8)});\n                }\n                position += 2;\n            }\n        }\n\n        // Write the decompressed data to the output file using modern C++ iterators\n        std::copy(decompressedData.begin(), decompressedData.end(), std::ostreambuf_iterator&lt;char&gt;(outputFile));\n    }\n\n    return true;\n}\n\nint main() {\n    const std::string inputFilePath = \"BACKS.bin\";\n    const std::string outputFilePath = \"output_images.bin\";\n\n    if (extractAndDecompressImages(inputFilePath, outputFilePath)) {\n        std::cout &lt;&lt; \"Extraction and decompression successful!\\n\";\n    } else {\n        std::cout &lt;&lt; \"Extraction and decompression failed.n\";\n    }\n\n    return 0;\n}\n</code></pre>\n</div>",
            "votes": "1",
            "user": "The Thinker",
            "time": "Jul 26, 2023 at 3:30",
            "is_accepted": false,
            "comments": []
        }
    ]
}