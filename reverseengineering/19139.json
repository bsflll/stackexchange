{
    "title": "Do all class instances have a relative address/offset and can i make a copy of any class pointer?",
    "link": "https://reverseengineering.stackexchange.com/questions/19139/do-all-class-instances-have-a-relative-address-offset-and-can-i-make-a-copy-of-a",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm familiar with finding a player base pointer as-well as other values in games, and finding offsets and such.\nAnd I have applied that to some of my own code in the past.</p>\n<p>But does this practice apply to instances of any class?</p>\n<p>Here's an example program.</p>\n<pre><code>using namespace std;\n\nclass A {\npublic:\n    int i = 0;\n    virtual void doThing() {\n        i++;\n        cout &lt;&lt; i &lt;&lt; endl;\n    }\n\n};\n\nint main()\n{\n    A* a = new A();\n    while (1)\n    {\n        a-&gt;doThing();\n        Sleep(6000);\n    }\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n<p>I used Cheat engine to find the address of the variable <code>i</code> in <code>A::doThing</code>. Then I used the option to find what writes to that address. From there I found what appeared to be an offset, did a pointer scan and found that <code>example.exe+0x001A2EC</code> was a static pointer and the value held by <code>i</code> was at offset <code>0x4</code>.</p>\n<p>Would <code>example.exe+0x001A2EC</code> be considered the pointer to the instance of class <code>A</code>? </p>\n<p>What I'm trying to do is basically make a copy of the target program's pointer to the instance of class <code>A</code>, then access it's V-Table in my own code which is to be injected into the process.</p>\n<p>This is how I was trying to achieve this.</p>\n<pre><code>DWORD Base = (DWORD)GetModuleHandle(0);\nA* a = (A*)(Base + 0x1A2EC);\nvoid** vtable = *(void***)a;\n</code></pre>\n<p>If there's something wrong with my understanding or methodology please do point out what i am doing wrong, or suggest some other way which I can get a copy of the pointer.</p>\n</div>",
    "votes": "3",
    "answers": 1,
    "views": "330",
    "tags": [
        "decompilation",
        "c++",
        "offset",
        "vtables",
        "cheat-engine"
    ],
    "user": "Michael Strobel",
    "time": "Aug 23, 2018 at 3:12",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'll start with a few minor corrections and clarifications, just to make sure we're using the right terms and exact definitions.</p>\n<blockquote>\n<p>I used Cheat engine to find the address of the variable <code>i</code> in <code>A::doThing</code></p>\n</blockquote>\n<p>First of all, <code>i</code> is not a variable of method <code>A::doThing</code>. It is a <em>member</em> of the <code>A</code> class.</p>\n<blockquote>\n<p>Then I used the option to find what writes to that address</p>\n</blockquote>\n<p>Doing this gives you the address of method <code>A::doThing</code> is located. Specifically, the address at which <code>A::i</code> is modified within that method.</p>\n<blockquote>\n<p>from there I found what appeared to be an offset, did a pointer scan</p>\n</blockquote>\n<p>I would assume you found the offset of <code>A</code> at which <code>i</code> is located, but I'm not 100% I understand what you mean by \"did a pointer scan\". I assume you subtracted the offset of <code>i</code> from the address found at the first stage (\"I used Cheat engine to find the address of the variable <code>i</code>\") to get the address of the object itself, then searched for pointers to that address.</p>\n<blockquote>\n<p>Would \"example.exe\"+0001A2EC be considered the pointer to the instance of A class?</p>\n</blockquote>\n<p>To be more accurate, <code>example.exe+0x001A2EC</code> would be an address of a variable of type <code>A *</code> (or pointer to an <code>A</code> instance), and it's value will be the value returned by <code>new A();</code>, i.e. an instance of class <code>A</code>, as you expect. Reading it's value will point you to where that instance of <code>A</code> is currently in memory.</p>\n<p><strong>However</strong> several assumptions you have may change between releases or even for different compiled versions of the same code base.</p>\n<p>The most obvious one in your example code, is the fact you're using the <strong>exetuable's image base</strong> to access the <strong>main thread's stack</strong>. This is likely to break depending on how/where the stack is allocated for your process, and is likely to be unreliable even if executed several times in succession, depending on OS and configuration.</p>\n<p>Even if you somehow address that, there are multiple other potential complications and slight changes that could make your life harder. To name a few:</p>\n<ol>\n<li>Even if you were using the process's stack offset instead of the image base, the offset in memory where the <code>A</code> pointer variable, <code>a</code>, is located is likely to change. <em>even just between different executions of an identical binary</em>. For example, in your case <code>a</code> is stored on the stack, and if the function defining <code>a</code> could be called in several different flows, the <em>stack depth</em> at which the stack frame of the function creating <code>a</code> may differ. if a function <code>a_creator</code> may be called in either one of two flows <code>main/a_creator</code> and <code>main/game_load/a_creator</code> depending on circumstances (e.g. if you're loading a save), the offset at which <code>a_craetor</code>'s stack frame will start will be different.</li>\n<li>The offset at which <code>i</code> is located in the <code>A</code> class's internal structure, may be changed because new members were added in the code. Although normally maintain the order members are defined at, optimizations may shift them around for better alignment. Different padding configuration settings may also change the location a member is actually at.</li>\n<li>Different optimization configurations may even completely eliminate the variable <code>a</code>, only storing it in a non-volatile register. This is very likely in the example implementation you provided, for example.</li>\n<li>A new version of the program can easily create move variables and make code changes so locations will be completely off.</li>\n<li>Inheritance and casting of <code>a</code> could lead you to different VTables than the ones you were looking for, as well as other complications.</li>\n</ol>\n<p>I hope this did not discourage you from pursuing your goal, but encouraged you to gain a better understanding of the internals and intricate world of dynamic patching.</p>\n<p>As a side note I'll include a warning about anti-cheat detection tools in a lot of games could make these endeavors quite expensive (account bans, etc).</p>\n</div>",
            "votes": "2",
            "user": "NirIzr",
            "time": "Aug 23, 2018 at 3:10",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Michael Strobel",
                    "text": "<span class=\"comment-copy\">Is there some other way to get the pointer to the A instance? Maybe by signature scanning?  Also, i don't quite understand how this differs from finding a static pointer to a player class in games as I've done before.  (Just to clarify also i don't intend on getting accounts banned anytime soon, anything I've done with games has just been for the purpose of learning, and done using insecure servers.)</span>",
                    "time": null
                },
                {
                    "user": "NirIzr",
                    "text": "<span class=\"comment-copy\">Static variables (pointers or not) reside in a fixed location relative to the executable's image base. the stack does not. As for suggestions for a better solution, I think you should start another question and describe your specific scenario (instead of an example program), although most of it will probably be derived from what I said here.</span>",
                    "time": null
                }
            ]
        }
    ]
}