{
    "title": "Distinguish between local function calls and external(imported) function calls in a dynamic trace",
    "link": "https://reverseengineering.stackexchange.com/questions/9198/distinguish-between-local-function-calls-and-externalimported-function-calls-i",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I know that when IDA pro want to disassemble a binary and label the functions, employs import address table and IDA flirt to distinguish from local functions and external functions! </p>\n<p>Now I have dynamice trace and want to distinguish between local and external function calls but I do not know how can I do this process. Could you please help me how can I do this process?</p>\n<p>My trace is something like this:(this is a small part of trace)</p>\n<pre><code>(1) 7c90e430: lea 0x10(%esp),%edi   A@0x0022fd30[0x00000000][4](R) T_begin (0x0) T_end (0x0)    R@edi[0x00310031][4](W) T_begin (0x0) T_end (0x0)   \n(2) 7c90e434: pop %eax  M@0x0022fd20[0x7c901166][4](R) T_begin (0x0) T_end (0x0)    R@eax[0x00401130][4](W) T_begin (0x0) T_end (0x0)   \n(3) 7c90e435: call %eax R@eax[0x7c901166][4](R) T_begin (0x0) T_end (0x0)   M@0x0022fd20[0x7c901166][4](W) T_begin (0x0) T_end (0x0)    \n(4) 7c901166: lea 0x10(%esp),%eax   A@0x0022fd30[0x00000000][4](R) T_begin (0x0) T_end (0x0)    R@eax[0x7c901166][4](W) T_begin (0x0) T_end (0x0)   \n(5) 7c90116a: mov %eax,0x4(%esp)    R@eax[0x0022fd30][4](R) T_begin (0x0) T_end (0x0)   M@0x0022fd24[0x00000000][4](W) T_begin (0x0) T_end (0x0)    \n(6) 7c90116e: xor %ebp,%ebp R@ebp[0x00350037][4](R) T_begin (0x0) T_end (0x0)   R@ebp[0x00350037][4](RW) T_begin (0x0) T_end (0x0)  \n(7) 7c901170: jmp 0x7c91b057    J@0x00000000[0x00019ee7][4](R) T_begin (0x0) T_end (0x0)    \n(8) 7c91b057: mov %edi,%edi R@edi[0x0022fd30][4](R) T_begin (0x0) T_end (0x0)   R@edi[0x0022fd30][4](W) T_begin (0x0) T_end (0x0)   \n(9) 7c91b059: push %ebp R@ebp[0x00000000][4](R) T_\n(33) 7c9222f9: pushl $0x7c97b0c8    I@0x00000000[0x7c97b0c8][4](R) T_begin (0x0) T_end (0x0)    M@0x0022fd04[0x00000000][4](W) T_begin (0x0) T_end (0x0)    \n(34) 7c9222fe: call 0x7c9199d7  J@0x00000000[0xffff76d9][4](R) T_begin (0x0) T_end begin (0x0) T_end (0x0)  M@0x0022fd1c[0x00000000][4](W) T_begin (0x0) T_end (0x0)    \n(10) 7c91b05a: mov %esp,%ebp    R@esp[0x0022fd1c][4](R) T_begin (0x0) T_end (0x0)   R@ebp[0x00000000][4](W) T_begin (0x0) T_end (0x0)   \n(11) 7c91b05c: cmpb $0x0,0x7c97b20c I@0x00000000[0x00000000][1](R) T_begin (0x0) T_end (0x0)    M@0x7c97b20c[0x00000000][1](R) T_begin (0x0) T_end (0x0)    \n(12) 7c91b063: jz 0x7c9226ed    J@0x00000000[0x0000768a][4](R) T_begin (0x0) T_end (0x0)    \n(13) 7c9226ed: call 0x7c9226fc  J@0x00000000[0x0000000f][4](R) T_begin (0x0) T_end (0x0)    M@0x0022fd18[0x00000000][4](W) T_begin (0x0) T_end (0x0)    \n(14) 7c9226fc: mov %edi,%edi    R@edi[0x0022fd30][4](R) T_begin (0x0) T_end (0x0)   R@edi[0x0022fd30][4](W) T_begin (0x0) T_end (0x0)   \n(15) 7c9226fe: push %ebp    R@ebp[0x0022fd1c][4](R) T_begin (0x0) T_end (0x0)   M@0x0022fd14[0x00000000][4](W) T_begin (0x0) T_end (0x0)    \n(16) 7c9226ff: mov %esp,%ebp    R@esp[0x0022fd14][4](R) T_begin (0x0) T_end (0x0)   R@ebp[0x0022fd1c][4](W) T_begin (0x0) T_end (0x0)   \n(17) 7c922701: push %ecx    R@ecx[0x00310038][4](R) T_begin (0x0) T_end (0x0)   M@0x0022fd10[0x00000000][4](W) T_begin (0x0) T_end (0x0)    \n(18) 7c922702: push %ecx    R@ecx[0x00310038][4](R) T_begin (0x0) T_end (0x0)   M@0x0022fd0c[0x00000000][4](W) T_begin (0x0) T_end (0x0)    \n(19) 7c922703: xor %ecx,%ecx    R@ecx[0x00310038][4](R) T_begin (0x0) T_end (0x0)   R@ecx[0x00310038][4](RW) T_begin (0x0) T_end (0x0)  \n(20) 7c922705: mov $0x7c97d394,%eax I@0x00000000[0x7c97d394][4](R) T_begin (0x0) T_end (0x0)    R@eax[0x0022fd30][4](W) T_begin (0x0) T_end (0x0)   \n(21) 7c92270a: inc %ecx R@ecx[0x00000000][4](RW) T_begin (0x0) T_end (0x0)  \n(22) 7c92270b: xadd %ecx,(%eax) R@ecx[0x00000001][4](RW) T_begin (0x0) T_end (0x0)  M@0x7c97d394[0x00000000][4](RW) T_begin (0x0) T_end (0x0)   \n(23) 7c92270b: xadd %ecx,(%eax) R@ecx[0x00000001][4](RW) T_begin (0x0) T_end (0x0)  M@0x7c97d394[0x00000000][4](RW) T_begin (0x0) T_end (0x0)   \n(24) 7c92270f: inc %ecx R@ecx[0x00000000][4](RW) T_begin (0x0) T_end (0x0)  \n(25) 7c922710: cmp $0x1,%ecx    I@0x00000000[0x00000001][1](R) T_begin (0x0) T_end (0x0)    R@ecx[0x00000001][4](R) T_begin (0x0) T_end (0x0)   \n(26) 7c922713: jnz 0x7c93d4d9   J@0x00000000[0x0001adc6][4](R) T_begin (0x0) T_end (0x0)    \n(27) 7c922719: call 0x7c9222e9  J@0x00000000[0xfffffbd0][4](R) T_begin (0x0) T_end (0x0)    M@0x0022fd08[0x00000000][4](W) T_begin (0x0) T_end (0x0)    \n(28) 7c9222e9: mov 0x7c97b0c8,%eax  M@0x7c97b0c8[0x0000bb40][4](R) T_begin (0x0) T_end (0x0)    R@eax[0x7c97d394][4](W) T_begin (0x0) T_end (0x0)   \n(29) 7c9222ee: test %eax,%eax   R@eax[0x0000bb40][4](R) T_begin (0x0) T_end (0x0)   R@eax[0x0000bb40][4](R) T_begin (0x0) T_end (0x0)   \n(30) 7c9222f0: jz 0x7c9222f9    J@0x00000000[0x00000009][4](R) T_begin (0x0) T_end (0x0)    \n(31) 7c9222f2: cmp $0xbb40,%eax I@0x00000000[0x0000bb40][4](R) T_begin (0x0) T_end (0x0)    R@eax[0x0000bb40][4](R) T_begin (0x0) T_end (0x0)   \n(32) 7c9222f7: jnz 0x7c922309   J@0x00000000[0x00000012][4](R) T_begin (0x0) T_end (0x0)    (0x0)   M@0x0022fd00[0x00000000][4](W) T_begin (0x0) T_end (0x0)    \n(35) 7c9199d7: pushb $0xc   I@0x00000000[0x0000000c][1](R) T_begin (0x0) T_end (0x0)    M@0x0022fcfc[0x00000000][4](W) T_begin (0x0) T_end (0x0)\n</code></pre>\n<p>P.S: I should mention that I do not have any other information except this trace file.</p>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "122",
    "tags": [
        "ida",
        "disassembly",
        "binary-analysis",
        "patch-reversing",
        "function-hooking"
    ],
    "user": "user2942756",
    "time": "Apr 28, 2017 at 12:50",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'd say this is an external function because of the memory range (0x7c000000 looks typical for imported DLLs), but without more information it's actually hard to tell.</p>\n<p>The proper way would be to check the memory sections of your binary and to see in which sections the current instructions are.</p>\n</div>",
            "votes": "1",
            "user": "user2823000",
            "time": "Jun 22, 2015 at 10:14",
            "is_accepted": false,
            "comments": []
        }
    ]
}