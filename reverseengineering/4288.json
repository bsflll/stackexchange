{
    "title": "How to deal with this “lea” instructions generated by objdump?",
    "link": "https://reverseengineering.stackexchange.com/questions/4288/how-to-deal-with-this-lea-instructions-generated-by-objdump",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>So basically I am using <code>objdump</code> to disassemble a binary from `GNU Coreutils\", on 32 bit Linux x86.</p>\n<p>In the disassembled code, I found one \"broken\" instruction like this:</p>\n<pre><code> 804bb49:   8d 04 ed 00 00 00 00    lea    0x0(,%ebp,8),%eax\n</code></pre>\n<p>I asked a related question about a very similar instruction <a href=\"https://reverseengineering.stackexchange.com/questions/4285/how-to-deal-with-this-error-instructions-generated-by-objdump\">here</a>, in that question, I think it should be a jump table related instruction, but how about this one ? I am quite confused..</p>\n<p>Could anyone give me some help?</p>\n</div>",
    "votes": "3",
    "answers": 2,
    "views": "2k",
    "tags": [
        "disassembly",
        "assembly",
        "objdump"
    ],
    "user": "lllllllllllll",
    "time": "Apr 28, 2017 at 12:54",
    "comments": [
        {
            "user": "yaspr",
            "text": "<span class=\"comment-copy\">You should update your question &amp; be more precise. I cannot seem to understand what you mean by \"broken\" from the code you provided.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I don't know what makes you think this instruction is \"broken\" - the fact that there is a comma right after a bracket, without a parameter in between? In this case, the disassembler just doesn't show the parameter because it's \"zero\" (more precisely, it specifies \"no register\" where \"any processor register\" would be allowed).</p>\n<p>What happens here is: when addressing memory locations, the processor has a mode where it adresses </p>\n<ul>\n<li>a base offset</li>\n<li>plus the content of one processor register</li>\n<li>plus the content of another processor register, multiplied by an integer that can be 1,2,4 or 8</li>\n</ul>\n<p>This calculation is quite fast, as it's done in special hardware in the address bus subsystem.</p>\n<p>The <code>lea</code> (load effective address) instruction is a special kind of RAM access -- it calculates the address of the operand, but then, it moves the <em>address</em>, not the data at that address, into the destination register.</p>\n<p>So your 'broken' instruction moves a base offset of 0, plus \"no\" first register, plus 8 times the content of ebp, into eax. The same could have been done by moving ebp to eax and multiplying by 8, or moving and shifting left by 3 bits, but the <code>lea</code> instruction is probably a bit faster (because, as i said, it's done in specialized address bus hardware), so the compiler used that one to save a few cycles. Nothing is broken here.</p>\n<p>You might want to take a look at a i386 assembler reference when disassembling, the indirect adressing is quite well explained in the <a href=\"https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/060-i386_Addressing_Modes_and_Assembler_Instructions/i386_intructions.html\" rel=\"noreferrer\">OS X Assembler reference</a>, scroll down to \"Indirect Memory Operands\".</p>\n</div>",
            "votes": "5",
            "user": "Guntram Blohm",
            "time": "May 8, 2014 at 8:38",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>what does broken mean </p>\n<p>the instruction in either this post or in your earlier post do not seem to be broken </p>\n<p>if you are confused with AT&amp;T syntax then you can ask objdump to disassemble in intel syntax</p>\n<p>a better explanation of broken can get a better answer </p>\n<pre><code>root@box:/home/dsl/gcctests/test# cat testjt.c \nvoid naked (void)\n{\n        asm( \".globl _naked\\n\");\n        asm( \"_naked:\\n\");\n        asm( \"jmp *0x80509e4(,%eax,4)\");\n        asm( \"lea 0x0(,%ebp,8),%eax\");\n        asm( \"ret\");\n}\nint main (void)\n{\n        naked();\n        return 0;\n}\n\n\nroot@box:/home/dsl/gcctests/test# objdump -t ./testjt | grep _naked\n08048357 g       .text  00000000              _naked\n\n\nroot@box:/home/dsl/gcctests/test# objdump -d --disassembler-option=intel  ./testjt | grep -A 2 _naked\n\n\n08048357 &lt;_naked&gt;:\n 8048357:       ff 24 85 e4 09 05 08    jmp    DWORD PTR [eax*4+134547940]\n 804835e:       8d 04 ed 00 00 00 00    lea    eax,[ebp*8]\n\n\nroot@box:/home/dsl/gcctests/test#  \n</code></pre>\n</div>",
            "votes": "5",
            "user": "blabb",
            "time": "May 8, 2014 at 9:04",
            "is_accepted": false,
            "comments": []
        }
    ]
}