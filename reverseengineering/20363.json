{
    "title": "Understanding assembly code: \"mov dword\" and \"mov qword\" in main.c",
    "link": "https://reverseengineering.stackexchange.com/questions/20363/understanding-assembly-code-mov-dword-and-mov-qword-in-main-c",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have just converted this piece of code in assembly:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char** argv) {\n    return (1);\n}\n</code></pre>\n<p>Here are my questions:</p>\n<ol>\n<li>Once you push the base-pointer value on to the stack, RSP will decrement automatically (to a lower address). This will also happen when memory was allocated for argc and argv (\"mov dword\" and \"mov qword\"). Is this correct? I don't see any instruction to move the stack-pointer up the stack, so I am assuming this is done implicitly.</li>\n<li>The instruction \"mov dword [rbp-4H], edi\" is 4 bytes less than the address in RBP, this is as expected since DWORD is 4 bytes in length. What I am confused about is why \"mov qword [rbp-10H], rsi\" is 10H (16 bytes)? Isn't QWORD 8 bytes in length? I was expecting the instruction to be \"mov qword [rbp-CH], rsi\", since 4+8=12 bytes.</li>\n<li>Can you explain to me what the comments on the right-side are? </li>\n</ol>\n<p>Below is the assembly code generated from my c program:</p>\n<pre><code>SECTION .text   align=1 execute                         ; section number 1, code\n\nmain:   ; Function begin\npush    rbp                                     ; 0000 _ 55\nmov     rbp, rsp                                ; 0001 _ 48: 89. E5\nmov     dword [rbp-4H], edi                     ; 0004 _ 89. 7D, FC\nmov     qword [rbp-10H], rsi                    ; 0007 _ 48: 89. 75, F0\nmov     eax, 1                                  ; 000B _ B8, 00000001\npop     rbp                                     ; 0010 _ 5D\nret                                             ; 0011 _ C3\n; main End of function\n\n\nSECTION .data   align=1 noexecute                       ; section number 2, data\n\nSECTION .bss    align=1 noexecute                       ; section number 3, bss\n</code></pre>\n</div>",
    "votes": "0",
    "answers": 1,
    "views": "8k",
    "tags": [
        "assembly"
    ],
    "user": "supmethods",
    "time": "Jan 14, 2019 at 0:34",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Variables are aligned to some extent to help faster access to them. The alignment value is usually an implementation detail, but compilers usually follow Intel's recommendations to align/place variables next to each other.</p>\n<p>According to <a href=\"http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf\" rel=\"nofollow noreferrer\">Intel® 64 and IA-32 Architectures Optimization Reference Manual</a>, section 3.6.7 Stack Alignment*:</p>\n<blockquote>\n<p>Performance penalty of unaligned access to the stack happens when a\nmemory reference splits a cache line. This means that one out of eight\nspatially consecutive unaligned quadword accesses is always penalized,\nsimilarly for one out of 4 consecutive, non-aligned double-quadword\naccesses, etc.</p>\n<p>Aligning the stack may be beneficial any time there are\ndata objects that exceed the default stack alignment of the system.\nFor example, on 32/64bit Linux, and 64bit Windows, the default stack\nalignment is 16 bytes, while 32bit Windows is 4 bytes.</p>\n<p><em><strong>Assembly/Compiler Coding Rule 55. (H impact, M generality)</strong> Make sure\nthat the stack is aligned at the largest multi-byte granular data type\nboundary matching the register width.</em></p>\n</blockquote>\n<p>In your case on x64 the registers are 8 bytes wide and <code>argc</code> being an <code>int</code> is 4 bytes wide. Following the guideline above the variables are aligned to 8-byte boundary.</p>\n<pre><code> ► 0x5555555545fe &lt;main+4&gt;                   mov    dword ptr [rbp - 4], edi\n   0x555555554601 &lt;main+7&gt;                   mov    qword ptr [rbp - 0x10], rsi\n   0x555555554605 &lt;main+11&gt;                  mov    eax, 0x2a\n   0x55555555460a &lt;main+16&gt;                  pop    rbp\n   0x55555555460b &lt;main+17&gt;                  ret    \n</code></pre>\n<p><code>edi</code> stores <code>argc</code> a 32 bit value - packed in a 64 bit boundary with the upper 32 bits of no use for you.</p>\n<pre><code>pwndbg&gt; tele rbp-0x10\n00:0000│          0x7fffffffdf10 —▸ 0x7fffffffe000 ◂— 0x1\n01:0008│          0x7fffffffdf18 ◂— 0x0\n02:0010│ rbp rsp  0x7fffffffdf20 —▸ 0x555555554610 (__libc_csu_init) ◂— push   r15\n</code></pre>\n<p>So the <code>argv</code> starts 8 bytes above <code>argv</code></p>\n</div>",
            "votes": "3",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": []
        }
    ]
}