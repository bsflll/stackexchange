{
    "title": "Restoring the file structure from a cocos2d-x JS Android APK, post decryption?",
    "link": "https://reverseengineering.stackexchange.com/questions/33245/restoring-the-file-structure-from-a-cocos2d-x-js-android-apk-post-decryption",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am currently learning how to reverse engineer an APK and have made significant progress. Here’s what I've accomplished so far:</p>\n<ol>\n<li><strong>Decryption &amp; Code Browsing:</strong> Converted the Dalvik bytecode (.dex files) to readable Java and JavaScript code.</li>\n<li><strong>Unbundling:</strong> Unbundled the decrypted JavaScript files. (Though they are still minified)</li>\n<li><strong>UUID Decryption:</strong> Figured out how to decrypt UUIDs into filenames and vice versa, and found resource paths for some UUIDs.</li>\n</ol>\n<p>However, I’m stuck on figuring out the correct folder structure for certain assets within the \"Main\" folder.</p>\n<h3>What I’ve Discovered So Far</h3>\n<p>Here’s what I know about the asset packs in the \"Main\" folder:</p>\n<ul>\n<li>Each asset pack has a UUID, which corresponds to an image containing multiple assets.</li>\n<li>There is a JSON file for each asset pack, but these don't provide much useful information regarding the folder structure.</li>\n<li>Each asset in the image has its own JSON file that includes:\n<ul>\n<li>The pack name near the beginning.</li>\n<li>Details about the asset's position in the image.</li>\n</ul>\n</li>\n<li>The manifest contains every asset's location, but only assets listed in <code>/resources/config.json</code> have \"paths\" to help re-map them.</li>\n</ul>\n<h3>My Questions</h3>\n<ol>\n<li><strong>How can I determine the correct folder structure for these assets?</strong></li>\n<li><strong>Is there a pattern or tool that can help map these assets to their appropriate locations?</strong></li>\n</ol>\n<h2>Important Note: There is NO map file - the manifest lists the obfuscated names and their md5 or sha-256 depending on which one you look at, My goal is to reverse engineer back to the original format that the code references.</h2>\n<h3>Code Samples &amp; Structure</h3>\n<p>I’ve included some relevant code snippets and file structure details to illustrate what I’m working with:</p>\n<h4>Example <code>config.json</code> (UUIDs without paths):</h4>\n<pre class=\"lang-json prettyprint-override\"><code>{\n    \"paths\": {},\n    \"types\": [],\n    \"uuids\": [\n        \"05mU7WsllFO4elu4Re6/pm\",\n        \"fcTsdoxZlLpKd3It99/+h6\"\n    ],\n    \"scenes\": {\n        \"db://assets/main.fire\": 127,\n        \"db://assets/start.fire\": 120\n    },\n    \"redirect\": [1, 0, 2, 0, 4, ... 0, 146, 0],\n    \"deps\": [\"resources\", \"internal\"],\n    \"packs\": {},\n    \"name\": \"main\",\n    \"importBase\": \"import\",\n    \"nativeBase\": \"native\",\n    \"debug\": false,\n    \"isZip\": false,\n    \"encrypted\": true\n}\n</code></pre>\n<h4>Example of Bundled Code Before Unbundling:</h4>\n<p>(but you can see the bottom section provides a filestructure / names for the bundles, which is how I reverse engineered and unbundled it)</p>\n<pre class=\"lang-js prettyprint-override\"><code>{\n    1: [function(e, t, i) {\n        \"use strict\";\n        const n = i;\n        n.bignum = e(\"bn.js\");\n        n.define = e(\"./asn1/api\").define;\n        n.base = e(\"./asn1/base\");\n        n.constants = e(\"./asn1/constants\");\n        n.decoders = e(\"./asn1/decoders\");\n        n.encoders = e(\"./asn1/encoders\");\n    }, {\n        \"./asn1/api\": 2,\n        \"./asn1/base\": 4,\n        \"./asn1/constants\": 8,\n        \"./asn1/decoders\": 10,\n        \"./asn1/encoders\": 13,\n        \"bn.js\": 15\n    }],\n</code></pre>\n<h4>File Structure</h4>\n<p>Here’s a partial view of the file structure I’m working with:</p>\n<pre><code>Directory: T:\\assets\n  Subdirectory: ad-viewer\n  Subdirectory: assets\n  Subdirectory: dexopt\n  Subdirectory: jsb-adapter\n  Subdirectory: src\n  File: audience_network.dex\n  File: cid\n  File: main.js\n  File: project.json\n  File: tt_mime_type.pro\n\nDirectory: T:\\assets\\assets\n  Subdirectory: internal\n  Subdirectory: localizeData\n  Subdirectory: main\n  Subdirectory: manifest\n  Subdirectory: resources\n  Subdirectory: Script\n\nDirectory: T:\\assets\\assets\\internal\n  Subdirectory: import\n  Subdirectory: native\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\internal\\import\n  Subdirectory: 09\n\nDirectory: T:\\assets\\assets\\internal\\import\\09\n  File: 0967b326a.json\n\nDirectory: T:\\assets\\assets\\internal\\native\n  Subdirectory: 02\n\nDirectory: T:\\assets\\assets\\internal\\native\\02\n  File: 0275e94c-56a7-410f-bd1a-fc7483f7d14a.png\n\nDirectory: T:\\assets\\assets\\localizeData\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\main\n  Subdirectory: import\n  Subdirectory: native\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\main\\import\n  Subdirectory: 05\n  Subdirectory: 06\n  Subdirectory: 08\n  Subdirectory: 12\n.....\nDirectory: T:\\assets\\assets\\manifest\n  Subdirectory: import\n  Subdirectory: native\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\manifest\\import\n  Subdirectory: 83\n\nDirectory: T:\\assets\\assets\\manifest\\import\\83\n  File: 83f57686-53e5-4bc7-bdf0-33bcd506f93b.json\n\nDirectory: T:\\assets\\assets\\manifest\\native\n  Subdirectory: 83\n\nDirectory: T:\\assets\\assets\\manifest\\native\\83\n  File: 83f57686-53e5-4bc7-bdf0-33bcd506f93b.manifest\n\nDirectory: T:\\assets\\assets\\resources\n  Subdirectory: import\n  Subdirectory: native\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\resources\\import\n  Subdirectory: 00\n  Subdirectory: 01\n  Subdirectory: 02\n....\nDirectory: T:\\assets\\assets\\Script\n  Subdirectory: import\n  File: config.json\n  File: index.js\n\nDirectory: T:\\assets\\assets\\Script\\import\n  Subdirectory: c8\n\nDirectory: T:\\assets\\assets\\Script\\import\\c8\n  File: c85c3dbd-5a7d-424c-8e07-965706736336.json\n\nDirectory: T:\\assets\\dexopt\n  File: baseline.prof\n  File: baseline.profm\n\nDirectory: T:\\assets\\jsb-adapter\n  File: jsb-builtin.js\n  File: jsb-engine.js\n\nDirectory: T:\\assets\\src\n  Subdirectory: assets\n  File: cocos2d-jsb.js\n  File: settings.js\n\nDirectory: T:\\assets\\src\\assets\n  Subdirectory: libs\n\nDirectory: T:\\assets\\src\\assets\\libs\n  File: thinkingdata.mg.cocoscreator.min.js\n</code></pre>\n<h4>Specific Asset Example</h4>\n<ul>\n<li>Asset pack UUID: <code>1e58fbfa7</code>\n<ul>\n<li>Image file: <code>assets\\assets\\main\\native\\1e\\1e58fbfa7.png</code></li>\n<li>JSON file: <code>assets\\assets\\main\\import\\1e\\1e58fbfa7.json</code>\nJSON Contents:</li>\n</ul>\n</li>\n</ul>\n<pre class=\"lang-json prettyprint-override\"><code>[\n    1,\n    0,\n    0,\n    [\n        \"cc.Texture2D\"\n    ],\n    0,\n    [\n        \"0,9729,9729,33071,33071,0,0,0\",\n        -1\n    ],\n    [\n        0\n    ],\n    0,\n    [],\n    [],\n    []\n]\n</code></pre>\n<h4>Traceback</h4>\n<p>I search for that string (1e58fbfa7) in all files and find a matching JSON for each of the assets on that image, here is an example of one:\n(I do understand what these are - they are stating where the asset that relates to that file / UUID is on the pack)</p>\n<pre class=\"lang-json prettyprint-override\"><code>[\n    1,\n    [\n        \"1e58fbfa7\"\n    ],\n    [\n        \"_textureSetter\"\n    ],\n    [\n        \"cc.SpriteFrame\"\n    ],\n    0,\n    [\n        {\n            \"name\": \"UI_Bt_world\",\n            \"rect\": [\n                342,\n                446,\n                127,\n                115\n            ],\n            \"offset\": [\n                0,\n                0.5\n            ],\n            \"originalSize\": [\n                129,\n                116\n            ],\n            \"capInsets\": [\n                0,\n                0,\n                0,\n                0\n            ]\n        }\n    ],\n    [\n        0\n    ],\n    0,\n    [\n        0\n    ],\n    [\n        0\n    ],\n    [\n        0\n    ]\n]\n</code></pre>\n<p>That JSON is \\assets\\assets\\main\\import\\3a\\3aa50555-73a6-416d-b35a-cfab79466fa7.json</p>\n<p>If I convert that to a UUID (3apQVVc6ZBbbNaz6t5Rm+n) I will find it in two locations, config.json (snippet provided above) and another location (\\assets\\assets\\main\\import\\9f\\9fde386a-2232-446d-9554-549e101dde19.json) which is somewhat similar to the config.json, but not quite... snippet:</p>\n<pre class=\"lang-json prettyprint-override\"><code>[\n    1,\n    [\n        \"ecpdLyjvZBwrvm+cedCcQy\",\n...\n    [\n        \"node\",\n        \"_spriteFrame\",\n        \"_N$file\",\n...\n   [\n        [\n            \"cc.Node\",\n            [\n                \"_name\",\n...\n               \"_children\"\n            ],\n            -2,\n            4,\n...\n                ]\n            ],\n            [\n                0,\n                \"58H6b2PPdJip4dKNTXDv0T\",\n                1,\n                0\n            ],\n            [\n                4,\n                4278190080\n            ],\n            [\n                5,\n                1242,\n                2688\n            ]\n        ]\n    ],\n    0,\n    [\n        0,\n        12,\n...\n        96,\n        97,\n        1\n    ]\n]\n</code></pre>\n<p>I convert that file name into a UUID (9f3jhqIjJEbZVUVJ4QHd4Z) and find it in yet another file (\\assets\\assets\\main\\import\\d7\\d726ed83-41aa-4389-bd34-dd1e963ba515.json)...</p>\n<pre class=\"lang-json prettyprint-override\"><code>[\n    1,\n    [\n        \"9f3jhqIjJEbZVUVJ4QHd4Z\"\n    ],\n    [\n        \"mainNode\",\n        \"node\",\n        \"scene\"\n    ],\n    [\n        [\n            \"cc.SceneAsset\",\n            [\n                \"_name\",\n                \"asyncLoadAssets\"\n            ],\n            1\n        ],\n        [\n            \"cc.Scene\",\n            [\n                \"_name\",\n...\n    [\n        0,\n        -1,\n        2,\n        0,\n        1,\n        2,\n        0,\n        2,\n        1,\n        2\n    ],\n    [\n        0\n    ],\n    [\n        0\n    ],\n    [\n        0\n    ]\n]\n</code></pre>\n<p>I went even deeper, converted that file name to a UUID (d7Ju2DQapDib003R6WO6UV) and looked and found it in one location.... the original config file. So now I'm back to the beginning!</p>\n</div>",
    "votes": "0",
    "answers": 1,
    "views": "80",
    "tags": [
        "android",
        "unpacking",
        "deobfuscation",
        "apk",
        "javascript"
    ],
    "user": "Lucy Taylor",
    "time": "Oct 4, 2024 at 2:12",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>It sounds like you’re making impressive progress with your reverse engineering efforts. You’re stuck at reconstructing the folder structure of the assets, and this can indeed be tricky. However, based on the patterns you’ve discovered, we can attempt to create a strategy to reverse the structure:</p>\n<p>Strategy for Determining the Folder Structure</p>\n<ol>\n<li><strong>Analyze UUID Relationships:</strong></li>\n</ol>\n<ul>\n<li>You’ve identified that UUIDs correspond to both asset packs and individual assets. By converting these UUIDs back and forth between JSON files and their image counterparts, you have already managed to trace some dependencies.</li>\n<li>To move forward, it’s important to explore any hierarchical relationships between these UUIDs. For example, when an asset UUID appears in a JSON file, check how it references other assets and their corresponding files. This often gives hints about the structure, such as child/parent relationships.</li>\n</ul>\n<ol start=\"2\">\n<li><strong>Use the Asset Pack Information (e.g., “rect”, “offset”, “originalSize”):</strong></li>\n</ol>\n<ul>\n<li>The metadata in the JSON files, particularly fields like \"rect\", \"offset\", and \"originalSize\", gives clues about how assets were packed into a texture atlas. If certain assets are packed together (as indicated by shared UUIDs or proximity in the texture), they may belong in the same folder or share a common prefix in the file structure.</li>\n<li><strong>Pattern Recognition:</strong> Look for patterns in asset metadata to determine if they relate to certain parts of the game. For example, UI elements might share common characteristics, which could suggest they belong in a UI folder.</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Path Reconstruction from Known UUIDs:</strong></li>\n</ol>\n<ul>\n<li>Since some assets in the config.json have paths, you can use these as a starting point for the folder structure. For example, assets related to specific game scenes like \"db://assets/main.fire\" might reside in the assets/main folder.</li>\n<li>Use the assets that have paths as “anchors” and attempt to match their structure to the UUIDs that don’t yet have paths. You can cross-reference these with their relationships in the JSON files.</li>\n</ul>\n<ol start=\"4\">\n<li><strong>Examine Obfuscated Names and Hashes (MD5 or SHA-256):</strong></li>\n</ol>\n<ul>\n<li>The manifest contains MD5 or SHA-256 hashes of asset files. These are likely computed from the file contents, filenames, or paths. While it’s difficult to reverse these directly, you might observe patterns between the hashes of similar assets (e.g., UI elements, textures).</li>\n<li>You could attempt to compute hashes of certain path combinations and compare them against the values in the manifest to reconstruct parts of the folder structure.</li>\n</ul>\n<ol start=\"5\">\n<li><strong>Folder Structure from Resource Metadata:</strong></li>\n</ol>\n<ul>\n<li>The \"packs\": {} section of config.json indicates grouping of certain assets. Investigate if these groupings follow a consistent naming convention or folder hierarchy.</li>\n<li>Check if there are any consistent prefixes or suffixes in the UUIDs or paths for assets that should belong in the same folder (e.g., textures, models, sounds). This could provide insights into how folders should be organized.</li>\n</ul>\n<p>Tools &amp; Techniques to Help</p>\n<ol>\n<li><strong>Automated Dependency Trackers:</strong></li>\n</ol>\n<ul>\n<li>Tools like <a href=\"https://www.andnixsh.com/2020/03/tool-unity-assets-bundle-extractor.html?m=1\" rel=\"nofollow noreferrer\">Unity Asset Bundle Extractor</a> (even if you’re not working with Unity, these tools might help interpret textures and packed assets) or APK reverse-engineering tools like <a href=\"https://www.pnfsoftware.com/\" rel=\"nofollow noreferrer\">JEB</a> could help in further automating the analysis.</li>\n<li>You might use a script (e.g., Python) to recursively trace dependencies through the JSON files, reconstructing the relationships between assets and helping generate a potential folder structure.</li>\n</ul>\n<ol start=\"2\">\n<li><strong>Cross-reference UUIDs and Hashes:</strong></li>\n</ol>\n<ul>\n<li>Consider generating a script to extract UUIDs and their corresponding asset data (e.g., position in atlas, size, type) and then attempt to sort them into potential folder structures based on their metadata. As you process more files, patterns should emerge.</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Visualization of Assets in Texture Atlases:</strong></li>\n</ol>\n<ul>\n<li>Visualizing the rect coordinates and asset positions on the texture atlas might help you guess at the logical grouping of assets. If you can map assets spatially, it might reveal clues about folder structure (e.g., UI elements packed closely together).</li>\n<li>Tools like <a href=\"https://www.codeandweb.com/texturepacker\" rel=\"nofollow noreferrer\">Texture Packer</a> can be used to visualize texture atlases and help you identify how the assets are grouped.</li>\n</ul>\n<p>Additional Steps to Consider</p>\n<ul>\n<li><strong>Recursive Conversion of UUIDs:</strong> You’ve done this manually, but consider writing a script to automate the process of recursively converting UUIDs and tracing the connections between assets. This can speed up the process of identifying groupings and dependencies.</li>\n<li><strong>Guess the Original Folder Structure:</strong> For assets you can’t place definitively, consider trying common folder structures used in game development (e.g., UI, Textures, Audio, Scenes, Scripts) and see if these align with any of the UUID patterns or JSON relationships.</li>\n<li><strong>Test Iterations:</strong> Once you’ve mapped out a possible structure, you could attempt a test reorganization and see if it matches what’s expected in the execution of the app, based on the decompiled JavaScript code.</li>\n</ul>\n<p>With these strategies, you should be able to progress further in reconstructing the original asset structure from the obfuscated files.</p>\n</div>",
            "votes": "0",
            "user": "Maximiliano López",
            "time": "Oct 8, 2024 at 2:15",
            "is_accepted": false,
            "comments": [
                {
                    "user": "sudhackar",
                    "text": "<span class=\"comment-copy\">This reads like its written by chatgpt</span>",
                    "time": null
                }
            ]
        }
    ]
}