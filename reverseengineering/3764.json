{
    "title": "identification/reverse engineer lz compression",
    "link": "https://reverseengineering.stackexchange.com/questions/3764/identification-reverse-engineer-lz-compression",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am doing a translation project for the PSP version of a game released by Prototype (Japanese company), but I am having trouble with some GIM files (image files). \nNow the actual problem is not with the gim format, but a compression that has been placed on the gim files, but before that I will clarify a few things.\nSome of the GIM's work, however sometimes a GIM file appears that neither puyotools or GimConv (software that converts gim to png) can handle. The GIM that doesn't work is a little different in appearance.\nI know its a GIM file because it starts with: MIG.00.1PSP, though to be exact, its a little different and written like this:</p>\n<p><code>[integer equals 16, signature?] [integer equals 131792] [MIG.00.1PSP, but where a 00 HEX is placed between each hex byte]\n</code></p>\n<p>like this:</p>\n<p><code>10 00 00 00 D0 02 02 00 4D 00 49 00 47 00 2E 00 30 00 30 00\n2E 00 31 00 50 00 53 00 50 00 00 00</code></p>\n<p>Each of the compressed GIM files starts with these two integers values (however an image I have with smaller resolution has a different second integer). I have allready tried removing these two integers and also tried replacing M(00)I(00)G(00).(00)0(00)0(00).(00)1(00)P(00)S(00)P(00), with simply MIG.00.1PSP, but that just ended up making GIMConv saying: wrong chunk data.</p>\n<p>Also I have tried analyzing the file with signsrch and TrID to look for hints of some sort, but signsrch finds nothing and TrID only finds: \"100 .0% (.) LTAC compressed audio (v1.61) (1001/2)\"</p>\n<p>Here is the file called: black.gim (a black image)\n<img alt=\"enter image description here\" src=\"https://i.sstatic.net/Quc5S.png\"/></p>\n<p>Here is a random CG: \n<img alt=\"enter image description here\" src=\"https://i.sstatic.net/W1UrT.png\"/></p>\n<p>Here is a random gim file for refference to how an uncompressed version should look like. Notice that the first 4 bytes of the second line indicates the file size minus 16. \nAnother thing is the int after MIG.001.PSP, which I from different sources has found to be the version number. Therefore, all the compressed files should problably get that int there too.\n<img alt=\"enter image description here\" src=\"https://i.sstatic.net/pTza1.png\"/>\nUpdate: I believe this is some kind of lz compression, but I haven't figured out which one yet. Tried lz01,lz00,lz10,lz11,CXLZ, lzss . It seems to me that it begins with a 10 byte like lz, it makes MIG.001.PSP become seperated by 00, due to the compression relying on value, key pair, where I believe the key 0 means that values should be directly send to the output. &lt;- if you are confident that its one of the compressions I have tried, please say so too as it could very well just be the tools I used to try those compressions that was wrong with. GZIP and deflate was tried using .NET's System.IO.Compression in C# and the others has been tried using something called Puyo tools.</p>\n<p>Update: It seams like I have it almost figured out, basicly a key equals zero outputs value to decompressed data. If key is higher than zero, then get the short value of [Value,key-1]. This short plus 8 times two gives the byte it has to write out twice to decompressed data. In other words, 00 00 08 01 would output 00 00 00. The only problem with this is that 0f 01 in my black.gim example at line 3. This would point to 15 which would be position (15 + 8)*2 equals byte 46 which should be 02 00 in line two. This is however incorrect! Since I expect it to place zeroes there, not output 02 02..</p>\n<p>In short in the black.gim example I have found that:\n0C 01 should output 00 00\n0D 01 should output 00 00 00\n0F 01 should output 00 00</p>\n<p>Any suggestions?</p>\n<p>I'll be really happy if anybody could give me some input or lead :)</p>\n</div>",
    "votes": "8",
    "answers": 1,
    "views": "1k",
    "tags": [
        "file-format"
    ],
    "user": "patr0805",
    "time": "Feb 27, 2014 at 4:47",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<span class=\"comment-copy\">LZJB? From Jonathan Bennett? It's used in AutoIt, for example.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Here is the complete answer to everyone who may encounter compressed GIM file of simular compression.\nBasicly the file starts like this:\n[magic number 10 00 00 00] [Integer with uncompressed size of file]\nAfter this the compressed file begin.\nThe compression basicly functions like this: (in terms of decompression)</p>\n<p><strong>-&gt; Take the next 2 bytes.</strong></p>\n<p><strong>-&gt; Is the second byte equals zero?</strong></p>\n<ul>\n<li>Write first byte to decompressed output.</li>\n</ul>\n<p><strong>-&gt; Is the second byte higher than 0?</strong></p>\n<p>This is a pointer whose job is to make use of bytes used before. The position it points to is equals the unsigned short value of: [first byte, second byte minus 1]*2 + 8. When a pointer reads at the position it points to, it will read the next 4 bytes and not just the next 2 bytes. If the bytes at the pointed location is: 00 02 0C 01, then the decompressed output would be 02 ?? where ?? would be the result of the first two bytes of what its pointing at. In other words, if we pointed to 0C 01 02 00, then the output 0C 01 would be replaced by the result whatever its pointing to.Lets say it points to 08 00 00 00, then the output of the last pointer would be 08 00 00 00, which would replace 0C 01 and become: 08 00 00 00 02 00, which lastly would output 08 00 02 to decompressed output. *Notice that a pointer placed as the second byte cannot be replaced by four bytes, but only by the first two bytes of what would normally have been the result. If the second byte is pointing to the first byte, then it will simply be given the result of the first byte.</p>\n<p>Examples from the image from the first post (Black.gim):\nIn the first image: 0c 01 points to 00 00 0C 01, which outputs 00 00.\nIn the first image 0d 01 points to 0C 01 0C 01, which outputs 00 00 00. &lt;- notice how only the first two bytes at a pointed position has the right to extend the result of what pointed to it by two bytes.\nIn the first image: 0F 01 points to 02 00 0D 01, which outputs 02 00</p>\n<p><strong>-&gt; do this until no bytes remains..</strong></p>\n<p>About the suggested LZJB, I'll check right away. In case its right, I have still gotten quite the experience about reverse engineering files.</p>\n</div>",
            "votes": "8",
            "user": "patr0805",
            "time": "Mar 3, 2014 at 1:39",
            "is_accepted": true,
            "comments": []
        }
    ]
}