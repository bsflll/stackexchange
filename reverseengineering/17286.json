{
    "title": "how to find the encryption algorithm?",
    "link": "https://reverseengineering.stackexchange.com/questions/17286/how-to-find-the-encryption-algorithm",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have an arm complied <code>so</code> file and find the decrypt function which pseudocode generated by IDA Pro is like this:</p>\n<pre><code>char __cdecl EncodeUtil::getDecryptStr()\n{\n  int *v0; // r0\n  int *v1; // r7\n  unsigned int i; // r5\n  char v3; // r6\n  int v5; // [sp+4h] [bp-1Ch]\n\n  v1 = v0;\n  HttpUtility::URLDecode(&amp;v5);\n  for ( i = 0; i &lt; *(_DWORD *)(v5 - 12); ++i )\n  {\n    sub_3B25D0(&amp;v5);\n    v3 = byte_41A7DD[i &amp; 7]; //byte_41A7DD     DCB 0xC, 0x17, 0xDE, 0x22, 0x2C, 0xC9, 0x37, 0x43\n    *(_BYTE *)(v5 + i) ^= v3;\n    sub_3B25D0(&amp;v5);\n    if ( !*(_BYTE *)(v5 + i) )\n    {\n      sub_3B25D0(&amp;v5);\n      *(_BYTE *)(v5 + i) ^= v3;\n    }\n  }\n  sub_3B2E20(v1, &amp;v5);\n  sub_3B1CCC(&amp;v5);\n  return (char)v1;\n}\n</code></pre>\n<p>and the <code>sub_3B25D0</code> function is:</p>\n<pre><code>int *__fastcall sub_3B25D0(int *result)\n{\n  if ( *(_DWORD *)(*result - 4) &gt;= 0 )\n    result = sub_3B2580(result);\n  return result;\n}\n</code></pre>\n<p>and the <code>sub_3B2580</code> function is:</p>\n<pre><code>int *__fastcall sub_3B2580(int *result)\n{\n  int v1; // r3\n  int *v2; // r4\n\n  v1 = *result;\n  v2 = result;\n  if ( (int *)(*result - 12) != &amp;dword_4C60C0 )\n  {\n    if ( *(_DWORD *)(v1 - 4) &gt; 0 )\n    {\n      result = sub_3B1D0C(result, 0, 0, 0);\n      v1 = *v2;\n    }\n    *(_DWORD *)(v1 - 4) = -1;\n  }\n  return result;\n}\n</code></pre>\n<p>and then <code>sub_3B1D0C</code></p>\n<pre><code>int *__fastcall sub_3B1D0C(int *result, size_t a2, int a3, int a4)\n{\n  int v4; // r12\n  int v5; // r10\n  int v6; // r8\n  int v7; // r7\n  unsigned int v8; // r3\n  unsigned int v9; // r8\n  int *v10; // r5\n  int v11; // r4\n  size_t v12; // r6\n  size_t v13; // r10\n  int v14; // r0\n  int v15; // r9\n  bool v16; // zf\n  int v17; // r7\n  int v18; // r4\n  const void *v19; // r1\n  int v20; // r7\n  int v21; // r4\n  _BYTE *v22; // r1\n  char v23; // [sp+4h] [bp-24h]\n\n  v4 = *result;\n  v5 = *(_DWORD *)(*result - 12);\n  v6 = a4 - a3;\n  v7 = a4;\n  v8 = *(_DWORD *)(*result - 8);\n  v9 = v6 + v5;\n  v10 = result;\n  v11 = a3;\n  v12 = a2;\n  v13 = v5 - a2 - a3;\n  if ( v9 &gt; v8 || *(_DWORD *)(v4 - 4) &gt; 0 )\n  {\n    v14 = sub_3B1B30(v9, v8, &amp;v23);\n    if ( v12 )\n    {\n      v22 = (_BYTE *)*v10;\n      if ( v12 == 1 )\n      {\n        *(_BYTE *)(v14 + 12) = *v22;\n        v15 = v14 + 12;\n      }\n      else\n      {\n        v15 = v14 + 12;\n        memcpy((void *)(v14 + 12), v22, v12);\n      }\n    }\n    else\n    {\n      v15 = v14 + 12;\n    }\n    if ( v13 )\n    {\n      v20 = v7 + v12;\n      v21 = v11 + v12;\n      if ( v13 == 1 )\n        *(_BYTE *)(v15 + v20) = *(_BYTE *)(*v10 + v21);\n      else\n        memcpy((void *)(v15 + v20), (const void *)(*v10 + v21), v13);\n    }\n    result = (int *)(*v10 - 12);\n    if ( result != &amp;dword_4C60C0 )\n      result = (int *)sub_3B1C84();\n    v4 = v15;\n    *v10 = v15;\n  }\n  else\n  {\n    v16 = a3 == v7;\n    if ( a3 != v7 )\n      v16 = v13 == 0;\n    if ( !v16 )\n    {\n      v17 = v7 + a2;\n      v18 = a3 + a2;\n      result = (int *)(v4 + v17);\n      v19 = (const void *)(v4 + a3 + a2);\n      if ( v13 == 1 )\n        *(_BYTE *)(v4 + v17) = *(_BYTE *)(v4 + v18);\n      else\n        result = (int *)memmove(result, v19, v13);\n      v4 = *v10;\n    }\n  }\n  if ( (int *)(v4 - 12) != &amp;dword_4C60C0 )\n  {\n    *(_DWORD *)(v4 - 4) = 0;\n    *(_DWORD *)(v4 - 12) = v9;\n    *(_BYTE *)(v4 + v9) = 0;\n  }\n  return result;\n}\n</code></pre>\n<p>can anyone give a best guess what does the function do after <code>HttpUtility::URLDecode</code> ?</p>\n<h2>EDIT</h2>\n<p>As inspired by @NirIzr's answer below and some of the comments, I wrote a snippet of Java code to try the XOR like this:</p>\n<pre><code> public static void main(String args[])\n    {\n        byte[] _bytes = null;\n        byte[] key = {(byte) 0xC,(byte)0x17,(byte)0xDE,(byte)0x22,(byte)0x2C,(byte)0xC9,(byte)0x37,(byte)0x43};\n        String s = \"%EB%9Ff%C5%A4q%D0%D9%88%F2M%87%C9Z%92%A6%83%BC%3B%86%8B%2D%8B%EC\";\n        try {\n            String decoded = URLDecoder.decode(s,\"UTF-8\");\n            _bytes = decoded.getBytes();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n\n\n        for(int i=0;i&lt;_bytes.length;i++){\n            _bytes[i] = (byte)(_bytes[i] ^ key[i%key.length]);\n        }\n\n        System.out.println(new String(_bytes));\n\n    }\n</code></pre>\n<p>But the out put didn't seems to be good:</p>\n<p><code>�cD�mF�����v��c͓tm���1��&amp;���c�v�����͓t��</code></p>\n</div>",
    "votes": "3",
    "answers": 2,
    "views": "935",
    "tags": [
        "c",
        "decryption",
        "decompress"
    ],
    "user": "armnotstrong",
    "time": "Jun 17, 2020 at 9:54",
    "comments": [
        {
            "user": "sudhackar",
            "text": "<span class=\"comment-copy\">Can you share the binary so that we can help you better?</span>",
            "time": null
        },
        {
            "user": "armnotstrong",
            "text": "<span class=\"comment-copy\">@sudhackar sure, the <code>.so</code> file could be found <a href=\"https://www.dropbox.com/s/fpy6kamr43saq42/libcocos2dcpp.so\" rel=\"nofollow noreferrer\">here</a> and you can search for <code>EncodeUtil.getDecryptStr</code> to find the function</span>",
            "time": null
        },
        {
            "user": "Avery3R",
            "text": "<span class=\"comment-copy\">Have you tried just xoring it with the byte array that you have commented? If that doesn't work I'd try stepping through it with a debugger.</span>",
            "time": null
        },
        {
            "user": "Paweł Łukasik",
            "text": "<span class=\"comment-copy\">it would be best if you would have some examples to run them through, but it looks like xoring would do what can be also noted from what does the encryptStr does.</span>",
            "time": null
        },
        {
            "user": "armnotstrong",
            "text": "<span class=\"comment-copy\">@PawełŁukasik @Avery3R I think you can use <code>%EB%9Ff%C5%A4q%D0%D9%88%F2M%87%C9Z%92%A6%83%BC%3B%86%8B%2D%8B%EC</code> this string(which is encoded first using httpUrlEncode according to the code) to do the test, moreover, I upload the SQLite DB which contains the encrypted string <a href=\"https://www.dropbox.com/s/h1o8dyunmzthr29/crazytalk.sqlite?dl=0\" rel=\"nofollow noreferrer\">here</a></span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>All the credit for this this answer should go to the @NirIzr and @Avery3R.</p>\n<p>Here is a python script that implements the xoring mentioned by these kind people:</p>\n<pre><code>import urllib\nimport binascii\ndata = \"%EB%9Ff%C5%A4q%D0%D9%88%F2M%87%C9Z%92%A6%83%BC%3B%86%8B%2D%8B%EC\" #quoted data as is\nunquoted = urllib.unquote(data)\nkey = binascii.unhexlify(\"0C17DE222CC93743\") # the key\nidx = 0\nres = \"\"\nfor c in unquoted:\n    res += chr(ord(c) ^ ord(key[idx % len(key)]))\n    idx += 1\nprint res\n</code></pre>\n<p>The result of running: </p>\n<pre><code>╭─wireshrink@[cenzored] ~/test  \n╰─$ python ./test.py \n爸爸的哥哥叫大伯\n</code></pre>\n<p>I think that you either forgot to encode it back to UTF8 before printing or there is some other issue in your code or default environment that is  related to encoding.</p>\n</div>",
            "votes": "4",
            "user": "w s",
            "time": "Jan 30, 2018 at 13:30",
            "is_accepted": true,
            "comments": [
                {
                    "user": "armnotstrong",
                    "text": "<span class=\"comment-copy\">Thanks, I will figure out what the problem is with my java code :D</span>",
                    "time": null
                },
                {
                    "user": "Paweł Łukasik",
                    "text": "<span class=\"comment-copy\">interesting content (via google translate): \"爸爸的哥哥叫大伯\"-&gt;\"Dad's brother called uncle\" ;)</span>",
                    "time": null
                },
                {
                    "user": "armnotstrong",
                    "text": "<span class=\"comment-copy\">@PawełŁukasik LOL</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><em>First, I have to say several things don't quite add up in the decompilation, and I often find it easier to understand disassembly than decompilation</em></p>\n<p>Let's start with the function doing most of the work - <code>sub_3B25D0</code>.</p>\n<p>As this function is somewhat long and has a little bit of quote-unquote <em>scary math</em> in it, our first impression may be that this function does all or most of the encryption heavy lifting. However after further investigation (and i won't dwell into this here) you can clearly see indications of an <em>compression algorithm</em>. There are multiple key elements revealing that, and you can find a full explanation of how to differentiate compression from encryption in <a href=\"https://reverseengineering.stackexchange.com/questions/13475/how-can-i-determine-if-a-piece-of-code-is-an-encryption-algorithm/13476#13476\">this answer</a>.</p>\n<p>I'll however go over some of the key indications as they appear in the code snippet you provided.</p>\n<ol>\n<li>There are no neat iteration of all characters in the string, by order. Nearly all encryption algorithms, either <a href=\"https://en.wikipedia.org/wiki/Block_cipher\" rel=\"nofollow noreferrer\">Block</a> or <a href=\"https://en.wikipedia.org/wiki/Stream_cipher\" rel=\"nofollow noreferrer\">Stream</a>  iterate over all characters of the input string. Blocks will iterate over block-sized chunks of the string.</li>\n<li>Not enough substitutions over either input message or stream/state.</li>\n<li>Plenty of partial <code>memcpy</code>/<code>memmove</code>s, indicating this function composes as string out of different sub-sequences of input string.</li>\n</ol>\n<p>Therefore, lets rename <code>sub_3B1D0C</code> to <code>NI_BlockDecompression</code>. You may use your own initials. I'm assuming it's a decompression and not a compression function merely because you called the flow \"Decrypt\", impling input is intangible.</p>\n<p>Now, going bottom to top, we can briefly review <code>sub_3B2580</code> and <code>sub_3B25D0</code> and see those functions just run a couple of simple sanity checks on input but basically don't do anything interesting. after a brief peek it looks like there's some kind of protection against running the <code>NI_BlockDecompression</code> function more than once on the same string, not sure though. Let's just skip them and get to the second interesting function - <code>getDecryptStr</code>.</p>\n<p>I find the multiple calls to <code>sub_3B25D0</code> quite odd, and I suggest you look further into what's going on there. The <code>EncodeUtil::getDecryptStr</code> function just seem to xor bytes with the hardcoded \"<a href=\"https://en.wikipedia.org/wiki/XOR_cipher\" rel=\"nofollow noreferrer\">XOR encryption</a>\" key at <code>byte_41A7DD</code>.</p>\n</div>",
            "votes": "4",
            "user": "NirIzr",
            "time": "Jan 30, 2018 at 2:54",
            "is_accepted": false,
            "comments": [
                {
                    "user": "armnotstrong",
                    "text": "<span class=\"comment-copy\">Hi, @Nirlzr thanks for your answer, seems promise, I will dig into that</span>",
                    "time": null
                },
                {
                    "user": "armnotstrong",
                    "text": "<span class=\"comment-copy\">Hi, @Nirlzr check the edit :-( could you give some pseudocode, so I can try to understand that?</span>",
                    "time": null
                },
                {
                    "user": "NirIzr",
                    "text": "<span class=\"comment-copy\">@armnotstrong You're doing the xor (although, again, the code there is not merely a xor. there some peculiarities with calling <code>sub_3B25D0</code> multiple times etc) but not performing the decompression.</span>",
                    "time": null
                }
            ]
        }
    ]
}