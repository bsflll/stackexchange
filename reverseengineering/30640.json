{
    "title": "UC_ERR_WRITE_UNMAPPED when emulation starts on binary",
    "link": "https://reverseengineering.stackexchange.com/questions/30640/uc-err-write-unmapped-when-emulation-starts-on-binary",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Whenever I try to emulate my obfuscated driver it fails at <code>uc_emu_start</code> with UC_ERR_WRITE_UNMAPPED. I get all success return codes on: <code>uc_mem_map</code> and <code>uc_mem_write</code> but when I call <code>uc_emu_start</code> ; I get the UC_ERR_WRITE_UNMAPPED error. So, I added a hook on the error code to see what address it was writing to and I found that it was: <code>0xfffffffffffffff8</code>. I don't understand why it is writing to this address because I put <code>0x1000</code> as my base address (<code>std::uint64_t BASE_ADDRESS = 0x1000;</code>) which is then used at\n<code>uc_emu_start</code>. Any help would be appreciated.\n<a href=\"https://i.sstatic.net/T0gH9.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/T0gH9.png\"/></a></p>\n<pre><code>// EMU.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n#include &lt;unicorn.h&gt;\n#include \"capstone/capstone.h\"\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;queue&gt;\n#include &lt;iomanip&gt;\n#include \"PE.h\"\n#include \"BasicBlock.h\"\n#include \"Optimizations.h\"\n#include \"CCapstoneHelper.h\"\nstatic bool hook_mem_invalid(uc_engine* uc, uc_mem_type type, uint64_t address,\n    int size, int64_t value, void* user_data)\n{\n    switch (type) {\n    default:\n        // return false to indicate we want to stop emulation\n        return false;\n    case UC_MEM_WRITE_UNMAPPED:\n        printf(\"&gt;&gt;&gt; Missing memory is being WRITE at 0x%\" PRIx64\n            \", data size = %u, data value = 0x%\" PRIx64 \"\\n\",\n            address, size, value);\n        // map this memory in with 2MB in size\n        uc_mem_map(uc, 0xaaaa0000, 2 * 1024 * 1024, UC_PROT_ALL);\n        // return true to indicate we want to continue\n        return true;\n    }\n}\nint main()\n{\n    try {\n        // UNICORN\n        uc_engine* uc;\n       uc_err err;\n\n        // CAPSTONE\n        csh handle{};\n        cs_insn* insn;\n        //size_t count; \n        std::queue&lt;uint64_t&gt; Q;\n        std::map&lt;uint64_t, bool&gt; seen;\n        std::uint64_t BASE_ADDRESS = 0x1000;\n\n        \n#define MEGABYTES_TO_MAP 15\n        \n        std::cout &lt;&lt; \"[+] Starting emulation...\" &lt;&lt; std::endl;\n        if (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle) != CS_ERR_OK) {\n            throw std::runtime_error(\"cs_open failed\");\n        }\n\n        if (uc_open(UC_ARCH_X86, UC_MODE_64, &amp;uc) != UC_ERR_OK) {\n            throw std::runtime_error(\"uc_open failed\");\n        }\n       \n        if (uc_mem_map(uc, BASE_ADDRESS, 2 * 1024 * 1024, UC_PROT_ALL) != UC_ERR_OK) {\n            throw std::runtime_error(\"uc_mem_map failed\");\n        }\n\n\n\n\n        cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);\n\n       \n        // get pointer to file from Init()\n        insn = cs_malloc(handle);\n        std::cout &lt;&lt; \"[+] Finding driver entry point...\" &lt;&lt; std::endl;\n       PE::CPe pe = PE::CPe::CPe(\"C:\\\\Program Files (x86)\\\\Driver\\\\Driver.sys\");\n\n   \n       std::cout &lt;&lt; \"[+] Found: \" &lt;&lt; std::hex &lt;&lt; pe.get_entry_point_address_relative_to_mapped_file() &lt;&lt; std::endl;\n\n       std::cout &lt;&lt; \"[+] Starting emulation...\" &lt;&lt; std::endl;\n       BasicBlock::CBasicBlock block_buffer{};\n       BasicBlock::_basic_block basic_block{};\n       basic_block.start_address = pe.get_entry_point_address_relative_to_mapped_file();\n    //   BASE_ADDRESS += pe.get_entry_point_file_offset();\n        const std::uint8_t* addr = (std::uint8_t*) basic_block.start_address;\n      \n       // we are at entry point. Start emulation until we reach end of basic block?\n       // At entrypoint, set start of basic block to entry point address.\n       // Emulate until we reach a JUMP instruction\n        std::cout &lt;&lt; \"[+] Removing anti-disassembly...\" &lt;&lt; std::endl;\n        Optimizations::COptimizations optimizations;\n        std::uint8_t anti_d_pattern[] = {0xEB, 0xFF, 0x64, 0x24, 0x08};\n        std::uint64_t num_of_bytes_fixed = optimizations.remove_antidisassembly(anti_d_pattern, sizeof(anti_d_pattern), pe);\n       \n        uint64_t target = 0;\n       size_t code_size = 0x1000;\n       \n       CapstoneHelper::CCapstoneHelper capstone_helper_obj;\n\n\n       uc_hook hook;\n       err = uc_hook_add(uc, &amp;hook, UC_HOOK_MEM_WRITE_UNMAPPED, hook_mem_invalid, NULL, 1, 0);\n      \n       while (true) {\n \n           std::uint64_t prev_base_address = BASE_ADDRESS;\n          while (cs_disasm_iter(handle, &amp;addr, &amp;code_size, &amp;BASE_ADDRESS, insn)) {\n               if (capstone_helper_obj.is_cs_cflow_ins(insn)) {\n                   basic_block.end_address = (std::uint64_t)addr;\n                   break;\n               }\n               \n\n           }\n\n           \n           std::uint32_t error;\n           // write code and then some into memory\n           //uc_mem_map(uc, prev_base_address, MEGABYTES_TO_MAP * 1024 * 1024, UC_PROT_ALL);\n          // if (uc_mem_map(uc, BASE_ADDRESS, MEGABYTES_TO_MAP * 1024 * 1024, UC_PROT_ALL) != UC_ERR_OK) {\n          \n               err = uc_mem_write(uc, prev_base_address, reinterpret_cast&lt;void*&gt;(basic_block.start_address), (basic_block.end_address - basic_block.start_address));\n               if (err != UC_ERR_OK) {\n                  throw std::runtime_error(\"uc_mem_write failed\");\n              }\n            \n              \n            // resolve file offset from base_address;\n              \n\n               err = uc_emu_start(uc, prev_base_address, prev_base_address + (basic_block.end_address - basic_block.start_address) , 0, 0);\n               if (err != UC_ERR_OK) {\n                   throw std::runtime_error(\"uc_emu_start failed\");\n               }\n\n\n\n               /* TODO:\n               1. Write anti-disassembly remover because capstone won't properly disassemble.\n               Anti disassembly byte string: EB FF 64 24 08 (Removing EB byte results in \" jmp    QWORD PTR [rsp+0x8]\"\n               Use file pointer to do operations before we disassemble with capstone.\n               2. Add check for control flow instructions (look at PBA)\n               */\n\n          \n       }\n\n        \n       \n\n\n\n\n\n\n\n\n\n\n        \n        uc_close(uc);\n        cs_close(&amp;handle);\n        \n    }\n    catch (std::exception&amp; e) {\n        std::cout &lt;&lt; \"Error: \" &lt;&lt; e.what();\n        getchar();\n        std::abort();\n    }\n    \n        return 0;\n}\n</code></pre>\n</div>",
    "votes": "1",
    "answers": 0,
    "views": "359",
    "tags": [
        "emulation",
        "capstone"
    ],
    "user": "Ayyware",
    "time": "Jul 15, 2022 at 23:10",
    "comments": [
        {
            "user": "Mega Tonnage",
            "text": "<span class=\"comment-copy\">Deleted my answer, too early in the morning and I confused hex and binary</span>",
            "time": null
        }
    ],
    "answers_data": []
}