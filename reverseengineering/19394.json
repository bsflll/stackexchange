{
    "title": "How did this 80286 detection code work?",
    "link": "https://reverseengineering.stackexchange.com/questions/19394/how-did-this-80286-detection-code-work",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm poking through a disassembled 16-bit DOS game circa 1992. The original system requirements state that the game needs an IBM AT-compatible machine or later, with the 286 processor, to run. And there's a stub around <code>main()</code> that checks for the processor and displays an error message if one is not found.</p>\n<p>I was intrigued as to what was actually being tested for, and I tracked down what appears to be the test procedure. It's comprised of five sub-tests, which are run conditionally, and it returns an integer in the range 0..7 depending on the results of the tests. I figured out, broadly, what the code does (although there may be errors; I'm still rather inexperienced and sometimes misread/misinterpret the meanings of instruction sequences).</p>\n<pre><code>; ... stack setup omitted ...\npushfw\n\n; ==========================================\n; === CHECK #1 =============================\n; ==========================================\n; Sets FLAGS to 0x0 and then immediately reads it back. On an 8086/80186, bits\n; 12-15 always come back set. On a 80286+ this is not the case.\n; 8086/80186 behavior: jump to check 3.\n; 80286+ behavior: fall through to check 2.\nxor ax,ax      ; AX=0x0\npush ax\npopfw          ; pop 0x0 into FLAGS\npushfw\npop ax         ; pop FLAGS into AX\n\nand ax,0xf000  ; bits 12-13: IOPL, always 1 on 86/186\ncmp ax,0xf000  ; bit 14: NT, always 1 on 86/186\n               ; bit 15: Reserved, always 1 on 86/186, always 0 on 286+\njz check3\n\n; ==========================================\n; === CHECK #2 =============================\n; ==========================================\n; Only runs if CPU is plausibly an 80286. Last check before returning.\n; Sets DL=0x6 if IOPL and NT flag bits are all clear.\n; Sets DL=0x7 if any bits in IOPL/NT flags are set.\nmov dl,0x6     ; DL is the proc's return val\nmov ax,0x7000\npush ax\npopfw          ; pop 0x7000 into FLAGS\npushfw\npop ax         ; pop FLAGS into AX\n\nand ax,0x7000  ; bits 12-13: IOPL\n               ; bit 14: NT\njz done\ninc dl         ; DL=0x7 if any bit was set\njmp done\nnop\n\n; ==========================================\n; === CHECK #3 =============================\n; ==========================================\n; Only runs if CPU seems to be an 8086/80186.\n; Sets DL=0x4 and moves on to...\n;   check 4 if 0xff &gt;&gt; 21 == 0\n;   check 5 otherwise (how can this happen?)\ncheck3:\nmov dl,0x4     ; DL is the proc's return val\nmov al,0xff\nmov cl,0x21\nshr al,cl      ; AL = 0xff &gt;&gt; 0x21\njnz check5     ; when does this happen?\n\n; ==========================================\n; === CHECK #4 =============================\n; ==========================================\n; At this point, DF is still 0. ES doesn't\n; point to anything sensible.\n; Sets DL=0x2 if the loop completes.\n; Sets DL=0x0 if the loop does not complete.\n; Moves onto check 5 unconditionally.\nmov dl,0x2     ; DL is the proc's return val\nsti            ; are interrupts important?\npush si\nmov si,0x0\nmov cx,0xffff\nrep lods [BYTE PTR es:si] ; read 64K, ES[SI]-&gt;AL, all junk?\npop si\nor cx,cx       ; test if loop reached 0\njz check5\nmov dl,0x0     ; didn't hit 0. interrupted?\n\n; ==========================================\n; === CHECK #5 =============================\n; ==========================================\n; Leaving memory addresses here because they seem important.\n; Here, DL is either 0x0 or 0x2 from check 4, or 0x4 from check 3. Looks like,\n; contingent on the INC instruction getting overwritten, DL either stays at\n; 0x0/0x2/0x4, or becomes 0x1/0x3/0x5.\ncheck5:\n00000B74  push cs\n00000B75  pop es        ; Set ES to CS. (why not mov es,cs? illegal?)\n00000B76  std           ; DF=1, rep decrements CX\n00000B77  mov di,0xb88\n00000B7A  mov al,0xfb   ; is this just an STI opcode?\n00000B7C  mov cx,0x3\n00000B7F  cli           ; are interrupts undesired?\n00000B80  rep stosb     ; write 3 bytes, AL-&gt;ES[DI]\n00000B82  cld           ; DF=0, why does it matter now?\n00000B83  nop\n00000B84  nop\n00000B85  nop\n00000B86  inc dx        ; destination when CX=1. overwritten?\n00000B87  nop           ; destination when CX=2\n00000B88  sti           ; destination when CX=3\n\ndone:\npopfw\nxor dh,dh      ; only keep low bits\nmov ax,dx      ; return through AX\n; ... stack teardown omitted ...\nretf\n\n; Return values:\n; AX == 0x0: 8086, normal right-shift, loop aborted, overwrites\n; AX == 0x1: 8086, normal right-shift, loop aborted, did not overwrite\n; AX == 0x2: 8086, normal right-shift, loop finished, overwrites\n; AX == 0x3: 8086, normal right-shift, loop finished, did not overwrite\n; AX == 0x4: 8086, weird right-shift, overwrites\n; AX == 0x5: 8086, weird right-shift, did not overwrite\n; AX == 0x6: 286, with clear IOPL/NT flags\n; AX == 0x7: 286, with set IOPL/NT flags\n</code></pre>\n<p>Here's what I can figure so far:</p>\n<p><strong>Check 1:</strong> Seems straightforward. Explicitly set FLAGS to 0x0 and then read it back. The 8086 will force all bits 12..15 to 1, and the 286 won't. <a href=\"https://en.wikipedia.org/wiki/FLAGS_register\" rel=\"nofollow noreferrer\">Source</a>.</p>\n<p><strong>Check 2:</strong> Only for the 286, seems to be similar to check 1 but with special focus on the protected mode flags. Not sure what significance this is to the caller.</p>\n<p>(An aside: If we're assuming the CPU is a 286, couldn't it have been <code>push 0x7000</code> instead of <code>mov ax,0x7000; push ax</code>?)</p>\n<p><strong>Check 3:</strong> Computes <code>0xff &gt;&gt; 0x21</code> and looks for a result other than <code>0</code>. How does this ever happen? Is there a reason the nonzero result obviates the need for check 4?</p>\n<p><strong>Check 4:</strong> Reads 64K from ES into AL. Seems like busywork; ES has not been set to anything useful, and AL is not read from. Core of the test seems to be built around the idea of CX never reaching zero, possibly because of an interrupt somewhere during the loop? Shouldn't the interrupt procedure <code>iret</code> and return here to finish?</p>\n<p><strong>Check 5:</strong> Self-modifying code? Looks like it replaces the last few instructions of the test with <code>STI</code>, thus removing the <code>INC</code> that would otherwise affect the return value? What is the circumstance under which it would fail to overwrite, and thus execute the <code>INC</code>?</p>\n<p>(An aside: Could <code>push cs; pop es</code> be rewritten as <code>mov es,cs</code> or is that not a legal form?)</p>\n<p>I feel like I'm pretty far along in understanding it, but there are clearly a few holes remaining. I'm also not anywhere near fluent in x86, so there may be misinterpretations in my translated comments as well. I get the sense that there's some real cleverness here, written by somebody who knew the intricacies of these machines at a very detailed level. I'd like to understand their magic on some level, if I can.</p>\n</div>",
    "votes": "10",
    "answers": 2,
    "views": "1k",
    "tags": [
        "disassembly",
        "x86",
        "dos",
        "dos-exe"
    ],
    "user": "smitelli",
    "time": "Aug 26, 2020 at 2:00",
    "comments": [
        {
            "user": "peter ferrie",
            "text": "<span class=\"comment-copy\">Check 4 code is wrong because the rep must be first to produce the effect.  An interrupt during the load causes one prefix to be lost.  If the rep is what's lost then cx will be non-zero on exit.</span>",
            "time": null
        },
        {
            "user": "smitelli",
            "text": "<span class=\"comment-copy\">@peterferrie I'm about two years late to the party, but you're right. I finally tried reassembling this and the binaries didn't match. I fixed the <code>rep lods</code> in check #4.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'll dive into the past and try to give an explanation of the different checks you are observing in your software. I found three references explaining the behaviour (as I hope), which I will reference to in this answer as /1/, /2/, /3/.</p>\n<p>/1/ <a href=\"http://www.drdobbs.com/embedded-systems/processor-detection-schemes/184409011\" rel=\"noreferrer\">http://www.drdobbs.com/embedded-systems/processor-detection-schemes/184409011</a></p>\n<p>It is an archive article from the DrDobbs Journal (very regrettably not existing any more since many years, but their archive still being a valuable resource), by Richard Leinecker, June 01, 1993, called \"Processor Detection Schemes\".</p>\n<p>/2/ <a href=\"https://github.com/lkundrak/dev86/blob/master/libc/misc/cputype.c\" rel=\"noreferrer\">https://github.com/lkundrak/dev86/blob/master/libc/misc/cputype.c</a></p>\n<p>It is a program written by Robert de Bath, published Oct 23, 2013, also covering problems like the one here in considerable detail, unfortunately not with too much of code comments.</p>\n<p>/3/ iAPX 86/88, 186/188 User's Manual, Programmer's Reference, intel, May 1983</p>\n<p>It is the Intel Programmers Reference for the processors listed in the title, still valid in many aspects (a nice example of the extremely fast pace of technology change in some fields...).</p>\n<p>Your CHECKs:</p>\n<p><strong>CHECK1</strong>: You gave the explanation yourself. It may be verified in /1/, LISTING ONE (contained in the article as well). I will not reproduce the code here and not comment further, as there is nothing to add to your explanation.</p>\n<p><strong>CHECK2</strong>: Checks whether the processor is a 286 or higher (like 386 or 486). I'll quote the description of /1/, together with their code. Quote:</p>\n<pre><code>; Is It an 80286?\n; Determines whether processor is a 286 or higher. Going into subroutine ax = 2\n; If the processor is a 386 or higher, ax will be 3 before returning. The\n; method is to set ax to 7000h which represent the 386/486 NT and IOPL bits\n; This value is pushed onto the stack and popped into the flags (with popf).\n; The flags are then pushed back onto the stack (with pushf). Only a 386 or 486\n; will keep the 7000h bits set. If it's a 286, those bits aren't defined and\n; when the flags are pushed onto stack these bits will be 0. Now, when ax is\n; popped these bits can be checked. If they're set, we have a 386 or 486.\nIsItA286    proc\n        pushf               ; Preserve the flags\n        mov ax,7000h        ; Set the NT and IOPL flag\n                            ; bits only available for\n                            ; 386 processors and above\n        push    ax          ; push ax so we can pop 7000h\n                            ; into the flag register\n        popf                ; pop 7000h off of the stack\n        pushf               ; push the flags back on\n        pop ax              ; get the pushed flags\n                            ; into ax\n        and ah,70h          ; see if the NT and IOPL\n                            ; flags are still set\n        mov ax,2            ; set ax to the 286 value\n        jz  YesItIsA286     ; If NT and IOPL not set\n                            ; it's a 286\n        inc ax              ; ax now is 4 to indicate\n                            ; 386 or higher\nYesItIsA286:\n        popf                ; Restore the flags\n\n        ret                 ; Return to caller\nIsItA286    endp\n</code></pre>\n<p>I hope you'll see the similarity to your code immediately.</p>\n<p><strong>CHECK3</strong>: Determines whether you have a 80186/80188 or earlier.\nQuote from /3/, p.3-26, chapter \"SHIFTS\":</p>\n<blockquote>\n<p>\"On the 8086,88 up to 255 shifts may be performed.  ...</p>\n<p>... Before the 80186, 188 perform a shift (or rotate) they AND the\n  value to be shifted with 1FH, thus limiting the number of shifts\n  occurring to 32 bits.\"</p>\n</blockquote>\n<p>Your code, commented:</p>\n<pre><code>mov dl, 0x4     ; DL is the proc's return val\nmov al, 0xff    ; al contains 0xff\nmov cl, 0x21    ; According to the above explanation from Intel,\n                ; this value in cl is in an 80186/188 converted to 1, by ANDing with 0x1F.\nshr al, cl      ; 80186/188 =&gt; al = 0x7F\n                ; other: al = 0\njnz check5      ; goto check5 if you have an 80186/188\n</code></pre>\n<p><strong>CHECK4</strong>: This one is not quite clear. However, it seems that it is the test of some CPU error. It seems to test for the CMOS version of an 8086/88.</p>\n<p>/2/ lists the following code with comment, starting from line 271ff:</p>\n<pre><code>; The CMOS 8088/6 had the bug with rep lods repaired.\ncmos:   push si\n    sti\n    mov cx, #$FFFF\nrep\n    lodsb\n    pop si\n    or cx,cx\n    jne test8\n    mov bx,#2   ; Intel 80C88\n</code></pre>\n<p>It's not exactly your code, but very similar, thus I assume your code as well tests for the 80C88 processor. I had never heard about this bug, and found no further information of it in the web. Thus, kind of a guess.</p>\n<p><strong>CHECK5</strong>: This one tests whether we have an 8086/80186 or an 8088/80188, i.e. 16-bit or 8-bit machine. And your suspicion was right, it is self-modifying code. The idea is whether the self-modified instruction has already been in the prefetch queue or not. This check is covered in /1/ and /2/ as well. I reproduce the comment from /1/.</p>\n<p>The author in /1/ describes it like this:</p>\n<blockquote>\n<p>\"Differentiating between 8088s and 8086s is trickier. The easiest way\n  I've found to do it is to modify code that's five bytes ahead of IP.\n  Since the prefetch queue of an 8088 is four bytes and the prefetch\n  queue of an 8086 is six bytes, an instruction five bytes ahead of IP\n  won't have any effect on an 8086 the first time around.\"</p>\n</blockquote>\n<p>As a reference, Intel writes in its manual /3/, p.3-2 \"Bus Interface Unit\":</p>\n<blockquote>\n<p>\"The 8088/188 istruction queue holds up to four bytes of instruction\n  stream, while the 8086/80186 queue can store up to six instruction\n  bytes.\"</p>\n</blockquote>\n<p>I won't reproduce the code from /1/ here (being very similar), but rather re-comment your code with some remarks which I hope explain the case.</p>\n<pre><code>check5:\n00000B74  push cs\n00000B75  pop es        ; Set ES to CS. (why not mov es,cs? /1/ uses mov ax, cs, mov es, ax)\n00000B76  std           ; Cause stosb to count backwards (di is decremented)\n00000B77  mov di,0xb88  ; di==offset of code tail to modify\n00000B7A  mov al,0xfb   ; is this just an STI opcode? ;IMO yes, /1/ uses 0x90 al==nop instruction opcode\n00000B7C  mov cx,0x3    ; Set for 3 repetitions\n00000B7F  cli           ; are interrupts undesired? Yes, I remember having read somewhere (no quote though) \n                        ; that the next instruction can be interrupted, without the cli. \n                        ; This of course would spoil the trick.\n00000B80  rep stosb     ; write 3 bytes, backwards from Addr 0xb88\n                        ; !!! 5 bytes down is the critical instruction \n                        ; which will be either already in the queue (8086/186) or not (8088/188)\n00000B82  cld           ; Clear the direction flag\n00000B83  nop          ; Three nops in a row\n00000B84  nop          ; provide dummy instructions\n00000B85  nop\n00000B86  inc dx        ; &lt;&lt;&lt;=== This instruction is executed ONLY in the 8086/186 case. \n                        ; In the 80188/88 case, it is overwritten with STI\n00000B87  nop           ; dummy instruction\n00000B88  sti           \n</code></pre>\n<p>As your return register dx came with a value of 4 from CHECK3, it will after CHECK5 have a value of 5 in the 16-Bit case.</p>\n</div>",
            "votes": "10",
            "user": "josh",
            "time": "Sep 19, 2018 at 18:26",
            "is_accepted": true,
            "comments": [
                {
                    "user": "peter ferrie",
                    "text": "<span class=\"comment-copy\">Regarding check 4, if an interrupt occurs during the rep, the resume point loses one of the prefixes.  The quoted code is wrong, though, because the test requires multiple prefixes.  The original code is also wrong because the rep must be first to produce the effect (i.e. causing the rep to be lost and thus cx non-zero on exit).</span>",
                    "time": null
                },
                {
                    "user": "smitelli",
                    "text": "<span class=\"comment-copy\">I fixed the original code, thanks for pointing out that my disassembly wasn't accurate. I've been doing some more reading, and it appears the \"losing a prefix\" bug was something the 8086/88 had, but the NEC V20 and V30 clones handled it correctly. I'm still digging, though.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><strong>Check 2</strong>: While check 1 tests if the high-order bits of the flag word can be <em>cleared</em>, check 2 tests whether they can be <em>set</em>. On an 80286, these bits cannot be set in real mode, while on an 80386 they can.</p>\n<p><strong>Check 3</strong>: This is testing what kind of shifter the processor has. Some (the newer ones) have a <a href=\"https://en.wikipedia.org/wiki/Barrel_shifter\" rel=\"nofollow noreferrer\">barrel shifter</a> that effectively masks the shift count to the word size (and the use of 0x21 as the shift count suggests to me that the difference appeared in the post-80286 era). So a shift by 0x21 (33) gives the same result as a shift by 33 - 32 = 1. I don't know at which generation the barrel shifter appeared.</p>\n<p><strong>Check 4</strong>: I can't remember the details, but parts of it seem familiar to me. It's either got something to do with the repeat count being wrong after a maximal-length loop, or something with having a double instruction prefix that triggers a CPU bug. I think it's the latter, and the order of prefixes matters. When an interrupt handler returns, the instruction pointer is set to the wrong address and one or more prefixes are forgotten. Illustration: <a href=\"https://www.youtube.com/watch?v=6FC-tcwMBnU\" rel=\"nofollow noreferrer\">https://www.youtube.com/watch?v=6FC-tcwMBnU</a> Note that the code you have here actually has the es: override prefix first, so the loop should always complete! Could this be a CPU bug detection routine, that itself contains a bug?</p>\n<p><strong>Check 5</strong>: This is checking for an instruction cache that operates independently of any data cache. On an 80486 you can stomp all over the 16-byte window in which the processor is currently executing, and it will still execute the old contents that were loaded into the (separate) instruction cache. I think Pentium+ processors detect this overwriting and flush the instruction cache and prefetch queue. Even the earliest x86 processors have a prefetch queue long enough (except the 8088) to cover the instructions being overwritten. Conditions under which the new code gets executed: on a Pentium+ (IIRC), under a single-stepping debugger, in v86 mode where the CLI instruction doesn't really take effect, and an interrupt occurs.</p>\n</div>",
            "votes": "2",
            "user": "Bernd Jendrissek",
            "time": "Sep 19, 2018 at 19:53",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Peter Cordes",
                    "text": "<span class=\"comment-copy\">186 and 286 don't have a barrel shifter but still mask the shift count to limit how slow a shift can be when done iteratively!  It happens that masking the shift count is natural for a barrel shifter, too.  <a href=\"https://stackoverflow.com/q/61745808\">Why any modern x86 masks shift count to the 5 low bits in CL</a> explains this, and the fact that it was new in 186.</span>",
                    "time": null
                }
            ]
        }
    ]
}