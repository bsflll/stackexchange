{
    "title": "What are the results of this sbb instruction?",
    "link": "https://reverseengineering.stackexchange.com/questions/13133/what-are-the-results-of-this-sbb-instruction",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm doing a crackme to learn some reversing, and I stumbled upon this code generated by C++ MFC:</p>\n<pre><code>sbb eax, eax\nsbb eax, -1\ntest eax, eax\njz exit\n</code></pre>\n<p>Before that code a comparison is done, such as <code>cmp al, bl</code> where al and bl hold some value read from the serial</p>\n<p>The thing that confused me, is I figured that the cmp and two sbb instructions are equivalent to this pseudocode:</p>\n<pre><code>cmp a,b\neax=-1 if b&gt;a\neax=1 otherwise\n</code></pre>\n<p>However this confused me because eax can never be 0, so the zero flag will always be set.  Therefore, I figure the chunk of code </p>\n<pre><code>test eax, eax\njz exit\n</code></pre>\n<p>is useless because it does nothing- but how can this be? I don't think their C++ compiler would generate useless code like that</p>\n<p>Where am I wrong here?</p>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "1k",
    "tags": [
        "x86",
        "crackme"
    ],
    "user": "Jason",
    "time": "Jul 25, 2016 at 3:45",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<span class=\"comment-copy\">What is the code before first <code>sbb</code>?</span>",
            "time": null
        },
        {
            "user": "peter ferrie",
            "text": "<span class=\"comment-copy\">the zero flag will always be clear, rather than set, but you are correct that the branch will never be taken.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>are you sure it was compiler generated ?<br/>\nmay be it was hand crafted or deliberately coded like wise \nmay be it checks the sign flag further down in the jz path \nmay be red herring ? </p>\n<p>well whatever it requires more info \nbased on the info provided only thing that pops up is a check for sign flag further down the path </p>\n<p>here is a small compilable c code that shows what flags and results are for the operations in the query </p>\n<pre><code>#include &lt;stdio.h&gt;\nint helper (unsigned char a , unsigned char b )\n{\n    unsigned char res = 0;\n    unsigned char flag = 0;\n    __asm\n    {\n        xor eax,eax\n        xor ecx,ecx\n        mov al,a        ;          = 0  1  2  3  4  5  6  7\n        mov cl,b        ;          = 4  4  4  4  4  4  4  4\n        cmp al,cl       ;cf        = 1  1  1  1  0  0  0  0\n        sbb eax,eax     ;x-x-cf    =-1 -1 -1 -1  0  0  0  0\n        sbb eax,-1      ;x-(-1)-cf =-1 -1 -1 -1  1  1  1  1\n        mov res,al      ;          = ---------\"\"-----------\n        pushfd\n        xor eax,eax\n        mov eax,dword ptr ss:[esp]\n        popfd\n        lahf\n        mov flag , al\n    }\n    bool zf = ((flag &amp; 64)==64);\n    bool sf = ((flag &amp; 128)==128);\n    bool cf = ((flag &amp; 1)==1);\n    printf(\"%2x %2x %2x %2x %2x %2x\\n\" ,a,b,res,zf,sf,cf);\n}\nint main (void)\n{\n    printf(\" a  b  r  z  s  c\\n\");\n    for (unsigned char i = 0; i &lt; 8 ;i++){\n        helper(i,4);\n    }\n    return 0;\n}\n</code></pre>\n<p>result</p>\n<pre><code>:\\&gt;dir /b &amp; cl /nologo runasm.cpp &amp; runasm.exe\nrunasm.cpp\nrunasm.cpp\n a  b  r  z  s  c\n 0  4 ff  0  1  1\n 1  4 ff  0  1  1\n 2  4 ff  0  1  1\n 3  4 ff  0  1  1\n 4  4  1  0  0  1\n 5  4  1  0  0  1\n 6  4  1  0  0  1\n 7  4  1  0  0  1\n</code></pre>\n</div>",
            "votes": "1",
            "user": "blabb",
            "time": "Jul 25, 2016 at 10:10",
            "is_accepted": true,
            "comments": []
        }
    ]
}