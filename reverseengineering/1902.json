{
    "title": "Why are special tools required to ascertain the differences between two related binary code files?",
    "link": "https://reverseengineering.stackexchange.com/questions/1902/why-are-special-tools-required-to-ascertain-the-differences-between-two-related",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>How comes that text diffing tools like <code>diff</code>, <code>kdiff3</code> or even more complex ones usually fail at highlighting the differences between two disassemblies in textual form - in particular two <em>related</em> binary executable files such as different versions of the same program?</p>\n<p>This is the question <a href=\"https://reverseengineering.stackexchange.com/users/107/gilles\">Gilles</a> asked <a href=\"https://reverseengineering.stackexchange.com/questions/1879/\">over here</a> in a comment:</p>\n<blockquote>\n<p>Why is diff/meld/kdiff/... on the disassembly not satisfactory?</p>\n</blockquote>\n<p>I thought this question deserves an answer, <a href=\"http://blog.stackoverflow.com/2011/07/its-ok-to-ask-and-answer-your-own-questions/\">so I'm giving an answer Q&amp;A style</a>, because it wouldn't fit into a 600 character comment for some strange reason ;)</p>\n<p><strong>Please don't miss out on <a href=\"https://reverseengineering.stackexchange.com/a/1907/245\">Rolf's answer</a>, though!</strong></p>\n</div>",
    "votes": "27",
    "answers": 3,
    "views": "4k",
    "tags": [
        "tools",
        "disassembly",
        "assembly",
        "bin-diffing"
    ],
    "user": "0xC0000022L",
    "time": "Apr 13, 2017 at 12:49",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<h1>Index (shortened)</h1>\n<ul>\n<li>Gentle Intro - binary executable code, how does it look?</li>\n<li>Why it is a hard task to compare binary executable code?</li>\n<li>Conclusion</li>\n<li>Solutions</li>\n<li>TL;DR</li>\n</ul>\n<p><strong>TL;DWTR (too long, don't want to read):</strong> skip ahead to the section <em>Why it is a hard task to compare binary executable code?</em> if you feel comfortable with the basics around assembly and disassembly. Alternatively skip to the bottom of this answer (<em>TL;DR</em>).</p>\n<h1>Gentle Intro - binary executable code, how does it look?</h1>\n<p>Binary executable code is made for computers to read, this is why it is commonly referred to as <a href=\"https://en.wikipedia.org/wiki/Machine_code\" rel=\"noreferrer\">machine code</a>. This means it is binary \"data\" that is usually represented as <a href=\"https://en.wikipedia.org/wiki/Hexadecimal\" rel=\"noreferrer\">hexadecimal numbers</a> to the naked eye. A category of <a class=\"post-tag\" href=\"/questions/tagged/tools\" rel=\"tag\" title=\"show questions tagged 'tools'\">tools</a> named \"hex editors\" exists for this task.</p>\n<p>Here's how this commonly looks, using <a href=\"http://hte.sourceforge.net/\" rel=\"noreferrer\">HTE</a> for the screenshot:</p>\n<p><img alt=\"HT Editor\" src=\"https://i.sstatic.net/gKhUF.png\"/></p>\n<p>The reason this is so convenient is because each hex digit represents exactly one nibble, that is 4 bits. So two hex digits can be used to represent a single 8-bit byte (the most common type of byte). Then showing them in multiples of 16 bytes per line has the additional advantage of making it easier to read the hexadecimal offset (given as 8-digit hexadecimal number in front of the hex bytes in the screenshot above), because decimal <code>16</code> is <code>0x10</code>. The most common notations for hexadecimal numbers are:</p>\n<ul>\n<li>prefix <code>0x</code>: e.g. <code>0x10</code> (C and related languages)</li>\n<li>prefix <code>$</code>: e.g. <code>$10</code> (Pascal, Delphi)</li>\n<li>suffix <code>h</code>: e.g. <code>10h</code> (assembly language)</li>\n</ul>\n<p>Side-note: the line between code and data is a thin one and disassemblers sometimes struggle to identify the bytes in a binary file as one or the other, although heuristics can be applied to help in the process of identification.</p>\n<h2>Assembly</h2>\n<p>Aside from the \"raw\" form of hexadecimal numbers there is also the human-readable representation known as <a href=\"https://en.wikipedia.org/wiki/Assembly_language\" rel=\"noreferrer\">assembly language</a>. This is a <a href=\"https://en.wikipedia.org/wiki/Mnemonic\" rel=\"noreferrer\">mnemonic</a> form of the binary instructions (or opcodes) and usually represents them 1:1 with very minor abstractions. The notable exception to this are macro assemblers such as <a href=\"http://www.microsoft.com/en-us/download/details.aspx?id=12654\" rel=\"noreferrer\">Microsoft's MASM</a> which provide a higher levels of abstraction as a convenience.</p>\n<p>Side-note: the program that digests assembly language code (also \"assembly code\" or \"assembler code\") is called an <strong>assembler</strong>.</p>\n<p>Depending on the type of processor and the exact architecture, various flavors of assembly language exist. For the scope of this question we'll stick with the <a href=\"https://en.wikipedia.org/wiki/IA-32\" rel=\"noreferrer\">IA-32 architecture</a> - also known as x86 (32bit, <a class=\"post-tag\" href=\"/questions/tagged/x86\" rel=\"tag\" title=\"show questions tagged 'x86'\">x86</a>), because its origins lie with the 8088 and 8086 processors, with subsequent processor (CPU) models being numbered <code>80x86</code>, where <code>x</code> was a one-digit number. Starting with the 80586 Intel departed from that naming scheme as they introduced the Pentium.</p>\n<p>Nevertheless, it is good to know that two main processor architectures exist: <a href=\"https://en.wikipedia.org/wiki/Complex_instruction_set_computing\" rel=\"noreferrer\">CISC</a> (68k, x86, x86-64) and <a href=\"https://en.wikipedia.org/wiki/Reduced_instruction_set_computing\" rel=\"noreferrer\">RISC</a> (SPARC, MIPS, PPC), whereas the aficionados of one or the other have claimed victory for their preferred architecture at one time or another, both still exist to this very day, although at the microcode level one could even argue CISC architectures to be RISC \"internally\". That said, x86 <em>is</em> a CISC architecture.</p>\n<p>Just to give you glimpse of what RISC and CISC look like in comparison, let's look at a few basic x86 and <a href=\"https://en.wikipedia.org/wiki/MIPS_architecture\" rel=\"noreferrer\">MIPS instructions</a>:</p>\n<pre><code> x86          |    MIPS              | Meaning\n-----------------------------------------------\n mov          | lb, lw, sb, move     | copy/\"move\" value from/to register/memory location\n jmp, jz, jnz | j/b, beq, beqz, bgez | jump unconditionally or on condition\n call         | jal                  | call other routine / jump and link\n</code></pre>\n<p>What hopefully becomes clear at first glance (line with <code>mov</code>) is the fact that in MIPS you heave a much larger number of very basic instructions than x86, which is the gist of the CISC versus RISC paradigm. Another thing is that we see how MIPS uses <code>j</code> and <code>b</code> as the mnemonic prefix for jump and branch (the difference being generally the distance these \"jumps\" can cover), whereas x86 uses also <code>j</code> as in <code>jmp</code> (unconditional jump), <code>jnz</code> (jump if not zero[-flag set]) but also has a dedicated <code>call</code> opcode which MIPS to my knowledge doesn't have - the closest approximation probably being <code>jal</code> (jump and link) which also stores the <a href=\"https://en.wikipedia.org/wiki/Program_counter\" rel=\"noreferrer\">program counter</a> in a register as opposed to x86's <code>call</code>, though, which stores it on the stack.</p>\n<p>In CISC you can do a relatively complex operation with a single instruction, where in RISC you often need several instructions to express the same thing. In fact assemblers for RISC architectures tend to have so-called pseudo-instructions which combine oft-used combinations of instructions, but which get translated to individual RISC instructions during the translation phase.</p>\n<p>An example would be the <code>ror</code> (bit-rotate right) instruction. On an x86 (CISC) this is an opcode in its own right with the <code>ror</code> mnemonic. On MIPS (RISC) this is a pseudo-instruction if and when the assembler offers it and it gets translated as follows (bit-rotate the value in register <code>$t2</code> by one bit and store result in <code>$t2</code> again):</p>\n<pre><code>ror $t2, $t2, 1    --&gt;   sll $1 , $10, 31  (bit-shift $10 left by 31, store in $1)\n                         srl $10, $10, 1   (bit-shift $10 right by 1, store in $10)\n                         or  $10, $10, $1  (bit-wise or $1 and $10)\n</code></pre>\n<p>This example is taken from the book referenced a bit further down from here (<em>MIPS resources</em>), page 370.</p>\n<p>However, we won't dig further into assembly language <em>basics</em> and instead focus on answering the question. I think it is not necessary to understand much more than the most fundamental facts to understand why simple and even complex diff tools fail at showing the differences of binary executable files.</p>\n<h3>Compilers and assembly language</h3>\n<p><a href=\"https://en.wikipedia.org/wiki/Compiler\" rel=\"noreferrer\">Compilers</a> (<a class=\"post-tag\" href=\"/questions/tagged/compilers\" rel=\"tag\" title=\"show questions tagged 'compilers'\">compilers</a>) convert code constructs usually written by humans or machines into machine code [*]. The usual translation is to translate the human-readable source code into an intermediate form which gets then optimized and after optimization translated to assembly language which in turn gets translated to machine code. This is shown beautifully in the Wikipedia article above, with the diagram I am reproducing here below:</p>\n<p><img alt=\"How a compiler works\" src=\"https://i.sstatic.net/aHGlr.png\"/></p>\n<p>The gist is, that compilers usually have an assembler somewhere in their back end, even though you may never get to see the actual assembly language instructions yourself. If you wanted to get it, you would use:</p>\n<ul>\n<li>With GCC: <code>gcc -S ...</code> (AT&amp;T syntax) or <code>gcc -masm=intel -S ...</code> (Intel syntax)</li>\n<li>With Microsoft Visual C++: <code>cl.exe /Fa ...</code></li>\n</ul>\n<p>[*] this is not the entire truth, as there are compilers which will create an intermediate <a href=\"https://en.wikipedia.org/wiki/Byte_code\" rel=\"noreferrer\">byte code</a> which then later gets translated further into machine code native to the CPU it is running on or interpreted on-the-fly. But for the scope of this answer we'll consider compilers to be the entities that convert human-readable high-level language source code into machine code through a number of processing stages, one of which involves assembly code.</p>\n<p>NB: some compilers, such as Embarcadero Delphi will hide the different stages from you and present the process from compiling to linking as one opaque step. This can cause some confusion in Delphians attempting to learn C/C++ which <em>expose</em> the different steps.</p>\n<h3>Intel versus AT&amp;T syntax</h3>\n<p>For x86 there exist two competing syntax variants. The AT&amp;T syntax is favored in the *nix world and by <a href=\"https://en.wikipedia.org/wiki/GNU_Assembler\" rel=\"noreferrer\">GASM</a>, Intel in the Windows world and most disassemblers and assemblers. Consider this simple C program:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(\"Hello world!\\n\");\n    return 0;\n}\n</code></pre>\n<p>... and the translations with the AT&amp;T (<code>gcc -S hello.c</code> or explicitly <code>gcc -masm=att -S hello.c</code>) and Intel (<code>gcc -masm=intel -S hello.c</code>) syntax respectively:</p>\n<pre><code> AT&amp;T                        |  Intel\n------------------------------------------------------------------------\n.LC0:                        | .LC0:\n    .string \"Hello world!\"   |     .string \"Hello world!\"\n    .text                    |     .text\n.globl main                  | .globl main\n    .type   main, @function  |     .type   main, @function\nmain:                        | main:\n    pushl   %ebp             |     push    ebp\n    movl    %esp, %ebp       |     mov ebp, esp\n    andl    $-16, %esp       |     and esp, -16\n    subl    $16, %esp        |     sub esp, 16\n    movl    $.LC0, (%esp)    |     mov DWORD PTR [esp], OFFSET FLAT:.LC0\n    call    puts             |     call    puts\n    movl    $0, %eax         |     mov eax, 0\n    leave                    |     leave\n    ret                      |     ret\n</code></pre>\n<p>You'll notice how the syntax differs. Registers in AT&amp;T syntax are denoted with the <code>%</code>, literal values with <code>$</code> and the position of source and destination register is the inverse of the Intel syntax. Furthermore some of the mnemonics differ (<code>movl</code> instead of <code>mov</code>). In Intel syntax the size of the operands helps to infer the intended operation - in case of registers this is made explicit by using EAX, AX and AL/AH respectively to denote the <code>DWORD</code> (32bit), <code>WORD</code> (16bit) and <code>BYTE</code> (8bit) sizes. However, the line:</p>\n<pre><code>mov DWORD PTR [esp], OFFSET FLAT:.LC0\n</code></pre>\n<p>shows neatly how you have to be explicit about the size of memory locations to get it right. The AT&amp;T <code>movl</code> mnemonic implies this because of its inherent meaning of \"move long\" (32bit here), so no need to mention that we are accessing a <code>DWORD</code> other than in the <code>l</code> in <code>movl</code>.</p>\n<p><strong>Please note:</strong> I trimmed some irrelevant parts at the top and the bottom of the generated assembly code for brevity.</p>\n<h3>MIPS resources</h3>\n<p>For the inclined reader I would recommend getting a copy of the excellent, albeit pricey:</p>\n<ul>\n<li>\"Introduction to Assembly Language Programming\", 2nd ed., by Sivarama P. Dandamudi, Springer 2004/2005 (ISBN 978-0-387-20636-3)</li>\n</ul>\n<p>If you want to experiment with MIPS, you can get <a href=\"http://spimsimulator.sourceforge.net/\" rel=\"noreferrer\">SPIM</a>, refer to its documentation or simply use a search engine to find useful information such as this <a href=\"http://people.cs.pitt.edu/~xujie/cs447/Mips/sub.html\" rel=\"noreferrer\">Quick Tutorial</a>.</p>\n<h3>x86 resources</h3>\n<ul>\n<li>The book mentioned above in the MIPS resources also discusses x86 assembly</li>\n<li>Randall Hyde's <a href=\"http://www.plantation-productions.com/Webster/www.artofasm.com/index.html\" rel=\"noreferrer\">\"Art of Assembly\" book</a></li>\n<li><a href=\"http://www.woodmann.com/RCE-CD-SITES/Iczelion/\" rel=\"noreferrer\">Iczelion's old website</a></li>\n</ul>\n<p>Again, use a search engine to find more information or consult the documentation of your favorite assembler, such as <a href=\"http://nasm.us/\" rel=\"noreferrer\">NASM</a>.</p>\n<h2>Disassembly</h2>\n<p>The process of translating the binary machine language back to a mnemonic representation, usually 1:1, is called <strong>disassembling</strong> or <strong>disassembly</strong>. The result of the process is commonly referred to as <strong>disassembly</strong> as well.</p>\n<p>The tool used for the process is called a <strong>disassembler</strong>.</p>\n<p>Since this is mostly a 1:1 process just like the reverse (assembly to machine code) there is no need to go into much more detail. There is one big difference between hand-written or compiler-generated assembly versus disassembly of the resulting binary code, and we'll see that a bit better by comparing the output of a disassembler and a compiler.</p>\n<p>So without much further ado let's go to a practical example that shows why diffing is hard.</p>\n<h1>Why it is a hard task to compare binary executable code?</h1>\n<p><strong>Note:</strong> For the remainder of this answer we'll use the Intel syntax for the assembly code. We'll also have some redundant parts of GCCs output removed for brevity.</p>\n<h2>Sample program - first iteration</h2>\n<h3>C version</h3>\n<p>In our first iteration we have the following C code (I named it <code>ptest1.c</code>):</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint syntax_help(int argc)\n{\n        return 20 + argc;\n}\n\nint main(int argc, char **argv)\n{\n        if (argc &lt; 3)\n                return syntax_help(argc);\n        else if (argc == 3)\n                return 42;\n        // else ...\n        return 0;\n}\n</code></pre>\n<h3>Assembly language version (with GCC, Intel syntax)</h3>\n<p>... compiling this into assembly with <code>gcc -O0 -masm=intel -S -o ptest1.asm ptest1.c</code> gives us:</p>\n<pre><code>.globl syntax_help\n        .type   syntax_help, @function\nsyntax_help:\n        push    ebp\n        mov     ebp, esp\n        mov     eax, DWORD PTR [ebp+8]\n        add     eax, 20\n        pop     ebp\n        ret\n        .size   syntax_help, .-syntax_help\n.globl main\n        .type   main, @function\nmain:\n        push    ebp\n        mov     ebp, esp\n        sub     esp, 4\n        cmp     DWORD PTR [ebp+8], 2\n        jg      .L4\n        mov     eax, DWORD PTR [ebp+8]\n        mov     DWORD PTR [esp], eax\n        call    syntax_help\n        jmp     .L5\n.L4:\n        cmp     DWORD PTR [ebp+8], 3\n        jne     .L6\n        mov     eax, 42\n        jmp     .L5\n.L6:\n        mov     eax, 0\n.L5:\n        leave\n        ret\n</code></pre>\n<h2>Sample program - second iteration</h2>\n<p>Now let us modify the program a little and then assemble it again, just to see how it looks.</p>\n<h3>C version</h3>\n<pre><code>#include &lt;stdio.h&gt;\n\nint syntax_help(int argc)\n{\n        switch (argc)\n        {\n        case 0:\n                return -1;\n        case 1:\n                return 23;\n        default:\n                return 20 + argc;\n        }\n}\n\nint main(int argc, char **argv)\n{\n        if (argc &lt; 5)\n                return syntax_help(argc);\n        else if (argc == 5)\n                return 42;\n        // else ...\n        return 0;\n}\n</code></pre>\n<p>As you can see the two instances of <code>3</code> in <code>main</code> changed to <code>5</code> and we tinkered a bit with the \"logic\" in <code>syntax_help</code>. Clearly this is a contrived example, but then that's the exact point.</p>\n<h3>Assembly language version (same options as above)</h3>\n<pre><code>.globl syntax_help\n        .type   syntax_help, @function\nsyntax_help:\n        push    ebp\n        mov     ebp, esp\n        mov     eax, DWORD PTR [ebp+8]\n        test    eax, eax\n        je      .L3\n        cmp     eax, 1\n        je      .L4\n        jmp     .L7\n.L3:\n        mov     eax, -1\n        jmp     .L5\n.L4:\n        mov     eax, 23\n        jmp     .L5\n.L7:\n        mov     eax, DWORD PTR [ebp+8]\n        add     eax, 20\n.L5:\n        pop     ebp\n        ret\n        .size   syntax_help, .-syntax_help\n.globl main\n        .type   main, @function\nmain:\n        push    ebp\n        mov     ebp, esp\n        sub     esp, 4\n        cmp     DWORD PTR [ebp+8], 4\n        jg      .L9\n        mov     eax, DWORD PTR [ebp+8]\n        mov     DWORD PTR [esp], eax\n        call    syntax_help\n        jmp     .L10\n.L9:\n        cmp     DWORD PTR [ebp+8], 5\n        jne     .L11\n        mov     eax, 42\n        jmp     .L10\n.L11:\n        mov     eax, 0\n.L10:\n        leave\n        ret\n</code></pre>\n<p>That's a mouthful. Now let's dig into one difference - aside from the \"optimization\" aspect - between this and a potential human-written piece of assembly that does the same. Here's what a human-written version might look like:</p>\n<pre><code>.globl syntax_help\n    .type   syntax_help, @function\nsyntax_help:\n    push    ebp\n    mov ebp, esp\n    mov eax, DWORD PTR [ebp+8]\n    test    eax, eax\n    je  .zero_args\n    cmp eax, 1\n    je  .one_arg\n    jmp .return_20plus\n.zero_args:\n    mov eax, -1\n    jmp .exit_help\n.one_arg:\n    mov eax, 23\n    jmp .exit_help\n.return_20plus:\n    mov eax, DWORD PTR [ebp+8]\n    add eax, 20\n.exit_help:\n    pop ebp\n    ret\n    .size   syntax_help, .-syntax_help\n.globl main\n    .type   main, @function\nmain:\n    push    ebp\n    mov ebp, esp\n    sub esp, 4\n    cmp DWORD PTR [ebp+8], 4\n    jg  .return_42\n    mov eax, DWORD PTR [ebp+8]\n    mov DWORD PTR [esp], eax\n    call    syntax_help\n    jmp .exit\n.return_42:\n    cmp DWORD PTR [ebp+8], 5\n    jne .return_0\n    mov eax, 42\n    jmp .exit\n.return_0:\n    mov eax, 0\n.exit:\n    leave\n    ret\n</code></pre>\n<p>Anyone who has ever written assembly code will inevitably notice how I am not declaring variables (<code>db</code>, <code>dw</code>, <code>dd</code>) here. This would be the normal course of action, but of course here I was merely showing that we humans tend to give symbolic names to code locations (and variables). If you hand write assembly, it would look still different, I merely adjusted the code to look a bit more like what a human might write (i.e. it's not perfect and certainly not \"hand-optimized\"). The compiler will stubbornly and efficiently tack a number on some kind of lettered prefix and be done with it. Let's also create a possible human-written version of the first iteration, using the same names:</p>\n<pre><code>.globl syntax_help\n    .type   syntax_help, @function\nsyntax_help:\n    push    ebp\n    mov ebp, esp\n    mov eax, DWORD PTR [ebp+8]\n    add eax, 20\n    pop ebp\n    ret\n    .size   syntax_help, .-syntax_help\n.globl main\n    .type   main, @function\nmain:\n    push    ebp\n    mov ebp, esp\n    sub esp, 4\n    cmp DWORD PTR [ebp+8], 2\n    jg  .return_42\n    mov eax, DWORD PTR [ebp+8]\n    mov DWORD PTR [esp], eax\n    call    syntax_help\n    jmp .exit\n.return_42:\n    cmp DWORD PTR [ebp+8], 3\n    jne .return_0\n    mov eax, 42\n    jmp .exit\n.return_0:\n    mov eax, 0\n.exit:\n    leave\n    ret\n</code></pre>\n<h2>Comparing compiler-generated assembly code</h2>\n<p>Here's the output of <code>diff ptest1.asm ptest2.asm</code> (the compiler-generated form):</p>\n<pre><code>1c1\n&lt;       .file   \"ptest1.c\"\n---\n&gt;       .file   \"ptest2.c\"\n9a10,22\n&gt;       test    eax, eax\n&gt;       je      .L3\n&gt;       cmp     eax, 1\n&gt;       je      .L4\n&gt;       jmp     .L7\n&gt; .L3:\n&gt;       mov     eax, -1\n&gt;       jmp     .L5\n&gt; .L4:\n&gt;       mov     eax, 23\n&gt;       jmp     .L5\n&gt; .L7:\n&gt;       mov     eax, DWORD PTR [ebp+8]\n10a24\n&gt; .L5:\n20,21c34,35\n&lt;       cmp     DWORD PTR [ebp+8], 2\n&lt;       jg      .L4\n---\n&gt;       cmp     DWORD PTR [ebp+8], 4\n&gt;       jg      .L9\n25,28c39,42\n&lt;       jmp     .L5\n&lt; .L4:\n&lt;       cmp     DWORD PTR [ebp+8], 3\n&lt;       jne     .L6\n---\n&gt;       jmp     .L10\n&gt; .L9:\n&gt;       cmp     DWORD PTR [ebp+8], 5\n&gt;       jne     .L11\n30,31c44,45\n&lt;       jmp     .L5\n&lt; .L6:\n---\n&gt;       jmp     .L10\n&gt; .L11:\n33c47\n&lt; .L5:\n---\n&gt; .L10:\n</code></pre>\n<p>Not exactly helpful to understanding the differences, is it?</p>\n<p><a href=\"http://winmerge.org/\" rel=\"noreferrer\">WinMerge</a> provides a more visual result. Chaos ensues ...</p>\n<p><img alt=\"WinMerge diff of ptest1.asm and ptest2.asm\" src=\"https://i.sstatic.net/QCNpW.png\"/></p>\n<p>NB: I decided to not doctor a full height screenshot, instead pay attention to the left pane which highlights the differences (yellow) and missing blocks (gray) and moved blocks (brown...ish).</p>\n<h2>Comparing \"human-written\" assembly code</h2>\n<p>Here's the output of <code>diff ptest1.asm-human ptest2.asm-human</code> (\"human-written\" form):</p>\n<pre><code>6a7,19\n&gt;       test    eax, eax\n&gt;       je      .zero_args\n&gt;       cmp     eax, 1\n&gt;       je      .one_arg\n&gt;       jmp     .return_20plus\n&gt; .zero_args:\n&gt;       mov     eax, -1\n&gt;       jmp     .exit_help\n&gt; .one_arg:\n&gt;       mov     eax, 23\n&gt;       jmp     .exit_help\n&gt; .return_20plus:\n&gt;       mov     eax, DWORD PTR [ebp+8]\n7a21\n&gt; .exit_help:\n17c31\n&lt;       cmp     DWORD PTR [ebp+8], 2\n---\n&gt;       cmp     DWORD PTR [ebp+8], 4\n24c38\n&lt;       cmp     DWORD PTR [ebp+8], 3\n---\n&gt;       cmp     DWORD PTR [ebp+8], 5\n</code></pre>\n<p>Whoa, that's actually almost readable. Use <code>colordiff</code> and it's useful.</p>\n<p>The respective visual comparison in WinMerge looks downright readable:</p>\n<p><img alt=\"WinMerge diff of ptest1.asm-human and ptest2.asm-human\" src=\"https://i.sstatic.net/qqPY9.png\"/></p>\n<h2>Interlude - basic blocks</h2>\n<p>A disassembler can only be smart to a certain extent, because it's a program. Even IDA Pro, hands down the most advanced disassembler as of this writing, will not be able to guess everything right - e.g. when distinguishing code or data. But the more sophisticated tools do a <em>pretty</em> good job at it. And IDA adds the <strong>I</strong> as <strong>interactive</strong>.</p>\n<p>One thing disassemblers encounter are what assembly programmers is known as <strong>labels</strong> and <strong>(sub)routines</strong>.</p>\n<p>Labels, although they exist in C and are (rightly) frowned upon together with <code>goto</code>, also exist in higher level language, but tend to cover a somewhat different concept. Perhaps the closest to the assembly language concept were the labels in the good old days of <a href=\"https://en.wikipedia.org/wiki/BASIC\" rel=\"noreferrer\">BASIC</a>. When you compile C into assembly code, however, every condition gets translated into a conditional or unconditional jump (<code>jmp</code>, <code>je</code>, <code>jg</code>, <code>jne</code> in the above compiler-generated code). The jump targets are referred to as <strong>labels</strong>. The jumps are the places where the code <strong>branches</strong> conditionally or unconditionally.</p>\n<p>The closest corresponding concept to a routine would be a function in C or the <code>procedure</code>/<code>function</code> in Pascal or the <code>sub</code> in BASIC.</p>\n<p>More or less each of the chunks of code between two branching instructions, other than <code>call</code>, are called <strong>basic blocks</strong>. In IDA Pro this is neatly visualized in the graph view (can be toggled with flat view via default <kbd>Space</kbd>):</p>\n<p><img alt=\"IDA Pro graph view demonstrating a visualization of basic blocks\" src=\"https://i.sstatic.net/Y8Puh.png\"/></p>\n<p>Each of the blocks linked by the arrows in the main IDA-view would be a <strong>basic block</strong>.</p>\n<h2>Again, why it is a hard task to compare binary executable code?</h2>\n<p>By now you should have a faint idea what makes the comparison hard, but let's go the extra mile. Let's switch from comparing the compiler-generated and \"human-written\" assembly code to actual disassembly.</p>\n<p>As before we will stick to the gist of it.</p>\n<h2>Compiler-generated versus disassembly</h2>\n<p>But just to mention it, in the disassembly you have the result after the <a href=\"https://en.wikipedia.org/wiki/Linker_%28computing%29\" rel=\"noreferrer\">linker</a> <em>mangled</em> it. The compiler-generated assembly from before contained merely the code <em>we</em> had written in the sample program.</p>\n<p>Just to give you an idea, I generated an <code>.asm</code> file using IDA, stripped it down to everything without comments and empty lines and still ended up with 362 lines, as opposed to 52 lines in the original compiler-generated assembly which included meta-data used by the linker. This whopping difference can of course be attributed to the linker adding all kinds of code required to initialize the executable. In fewer words: it's boiler plate code the compiler (or more precisely its linker) adds.</p>\n<p>For this comparison I am going to leave out this boiler plate code entirely, although obviously this only adds to the complexity a <code>diff</code> tool will encounter when comparing binary executable code.</p>\n<p>Unlike in the IDA screenshot above, which shows <code>ptest2.c</code> disassembled, in reality you will mostly have to work without <a href=\"https://en.wikipedia.org/wiki/Debug_symbol\" rel=\"noreferrer\">debug symbols</a>. This means the names such as <code>main</code> and <code>syntax_help</code> will no longer exist. Instead disassemblers such as IDA Pro mostly resort to naming the routines after their offset (e.g. <code>sub_80483DB</code>). It applies the same for labels (i.e. naming those <code>loc_80483F4</code> or <code>locret_something</code>). Of course the reverse engineer is free to change these names to something more readable/recognizable for herself. But the default names still depend on the offset.</p>\n<p>In fact the disassembler will have a hard time to identify the <code>main</code> function, because the aforementioned boiler plate code tends to come <em>before</em> it when looking at it starting from the entry point of the executable. Here's what IDA shows you if there are no symbols available to the compiled <code>ptest2.c</code> from before (i.e. ran <code>strip -s ...</code>):</p>\n<p><img alt=\"IDA Pro showing the entry point of compiled &lt;code&gt;ptest2.c&lt;/code&gt;\" src=\"https://i.sstatic.net/XTlLt.png\"/></p>\n<p>Now let's look at the entry point for the compiled (and stripped) <code>ptest1.c</code> as well:</p>\n<p><img alt=\"IDA Pro showing the entry point of compiled &lt;code&gt;ptest2.c&lt;/code&gt;\" src=\"https://i.sstatic.net/o0tAE.png\"/></p>\n<p>Do you notice the difference? It's subtle, but let me put them side to side for you:</p>\n<p><img alt=\"Side by side comparison\" src=\"https://i.sstatic.net/L5jXL.png\"/></p>\n<p>Yes, the highlighted lines ... ooh the offsets differ. What does that mean?</p>\n<p>Well, it means that the symbolic names IDA Pro assigns to routines and also to labels (i.e. basic blocks) will differ based on the offset of these entities within the file. </p>\n<p>This is very similar indeed to what we encountered before with the compiler-generated assembly code and the numbered label names.</p>\n<h3>Using a simpler disassembler</h3>\n<p>Let's compare the relevant pieces of code created by a simpler disassembler in a text differ.</p>\n<p>Using <code>objdump -M intel -d ...</code> and then getting rid of the leading offsets and spaces we get this for the relevant parts in WinMerge:</p>\n<p><img alt=\"WinMerge of the disassembly created with objdump\" src=\"https://i.sstatic.net/nn9X8.png\"/></p>\n<p>Full commands were:</p>\n<pre><code>objdump -M intel -d ptest1.stripped|grep '^ 80'|cut -f 2- -d ':'|sed 's/^\\s*//g'\nobjdump -M intel -d ptest2.stripped|grep '^ 80'|cut -f 2- -d ':'|sed 's/^\\s*//g'\n</code></pre>\n<h1>Conclusion</h1>\n<p>This means text diffing tools such as <code>diff</code>, <code>kdiff3</code>, <code>WinMerge</code> and many others will have a hard time comparing disassemblies unless the reverse engineer took the time to rename all routines and labels to something not based on the offset.</p>\n<p>In fact this becomes an almost insurmountable task when facing a disassembly in textual form. The internal form IDA Pro keeps of the disassembly is much more suitable.</p>\n<p>In text form every single changed offset - and there will be loads of those - will draw your attention because it is a difference to a text differ.</p>\n<h1>Solutions</h1>\n<p>Not that we know the problem, what can we do about it?</p>\n<p>Basic blocks are the answer to the problem at hand. Tools like <a href=\"http://www.darungrim.org\" rel=\"noreferrer\">DarunGrim</a> (FLOSS), <a href=\"http://code.google.com/p/patchdiff2/\" rel=\"noreferrer\">patchdiff2</a> (FLOSS) and Bindiff (commercial) use IDA's knowledge about basic blocks to build graphs. These graphs can then be used to identify similar and different blocks. With the abstraction in the form of a graph the visualization can be superimposed on the respective view inside IDA or a specialized view can be offered.</p>\n<p>As you see, when you export your disassembly to a text file, you are stripping a whole lot of contextual information from it which IDA keeps for you in its database. Instead draw from the information IDA already has and use it. Plugins and scripts allow you to reach into the guts of the IDA database and extract what treasures are in there to make sense of basic blocks in a way a text differ will never be able to.</p>\n<h2>Tools</h2>\n<p>For a listing of tools able to tackle the task, refer to the answers to the question which sparked <em>this</em> one:</p>\n<ul>\n<li><a href=\"https://reverseengineering.stackexchange.com/questions/1879\">how can I diff two x86 binaries at assembly code level?</a></li>\n</ul>\n<h2>Further reading</h2>\n<ul>\n<li><strong>Make sure to read <a href=\"https://reverseengineering.stackexchange.com/a/1907/245\">Rolf's answer</a> below!</strong></li>\n<li><a href=\"https://reverseengineering.stackexchange.com/a/1511/245\">How BinDiff works</a>, answer by newgre</li>\n<li><a href=\"http://www.darungrim.org/Presentations\" rel=\"noreferrer\">http://www.darungrim.org/Presentations</a></li>\n<li><a href=\"http://www.darungrim.org/Researches\" rel=\"noreferrer\">http://www.darungrim.org/Researches</a></li>\n</ul>\n<h1>TL;DR</h1>\n<p>The reason text differs are insufficient for handling textual disassembly is because the textual representation discards valuable information the disassembler collects during the process of disassembling. Also disassemblers name the code locations and variables after their offsets - changes to a program with subsequent recompilation <strong>will change virtually all offsets and therefore create a lot of noise</strong> in the textual representation. Text differs will point out every single one, making it impossible to find the <em>relevant</em> changes from the reverse engineer's point of view.</p>\n</div>",
            "votes": "44",
            "user": "Community",
            "time": "Apr 13, 2017 at 12:49",
            "is_accepted": true,
            "comments": [
                {
                    "user": "amccormack",
                    "text": "<span class=\"comment-copy\">I think stack exchange needs to make a <code>novelist</code> badge just for you. Good work.</span>",
                    "time": null
                },
                {
                    "user": "dyasta",
                    "text": "<span class=\"comment-copy\">Now THAT is an answer!</span>",
                    "time": null
                },
                {
                    "user": "jyz",
                    "text": "<span class=\"comment-copy\">Bookmarked. And probably gonna print it.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Most of the problems come into play due to the fact that small changes to the source code can result in large changes to the compiled binary.  In fact, <em>no changes</em> to the source code can still result in different binaries.</p>\n<p>Compiler optimizations will wreck your day if you want to compare binaries.  The worst-case scenario is if you have two binaries compiled with different compilers, or different revisions of a compiler, or the same revision of a compiler at different optimization settings.</p>\n<p>A few examples that come to mind:  </p>\n<ul>\n<li><p>Inlining.  This optimization can actually remove functions entirely, and can change the control flow graph of the optimized function.</p></li>\n<li><p>Instruction scheduling re-orders the instructions within a given basic block in order to minimize pipeline stalls.  This wreaks havoc on UNIX diff-style tools.</p></li>\n<li><p>Loop-invariant code motion.  This optimization can actually change the number of basic blocks within a function!  The same function compiled at different optimization levels can have a different control-flow signature.</p></li>\n<li><p>Intraprocedural register allocation.  Suppose that a function is changed by adding an if-statement somewhere that references some variable that was already defined within the function.  The act of using the variable again modifies the definition-use chains for the function's variables.  Now, when the compiler generates low-level code for a given function, it uses the use-def information to decide at each point which variables should be on the stack, and which ones should be placed in registers.  This is intraprocedural register allocation.  Therefore, it could turn out that simply adding one line of code results in the variables being held in different registers, and/or held on the stack instead of in registers (or vice versa) which obviously will affect what the compiled code looks like.</p></li>\n<li><p>Interprocedural optimizations such as \"interprocedural register allocation\" (IRA), interprocedural common subexpression elimination (ICSE), etc. drastically affect the layout of the compiled binary, and they are also sensitive to minute changes in the source code.  For example, IRA will manufacture novel calling conventions for functions that are not required to conform to standard calling conventions, e.g. because they are not exported from their containing module or library, and are never referenced via function pointer.  ICSE can remove portions of code from a given function.</p></li>\n<li><p>Profile-guided optimization (PGO).  Under this optimization, the compiler first produces a binary with extra code that computes statistics about the program's runtime behavior.  The programmer then subjects the instrumented code to \"a typical workload\" and computes statistics.  Then, the programmer recompiles the program, supplying those statistics to the compiler and telling it to generate code via PGO.  The compiler then dramatically changes the layout of the binary by ordering the code by how frequently each function executed, which paths through the function were the most common, etc.  Different training sets will produce different statistical profiles, and hence vastly different executables.</p></li>\n</ul>\n<p>This is not an exhaustive list.  Many other optimizations will plague you.  It's mostly because of compiler optimizations that UNIX diff-style tools have little utility in the binary comparison space.</p>\n</div>",
            "votes": "10",
            "user": "Rolf Rolles",
            "time": "Apr 23, 2013 at 5:15",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>One of things I do is to read the machine code and translate it back into IR pseudo opcodes sans any addressing address values, and then perform differences between those two pseudo-IR binaries after using this reduction method on each.  </p>\n</div>",
            "votes": "1",
            "user": "John Greene",
            "time": "May 11, 2020 at 18:31",
            "is_accepted": false,
            "comments": [
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">this would amount (roughly) to what tools like retdec are trying. And yes, this feasible nowadays (now look at the timestamp of my Q&amp;A, though). But the question was actually where this stems from. Still +1 from me, because it's a fair point. Btw, your answer could gain a lot by providing some more details ;)</span>",
                    "time": null
                },
                {
                    "user": "John Greene",
                    "text": "<span class=\"comment-copy\">Yep.  But often times we are in a hurry to see if an executable has been tampered with against our baseline set of executables and this aforementioned method helps us to zero into the afflicted blocks and/or function that had been repurposed, especially in the case that the executable maintained the same executable header checksum value.</span>",
                    "time": null
                }
            ]
        }
    ]
}