{
    "title": "Get interface definition of undocumented COM objects",
    "link": "https://reverseengineering.stackexchange.com/questions/19947/get-interface-definition-of-undocumented-com-objects",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have started exploring COM objects, initially I got to it from UAC bypass methods but I guess my question is general. The general question is: <strong>How can I get from (elevated) CLSID in the registry to calling the functions in the COM interface?</strong>. Explanation of the research I performed and my specific questions next. I will use IFileOperation COM (CLSID = 3AD05575-8857-4850-9277-11B85BDB8E09) and ICMLuaUtil COM (CLSID = 3E5FC7F9-9A51-4367-9063-A120244FBEC7) as an example in this post. </p>\n<p>COM objects are listed in the registry under <code>HKEY_CLASSES_ROOT\\CLSID</code>. The default value has the COM name and the server DLL file. </p>\n<p>Now, in order to list the interfaces associated with it I used <code>oleview</code>, for IFileOperation it showed all the interfaces but for ICMLuaUtil it showed only the . </p>\n<p>Even after I get the interface name, I have to get the function list and signatures, this can be extracted from the <code>idl</code> file. A great answer presented <a href=\"https://reverseengineering.stackexchange.com/questions/2822/com-interface-methods\">here</a> shows how to get from an interface name to its function signatures by examining the example code and searching for <code>idl</code> file with the same name as the imports in the <code>sdk</code> folder. I have tried applying similar approach with the two interfaces with partial success. </p>\n<ol>\n<li>For IFileOperation, the example source has 4 includes neither of which has exact same <code>idl</code> file in the sdk folder. So i search the content of all the files in the folder for the word <code>IFileOperation</code> which resulted in getting the desired file: <code>shobjidl_core</code>. </li>\n<li>Unfortunately I couldn't do the same thing with <code>ICMLuaUtil</code> as I don't know the interface name, I tried several name variations but got nothing. </li>\n</ol>\n<p>Other methods I tried are:</p>\n<ol>\n<li>Extracting all files from the DLLs I found in the registry (nothing there)</li>\n<li>COMViewer should present additional information but it didn't work on my Windows 10 machine (didn't start), even with compatibility mode.</li>\n</ol>\n<p>My question is how do I get from the (sometimes undocumented) COM objects to concrete interface definition so I could use it in my code? The <a href=\"https://github.com/hfiref0x/UACME\" rel=\"nofollow noreferrer\">UACMe</a> project has a concrete definition of the interface for <code>ICMLuaUtil</code>, so there must be a method to obtain it. What are the guidelines and steps to obtain those function signatures?</p>\n</div>",
    "votes": "4",
    "answers": 3,
    "views": "4k",
    "tags": [
        "windows",
        "dll",
        "functions",
        "com",
        "windows-10"
    ],
    "user": "Anton.P",
    "time": "Nov 22, 2018 at 19:50",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<span class=\"comment-copy\">Hi and welcome to RE.SE! I'm confused. One of the sentences trails off just like . And furthermore why do you think you need an interface <i>name</i>? IIDs/CLSIDs/GUIDs is all that COM will ever care about. It all starts with <code>IUnknown</code> and both the documentation (MSDN) as well as several books explain in great detail how to instantiate COM objects. However, those are all non-RCE topics. Whether there is an interface definition (IDL or otherwise) solely depends on the author. After all COM is <i>meant</i> to allow black-box objects to interact with each other. Only caller and callee need to know.</span>",
            "time": null
        },
        {
            "user": "Anton.P",
            "text": "<span class=\"comment-copy\">@0xC0000022L thanks for taking the time to understand the question. I do realize that functions which handle COMs (CoCreateInstance, CoGetObject..) require IIDs/CLSIDs only. Let me narrow the question, for <code>ICMLuaUtil</code>, where I got no interface name/idl file, how can I get the IID and how to figure out the method signatures for it? it was done before, and I wish to learn how to reproduce the results (<a href=\"https://github.com/hfiref0x/UACME/blob/62a42eb94c07a25979b525a77b5718158e8b5f0d/Source/Akagi/methods/hybrids.c#L2239\" rel=\"nofollow noreferrer\">github.com/hfiref0x/UACME/blob/â€¦</a>)</span>",
            "time": null
        },
        {
            "user": "Biswapriyo",
            "text": "<span class=\"comment-copy\">@Anton.P Do you have the basic knowledge of C++ class, constructor, destructor, inheritance? I want to add some info.</span>",
            "time": null
        },
        {
            "user": "Anton.P",
            "text": "<span class=\"comment-copy\">@Biswapriyo yes I am familiar with C++ (know it well and familiar with the concepts you listed), and I would be glad to get more info</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Now, this can't be a full-fledged answer from A to Z, unfortunately. But for COM there are only a few steps that are really specific to COM.</p>\n<p>The project you linked clearly has reverse-engineered the interfaces (<code>elvint.h</code>). What this means first and foremost is that the names of the interfaces needn't necessarily match what Microsoft called them (in your case they match, though). However, if the binaries implementing the respective COM interfaces or their proxy DLL are official system files, PDB files can be fetched for them and even though Microsoft has severely cut down on public symbols, this often allows you to assign more meaningful names to functions/methods.</p>\n<p>Of course the author(s) of the linked project already knew what they were looking for and it seems to be system components that somehow \"magically\" are able to circumvent the typical UAC elevation prompt even though one should expect them to show one.</p>\n<p>Now say they found that the Connection Manager configuration (related to <a href=\"https://docs.microsoft.com/en-us/windows/desktop/rras/remote-access-start-page\" rel=\"noreferrer\">RAS</a>) contained such functionality, they'd now go ahead and perform an action that you'd expect to require elevation but which doesn't. Then they'd look up the DLLs loaded into the process and either find an InProc server or a proxy leading them to an OutProc server.</p>\n<p>Failing the lookup step they could simply survey all the system DLLs, looking for the typical COM bunch of exported functions (the first being the most obvious):</p>\n<ul>\n<li><strong><code>DllGetClassObject</code></strong></li>\n<li><code>DllCanUnloadNow</code></li>\n<li><code>DllAddRef</code></li>\n<li><code>DllRelease</code></li>\n</ul>\n<p>... and then inspect the version info resource. With the <a href=\"https://github.com/erocarrera/pefile\" rel=\"noreferrer\"><code>pefile</code></a> module this becomes a simple Python scripting job. It's basically that first step you always have with RCE: intelligence gathering. It's not strictly RCE (as in sifting through or manipulating disassembly) but it's an intrinsic part of all the RCE jobs I've done so far.</p>\n<p>But in your case you already used oleview.exe and therefore knew the most important information:</p>\n<p><a href=\"https://i.sstatic.net/CwlCN.png\" rel=\"noreferrer\"><img alt=\"Information shown in cmlua.dll for ICMLuaUtil\" src=\"https://i.sstatic.net/CwlCN.png\"/></a></p>\n<p>... which is why I found your comment confusing:</p>\n<blockquote>\n<p>Unfortunately I couldn't do the same thing with <code>ICMLuaUtil</code> as I don't\n  know the interface name, I tried several name variations but got\n  nothing.</p>\n</blockquote>\n<p>Now having found <code>cmlua.dll</code> to be the DLL to implement our (COM) object of interest, we can go ahead and load that into IDA (or another disassembler) and we will get prompted to load the debug symbol from Microsoft's symbol servers.</p>\n<p>And once the symbols are loaded we get to see this:</p>\n<p><a href=\"https://i.sstatic.net/ibo7z.png\" rel=\"noreferrer\"><img alt=\"excerpt of IDA's understanding of the cmlua.dll functions with debug symbols applied\" src=\"https://i.sstatic.net/ibo7z.png\"/></a></p>\n<p><a href=\"https://github.com/hfiref0x/UACME/blob/62a42eb94c07a25979b525a77b5718158e8b5f0d/Source/Akagi/methods/elvint.h#L147\" rel=\"noreferrer\">Looks familiar?</a></p>\n<p>To get the IDL you need to match the vtable of the <code>CCMLuaUtil</code> class to the interface pointer its DLL returns when asked for that specific class. Looking into <code>DllGetClassObject</code> will enable you to figure out the IID.</p>\n<p>Now from here on this is going to be the same old grunt job of making sense of the disassembly (or the pseudo code if you can afford the decompiler plugin).</p>\n<hr/>\n<p>Now <strong>if</strong> we get lucky we can save a whole lot of time if the COM server (typically a DLL) in question contains a TYPELIB resource, which is the compiled version of an IDL and therefore the best starting point to get to an IDL quickly. For <code>cmlua.dll</code> we're out of luck, however.</p>\n<p>Furthermore if you had no symbols like with Windows components, you would have to dig yourself into the disassembly starting from <code>DllGetClassObject</code> which is well-known and well-documented and should be trivial to understand even for the layperson. Going from there and equipped with the knowledge that the three first methods of any COM interface are inherited from <code>IUnknown</code> you'd then try to make sense of the implementation of each method (apart from those well-known first three) and assign hopefully meaningful names to the functions and their parameters. That is: the whole task becomes a bit more tedious without debug symbols, but not at all impossible.</p>\n</div>",
            "votes": "5",
            "user": "0xC0000022L",
            "time": "Nov 23, 2018 at 10:03",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Anton.P",
                    "text": "<span class=\"comment-copy\">I can't even imagine a better answer than this one. Thank you so much. I tried loading the DLL with IDA and indeed after obtaining the symbols I see the signatures. There is a lot of information I need to parse, try out, and apply on my research. Thanks!!</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>well the answers out there are good this is just an addition to show how you could arrive using windbg in command line</p>\n<p>dbh is an utility in windbg installation that can load any binary and provide a lot of static information \nusing it and the command line version of windbg cdb.exe you can get the methods in two commands (notice the method names are demangled)</p>\n<pre><code>C:\\&gt;dbh c:\\Windows\\System32\\cmlua.dll  \"x CCM*\" | grep -i vf\n    11            1002d58 :   CCMLuaUtil::`vftable'\n\nC:\\&gt;cdb -c \"dps cmlua.dll+2d58\" -z c:\\Windows\\System32\\cmlua.dll\n\nMicrosoft (R) Windows Debugger Version 10.0.16299.15 X86\nLoading Dump File [c:\\Windows\\System32\\cmlua.dll]\n\n\ncmlua!_DllMainCRTStartup:\n100061e7 8bff            mov     edi,edi\n\n0:000&gt; cdb: Reading initial command 'dps cmlua.dll+2d58'\n\n10002d58  100042ad cmlua!CCMLuaUtil::QueryInterface\n10002d5c  10004e82 cmlua!CCMLuaUtil::AddRef\n10002d60  10004279 cmlua!CCMLuaUtil::Release\n10002d64  10004346 cmlua!CCMLuaUtil::SetRasCredentials\n10002d68  10004401 cmlua!CCMLuaUtil::SetRasEntryProperties\n10002d6c  100044dd cmlua!CCMLuaUtil::DeleteRasEntry\n10002d70  10004573 cmlua!CCMLuaUtil::LaunchInfSection\n10002d74  100045e1 cmlua!CCMLuaUtil::LaunchInfSectionEx\n10002d78  10004630 cmlua!CCMLuaUtil::CreateLayerDirectory\n10002d7c  1000466e cmlua!CCMLuaUtil::ShellExec\n10002d80  10004690 cmlua!CCMLuaUtil::SetRegistryStringValue\n10002d84  10004701 cmlua!CCMLuaUtil::DeleteRegistryStringValue\n10002d88  100055da cmlua!CCMLuaUtil::DeleteRegKeysWithoutSubKeys\n10002d8c  10004767 cmlua!CCMLuaUtil::DeleteRegTree\n10002d90  100048cc cmlua!CCMLuaUtil::ExitWindowsFunc\n10002d94  10005c72 cmlua!CCMLuaUtil::AllowAccessToTheWorld\n10002d98  100048d9 cmlua!CCMLuaUtil::CreateFileAndClose\n10002d9c  1000560f cmlua!CCMLuaUtil::DeleteHiddenCmProfileFiles\n10002da0  1000492a cmlua!CCMLuaUtil::CallCustomActionDll\n10002da4  10004b6c cmlua!CCMLuaUtil::RunCustomActionExe\n10002da8  10004c2c cmlua!CCMLuaUtil::SetRasSubEntryProperties\n10002dac  10004d0e cmlua!CCMLuaUtil::DeleteRasSubEntry\n10002db0  10004da7 cmlua!CCMLuaUtil::SetCustomAuthData\n10002db4  10005cdb cmlua!CCMLuaUtil::`vector deleting destructor'\n10002db8  00000000\n10002dbc  10009138 cmlua!hProxyDll+0x10\n10002dc0  10009188 cmlua!hProxyDll+0x60\n10002dc4  00000000\n10002dc8  69727453\n10002dcc  6343676e\n10002dd0  706f4368\n10002dd4  20784579\n0:000&gt;\n</code></pre>\n<p><a href=\"https://stackoverflow.com/questions/36251393/get-parameters-of-public-symbols-in-windbg/36295654#36295654\">now dbh has a switch -d which would output mangled names and you can leverage that switch to print the parameters to the Methods</a> </p>\n<pre><code>C:\\&gt;echo off\n\nfor /F %i in ('dbh -d c:\\Windows\\System32\\cmlua.dll  \"x *CCM*\"  ^| awk \"{print $4}\"') do  dbh c:\\windows\\system32\\cmlua.\ndll undec %i\n\n?Release@CCMLuaUtil@@UAGKXZ =\npublic: virtual unsigned long __stdcall CCMLuaUtil::Release(void)\n\n??_ECCMLuaUtil@@UAEPAXI@Z =\npublic: virtual void * __thiscall CCMLuaUtil::`vector deleting destructor'(unsigned int)\n\n??0CCMLuaUtil@@QAE@XZ =\npublic: __thiscall CCMLuaUtil::CCMLuaUtil(void)\n\n?AddRef@CCMLuaUtil@@UAGKXZ =\npublic: virtual unsigned long __stdcall CCMLuaUtil::AddRef(void)\n\n?CreateFileAndClose@CCMLuaUtil@@UAGJPBGKKKK@Z =\npublic: virtual long __stdcall CCMLuaUtil::CreateFileAndClose(unsigned short const *,unsigned long,unsigned long,unsigne\nd long,unsigned long)\n\n?DeleteHiddenCmProfileFiles@CCMLuaUtil@@UAGJPBG@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteHiddenCmProfileFiles(unsigned short const *)\n\n??_GCCMLuaUtil@@UAEPAXI@Z =\npublic: virtual void * __thiscall CCMLuaUtil::`scalar deleting destructor'(unsigned int)\n\n?SetRasSubEntryProperties@CCMLuaUtil@@UAGJPBG0KPAPAGK@Z =\npublic: virtual long __stdcall CCMLuaUtil::SetRasSubEntryProperties(unsigned short const *,unsigned short const *,unsign\ned long,unsigned short * *,unsigned long)\n\n?QueryInterface@CCMLuaUtil@@UAGJABU_GUID@@PAPAX@Z =\npublic: virtual long __stdcall CCMLuaUtil::QueryInterface(struct _GUID const &amp;,void * *)\n\n?CCMLuaUtil_CreateInstance@@YGJABU_GUID@@PAPAX@Z =\nlong __stdcall CCMLuaUtil_CreateInstance(struct _GUID const &amp;,void * *)\n\n?ExitWindowsFunc@CCMLuaUtil@@UAGJXZ =\npublic: virtual long __stdcall CCMLuaUtil::ExitWindowsFunc(void)\n\n?CreateLayerDirectory@CCMLuaUtil@@UAGJPBG@Z =\npublic: virtual long __stdcall CCMLuaUtil::CreateLayerDirectory(unsigned short const *)\n\n?LaunchInfSectionEx@CCMLuaUtil@@UAGJPBG0K@Z =\npublic: virtual long __stdcall CCMLuaUtil::LaunchInfSectionEx(unsigned short const *,unsigned short const *,unsigned lon\ng)\n\n?ShellExec@CCMLuaUtil@@UAGJPBG00KK@Z =\npublic: virtual long __stdcall CCMLuaUtil::ShellExec(unsigned short const *,unsigned short const *,unsigned short const\n*,unsigned long,unsigned long)\n\n?DeleteRasEntry@CCMLuaUtil@@UAGJPBG0@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteRasEntry(unsigned short const *,unsigned short const *)\n\n?DeleteRegistryStringValue@CCMLuaUtil@@UAGJHPBG0@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteRegistryStringValue(int,unsigned short const *,unsigned short const *)\n\n??_7CCMLuaUtil@@6B@ =\nconst CCMLuaUtil::`vftable'\n\n?LaunchInfSection@CCMLuaUtil@@UAGJPBG00H@Z =\npublic: virtual long __stdcall CCMLuaUtil::LaunchInfSection(unsigned short const *,unsigned short const *,unsigned short\n const *,int)\n\n?SetCustomAuthData@CCMLuaUtil@@UAGJPBG00K@Z =\npublic: virtual long __stdcall CCMLuaUtil::SetCustomAuthData(unsigned short const *,unsigned short const *,unsigned shor\nt const *,unsigned long)\n\n?DeleteRasSubEntry@CCMLuaUtil@@UAGJPBG0K@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteRasSubEntry(unsigned short const *,unsigned short const *,unsigned long\n)\n\n?DeleteRegTree@CCMLuaUtil@@UAGJHPBG@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteRegTree(int,unsigned short const *)\n\n?DeleteRegKeysWithoutSubKeys@CCMLuaUtil@@UAGJHPBGH@Z =\npublic: virtual long __stdcall CCMLuaUtil::DeleteRegKeysWithoutSubKeys(int,unsigned short const *,int)\n\n?CallCustomActionDll@CCMLuaUtil@@UAGJPBG000PAK@Z =\npublic: virtual long __stdcall CCMLuaUtil::CallCustomActionDll(unsigned short const *,unsigned short const *,unsigned sh\nort const *,unsigned short const *,unsigned long *)\n\n?SetRegistryStringValue@CCMLuaUtil@@UAGJHPBG00@Z =\npublic: virtual long __stdcall CCMLuaUtil::SetRegistryStringValue(int,unsigned short const *,unsigned short const *,unsi\ngned short const *)\n\n?SetRasCredentials@CCMLuaUtil@@UAGJPBG00H@Z =\npublic: virtual long __stdcall CCMLuaUtil::SetRasCredentials(unsigned short const *,unsigned short const *,unsigned shor\nt const *,int)\n\n?SetRasEntryProperties@CCMLuaUtil@@UAGJPBG0PAPAGK@Z =\npublic: virtual long __stdcall CCMLuaUtil::SetRasEntryProperties(unsigned short const *,unsigned short const *,unsigned\nshort * *,unsigned long)\n\n?AllowAccessToTheWorld@CCMLuaUtil@@UAGJPBG@Z =\npublic: virtual long __stdcall CCMLuaUtil::AllowAccessToTheWorld(unsigned short const *)\n\n?RunCustomActionExe@CCMLuaUtil@@UAGJPBG0PAPAG@Z =\npublic: virtual long __stdcall CCMLuaUtil::RunCustomActionExe(unsigned short const *,unsigned short const *,unsigned sho\nrt * *)\n</code></pre>\n</div>",
            "votes": "3",
            "user": "blabb",
            "time": "Nov 25, 2018 at 16:33",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This is just an extension of @0xC0000022L's answer. For this question, I will explain ICMLuaUtil COM interface below because IFileOperation COM interface is in <code>shell32.dll</code>, too big ;)</p>\n<p>You mentioned the wrong CLSID. Here I provide a list of them:</p>\n<pre><code>GUID CLSID_CmstpLua = {3E5FC7F9-9A51-4367-9063-A120244FBEC7}\nGUID IID_ICmstpLua = {6EF07F29-F9B8-4DA4-B59E-13DEA060AD60}\nGUID IID_ICmstpLua2 = {AE8AFD54-5B57-4961-8A9B-12ADF23B696A}\n\nGUID CLSID_CMLuaUtil = {3E000D72-A845-4CD9-BD83-80C07C3B881F}\nGUID IID_ICMLuaUtil = {6EDD6D74-C007-4E75-B76A-E5740995E24C}\n</code></pre>\n<p>How to find the DLL file path from <a href=\"https://docs.microsoft.com/en-us/windows/desktop/com/clsid-key-hklm\" rel=\"nofollow noreferrer\">CLSID</a> without using any 3rd party program? Open this registry path <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{CLSID}</code> in RegEdit. For this case, try this command:</p>\n<pre><code>REG Query \"HKLM\\SOFTWARE\\Classes\\CLSID\\{3E000D72-A845-4CD9-BD83-80C07C3B881F}\\InprocServer32\" /VE\nREG Query \"HKLM\\SOFTWARE\\Classes\\Interface\\{6EDD6D74-C007-4E75-B76A-E5740995E24C}\" /VE\n</code></pre>\n<p>The path will be <code>%SystemRoot%\\System32\\cmlua.dll</code>. Open it in IDA (or any disassembler/decompiler) and load the PDB symbol file. Go to the functions window with <kbd>Shift</kbd> + <kbd>F3</kbd> and search for the <a href=\"https://en.cppreference.com/w/cpp/language/initializer_list\" rel=\"nofollow noreferrer\">constructor</a> or the <a href=\"https://en.cppreference.com/w/cpp/language/destructor\" rel=\"nofollow noreferrer\">destructor</a> by typing those words in that window. Open that function in assembly view. There must be a variable like <code>const CCMLuaUtil::vftable</code> because <a href=\"https://en.wikipedia.org/wiki/Virtual_method_table\" rel=\"nofollow noreferrer\">you-know-why</a>. Double click on it and you will see the layout of that COM class in assembly view. </p>\n<p><a href=\"https://i.sstatic.net/sGRNb.png\" rel=\"nofollow noreferrer\"><img alt=\"CMLuaUtil_interface\" src=\"https://i.sstatic.net/sGRNb.png\"/></a></p>\n<p>There are many advantages of the assembly view. In the <strong>assembly view</strong>, all the methods in that class are placed in <strong>actual order</strong> but the functions windows may not (according to settings). The methods are actually placed as function pointers. For 64 bit binary there will be <code>dq</code> (qword 8 bytes) before every methods (in the above screenshot). The first three methods are <a href=\"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)\" rel=\"nofollow noreferrer\">inherited</a> from <a href=\"https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown\" rel=\"nofollow noreferrer\">IUnknown interface</a>. If you are writing that class (as struct) in C, you've to include those three.</p>\n<p>See <a href=\"https://reverseengineering.stackexchange.com/a/19079/23069\">another canonical answer</a> for further reference. One can see a real example of this method in my repository <a href=\"https://github.com/Biswa96/WslReverse\" rel=\"nofollow noreferrer\">GitHub: WslReverse</a> where I showed the hidden COM interface of <code>LxssManager.DLL</code>. Also this video about <a href=\"http://youtu.be/efkLG8-G3J0\" rel=\"nofollow noreferrer\">Practical C++ Decompilation | Recon 2011 | Igor Skochinsky</a> helped me a lot.</p>\n</div>",
            "votes": "2",
            "user": "Biswapriyo",
            "time": "Nov 25, 2018 at 15:41",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Anton.P",
                    "text": "<span class=\"comment-copy\">Thx for the extra information, I will of course go over it also, but I have a preliminary question, how do you know which interface relates to which CLSID? in oleview, CMLuaUtil doesn't have any interfaces associated with it</span>",
                    "time": null
                },
                {
                    "user": "Anton.P",
                    "text": "<span class=\"comment-copy\">my question is how do you understand that IID_ICMLuaUtil is related to  CLSID_CMLuaUtil? (other than the name of course which is not mendatory, e.g. in the IFileOperation COM some of the supported interfaces doesnt share its name). The commands do reveal the DLLs but I fail to understand the general approach of fining the link between them</span>",
                    "time": null
                },
                {
                    "user": "Biswapriyo",
                    "text": "<span class=\"comment-copy\">@Anton.P This would be the oversimplificated answer: <a href=\"https://i.sstatic.net/ZpIRF.png\" rel=\"nofollow noreferrer\">i.sstatic.net/ZpIRF.png</a></span>",
                    "time": null
                }
            ]
        }
    ]
}