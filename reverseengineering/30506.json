{
    "title": "Patching a B(ranch) causes segfault in ARMv7 binary, while the same patch (with JMP) works on x64 binary",
    "link": "https://reverseengineering.stackexchange.com/questions/30506/patching-a-branch-causes-segfault-in-armv7-binary-while-the-same-patch-with",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Any ideas why trying to patch a ARMv7 binary causes a segfault while basically the same patch on the Win64 version of the software works as expected?</p>\n<p>Here is the Win64 version, that works</p>\n<pre><code>    UPX0:00000001406AEB39 InvLicenseCheck:                        ; CODE XREF: sub_1406AE6D0+53↑j\n    UPX0:00000001406AEB39                                         ; sub_1406AE6D0+72↑j ...\n    UPX0:00000001406AEB39                 jmp     short JumpHere\n    UPX0:00000001406AEB3B ; ---------------------------------------------------------------------------\n    UPX0:00000001406AEB3B                 nop\n    UPX0:00000001406AEB3C                 nop\n    UPX0:00000001406AEB3D                 nop\n    UPX0:00000001406AEB3E                 call    cs:__imp___acrt_iob_func\n    UPX0:00000001406AEB44                 lea     rdx, aInvalidLicense_1 ; \"Invalid License\\r\\n\"\n    UPX0:00000001406AEB4B                 mov     rcx, rax\n    UPX0:00000001406AEB4E                 call    sub_14066C780\n    UPX0:00000001406AEB53                 lea     rdx, aInvalidLicense_0 ; \"Invalid License\"\n    UPX0:00000001406AEB5A                 mov     ecx, 3\n    UPX0:00000001406AEB5F                 call    sub_14068EEA0\n    UPX0:00000001406AEB64                 mov     ecx, 1          ; Count\n    UPX0:00000001406AEB69                 mov     edx, 34h        ; Size\n    UPX0:00000001406AEB6E                 call    calloc\n    UPX0:00000001406AEB73                 mov     rbx, rax\n    UPX0:00000001406AEB76                 mov     rax, 736E6563696C6E75h\n    UPX0:00000001406AEB80                 mov     [rbx], rax\n    UPX0:00000001406AEB83                 mov     dword ptr [rbx+7], 646573h\n    UPX0:00000001406AEB8A                 mov     dword ptr [rbx+28h], 1\n    UPX0:00000001406AEB91                 mov     byte ptr [rbx+30h], 1\n    UPX0:00000001406AEB95\n    UPX0:00000001406AEB95 JumpHere:                               ; CODE XREF: sub_1406AE6D0:InvLicenseCheck↑j\n    UPX0:00000001406AEB95                                         ; sub_1406AE6D0+51F↓j\n    UPX0:00000001406AEB95                 mov     rcx, r13        ; Memory\n    UPX0:00000001406AEB98                 call    free\n    UPX0:00000001406AEB9D                 mov     rax, rbx\n    UPX0:00000001406AEBA0                 add     rsp, 278h\n    UPX0:00000001406AEBA7                 pop     rbx\n    UPX0:00000001406AEBA8                 pop     rbp\n    UPX0:00000001406AEBA9                 pop     rdi\n    UPX0:00000001406AEBAA                 pop     rsi\n    UPX0:00000001406AEBAB                 pop     r12\n    UPX0:00000001406AEBAD                 pop     r13\n    UPX0:00000001406AEBAF                 pop     r14\n    UPX0:00000001406AEBB1                 pop     r15\n    UPX0:00000001406AEBB3                 retn\n    UPX0:00000001406AEBB4 ; ---------------------------------------------------------------------------\n</code></pre>\n<p>And the ARMv7l version, which gives a signal 11 (segfault).</p>\n<p>This is odd because I've stepped through the patch in GDB and the patch itself does not cause the segfault...</p>\n<pre><code>    LOAD:000447C4 InvLicenseCheck                         ; CODE XREF: sub_44664+4C↑j\n    LOAD:000447C4                                         ; sub_44664+64↑j ...\n    LOAD:000447C4                 B               JumpHere ; Keypatch modified this from:\n    LOAD:000447C4                                         ;   LDR R3, =off_135004\n    LOAD:000447C8 ; ---------------------------------------------------------------------------\n    LOAD:000447C8                 MOV             R2, #0x10\n    LOAD:000447CC                 LDR             R3, [R3]\n    LOAD:000447D0                 MOV             R1, #1\n    LOAD:000447D4                 LDR             R0, =aInvalidLicense_0 ; \"Invalid License\\n\"\n    LOAD:000447D8                 BL              sub_F4850\n    LOAD:000447DC                 LDR             R1, =aInvalidLicense ; \"Invalid License\"\n    LOAD:000447E0                 MOV             R0, #3\n    LOAD:000447E4                 BL              sub_5079C\n    LOAD:000447E8                 MOV             R1, #0x34 ; Count\n    LOAD:000447EC                 MOV             R0, #1  ; Size\n    LOAD:000447F0                 BL              calloc  ; calloc\n    LOAD:000447F4                 LDR             R3, =aUnlicensed ; \"unlicensed\"\n    LOAD:000447F8                 MOV             R7, R0\n    LOAD:000447FC                 LDMIA           R3, {R0-R2} ; \"unlicensed\"\n    LOAD:00044800                 MOV             R3, R7\n    LOAD:00044804                 STMIA           R3!, {R0,R1}\n    LOAD:00044808                 MOV             R12, R2,LSR#16\n    LOAD:0004480C                 MOV             R1, #1\n    LOAD:00044810                 STRH            R2, [R3],#2\n    LOAD:00044814                 STRB            R12, [R3]\n    LOAD:00044818                 STR             R1, [R7,#0x28]\n    LOAD:0004481C                 STRB            R1, [R7,#0x30]\n    LOAD:00044820\n    LOAD:00044820 JumpHere                                ; CODE XREF: sub_44664:InvLicenseCheck↑j\n    LOAD:00044820                                         ; sub_44664+454↓j\n    LOAD:00044820                 MOV             R0, R5  ; Memory\n    LOAD:00044824                 BL              cfree   ; cfree\n    LOAD:00044828                 MOV             R0, R7\n    LOAD:0004482C                 ADD             SP, SP, #0x184\n    LOAD:00044830                 LDMFD           SP!, {R4-R11,PC}\n    LOAD:00044834 ; ---------------------------------------------------------------------------\n</code></pre>\n<p>I'm not very well versed in debugging on linux, let alone on the ARM platform. Any hints would be welcome.</p>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "74",
    "tags": [
        "linux",
        "arm",
        "elf",
        "patching"
    ],
    "user": "captmicr0",
    "time": "Jun 12, 2022 at 5:39",
    "comments": [
        {
            "user": "peter ferrie",
            "text": "<span class=\"comment-copy\">I'm surprised that it works in the x86 code.  At the very least, you have an apparently uninitialised RBX value (and corresponding R7 in the ARM code).  Does the segfault occur within this routine, or after it returns?  You might have gotten lucky that RBX points to something writable, but R7 does not.</span>",
            "time": null
        },
        {
            "user": "captmicr0",
            "text": "<span class=\"comment-copy\">The segfault occurs quite a few calls after the JumpHere segment, all the way in 0x107EC (which seems completely unrelated). I've tried making it jump to after the free call aswell incase it was doing something weird to the memory. I've also attempted to patch each BL with a NOP (mov r0, r0) instead of doing a branch at the beginning. After some more investigating on the x64 binary, it looks like it sets up the return values for the function starting at 1406AEB64, so I will try branching to there instead directly to JumpHere and see if I can implement the same on the ARM binary.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Do you know the difference between jmp (B) and call (BL)?\nRead about return address, which is saved in the LR register (ARM) for 'BL'.</p>\n</div>",
            "votes": "1",
            "user": "strannyi",
            "time": "Oct 27, 2022 at 19:55",
            "is_accepted": false,
            "comments": []
        }
    ]
}