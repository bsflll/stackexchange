{
    "title": "dwarf: variable offset from base",
    "link": "https://reverseengineering.stackexchange.com/questions/24853/dwarf-variable-offset-from-base",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have a simple code:</p>\n<pre><code>int main()\n{\n  int a = 4;\n  printf(\"%d\\n\", a);\n  a = 8;\n  if (a == 8)\n    printf(\"%d\\n\", a);\n  return 0;\n}\n</code></pre>\n<p>DIEs for the function and variable:</p>\n<pre><code> &lt;1&gt;&lt;32a&gt;: Abbrev Number: 18 (DW_TAG_subprogram)\n    &lt;32b&gt;   DW_AT_external    : 1\n    &lt;32b&gt;   DW_AT_name        : (indirect string, offset: 0x19c): main\n    &lt;32f&gt;   DW_AT_decl_file   : 1\n    &lt;330&gt;   DW_AT_decl_line   : 4\n    &lt;331&gt;   DW_AT_decl_column : 5\n    &lt;332&gt;   DW_AT_type        : &lt;0x63&gt;\n    &lt;336&gt;   DW_AT_low_pc      : 0x4004b2\n    &lt;33e&gt;   DW_AT_high_pc     : 0x4b\n    &lt;346&gt;   DW_AT_frame_base  : 1 byte block: 9c        (DW_OP_call_frame_cfa)\n    &lt;348&gt;   DW_AT_GNU_all_tail_call_sites: 1\n &lt;2&gt;&lt;348&gt;: Abbrev Number: 19 (DW_TAG_variable)\n    &lt;349&gt;   DW_AT_name        : a\n    &lt;34b&gt;   DW_AT_decl_file   : 1\n    &lt;34c&gt;   DW_AT_decl_line   : 6\n    &lt;34d&gt;   DW_AT_decl_column : 7\n    &lt;34e&gt;   DW_AT_type        : &lt;0x63&gt;\n    &lt;352&gt;   DW_AT_location    : 2 byte block: 91 6c     (DW_OP_fbreg: -20)\n</code></pre>\n<p>And objdump output for the same:</p>\n<pre><code>00000000004004b2 &lt;main&gt;:\n  4004b2:       55                      push   rbp\n  4004b3:       48 89 e5                mov    rbp,rsp\n  4004b6:       48 83 ec 10             sub    rsp,0x10\n  4004ba:       c7 45 fc 04 00 00 00    mov    DWORD PTR [rbp-0x4],0x4\n  4004c1:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]\n  4004c4:       89 c6                   mov    esi,eax\n  4004c6:       bf 84 05 40 00          mov    edi,0x400584\n  4004cb:       b8 00 00 00 00          mov    eax,0x0\n  4004d0:       e8 db fe ff ff          call   4003b0 &lt;printf@plt&gt;\n  4004d5:       c7 45 fc 08 00 00 00    mov    DWORD PTR [rbp-0x4],0x8\n  4004dc:       83 7d fc 08             cmp    DWORD PTR [rbp-0x4],0x8\n  4004e0:       75 14                   jne    4004f6 &lt;main+0x44&gt;\n  4004e2:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]\n  4004e5:       89 c6                   mov    esi,eax\n  4004e7:       bf 84 05 40 00          mov    edi,0x400584\n  4004ec:       b8 00 00 00 00          mov    eax,0x0\n  4004f1:       e8 ba fe ff ff          call   4003b0 &lt;printf@plt&gt;\n  4004f6:       b8 00 00 00 00          mov    eax,0x0\n  4004fb:       c9                      leave\n  4004fc:       c3                      ret\n  4004fd:       0f 1f 00                nop    DWORD PTR [rax]\n</code></pre>\n<p>I am curious if detecting variable offset from ebp (assuming ebp is stack base and variable is on stack) is possible, by looking at debugging symbols. For e.g. in this case variable <code>a</code> is present at <code>rbp-0x4</code>. It looks like tag <code>DW_AT_location</code> could give me the location information. But, as per the dwarf documentation - 0x91 belongs to <code>DW_OP_fbreg</code> and 0x6C belongs to <code>DW_AT_const_expr</code>. I don't really get the meaning of this. I also read that <code>DW_AT_frame_base</code> gives the frame base of the function.</p>\n<p>I really appreciate any help.</p>\n</div>",
    "votes": "1",
    "answers": 0,
    "views": "153",
    "tags": [
        "binary-analysis",
        "elf",
        "symbols",
        "debugging-symbols"
    ],
    "user": "R4444",
    "time": "Apr 28, 2020 at 21:48",
    "comments": [],
    "answers_data": []
}