{
    "title": "What is the purpose of these instructions before the main preamble?",
    "link": "https://reverseengineering.stackexchange.com/questions/15173/what-is-the-purpose-of-these-instructions-before-the-main-preamble",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I wrote a small C program below:</p>\n<pre><code>#include &lt;stdlib.h&gt;\nint sub(int x, int y){\n  return 2*x+y;\n}\n\nint main(int argc, char ** argv){\n  int a;\n  a = atoi(argv[1]);\n  return sub(argc,a);\n}\n</code></pre>\n<p>Compiled with gcc 5.4.0 and target 32 bit x86. I got the following in disassembly:</p>\n<pre><code>0804841b &lt;main&gt;:\n 804841b: 8d 4c 24 04           lea    0x4(%esp),%ecx\n 804841f: 83 e4 f0              and    $0xfffffff0,%esp\n 8048422: ff 71 fc              pushl  -0x4(%ecx)\n 8048425: 55                    push   %ebp\n 8048426: 89 e5                 mov    %esp,%ebp\n 8048428: 53                    push   %ebx\n 8048429: 51                    push   %ecx\n 804842a: 83 ec 10              sub    $0x10,%esp\n 804842d: 89 cb                 mov    %ecx,%ebx\n....\n</code></pre>\n<p>What are the first three instructions before <code>push %ebp</code> doing? I haven't seen those in older gcc compiled binaries.</p>\n</div>",
    "votes": "10",
    "answers": 2,
    "views": "6k",
    "tags": [
        "disassembly",
        "x86",
        "gcc"
    ],
    "user": "drdot",
    "time": "Apr 17, 2017 at 1:08",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<h2>What the Instructions Are Doing</h2>\n<blockquote>\n<p>What are the first three instructions before <code>push %ebp</code> doing?</p>\n</blockquote>\n<p>Namely,</p>\n<pre><code> 804841b: 8d 4c 24 04           lea    0x4(%esp),%ecx      &lt;-  1\n 804841f: 83 e4 f0              and    $0xfffffff0,%esp    &lt;-  2\n 8048422: ff 71 fc              pushl  -0x4(%ecx)          &lt;-  3\n</code></pre>\n<p>This is easy to see if <code>gdb</code> (or some other debugger) is used to step through the code.</p>\n<ol>\n<li><blockquote>\n<p><code>804841b: 8d 4c 24 04           lea    0x4(%esp),%ecx</code></p>\n</blockquote></li>\n</ol>\n<p>At this point in the process, the memory address in register <code>$esp</code> is <code>0xffffd13c</code>, so <code>4(%esp)</code> = <code>$esp+4</code> = <code>0xffffd140</code>:</p>\n<pre><code>&gt;&gt;&gt; x/x $esp+4\n0xffffd140: 0x01\n</code></pre>\n<p>This means that the <code>lea</code> instruction loads the effective address of <code>0x4(%esp)</code>, <code>0xffffd140</code>, into <code>$ecx</code>.</p>\n<hr/>\n<ol start=\"2\">\n<li><blockquote>\n<p><code>804841f: 83 e4 f0              and    $0xfffffff0,%esp</code></p>\n</blockquote></li>\n</ol>\n<p>Next, the value in <code>$esp</code>, <code>0xffffd13c</code>, is ANDed with <code>0xfffffff0</code>:</p>\n<pre><code>0xffffd13c:            11111111111111111101000100111100\n0xfffffff0:       AND  11111111111111111111111111110000\n                  -------------------------------------\n                       11111111111111111101000100110000\n</code></pre>\n<p>This results in the value <code>0xffffd130</code>, which is stored in <code>$esp</code>. This is equivalent to </p>\n<p><code>0xffffd13c</code> - <code>0x0c</code> = <code>0xffffd130</code>.</p>\n<p>This has the effect of creating 12 bytes of space on the process runtime stack. On a side note, the value -16 would be represented as <code>0xfffffff0</code>, so we could think of </p>\n<p><code>and $0xfffffff0,%esp</code></p>\n<p>as</p>\n<p><code>and $-16,%esp</code></p>\n<p>This is done to <a href=\"https://reverseengineering.stackexchange.com/questions/14880/basic-reversing-question-about-local-variable/14883#14883\">keep the stack aligned to a 16-byte boundary</a>, since the next instruction (see 3) decrements the stack pointer by 4 and then saves a value to the stack.</p>\n<hr/>\n<ol start=\"3\">\n<li><blockquote>\n<p><code>8048422: ff 71 fc              pushl  -0x4(%ecx)</code></p>\n</blockquote></li>\n</ol>\n<p>As a result of <code>lea 0x4(%esp),%ecx</code> from earlier, the value in <code>$ecx</code> is equivalent to what had been <code>$esp+4</code> (that is, <code>0xffffd140</code>). As a result,</p>\n<p><code>-0x4(%ecx)</code> = <code>0xffffd140</code> - 4 = <code>0xffffd13c</code>.</p>\n<p>This was the value of <code>$esp</code> at the beginning of <code>main()</code>. This value is now saved on the process runtime stack via a <code>pushl</code> instruction. </p>\n<p><hr/>\n<strong>summary:</strong></p>\n<pre><code> lea    0x4(%esp),%ecx         // load 0xffffd140 into $ecx\n and    $0xfffffff0,%esp       // subtract 0x0c (decimal 12) from $esp\n pushl  -0x4(%ecx)             // decrement $esp by 4, save 0xffffd13c on stack\n</code></pre>\n<hr/>\n<h2>The Purpose of these Instructions</h2>\n<blockquote>\n<p>What is the purpose of these instructions before the main preamble?</p>\n</blockquote>\n<p>A clue about the purpose of these instructions is the fact that they are executed prior to the conventional function prologue:</p>\n<pre><code>8048425: 55                    push   %ebp\n8048426: 89 e5                 mov    %esp,%ebp\n</code></pre>\n<p>According to the <a href=\"http://refspecs.linux-foundation.org/elf/abi386-4.pdf\" rel=\"noreferrer\">System V Application Binary Interface Intel386 Architecture Processor Supplment, Fourth Edition</a>, after the execution of the function prologue <code>$ebp+4</code> is the location on the runtime stack of the return address. </p>\n<p><a href=\"https://i.sstatic.net/VRdaH.png\" rel=\"noreferrer\"><img alt=\"SYS V ABI i386 supplement C stack frame\" src=\"https://i.sstatic.net/VRdaH.png\"/></a></p>\n<p>The address saved on the stack at <code>$ebp+4</code> by the instruction </p>\n<p><code>8048422: ff 71 fc              pushl  -0x4(%ecx)</code></p>\n<p>is <code>0xffffd13c</code>. This is a pointer to <code>0xf7e12637</code>, the address of offset 247 in <code>__libc_start_main()</code>:</p>\n<pre><code>&gt;&gt;&gt; x/x $ecx-4\n0xffffd13c: 0xf7e12637\n&gt;&gt;&gt; x/x 0xf7e12637\n0xf7e12637 &lt;__libc_start_main+247&gt;: 0x8310c483\n</code></pre>\n<p>This indicates that the return address of <code>main()</code> is in function <code>__libc_start_main()</code>. </p>\n<p>As for <code>$ecx</code>, this register simply holds the value of <code>argc</code>:</p>\n<pre><code>&gt;&gt;&gt; x/x $ecx\n0xffffd140: 0x00000001\n</code></pre>\n<p>Note that since variable <code>a</code> is never used, the compiler optimizes out the call to <code>atoi</code>.  </p>\n<p>So to answer the question directly, the instructions in <code>main()</code> prior to the prologue pass an argument to <code>main()</code> (the value of <code>argc</code>) and save the return address of <code>main()</code> on the runtime stack.</p>\n<h2>The C Runtime Environment and Linux Process Anatomy</h2>\n<p>Naturally, the next question is \"What is <code>__libc_start_main</code>?\" According to <a href=\"http://refspecs.linuxbase.org/LSB_3.0.0/LSB-PDA/LSB-PDA/baselib---libc-start-main-.html\" rel=\"noreferrer\">Linux Standard Base PDA Specification 3.0RC1</a>:</p>\n<blockquote>\n<p>The <code>__libc_start_main()</code> function shall initialize the process, call the main function with appropriate arguments, and handle the return from <code>main()</code>.</p>\n</blockquote>\n<p>So where does <code>__libc_start_main()</code> come from? The short answer is that it is a function in the shared object <code>/lib/i386-linux-gnu/libc-2.23.so</code> which is dynamically linked into the executable ELF binary:</p>\n<pre><code> $ ldd [binary_name]\n    linux-gate.so.1 =&gt;  (0xf7764000)\n    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7586000)\n    /lib/ld-linux.so.2 (0x56640000)\n</code></pre>\n<p>In addition to <code>__libc_start_main()</code>, the function <code>__gmon_start__</code>, also part of process initialization, is dynamically linked to the executable ELF binary as well:</p>\n<pre><code>$ readelf --dyn-syms [binary_name]\n\nSymbol table '.dynsym' contains 5 entries:\n   Num:    Value  Size Type    Bind   Vis      Ndx Name\n     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (2)\n     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__\n     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (3)\n     4: 0804851c     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used\n</code></pre>\n<p>Here is the complete picture, from <a href=\"http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html\" rel=\"noreferrer\"><strong>Linux x86 Program Start Up or - How the heck do we get to main()?</strong></a> by Patrick Horgan:</p>\n<p><a href=\"https://i.sstatic.net/xKl8k.png\" rel=\"noreferrer\"><img alt=\"C process initialization call graph\" src=\"https://i.sstatic.net/xKl8k.png\"/></a></p>\n<p>On a final note, if the return address of <code>main()</code> of <code>0xf7e12637</code> is examined more closely, we see that this address lies outside of the <code>text</code> segment as well as the runtime stack. This address, located in <code>__libc_start_main()</code>, is actually located in the memory-mapped segment in virtual memory, as shown by this diagram from Gustavo Duarte's article <a href=\"http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/\" rel=\"noreferrer\"><strong>Anatomy of a Program in Memory</strong></a>:</p>\n<p><a href=\"https://i.sstatic.net/LPwfZ.png\" rel=\"noreferrer\"><img alt=\"Linux Process Layout in VM\" src=\"https://i.sstatic.net/LPwfZ.png\"/></a></p>\n</div>",
            "votes": "19",
            "user": "sudhackar",
            "time": "Aug 4, 2018 at 8:39",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<h1>What does this do?</h1>\n<p>These three statements serve to <em>move</em> the stackframe of <code>main</code>, beginning with its return address, to the next 16-byte-aligned address.</p>\n<pre><code>lea    0x4(%esp),%ecx    # save address of arguments\nand    $0xfffffff0,%esp  # align stack\npushl  -0x4(%ecx)        # move return address\n...                      # continue normal preamble\n</code></pre>\n<p>At the same time, the arguments to <code>main</code> (<code>argc</code> and <code>argv</code>) are not moved, so a pointer to them is saved in <code>%ecx</code>.</p>\n<p>Recall the layout of the stack upon entering <code>main</code>:</p>\n<pre><code>%esp+8:  argv (a pointer to an array of pointers)\n%esp+4:  argc (a 32-bit integer)\n%esp+0:  return address (from call)\n</code></pre>\n<p>The arguments sit right above the return address, so <code>%esp+4</code> is saved to <code>%ecx</code> before the stack pointer is adjusted.\nNext, <code>%ecx</code> also serves as our pointer to locate the original return address, <code>-4(%ecx)</code>, which we push to our new stack frame.</p>\n<p>After the rest of the preamble, the stack will look like this:</p>\n<pre><code>%ecx+4:  argv pointer\n%ecx+0:  argc\n%ecx-4:  original return address\n         ...\n%esp+4:  copy of return address\n%esp+0:  saved base pointer\n</code></pre>\n<p>In your code, you can also see that <code>%ecx</code> is pushed onto the stack (i.e. saved as a local variable) after the preamble; it will be restored from there at the end of the function which will look like this:</p>\n<pre><code>...\nmov    -0x8(%ebp),%ecx   # load pointer to argc\nleave                    # unwind stack frame, pop %ebp\nlea    -0x4(%ecx),%esp   # restore original stack pointer\nret                      # jump out, using the original return address!\n</code></pre>\n<h1>Why is all this done at all?</h1>\n<p>Modern processors like data aligned to 16-byte boundaries for various reasons; some operations may take significant performance hits otherwise, others might not work at all.</p>\n<p>Adjusting the <code>main</code> stack frame once allows the rest of the code to run without further adjustment as long as care is taken to always allocate stack in multiples of 16 bytes before a call. That is why you will often see something like this:</p>\n<pre><code>sub    $0xc,%esp    # pad stack by 12 bytes\npush   %eax         # push 4-byte argument\ncall   puts\n</code></pre>\n<p><strong>NB:</strong> The x86-64 ABI makes the 16-byte stack alignment mandatory. Incidentally this means that you <em>will not</em> find a frame adjustment on <code>main</code> in 64-bit code - the stack is already aligned.</p>\n</div>",
            "votes": "7",
            "user": "pesco",
            "time": "Aug 3, 2018 at 15:36",
            "is_accepted": false,
            "comments": [
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">Welcome! Based on what you have written so far, I look forward to reading your future posts.</span>",
                    "time": null
                },
                {
                    "user": "pesco",
                    "text": "<span class=\"comment-copy\">Thanks! I came here to look this up and afterwards felt that, while your answer is quite elaborate, it was missing a few details. Since as a new user I couldn't comment, I took a shot at my own. Hope you don't mind! :)</span>",
                    "time": null
                },
                {
                    "user": "Evan Carroll",
                    "text": "<span class=\"comment-copy\">I like this better than @SYS_V's answer (no offense to SYS_V). I don't believe SYS_V's answer address \"what is the purpose\". It does a great job of explaining what the instructions do. The answer seems to be very very simple. Above and beyond the obvious alignment-optimization \"At the same time, the arguments to main (argc and argv) are not moved, so a pointer to them is saved in %ecx.\" Beautiful. Thanks a ton.</span>",
                    "time": null
                }
            ]
        }
    ]
}