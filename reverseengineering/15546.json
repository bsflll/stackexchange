{
    "title": "ptrace TRACE_PEEKER: Input/output error accessing virtual address contents when traced file is a shared object file",
    "link": "https://reverseengineering.stackexchange.com/questions/15546/ptrace-trace-peeker-input-output-error-accessing-virtual-address-contents-when",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm using updated Kali and compiling this for 64- bit</p>\n<p>Working through Learning Linux Binary Analysis,'simple ptrace-based debugger' on page 57.</p>\n<p>Source code and testfile to debug included.</p>\n<p>Problem is accessing the return value of lookup_symbol from the shared object file 'test'.</p>\n<p>Regarding the given program:\nThe only thing I've changed is the error check that checks for ET_EXEC, I changed it to ET_DYN so that I can try to trace shared object files, which seem unavoidable when I import stdio.h for the print function. Also, changed the part that checks for ELF files, used use: </p>\n<blockquote>\n<p>h.mem[0] != 0x7f || strcmp((char *)&amp;h.mem<a href=\"http://refspecs.linuxbase.org/elf/elf.pdf\" rel=\"nofollow noreferrer\">1</a>, \"ELF\"\n  But I don't think the second part is necessary, and my computer spits out an error unless I use \"ELF\\002\\001\\001\" in the strcmp. </p>\n</blockquote>\n<p>The work of the parent program is done in the lookup_symbol function which searches for the symbol name in the string table and returns the symbol table st_value (the virtual address) of the desired symbol.</p>\n<p>From <a href=\"http://refspecs.linuxbase.org/elf/elf.pdf\" rel=\"nofollow noreferrer\">TIS ELF Specification </a></p>\n<blockquote>\n<p>In executable and shared object files, st_value holds a virtual\n  address. To make these files' symbols more useful for the dynamic\n  linker, the section offset (file interpretation) gives way to a\n  virtual address (memory interpretation) for which the section number\n  is irrelevant.</p>\n</blockquote>\n<p>To search for <strong>print_string</strong> in 'test':</p>\n<blockquote>\n<p>./tracer ./test print_string</p>\n</blockquote>\n<p>The goal is to break at each print_string call and print the registers at that point, then any key can be pressed to continue execution.</p>\n<p>When running the source code the lookup_symbol function returns 0x6b0 on my comp for the value of symtab-&gt;st_value and assigns it to h.symaddr.</p>\n<p>0x6b0 is the virtual address (value of) of print_string in the symbol table, confirmed by checking readelf </p>\n<blockquote>\n<p>58: 00000000000006b0    27 FUNC    GLOBAL DEFAULT   14 print_string</p>\n</blockquote>\n<p>The original from the book uses 0x6b0 directly in the following function:</p>\n<blockquote>\n<p>if ((orig = ptrace(PTRACE_PEEKTEXT, pid, h.symaddr, NULL)) &lt; 0)</p>\n</blockquote>\n<p>This function fails with an error on my computer when it attempts to use h.symaddr=0x6b0:</p>\n<pre><code>Beginning analysis of pid: 2462 at 6b0\nPTRACE_PEEKER: Input/output error\nhello 1\nhello 2\n</code></pre>\n<p>The problem is not that it's a virtual address being returned, because as quoted above, both executables and shared object files contain virtual addresses in symbol_table-&gt;st_value. I'm not sure why but there is a difference in how this ptracing parent program treats shared objects and executables.</p>\n<p>This is the test file:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid print_string(char * str)\n{\n    printf(\"%s\\n\", str); \n}\n\nint main(int argc, char ** argv)\n{\n    print_string(\"hello 1\");\n    print_string(\"hello 2\");\n    return 0;\n}\n</code></pre>\n<p>This is the source file:    </p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;elf.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/user.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/ptrace.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;sys/wait.h&gt;\n\n\n\n\ntypedef struct handle\n{\n    Elf64_Ehdr *ehdr;\n    Elf64_Phdr *phdr;\n    Elf64_Shdr *shdr;\n    uint8_t *mem;\n    char *symname;\n    Elf64_Addr symaddr;\n    struct user_regs_struct pt_reg;\n    char *exec;\n} handle_t;\n\nElf64_Addr lookup_symbol(handle_t *, const char *);\n\n\n\nint main(int argc, char **argv, char **envp)\n{\n\n    int fd;\n    handle_t h;\n    struct stat st;\n    long trap, orig;\n    int status, pid;\n    char * args[2]; \n\n    if (argc &lt; 3)\n    {\n        printf(\"Usage: %s &lt;program&gt; &lt;function&gt;\\n\", argv[0]);\n        exit(0);\n    }\n\n\n    if ((h.exec = strdup(argv[1])) == NULL)\n    {\n        perror(\"strdup\"); exit(-1);\n    }\n\n    args[0] = h.exec;\n\n    args[1] = NULL;\n\n    if ((h.symname = strdup(argv[2])) == NULL)\n    {\n        perror(\"strdup\");\n        exit(-1);\n    }\n\n    if ((fd = open(argv[1], O_RDONLY)) &lt; 0)\n    {\n        perror(\"open\");\n        exit(-1);\n    }\n\n    if (fstat(fd, &amp;st) &lt; 0) \n    {\n        perror(\"fstat\");\n        exit(-1);\n    }\n\n    h.mem = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\n    if (h.mem == MAP_FAILED)\n    {\n        perror(\"mmap\");\n        exit(-1);\n    }\n\n\n    h.ehdr = (Elf64_Ehdr *)h.mem;\n\n    h.phdr = (Elf64_Phdr *)(h.mem + h.ehdr-&gt;e_phoff);\n\n    h.shdr = (Elf64_Shdr *)(h.mem + h.ehdr-&gt;e_shoff);\n\n    if (h.mem[0] != 0x7f)\n    {\n        printf(\"%s is not an ELF file\\n\", h.exec);\n        exit(-1);\n    }\n\n    if (h.ehdr-&gt;e_type != ET_DYN)\n    {\n        printf(\"%s is not an ELF dynamic\\n\", h.exec);\n        exit(-1);\n    }\n\n    if (h.ehdr-&gt;e_shstrndx == 0 || h.ehdr-&gt;e_shoff == 0 || h.ehdr-&gt;e_shnum == 0)\n    {\n        printf(\"Section header table not found\\n\");\n        exit(-1);\n    }\n\n    if ((h.symaddr = lookup_symbol(&amp;h, h.symname)) == 0)\n    {\n        printf(\"Unable to find symbol: %s not found in executable\\n\", h.symname);\n        exit(-1);\n    }\n\n    close(fd);  \n\n    if ((pid = fork()) &lt; 0)\n    {\n        perror(\"fork\");\n        exit(-1);\n    }\n\n    if (pid == 0)\n    {\n\n        if (ptrace(PTRACE_TRACEME, pid, NULL, NULL) &lt; 0)\n        {\n            perror(\"PTRACE_TRACEME\");\n            exit(-1);\n        }\n\n        execve(h.exec, args, envp);\n        exit(0);\n    }\n\n    wait(&amp;status);\n    printf(\"Beginning analysis of pid: %d at %lx\\n\", pid, h.symaddr);\n\n\n    if ((orig = ptrace(PTRACE_PEEKTEXT, pid, h.symaddr, NULL)) &lt; 0)\n    {\n        perror(\"PTRACE_PEEKER\");\n        exit(-1);\n    }\n    trap = (orig &amp; ~0xff | 0xcc);\n\n\n    printf(\"Made it here\");\n\n\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) &lt; 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\ntrace:\n\n    if (ptrace(PTRACE_CONT, pid, NULL, NULL) &lt; 0)\n    {\n        perror(\"PTRACE_CONT\");\n        exit(-1);\n    }\n    wait(&amp;status);\n\n\n    if (WIFSTOPPED(status) &amp;&amp; WSTOPSIG(status) == SIGTRAP)\n    {\n        if (ptrace(PTRACE_GETREGS, pid, NULL, &amp;h.pt_reg) &lt; 0)\n        {\n            perror(\"PTRACE_GETREGS\");\n            exit(-1);\n        }\n\n        printf(\"\\nExecutable %s (pid: %d) has hit breakpoint 0x%lx\\n\", h.exec, pid, h.symaddr);\n\n    printf(\"%%rcx: %llx\\n%%rdx: %llx\\n%%rbx: %llx\\n\" \n                \"%%rax: %llx\\n%%rdi: %llx\\n%%rsi: %llx\\n\" \n                \"%%r8: %llx\\n%%r9: %llx\\n%%r10: %llx\\n%%\" \n                \"%%r11: %llx\\n%%r12: %llx\\n%%r13: %llx\\n%%\" \n                \"%%r14: %llx\\n%%r15: %llx\\n%%rsp: %llx\\n%%\");\n    printf(\"\\nHit any key to continue: \");\n    getchar();\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, orig) &lt; 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\n\n    h.pt_reg.rip = h.pt_reg.rip - 1;\n    if (ptrace(PTRACE_SETREGS, pid, NULL, &amp;h.pt_reg) &lt; 0)\n    {\n        perror(\"PTRACE_SETREGS\");\n        exit(-1);\n    }\n\n    if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) &lt; 0)\n    {\n        perror(\"PTRACE_SINGLESTEP\");\n        exit(-1);\n    }\n    wait(NULL);\n\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) &lt; 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\n\n    goto trace;\n    }\n\n    if (WIFEXITED(status)) \n        printf(\"Completed tracing pid: %d\\n\", pid);\n\n    exit(0);\n}\n\n\n\n\n    Elf64_Addr lookup_symbol(handle_t *h, const char *symname)\n    {\n        int i, j;\n        char *strtab;\n        Elf64_Sym *symtab;\n        for (i = 0; i &lt; h-&gt;ehdr-&gt;e_shnum; i++)      \n        {\n            if (h-&gt;shdr[i].sh_type == SHT_SYMTAB)   \n            {\n                strtab = (char *)&amp;h-&gt;mem[h-&gt;shdr[h-&gt;shdr[i].sh_link].sh_offset];\n\n                symtab = (Elf64_Sym *)&amp;h-&gt;mem[h-&gt;shdr[i].sh_offset];\n\n\n                for (j = 0; j &lt; h-&gt;shdr[i].sh_size/sizeof(Elf64_Sym); j++)\n                {\n                    if (strcmp(&amp;strtab[symtab-&gt;st_name], symname) == 0)\n                        //printf(\"symtab-&gt;st_value is 0x%lx\\n\", symtab-&gt;st_value);  \n                        return (symtab-&gt;st_value);\n                    symtab++;\n                }\n            }\n        }\n        return 0;\n    }\n</code></pre>\n</div>",
    "votes": "2",
    "answers": 2,
    "views": "2k",
    "tags": [
        "elf"
    ],
    "user": "flerb",
    "time": "Jun 21, 2017 at 16:34",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The problem is that when I compile test.c with gcc, gcc creates a shared object file. </p>\n<p>This is the case with even the simplest of programs:\n    //simplereturn.c\n    int main(void)\n    {\n        return 22;\n    }</p>\n<p>from readelf:</p>\n<pre><code>Type:                              DYN (Shared object file)\n</code></pre>\n<p>When I try to parse this with tracer, previously I had changed the error-checking section that ensured that the file that I'm parsing with ptrace is ET_EXEC (an executable file). I changed it so it checked if the traced file was ET_DYN (shared object file). </p>\n<p>Doing this allowed the error-check to pass for the simple C programs that I wanted to trace, but had unexpected (at least for me) consequences. When lookup_symbol was returning it was in fact returning a virtual address (0x6b0), which agrees with the symbol table of the readelf, and the function address in objdump -D. Can even check it in gdb. However, interestingly, a break at print_string is placed at 0x6bc, while the start of the print_string function is at 0x6b0. Probably not irrelevant.</p>\n<p>After a lot of research and struggle, the problem was an easy fix. </p>\n<p>I created an executable instead of a shared object file. The requisite as far as I can tell is that it uses no external libraries or functions, or I guess probably that it's self-contained. Either way, gcc won't make them.</p>\n<pre><code>;test.asm\nsection .text\n    global _start\n\n_start:\n    mov rsi, hello1\n    call print_string\n    mov rsi, hello2\n    call print_string\n\n    xor rdi,rdi\n    mov rax, 60\n    syscall\n\nprint_string:\n    mov rax, 1\n    mov rdi, 1\n    mov rdx, 6\n    syscall\n    ret\n\nsection .data\n    hello1 db \"Hello1\"\n    hello2 db \"Hello2\"\n</code></pre>\n<p>Compiled with nasm -g -f elf64 test.asm &amp;&amp; ld -m elf_x86_64 -o testasm testasm.o</p>\n<p>Now <strong>readelf -a testasm</strong> confirms that it's an executable </p>\n<pre><code>ELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n Type:                              EXEC (Executable file) //EXEC NOW\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x4000b0\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          616 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         2\n  Size of section headers:           64 (bytes)\n  Number of section headers:         6\n  Section header string table index: 5\n</code></pre>\n<p>And I switched the error checking in the original back:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;elf.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/user.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/ptrace.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;sys/wait.h&gt;\n\n\ntypedef struct handle\n{\n    Elf64_Ehdr *ehdr;\n    Elf64_Phdr *phdr;\n    Elf64_Shdr *shdr;\n    uint8_t *mem;\n    char *symname;\n    Elf64_Addr symaddr;\n    struct user_regs_struct pt_reg;\n    char *exec;\n} handle_t;\n\nElf64_Addr lookup_symbol(handle_t *, const char *);\n\nint main(int argc, char **argv, char **envp)\n{\n    int fd;\n    handle_t h;\n    struct stat st;\n    long trap, orig;\n    int status, pid;\n    char * args[2];\n\n    if (argc &lt; 3)\n    {\n        printf(\"Usage: %s &lt;program&gt; &lt;function&gt;\\n\", argv[0]);\n        exit(0);\n    }\n\n    if ((h.exec = strdup(argv[1])) == NULL)\n    {\n        perror(\"strdup\"); exit(-1);\n    }\n\n    args[0] = h.exec;\n\n    args[1] = NULL;\n\n    if ((h.symname = strdup(argv[2])) == NULL)\n    {\n        perror(\"strdup\");\n        exit(-1);\n    }\n\n    if ((fd = open(argv[1], O_RDONLY)) &lt; 0)\n    {\n        perror(\"open\");\n        exit(-1);\n    }\n\n    if (fstat(fd, &amp;st) &lt; 0) \n    {\n        perror(\"fstat\");\n        exit(-1);\n    }\n\n\n    h.mem = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\n\n    if (h.mem == MAP_FAILED)\n    {\n        perror(\"mmap\");\n        exit(-1);\n    }\n\n\n    h.ehdr = (Elf64_Ehdr *)h.mem;\n\n    h.phdr = (Elf64_Phdr *)(h.mem + h.ehdr-&gt;e_phoff);\n\n    h.shdr = (Elf64_Shdr *)(h.mem + h.ehdr-&gt;e_shoff);\n\n    if ((h.mem[0] != 0x7f) || strcmp((char *)&amp;h.mem[1], \"ELF\\002\\001\\001\"))\n    {\n        printf(\"%s is not an ELF file\\n\", h.exec);\n        exit(-1);\n    }\n\n    if (h.ehdr-&gt;e_type != ET_EXEC) \n    {\n        printf(\"%s is not an ELF executable\\n\", h.exec);\n        exit(-1);\n    }\n\n\n    if (h.ehdr-&gt;e_shstrndx == 0 || h.ehdr-&gt;e_shoff == 0 || h.ehdr-&gt;e_shnum == 0)\n    {\n        printf(\"Section header table not found\\n\");\n        exit(-1);\n    }\n\n    if ((h.symaddr = lookup_symbol(&amp;h, h.symname)) == 0)\n    {\n        printf(\"Unable to find symbol: %s not found in executable\\n\", h.symname);\n        exit(-1);\n    }\n\n\n    close(fd);  \n\n\n    if ((pid = fork()) &lt; 0)\n    {\n        perror(\"fork\");\n        exit(-1);\n    }\n\n    if (pid == 0)\n    {\n        if (ptrace(PTRACE_TRACEME, pid, NULL, NULL) &lt; 0)\n        {\n            perror(\"PTRACE_TRACEME\");\n            exit(-1);\n        }\n        execve(h.exec, args, envp);\n        exit(0);\n    }\n\n\n\n\n    wait(&amp;status);\n    printf(\"Beginning analysis of pid: %d at %lx\\n\", pid, h.symaddr);\n\n    if ((orig = ptrace(PTRACE_PEEKTEXT, pid, h.symaddr, (void *)0)) &lt; 0)\n    {\n        perror(\"PTRACE_PEEKER\");\n        exit(-1);\n    }\n    trap = (orig &amp; ~0xff | 0xcc);\n\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) &lt; 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\ntrace:\n    if (ptrace(PTRACE_CONT, pid, NULL, NULL) &lt; 0)\n    {\n        perror(\"PTRACE_CONT\");\n        exit(-1);\n    }\n    wait(&amp;status);\n\n    if (WIFSTOPPED(status) &amp;&amp; WSTOPSIG(status) == SIGTRAP)\n    {\n        if (ptrace(PTRACE_GETREGS, pid, NULL, &amp;h.pt_reg) &lt; 0)\n        {\n            perror(\"PTRACE_GETREGS\");\n            exit(-1);\n        }\n\n        printf(\"\\nExecutable %s (pid: %d) has hit breakpoint 0x%lx\\n\", h.exec, pid, h.symaddr);\n\n    printf(\"%%rcx: %llx\\n%%rdx: %llx\\n%%rbx: %llx\\n\" \n                \"%%rax: %llx\\n%%rdi: %llx\\n%%rsi: %llx\\n\" \n                \"%%r8: %llx\\n%%r9: %llx\\n%%r10: %llx\\n%%\" \n                \"%%r11: %llx\\n%%r12: %llx\\n%%r13: %llx\\n%%\" \n                \"%%r14: %llx\\n%%r15: %llx\\n%%rsp: %llx\\n%%\");\n    printf(\"\\nHit any key to continue: \");\n    getchar();\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, orig) &lt; 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\n\n    h.pt_reg.rip = h.pt_reg.rip - 1;\n\n    if (ptrace(PTRACE_SETREGS, pid, NULL, &amp;h.pt_reg) &lt; 0)\n    {\n        perror(\"PTRACE_SETREGS\");\n        exit(-1);\n    }\n\n    if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) &lt; 0)\n    {\n        perror(\"PTRACE_SINGLESTEP\");\n        exit(-1);\n    }\n    wait(NULL);\n\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) &lt; 0)\n    {\n        perror(\"PTRACE_POKETEXT\");\n        exit(-1);\n    }\n\n    goto trace;\n    }\n\n    if (WIFEXITED(status)) \n        printf(\"Completed tracing pid: %d\\n\", pid);\n\n    exit(0);\n}\n\n\n\n\n    Elf64_Addr lookup_symbol(handle_t *h, const char *symname)\n    {\n        int i, j;\n        char *strtab;\n        Elf64_Sym *symtab;\n        for (i = 0; i &lt; h-&gt;ehdr-&gt;e_shnum; i++)  \n        {\n            if (h-&gt;shdr[i].sh_type == SHT_SYMTAB)\n            {\n                strtab = (char *)&amp;h-&gt;mem[h-&gt;shdr[h-&gt;shdr[i].sh_link].sh_offset];\n\n                symtab = (Elf64_Sym *)&amp;h-&gt;mem[h-&gt;shdr[i].sh_offset];\n\n                for (j = 0; j &lt; h-&gt;shdr[i].sh_size/sizeof(Elf64_Sym); j++)\n                {\n                    if (strcmp(&amp;strtab[symtab-&gt;st_name], symname) == 0)\n                        return (symtab-&gt;st_value);\n                    symtab++;\n                }\n            }\n        }\n        return 0;\n    }\n</code></pre>\n<p>And now when run it it works\n$ <strong>./tracer ./testasm print_string</strong></p>\n<pre><code>Beginning analysis of pid: 5378 at 4000d8\n\nExecutable ./testasm (pid: 5378) has hit breakpoint 0x4000d8\n%rcx: 564ed7b07050\n%rdx: 7fb9525a9760\n%rbx: 7fffffc2\n%rax: 1\n%rdi: 3e\n%rsi: 1958ac0\n%r8: 7ffcd2b98848\n%r9: 7ffcd2b98828\n%r10: 3d2bea1a8\n%%r11: 564ed7b07010\n%r12: 0\n%r13: 7fb9527d2728\n%%r14: 57f00000001\n%r15: 801\n%rsp: 203bec\n%\nHit any key to continue: \nHello1\nExecutable ./testasm (pid: 5378) has hit breakpoint 0x4000d8\n%rcx: 564ed7b07050\n%rdx: 7fb9525a9760\n%rbx: 7fffffc2\n%rax: 1\n%rdi: 3e\n%rsi: 1958ac0\n%r8: 7ffcd2b98848\n%r9: 7ffcd2b98828\n%r10: 3d2bea1a8\n%%r11: 564ed7b07010\n%r12: 0\n%r13: 7fb9527d2728\n%%r14: 57f00000001\n%r15: 801\n%rsp: 203bec\n%\nHit any key to continue: \nHello2Completed tracing pid: 5378\n</code></pre>\n<p>checking gdb and readelf\nLookup symbol returns value at 0x4000d8, as the symbol table from <strong>readelf -a testasm</strong> says it should:</p>\n<pre><code>Symbol table '.symtab' contains 11 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 00000000004000b0     0 SECTION LOCAL  DEFAULT    1 \n     2: 00000000006000ec     0 SECTION LOCAL  DEFAULT    2 \n     3: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS test.asm\n     4: 00000000004000d8     0 NOTYPE  LOCAL  DEFAULT    1 print_string\n     5: 00000000006000ec     0 NOTYPE  LOCAL  DEFAULT    2 hello1\n     6: 00000000006000f2     0 NOTYPE  LOCAL  DEFAULT    2 hello2\n     7: 00000000004000b0     0 NOTYPE  GLOBAL DEFAULT    1 _start\n     8: 00000000006000f8     0 NOTYPE  GLOBAL DEFAULT    2 __bss_start\n     9: 00000000006000f8     0 NOTYPE  GLOBAL DEFAULT    2 _edata\n    10: 00000000006000f8     0 NOTYPE  GLOBAL DEFAULT    2 _end\n</code></pre>\n<p>So the differences between tracing an executable or shared object file in this case were what broke it.</p>\n</div>",
            "votes": "1",
            "user": "flerb",
            "time": "Jun 21, 2017 at 16:47",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>You can build without dynamic linking like this:</p>\n<pre><code>gcc -static -o test test.c\n</code></pre>\n<p>Then it'll create DT_EXEC type executable not DT_DYN.</p>\n</div>",
            "votes": "0",
            "user": "wonbear",
            "time": "Dec 28, 2022 at 6:32",
            "is_accepted": false,
            "comments": []
        }
    ]
}