{
    "title": "Is it possible to get python bytecode without using co_code?",
    "link": "https://reverseengineering.stackexchange.com/questions/1934/is-it-possible-to-get-python-bytecode-without-using-co-code",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I posted this a while back on <a href=\"https://stackoverflow.com/questions/12513901/is-it-possible-to-get-python-bytecode-without-using-co-code\">stackoverflow</a> (too old to migrate though).</p>\n<p>Say I am in the python interpreter and define a function as follows:</p>\n<pre><code>def h(a):\n  return a\n</code></pre>\n<p>If I want to look at the bytecode (not a disassembly using dis), I can typically use <code>h.func_code.co_code</code>. Is there any other way to look at the bytecode? This particular application was packaged with a custom python interpreter (using py2exe probably) which removed access to co_code. I can't just look at the pyc file as they are encrypted.</p>\n<p>For example, in the interpreter, if I just type <code>h</code> without making it a function call, I get the address of the function. Can I use that address to get the bytecode? Is there some other way?</p>\n<p>P.S. My original goal in doing this at the time was to use pyREtic (which calls co_code) to decompile. Since it called co_code, it would fail to work. I figured out one way to do it which I will post as an answer eventually. Wanted to see what others have done or come up with.</p>\n</div>",
    "votes": "18",
    "answers": 2,
    "views": "8k",
    "tags": [
        "python"
    ],
    "user": "mikeazo",
    "time": "May 23, 2017 at 12:37",
    "comments": [
        {
            "user": "Avery3R",
            "text": "<span class=\"comment-copy\">Don't have access to a computer right now, but have you tried digging into the python source code to see what co_code does?</span>",
            "time": null
        },
        {
            "user": "mikeazo",
            "text": "<span class=\"comment-copy\">yeah, co_code is just a buffer that stores the bytecode of the given function.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>First, just a small reminder about \"what is <code>co_code</code>\".</p>\n<p>In Python, every element of the language (functions, methods, classes, ...) is defined and stored in an object. The <code>co_code</code> is one of the fields attached to the class used to represent a function or a method.  Lets practice a bit with Python 2.7.</p>\n<pre><code>$&gt; python2.7\nPython 2.7.3 (default, Mar  4 2013, 14:57:34) \n[GCC 4.7.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; def foo():\n...     print('Hello World!')\n... \n&gt;&gt;&gt; dir(foo.__code__)\n\n['__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', \n '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', \n '__new__',  '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', \n '__str__', '__subclasshook__', 'co_argcount', 'co_cellvars', 'co_code', 'co_consts', \n 'co_filename', 'co_firstlineno', 'co_flags', 'co_freevars', 'co_lnotab', 'co_name', \n 'co_names', 'co_nlocals', 'co_stacksize', 'co_varnames']\n&gt;&gt;&gt; foo.__code__.co_code\n'd\\x01\\x00GHd\\x00\\x00S'\n</code></pre>\n<p>So, you can see that the <code>co_code</code> field contain the compiled bytecode of the function we just defined previously. In fact, it seems that <code>co_code</code> is just a buffer to store the compiled bytecode in a lazy manner. It is compiled only when it is accessed for the first time.</p>\n<p>Assuming this, the <code>co_code</code> is just a unified helper to access the bytecode which might be stored in several forms. One form are the <code>*.pyc</code> files which are storing the compiled Python bytecode of a whole file. Another form is just the on-the-fly compilation of the function/method.</p>\n<p>Nevertheless, there is a way to access directly the function/method definition and, thus, to the bytecode. The point is to intercept the Python process with <code>gdb</code> and analyze it. A few tutorials exists in the web about this (see <a href=\"http://grapsus.net/blog/post/Low-level-Python-debugging-with-GDB\">here</a>, <a href=\"http://docs.python.org/devguide/gdb.html\">here</a>, <a href=\"http://www.jmcneil.net/2012/04/debugging-your-python-with-gdb-ftw/\">here</a> or <a href=\"http://chrismiles.livejournal.com/20226.html\">here</a>). But, here is a quick example (you need to install the <code>python-gdb</code> package first):</p>\n<pre><code>$&gt; python2.7-dbg\nPython 2.7.3 (default, Mar  4 2013, 14:27:19) \n[GCC 4.7.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; def foo():\n...     print('Hello World!')\n... \n[40809 refs]\n&gt;&gt;&gt; foo\n&lt;function foo at 0x1a5e1b0&gt;\n[40811 refs]\n&gt;&gt;&gt; foo.__code__.co_code\n'd\\x01\\x00GHd\\x00\\x00S'\n[40811 refs]\n&gt;&gt;&gt; \n[1]+  Stopped                 python2.7-dbg\n</code></pre>\n<p>Then, you need to get the PID of the Python process and attach <code>gdb</code> on it.</p>\n<pre><code>$ gdb -p 5164\nGNU gdb (GDB) 7.4.1-debian\n...\nAttaching to process 5164\nProgram received signal SIGTSTP, Stopped (user).\nReading symbols from /usr/bin/python2.7-dbg...done.\nReading symbols from /lib/x86_64-linux-gnu/libpthread.so.0...\nReading symbols from /usr/lib/debug/lib/x86_64-linux-gnu/libpthread-2.13.so...done.\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".done.\n...\n(gdb) print *(PyFunctionObject*)0x1a5e1b0\n$1 = {_ob_next = 0x187aca0, _ob_prev = 0x189dd08, ob_refcnt = 2, \n      ob_type = 0x87ce00, func_code = &lt;code at remote 0x187aca0&gt;, \n      func_globals = {'__builtins__': &lt;module at remote 0x7f5ebcb5e470&gt;,\n      '__name__': '__main__', 'foo': &lt;function at remote 0x1a5e1b0&gt;, '__doc__': None, \n      '__package__': None}, func_defaults = 0x0, func_closure = 0x0, func_doc = None, \n      func_name = 'foo', func_dict = 0x0, func_weakreflist = 0x0, \n      func_module = '__main__'}\n(gdb) print  (*(PyFunctionObject*)0x1a5e1b0)-&gt;func_name\n$2 = 'foo'\n(gdb) print (*(PyCodeObject*)0x187aca0)\n$3 = {_ob_next = 0x18983a8, _ob_prev = 0x1a5e1b0, ob_refcnt = 1, ob_type = 0x872680, \n      co_argcount = 0, co_nlocals = 0, co_stacksize = 1, co_flags = 67,\n      co_code = 'd\\x01\\x00GHd\\x00\\x00S', co_consts = (None, 'Hello World!'),\n      co_names = (), co_varnames = (), co_freevars = (), co_cellvars = (),\n      co_filename = '&lt;stdin&gt;', co_name = 'foo', co_firstlineno = 1,\n      co_lnotab = '\\x00\\x01', co_zombieframe = 0x0, co_weakreflist = 0x0}\n(gdb) print (*(PyCodeObject*)0x187aca0)-&gt;co_code\n$4 = 'd\\x01\\x00GHd\\x00\\x00S'\n</code></pre>\n<p>So, here is the way to access directly the bytecode, given the address of the function.</p>\n<p>Just to try to  be complete, the best documentation I found on Python bytecode (and how to access it), is the Python code itself and especially the <code>inspect</code> module (<a href=\"http://hg.python.org/cpython/file/2.7/Lib/inspect.py\">2.7</a>, <a href=\"http://hg.python.org/cpython/file/3.2/Lib/inspect.py\">3.2</a>). Try to look at it, it is quite instructive.</p>\n<p>Another help you can use is the <a href=\"http://docs.python.org/2/library/dis.html\"><code>dis</code> module</a> that provide a disassembler for the Python bytecode. Here is an example of what can do this disassembler.</p>\n<pre><code>$&gt; python2.7\nPython 2.7.3 (default, Mar  4 2013, 14:57:34) \n[GCC 4.7.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; def foo():\n...     print(\"Hello World!\")\n... \n&gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(foo)\n  2           0 LOAD_CONST               1 ('Hello World!')\n              3 PRINT_ITEM          \n              4 PRINT_NEWLINE       \n              5 LOAD_CONST               0 (None)\n              8 RETURN_VALUE \n</code></pre>\n</div>",
            "votes": "20",
            "user": "perror",
            "time": "Apr 27, 2013 at 18:13",
            "is_accepted": true,
            "comments": [
                {
                    "user": "mikeazo",
                    "text": "<span class=\"comment-copy\">That's pretty cool! I'm not 100% sure this would have worked in the particular project I was working on as it had a custom python interpreter that I probably couldn't install the gdb bindings for. Still a great technique nonetheless. Thanks for sharing!</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>perror's answer I think is the correct way to do it. I wanted to post the way I ended up doing this for other's sake just in case the issue I mentioned in my comment to perror's answer is correct. I don't have all my notes with me right now and will update if necessary.</p>\n<p>Basically I ran the program in gdb, set a break point in PyObject_New (or possibly PyObject_Init). I set the break point near the end of the function so that the object would be created. From there I was able to look into the object in memory to extract the byte code.</p>\n<p>To get this info back to pyREtic, I dumped function names and bytecode to a file from within GDB, modified pyREtic so that instead of calling co_code to get the bytecode, it would extract it from the file.</p>\n<p>Like I said, it has been a while now (the stackoverflow question was from Sept 2012). I'll look back over my notes and fill in the details.</p>\n</div>",
            "votes": "2",
            "user": "mikeazo",
            "time": "Apr 27, 2013 at 19:21",
            "is_accepted": false,
            "comments": []
        }
    ]
}