{
    "title": "Why did I have gotten only null bytes argv variable from angr?",
    "link": "https://reverseengineering.stackexchange.com/questions/31543/why-did-i-have-gotten-only-null-bytes-argv-variable-from-angr",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have made simple program to test the angr.</p>\n<p>My python code is here.</p>\n<pre><code>import angr \nimport claripy\n\np=angr.Project('./test2')\nbuf=claripy.BVS('buf', 8*10)\n\ninitial_state=p.factory.entry_state(args=[\"./test2\", buf])\n\ns=p.factory.simulation_manager()\n\ns.explore(find=0x80491ab, avoid=0x80491ba)\n\nprint(s.found)\n\nif s.found:\n    sol_state=s.found[0]\n    sol=sol_state.solver.eval(buf, cast_to=bytes)\n    print(sol)\nelse:\n    print(\"not found\")\n</code></pre>\n<p>I expected this program print \"hello\"\nbut It printed as follows.</p>\n<pre><code>WARNING  | 2023-02-13 23:57:05,077 | angr.storage.memory_mixins.default_filler_mixin | The program is accessing memory with an unspecified value. This could indicate unwanted behavior.\nWARNING  | 2023-02-13 23:57:05,077 | angr.storage.memory_mixins.default_filler_mixin | angr will cope with this by generating an unconstrained symbolic variable and continuing. You can resolve this by:\nWARNING  | 2023-02-13 23:57:05,077 | angr.storage.memory_mixins.default_filler_mixin | 1) setting a value to the initial state\nWARNING  | 2023-02-13 23:57:05,077 | angr.storage.memory_mixins.default_filler_mixin | 2) adding the state option ZERO_FILL_UNCONSTRAINED_{MEMORY,REGISTERS}, to make unknown regions hold null\nWARNING  | 2023-02-13 23:57:05,078 | angr.storage.memory_mixins.default_filler_mixin | 3) adding the state option SYMBOL_FILL_UNCONSTRAINED_{MEMORY,REGISTERS}, to suppress these messages.\nWARNING  | 2023-02-13 23:57:05,078 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x0 with 129 unconstrained bytes referenced from 0x819f230 (strcpy+0x0 in libc.so.6 (0x9f230))\nWARNING  | 2023-02-13 23:57:05,402 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7ffeff6e with 10 unconstrained bytes referenced from 0x819f230 (strcpy+0x0 in libc.so.6 (0x9f230))\n[&lt;SimState @ 0x80491ab&gt;]\nb'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n</code></pre>\n<p>Here is my source code test2.c and assembly code</p>\n<p>test2.c</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(int agrc, char* argv[])\n{\n    char buf[10];\n\n    strcpy(buf, argv[1]);\n\n    if(!strcmp(buf, \"hello\"))\n    {\n        puts(\"Correct!\");\n    }\n    else\n    {\n        puts(\"Incorrect\");\n    }\n}\n</code></pre>\n<p>test2 assembly code</p>\n<pre><code>Dump of assembler code for function main:\n   0x08049176 &lt;+0&gt;:     push   ebp\n   0x08049177 &lt;+1&gt;:     mov    ebp,esp\n   0x08049179 &lt;+3&gt;:     sub    esp,0xc\n   0x0804917c &lt;+6&gt;:     mov    eax,DWORD PTR [ebp+0xc]\n   0x0804917f &lt;+9&gt;:     add    eax,0x4\n   0x08049182 &lt;+12&gt;:    mov    eax,DWORD PTR [eax]\n   0x08049184 &lt;+14&gt;:    push   eax\n   0x08049185 &lt;+15&gt;:    lea    eax,[ebp-0xa]\n   0x08049188 &lt;+18&gt;:    push   eax\n   0x08049189 &lt;+19&gt;:    call   0x8049050 &lt;strcpy@plt&gt;\n   0x0804918e &lt;+24&gt;:    add    esp,0x8\n   0x08049191 &lt;+27&gt;:    push   0x804a008\n   0x08049196 &lt;+32&gt;:    lea    eax,[ebp-0xa]\n   0x08049199 &lt;+35&gt;:    push   eax\n   0x0804919a &lt;+36&gt;:    call   0x8049030 &lt;strcmp@plt&gt;\n   0x0804919f &lt;+41&gt;:    add    esp,0x8\n   0x080491a2 &lt;+44&gt;:    test   eax,eax\n   0x080491a4 &lt;+46&gt;:    jne    0x80491b5 &lt;main+63&gt;\n   0x080491a6 &lt;+48&gt;:    push   0x804a00e\n   0x080491ab &lt;+53&gt;:    call   0x8049060 &lt;puts@plt&gt;\n   0x080491b0 &lt;+58&gt;:    add    esp,0x4\n   0x080491b3 &lt;+61&gt;:    jmp    0x80491c2 &lt;main+76&gt;\n   0x080491b5 &lt;+63&gt;:    push   0x804a017\n   0x080491ba &lt;+68&gt;:    call   0x8049060 &lt;puts@plt&gt;\n   0x080491bf &lt;+73&gt;:    add    esp,0x4\n   0x080491c2 &lt;+76&gt;:    mov    eax,0x0\n   0x080491c7 &lt;+81&gt;:    leave\n   0x080491c8 &lt;+82&gt;:    ret\nEnd of assembler dump.\n</code></pre>\n<p>Why is this happening?\nThank you in advance.</p>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "83",
    "tags": [
        "assembly",
        "python",
        "angr"
    ],
    "user": "doldom",
    "time": "Feb 14, 2023 at 5:15",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>You do not use the <code>initial_state</code> you create with constraints for <code>buf</code> arg.\nFrom the doc</p>\n<blockquote>\n<p>If nothing is passed in, the SimulationManager is seeded with a state initialized for the program entry point, i.e. entry_state().\nIf a SimState is passed in, the SimulationManager is seeded with that state.</p>\n</blockquote>\n<pre><code>s = p.factory.simulation_manager(initial_state)\n</code></pre>\n<p>would just do it</p>\n<pre><code>[&lt;SimState @ 0x4007a3&gt;]\nb'hello\\x00\\x08\\x80\\x00\\x00'\n</code></pre>\n</div>",
            "votes": "1",
            "user": "sudhackar",
            "time": "Feb 14, 2023 at 14:14",
            "is_accepted": true,
            "comments": []
        }
    ]
}