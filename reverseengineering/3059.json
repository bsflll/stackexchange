{
    "title": "Decoding an ancient format",
    "link": "https://reverseengineering.stackexchange.com/questions/3059/decoding-an-ancient-format",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>It's a very interesting file format may greatly satisfies binary archaeologists. <a href=\"http://pastelink.me/dl/36f07d\" rel=\"noreferrer\">sample file</a></p>\n<h2>Background</h2>\n<p>This file format was created in 90s to archive customer created AutoCAD components library like window, door and column. The first line is in plain text <code>xxxx DWG library 1.0</code>, it has been removed from the sample file to avoid any problem. The company xxx already gone, not sure if anyone still hold the trademark though. Lots of my father's design documents depends on it.</p>\n<p>This file format has a companion index/reference file which is a simple dBase III. The working platform is DOS/Windows.</p>\n<h2>Findings</h2>\n<p>I spent 2 days tried to understand the format. While still far from the full picture here are what I've got:</p>\n<ul>\n<li>It consists of two parts, a file list section and a section of blob array</li>\n<li>The file list section is a simple array of file name + <s><s>a mythical 3 bytes file codes (let's call it m1)</s> <strong>m1 points to the position of its binary</strong>, 2 bytes. the left 1 byte seems related to the file/record name.</s> a 4 bytes int points to the location of its corresponding binary. \n<ul>\n<li>the filename is 0x20 in length, empty spaces filled with 0x00. </li>\n<li><s>m1 is not position offset as it usually would be.</s></li>\n<li><s>file records are separated by 0x00</s></li>\n</ul></li>\n<li>The blob array section is fun.\n<ul>\n<li>each blob starts with \"AS LZW 1.0 \" (don't miss the tailing space)</li>\n<li><s>then 2 bytes of unknown usage. Not random. examples: 0x6323, 0x5b23, 0xfa22, 0x0223. (call it m2)</s> the size of the decoded binary.</li>\n<li>6 bytes of 0x00</li>\n<li>2 bytes of unknown usage. Not random. mostly 0x9ccc (call it m3)</li>\n<li>then 0xaa08 + 12 bytes of 0x00</li>\n<li>LZW old-style codes encoded binary: 0c00 0000 0083 0c89 0123 460d 0008 113e 08c0 ...</li>\n</ul></li>\n</ul>\n<h2>Questions</h2>\n<ol>\n<li><s>Are the blobs in the blob array sections really compressed with LZW? I tried to decode with python lzw from m2, m3 positions but both failed.</s></li>\n<li><s>Is m1 holding the key to decode blobs?</s></li>\n<li>What's the usage of <s>m2,</s> m3?</li>\n<li>Is there a general methodology to decode file format like this? (well, I have only google :( and <a href=\"http://www.garykessler.net/library/file_sigs.html\" rel=\"noreferrer\">file signature list</a>) <strong>010 Editor</strong> (decent software, thanks @0xC0000022L)</li>\n</ol>\n<h2>Update</h2>\n<ul>\n<li><s>m1 are 3 bytes. therefore ruled out the possibility of being CRC16 for the blob entry.</s></li>\n<li>Thanks @0xC0000022L for his comment. The first line of the file is:\nArchStar DWG Library 1.0 (line ends with 0x0d)</li>\n<li><p>tried <a href=\"http://mark0.net/soft-trid-e.html\" rel=\"noreferrer\">Trid</a> on the blob (after chopping off \"AS LWS 1.0\"), it reports </p>\n<p>100.0% (.CEL) Autodesk FLIC Image File (extensions: flc, fli, cel) (7/3)</p>\n<p>makes no sense.</p></li>\n</ul>\n<h2>Update 21/11/13</h2>\n<p><strong>Progress</strong> The <a href=\"http://www.joe-bowers.com/static/lzw/\" rel=\"noreferrer\">python lzw</a> seems to be relatively recent. So I looked into older LZW implementation in last century. So I found the lzw module of <a href=\"http://www.libtiff.org/\" rel=\"noreferrer\">libtiff</a>, and it's <a href=\"https://code.google.com/p/pylibtiff/\" rel=\"noreferrer\">python implementation</a>. (have to use the bitarray module inside of it: ver 0.35 instead of the most recent ver). I tried this python library with the brute force method (thanks to @Attila), the blob is indeed decode-able from 28h (based: \"AS LZW\"). And most importantly, the decoded starts with \"AC10\", AutoCAD DWG format! However, it only decoded around 30% of the blob.</p>\n<p><strong>Progress 2</strong> Tried <a href=\"http://golang.org/pkg/compress/lzw/\" rel=\"noreferrer\">lzw from golang</a>, with the decoding configuration order:LSB and litWid: 2, decoded around 3x more data. Will report more result tomorrow.</p>\n<p><strong>Progress 3</strong> The dwg decoded with python LibTiff LZW is a valid AutoCAD DWG. AutoCAD 2014 reported the one decoded from golang LZW invalid. Now I guess the rest part of the blob is image thumbnail of the vector. Will decode all 50 blobs and report back.</p>\n<h2>Update 22/11/13</h2>\n<p>The blobs decoded with the libtiff lzw (lzw.py) are not valid although they have correct header \"AC10\". </p>\n<p>I looked carefully into the <a href=\"https://code.google.com/p/pylibtiff/source/browse/trunk/libtiff/lzw.py\" rel=\"noreferrer\">lzw.py</a> inside of pylibtiff, and found the first two lines:</p>\n<blockquote>\n<p>\"\"\" Encoder and decoder of Lempel-Ziv-Welch algorithm for TIFF.</p>\n<p>This module is obsolete, use tif_lzw extension module instead. \"\"\"\n  (lesson learned: read every line!)</p>\n</blockquote>\n<p>So I modified my codes to use tif_lzw to decode the blob. No luck. This time, I read the <a href=\"https://code.google.com/p/pylibtiff/source/browse/trunk/libtiff/src/tif_lzw.c\" rel=\"noreferrer\">code</a> carefully, line by line. </p>\n<p>At the first glance, the file has two more Python wrapper methods Py_decode and Py_encode. Then I noticed the disabled methods LZWDecodeCompat for <em>Old-style LZW codes</em>. It's kind of interesting. So I modified the module, enabled LZWDecodeCompat and use it in the Py_decode method. the tif_lzw.decode method requires an extra parameter <strong>size</strong>. Naturally I used m1 (for the first blob, i used 0x4c07). The decoded result have \"AC10\" header, and opened successfully in AutoCAD(mac ver) but show nothing. AutoCAD says it's a Trusted DWG and contains 1 block which I couldn't find. So I spent a good few hours installed Windows and AutoCAD. bingo! there is a column drawing! There are still remaining questions. e.g. still not able to find the right size for tif_lzw.decode method call.</p>\n<p><strong>progress</strong> decoded all 50 binaries with:</p>\n<ul>\n<li>tif_lzw LZWDecodeCompat</li>\n<li>use m3 as the size paramter</li>\n</ul>\n<h2>Template (work in progress)</h2>\n<pre><code>struct FILE {\n\n    char banner[26];\n    char f1[2];\n    FSkip(4); //char sp[4];\n\n    local int count = 0;\n    local int pos;\n    local char sp[36];\n    local char SP[36];\n    Memset(SP, 0, 36);\n\n    while(true){\n        pos = FTell();\n        ReadBytes(sp, pos, 36);\n\n        if(Memcmp(sp, SP, 36) == 0){\n            break;\n        }\n        count ++;\n        FSeek(pos);\n\n        struct {\n            char name[32];\n            DWORD loc;\n        } index;\n    }\n\n\n    FSkip(36); //char sp2[36];\n    struct Binary(int len){\n            char banner[11];\n            WORD size;\n            FSkip(7);//char sp[7];\n            char m3[2]; // CRC16?\n            char m4[2]; // always AA 08\n            FSkip(16);\n            char lzw[len];\n    };\n\n    local int i;\n\n    for(i = 1; i &lt; count; i++){\n        Binary b(index[i].loc - index[i-1].loc - 40);\n    }\n\n    if(count&gt;0){\n        Binary b(FileSize() - index[i-1].loc - 40);\n    }\n} file;\n</code></pre>\n</div>",
    "votes": "9",
    "answers": 2,
    "views": "2k",
    "tags": [
        "binary-analysis",
        "file-format"
    ],
    "user": null,
    "time": "Nov 23, 2013 at 20:49",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<span class=\"comment-copy\">The best way is to reverse the program which reads or writes the format. Do you have it?</span>",
            "time": null
        },
        {
            "user": "wangii",
            "text": "<span class=\"comment-copy\">unfortunately, I don't have the program to read/write it. it's a software my dad used 12 years ago in china.</span>",
            "time": null
        },
        {
            "user": "0xC0000022L",
            "text": "<span class=\"comment-copy\">Literally the point that you took out the company name is pretty bad. See, you want us to help you but you make it artificially worse than what you have. <i>Every</i> single piece of circumstantial information matters in such a scenario (speaking from experience), especially if you have no piece of software able to read/write the file. Even if you had left the first line and then exchanged the company name with letters <code>x</code> (upper/lowercase as it was) in place of the original would have been better. For all we know the key could be part of the first line.</span>",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "<span class=\"comment-copy\">Not in Little Endian; then it's only 0x74C. You can find your magic string 0x1B bytes before where it points to -- <i>all</i> of the 50 offsets in your sample do. The string is the same for all offsets, except for the 11th and 12th bytes. Also, the <i>next</i> 20 bytes (at least) are the same, but maybe this is only because the first <i>x</i> bytes of the compressed data is.</span>",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "<span class=\"comment-copy\">Also some small variation in bytes 20 and 21 ... Just confirmed the first <b>40</b> data bytes are all the same; only the very last set differs. Apart from that one, the first <b>52</b> bytes are all the same. I'll LZW-decode the data next, will report back with findings (if any).</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Consider changing your Python script to run LZW decompression from various offsets, that is in  a brute force manner.</p>\n</div>",
            "votes": "4",
            "user": "Attila",
            "time": "Nov 20, 2013 at 12:50",
            "is_accepted": false,
            "comments": [
                {
                    "user": "wangii",
                    "text": "<span class=\"comment-copy\">brute force is indeed very useful :) (see updates)</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Feel free to edit this community-wiki \"answer\".</p>\n<p><strong>NB: Only writing this as answer because it's too long for a comment.</strong> I think given the bits and pieces of information there is no answer unless you get lucky and someone happens to know this particular file format.</p>\n<p>If we assume that the file format has indeed something to do with DWG, we can learn a lot by looking into <a href=\"http://kldp.org/files/OpenDesign_Specification_for_.dwg_files.pdf\" rel=\"nofollow noreferrer\">old</a> or new specifications (Google-search for <code>OpenDesign_Specification_for_.dwg_files.pdf</code>) for DWG and finding out about their used file format. Of particular interest are the data types (see \"BIT CODES AND DATA DEFINITIONS\" and \"Compression\" of the linked paper) and algorithms. For example in the mentioned section we find:</p>\n<blockquote>\n<p>The AutoCAD DWG file format uses a modification of a standard cyclic\n  redundancy check as an error detecting mechanism. The CRC ends up\n  being 2 bytes long due to a lookup in a table containing 256 16-bit\n  values, and are not stored in any sort of bit code form. They also\n  always appear on byte boundaries; they are not embedded within the\n  stream of bits.</p>\n</blockquote>\n<p>This is pretty valuable information and helps you confirm findings.</p>\n<p>Also interesting, assuming that this holds for your case:</p>\n<blockquote>\n<p>Autodesk also uses a method whereby the result of the CRC is XORed\n  with a \"magic number\". This method is used  extensively in pre-R13\n  files [...]</p>\n</blockquote>\n<p>BricsCAD and others provide SDKs and libraries (and products) which they claim understand also old DWG formats.</p>\n<p>But back to investigating the format yourself.</p>\n<p>You'll want to get handy with a tool such as 010 Editor that allows you to create a template and literally develop your understanding of the file format this way.</p>\n<p>Now, you have deprived us of vital information by stating that the first line is text but not giving a length or anyway an idea how you come to the conclusion that it's plain text.</p>\n<p>There are for example 50 occurrences of <code>AS LZW 1.0</code> in the file. Still, I count more occurrences of the mysterious ASCII numbers at the beginning. Possible that this counts some markers as well that aren't in need of the <code>AS LZW 1.0</code> bit.</p>\n<p>Also those decimals start out at 2. Why?</p>\n<p>I'm also unable to follow your description, to be honest. If the first part are file names and they are separated by <code>00</code>, then why are there so many occurrences of <code>00</code> in that part?</p>\n<p>ArchStar explains the <code>AS LZW 1.0</code> of course. It's probably a variation on the \"normal\" LZW then. <code>LZW</code> could of course also stand for something unrelated, like the author's initials or their name for something.</p>\n<hr/>\n<p>Concerning the update about CEL/FLIC files. If we assume that the information <a href=\"http://www.compuphase.com/flic.htm#FLICHEADER\" rel=\"nofollow noreferrer\">here</a> is correct, we should see something useful here. But it looks like gibberish indeed.</p>\n<p><img alt=\"enter image description here\" src=\"https://i.sstatic.net/TiycY.png\"/></p>\n<p>So I agree, likely no FLIC file. Still, keep in mind that DWG comes from the same creator. This may not be a coincidence.</p>\n<hr/>\n<p>Update concerning the findings about the LZW data. From Wikipedia (<a href=\"https://en.wikipedia.org/wiki/Lzw\" rel=\"nofollow noreferrer\">here</a>):</p>\n<blockquote>\n<p>In this way the decoder builds up a dictionary which is identical to\n  that used by the encoder, and uses it to decode subsequent input\n  values. Thus the full dictionary does not need be sent with the\n  encoded data; just the initial dictionary containing the\n  single-character strings is sufficient <strong>(and is typically defined\n  beforehand within the encoder and decoder rather than being explicitly\n  sent with the encoded data.)</strong></p>\n</blockquote>\n<p>(Emphasis added.)</p>\n</div>",
            "votes": "3",
            "user": "5 revs, 2 users 94%0xC0000022L",
            "time": "Jan 2, 2014 at 22:14",
            "is_accepted": false,
            "comments": [
                {
                    "user": "wangii",
                    "text": "<span class=\"comment-copy\">Good point about \"AS LZW\". I thought it was \"as lzw\" instead of \"A(rch)S(tar) lzw\"</span>",
                    "time": null
                },
                {
                    "user": "wangii",
                    "text": "<span class=\"comment-copy\">I don't think m1, m2, m3 or anything prior to \"AS LZW 1.0\" + 28h are kind of key to decode the LZW, b/c if so blobs should not have same exact \"header\" 0083 0c89 0123 460d 0008 113e 08c0</span>",
                    "time": null
                }
            ]
        }
    ]
}