{
    "title": "Extract a global variable [duplicate]",
    "link": "https://reverseengineering.stackexchange.com/questions/4716/extract-a-global-variable",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<div>\n<aside class=\"s-notice s-notice__info post-notice js-post-notice mb16\" role=\"status\">\n<div class=\"d-flex fd-column fw-nowrap\">\n<div class=\"d-flex fw-nowrap\">\n<div class=\"flex--item wmn0 fl1 lh-lg\">\n<div class=\"flex--item fl1 lh-lg\">\n<div>\n<b>This question already has an answer here</b>:\n                                \n                            </div>\n</div>\n</div>\n</div>\n<div class=\"flex--item mb0 mt4\">\n<a dir=\"ltr\" href=\"/questions/4710/extracting-a-variable-from-an-executable\">Extracting a variable from an executable</a>\n<span class=\"question-originals-answer-count\">\n                                (1 answer)\n                            </span>\n</div>\n<div class=\"flex--item mb0 mt8\">Closed <span class=\"relativetime\" title=\"2014-06-30 18:13:02Z\">10 years ago</span>.</div>\n</div>\n</aside>\n</div>\n<p>I'm trying to extact a global variable from an executable. Basically, I'm tryin to reverse an executable that put some python bytecode in a global variable and I'd like to extract it. I found out that the data is in the .data of the PE File, but I can't find a way to get it in all the data segments.\nAny ideas?</p>\n</div>",
    "votes": "0",
    "answers": 1,
    "views": "709",
    "tags": [
        "python",
        "executable"
    ],
    "user": "Maxence Henneron",
    "time": "10 years ago",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<span class=\"comment-copy\">@MaxenceHenneron: if it's a variable that can be found in the <code>.data</code> section that sounds to me like it's an initialized variable. What more than the part in the <code>.data</code> section do you need then?</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Since you say you are trying to reverse an executable which stores some python bytecode in a variable, it means probably the executable <a href=\"https://docs.python.org/2/extending/embedding.html\" rel=\"nofollow\"><em>embeds python</em></a>. If the code is likely to be executed at some point of time, you can use a debugger.</p>\n<p>Set a breakpoint on <strong><a href=\"https://docs.python.org/2/c-api/veryhigh.html?highlight=pyeval_evalframeex#PyEval_EvalFrameEx\" rel=\"nofollow\">PyEval_EvalFrameEx</a></strong> . </p>\n<p>It has a prototype of <code>PyObject* PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)</code></p>\n<p>The first parameter <code>PyFrameObject</code> has the following structure.</p>\n<pre><code>typedef struct _frame {\n    PyObject_VAR_HEAD\n    struct _frame *f_back;  /* previous frame, or NULL */\n    PyCodeObject *f_code;   /* code segment */\n    PyObject *f_builtins;   /* builtin symbol table (PyDictObject) */\n    PyObject *f_globals;    /* global symbol table (PyDictObject) */\n    PyObject *f_locals;     /* local symbol table (any mapping) */\n    PyObject **f_valuestack;    /* points after the last local */\n    PyObject **f_stacktop;\n    PyObject *f_trace;      /* Trace function */\n    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;\n    PyThreadState *f_tstate;\n    int f_lasti;        /* Last instruction if called */\n    int f_lineno;       /* Current line number */\n    int f_iblock;       /* index in f_blockstack */\n    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */\n    PyObject *f_localsplus[1];  /* locals+stack, dynamically sized */\n} PyFrameObject;\n</code></pre>\n<p>The <em>third</em> member of <code>PyFrameObject</code> is <code>PyCodeObject</code>.</p>\n<p><code>PyCodeObject</code> has the following structure.</p>\n<pre><code>typedef struct {\n    PyObject_HEAD\n    int co_argcount;        /* #arguments, except *args */\n    int co_nlocals;     /* #local variables */\n    int co_stacksize;       /* #entries needed for evaluation stack */\n    int co_flags;       /* CO_..., see below */\n    PyObject *co_code;      /* instruction opcodes */\n    PyObject *co_consts;    /* list (constants used) */\n    PyObject *co_names;     /* list of strings (names used) */\n    PyObject *co_varnames;  /* tuple of strings (local variable names) */\n    PyObject *co_freevars;  /* tuple of strings (free variable names) */\n    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */\n    /* The rest doesn't count for hash/cmp */\n    PyObject *co_filename;  /* string (where it was loaded from) */\n    PyObject *co_name;      /* string (name, for reference) */\n    int co_firstlineno;     /* first source line number */\n    PyObject *co_lnotab;    /* string (encoding addr&lt;-&gt;lineno mapping) */\n    void *co_zombieframe;     /* for optimization only (see frameobject.c) */\n} PyCodeObject;\n</code></pre>\n<p>The <em>sixth</em> member of the above structure is <code>co_code</code> . It is basically a <code>PyStringObject</code>. \nIt has the following structure.</p>\n<pre><code>typedef struct {\n    PyObject_VAR_HEAD\n    long ob_shash;\n    int ob_sstate;\n    char ob_sval[1];\n} PyStringObject;\n</code></pre>\n<p>The <code>ob_sval</code> contains the bytecode you are after.\nSo once you hit <code>PyEval_EvalFrameEx</code> follow the structures in memory to get the bytecode.</p>\n<p>Another thing to note is you need to know the layout of <code>PyObject_VAR_HEAD</code> and <code>PyObject_HEAD</code> to get the actual offsets. Refer to the <a href=\"http://hg.python.org/cpython/file/3124790c07b4\" rel=\"nofollow\">python source</a> for more information.</p>\n</div>",
            "votes": "3",
            "user": "0xec",
            "time": "Jun 27, 2014 at 7:26",
            "is_accepted": true,
            "comments": []
        }
    ]
}