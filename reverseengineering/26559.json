{
    "title": "How to parse the NT headers and section headers of a PE file using IDApython?",
    "link": "https://reverseengineering.stackexchange.com/questions/26559/how-to-parse-the-nt-headers-and-section-headers-of-a-pe-file-using-idapython",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to move some of my PE parsing into IDApython, i know how to do this with libraries like lief, but is it possible to parse the PE headers using IDA python, just like lief? i want to get all the info from the header like is debug info present and is the file signed and the compilation time and so on.</p>\n<p>how to parse PE headers using IDApython? any guide? tried googling but there is nothing.</p>\n</div>",
    "votes": "1",
    "answers": 2,
    "views": "769",
    "tags": [
        "ida",
        "idapython",
        "ida-plugin"
    ],
    "user": "OneAndOnly",
    "time": "Dec 16, 2020 at 7:49",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The PE header area is not loaded into the database by default but you can do it by enabling “manual load” in the initial load dialog. However, the copy of the header <em>is</em> saved in the database and can be accessed using the <code>idautils.peutils_t</code> class.</p>\n</div>",
            "votes": "2",
            "user": "Igor Skochinsky",
            "time": "Dec 16, 2020 at 14:38",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>And if you ever feel the need to do it manually or in an environment other than IDA, you might find this useful.</p>\n<pre><code>class AttrDict(dict):\n    def __init__(self, *args, **kwargs):\n        super(AttrDict, self).__init__(*args, **kwargs)\n        self.__dict__ = self\n\nclass section_header(object):\n    packstring = '8BIIIIIIHHI'\n    packcount = 16\n    packchunk = 17\n    packinfo = [\n        [ 'B', 'Name', 8, 'string' ],\n        [ 'I', 'VirtualSize' ],\n        [ 'I', 'VirtualAddress' ],\n        [ 'I', 'SizeOfRawData' ],\n        [ 'I', 'PointerToRawData' ],\n        [ 'I', 'PointerToRelocations' ],\n        [ 'I', 'PointerToLinenumbers' ],\n        [ 'H', 'NumberOfRelocations' ],\n        [ 'H', 'NumberOfLinenumbers' ],\n        [ 'I', 'Characteristics' ]\n    ]\n\n    def __str__(self):\n        return \"{:32} {} - {}\".format(self.name(), \n                hex(self.base + self.data.VirtualAddress), \n                hex(self.base + self.data.VirtualAddress + self.data.VirtualSize)) \n\n    def __repr__(self):\n        return \"&lt;{} '{}'&gt;\".format(str(__class__)[1:-2].split('.', 2)[1], self.name())\n\n    def __init__(self, base, data):\n        self.base = base\n        self.data = AttrDict()\n        for i in range(len(self.packinfo)):\n            count = 1\n            if len(self.packinfo[i]) &gt; 2:\n                count = self.packinfo[i][2]\n                l = []\n                for unused in range(count):\n                    l.append(data.pop(0))\n                if len(self.packinfo[i]) &gt; 3:\n                    iteratee = self.packinfo[i][3]\n                    fn = getattr(self, iteratee)\n                    result = (fn(l))\n                else:\n                    result = (l)\n            else:\n                result = (data.pop(0))\n\n            self.data[self.packinfo[i][1]] = result\n\n    def name(self):\n        return self.data.Name\n\n    def empty(self):\n        return self.data.VirtualSize == 0 and self.data.VirtualAddress == 0\n\n    def string(self, data):\n        return ''.join([chr(x) for x in data]).rstrip('\\0')\n\nclass data_directory(section_header):\n    names = [\n        \"Export Directory\", \"Import Directory\", \"Resource Directory\",\n        \"Exception Directory\", \"Security Directory\", \"Base Relocation Table\",\n        \"Debug Directory\", \"Architecture Specific Data\", \"RVA of GP\", \n        \"TLS Directory\", \"Load Configuration Directory\", \n        \"Bound Import Directory\", \"Import Address Table\", \n        \"Delay Load Import Descriptors\", \"COM Runtime descriptor\"\n    ]\n    packstring = 'II'\n    packcount = 16\n    packchunk = 2\n    packinfo = [\n        [ 'I', 'VirtualAddress' ],\n        [ 'I', 'Size' ],\n    ]\n\n    def __init__(self, base, data, number):\n        super(data_directory, self).__init__(base, data)\n        if number &lt; len(self.names):\n            self.data.Name = self.names[number]\n        else:\n            self.data.Name = 'Unknown'\n\n    def __str__(self):\n        return \"{:32} {} - {}\".format(self.name(), \n                hex(self.base + self.data.VirtualAddress), \n                hex(self.base + self.data.VirtualAddress + self.data.Size)) \n\n    def empty(self):\n        return self.data.Size == 0 and self.data.VirtualAddress == 0\n\n\nclass WinPE(object):\n    \"\"\"\n    example usage:\n\n        w = WinPE(64)\n        print(w.nt.SizeOfCode)\n        print(w.dos.e_lfanew)\n        print(w.get_rva(w.nt.BaseOfCode))\n    \"\"\"\n\n    _nt_nam_32 = [ \"Signature\", \"Machine\", \"NumberOfSections\",\n        \"TimeDateStamp\", \"PointerToSymbolTable\", \"NumberOfSymbols\",\n        \"SizeOfOptionalHeader\", \"Characteristics\", \"Magic\", \"MajorLinkerVersion\",\n        \"MinorLinkerVersion\", \"SizeOfCode\", \"SizeOfInitializedData\",\n        \"SizeOfUninitializedData\", \"AddressOfEntryPoint\", \"BaseOfCode\",\n        \"BaseOfData\", \"ImageBase\", \"SectionAlignment\", \"FileAlignment\",\n        \"MajorOperatingSystemVersion\", \"MinorOperatingSystemVersion\",\n        \"MajorImageVersion\", \"MinorImageVersion\", \"MajorSubsystemVersion\",\n        \"MinorSubsystemVersion\", \"Win32VersionValue\", \"SizeOfImage\",\n        \"SizeOfHeaders\", \"CheckSum\", \"Subsystem\", \"DllCharacteristics\",\n        \"SizeOfStackReserve\", \"SizeOfStackCommit\", \"SizeOfHeapReserve\",\n        \"SizeOfHeapCommit\", \"LoaderFlags\", \"NumberOfRvaAndSizes\" ]\n    _nt_nam_64 = _nt_nam_32.copy()\n    _nt_nam_64.remove('BaseOfData')\n    _dos_nam = ['e_magic', 'e_cblp', 'e_cp', 'e_crlc', 'e_cparhdr',\n        'e_minalloc', 'e_maxalloc', 'e_ss', 'e_sp', 'e_csum', 'e_ip', 'e_cs',\n        'e_lfarlc', 'e_ovno', 'e_res_0', 'e_res_1', 'e_res_2', 'e_res_3',\n        'e_oemid', 'e_oeminfo', 'e_res2_0', 'e_res2_1', 'e_res2_2', 'e_res2_3',\n        'e_res2_4', 'e_res2_5', 'e_res2_6', 'e_res2_7', 'e_res2_8', 'e_res2_9',\n        'e_lfanew' ]\n    _dos_fmt = 'HHHHHHHHHHHHHH4HHH10Hi'\n    _sig_fmt = 'I'\n    _img_fmt = 'HHIIIHH'\n    _dir_fmt = data_directory.packstring * data_directory.packcount\n    _sec_fmt = section_header.packstring * section_header.packcount\n\n    _nt_fmt_32 = _sig_fmt + _img_fmt + \"HBBIIIIIIIIIHHHHHHIIIIHHIIIIII\" \\\n            + _dir_fmt + _sec_fmt\n    _nt_fmt_64 = _sig_fmt + _img_fmt + \"HBBIIIIIQIIHHHHHHIIIIHHQQQQII\"  \\\n            + _dir_fmt + _sec_fmt\n\n    def __init__(self, bits=64, base=None):\n        if bits not in (32, 64):\n            raise RuntimeError(\"bits must be 32 or 64\")\n        if base is None:\n            import idaapi\n            base = idaapi.cvar.inf.min_ea\n\n        self.bits = bits\n        self.base = base\n        self.dos = self.unpack(self.get_rva(0), self._dos_nam, self._dos_fmt)\n        self.nt  = self.unpack(\n                self.get_rva(self.dos.e_lfanew),\n                getattr(self, \"_nt_nam_%i\" % bits),\n                getattr(self, \"_nt_fmt_%i\" % bits))\n\n        t2s = data_directory.packcount * data_directory.packchunk\n        t4s = section_header.packcount * section_header.packchunk\n\n        self.dirs = [y for y in [data_directory(base, x[1], x[0]) \\\n                for x in enumerate(chunk_list(self._overspill[0:t2s], \\\n                data_directory.packchunk))] \\\n                if not y.empty()]\n\n        self.sections = [y for y in [section_header(base, x) \\\n                for x in chunk_list(self._overspill[t2s:t2s+t4s], \\\n                section_header.packchunk)] \\\n                if not y.empty()]\n\n        self.end  = self.base + self.nt.SizeOfCode;\n        self.size = self.nt.SizeOfImage;\n\n        print(\"-- DOS Header --\")\n        for k, s in self.dos.items(): print(\"{:32} {}\".format(k, hex(s)))\n        print(\"-- NT Header --\")\n        for k, s in self.nt.items(): print(\"{:32} {}\".format(k, hex(s)))\n        print(\"-- Directories --\")\n        for s in self.dirs: print(s)\n        print(\"-- Segments --\")\n        for s in self.sections: print(s)\n\n    def get_rva(self, offset):\n        return self.base + offset\n\n    def zipObject(self, keys, values):\n        result = {}\n        for x in zip(keys, values):\n            result[x[0]] = x[1]\n        return result\n\n    def unpack(self, ea, names, fmt):\n        d = struct.unpack(fmt, idc.get_bytes(ea, struct.calcsize(fmt)))\n        o = self.zipObject(names, d)\n        self._overspill = list(d[len(names):])\n        return AttrDict(o)\n\ndef chunk_list(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in range(0, len(lst), n):\n        yield lst[i:i + n]\n</code></pre>\n</div>",
            "votes": "1",
            "user": "Orwellophile",
            "time": "Mar 27, 2021 at 8:11",
            "is_accepted": false,
            "comments": []
        }
    ]
}