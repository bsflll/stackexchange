{
    "title": "The structure of the Python's marshaled code object (or .pyc file)",
    "link": "https://reverseengineering.stackexchange.com/questions/21085/the-structure-of-the-pythons-marshaled-code-object-or-pyc-file",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Help me to decipher the Python's marshaled code object. The <code>.pyc</code> files are almost the same: <a href=\"https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html\" rel=\"nofollow noreferrer\">The structure of .pyc files</a>.</p>\n<p><strong>I have:</strong></p>\n<ol>\n<li>The code object compiled from the source.</li>\n<li>The marshaled representation of this code object.</li>\n<li>The recursive disassembly of its (code object) code section.</li>\n<li>All its fields values.</li>\n</ol>\n<p><strong>The main purpose:</strong> </p>\n<p>I want to find out, how the different code objects stored and referenced from each other. That is, how the links to the child code objects are stored?  The module should have references to all its functions. The function should have references to all other functions, callable from it. Etc. Does Virtual Machine preserves the code object <code>id</code>, when storing it to the <code>.pyc</code>? I don't thinks so, because can't see <code>id</code>s in the <code>.pyc</code> file.</p>\n<p>For example, I have such instruction in the disassembled source:</p>\n<pre><code>LOAD_CONST        2 (&lt;code object baz at 0x7f380995e5d0, file \"foo.py\", line 7&gt;)\n</code></pre>\n<p>Hence:</p>\n<ul>\n<li>How the Virtual Machine will found the <code>baz</code> code object? I can't see all this information: <code>0x7f380995e5d0, file \"foo.py\", line 7</code> in the marshaled string. Does the object id <code>0x7f380995e5d0</code> stored in the marshaled code or it is created each time the program is running? </li>\n<li>If it is not stored, how the connection of objects is preserved in the marshaled code objects (<code>.pyc</code> files)?</li>\n</ul>\n<p>I think, I will investigate by the <code>gdb</code> further, but maybe this approach (<code>.pyc</code> file deciphering) also will do the job.</p>\n<p><strong>Current result:</strong></p>\n<p>I used all this information for creating the next file: the first column is the binary representation of marshaled code object, the second is the meaning of each byte sequences, which I have determined already.</p>\n<pre><code>b'\n\\xe3                    &lt;don't know&gt;\n\\x00\\x00\\x00\\x00        &lt;foo.py: co_argcount: 0&gt;\n\\x00\\x00\\x00\\x00        &lt;foo.py: co_kwonlyargcount: 0&gt;\n\\x00\\x00\\x00\\x00        &lt;foo.py: co_nlocals: 0&gt;\n\\x03\\x00\\x00\\x00        &lt;foo.py: co_stacksize: 3&gt;               \n@\\x00\\x00\\x00           &lt;foo.py: co_flags = '@' = 0x40 = 64&gt;\ns.\\x00\\x00\\x00          &lt;foo.py: number of bytes for module instructions = '.' = 46&gt;\nd\\x00                   &lt;foo.py: co_code:  0 LOAD_CONST        0 (1)\nZ\\x00                   &lt;foo.py: co_code:  2 STORE_NAME        0 (a)\nd\\x01                   &lt;foo.py: co_code:  4 LOAD_CONST        1 (2)\nZ\\x01                   &lt;foo.py: co_code:  6 STORE_NAME        1 (b)\ne\\x00                   &lt;foo.py: co_code:  8 LOAD_NAME         0 (a)\ne\\x01                   &lt;foo.py: co_code: 10 LOAD_NAME         1 (b)\n\\x17\\x00                &lt;foo.py: co_code: 12 BINARY_ADD\nZ\\x02                   &lt;foo.py: co_code: 14 STORE_NAME        2 (c)\nd\\x02                   &lt;foo.py: co_code: 16 LOAD_CONST        2 (&lt;code object baz at 0x7f380995e5d0, file \"foo.py\", line 7&gt;)\nd\\x03                   &lt;foo.py: co_code: 18 LOAD_CONST        3 ('baz')\n\\x84\\x00                &lt;foo.py: co_code: 20 MAKE_FUNCTION     0\nZ\\x03                   &lt;foo.py: co_code: 22 STORE_NAME        3 (baz)\ne\\x03                   &lt;foo.py: co_code: 24 LOAD_NAME         3 (baz)\ne\\x00                   &lt;foo.py: co_code: 26 LOAD_NAME         0 (a)\ne\\x01                   &lt;foo.py: co_code: 28 LOAD_NAME         1 (b)\n\\x83\\x02                &lt;foo.py: co_code: 30 CALL_FUNCTION     2\nZ\\x04                   &lt;foo.py: co_code: 32 STORE_NAME        4 (multiplication)\ne\\x04                   &lt;foo.py: co_code: 34 LOAD_NAME         4 (multiplication)\nd\\x01                   &lt;foo.py: co_code: 36 LOAD_CONST        1 (2)\n\\x13\\x00                &lt;foo.py: co_code: 38 BINARY_POWER\nZ\\x05                   &lt;foo.py: co_code: 40 STORE_NAME        5 (square)\nd\\x04                   &lt;foo.py: co_code: 42 LOAD_CONST        4 (None)\nS\\x00                   &lt;foo.py: co_code: 44 RETURN_VALUE\n)\\x05                   &lt;foo.py: co_const: size&gt;\n\\xe9\\x01\\x00\\x00\\x00    &lt;foo.py: co_const[0]: 1&gt;\n\\xe9\\x02\\x00\\x00\\x00    &lt;foo.py: co_const[1]: 2&gt;\nc                       &lt;TYPE_CODE&gt;\n\\x02\\x00\\x00\\x00        &lt;baz: co_argcount: 2&gt;\n\\x00\\x00\\x00\\x00        &lt;baz: co_kwonlyargcount: 0&gt;\n\\x02\\x00\\x00\\x00        &lt;baz: co_nlocals: 2&gt;\n\\x02\\x00\\x00\\x00        &lt;baz: co_stacksize: 2&gt;               \nC\\x00\\x00\\x00           &lt;baz: co_flags = 'C' = 0x43 = 67&gt;\ns\\x08\\x00\\x00\\x00       &lt;baz: co_code: size = 8 bytes&gt;\n|\\x00                   &lt;baz: co_code: 0 LOAD_FAST                0 (x) \n|\\x01                   &lt;baz: co_code: 2 LOAD_FAST                1 (y) \n\\x14\\x00                &lt;baz: co_code: 4 BINARY_MULTIPLY                \nS\\x00                   &lt;baz: co_code: 6 RETURN_VALUE                   \n)\\x01                   &lt;baz: co_const: size&gt;\nN                       &lt;baz: co_const[0]: None&gt;\n\\xa9\\x00                &lt;don't know&gt; \n)\\x02                   &lt;baz: co_varnames: size&gt;\n\\xda\\x01                &lt;baz: number of characters of next item&gt;\nx                       &lt;baz: co_varnames[0]: x&gt;\n\\xda\\x01                &lt;baz: number of characters of next item&gt;\ny                       &lt;baz: co_varnames[1]: y&gt;\nr\\x03\\x00\\x00\\x00       &lt;baz: don't know. But the 'r' = 'TYPE_REF'&gt;\nr\\x03\\x00\\x00\\x00       &lt;baz: don't know. But the 'r' = 'TYPE_REF'&gt;\n\\xfa\\x06                &lt;baz: next item length&gt;\nfoo.py                  &lt;baz: co_filename&gt;\n\\xda\\x03                &lt;baz: number of characters of next item&gt;\nbaz                     &lt;baz: co_name: 'baz'&gt;\n\\x07\\x00\\x00\\x00        &lt;baz: co_firstlineno: 7&gt;\ns\\x02\\x00\\x00\\x00       &lt;baz: co_lnotab: size = 2 &gt;\n\\x00\\x01                &lt;baz: co_lnotab&gt;\nr\\x07\\x00\\x00\\x00       &lt;foo.py: co_const[3]: reference to baz&gt;\nN                       &lt;foo.py: co_const[4]: None&gt;\n)\\x06                   &lt;foo.py: co_names: size&gt; \n\\xda\\x01                &lt;foo.py: number of characters of next item&gt;\na                       &lt;foo.py: co_names[0]: a&gt;\n\\xda\\x01                &lt;foo.py: number of characters of next item&gt;\nb                       &lt;foo.py: co_names[1]: b&gt;\n\\xda\\x01                &lt;foo.py: number of characters of next item&gt;\nc                       &lt;foo.py: co_names[2]: c&gt;\nr\\x07\\x00\\x00\\x00       &lt;foo.py: co_names[3]: reference to baz&gt;\nZ\\x0e                   &lt;foo.py: number of characters of next item&gt;\nmultiplication          &lt;foo.py: co_names[4]: multiplication&gt;\nZ\\x06                   &lt;foo.py: number of characters of next item&gt;\nsquare                  &lt;foo.py: co_names[5]: square&gt;\nr\\x03\\x00\\x00\\x00       &lt;foo.py: don't know&gt;     \nr\\x03\\x00\\x00\\x00       &lt;foo.py: don't know&gt;     \nr\\x03\\x00\\x00\\x00       &lt;foo.py: don't know&gt;     \nr\\x06\\x00\\x00\\x00       &lt;foo.py: don't know&gt;     \n\\xda\\x08                &lt;foo.py: number of characters of next item&gt;\n&lt;module&gt;                &lt;foo.py: co_name&gt;\n\\x03\\x00\\x00\\x00        &lt;foo.py: co_firstlineno&gt;\ns\\n\\x00\\x00\\x00         &lt;foo.py: co_lnotab: size = '\\n' = 0A&gt;\n\\x04\\x01                &lt;foo.py: o_lnotab&gt; \n\\x04\\x01                &lt;foo.py: o_lnotab&gt;\n\\x08\\x02                &lt;foo.py: o_lnotab&gt;\n\\x08\\x07                &lt;foo.py: o_lnotab&gt;\n\\n\\x01'                 &lt;foo.py: o_lnotab&gt;\n</code></pre>\n<hr/>\n<h3>Code snippets required for replication:</h3>\n<p>1) <strong>The source code</strong>: <code>foo.py</code></p>\n<pre><code>a = 1 \nb = 2 \nc = a + b \n\ndef baz(x,y):\n    return x * y\n\nmultiplication = baz(a,b)\nsquare = multiplication ** 2\n</code></pre>\n<p>2) <strong>The marshaled representation</strong> of <code>foo.py</code>.</p>\n<pre><code>source_py = \"foo.py\"\n\nwith open(source_py) as f_source:\n    source_code = f_source.read()\n\ncode_obj_compile = compile(source_code, source_py, \"exec\")\n\ndata = marshal.dumps(code_obj_compile)\n\nprint(data)\n</code></pre>\n<p>3) <strong>The full (recursive) disassembly</strong> of the code object.</p>\n<pre><code>import types\n\ndis.dis(code_obj_compile)\n\nfor x in code_obj_compile.co_consts:\n    if isinstance(x, types.CodeType):\n        sub_byte_code = x\n        func_name = sub_byte_code.co_name\n        print('\\nDisassembly of %s:' % func_name)\n        dis.dis(sub_byte_code)\n</code></pre>\n<p>4) <strong>All code object's field values</strong>.</p>\n<pre><code>def print_co_obj_fields(code_obj):\n    # Iterating through all instance attributes\n    # and calling all having the 'co_' prefix\n    for name in dir(code_obj):\n        if name.startswith('co_'):\n            co_field = getattr(code_obj, name)\n            print(f'{name:&lt;20} = {co_field}')\n\nprint_co_obj_fields(code_obj_compile)\n</code></pre>\n</div>",
    "votes": "3",
    "answers": 2,
    "views": "3k",
    "tags": [
        "python"
    ],
    "user": "MiniMax",
    "time": "Apr 10, 2019 at 21:17",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The answer below is with reference to Python 2.7</p>\n<blockquote>\n<p>How the Virtual Machine will found the baz code object? I can't see all this information: 0x7f380995e5d0, file \"foo.py\", line 7 in the marshaled string. Does the object id 0x7f380995e5d0 stored in the marshaled code or it is created each time the program is running?</p>\n</blockquote>\n<p>The <code>baz</code> code object is located within the <code>co_consts</code> member. Going by your example.</p>\n<pre><code>&gt;&gt;&gt; import marshal\n&gt;&gt;&gt; import dis\n&gt;&gt;&gt; \n&gt;&gt;&gt; source_py = \"foo.py\"\n&gt;&gt;&gt; \n&gt;&gt;&gt; with open(source_py) as f_source:\n...     source_code = f_source.read()\n&gt;&gt;&gt; \n\n&gt;&gt;&gt; code_obj_compile = compile(source_code, source_py, \"exec\")\n</code></pre>\n<p>If you disassemble, the newly generated code object you can find references to <code>baz</code></p>\n<pre><code>&gt;&gt;&gt; dis.dis(code_obj_compile)\n  1           0 LOAD_CONST               0 (7)\n              3 STORE_NAME               0 (a)\n\n  2           6 LOAD_CONST               1 (5)\n              9 STORE_NAME               1 (b)\n\n  3          12 LOAD_NAME                0 (a)\n             15 LOAD_NAME                1 (b)\n             18 BINARY_ADD\n             19 STORE_NAME               2 (c)\n\n  5          22 LOAD_CONST               2 (&lt;code object baz at 0x7f1dcdb06bb0, file \"foo.py\", line 5&gt;)\n             25 MAKE_FUNCTION            0\n... snip...\n</code></pre>\n<p>The <code>baz</code> code object is located within the <code>co_consts</code> array of the parent code object as shown below.</p>\n<pre><code>&gt;&gt;&gt; code_obj_compile.co_consts[2]\n&lt;code object baz at 0x7f1dcdb06bb0, file \"foo.py\", line 5&gt;\n</code></pre>\n<p>And you can disassemble that as well.</p>\n<pre><code>&gt;&gt;&gt; dis.dis(code_obj_compile.co_consts[2])\n  6           0 LOAD_FAST                0 (x)\n              3 LOAD_FAST                1 (y)\n              6 BINARY_MULTIPLY\n              7 RETURN_VALUE\n</code></pre>\n<p>The objects will be created each time the program is run. Hence the addresses will change correspondingly.</p>\n<blockquote>\n<p>If it is not stored, how the connection of objects is preserved in the marshaled code objects (.pyc files)?</p>\n</blockquote>\n<p>Just explained. If you look at the instruction carefully you can notice the <code>LOAD_CONST</code> instruction takes a offset as a parameter - the operand.</p>\n<pre><code>  5          22 LOAD_CONST               2 (&lt;code object baz at 0x7f1dcdb06bb0, file \"foo.py\", line 5&gt;)\n</code></pre>\n<p>Here the offset is 2 which instructs the Python Virtual Machine to load the third (zero based) item in the <code>co_consts</code> array on to the evaluation stack. So the \"connection\" is preserved using the offsets into the other metadata members.</p>\n</div>",
            "votes": "4",
            "user": "0xec",
            "time": "Apr 9, 2019 at 11:55",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The purpose of a code object marshaling is the storing and restoring the program to/from the file. Therefore, it should have the coding scheme for all Python's features: objects, bytecode, names, etc, otherwise it can't restore a program from the file.</p>\n<p>So, it uses multiple type identifiers, which can be divided into four groups:</p>\n<ul>\n<li><p><strong>single TYPE</strong>:   {the type identifier} the size is 1 byte.</p>\n<pre><code> Example: TYPE_NONE = 'N'`, `TYPE_TRUE = 'T'.\n</code></pre>\n</li>\n<li><p><strong>short TYPE</strong>:    {the type identifier} + 1 byte value</p>\n<pre><code> Example: TYPE_SHORT_ASCII_INTERNED = 'Z'.\n</code></pre>\n</li>\n<li><p><strong>long TYPE</strong>:     {the type identifier} + 4 bytes value</p>\n<pre><code> Example: TYPE_STRING = 's'.\n</code></pre>\n</li>\n<li><p><strong>object TYPE</strong>:   {the type identifier} + the combination of all different types, including the <code>object TYPE</code> itself. That is, it has the recursive structure.</p>\n<pre><code> Example: TYPE_CODE = 'c'\n</code></pre>\n</li>\n</ul>\n<p><strong>All types can be seen here:</strong> <a href=\"https://github.com/python/cpython/blob/master/Python/marshal.c\" rel=\"nofollow noreferrer\">cpython/Python/marshal.c</a></p>\n<p>Also, the code object has multiple <code>int</code> fields. They doesn't have identifier in the marshaled string, just the sequence of four bytes values.</p>\n<pre><code>    int co_argcount;            /* #arguments, except *args */\n    int co_kwonlyargcount;      /* #keyword only arguments */\n    int co_nlocals;             /* #local variables */\n    int co_stacksize;           /* #entries needed for evaluation stack */\n    int co_flags;               /* CO_..., see below */\n    int co_firstlineno;         /* first source line number */\n    \n</code></pre>\n<p><strong>The full code object structure is here:</strong> <a href=\"https://github.com/python/cpython/blob/master/Include/code.h\" rel=\"nofollow noreferrer\">cpython/Include/code.h </a></p>\n<p>It is useful to know the order, in which the code object have been dumped, because then we can calculate the each field offset in the resulting string, like - the first four byte is <code>co_argcount</code>, the second is <code>co_kwonlyargcount</code>, etc.</p>\n<p><strong>The order of code object dumping:</strong></p>\n<pre><code>    # PyCodeObject *co - pointer to the code object\n    # p                - pointer to the file object,\n    that accumulating marshaled code object before\n    writing to the file.\n    \n    W_TYPE(TYPE_CODE, p);\n    w_long(co-&gt;co_argcount, p);\n    w_long(co-&gt;co_kwonlyargcount, p);\n    w_long(co-&gt;co_nlocals, p);\n    w_long(co-&gt;co_stacksize, p);\n    w_long(co-&gt;co_flags, p);\n    w_object(co-&gt;co_code, p);\n    w_object(co-&gt;co_consts, p);\n    w_object(co-&gt;co_names, p);\n    w_object(co-&gt;co_varnames, p);\n    w_object(co-&gt;co_freevars, p);\n    w_object(co-&gt;co_cellvars, p);\n    w_object(co-&gt;co_filename, p);\n    w_object(co-&gt;co_name, p);\n    w_long(co-&gt;co_firstlineno, p);\n    w_object(co-&gt;co_lnotab, p);\n</code></pre>\n<h3>The result: foo.py marshaled string fully deciphered:</h3>\n<pre><code>b'\n\\xe3                    &lt;foo.py: '\\xe3' &amp; 0x80 (FLAG_REF)  = 'c' (TYPE_CODE)&gt;\n\\x00\\x00\\x00\\x00        &lt;foo.py: co_argcount: 0&gt;\n\\x00\\x00\\x00\\x00        &lt;foo.py: co_kwonlyargcount: 0&gt;\n\\x00\\x00\\x00\\x00        &lt;foo.py: co_nlocals: 0&gt;\n\\x03\\x00\\x00\\x00        &lt;foo.py: co_stacksize: 3&gt;               \n@\\x00\\x00\\x00           &lt;foo.py: co_flags = '@' = 0x40 = 64&gt;\ns.\\x00\\x00\\x00          &lt;foo.py: number of bytes for module instructions = '.' = 46&gt;\nd\\x00                   &lt;foo.py: co_code:  0 LOAD_CONST        0 (1)\nZ\\x00                   &lt;foo.py: co_code:  2 STORE_NAME        0 (a)\nd\\x01                   &lt;foo.py: co_code:  4 LOAD_CONST        1 (2)\nZ\\x01                   &lt;foo.py: co_code:  6 STORE_NAME        1 (b)\ne\\x00                   &lt;foo.py: co_code:  8 LOAD_NAME         0 (a)\ne\\x01                   &lt;foo.py: co_code: 10 LOAD_NAME         1 (b)\n\\x17\\x00                &lt;foo.py: co_code: 12 BINARY_ADD\nZ\\x02                   &lt;foo.py: co_code: 14 STORE_NAME        2 (c)\nd\\x02                   &lt;foo.py: co_code: 16 LOAD_CONST        2 (&lt;code object baz at 0x7f380995e5d0, file \"foo.py\", line 7&gt;)\nd\\x03                   &lt;foo.py: co_code: 18 LOAD_CONST        3 ('baz')\n\\x84\\x00                &lt;foo.py: co_code: 20 MAKE_FUNCTION     0\nZ\\x03                   &lt;foo.py: co_code: 22 STORE_NAME        3 (baz)\ne\\x03                   &lt;foo.py: co_code: 24 LOAD_NAME         3 (baz)\ne\\x00                   &lt;foo.py: co_code: 26 LOAD_NAME         0 (a)\ne\\x01                   &lt;foo.py: co_code: 28 LOAD_NAME         1 (b)\n\\x83\\x02                &lt;foo.py: co_code: 30 CALL_FUNCTION     2\nZ\\x04                   &lt;foo.py: co_code: 32 STORE_NAME        4 (multiplication)\ne\\x04                   &lt;foo.py: co_code: 34 LOAD_NAME         4 (multiplication)\nd\\x01                   &lt;foo.py: co_code: 36 LOAD_CONST        1 (2)\n\\x13\\x00                &lt;foo.py: co_code: 38 BINARY_POWER\nZ\\x05                   &lt;foo.py: co_code: 40 STORE_NAME        5 (square)\nd\\x04                   &lt;foo.py: co_code: 42 LOAD_CONST        4 (None)\nS\\x00                   &lt;foo.py: co_code: 44 RETURN_VALUE\n)\\x05                   &lt;foo.py: co_const: size&gt;\n\\xe9\\x01\\x00\\x00\\x00    &lt;foo.py: co_const[0]: 1; '\\xe9' &amp; 0x80 (FLAG_REF) = 'i' (TYPE_INT)&gt;\n\\xe9\\x02\\x00\\x00\\x00    &lt;foo.py: co_const[1]: 2; '\\xe9' &amp; 0x80 (FLAG_REF) = 'i' (TYPE_INT)&gt;\nc                       &lt;foo.py: co_const[2]: 'c' = TYPE_CODE&gt;\n\\x02\\x00\\x00\\x00        &lt;baz: co_argcount: 2&gt;\n\\x00\\x00\\x00\\x00        &lt;baz: co_kwonlyargcount: 0&gt;\n\\x02\\x00\\x00\\x00        &lt;baz: co_nlocals: 2&gt;\n\\x02\\x00\\x00\\x00        &lt;baz: co_stacksize: 2&gt;               \nC\\x00\\x00\\x00           &lt;baz: co_flags = 'C' = 0x43 = 67&gt;\ns\\x08\\x00\\x00\\x00       &lt;baz: co_code: size = 8 bytes&gt;\n|\\x00                   &lt;baz: co_code: 0 LOAD_FAST                0 (x) \n|\\x01                   &lt;baz: co_code: 2 LOAD_FAST                1 (y) \n\\x14\\x00                &lt;baz: co_code: 4 BINARY_MULTIPLY                \nS\\x00                   &lt;baz: co_code: 6 RETURN_VALUE                   \n)\\x01                   &lt;baz: co_const: size&gt;\nN                       &lt;baz: co_const[0]: None&gt;\n\\xa9\\x00                &lt;baz: co_names: size = 0  '\\xa9' &amp; 0x80 (FLAG_REF)  = ')'&gt; \n)\\x02                   &lt;baz: co_varnames: size&gt;\n\\xda\\x01                &lt;baz: number of characters of next item; '\\xda' &amp; 0x80 (FLAG_REF)  = 'Z'&gt;\nx                       &lt;baz: co_varnames[0]: x&gt;\n\\xda\\x01                &lt;baz: number of characters of next item; '\\xda' &amp; 0x80 (FLAG_REF)  = 'Z'&gt;\ny                       &lt;baz: co_varnames[1]: y&gt;\nr\\x03\\x00\\x00\\x00       &lt;baz: co_freevars: reference to empty tuple '()'&gt;     \nr\\x03\\x00\\x00\\x00       &lt;baz: co_cellvars: reference to empty tuple '()'&gt;\n\\xfa\\x06                &lt;baz: next item length&gt;\nfoo.py                  &lt;baz: co_filename&gt;\n\\xda\\x03                &lt;baz: number of characters of next item&gt;\nbaz                     &lt;baz: co_name: 'baz'&gt;\n\\x07\\x00\\x00\\x00        &lt;baz: co_firstlineno: 7&gt;\ns\\x02\\x00\\x00\\x00       &lt;baz: co_lnotab: size = 2 &gt;\n\\x00\\x01                &lt;baz: co_lnotab&gt;\nr\\x07\\x00\\x00\\x00       &lt;foo.py: co_const[3]: reference to 'baz'&gt;\nN                       &lt;foo.py: co_const[4]: None&gt;\n)\\x06                   &lt;foo.py: co_names: size&gt; \n\\xda\\x01                &lt;foo.py: number of characters of next item&gt;\na                       &lt;foo.py: co_names[0]: a&gt;\n\\xda\\x01                &lt;foo.py: number of characters of next item&gt;\nb                       &lt;foo.py: co_names[1]: b&gt;\n\\xda\\x01                &lt;foo.py: number of characters of next item&gt;\nc                       &lt;foo.py: co_names[2]: c&gt;\nr\\x07\\x00\\x00\\x00       &lt;foo.py: co_names[3]: reference to 'baz'&gt;\nZ\\x0e                   &lt;foo.py: number of characters of next item&gt;\nmultiplication          &lt;foo.py: co_names[4]: multiplication&gt;\nZ\\x06                   &lt;foo.py: number of characters of next item&gt;\nsquare                  &lt;foo.py: co_names[5]: square&gt;\nr\\x03\\x00\\x00\\x00       &lt;foo.py: co_varnames: reference to empty tuple '()'&gt;     \nr\\x03\\x00\\x00\\x00       &lt;foo.py: co_freevars: reference to emtpy tuple '()'&gt;     \nr\\x03\\x00\\x00\\x00       &lt;foo.py: co_cellvars: reference to empty tuple '()'&gt;\nr\\x06\\x00\\x00\\x00       &lt;foo.py: co_filename: reference to 'foo.py'&gt;     \n\\xda\\x08                &lt;foo.py: number of characters of next item&gt;\n&lt;module&gt;                &lt;foo.py: co_name&gt;\n\\x03\\x00\\x00\\x00        &lt;foo.py: co_firstlineno&gt;\ns\\n\\x00\\x00\\x00         &lt;foo.py: co_lnotab: size = '\\n' = 0A&gt;\n\\x04\\x01                &lt;foo.py: o_lnotab&gt; \n\\x04\\x01                &lt;foo.py: o_lnotab&gt;\n\\x08\\x02                &lt;foo.py: o_lnotab&gt;\n\\x08\\x07                &lt;foo.py: o_lnotab&gt;\n\\n\\x01'                 &lt;foo.py: o_lnotab&gt;\n</code></pre>\n<p><strong>The useful information:</strong></p>\n<p><a href=\"https://stackoverflow.com/a/16123158/2913477\">How to create a code object in python?</a></p>\n</div>",
            "votes": "1",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": []
        }
    ]
}