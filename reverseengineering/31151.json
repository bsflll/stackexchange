{
    "title": "Access to CPU registers in GMM space",
    "link": "https://reverseengineering.stackexchange.com/questions/31151/access-to-cpu-registers-in-gmm-space",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>AMD's BIOS and Kernel Developerâ€™s Guide (BKDG) documents GMM registers and access to them:</p>\n<blockquote>\n<p>GMMxXXXXX: GPU memory mapped registers; XXXXX specifies the hexadecimal byte address offset (this may be 2 to 5 digits) from the base address register; The base address for this space is specified by D1F0x18 [Graphics Memory Mapped Registers Base Address].</p>\n</blockquote>\n<p><code>D1F0x18</code> has the following structure (I also add a column with values that I get):</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Bits</th>\n<th>My value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>31:18</td>\n<td>0x3c08</td>\n<td>BaseAddr[31:18]: base address.</td>\n</tr>\n<tr>\n<td>17:16</td>\n<td>0</td>\n<td>BaseAddr[17:16]: base address.</td>\n</tr>\n<tr>\n<td>15:4</td>\n<td>0</td>\n<td>BaseAddr[15:4]: base address.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>0</td>\n<td>prefetchable. 0=Non-prefetchable memory region.</td>\n</tr>\n<tr>\n<td>2:1</td>\n<td>0</td>\n<td>base address register type. 00b=32-bit BAR. 10b=64-bit BAR.</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>memory space type. 0=Memory mapped base address.</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>How to properly access registers in the GMM space?</p>\n<p>There are three base address fields in the <code>D1F0x18</code> register, and the guide doesn't explain any further how to compile the base address. I tried to read memory (in Linux with <code>root</code> privileges) at the following memory offsets, but all of them return me <code>Segmentation fault</code> error.</p>\n<pre><code>printf(\"%02x\\n\", (unsigned)*(unsigned char*)0x3c08); // Base address itself\nprintf(\"%02x\\n\", (unsigned)*(unsigned char*)0x4378); // 0x3c08+0x770 (GMMx770)\nprintf(\"%02x\\n\", (unsigned)*(unsigned char*)0x4381); // 0x3c08+0x770+3\n\nprintf(\"%02x\\n\", (unsigned)*(unsigned char*)0x3c080000); // Base address appended with zeroes\nprintf(\"%02x\\n\", (unsigned)*(unsigned char*)0x3c080770); // plus GMMx770 offset\nprintf(\"%02x\\n\", (unsigned)*(unsigned char*)0x3c080773); // plus size of the GMMx770\n\nprintf(\"%02x\\n\", (unsigned)*(unsigned char*)0xf0200000); // 0x3c08 shifted left by 2 bits (so that to align 31:18 field to 16 bits)\nprintf(\"%02x\\n\", (unsigned)*(unsigned char*)0xf0200770); // plus GMMx770 offset\nprintf(\"%02x\\n\", (unsigned)*(unsigned char*)0xf0200773); // plus size GMMx770 offset\n\n</code></pre>\n<h3>Edit</h3>\n<p>There is a source code of the <a href=\"https://en.wikipedia.org/wiki/Coreboot\" rel=\"nofollow noreferrer\">Coreboot</a> project available on the Internet. <s>There are clear footprints that they implement access to the GMM space, but I couldn't extract the method from their code either.</s> The code gives some clues:</p>\n<ol>\n<li><s>It looks, like they use the base address as is, i.e. it is <code>0x3c080000</code> in my case.</s></li>\n<li>They set bits 0 and 1 in <code>D1F0x04</code> so that apparently to enable access to the device's memory area (I have both of these bits set by default).</li>\n<li>They read memory with <code>__readfsdword</code>. Because I am on GCC, I redefined this function as follows, but still get the <code>Segmentation fault</code>:</li>\n</ol>\n<pre><code>unsigned long __readfsdword(const unsigned long Offset)\n{\n    unsigned long value;\n    __asm__ __volatile__(\"movl %%fs:%a[Offset], %k[value]\" : [value] \"=r\" (value) : [Offset] \"ir\" (Offset));\n    return value;\n}\n</code></pre>\n</div>",
    "votes": "2",
    "answers": 0,
    "views": "57",
    "tags": [
        "firmware",
        "hardware",
        "register"
    ],
    "user": "Hweaker",
    "time": "Nov 20, 2022 at 4:07",
    "comments": [],
    "answers_data": []
}