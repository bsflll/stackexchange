{
    "title": "Comparing the static address of the vtable of a class, to the pointer to it held by the object",
    "link": "https://reverseengineering.stackexchange.com/questions/27485/comparing-the-static-address-of-the-vtable-of-a-class-to-the-pointer-to-it-held",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I know this is compiler/ABI dependent, not necessarily standardized, etc. I've always assumed, from what I've read in several places (e.g. <a href=\"https://reverseengineering.stackexchange.com/a/5957/33935\">an answer here</a> or <a href=\"https://en.wikipedia.org/w/index.php?title=Virtual_method_table&amp;oldid=1007338497#Example\" rel=\"nofollow noreferrer\">the example in wikipedia</a>), that a typical thing a compiler does is having a pointer to the vtable of <code>Class</code> at the start of an object of type <code>Class</code>.</p>\n<p>I'm now debugging and instrumenting a function that receives a <code>Class*</code> parameter. <code>Class</code> has virtual functions. I want to <strong>determine if it belongs to a class</strong> that I care about. I probably also want to do other things with it, so I'm trying to get a good understanding.</p>\n<p>I look at the disassembly in Ghidra, and I find this about the vtable of that class (paste is coming from an example I wrote, but it's equivalent in a real binary that I want to RE):</p>\n<pre><code>                             **************************************************************\n                             * vtable for DerivedClass                                    *\n                             **************************************************************\n                             _ZTV12DerivedClass                              XREF[3]:     Entry Point(*), \n                             DerivedClass::vtable                                         operator():001039d1(*), \n                                                                                          _elfSectionHeaders::00000650(*)  \n        00107c70 00 00 00        ptrdiff_\n                 00 00 00 \n                 00 00\n           00107c70 [0]                                  0h\n        00107c78 88 7c 10        addr       DerivedClass::typeinfo                           = \n                 00 00 00 \n                 00 00\n                             PTR_ARRAY_00107c80                              XREF[2]:     operator():001039d8(*), \n                                                                                          operator():001039dc(*)  \n        00107c80 94 42 10        addr[1]\n                 00 00 00 \n                 00 00\n           00107c80 94 42 10 00 00  addr      DerivedClass::someVirt  [0]                               XREF[2]:     operator():001039d8(*), \n                    00 00 00                                                                                         operator():001039dc(*)  \n\n</code></pre>\n<p>And here is where my surprise is:</p>\n<ol>\n<li>I get the address of <code>_ZTV12DerivedClass</code> (e.g. via Frida, <code>Module.findExportByName(null, \"_ZTV12DerivedClass\")</code> or in GDB, <code>info address _ZTV12DerivedClass</code>).</li>\n<li>I get the address of the vtable of the object (it's 64 bits, so 8 first bytes of the object), again, in the debugger or with Frida.</li>\n<li>I compare the two, and I get that <em>they are 16 bytes away</em>, the size of 2 pointers: the pointer in the object instance is <strong>not to the start</strong> of the vtable, but at the start of the array of pointers to the virtual functions!</li>\n</ol>\n<p>This is not Earth-shattering in order to compare the pointers, of course. Just add 16. I've seen explanations of what those first two pointers should be. But I have some doubts:</p>\n<ol>\n<li>Is it reliable to assume that the difference of 16 is going to be consistent in all classes in the same binary?</li>\n<li>Is this common in more compilers?</li>\n<li>Do the two positions in the table (the very start of it and the start of the array of pointers to the virtual functions) have any naming convention? I find it surprising that there is a pointer to something and it's not the start of the vtable as found on the disassembly.</li>\n<li>Could be some historical legacy? If C++ first had virtual functions but without virtual inheritance or RTTI, it might explain that those two extra pointers were added to the top to not change some other assumptions.</li>\n</ol>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "428",
    "tags": [
        "linux",
        "gcc",
        "pointer",
        "vtables"
    ],
    "user": "Alejandro Exojo",
    "time": "Apr 16, 2021 at 21:14",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The <a href=\"https://itanium-cxx-abi.github.io/cxx-abi/abi.html\" rel=\"nofollow noreferrer\">Itanium C++ ABI</a> is sometimes not very clear about what exactly is “vtable”.</p>\n<p>In practice, the symbol such as <code>_ZTV12DerivedClass</code> points to the <em>complete vtable structure</em>, which includes the two pointer-sized slots before it (RTTI pointer and offset to top).</p>\n<p>So, to get the start of the virtual function pointers table (what is commonly understood as “the vtable”),  you have to add 16 (or 8 on 32-but platforms) to the symbol’s address.</p>\n</div>",
            "votes": "3",
            "user": "Igor Skochinsky",
            "time": "Apr 16, 2021 at 23:28",
            "is_accepted": true,
            "comments": []
        }
    ]
}