{
    "title": "Change the behavior of any running process",
    "link": "https://reverseengineering.stackexchange.com/questions/26115/change-the-behavior-of-any-running-process",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Would it be possible to develop a program that decompiles the instructions of a running process, for example into a C-like language, and allows them to be modified and then injected into the process itself, changing its behavior?</p>\n</div>",
    "votes": "1",
    "answers": 0,
    "views": "152",
    "tags": [
        "decompiler"
    ],
    "user": "Axeryon",
    "time": "Oct 14, 2020 at 17:46",
    "comments": [
        {
            "user": "morsisko",
            "text": "<span class=\"comment-copy\">Yes, but what is the point since you can modify assembler instructions directly, with much much less effort?</span>",
            "time": null
        },
        {
            "user": "Axeryon",
            "text": "<span class=\"comment-copy\">Wouldn't C or C++ be more comfortable and readable than Assembly?</span>",
            "time": null
        },
        {
            "user": "morsisko",
            "text": "<span class=\"comment-copy\">Don't think so. Something as perfect C or C++ decompiler doesn't exist. They are often more confusing than assembly, and sometimes just wrong.</span>",
            "time": null
        },
        {
            "user": "Axeryon",
            "text": "<span class=\"comment-copy\">Would such a decompiler be technically impossible or just very difficult to develop?</span>",
            "time": null
        },
        {
            "user": "Robert",
            "text": "<span class=\"comment-copy\">@Axeryon The main problem of decompilers is that the generated assembler code can be very different depending on which compiler (and what compile options) was used to generate it. Writing a decompiler for one specific compiler with one specific set of options is difficult. However you have hundred of compilers that can generate e.g. x86 binary code with thousands of options that can be applied. You can see that writing a general decompiler that is generating compilable and correct code is more than a life-time job.</span>",
            "time": null
        }
    ],
    "answers_data": []
}