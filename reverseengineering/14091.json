{
    "title": "Hacking Lua - Introduce new functions into built Lua",
    "link": "https://reverseengineering.stackexchange.com/questions/14091/hacking-lua-introduce-new-functions-into-built-lua",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to hack a game (not for cheating though) by introducing new built-in methods and functions in order to communicate with the game using sockets. Here is a small \"pseudo code\" example of what I want to accomplish:</p>\n<p>Inside the Lua code I am calling <code>my_hack()</code> and pass the current game state:</p>\n<pre><code>GameState = {}\n\n-- Game state object to be passed on\nfunction GameState:new()\n  -- Data\nend\n\nlocal gameState = GameState:new()\n-- Collect game state data and pass it to 'my_hack' ..\nmy_hack(gameState)\n</code></pre>\n<p>and inside <code>my_hack</code> the object is getting sent away:</p>\n<pre><code>int my_hack(lua_State * l)\n{\n   void* gameState= lua_topointer(l, 1);\n\n   // Send the game state:\n   socket-&gt;send_data(gameState);\n\n   return 0;\n}\n</code></pre>\n<hr/>\n<p>Now, the big question is how to introduce <code>my_hack()</code> to the game?</p>\n<p>I assume, that all built in functions must be kept in some sort of lookup table. Since all Lua code is getting interpreted, functions like <code>import</code> etc. will have to be statically available, right? If that is correct, then it should be \"enough\" to find out <em>where</em> this code is residing in order to smuggle my code into the game that would allow me to call <code>my_hack()</code> in a Lua script.</p>\n<p>There should be two options: The first is that the Lua built is embedded inside the executable and is completely static and the second is that all Lua code gets loaded dynamically from a DLL. </p>\n<p>This question goes out to anybody who has a slightest clue about where and how I should keep looking for the built in functions. I've tried a few things with Cheat Engine but I wasn't too successful. I was able to cheat a bit ^^ but that's not what I'm looking out for.</p>\n<hr/>\n<p>This is what my current \"progress\" looks like:</p>\n<p>I found some hints I'm trying to go after in the data section of the executable. For example IDA is giving me</p>\n<pre><code>.rdata:00D44210                 dd offset aLoadfile     ; \"loadfile\"\n.rdata:00D44214                 dd offset sub_90ECE0\n.rdata:00D44218                 dd offset aDofile       ; \"dofile\"\n.rdata:00D4421C                 dd offset sub_90ED20\n.rdata:00D44220                 dd offset aLoadstring   ; \"loadstring\"\n.rdata:00D44224                 dd offset sub_90EC80\n</code></pre>\n<p>Now, I know that these strings here (loadfile, dofile, etc.) are actually the names of built-in functions that modders can use in Lua - a script language in order to change stuff in the game.</p>\n<p>I am trying to find out at which point this address is being accessed for reading. For that I am using Cheat Engine and at this point I would like to stress that I am not trying to cheat here but to introduce new built-in functions in order to have more flexibility when it comes to modding. </p>\n<p>However, the addresses which I see in IDA do not seem to be the actual virtual addresses. If I look at this address with Cheat Engine, which is just reading out the memory, I'm getting nothing. </p>\n<p>So the question is if I will be able to find the correct virtual address of e.g. <code>dofile</code> in order to read that out from my RAM.</p>\n<p>What I hope to see in the end is from where these methods are getting accessed and in a much later step maybe find out where the actual code of <code>dofile</code> resides. At the end I want to smuggle my code into the right place and introduce a new function <code>my_hack</code> in order to get control of the program.</p>\n</div>",
    "votes": "5",
    "answers": 1,
    "views": "4k",
    "tags": [
        "ida",
        "dll-injection",
        "injection"
    ],
    "user": "Stefan Falk",
    "time": "Dec 3, 2016 at 11:53",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>One way of doing this :</p>\n<ul>\n<li><p>Localize <a href=\"http://pgl.yoyo.org/luai/i/lua_gettop\" rel=\"nofollow noreferrer\">lua_gettop</a> in your target binary with IDA (which should be called very frequently). You can get it by downloading Lua sources, and look for error messages in your target binary. You should be able to reconstruct little by little the Lua runtime by looking at XRefs of lua functions containing error messages.</p></li>\n<li><p>Hook lua_gettop, and retrieve the lua_State reference in the first argument :</p></li>\n</ul>\n<blockquote>\n<p></p>\n</blockquote>\n<pre><code>lua_State * hLua = NULL;\n\nint __cdecl lua_gettop_hook (lua_State *self) {\n    int (__cdecl *hooked) (lua_State *) =\n        (typeof(hooked)) get_original_function (lua_gettop_hook);\n    hLua = self;\n    return hooked (self);\n}\n</code></pre>\n<ul>\n<li>Once your lua_gettop hook have been called, load your own version of luaXX.dll inside the game process (using LoadLibrary). <strong>Make sure you load the same lua library version than in the game!</strong> - for instance, lua51.dll.</li>\n</ul>\n<blockquote>\n<p></p>\n</blockquote>\n<pre><code>HMODULE lua51 = LoadLibrary(str_dup_printf(\"%s/luajit/lua51.dll\", luaPath));\n</code></pre>\n<ul>\n<li><p>Call the function you want using the stolen lua_State reference, for instance luaL_loadfile :</p></li>\n<li><p>Load <a href=\"http://pgl.yoyo.org/luai/i/luaL_loadfile\" rel=\"nofollow noreferrer\">luaL_loadfile</a> using GetProcAdress, and call it :</p></li>\n</ul>\n<blockquote>\n<p></p>\n</blockquote>\n<pre><code>LOADFILEFN _luaL_loadfile = (typeof(_luaL_loadfile)) GetProcAddress (lua51, \"luaL_loadfile\"); \n\n// Load custom script \"script.lua\"\nif (_luaL_loadfile (hLua, str_dup_printf(\"%s/script.lua\", scriptPath))) {\n    MessageBox (NULL, \"Cannot load script.lua\", \"ERROR\", 0);\n}\n</code></pre>\n<p>By doing so, you'll be able to inject your own Lua code using the current Lua context of the game.</p>\n</div>",
            "votes": "3",
            "user": "Spl3en",
            "time": "Dec 5, 2016 at 10:32",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Stefan Falk",
                    "text": "<span class=\"comment-copy\">That sounds reasonable and in fact it's not so far away from what I'm currently trying to do. I downloaded the Lua code and found that there is a list <code>base_funcs</code> which has name/address pairs e.g. <code>{\"loadfile\", luaB_loadfile}</code> etc. It seems these are the built-in functions of Lua. I found that this array is getting passed to <code>luaL_openlib()</code> which is getting called in <code>base_open()</code> in file <code>lbaselib.c</code>. To me it looks like as if <code>luaL_openlib()</code> does register these functions. So if I am not mistaken I should be able to do something like this:</span>",
                    "time": null
                },
                {
                    "user": "Stefan Falk",
                    "text": "<span class=\"comment-copy\">Locate <code>base_open()</code> in the executable and inject a <code>jmp</code> to a location wher I inject code that loads <code>my-lua-extension.dll</code> and further calls something like <code>initialize_my_lua_extension(lua_State *L)</code>. Since I have the starting address of <code>luaL_openlib</code> I simply could call this function within my dll and therefore register new methods/functions. I would not have to replace the whole Lua implementations or replace them but would only register additional methods. The question I'd have here whether calling <code>luaL_openlib</code> is enough and if the interpreter will then be able to parse my new methods.</span>",
                    "time": null
                }
            ]
        }
    ]
}