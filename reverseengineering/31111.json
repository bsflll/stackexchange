{
    "title": "Data placement in memory",
    "link": "https://reverseengineering.stackexchange.com/questions/31111/data-placement-in-memory",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am playing with buffer overflow attacks in C. I have the following code:</p>\n<pre><code>int foo(void*, void*);        // Calculates the distance (in bytes) between two addresses in memory\n\nint main(int argc, char** argv) {\n   int a = 15;\n   int b = 16;\n   int c = 90;\n\n   char buffer[4];\n   \n   /* Memory layout */\n   printf(\"[LAYOUT]\\n\");\n   printf(\"foo(&amp;a, &amp;b) is %d\\n\", foo(&amp;a, &amp;b));\n   printf(\"foo(&amp;a, &amp;c) is %d\\n\", foo(&amp;a, &amp;c));\n   printf(\"foo(&amp;c, &amp;string) is %d\\n\", foo(&amp;c, &amp;string));\n   printf(\"foo(&amp;a, &amp;string) is %d\\n\\n\", foo(&amp;a, &amp;string));\n\n   /* Memory content before copying into the buffer */\n   printf(\"[BEFORE]\\n\");\n   printf(\"a is at %p and is %d (0x%08x)\\n\", &amp;a, a, a);\n   printf(\"b is at %p and is %d (0x%08x)\\n\", &amp;b, b, b);\n   printf(\"c is at %p and is %d (0x%08x)\\n\", &amp;c, c, c);\n   printf(\"string is at %p and is %s\\n\\n\", &amp;string, string);\n\n   strcpy(buffer, \"aaaaaaaaa\");\n\n   /* Memory content after copying into the buffer */\n   printf(\"[AFTER]\\n\");\n   printf(\"a is at %p and is %d (0x%08x)\\n\", &amp;a, a, a);\n   printf(\"b is at %p and is %d (0x%08x)\\n\", &amp;b, b, b);\n   printf(\"c is at %p and is %d (0x%08x)\\n\", &amp;c, c, c);\n   printf(\"string is at %p and is %s\\n\", &amp;string, string);\n\n   return EXIT_SUCCESS;\n}\n\nint foo(void* addr_1, void* addr_2) {\n   return (addr_1 - addr_2);\n}\n</code></pre>\n<p>After the compilation with <code>gcc main.c -o main -O0 -g -fno-stack-protector -D_FORTIFY_SOURCE=0</code> flags <strong>with optimization turned off</strong>, the output is following (<em>on my machine</em>):</p>\n<pre><code>[LAYOUT]\nfoo(&amp;a, &amp;b) is 4\nfoo(&amp;a, &amp;c) is 8\nfoo(&amp;c, &amp;string) is 4\nfoo(&amp;a, &amp;string) is 12\n\n[BEFORE]\na is at 0x7ffee13d5b68 and is 16 (0x00000010)\nb is at 0x7ffee13d5b64 and is 15 (0x0000000f)\nc is at 0x7ffee13d5b60 and is 90 (0x0000005a)\nstring is at 0x7ffee13d5b5c and is \n\n[AFTER]\na is at 0x7ffee13d5b68 and is 16 (0x00000010)\nb is at 0x7ffee13d5b64 and is 97 (0x00000061)\nc is at 0x7ffee13d5b60 and is 1633771873 (0x61616161)\nstring is at 0x7ffee13d5b5c and is aaaaaaaaa\n</code></pre>\n<p>Obviously, the buffer is located at the leftmost position, before integer variables. I can think of it as:</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th style=\"text-align: center;\">0x5c</th>\n<th style=\"text-align: center;\">0x5d</th>\n<th style=\"text-align: center;\">0x5e</th>\n<th style=\"text-align: center;\">0x5f</th>\n<th style=\"text-align: center;\">0x60</th>\n<th style=\"text-align: center;\">0x61</th>\n<th style=\"text-align: center;\">0x62</th>\n<th style=\"text-align: center;\">0x63</th>\n<th style=\"text-align: center;\">0x64</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">0x61</td>\n<td style=\"text-align: center;\">0x61</td>\n<td style=\"text-align: center;\">0x61</td>\n<td style=\"text-align: center;\">0x61</td>\n<td style=\"text-align: center;\">0x61</td>\n<td style=\"text-align: center;\">0x61</td>\n<td style=\"text-align: center;\">0x61</td>\n<td style=\"text-align: center;\">0x61</td>\n<td style=\"text-align: center;\">0x61</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>It completely overwrites <code>c</code>'s data (all four bytes) and the one byte of <code>b</code>'s data (<em>little-endian machine</em>).</p>\n<p>After compiling the same program with the optimization turned on, <code>-O1</code> for example, it produces the output:</p>\n<pre><code>[LAYOUT]\nfoo(&amp;a, &amp;b) is -4\nfoo(&amp;a, &amp;c) is -8\nfoo(&amp;c, &amp;string) is 12\nfoo(&amp;a, &amp;string) is 4\n\n[BEFORE]\na is at 0x7ffee056db3c and is 16 (0x00000010)\nb is at 0x7ffee056db40 and is 15 (0x0000000f)\nc is at 0x7ffee056db44 and is 90 (0x0000005a)\nstring is at 0x7ffee056db38 and is \n\n[AFTER]\na is at 0x7ffee056db3c and is 1633771873 (0x61616161)\nb is at 0x7ffee056db40 and is 97 (0x00000061)\nc is at 0x7ffee056db44 and is 90 (0x0000005a)\nstring is at 0x7ffee056db38 and is aaaaaaaaa\n</code></pre>\n<p>It seems to me that integer variables are placed in memory in reversed order.</p>\n<p>The questions are:</p>\n<ol>\n<li><strong>How does a variable declaration and/or initialization in C affect its placement in memory?</strong></li>\n<li><strong>Does the optimization affect on variable placement in memory? If so, then how?</strong></li>\n</ol>\n<p>The working environment is <code>macOS Mojave 10.14.6</code>, <code>Apple LLVM version 10.0.1 (clang-1001.0.46.4)</code></p>\n</div>",
    "votes": "3",
    "answers": 0,
    "views": "47",
    "tags": [
        "disassembly",
        "assembly",
        "c",
        "memory",
        "buffer-overflow"
    ],
    "user": "Stone Paul",
    "time": "Nov 9, 2022 at 1:42",
    "comments": [
        {
            "user": "Mega Tonnage",
            "text": "<span class=\"comment-copy\">You might find that this is compiler dependent.. this is not part of the C standard.</span>",
            "time": null
        }
    ],
    "answers_data": []
}