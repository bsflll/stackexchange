{
    "title": "Locate member of a structure",
    "link": "https://reverseengineering.stackexchange.com/questions/6565/locate-member-of-a-structure",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>In an assembly line, I have a call to <code>gethostbyname(...)</code>. I have read that the return value of that function can be a pointer to a <code>hostent</code> structure\n(of course, it could be also a null pointer but for my question I need the pointer to the hostent structure)</p>\n<p>I also take a look to the hostent structure which is the following:</p>\n<pre><code>   typedef struct hostent{\n    char FAR *h_name;\n    char FAR FAR **h_aliases;\n    short h_addrtype;\n    short h_length;\n    char FAR FAR **h_addr_list;\n   } HOSTENT, *PHOSTENT, FAR *LPHOSTENT;\n\n \n</code></pre>\n<p>So, some lines later the following appears:</p>\n<pre><code>  mov edx, [eax+0Ch]\n</code></pre>\n<p>I know that the return value of a function is stored in <code>eax</code>. So, when <code>eax</code> points to <code>hostent</code> structure, then <code>edx</code> must point to one of the <code>hostent</code> structure <code>members</code>, because the offset is <code>0Ch</code>.</p>\n<p>To determine which of the member it is, i know that I must count the sizes of the members. And here comes my question:</p>\n<blockquote>\n<p>When I count until I reach the offset <code>0Ch</code>, which of these types I must take? I mean, when you look at the first member, for example:</p>\n<pre><code>char FAR *h_name; \n</code></pre>\n<p>Is the size of <code>char</code> relevant or the size of <code>FAR</code> ? Or both ?</p>\n</blockquote>\n<p>I hope someone can explain me that.</p>\n</div>",
    "votes": "2",
    "answers": 2,
    "views": "262",
    "tags": [
        "assembly",
        "struct",
        "offset",
        "pointer"
    ],
    "user": "user3097712",
    "time": "Jun 17, 2020 at 9:54",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><code>FAR</code> is just an attribute, not a data type.  Not even a standard attribute, but an attribute that was introduced with MS-DOS C compilers, to distinguish between 16-bit and 32-bit pointers, and carried over to windows 16 bit, windows 32 bit and, recently, windows 64 bit.</p>\n<p>What is stored in the structure is a pointer to a character (in fact, an array of characters), which has 4 bytes (in the case of a 32 bit program), or 8 bytes (in the case of a 64 bit program). You don't tell which you have, but <code>mov edx, [eax+0Ch]</code> implies 32 bit, as 64 bit registers have names like <code>rdx</code> and <code>rax</code>. So, your structure has this layout (note you also need to know <code>short</code>s have 16 bit):</p>\n<pre><code>offset   bytes bits member\n00-03    4     32   h_name\n04-07    4     32   h_aliases\n08-09    2     16   h_addrtype\n0a-0b    2     16   h_length\n0c-0f    4     32   h_addr_list\n</code></pre>\n<p>Note that it's not always that easy, because <a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment\" rel=\"nofollow\">compilers may introduce padding bytes between struct members for alignment reasons</a>. If you have access to a C compiler, the safest thing is to use <a href=\"http://en.wikipedia.org/wiki/Offsetof\" rel=\"nofollow\">offsetof</a>:</p>\n<pre><code>printf(\"%02x\\n\", offsetof(struct hostent, h_addr_list));\n</code></pre>\n</div>",
            "votes": "2",
            "user": "Guntram Blohm",
            "time": "Nov 3, 2014 at 8:04",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>A sample walkthrough containing few lines of code compiled in msvc++exp and windbagged in 32 bit machine</p>\n<pre><code>int _tmain(int argc, _TCHAR* argv[]) {\n    WSADATA wsaData;    \n    in_addr addr;\n    hostent *myhost;\n        if ((WSAStartup(MAKEWORD(2, 2), &amp;wsaData)) == 0)\n        if ( ( myhost = gethostbyname(\"www.google.com\") ) != NULL) {\n            printf(\"host name = %s\\n\",myhost-&gt;h_name);\n            if (myhost-&gt;h_addrtype == AF_INET) {\n                addr.s_addr = *(u_long *) myhost-&gt;h_addr_list[0];\n                printf(\"IPv4 Addr = %s\\n\",inet_ntoa(addr));\n            }\n        }    \n        return 0;\n}\n</code></pre>\n<p>run the compiled exe in windbg with a conditional break point as below\nexplanation being </p>\n<pre><code>break when ws2_32!gethostbyname is called\ngu is to go up back to caller (eax will hold * to hostent structure)\ndisplay the structure pointed by eax with a c++ expression evaluator  ?? and quit\n</code></pre>\n<p>.</p>\n<pre><code>:\\&gt;cdb -c \"bp ws2_32!gethostbyname \\\"gu ; r eax; ?? (hostent *) @eax;q\\\";g\" ghostbyname.exe    \n0:000&gt; cdb: Reading initial command 'bp ws2_32!gethostbyname \"gu ; r eax; ?? (ho\nstent *) @eax;q\";g'\neax=0016c3b8\nstruct hostent * 0x0016c3b8\n   +0x000 h_name           : 0x0016c3f8  \"www.google.com\"\n   +0x004 h_aliases        : 0x0016c3c8  -&gt; (null)\n   +0x008 h_addrtype       : 0n2\n   +0x00a h_length         : 0n4\n   +0x00c h_addr_list      : 0x0016c3cc  -&gt; 0x0016c3e4  \"J}???\"\nquit:\n\n:\\&gt;\n</code></pre>\n<p>windbg can also be used to ascertain size of individual members </p>\n<pre><code>0:000&gt; ?? sizeof(((hostent *) @eax)-&gt;h_name)\nunsigned int 4\n0:000&gt; ?? sizeof(((hostent *) @eax)-&gt;h_aliases)\nunsigned int 4\n0:000&gt; ?? sizeof(((hostent *) @eax)-&gt;h_addrtype)\nunsigned int 2\n0:000&gt; ?? sizeof(((hostent *) @eax)-&gt;h_length)\nunsigned int 2\n0:000&gt; ?? sizeof(((hostent *) @eax)-&gt;h_addr_list)\nunsigned int 4\n0:000&gt; ?? sizeof(hostent)\nunsigned int 0x10\n</code></pre>\n<p>with sizes gleaned thus dumping it in raw format becomes easy to script in an unknown binary </p>\n<pre><code>r $t0 = ${$arg1}\n.printf /D \"&lt;b&gt;eax          \\t%p &lt;/b&gt;\\n\",@$t0\n.printf /D \"&lt;b&gt;hostent *    \\t%p &lt;/b&gt;\\n\",poi(@$t0)\n.printf /D \"&lt;b&gt;-&gt;h_name     \\t%ma&lt;/b&gt;\\n\",poi(@$t0)\n.printf /D \"&lt;b&gt;-&gt;h_alias    \\t%p &lt;/b&gt;\\n\",poi(poi(@$t0+0x4))\n.printf /D \"&lt;b&gt;-&gt;h_addrtype \\t%p &lt;/b&gt;\\n\",low(poi(@$t0+0x8))\n.printf /D \"&lt;b&gt;-&gt;h_length   \\t%p &lt;/b&gt;\\n\",hi(poi(@$t0+0x8))\n.printf /D \"&lt;b&gt;-&gt;h_addrlist \\t%p &lt;/b&gt;\\n\",poi(poi(@$t0+0xc))\n.printf /D \"&lt;b&gt;-&gt;h_addrlist contains ip address in network byte order&lt;/b&gt;\\n\"\ndb poi(poi(@$t0+0xc)) l10\n.printf /D \"&lt;b&gt;Ipv4 Address of google.com %d.%d.%d.%d\\n\" , \n\nby(poi(poi(@$t0+0xc))),by(poi(poi(@$t0+0xc))+1),by(poi(poi(@$t0+0xc))+2),by(poi(poi(@$t0+0xc))+3)\n</code></pre>\n<p>result dumped in raw format without symbol support in an unknown binary</p>\n<pre><code>0:000&gt; $$&gt;a&lt; ghostbyname.txt @eax\n\neax             0016c3b8 \nhostent *       0016c3f8 \n-&gt;h_name        www.google.com\n-&gt;h_alias       00000000 \n-&gt;h_addrtype    00000002 \n-&gt;h_length      00000004 \n-&gt;h_addrlist    0016c3e4 \n-&gt;h_addrlist contains ip address in network byte order\n0016c3e4  4a 7d ec d0 4a 7d ec d4-4a 7d ec d3 4a 7d ec d1  J}..J}..J}..J}..\nIpv4 Address of google.com 74.125.236.208\n</code></pre>\n</div>",
            "votes": "1",
            "user": "blabb",
            "time": "Nov 3, 2014 at 10:59",
            "is_accepted": false,
            "comments": []
        }
    ]
}