{
    "title": "How to organize vtables in IDA Pro?",
    "link": "https://reverseengineering.stackexchange.com/questions/11811/how-to-organize-vtables-in-ida-pro",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am using IDA Pro to disassemble a C++ behemoth with 1600+ classes, many of them having pure virtual methods.</p>\n<p>Some classes also are made up of multiple base classes, in hierarchies 5+ levels deep.</p>\n<p>Ida PRO supports making structures of pointers, to handle vtables, but some of the final classes can have multiple different vtables in the same \"slot\", due to heavy polymorphism, so how you organize the vtables? How you tell IDA that in this method, or that method, what vtable is actually being refered to?</p>\n</div>",
    "votes": "23",
    "answers": 1,
    "views": "21k",
    "tags": [
        "ida",
        "c++",
        "hexrays"
    ],
    "user": "speeder",
    "time": "Jan 20, 2016 at 18:29",
    "comments": [
        {
            "user": "Jongware",
            "text": "<span class=\"comment-copy\">Funny enough I solved this once for a class heavy executable by writing my own disassembler. At its current state it can gather class members and functions from several DLLs. But not a general solution: the code relies extremely on the particular compiler the code was written with.</span>",
            "time": null
        },
        {
            "user": "speeder",
            "text": "<span class=\"comment-copy\">Why I was downvoted?</span>",
            "time": null
        },
        {
            "user": "sudhackar",
            "text": "<span class=\"comment-copy\">Athough this question is quite old try using <a href=\"https://github.com/igogo-x86/HexRaysPyTools\" rel=\"nofollow noreferrer\">HexRaysPyTools</a> for hexrays</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This depends on the compiler originally used as each creates slightly different layouts. You can find tutorials for most compilers on the net, I'm going to focus MSVC as that's the one I have experience with, and since it provides a <a href=\"https://pigworlds.wordpress.com/2009/01/17/msvc-compiler-d1reportsingleclasslayout-d1reportallclasslayout/\" rel=\"nofollow noreferrer\">hidden compiler switch printing how classes will be layouted in memory</a> which I'm going to use for illustration.</p>\n<p>As you might have already guessed, you have to recreate C++ classes with C structs. This is possible but bothersome, especially if you have as many classes as you said. Some tips to make it less annoying:</p>\n<ul>\n<li>Focus the ones you're interested in.</li>\n<li>Start with the \"base-most\" classes, e.g. the ones at the top of the hierarchy tree. If you mess up something there, fixing it can be expensive later on:; imagine adding a forgotten member to something like a smart pointer base class which is inherited by hundreds of classes, and now you have to adjust all of those.</li>\n<li>You may want to define the <code>struct</code>s with C like code in the <strong>Local Types</strong> subview first and not in the <strong>Structures</strong> subview. The following samples can be pasted as local types.</li>\n<li>If you're unsure about reversing a struct, a constructor typically spoils the vftable and the layout of some members; a function calling it may yield the total size of the object by reserving enough bytes for it.</li>\n</ul>\n<blockquote>\n<ul>\n<li>IDA 7.0 helps you a lot by automatically recognizing and marking <a href=\"http://www.openrce.org/articles/full_view/23\" rel=\"nofollow noreferrer\">RTTI data</a> (if available) which spoils the class hierarchy and vftables, but it incorrectly marks which vftable belongs to which base class in case of multiple inheritance, an issue <a href=\"http://www.openrce.org/downloads/details/196\" rel=\"nofollow noreferrer\">the IDA6 script it is based on</a> didn't have. I <a href=\"https://gitlab.com/Syroot/ida-tools/-/blob/master/scripts\" rel=\"nofollow noreferrer\">rewrote it</a> in IDAPython for 7.0 to fix this and other MSVC related issues, it can also automatically create the structs as explained below.</li>\n<li>IDA 7.2 has <a href=\"https://www.hex-rays.com/products/ida/7.2/index.shtml\" rel=\"nofollow noreferrer\">even better support</a> for automatically detecting and recreating C++ structures, but the following answer was written with 7.0 in mind and using 7.2 naming.</li>\n</ul>\n</blockquote>\n<p>Depending on how fancy your polymorphism is, your C structs have to be more or less fancy aswell. So let's start with the simple cases first and work our way to the more complicated ones.</p>\n<hr/>\n<p><strong>No inheritance (base class)</strong></p>\n<p>The simplest case does not use any inheritance at all, only some members and (pure) virtual methods to start with:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Animal {\n    int _age;\n    Animal() { _age = 0; }\n    int getAge() { return _age; }\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() = 0;\n};\n</code></pre>\n<p>MSVC layout:</p>\n<pre><code>class Animal    size(8):\n        +---\n 0      | {vfptr} // pointer to the vftable (s. below)\n 4      | _age    // members of Animal\n        +---\n\nAnimal::$vftable@:\n        | &amp;Animal_meta    // ignore meta for our examples\n        |  0              // the (pure) virtual method follow\n 0      | &amp;Animal::setAge    \n 1      | &amp;Animal::makeSound\n</code></pre>\n<p>IDA representation:</p>\n<pre class=\"lang-c prettyprint-override\"><code>struct Animal;\nstruct Animal_vtbl {\n  void (__thiscall *setAge)(Animal *this, int value);\n  void (__thiscall *makeSound)(Animal *this);\n};\nstruct Animal_mbrs {\n  int _age;\n};\nstruct Animal {\n  Animal_vtbl *__vftable;\n  Animal_mbrs __members;\n};\n</code></pre>\n<blockquote>\n<ul>\n<li>Forward declare the class struct to use it in the <code>this</code> parameter of the vftable.</li>\n<li>MSVC uses the <code>__thiscall</code> calling convention by default to create class methods. It implicitly passes a pointer to the class instance in the <code>ecx</code> register besides all other parameters.</li>\n<li>It is not required to provide names for the parameters.</li>\n<li><code>makeSound</code> will be a <code>purecall</code>, and <code>setAge</code> will be a typical unknown sub modifying our member.</li>\n<li>Place members in a separate structure for inheritance (s. below).</li>\n</ul>\n</blockquote>\n<hr/>\n<p><strong>Single inheritance</strong></p>\n<p>Let's quickly breed a <code>Dog</code> inheriting from <code>Animal</code>, implement the <code>makeSound</code> method, and add a new virtual method to set the fur color:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Dog : public Animal {\n    int _furColor;\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() { cout &lt;&lt; \"Woof Woof\"; }\n    virtual void setFurColor(int color) { _furColor = color; }\n};\n</code></pre>\n<p>MSVC layout: The <code>Animal</code> base class is simply embedded inside the <code>Dog</code> class. The embedded <code>Animal</code> vftable also grabs all the virtual <code>Dog</code> methods and adds them at its end. The members of <code>Dog</code> appear behind <code>Animal</code>s members:</p>\n<pre><code>class Dog       size(12):\n        +---\n 0      | +--- (base class Animal)\n 0      | | {vfptr}\n 4      | | _age\n        | +---\n 8      | _furColor\n        +---\n\nDog::$vftable@:\n        | &amp;Dog_meta\n        |  0\n 0      | &amp;Dog::setAge\n 1      | &amp;Dog::makeSound\n 2      | &amp;Dog::setFurColor // Added behind the Animal methods!\n</code></pre>\n<p>IDA representation: Leaving <code>Animal</code> structures untouched, we add the following:</p>\n<pre class=\"lang-c prettyprint-override\"><code>struct Dog;\nstruct Dog_vtbl : Animal_vtbl {\n  void (__thiscall *setFurColor)(Dog *this, int color);\n};\nstruct Dog_mbrs : Animal_mbrs {\n  int _furColor;\n};\nstruct Dog {\n  Dog_vtbl *__vftable;\n  Dog_mbrs __members;\n};\n</code></pre>\n<blockquote>\n<ul>\n<li>Reuse the <code>Animal</code> vftable by letting the <code>Dog</code> vftable inherit from it (inheriting a struct in IDA simply means prepending it), then add the <code>Dog</code> specific virtual functions.</li>\n<li>The same thing happens with the members, which is why I separated them earlier.</li>\n</ul>\n</blockquote>\n<hr/>\n<p><strong>Multiple inheritance</strong></p>\n<p>This requires a bit of mind-mangling. For this, we make it possible to kill our dog (sorry if that's cruel to you, I'm bad at creating happy examples):</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Killable {\n    bool _isDead;\n    virtual void kill() { makeDeathSound(); _isDead = true; }\n    virtual void makeDeathSound() = 0;\n};\n\nclass Dog : public Animal, public Killable {\n    int _furColor;\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() { cout &lt;&lt; \"Woof Woof\"; }\n    virtual void setFurColor(int color) { _furColor = color; }\n    virtual void makeDeathSound() { cout &lt;&lt; \"I'll call WWF, bark-blerg\"; }\n};\n</code></pre>\n<p>MSVC layout: As with the <code>Animal</code> base class, it embeds the second <code>Killable</code> base class into the <code>Dog</code> class aswell, and keeps <code>Dog</code>s members separate. While <code>Dog</code>-specific virtual methods are <em>still</em> merged with the <code>Animal</code> vftable (aka the first base class), <code>Killable</code> related ones are in a separate <code>Killable</code>-related vftable, so we now have:</p>\n<pre><code>class Dog       size(20):\n        +---\n 0      | +--- (base class Animal)\n 0      | | {vfptr}\n 4      | | _age\n        | +---\n 8      | +--- (base class Killable)\n 8      | | {vfptr}\n12      | | _isDead\n        | | &lt;alignment member&gt; (size=3) // since _isDead is a 1-byte bool\n        | +---\n16      | _furColor\n        +---\n\nDog::$vftable@Animal@:\n        | &amp;Dog_meta\n        |  0\n 0      | &amp;Dog::setAge\n 1      | &amp;Dog::makeSound\n 2      | &amp;Dog::setFurColor // Dog methods still merged with Animal!\n\nDog::$vftable@Killable@: // All the Killable-related methods in here\n        | -8 // offset for `this` pointer in Killable methods to get a Dog pointer\n 0      | &amp;Killable::kill\n 1      | &amp;Dog::makeDeathSound\n</code></pre>\n<p>IDA representation: We keep a <code>Dog</code>-specific vftable at the start which reuses the <code>Animal</code> vftable internally, as the <code>Dog</code> virtual methods are still appended to <code>Animal</code>s vftable. Then <code>Animal</code>s members follow as usual. Now, the untouched <code>Killable</code> structs follow, since nothing gets merged into them. At the end, our <code>Dog</code> members follow. If you compare this to the offsets MSVC printed, it makes sense:</p>\n<pre class=\"lang-c prettyprint-override\"><code>struct Killable;\nstruct Killable_vtbl {\n    void (__thiscall *kill)(Killable *this);\n    void (__thiscall *makeDeathSound)(Killable *this);\n};\nstruct Killable_mbrs {\n    bool _isDead;\n};\nstruct Killable {\n  Killable_vtbl* __vftable;\n  Killable_mbrs __members;\n};\n\nstruct Dog;\nstruct Dog_vtbl : Animal_vtbl {\n  void (__thiscall *setFurColor)(Dog *this, int color);\n};\nstruct Dog_mbrs { // No more base Animal members as they're split up now!\n  int _furColor; \n};\nstruct Dog {\n  Dog_vtbl *__vftable; // Still contains animal methods.\n  Animal_mbrs __members_Animal; // Animal members come here separately.\n  Killable_vtbl *__vftable_Killable;\n  Killable_mbrs __members_Killable;\n  Dog_mbrs __members;\n};\n</code></pre>\n<blockquote>\n<p>IDA 7.2 uses slightly different naming for vftables participating in multiple inheritance. I find it bothersome to deal with manually, so we won't use it here.</p>\n</blockquote>\n<p>Let's see how this looks like in the <code>Dog::ctor</code> pseudocode:</p>\n<pre class=\"lang-c prettyprint-override\"><code>Dog *__thiscall Dog::ctor(Dog *this)\n{\n  j_Animal::ctor((Animal *)this);\n  j_Killable::ctor((Killable *)&amp;this-&gt;__vftable_Killable);\n  this-&gt;__vftable = (Dog_vftable *)&amp;Dog::`vftable';\n  this-&gt;__vftable_Killable = (Killable_vftable *)&amp;Dog::`vftable';\n  return this;\n}\n</code></pre>\n<p>As typical for constructors, the base class constructors are called first. Then, the vftables required for <code>Dog</code> are set. But something doesn't make sense: Why is <code>Dog::vftable</code> assigned to our <code>__vftable_Killable</code>? Well, I used IDA 7.0's naming here, and what I previously mentioned is that it doesn't mark which vftable maps to which base class anymore (unlike the script). With the IDA 6.0 or my IDAPython script, it would say:</p>\n<pre class=\"lang-c prettyprint-override\"><code>Dog *__thiscall Dog::ctor(Dog *this)\n{\n  j_Animal::ctor((Animal *)this);\n  j_Killable::ctor((Killable *)&amp;this-&gt;__vftable_Killable);\n  this-&gt;__vftable = (Dog_vftable *)&amp;Dog::`vftable for Animal';\n  this-&gt;__vftable_Killable = (Killable_vftable *)&amp;Dog::`vftable for Killable';\n  return this;\n}\n</code></pre>\n<p>Now the names aren't the same and make more sense, so don't get busted by this IDA 7 annoyance, double click the names to check where they'll actually lead.</p>\n<blockquote>\n<p>I do not recommend setting the actual type of the vftables to their locations / names: You get nothing out of it, it just makes the disassembly output messy.</p>\n</blockquote>\n<hr/>\n<p><strong>Bonus: Classes inherited from classes using multiple inheritance (wew)</strong></p>\n<p>This one kept me a little baffled for some time, maybe because it's not covered in most tutorials on the net on which I so rely on, or maybe because I'm just dumb. Let's inherit from <code>Dog</code> with our <code>Terrier</code> class.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Terrier : public Dog {\n    int _annoyanceLevel;\n    virtual void setAge(int value) { _age = value; }\n    virtual void makeSound() { cout &lt;&lt; \"Bark Bark not Woof Woof\"; }\n    virtual void annoy() { _annoyanceLevel++; }\n};\n</code></pre>\n<p>MSVC layout: It doesn't seem too special. The <code>Animal</code> vftable <em>still</em> merges the new virtual methods of our <code>Terrier</code>, and everything else has its separate vftable:</p>\n<pre><code>class Terrier   size(24):\n        +---\n 0      | +--- (base class Dog)\n 0      | | +--- (base class Animal)\n 0      | | | {vfptr}\n 4      | | | _age\n        | | +---\n 8      | | +--- (base class Killable)\n 8      | | | {vfptr}\n12      | | | _isDead\n        | | | &lt;alignment member&gt; (size=3)\n        | | +---\n16      | | _furColor\n        | +---\n20      | _annoyanceLevel\n        +---\n\nTerrier::$vftable@Animal@:\n        | &amp;Terrier_meta\n        |  0\n 0      | &amp;Terrier::setAge\n 1      | &amp;Terrier::makeSound\n 2      | &amp;Dog::setFurColor\n 3      | &amp;Terrier::annoy // Animal even takes the Terrier methods (greedy!)\n\nTerrier::$vftable@Killable@:\n        | -8\n 0      | &amp;Killable::kill\n 1      | &amp;Dog::makeDeathSound\n</code></pre>\n<p>IDA representation: It's pretty similar to our first <code>Dog</code> struct creation, just that we need to respect the second base class of <code>Dog</code> aswell.</p>\n<pre class=\"lang-c prettyprint-override\"><code>struct Terrier_vtbl : Dog_vtbl {\n  void (__thiscall *annoy)(Terrier *this);\n};\nstruct Terrier_mbrs : Dog_mbrs {\n  int _annoyanceLevel;\n};\nstruct Terrier {\n  Terrier_vtbl *__vftable;\n  Animal_mbrs __members_Animal;\n  Killable_vtbl *__vftable_Killable;\n  Killable_mbrs __members_Killable;\n  Terrier_mbrs __members;\n};\n</code></pre>\n</div>",
            "votes": "39",
            "user": "Ray",
            "time": "Mar 16, 2023 at 10:35",
            "is_accepted": false,
            "comments": [
                {
                    "user": "savram",
                    "text": "<span class=\"comment-copy\">Is \"__thiscall\" necessary to work?</span>",
                    "time": null
                },
                {
                    "user": "Trass3r",
                    "text": "<span class=\"comment-copy\">For reference here's what 7.2+ generates: <a href=\"https://www.hex-rays.com/products/ida/support/idadoc/1691.shtml\" rel=\"nofollow noreferrer\">hex-rays.com/products/ida/support/idadoc/1691.shtml</a></span>",
                    "time": null
                }
            ]
        }
    ]
}