{
    "title": "Why this x64 shellcode doesn't work?(segmentation fault)",
    "link": "https://reverseengineering.stackexchange.com/questions/31598/why-this-x64-shellcode-doesnt-worksegmentation-fault",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I found a simple shellcode on the internet.\nThen, to test this shellcode, I make the simple ret overwrite code.</p>\n<p>test.c</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nchar buf[100];\n\nint main(void)\n{\n        char x=0;\n        strcpy(buf, \"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\");\n\n        *(&amp;x+9)=0x40;\n        *(&amp;x+10)=0x40;\n        *(&amp;x+11)=0x40;\n        *(&amp;x+12)=0x00;\n        *(&amp;x+13)=0x00;\n        *(&amp;x+14)=0x00;\n        *(&amp;x+15)=0x00;\n        *(&amp;x+16)=0x00;\n\n        puts(\"end of program\");\n}\n</code></pre>\n<p>I compiled this using gcc like this.</p>\n<pre><code>gcc -o test test.c -fno-stack-protector -mpreferred-stack-boundary=2 -no-pie -fno-pie -z execstack\n</code></pre>\n<p>and the following is the result of what I debugged with gdb.</p>\n<pre><code>┌──(kali㉿kali)-[~]\n└─$ gdb -q test                                                                                \nReading symbols from test...\n(No debugging symbols found in test)\n(gdb) set disassembly-flavor intel\n(gdb) disas main\nDump of assembler code for function main:\n   0x0000000000401126 &lt;+0&gt;:     push   rbp\n   0x0000000000401127 &lt;+1&gt;:     mov    rbp,rsp\n   0x000000000040112a &lt;+4&gt;:     sub    rsp,0x10\n   0x000000000040112e &lt;+8&gt;:     mov    BYTE PTR [rbp-0x1],0x0\n   0x0000000000401132 &lt;+12&gt;:    movabs rax,0x6e69622fbb48f631\n   0x000000000040113c &lt;+22&gt;:    movabs rdx,0x5f54535668732f2f\n   0x0000000000401146 &lt;+32&gt;:    mov    QWORD PTR [rip+0x2ef3],rax        # 0x404040 &lt;buf&gt;\n   0x000000000040114d &lt;+39&gt;:    mov    QWORD PTR [rip+0x2ef4],rdx        # 0x404048 &lt;buf+8&gt;\n   0x0000000000401154 &lt;+46&gt;:    movabs rax,0x50fd231583b6a\n   0x000000000040115e &lt;+56&gt;:    mov    QWORD PTR [rip+0x2eeb],rax        # 0x404050 &lt;buf+16&gt;\n   0x0000000000401165 &lt;+63&gt;:    lea    rax,[rbp-0x1]\n   0x0000000000401169 &lt;+67&gt;:    add    rax,0x9\n   0x000000000040116d &lt;+71&gt;:    mov    BYTE PTR [rax],0x40\n   0x0000000000401170 &lt;+74&gt;:    lea    rax,[rbp-0x1]\n   0x0000000000401174 &lt;+78&gt;:    add    rax,0xa\n   0x0000000000401178 &lt;+82&gt;:    mov    BYTE PTR [rax],0x40\n   0x000000000040117b &lt;+85&gt;:    lea    rax,[rbp-0x1]\n   0x000000000040117f &lt;+89&gt;:    add    rax,0xb\n   0x0000000000401183 &lt;+93&gt;:    mov    BYTE PTR [rax],0x40\n   0x0000000000401186 &lt;+96&gt;:    lea    rax,[rbp-0x1]\n   0x000000000040118a &lt;+100&gt;:   add    rax,0xc\n   0x000000000040118e &lt;+104&gt;:   mov    BYTE PTR [rax],0x0\n   0x0000000000401191 &lt;+107&gt;:   lea    rax,[rbp-0x1]\n   0x0000000000401195 &lt;+111&gt;:   add    rax,0xd\n   0x0000000000401199 &lt;+115&gt;:   mov    BYTE PTR [rax],0x0\n   0x000000000040119c &lt;+118&gt;:   lea    rax,[rbp-0x1]\n   0x00000000004011a0 &lt;+122&gt;:   add    rax,0xe\n   0x00000000004011a4 &lt;+126&gt;:   mov    BYTE PTR [rax],0x0\n   0x00000000004011a7 &lt;+129&gt;:   lea    rax,[rbp-0x1]\n   0x00000000004011ab &lt;+133&gt;:   add    rax,0xf\n   0x00000000004011af &lt;+137&gt;:   mov    BYTE PTR [rax],0x0\n   0x00000000004011b2 &lt;+140&gt;:   lea    rax,[rbp-0x1]\n   0x00000000004011b6 &lt;+144&gt;:   add    rax,0x10\n   0x00000000004011ba &lt;+148&gt;:   mov    BYTE PTR [rax],0x0\n   0x00000000004011bd &lt;+151&gt;:   lea    rax,[rip+0xe40]        # 0x402004\n   0x00000000004011c4 &lt;+158&gt;:   mov    rdi,rax\n   0x00000000004011c7 &lt;+161&gt;:   call   0x401030 &lt;puts@plt&gt;\n   0x00000000004011cc &lt;+166&gt;:   mov    eax,0x0\n   0x00000000004011d1 &lt;+171&gt;:   leave\n   0x00000000004011d2 &lt;+172&gt;:   ret\nEnd of assembler dump.\n(gdb) b *main+172\nBreakpoint 1 at 0x4011d2\n(gdb) r\nStarting program: /home/kali/test \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nend of program\n\nBreakpoint 1, 0x00000000004011d2 in main ()\n(gdb) si\n0x0000000000404040 in buf ()\n(gdb) x/30i $rip\n=&gt; 0x404040 &lt;buf&gt;:      xor    esi,esi\n   0x404042 &lt;buf+2&gt;:    movabs rbx,0x68732f2f6e69622f\n   0x40404c &lt;buf+12&gt;:   push   rsi\n   0x40404d &lt;buf+13&gt;:   push   rbx\n   0x40404e &lt;buf+14&gt;:   push   rsp\n   0x40404f &lt;buf+15&gt;:   pop    rdi\n   0x404050 &lt;buf+16&gt;:   push   0x3b\n   0x404052 &lt;buf+18&gt;:   pop    rax\n   0x404053 &lt;buf+19&gt;:   xor    edx,edx\n   0x404055 &lt;buf+21&gt;:   syscall\n   0x404057 &lt;buf+23&gt;:   add    BYTE PTR [rax],al\n   0x404059 &lt;buf+25&gt;:   add    BYTE PTR [rax],al\n   0x40405b &lt;buf+27&gt;:   add    BYTE PTR [rax],al\n   0x40405d &lt;buf+29&gt;:   add    BYTE PTR [rax],al\n   0x40405f &lt;buf+31&gt;:   add    BYTE PTR [rax],al\n   0x404061 &lt;buf+33&gt;:   add    BYTE PTR [rax],al\n   0x404063 &lt;buf+35&gt;:   add    BYTE PTR [rax],al\n   0x404065 &lt;buf+37&gt;:   add    BYTE PTR [rax],al\n   0x404067 &lt;buf+39&gt;:   add    BYTE PTR [rax],al\n   0x404069 &lt;buf+41&gt;:   add    BYTE PTR [rax],al\n   0x40406b &lt;buf+43&gt;:   add    BYTE PTR [rax],al\n   0x40406d &lt;buf+45&gt;:   add    BYTE PTR [rax],al\n   0x40406f &lt;buf+47&gt;:   add    BYTE PTR [rax],al\n   0x404071 &lt;buf+49&gt;:   add    BYTE PTR [rax],al\n   0x404073 &lt;buf+51&gt;:   add    BYTE PTR [rax],al\n   0x404075 &lt;buf+53&gt;:   add    BYTE PTR [rax],al\n   0x404077 &lt;buf+55&gt;:   add    BYTE PTR [rax],al\n   0x404079 &lt;buf+57&gt;:   add    BYTE PTR [rax],al\n   0x40407b &lt;buf+59&gt;:   add    BYTE PTR [rax],al\n   0x40407d &lt;buf+61&gt;:   add    BYTE PTR [rax],al\n(gdb) si\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000404040 in buf ()\n</code></pre>\n<p>I think that 'xor esi,esi' don't generate segmentation fault, but It generated. Why the segmentation fault occured?</p>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "349",
    "tags": [
        "c",
        "gdb",
        "x86-64",
        "shellcode",
        "gcc"
    ],
    "user": "doldom",
    "time": "Feb 28, 2023 at 11:55",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Your <code>buf</code> variable is a global variable, which most likely is located inside <code>.data</code> section.</p>\n<p>This section is not executable by default (it probably has RW permissions). You can check its permissions with <code>readelf</code> utility.</p>\n<p>Since you are putting your shell code inside a buffer located in a non executable section of memory, upon executing first instructions, program segfaults.</p>\n<p>Considering arguments you are passing to compile your code, I assume that you wanted your shell code to be located in the stack. Thus, to avoid segfault, your <code>buf</code> array should be a local variable (place your array inside <code>main</code> function).</p>\n</div>",
            "votes": "1",
            "user": "Qwark",
            "time": "Feb 28, 2023 at 15:40",
            "is_accepted": true,
            "comments": []
        }
    ]
}