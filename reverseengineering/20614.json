{
    "title": "x64dbg - Locating where data is initially written",
    "link": "https://reverseengineering.stackexchange.com/questions/20614/x64dbg-locating-where-data-is-initially-written",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am hoping someone can help me with a question or two.</p>\n<p>Essentially I used to be a computer programmer who always wanted to get into a bit of game hacking, having not done any serious programming for a few years I had an itch for a technical endeavour. I decided on football (soccer) manager and wanted to do two things.</p>\n<ol>\n<li>Decipher their file format for tactics. Essentially this has changed\nfrom tac to fmf in the last version or so </li>\n<li>When a game is being played hook into the DirectX calls to essentially record a match, or figure out the format of their saved matches which can be shown to others</li>\n</ol>\n<p>Now as I have no experience of DirectX I went to do number 1 first and have made good progress, but I am at the point where I need a bit of help and pointing in the right direction. Here's what I have deciphered so far with screenshots.</p>\n<p><strong>The start of the fmf file is written (always 02 01 61 66 65 afe) to start, so essentially the file header</strong></p>\n<p><a href=\"https://i.sstatic.net/jEIsj.png\" rel=\"nofollow noreferrer\"><img alt=\"start of FMF file\" src=\"https://i.sstatic.net/jEIsj.png\"/></a></p>\n<p><strong>Then actually the old TAC format is written to disk though the user never sees it unless you breakpoint it, as it puts the tactic on the file, reads it back in and then deletes it again</strong></p>\n<p><a href=\"https://i.sstatic.net/l78ON.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/l78ON.png\"/></a></p>\n<p><a href=\"https://i.sstatic.net/Vpb59.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/Vpb59.png\"/></a></p>\n<p><strong>The TAC file is read back in and a new section of the fmf is written</strong></p>\n<p><a href=\"https://i.sstatic.net/ZQZhV.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/ZQZhV.png\"/></a></p>\n<p><strong>Now this looks similar in size to the previous tac file and is written after the tac file is read back in by the application, it also seems to have section separators in the FMF file so it is its own section.</strong></p>\n<p><a href=\"https://i.sstatic.net/edtCl.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/edtCl.png\"/></a></p>\n<p>If you look carefully you can see that this section is what was written after it read the tac file back in, now this section appears to be compressed/encrypted but I would guess that this is the tac, and you can clearly see distinct sections in the file separated by</p>\n<p>10 00 00 00 10 00 00 00</p>\n<p>So it is easy to break the file up. Now my question is, this section is the area of interest.</p>\n<p><a href=\"https://i.sstatic.net/1jfGa.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/1jfGa.png\"/></a></p>\n<p>The actual data always seems to be around rcx+8 which points to an address with a QWORD pointer which points to the data. I tried decompiling this function and got the following:</p>\n<pre><code>struct s0 {\n    uint32_t f0;\n    int8_t[4] pad8;\n    uint32_t f8;\n    int8_t[4] pad16;\n    uint32_t f16;\n    uint32_t f20;\n};\n\nint32_t fun_146da5dd0();\n\n/* function-which-calls-write */\nuint32_t function_which_calls_write(int64_t rcx, uint32_t rdx, int64_t r8);\n\n/* unknown 1 */\nint64_t unknown_1(struct s0* rcx) {\n    uint32_t eax2;\n    uint32_t eax3;\n    uint32_t edi4;\n    uint32_t rsi5;\n    int64_t rax6;\n    int32_t eax7;\n    int64_t rcx8;\n    int64_t r8_9;\n    uint32_t eax10;\n    uint32_t eax11;\n\n    eax2 = rcx-&gt;f20;    \n    if ((*(uint8_t*)&amp;eax2 &amp; 3) != 2 || ((eax3 = rcx-&gt;f20, (*(uint8_t*)&amp;eax3 &amp; 0xc0) == 0) || (edi4 = rcx-&gt;f0 - rcx-&gt;f8, rcx-&gt;f16 = 0, rsi5 = rcx-&gt;f8, rcx-&gt;f0 =     rsi5, (uint1_t)((int32_t)edi4 &lt; (int32_t)0) | (uint1_t)(edi4 == 0)))) {\n        addr_0x146d9e917_2:\n        *(uint32_t*)&amp;rax6 = 0;\n        *(int32_t*)((int64_t)&amp;rax6 + 4) = 0;\n    } else {\n        eax7 = fun_146da5dd0();\n        *(int32_t*)&amp;rcx8 = eax7;\n        *(int32_t*)((int64_t)&amp;rcx8 + 4) = 0;\n        *(uint32_t*)&amp;r8_9 = edi4;\n        *(int32_t*)((int64_t)&amp;r8_9 + 4) = 0;\n        eax10 = function_which_calls_write(rcx8, rsi5, r8_9);\n        if (edi4 == eax10) {\n            eax11 = rcx-&gt;f20 &gt;&gt; 2;\n            if (*(uint8_t*)&amp;eax11 &amp; 1) {\n                rcx-&gt;f20 = rcx-&gt;f20 &amp; 0xfffffffd;\n                goto addr_0x146d9e917_2;\n            }\n        } else {\n            rcx-&gt;f20 = rcx-&gt;f20 | 16;\n            *(uint32_t*)&amp;rax6 = 0xffffffff;\n            *(int32_t*)((int64_t)&amp;rax6 + 4) = 0;\n        }\n    }\n    return rax6;\n}\n</code></pre>\n<p>So obvious it seems like a struct, especially with the +number on the registers.</p>\n<p>Another useful thing to note is that these sections in the fmf file are always different, ALWAYS, so if I make a tactic, save it, load in the tactic again (exact same one) and resave it is totally different content in between the constant separators 10 00 00 00 and the signature at the start of the file. So that leads me to believe it is some form of compression/encryption but with additional seed, such as the time added.</p>\n<p>My question is I have located this data in the function I showed above, but obviously, there is data loaded in before this place in the function or in a previous function in the call stack. <strong>Is there any quick way of following where this data comes from?</strong> Once I find the exact point it originates I should obviously be able to conclude that is the encryption/compression function which produces it.</p>\n<p>Thanks a lot.</p>\n</div>",
    "votes": "0",
    "answers": 1,
    "views": "1k",
    "tags": [
        "x64dbg",
        "game-hacking"
    ],
    "user": "Tim",
    "time": "Feb 14, 2019 at 13:18",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>If you know where the data is going to be before it's written, you can set a write hardware breakpoint and it should stop whenever that memory location is populated.<br/>\nOtherwise, you'll to reverse engineer where RCX comes by going up the stack frame judging by the decompiled output.</p>\n</div>",
            "votes": "1",
            "user": "NotGI",
            "time": "Feb 16, 2019 at 10:48",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Tim",
                    "text": "<span class=\"comment-copy\">Thanks for commenting NotGI, are there any techniques you can share, for example compiled output, you mean using a tool such as IDE Pro?  I have checked the \"Call Stack\" tab but sometimes it doesn't appear accurate.</span>",
                    "time": null
                },
                {
                    "user": "NotGI",
                    "text": "<span class=\"comment-copy\">@Tim, In order to determine the function from which you came from, you can use gdb/ollydbg for debugging and given a standard calling convention in a 32 bits system the saved EIP should be in <code>$ebp+4</code> and for 64 bits <code>$rbp+8</code>.</span>",
                    "time": null
                }
            ]
        }
    ]
}