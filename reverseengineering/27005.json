{
    "title": "Why this ASM represents Virtual Function call?",
    "link": "https://reverseengineering.stackexchange.com/questions/27005/why-this-asm-represents-virtual-function-call",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm referring to this question that was asked previously:\n<a href=\"https://reverseengineering.stackexchange.com/questions/26630/virtual-functions-call-asm/26634\">Virtual functions call asm</a></p>\n<p>I'm wondering how is it possible to know whether this ASM listing represents Virtual Functions calls? What's in the ASM mentioned in the question linked above that tells that this is Virtual Function call?</p>\n</div>",
    "votes": "2",
    "answers": 2,
    "views": "337",
    "tags": [
        "disassembly",
        "c++",
        "static-analysis",
        "virtual-functions"
    ],
    "user": "Abdullah Mohamed",
    "time": "Feb 14, 2021 at 8:28",
    "comments": [
        {
            "user": "blabb",
            "text": "<span class=\"comment-copy\">an indirect call like call eax, call[ecx+4] , call [reg+offset]  calls indicate that</span>",
            "time": null
        },
        {
            "user": "Abdullah Mohamed",
            "text": "<span class=\"comment-copy\">Thanks for your reply! Wouldn't a normal class method call result in similar indirect register calls as well? As well as Struct functions and function pointers?</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>an indirect call , use of ecx as the this pointer etc indicates it is a virtual function call</p>\n<p>lets take the example you quoted in your query modify it a little and see the disassembly</p>\n<p>contents of directory pre compilation</p>\n<pre><code>D:\\virt&gt;dir /b\nvirt.cpp\n</code></pre>\n<p>source from example duly modified a bit</p>\n<pre><code>D:\\virt&gt;type virt.cpp\n01 #include &lt;iostream&gt;\n02 class Animal {\n03 public:\n04     Animal( char *name,char *color) {_name =name; _color=color;};\n05     virtual char *getname(){return _name;}\n06     virtual char *makeSound() = 0;\n07     virtual char *getColor() {return _color;}\n08     virtual ~Animal() {};\n09 private:\n10     char *_name;\n11     char *_color;\n12 };\n13 class Cat : public Animal{\n14 public:\n15     Cat(char *name,char* color) : Animal(name,color) {};\n16     char *makeSound() { return \"meow\"; }\n17     ~Cat() {};\n18 };\n19 Animal* animals[] = {\n20     new Cat(\"fluffy\",\"  red  \"), new Cat(\"gruffy\",\" green \"),\n22     new Cat(\"mooody\",\"magenta\")\n23 };\n24 int main(){\n25     for (int i = 0; i &lt; 3; i++)\n26     if (animals[i]){\n27         std::cout &lt;&lt; animals[i]-&gt;getname()      &lt;&lt; \" is \";\n28         std::cout &lt;&lt; animals[i]-&gt;getColor()     &lt;&lt; \" and sounds \";\n29         std::cout &lt;&lt; animals[i]-&gt;makeSound()    &lt;&lt; std::endl;\n30     }\n31     for (int i = 0; i &lt; 3; i++)\n32     delete animals[i];\n33     return 0;\n34 }\n</code></pre>\n<p>compiled and executed using vs2017 community in x86 as x86</p>\n<pre><code>D:\\virt&gt;cl /Zi /W4 /analyze /EHsc /nologo /Od virt.cpp /link /release\nvirt.cpp\n\nD:\\virt&gt;virt.exe\nfluffy is   red   and sounds meow\ngruffy is  green  and sounds meow\nmooody is magenta and sounds meow\n</code></pre>\n<p>disassembly of line 26,27,28 which calls the functions notice the pointer arithmetic<br/>\nand indirect calls  highlighted with &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</p>\n<pre><code>D:\\virt&gt;cdb -lines -c \"g virt!main;uf .;q\" virt.exe | grep -iE \" 26| 27| 28\"\nvirt!main+0x33 [d:\\virt\\virt.cpp @ 26]:\n   26 00251223 6800022c00      push    offset virt!__xt_z+0x34 (002c0200)\n   26 00251228 8b55fc          mov     edx,dword ptr [ebp-4]\n   26 0025122b 8b049528892d00  mov     eax,dword ptr virt!animals (002d8928)[edx*4]\n   26 00251232 8b4dfc          mov     ecx,dword ptr [ebp-4]\n   26 00251235 8b10            mov     edx,dword ptr [eax]\n   26 00251237 8b0c8d28892d00  mov     ecx,dword ptr virt!animals (002d8928)[ecx*4]\n   26 0025123e 8b02            mov     eax,dword ptr [edx] &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n   26 00251240 ffd0            call    eax &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n   26 00251242 50              push    eax\n   26 00251243 68688a2d00      push    offset virt!std::cout (002d8a68)\n   26 00251248 e803020000      call    virt!std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; \n   26 0025124d 83c408          add     esp,8\n   26 00251250 50              push    eax\n   26 00251251 e8fa010000      call    virt!std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;\n   26 00251256 83c408          add     esp,8\n   27 00251259 6808022c00      push    offset virt!__xt_z+0x3c (002c0208)\n   27 0025125e 8b4dfc          mov     ecx,dword ptr [ebp-4]\n   27 00251261 8b148d28892d00  mov     edx,dword ptr virt!animals (002d8928)[ecx*4]\n   27 00251268 8b45fc          mov     eax,dword ptr [ebp-4]\n   27 0025126b 8b12            mov     edx,dword ptr [edx]\n   27 0025126d 8b0c8528892d00  mov     ecx,dword ptr virt!animals (002d8928)[eax*4]\n   27 00251274 8b4208          mov     eax,dword ptr [edx+8] &lt;&lt;&lt;&lt;&lt;&lt;&lt;\n   27 00251277 ffd0            call    eax &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n   27 00251279 50              push    eax\n   27 0025127a 68688a2d00      push    offset virt!std::cout (002d8a68)\n   27 0025127f e8cc010000      call    virt!std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;\n   27 00251284 83c408          add     esp,8\n   27 00251287 50              push    eax\n   27 00251288 e8c3010000      call    virt!std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;\n   27 0025128d 83c408          add     esp,8\n   28 00251290 68f01b2500      push    offset virt!std::endl&lt;char,std::char_traits&lt;char&gt;\n   28 00251295 8b4dfc          mov     ecx,dword ptr [ebp-4]\n   28 00251298 8b148d28892d00  mov     edx,dword ptr virt!animals (002d8928)[ecx*4]\n   28 0025129f 8b45fc          mov     eax,dword ptr [ebp-4]\n   28 002512a2 8b12            mov     edx,dword ptr [edx]\n   28 002512a4 8b0c8528892d00  mov     ecx,dword ptr virt!animals (002d8928)[eax*4]\n   28 002512ab 8b4204          mov     eax,dword ptr [edx+4] &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n   28 002512ae ffd0            call    eax &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n   28 002512b0 50              push    eax\n   28 002512b1 68688a2d00      push    offset virt!std::cout (002d8a68)\n   28 002512b6 e895010000      call    virt!std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;\n   28 002512bb 83c408          add     esp,8\n   28 002512be 8bc8            mov     ecx,eax\n   28 002512c0 e8db1a0000      call    ::operator&lt;&lt; (00252da0)\n</code></pre>\n<p>edit :</p>\n<p>an array of function pointers  will generate indirect calls\nlike call qword ptr [reg + offset]  ,call qword ptr [mem+offset] etc</p>\n<p>my answer is more of practical nature if you are looking for a theoretical way to distinguish  the nature indirect calls i cant be of much help there shown below is source and disassembly of an array of function pointers</p>\n<p>source compiled and executed</p>\n<pre><code>:\\&gt;type funarr.cpp\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint sum(int a, int b){ return a + b;}\nint sub(int a, int b){ return a - b;}\nint mul(int a, int b){ return a * b;}\nint (*p[3]) (int x, int y) {sum,sub,mul};\n\nint main(int argc,char *argv[])\n{\n        if(argc == 3)\n        {\n                int i = atoi(argv[1]);\n                int j = atoi(argv[2]);\n                int k = (*p[0]) (i, j);\n                int l = (*p[1]) (i, j);\n                int m = (*p[2]) (i, j);\n                printf(\"%d %d %d\", k,l,m );\n        }\n}\n:\\&gt;cl /Zi /W4 /analyze /O1 /nologo funarr.cpp /link /release\nfunarr.cpp\n\n:\\&gt;funarr.exe 2 3\n5 -1 6\n</code></pre>\n<p>disassembly of main</p>\n<pre><code>:\\&gt;cdb -c \"uf funarr!main;q\" funarr.exe | awk \"/Reading/,/quit/\"\n0:000&gt; cdb: Reading initial command 'uf funarr!main;q'                                                                  funarr!main:                                                                                                            00007ff7`95f2106c 48895c2408      mov     qword ptr [rsp+8],rbx\n00007ff7`95f21071 48896c2410      mov     qword ptr [rsp+10h],rbp\n00007ff7`95f21076 4889742418      mov     qword ptr [rsp+18h],rsi\n00007ff7`95f2107b 57              push    rdi\n00007ff7`95f2107c 4883ec20        sub     rsp,20h\n00007ff7`95f21080 488bda          mov     rbx,rdx\n00007ff7`95f21083 83f903          cmp     ecx,3\n00007ff7`95f21086 754c            jne     funarr!main+0x68 (00007ff7`95f210d4)\n\nfunarr!main+0x1c:\n00007ff7`95f21088 488b4a08        mov     rcx,qword ptr [rdx+8]\n00007ff7`95f2108c e803810200      call    funarr!atoi (00007ff7`95f49194)\n00007ff7`95f21091 488b4b10        mov     rcx,qword ptr [rbx+10h]\n00007ff7`95f21095 8be8            mov     ebp,eax\n00007ff7`95f21097 e8f8800200      call    funarr!atoi (00007ff7`95f49194)\n00007ff7`95f2109c 8bd0            mov     edx,eax\n00007ff7`95f2109e 8bcd            mov     ecx,ebp\n00007ff7`95f210a0 8bf8            mov     edi,eax\n00007ff7`95f210a2 ff1558cf0500    call    qword ptr [funarr!p (00007ff7`95f7e000)]\n00007ff7`95f210a8 8bd7            mov     edx,edi\n00007ff7`95f210aa 8bcd            mov     ecx,ebp\n00007ff7`95f210ac 8bf0            mov     esi,eax\n00007ff7`95f210ae ff1554cf0500    call    qword ptr [funarr!p+0x8 (00007ff7`95f7e008)]\n00007ff7`95f210b4 8bd7            mov     edx,edi\n00007ff7`95f210b6 8bcd            mov     ecx,ebp\n00007ff7`95f210b8 8bd8            mov     ebx,eax\n00007ff7`95f210ba ff1550cf0500    call    qword ptr [funarr!p+0x10 (00007ff7`95f7e010)]\n00007ff7`95f210c0 448bc3          mov     r8d,ebx\n00007ff7`95f210c3 488d0d76c20400  lea     rcx,[funarr!`string' (00007ff7`95f6d340)]\n00007ff7`95f210ca 448bc8          mov     r9d,eax\n00007ff7`95f210cd 8bd6            mov     edx,esi\n00007ff7`95f210cf e818000000      call    funarr!printf (00007ff7`95f210ec)\n\nfunarr!main+0x68:\n00007ff7`95f210d4 488b5c2430      mov     rbx,qword ptr [rsp+30h]\n00007ff7`95f210d9 33c0            xor     eax,eax\n00007ff7`95f210db 488b6c2438      mov     rbp,qword ptr [rsp+38h]\n00007ff7`95f210e0 488b742440      mov     rsi,qword ptr [rsp+40h]\n00007ff7`95f210e5 4883c420        add     rsp,20h\n00007ff7`95f210e9 5f              pop     rdi\n00007ff7`95f210ea c3              ret\nquit:\n</code></pre>\n</div>",
            "votes": "2",
            "user": "blabb",
            "time": "Feb 15, 2021 at 20:13",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Abdullah Mohamed",
                    "text": "<span class=\"comment-copy\">Thank you for your answer and comments. However, that still didn't answer my specific answer (sorry again if I'm missing something obvious, so please bear with me), isn't that disassembly and the access of indirect function calls through registers could as well mean class/structure methods or even array of function pointers?</span>",
                    "time": null
                },
                {
                    "user": "Abdullah Mohamed",
                    "text": "<span class=\"comment-copy\">Your edit helped a lot clarifying the difference between the different assembly results! Thanks a lot! :)</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>There’s no 100% sure way to distinguish a virtual call from a function pointer call but there are some strong hints.</p>\n<ol>\n<li><p>The virtual function table (vftable) is <em>usually</em> at the very start of the object so assuming the object’s address is stored in <code>objectreg</code>, you should see something like</p>\n<pre><code>mov vftreg, [objectreg]\n</code></pre>\n</li>\n<li><p>The object address (the <em>this</em> pointer) is passed to the virtual method, commonly as the first argument or in a separate register, according to the ABI in use. In Microsoft x86 the <code>ecx</code> register is used for this purpose so the common pattern is:</p>\n<pre><code>mov ecx, objectreg\n</code></pre>\n</li>\n<li><p>The call is performed using a slot in the vftable. It can be done either directly using a displacement from the register holding the vftable:</p>\n<pre><code>call [vftreg+slotoff]\n</code></pre>\n</li>\n</ol>\n<p>Or via an intermediate register:</p>\n<pre><code>  mov callreg, [vftreg+slotoff]\n  call callreg\n</code></pre>\n<p><code>slotoff</code> should be a multiple of a pointer size and may be zero.</p>\n<p>In case the method has arguments, they will be loaded as well (usually the <em>this</em> argument is initialized last, just before the call).</p>\n<p>You may also find informative <a href=\"http://www.openrce.org/articles/full_view/23\" rel=\"nofollow noreferrer\">my old article</a> on the topic.</p>\n</div>",
            "votes": "1",
            "user": "Igor Skochinsky",
            "time": "Feb 17, 2021 at 23:21",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Abdullah Mohamed",
                    "text": "<span class=\"comment-copy\">That even clarified the issue more, thanks for taking the time to answer, as well as linking your article!</span>",
                    "time": null
                }
            ]
        }
    ]
}