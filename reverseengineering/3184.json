{
    "title": "Packers/Protectors for Linux",
    "link": "https://reverseengineering.stackexchange.com/questions/3184/packers-protectors-for-linux",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I was wondering if anyone had come across a packer/protector which could be used for ELF binaries. There seem to be quite a few articles on writing packers and protectors for the PE format -- however, there don't seem to be very many for Linux.</p>\n<p>This is just a hobby and so far I've come across<a href=\"http://asm.sourceforge.net/articles/smc.html\" rel=\"nofollow\">1</a> which is seems to be a very basic(but neat) <a href=\"http://asm.sourceforge.net/articles/smc.html\" rel=\"nofollow\">introduction to SMC</a>.</p>\n<p>Are there any resources/source code that you could point me to that I could refer and learn from?</p>\n</div>",
    "votes": "6",
    "answers": 3,
    "views": "12k",
    "tags": [
        "linux",
        "elf",
        "packers"
    ],
    "user": null,
    "time": "Dec 14, 2013 at 22:16",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Apart from the classix <a href=\"http://upx.sourceforge.net/\">UPX</a>, you should take a look at <a href=\"http://woodmann.com/collaborative/tools/index.php/Burneye\">Burneye</a> (With its crackers, <a href=\"http://www.securiteam.com/tools/6T00N0K5SY.html\">UNFburninhell</a> and <a href=\"http://www.securiteam.com/tools/5BP0H0U7PQ.html\">Burndump</a>) and elfuck. They are pretty old, but still interesting.</p>\n<p>If you are interested about tricks that can be used, <a href=\"http://www.hackintherandom2600nldatabox.nl/archive/slides/2012/antidebugging.tgz\">this</a> is a good introduction by aczid, and I would also recommend <a href=\"http://indra.linuxstudy.pe.kr/study/Binary%20Protection%20Schemes.pdf\">Binary protection schemes</a> for a more complete overview. </p>\n<p>Someone also presented a CanSecWest a packer named <a href=\"http://cansecwest.com/core03/shiva.ppt\">Shiva</a> that was broken at <a href=\"https://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf\">Blackhat</a>. Unfortunately, there is no sources available.</p>\n</div>",
            "votes": "8",
            "user": "jvoisin",
            "time": "Dec 14, 2013 at 19:12",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Krypton",
                    "text": "<span class=\"comment-copy\">any update on this list? Except UPX, those listed are really old and not maintained.</span>",
                    "time": null
                },
                {
                    "user": "jvoisin",
                    "text": "<span class=\"comment-copy\">Feel free to write your own if you're impatient ;)</span>",
                    "time": null
                },
                {
                    "user": "Rui F Ribeiro",
                    "text": "<span class=\"comment-copy\">Unfortunately many of the links above seem not to be working anymore.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Click on the tool names to download. Some will be source code only, others binary only. Use at your own risk.</p>\n<hr/>\n<p>There are 4 sections: </p>\n<ol>\n<li>experimental designs, which were developed to advance the state of the art in ELF binary protection or for research purposes</li>\n<li>tools resulting from personal projects or created for fun/as a hobby</li>\n<li>historically relevant protectors, now cracked/deprecated</li>\n<li>modern protectors - those known at the time of writing to be used out in the \"real world\", so to speak (outside of academia - in malware for example).</li>\n</ol>\n<hr/>\n<h2>Experimental / Proof of Concept</h2>\n<ul>\n<li><p><strong><a href=\"https://github.com/packz/binary-encryption/tree/master/binary-encryption/dacryfile\" rel=\"nofollow noreferrer\"><code>dacryfile</code></a></strong> (2001)</p>\n<p>phrack article: <a href=\"http://phrack.org/issues/58/5.html#article\" rel=\"nofollow noreferrer\">Armouring the ELF: Binary encryption on the UNIX platform</a></p>\n<blockquote>\n<p>Dacryfile is a collection of tools which implement the following concept.\n  The host file is encrypted from the start of the <code>.text</code> section, to the end\n  of the <code>.text</code> segment. The file now has its object code and its read only\n  data protected by encryption, while all its data and dynamic objects are\n  open to inspection. The host file is injected with a parasite that will\n  perform the runtime decryption. This parasite can be of arbitrary size\n  because it is appended to the end of the <code>.data</code> segment. </p>\n</blockquote>\n<p>\"Parasite code\" refers to code inserted into the either the file on disk or the process image in memory in order to change the runtime behavior of the program. Various techniques that were historically used to accomplish this kind of code insertion are discussed in Silvio Cesare's article <a href=\"https://www.win.tue.nl/~aeb/linux/hh/virus/unix-viruses.txt\" rel=\"nofollow noreferrer\">Unix Viruses</a> (1999)</p>\n<p>The mechanism by which the parasite code appended to the ELF binary containing the encrypted code accomplished is referred to by the grugq as \"subversive dynamic linking\":</p>\n<blockquote>\n<p>The parasite itself is fairly simple, utilising the <em>subversive dynamic\n  linking</em> Linux library to access libc functions, and rc4 to decrypt the host.</p>\n</blockquote>\n<p>This technique was detailed in his article <a href=\"https://grugq.github.io/docs/subversiveld.pdf\" rel=\"nofollow noreferrer\">Cheating the ELF</a>, in which parasite code written to a dynamically linked executable to is able to make calls to library functions essentially by searching through the process's <code>proc/self/maps</code> file for <code>glibc</code>'s shared object loading and unloading functions to then load the libraries of interest.</p></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"http://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-shiva-0.96.tar\" rel=\"nofollow noreferrer\"><code>shiva 0.96</code></a></strong> (2003) (binary only (protected))</p>\n<ul>\n<li><a href=\"https://www.blackhat.com/presentations/bh-usa-03/bh-us-03-mehta/bh-us-03-mehta.pdf\" rel=\"nofollow noreferrer\">Introduction Presentation</a></li>\n<li><p><a href=\"https://www.blackhat.com/presentations/bh-federal-03/bh-federal-03-eagle/bh-fed-03-eagle.pdf\" rel=\"nofollow noreferrer\">Defeat Presentation</a></p>\n<p>Implements the following features:</p>\n<ul>\n<li>Outer obfuscation layer to thwart static analysis</li>\n<li>AES encrpyted, password protected middle layer</li>\n<li>Inner encrypted layer consisting of crypt blocks which may be memory-mapped on demand</li>\n<li>TRAP flag detection to prevent single-stepping</li>\n<li>forks and then the processes <code>ptrace()</code> each other, which prevents PTRACE_ATTACH</li>\n<li>jumps into the middle of instructions</li>\n<li>catches SIGTRAP</li>\n<li>timing checks</li>\n<li>INT3 instruction replacement</li>\n</ul>\n<p>Outside of these presentations, it has been difficult to find additional information besides some discussion in <code>phrack</code> articles on ELF runtime encryption/decryption. No source code is available, only the binary, which is protected.</p></li>\n</ul></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"http://phrack.org/issues/63/13.html\" rel=\"nofollow noreferrer\"><code>cryptexec</code></a></strong> (2005)</p>\n<p>phrack article: <a href=\"http://phrack.org/issues/63/13.html\" rel=\"nofollow noreferrer\">cryptexec: Next-generation runtime binary encryption using on-demand function extraction</a>. The source code is included at the end.</p>\n<p>Here runtime decryption is accomplished through a combination of a tracing function that uses a private stack, a disassembler and code emulation to read blocks of 24 bytes are read, decrypted, disassembled and then emulated. This ensures that no more than 24 bytes of unencrypted program code reside in memory while decrypting and executing the protected code.</p>\n<blockquote>\n<p>The tracing routine maintains two contexts: the traced context and\n  its own context. The context consists of 8 32-bit general-purpose\n  registers and flags. Other registers are not modified by the routine.\n  Both contexts are held on the private stack (that is also used for\n  calling C).</p>\n<p>The idea is to fetch, one at a time, instructions from the traced \n  program and execute them natively. Intel instruction set has rather \n  irregular encoding, so the XDE [5] disassembler engine is used to find \n  both the real opcode and total instruction length. During experiments on \n  FreeBSD (which uses LOCK- prefixed MOV instruction in its dynamic loader) \n  I discovered a bug in XDE which is described and fixed below.</p>\n<p>We maintain our own EIP in traced_eip, round it down to the next lower\n  8-byte boundary and then decrypt 24 bytes into our own buffer.  Then\n  the disassembly takes place and the control is  transferred to emulation\n  routines via the opcode control table.  All instructions, except control\n  transfer, are executed natively (in traced context which is restored at\n  appropriate time).  After single instruction execution, the control is\n  returned to our tracing routine.</p>\n</blockquote></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"https://github.com/zvrba/cspim\" rel=\"nofollow noreferrer\"><code>CSPIM</code></a></strong> (2010)</p>\n<p>Also developed by Vrba (the designer of the aforementioned <code>cryptexec</code>), and presented in the paper <a href=\"https://ieeexplore.ieee.org/document/5438087\" rel=\"nofollow noreferrer\">Program Obfuscation by Strong Cryptography</a> (the paper is paywalled but the code is on github and the <a href=\"http://zvrba.net/articles/encrypted-execution.html\" rel=\"nofollow noreferrer\">Vrba's site</a>):</p>\n<blockquote>\n<p>...we present a program obfuscation method that is based on the combination of strong encryption of code and data and a CPU simulator(CSPIM) that implements the MIPS I instruction set. Our method is different from existing methods in that only a single word (32-bits) of the protected code or data is present as plain-text in main memory. Furthermore, our method allows the possibility of externally supplying the decryption key to the simulator. </p>\n</blockquote>\n<p><a href=\"https://i.sstatic.net/VJBqE.png\" rel=\"nofollow noreferrer\"><img alt=\"CSPIM\" src=\"https://i.sstatic.net/VJBqE.png\"/></a></p>\n<p>The above diagram is from <a href=\"https://www.esat.kuleuven.be/cosic/publications/article-2038.pdf\" rel=\"nofollow noreferrer\">Enhancements to a virtual machine based code\nencryptor</a> (no code available for this paper as far as I know).</p></li>\n</ul>\n<hr/>\n<h2>Personal Projects</h2>\n<ul>\n<li><p><strong><a href=\"https://packetstormsecurity.com/files/30886/cryptelf.c.html\" rel=\"nofollow noreferrer\"><code>cryptelf</code></a></strong> (2003) by SLACKo</p>\n<p>Modifies binary by appending code to handle runtime decryption, changing the program entry point and changing the <code>.note</code> segment to <code>LOAD</code>. Encrypts the <code>.text</code> section by XORing its bytes with a key. </p></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"http://elf-encrypter.sourceforge.net\" rel=\"nofollow noreferrer\"><code>ELF Encrypter</code></a></strong> - Last update: 2013-03-12</p>\n<p>Appears to rely on classical runtime code injection or parasite code techniques to accomplish runtime decryption.</p>\n<blockquote>\n<p>The encrypted file (generated by the <code>crypt-7lib program</code>) will be decrypted at runtime by a shared library, directly linked to the binary or listed in<code>LD_PRELOAD</code>, during its initialization routine. The suite also contains programs to inject plain and encrypted code into ELF binaries.</p>\n<p>ELF-Encrypter 0.12</p>\n<ul>\n<li>changed the data segment infection technique</li>\n<li>added the code to correct section table offsets</li>\n</ul>\n</blockquote></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"https://github.com/ps2dev/ps2-packer\" rel=\"nofollow noreferrer\">ps2-packer</a></strong> (2013)</p>\n<p>Based on UPX.</p>\n<blockquote>\n<p>Just like UPX this tool is designed to help you\n  create packed ELF to run on the PS2. It has a modular design, so anybody can\n  write any kind of module to it. It actually has a zlib module, a lzo module,\n  three ucl modules (n2b, n2d and n2e) and a null module, for demo purpose only.</p>\n</blockquote></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"https://github.com/arisada/midgetpack\" rel=\"nofollow noreferrer\">midgetpack</a></strong> (2014)</p>\n<blockquote>\n<p>Midgetpack contains two modes of operation: password and curve25519 key exchange.</p>\n<p>The curve25519 is the real advantage of midgetpack. In this mode, you do not\n  provide any password or key. Instead, a key file is generated at packing time.\n  This key file must be used everytime you wish to use the binary. When you start\n  the binary, it will give a challenge and expect a response. You copy/paste the\n  challenge in the input of the mpkex tool and receive a response containing the\n  encrypted key to the binary.\n  This key exchange is protected by Curve25519 key exchange, the key is encrypted\n  with aes-128 and the whole exchange is authenticated with HMAC-SHA256 to avoid\n  generic man-in-the-middle attacks.</p>\n</blockquote></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"https://github.com/tweksteen/oplzkwp\" rel=\"nofollow noreferrer\"><code>oplzkwp</code></a></strong> (2015)</p>\n<blockquote>\n<p>oplzkwp is a library for ELF obfuscation. It uses PRESENT and blake244 to encrypt your payload on the fly. Only the functions that are currently executed are decrypted in memory. Both Linux (x86) and Android (ARM) are supported.</p>\n</blockquote></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"https://github.com/picoflamingo/pocrypt\" rel=\"nofollow noreferrer\">pocrypt</a></strong> (2015)</p>\n<blockquote>\n<p>Proof of Code to demonstrate how to crypt parts of a binary. The modified binary is extended with a small function that decrypts the secured parts of the file at run-time to enable its execution.</p>\n</blockquote></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"https://github.com/glen-mac/ELF-Packer\" rel=\"nofollow noreferrer\"><code>ELF-Packer</code></a></strong> (2017)</p>\n<p>Simple tool developed as a homework assignment. It uses parasite code inserted into a code cave to perform runtime XOR obfuscation or de-obfuscation of a target binary's <code>.text</code> section. The details are discussed in <a href=\"https://github.com/glen-mac/ELF-Packer/blob/master/elf_cryptor.pdf\" rel=\"nofollow noreferrer\">Simple Polymorphic x86-64 Runtime Code Segment Crpytor</a>.</p></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"https://github.com/droberson/ELFcrypt\" rel=\"nofollow noreferrer\">ELFcrypt</a></strong> (2018)</p>\n<blockquote>\n<p>Simple ELF crypter. Uses RC4 encryption.</p>\n</blockquote></li>\n</ul>\n<hr/>\n<ul>\n<li>Ryan O'Neill's (@ryan_elfmaster) experiments. These may have research value:\n\n<ul>\n<li><a href=\"http://www.bitlackeys.org/projects/elfpacker.tgz\" rel=\"nofollow noreferrer\">ELF Packer v0.3</a> (2009)</li>\n<li><a href=\"https://github.com/elfmaster/sherlocked\" rel=\"nofollow noreferrer\">sherlocked</a> (2014)</li>\n<li><a href=\"https://github.com/elfmaster/davinci\" rel=\"nofollow noreferrer\">davinci</a> (2015)</li>\n<li><a href=\"https://github.com/elfmaster/saruman\" rel=\"nofollow noreferrer\">saruman</a> (2018)</li>\n</ul></li>\n</ul>\n<hr/>\n<h2>Historical</h2>\n<ul>\n<li><p><strong><a href=\"https://packetstormsecurity.com/files/related/30648/burneye-1.0.1-src.tar.bz2.html\" rel=\"nofollow noreferrer\"><code>burneye</code> (v1)</a></strong> by the Teso group (2002)</p>\n<p>The following summary is given in <a href=\"http://phrack.org/issues/63/13.html\" rel=\"nofollow noreferrer\">cryptexec: Next-generation runtime binary encryption using on-demand function extraction</a> (more information is included in burneye's documentation):</p>\n<blockquote>\n<p>Similarly to Shiva, it has three layers: 1) obfuscation, 2) password-based encryption using RC4 and SHA1 (for generating the key from passphrase), and 3) the fingerprinting layer.</p>\n<p>The fingerprinting layer is the most interesting one: the data about the\n  target system is collected (e.g. amount of memory, etc..) and made into\n  a 'fingeprint'. The executable is encrypted taking the fingerprint into\n  account so that the resulting binary can be run only on the host with the\n  given fingerprint. There are two fingerprinting options:</p>\n<ul>\n<li><p>Fingeprint tolerance can be specified so that Small deviations are\n  allowed. That way, for example, the memory can be upgraded on the\n  target system and the executable will still work. If the number of\n  differences in the fingeprint is too large, the program won't work.</p></li>\n<li><p>Seal: the program produced with this option will run on any system.\n  However, the first time it is run, it creats a fingerprint of the\n  host and 'seals' itself to that host. The original seal binary is\n  securely deleted afterwards.</p></li>\n</ul>\n<p>The encrypted binary can also be made to delete itself when a certain\n  environment variable is set during the program execution.</p>\n</blockquote></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"https://packetstormsecurity.com/files/31524/objobf-0.5.0.tar.bz2.html\" rel=\"nofollow noreferrer\"><code>objobf</code></a></strong> aka burneye2 (2003)</p>\n<blockquote>\n<p>It reads one ELF relocateable object file and\n  produces a functional equivalent output file, which is an obfuscated version\n  of the input file. To do this, <code>objobf</code> breaks up all functions in the file to the basic block level. This representation is used to mutate the code while keeping it semantically equivalent. This involves dataflow analysis and basic block transformations. Afterwards, the basic block representation as control flow graph is linearized into a new object file, which is created from scratch.</p>\n</blockquote></li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><a href=\"https://github.com/timhsutw/elfuck/tree/master/doc\" rel=\"nofollow noreferrer\">elfuck</a></strong></p>\n<p>Implements executable compression as well as encryption. Based on UPX and <code>burneye</code>.</p>\n<ul>\n<li><blockquote>\n<p>ELFuck uses excellent Markus F.X.J. Oberhumer's compression algorithm,\n  NRV2E which carries very good compression with tiny decompressor\n  (about 128 bytes!). This algorithm family is stolen from UPX, with\n  difference in that decompression is done in real time; ELFuck will\n  decompress ELF directly to .text/.data segment and executes authentic\n  ELF image from there, on other hand, UPX creates original ELF in /tmp\n  and execve() it, so that we don't need any writeable filesystem at all.</p>\n</blockquote></li>\n<li><blockquote>\n<p>Because ELFuck is 100%-ly based on stolen ideas, I also implemented\n  this one of BurnEye. Someone may like to disallow other users to\n  use/analyse your binary (public shells, root browsing user's homes).\n  The algorithm is kinda simple, but seems to be pretty effective:\n  We'll select some password; expand it using sha1 to 160 bit key.\n  by this key we'll encrypt, using RC4 algorithm, whole binary\n  (except the decrypting stub, of course). We'll also keep\n  last 32bits of sha1 against original binary, in order to check password.\n  When someone will execute such protected binary; the stub will ask for\n  password, make hash of it and try to decrypt the binary back using\n  this key. Then we'll make a hash of potentially decrypted binary,\n  check it against the value we've saved while creating, and if matches,\n  the binary is decrypted correctly (=right password) and we'll let it\n  run.   </p>\n</blockquote></li>\n</ul></li>\n</ul>\n<h2>Modern</h2>\n<p>The majority of modern ELF binaries are protected using UPX or a variant thereof. <sup>1,2</sup></p>\n<ul>\n<li>The simplest variation of the UPX packer used out in the wild is the <a href=\"https://i.sstatic.net/AUgrm.jpg\" rel=\"nofollow noreferrer\">'LSD' packer</a>, in which the string 'UPX' is changed to 'LSD'. An example of this was a <a href=\"https://www.fortinet.com/blog/threat-research/rocke-variant-ready-to-box-mining-challengers.html\" rel=\"nofollow noreferrer\">XMR coin miner written in Go which targeted systems running Jenkins</a>. </li>\n</ul>\n<hr/>\n<ul>\n<li><p><strong><code>mumblehard</code></strong> custom protector - not based on UPX</p>\n<blockquote>\n<p>The whole packer actually consists of about 200 assembly instructions.\n  Another notable observation: system calls are made directly by using <code>int 80h</code> instructions. Another hint that it was written in assembly is that functions do not have the usual prologue to manage the stack. By doing system calls with interrupts, Mumblehard ELF binaries avoid any external dependency.\n  Furthermore, the packer works on both Linux and BSD systems. <sup>1</sup></p>\n</blockquote>\n<p>samples:</p>\n<ul>\n<li><a href=\"https://malshare.com/sample.php?action=detail&amp;hash=6fe8c28022c0acb99ce1c48214043dee\" rel=\"nofollow noreferrer\">20b567084bcc6bd5ac47b2ab450bbe838ec88fc726070eb6e61032753734d233</a></li>\n<li><a href=\"https://malshare.com/sample.php?action=detail&amp;hash=8c0ed8b22000d7493aa94a0c2e587a4c\" rel=\"nofollow noreferrer\">78c19897d08e35c0e50155c87f501e20f2d1dbfd38607fc8e12711d086d52204</a></li>\n<li><a href=\"https://malshare.com/sample.php?action=detail&amp;hash=88b62d23b9f2b6f866774b82962442d7\" rel=\"nofollow noreferrer\">84dfe2ac489ba41dfb25166a983ee2d664022bbcc01058c56a1b1de82f785a43</a></li>\n<li><a href=\"https://malshare.com/sample.php?action=detail&amp;hash=86f0b0b74fe8b95b163a1b31d76f7917\" rel=\"nofollow noreferrer\">747d985d4bd302e974474dc9ab44cb1f60cb06206f3639c5d603db94395b877b</a></li>\n<li><a href=\"https://malshare.com/sample.php?action=detail&amp;hash=3437bd29e5c8fe493603581dbb0285c7\" rel=\"nofollow noreferrer\">9512cd72e901d7df95ddbcdfc42cdb16141ff155e0cb0f8321069212e0cd67a8</a></li>\n<li><a href=\"https://malshare.com/sample.php?action=detail&amp;hash=b1338cd9b5a853d8920f5a868108135b\" rel=\"nofollow noreferrer\">a5915c3060f5891242514b7899975393ef3d3cb87b33b6a767cffce4feac215f</a></li>\n</ul></li>\n</ul>\n<hr/>\n<ul>\n<li><p>a variant of <strong><code>tiny XMR mooner</code></strong> uses a custom packer according to the r2con 2018 presentation <a href=\"https://github.com/radareorg/r2con2018/blob/master/talks/unpacking/Unpacking-a-Non-Unpackables.pdf\" rel=\"nofollow noreferrer\">Unpacking the Non-Unpackable</a>. </p>\n<ul>\n<li><a href=\"https://www.virustotal.com/gui/file/8a0d9c84cfb86dd1f8c9acab87738d2cb82106aee0d88396f6fa86265ff252dd/detection\" rel=\"nofollow noreferrer\">8a0d9c84cfb86dd1f8c9acab87738d2cb82106aee0d88396f6fa86265ff252dd</a> </li>\n<li><p>md5sum from presentation: <code>4f1fdacaee8e3c612c9ffbbe162042b2</code></p>\n<p>Note this particular file was the subject of <a href=\"https://xorl.wordpress.com/2017/12/21/the-tiny-xml-mooner-linux-cryptominer-malware/\" rel=\"nofollow noreferrer\">The “Tiny XMR mooner” Linux cryptominer malware</a> (the sha256 sum is identical) but no mention is made in this analysis of packing or any other form of binary protection.</p></li>\n</ul></li>\n</ul>\n<hr/>\n<ul>\n<li><strong><code>Linux/Tsunami</code></strong> with custom packer\n\n<ul>\n<li><a href=\"https://malshare.com/sample.php?action=detail&amp;hash=171edd284f6a19c6ed3fe010b79c94af\" rel=\"nofollow noreferrer\">Malshare sample</a></li>\n<li><a href=\"https://www.virustotal.com/gui/file/f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863/detection\" rel=\"nofollow noreferrer\">f22ffc07e0cc907f00fd6a4ecee09fe8411225badb2289c1bffa867a2a3bd863</a> (Virustotal)</li>\n<li>there used to be an analysis available at <a href=\"http://pwning.fun/article/2017/11/17/UnPacking_a_Linux_Tsunami_Sample.html\" rel=\"nofollow noreferrer\">pwning.fun</a> but it looks like its been taken down.</li>\n</ul></li>\n</ul>\n<hr/>\n<h3>Additional Information</h3>\n<p><a href=\"https://www.esat.kuleuven.be/cosic/publications/article-1529.pdf\" rel=\"nofollow noreferrer\">A taxonomy of self-modifying code for obfuscation</a> (2011) concisely summarizes some of these tools and discusses a variety of obfuscation techniques.</p>\n<h3>References</h3>\n<ol>\n<li><p><a href=\"http://www.s3.eurecom.fr/docs/oakland18_cozzi.pdf\" rel=\"nofollow noreferrer\">Understanding Linux Malware</a></p></li>\n<li><p><a href=\"http://s3.eurecom.fr/~invano/slides/recon18_linux_malware.pdf\" rel=\"nofollow noreferrer\">Modern Linux Malware Exposed</a></p></li>\n<li><p><a href=\"https://www.welivesecurity.com/wp-content/uploads/2015/04/mumblehard.pdf\" rel=\"nofollow noreferrer\">Unboxing Linux/Mumblehard</a> (2015) - ESET</p></li>\n</ol>\n</div>",
            "votes": "1",
            "user": "julian",
            "time": "Aug 11, 2019 at 5:47",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><a href=\"http://upx.sourceforge.net/\" rel=\"nofollow\">UPX</a> is an <a href=\"http://sourceforge.net/projects/upx/\" rel=\"nofollow\">open-source</a> packer that works on ELF binaries.</p>\n</div>",
            "votes": "0",
            "user": "Jason Geffner",
            "time": "Dec 14, 2013 at 15:05",
            "is_accepted": false,
            "comments": []
        }
    ]
}