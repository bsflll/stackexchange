{
    "title": "Decompress from file with crush32",
    "link": "https://reverseengineering.stackexchange.com/questions/21359/decompress-from-file-with-crush32",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have some files *.bli, *.ilg, *.pix, etc. These files are from technical documentation LinkOne, and compressed with old C/Win32 compression library crush32.dll. </p>\n<p>information can be found here \n<a href=\"https://reverseengineering.stackexchange.com/questions/20771/reverse-engineering-file-format-imagelink\">Reverse engineering file format - ImageLink</a> </p>\n<p>I found c# code to decompress it, but it is not working. What did I do wrong? I tried to read s001.bli, it`s ok, than from result gets \"true\" and that's all. decompressedPixelData is empty, with size 0.</p>\n<p>I run the code through Visual Studio 2012 on emulated Windows 7 X86 in VirtualBox. The crush32.dll library seems to work only with x86, although on win10 x64 the result is exactly the same.</p>\n<p><strong>Files and dll</strong>: <a href=\"https://drive.google.com/file/d/1GipwXL9ikog1YVu46uqxLfuuY1Rk-5Pc/view\" rel=\"nofollow noreferrer\">https://drive.google.com/file/d/1GipwXL9ikog1YVu46uqxLfuuY1Rk-5Pc/view</a></p>\n<p>Code:</p>\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.IO;\n\nnamespace Crush32Wrap\n{\n    public unsafe static class Crush32\n    {\n        #region Private PINVOKE signatures\n        /// &lt;summary&gt;\n        /// Name of legacy crush32.dll file (put it in same folder!)\n        /// &lt;/summary&gt;\n        public const string DLLName = \"crush32.dll\";\n        public const string FName = \"s001.bli\";\n\n        /// &lt;summary&gt;\n        /// The cxERROR for SUCCESS\n        /// &lt;/summary&gt;\n        private const short CX_SUCCESS = 0;\n\n        /// &lt;summary&gt;\n        /// Initializes the library\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;cxERROR statevalue&lt;/returns&gt;\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxInit();\n\n        /// &lt;summary&gt;\n        /// Cleanup\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;cxERROR statevalue&lt;/returns&gt;\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxCleanup();\n\n        /// &lt;summary&gt;\n        /// Initializes a buffer to buffer operation.\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;cxERROR statevalue&lt;/returns&gt;\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBuf2BufInit();\n\n        /// &lt;summary&gt;\n        /// Closes a buffer to buffer operation\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;cxERROR statevalue&lt;/returns&gt;\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBuf2BufClose();\n\n        /// &lt;summary&gt;\n        /// Decrypts data in a buffer.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"Buffer\"&gt;A pointer to the data to be decrypted.&lt;/param&gt;\n        /// &lt;param name=\"Length\"&gt;How many bytes should be decrypted.&lt;/param&gt;\n        /// &lt;param name=\"Challenge\"&gt;The Challenge used to test your password first.&lt;/param&gt;\n        /// &lt;param name=\"ExpectedResponse\"&gt;The ExpectedResponse matching your Challenge and your password.&lt;/param&gt;\n        /// &lt;returns&gt;cxERROR statevalue&lt;/returns&gt;\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBufDecrypt(byte* Buffer, int Length, uint Challenge, uint ExpectedResponse);\n\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBufDecrypt(IntPtr Buffer, int Length, uint Challenge, uint ExpectedResponse);\n\n\n        /// &lt;summary&gt;\n        /// Encrypts data in a buffer.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"Buffer\"&gt;A pointer to the data to be encrypted.&lt;/param&gt;\n        /// &lt;param name=\"Length\"&gt;How many bytes should be encrypted.&lt;/param&gt;\n        /// &lt;param name=\"Challenge\"&gt;The Challenge used to create the returnvalue.&lt;/param&gt;\n        /// &lt;returns&gt;The \"ExpectedResponse\" matching your given Challenge and your Password, use this in decryption later.&lt;/returns&gt;\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern uint cxBufEncrypt(IntPtr Buffer, int Length, uint Challenge);\n\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern uint cxBufEncrypt(byte* Buffer, int Length, uint Challenge);\n\n\n        /// &lt;summary&gt;\n        /// Sets a password for the encryption and decryption methods.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"PtrPasswordString\"&gt;A pointer to the nullterminated passwordstring in memory.&lt;/param&gt;\n        /// &lt;returns&gt;cxERROR statevalue&lt;/returns&gt;\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxSetPassword(IntPtr PtrPasswordString);\n\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxSetPassword(byte* Password);\n\n        /// &lt;summary&gt;\n        /// Compresses the data from the InputBuffer to the OutputBuffer.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"InputBuffer\"&gt;A pointer to read inputdata from.&lt;/param&gt;\n        /// &lt;param name=\"OutputBuffer\"&gt;A pointer to write outputdata to.&lt;/param&gt;\n        /// &lt;param name=\"InputLength\"&gt;How many bytes should be read from input buffer.&lt;/param&gt;\n        /// &lt;returns&gt;The length of the compressed data.&lt;/returns&gt;\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern int cxBuf2BufCompress(IntPtr InputBuffer, IntPtr OutputBuffer, int InputLength);\n\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern int cxBuf2BufCompress(byte* InputBuffer, byte* OutputBuffer, int InputLength);\n\n        /// &lt;summary&gt;\n        /// Decompresses the data from the InputBuffer to the OutputBuffer.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"InputBuffer\"&gt;A pointer to read inputdata from.&lt;/param&gt;\n        /// &lt;param name=\"OutputBuffer\"&gt;A pointer to write outputdata to.&lt;/param&gt;\n        /// &lt;param name=\"DecompressedLength\"&gt;The length of the data in decompressed state.&lt;/param&gt;\n        /// &lt;param name=\"CompressedLength\"&gt;The length of the data in compressed state.&lt;/param&gt;\n        /// &lt;returns&gt;cxERROR statevalue&lt;/returns&gt;\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBuf2BufExpand(IntPtr InputBuffer, IntPtr OutputBuffer, int DecompressedLength, int CompressedLength);\n\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        private static extern short cxBuf2BufExpand(byte* InputBuffer, byte* OutputBuffer, int DecompressedLength, int CompressedLength);\n\n        /// &lt;summary&gt;\n        /// Creates a CRC32 for the data in the Buffer.\n        /// Note: The used algorithm is equal to\n        /// http://damieng.com/blog/2006/08/08/calculating_crc32_in_c_and_net\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"Buffer\"&gt;A pointer to read the data to CRC.&lt;/param&gt;\n        /// &lt;param name=\"Length\"&gt;How many bytes should be read from pointer.&lt;/param&gt;\n        /// &lt;returns&gt;The created CRC32&lt;/returns&gt;\n        [DllImport(DLLName, CharSet = CharSet.Unicode, SetLastError = true, CallingConvention = CallingConvention.StdCall)]\n        public static extern uint cxBufCRC32(IntPtr Buffer, int Length);\n\n        #endregion\n        #region Public Wrappers\n\n        /// &lt;summary&gt;\n        /// Fast decompresses data from managed sourcebuffer to managed targetbuffer using pointers\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"SourceBuffer\"&gt;SourceBuffer containing compressed data&lt;/param&gt;\n        /// &lt;param name=\"SourceIndex\"&gt;Cursor in SourceBuffer to start reading&lt;/param&gt;\n        /// &lt;param name=\"TargetBuffer\"&gt;TargetBuffer for decompressed data&lt;/param&gt;\n        /// &lt;param name=\"TargetIndex\"&gt;Cursor in TargetBuffer to start writing&lt;/param&gt;\n        /// &lt;param name=\"UncompressedLength\"&gt;Uncompressed data length&lt;/param&gt;\n        /// &lt;param name=\"CompressedLength\"&gt;Compressed data length&lt;/param&gt;\n        /// &lt;returns&gt;True if the operation was successful.&lt;/returns&gt;\n        public static bool Decompress(byte[] SourceBuffer, int SourceIndex, byte[] TargetBuffer, int TargetIndex, int UncompressedLength, int CompressedLength)\n        {\n            bool isSuccessful = false;\n\n            // init crush32\n            if (Crush32.CX_SUCCESS == Crush32.cxInit())\n            {\n                if (Crush32.CX_SUCCESS == Crush32.cxBuf2BufInit())\n                {\n                    // pin the managed source &amp; targetbuffers in memory so crush32 can access them\n                    // and we can directly use them without marshaling.\n                    fixed (byte* ptrSourceBuffer = SourceBuffer, ptrTargetBuffer = TargetBuffer)\n                    {\n                        // add the offsets to the pointers (they still point to the beginning of the buffer)\n                        byte* ptrSourceIndex = ptrSourceBuffer + SourceIndex;\n                        byte* ptrTargetIndex = ptrTargetBuffer + TargetIndex;\n\n                        if (Crush32.CX_SUCCESS == Crush32.cxBuf2BufExpand(ptrSourceIndex, ptrTargetIndex, UncompressedLength, CompressedLength))\n                            isSuccessful = true;\n\n                    }\n\n\n\n                    Crush32.cxBuf2BufClose();\n                }\n\n                Crush32.cxCleanup();\n            }\n\n            return isSuccessful;\n        }\n\n        /// &lt;summary&gt;\n        /// Fast compresses data from managed sourcebuffer to managed targetbuffer using pointers\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"SourceBuffer\"&gt;SourceBuffer containing data to be compressed&lt;/param&gt;\n        /// &lt;param name=\"SourceIndex\"&gt;Cursor in SourceBuffer to start reading&lt;/param&gt;\n        /// &lt;param name=\"TargetBuffer\"&gt;TargetBuffer for compressed data&lt;/param&gt;\n        /// &lt;param name=\"TargetIndex\"&gt;Cursor in TargetBuffer to start writing&lt;/param&gt;\n        /// &lt;param name=\"UncompressedLength\"&gt;Uncompressed data length in SourceBuffer&lt;/param&gt;\n        /// &lt;returns&gt;Compressed length&lt;/returns&gt;\n        public static int Compress(byte[] SourceBuffer, int SourceIndex, byte[] TargetBuffer, int TargetIndex, int UncompressedLength)\n        {\n            int compressedLength = 0;\n\n            // init crush32\n            if (Crush32.CX_SUCCESS == Crush32.cxInit())\n            {\n                if (Crush32.CX_SUCCESS == Crush32.cxBuf2BufInit())\n                {\n                    // pin the managed source &amp; targetbuffers in memory so crush32 can access them\n                    // and we can directly use them without marshaling.\n                    fixed (byte* ptrSourceBuffer = SourceBuffer, ptrTargetBuffer = TargetBuffer)\n                    {\n                        // add the offsets to the pointers (they still point to the beginning of the buffer)\n                        byte* ptrSourceIndex = ptrSourceBuffer + SourceIndex;\n                        byte* ptrTargetIndex = ptrTargetBuffer + TargetIndex;\n\n                        // compress\n                        compressedLength = Crush32.cxBuf2BufCompress(ptrSourceIndex, ptrTargetIndex, UncompressedLength);\n                    }\n\n                    Crush32.cxBuf2BufClose();\n                }\n\n                Crush32.cxCleanup();\n            }\n\n            return compressedLength;\n        }\n\n        /// &lt;summary&gt;\n        /// Fast decrypt data in managed buffer using pointer\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"SourceBuffer\"&gt;SourceBuffer containing encrypted data&lt;/param&gt;\n        /// &lt;param name=\"SourceIndex\"&gt;Cursor in SourceBuffer to start reading&lt;/param&gt;\n        /// &lt;param name=\"Length\"&gt;Encrypted data length&lt;/param&gt;\n        /// &lt;param name=\"Challenge\"&gt;Challenge to use&lt;/param&gt;\n        /// &lt;param name=\"ExpectedResponse\"&gt;ExpectedRespone to use&lt;/param&gt;\n        /// &lt;param name=\"Password\"&gt;Password to use&lt;/param&gt;\n        /// &lt;returns&gt;True if the operation was successful.&lt;/returns&gt;\n        public static bool Decrypt(byte[] SourceBuffer, int SourceIndex, int Length, uint Challenge, uint ExpectedResponse, byte[] Password)\n        {\n            bool isSuccessful = false;\n\n            // pin the managed sourcebuffer in memory so crush32 can access\n            // and we can directly use without marshaling.\n            fixed (byte* ptrSourceBuffer = SourceBuffer)\n            {\n                // add the offsets to the pointers (they still point to the beginning of the buffer)\n                byte* ptrSourceIndex = ptrSourceBuffer + SourceIndex;\n                isSuccessful = Decrypt(ptrSourceIndex, Length, Challenge, ExpectedResponse, Password);\n            }\n\n            return isSuccessful;\n        }\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        /// &lt;param name=\"SourceBuffer\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"Length\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"Challenge\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"ExpectedREsponse\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"Password\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static unsafe bool Decrypt(byte* SourceBuffer, int Length, uint Challenge, uint ExpectedResponse, byte[] Password)\n        {\n            bool isSuccessful = false;\n\n            // init crush32\n            if (Crush32.CX_SUCCESS == Crush32.cxInit())\n            {\n                if (Crush32.CX_SUCCESS == Crush32.cxBuf2BufInit())\n                {\n                    // pin the managed sourcebuffer in memory so crush32 can access\n                    // and we can directly use without marshaling.\n                    fixed (byte* ptrPassword = Password)\n                    {\n                        // set password &amp;&amp; decrypt\n                        if (Crush32.CX_SUCCESS == Crush32.cxSetPassword(ptrPassword))\n                            if (Crush32.CX_SUCCESS == Crush32.cxBufDecrypt(SourceBuffer, Length, Challenge, ExpectedResponse))\n                                isSuccessful = true;\n                    }\n\n                    Crush32.cxBuf2BufClose();\n                }\n\n                Crush32.cxCleanup();\n            }\n\n            return isSuccessful;\n        }\n\n        /// &lt;summary&gt;\n        /// Fast encrypt data in managed buffer using pointer\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"SourceBuffer\"&gt;SourceBuffer containing data to be encrypted&lt;/param&gt;\n        /// &lt;param name=\"SourceIndex\"&gt;Cursor in SourceBuffer to start reading&lt;/param&gt;\n        /// &lt;param name=\"Length\"&gt;Length of data to be encrypted&lt;/param&gt;\n        /// &lt;param name=\"Challenge\"&gt;Challenge to use&lt;/param&gt;\n        /// &lt;param name=\"Password\"&gt;Password to use&lt;/param&gt;\n        /// &lt;returns&gt;ExpectedResponse for Challenge/Password combination.&lt;/returns&gt;\n        public static uint Encrypt(byte[] SourceBuffer, int SourceIndex, int Length, uint Challenge, byte[] Password)\n        {\n            uint expectedResponse = 0;\n\n            // pin the managed sourcebuffer in memory so crush32 can access\n            // and we can directly use without marshaling.\n            fixed (byte* ptrSourceBuffer = SourceBuffer, ptrPassword = Password)\n            {\n                // add the offsets to the pointers (they still point to the beginning of the buffer)\n                byte* ptrSourceIndex = ptrSourceBuffer + SourceIndex;\n                expectedResponse = Encrypt(ptrSourceIndex, Length, Challenge, Password);\n            }\n\n            return expectedResponse;\n        }\n\n        /// &lt;summary&gt;\n        /// Fast encrypt data on unmanaged pointer\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"SourceBuffer\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"Length\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"Challenge\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"Password\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static unsafe uint Encrypt(byte* SourceBuffer, int Length, uint Challenge, byte[] Password)\n        {\n            uint expectedResponse = 0;\n\n            // init crush32\n            if (Crush32.CX_SUCCESS == Crush32.cxInit())\n            {\n                if (Crush32.CX_SUCCESS == Crush32.cxBuf2BufInit())\n                {\n                    // pin the managed sourcebuffer in memory so crush32 can access\n                    // and we can directly use without marshaling.\n                    fixed (byte* ptrPassword = Password)\n                    {\n                        // set password &amp;&amp; encrypt\n                        if (Crush32.CX_SUCCESS == Crush32.cxSetPassword(ptrPassword))\n                            expectedResponse = Crush32.cxBufEncrypt(SourceBuffer, Length, Challenge);\n                    }\n\n                    Crush32.cxBuf2BufClose();\n                }\n\n                Crush32.cxCleanup();\n            }\n\n            return expectedResponse;\n        }\n        #endregion\n        #region Public main\n        [STAThread]\n        static void Main(string[] args)\n        {\n            byte[] Data = File.ReadAllBytes(\"s001.bli\");\n                int CompressedLength = Data.Length;\n                int UncompressedLength = 0;\n                byte[] decompressedPixelData = new byte[UncompressedLength];\n                bool result = Crush32.Decompress(Data, 15, decompressedPixelData, 0, (int)UncompressedLength, CompressedLength);\n                string s = \"{\" +\n                        string.Join(\", \",\n                            decompressedPixelData.Select(x =&gt; string.Format(\"0x{0}\", x.ToString(\"X\")))\n                        ) + \"}\";\n                Console.WriteLine(s);\n                Console.ReadKey(true);\n\n        }\n        #endregion\n    }\n}\n</code></pre>\n</div>",
    "votes": "2",
    "answers": 0,
    "views": "351",
    "tags": [
        "decompress",
        "c#"
    ],
    "user": "Антон Родин",
    "time": "Jun 4, 2019 at 6:38",
    "comments": [
        {
            "user": "Антон Родин",
            "text": "<span class=\"comment-copy\">I don`t know. I know that these files can be read by LinkOne program, but I need to open them separately. There is also another program that seems to work with this library. That version of the code I also could not run: <a href=\"https://github.com/cyberjunk/meridian59-dotnet/blob/master/Meridian59/Common/Crush32.cs\" rel=\"nofollow noreferrer\">github.com/cyberjunk/meridian59-dotnet/blob/master/Meridian59/…</a>.</span>",
            "time": null
        }
    ],
    "answers_data": []
}