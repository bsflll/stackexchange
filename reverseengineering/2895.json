{
    "title": "Delphi Pascal Try..Except..Finally block",
    "link": "https://reverseengineering.stackexchange.com/questions/2895/delphi-pascal-try-except-finally-block",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm having trouble reverse-engineering a specific Delphi Pascal .exe (old vsn., pre-1995 so probably v.3). From the system calls I understand this is <em>probably</em> a <code>try..except..finally</code> block, but I am at a loss finding the 'normal' route through the code, and what the <code>except</code> and (possibly) <code>finally</code> blocks are.</p>\n<p>The assembly looks like this:</p>\n<pre><code>782CFC  33 C0                   xor    eax, eax\n782CFE  55                      push   ebp\n782CFF  68 (782E37)             push   _FINALLY_A_0_782E37\n782D04  64 FF 30                push   dword ptr fs:[eax]\n782D07  64 89 20                mov    dword ptr fs:[eax], esp\n\n            _try_0_782D0A:\n782D0A  8B D3                   mov    edx, ebx\n782D0C  8B C6                   mov    eax, esi\n782D0E  E8 D1 F3 FF FF          call   ...unrelated...\n782D13  8D 56 1C                lea    edx, [esi+1Ch]\n.. lots of regular code here ..\n.. ending with ..\n782E17  8B 18                   mov    ebx, dword ptr [eax]\n782E19  FF 53 20                call   dword ptr [ebx+20h]\n\n        finally_1_782E1C:\n782E1C  33 C0                   xor    eax, eax\n782E1E  5A                      pop    edx\n782E1F  59                      pop    ecx\n782E20  59                      pop    ecx\n782E21  64 89 10                mov    dword ptr fs:[eax], edx\n782E24  68 (782E3E)             push   _end_1_782E3E\n\n                @block_L:\n782E29  8D 45 F4                lea    eax, [ebp + local_0C]\n782E2C  BA 02 00 00 00          mov    edx, 2\n782E31  E8 12 E3 F7 FF          call   System.@LStrArrayClr\n782E36  C3                      retn\n\n            _FINALLY_A_0_782E37:\n782E37  E9 B4 E2 F7 FF          jmp    System.@HandleFinally\n\n            _FINALLY_B_0_782E3C:\n782E3C  EB EB                   jmp    @block_L\n                ; -------\n\n            _end_1_782E3E:\n782E3E  5F                      pop    edi\n782E3F  5E                      pop    esi\n782E40  5B                      pop    ebx\n782E41  8B E5                   mov    esp, ebp\n782E43  5D                      pop    ebp\n782E44  C3                      retn\n</code></pre>\n<p>-- this is output from my own disassembler, but I don't think there are errors in it. The labels have been auto-named, but I still cannot follow the 'logic' (if any) from one block to the next. In particular, the bottom half, right before the function epilogue, confuses me.</p>\n<p>Are these fragments enough to reconstruct the original <code>try</code>..<code>finally</code> blocks?</p>\n<hr/>\n<p>After reading Igor's answer: yes they are. Consider these flowcharts: left, original before special handling of try/finally blocks, right, afterwards.</p>\n<p><img alt=\"flowcharts\" src=\"https://i.sstatic.net/1B6lK.png\"/></p>\n<p>In the original flowchart, I considered every jump from one basic block to another as a <em>link</em>, and the code flow stops at every <code>retn</code>. <code>if</code> (E-(F)-K) and <code>if-else</code> (G-H/I-J) structures can clearly be discerned. However, pushing return addresses and the other 'tricks' of exception handling, defeat this, as can be seen by the dangling blocks N and O -- they 'enter' from nowhere --, and a separate block 'M' which comes and goes from nowhere.</p>\n<p>At the right, I separated the <em>initialization</em> of the exception block from the main code (adding a new block B), and concatenated the <em>finalize</em> structure into one single new block (M), which ultimately jumps to an AFTER_TRY (which happened to be the last <em>Exit</em> block). Now it's clear that</p>\n<ol>\n<li>right after the prologue, a <code>try</code> is initiated;</li>\n<li>all code ends up at the <code>finally</code> block M, which</li>\n<li>then always exists the code at a single fixed point.</li>\n</ol>\n</div>",
    "votes": "12",
    "answers": 1,
    "views": "3k",
    "tags": [
        "disassembly",
        "decompilation"
    ],
    "user": "Jongware",
    "time": "Oct 7, 2013 at 21:44",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Delphi implements <code>try</code>/<code>except</code>/<code>finally</code> by using Win32 Structured Exception Handlers (SEH). The basics of SEH are explained in the <a href=\"http://www.microsoft.com/msj/0197/Exception/Exception.aspx\" rel=\"noreferrer\">classic article by Matt Pietrek</a>, so I'll skip to the details relevant to Delphi only.</p>\n<h1>1. <code>try</code> entry</h1>\n<p>Entry to a <code>try</code> block, or a block which protects automatic variables that need to be destructed on exit (such as strings) looks like the following:</p>\n<pre><code>xor     eax, eax\npush    ebp\npush    offset SEH_HANDLER\npush    dword ptr fs:[eax]\nmov     fs:[eax], esp\n</code></pre>\n<p>This is a typical way of setting up a SEH frame. After it's run, top of the stack will look like this:</p>\n<pre><code>       +-----------+\nESP+00 |    next   | &lt;- fs:[0] points here\n       +-----------+\nESP+04 |  handler  |\n       +-----------+\nESP+08 | saved_ebp |\n       +-----------+\n</code></pre>\n<p>The pointer to this structure will be passed to the SEH handler.</p>\n<h1>2. <code>try</code> exit</h1>\n<p>At the end of the <code>try</code> block, the SEH frame is torn down:</p>\n<pre><code>    xor     eax, eax\n    pop     edx               ; pop 'next' into edx\n    pop     ecx               ; pop handler\n    pop     ecx               ; pop saved_ebp\n    mov     fs:[eax], edx     ; move 'next' into fs:[0]\n</code></pre>\n<p>If there is a <code>finally</code> handler or automatic destructors, then it continues like this:</p>\n<pre><code>    push    offset AFTER_TRY  ; make it so the 'ret' will jump to AFTER_TRY\nFINALLY_HANDLER:\n    &lt;destruct automatic variables created in the try block&gt;\n    &lt;finally handler body&gt;\n    ret                       ; jumps to AFTER_TRY\n</code></pre>\n<p>Otherwise there is a simple jump:</p>\n<pre><code>    jmp AFTER_TRY\n</code></pre>\n<h1>3. <code>finally</code> handler</h1>\n<p>In case the program use <code>finally</code> statement, or in case of the <code>try..finally</code> added by the compiler to guard automatic variables, the SEH handler looks like this:</p>\n<pre><code>SEH_HANDLER:\n    jmp     _HandleFinally\n    jmp     FINALLY_HANDLER\n</code></pre>\n<h1>4. <code>except</code> handler</h1>\n<p>If the program uses an <code>except</code> handler to catch all exceptions, the code looks a little different:</p>\n<pre><code>SEH_HANDLER:\n    jmp     _HandleAnyException\n    &lt;handler code&gt;\n    call    _DoneExcept\n</code></pre>\n<h1>5. <code>except on</code> handlers</h1>\n<p>If the program uses <code>except on...</code> to match the exception(s) being caught, the compiler generates a table of one or more possible exception classes with corresponding handlers:</p>\n<pre><code>SEH_HANDLER:\n    jmp     _HandleOnException\n    dd &lt;numExceptions&gt;\n    dd offset ExceptionClass1\n    dd offset OnException1_handler\n    dd offset ExceptionClass2\n    dd offset OnException2_handler\n    &lt;...&gt;\n\nOnException1_handler:\n    &lt;handler code&gt;\n    call    _DoneExcept\n\nOnException2_handler:\n    &lt;handler code&gt;\n    call    _DoneExcept\n</code></pre>\n<p>There may be some variations, but I think I covered most of it.</p>\n<p>The source code of <code>_HandleFinally</code>, <code>_HandleAnyException</code>, <code>_HandleOnException</code>, <code>_DoneExcept</code> and a few other exceptions-related functions can be found in <code>system.pas</code> in the VCL sources.</p>\n</div>",
            "votes": "11",
            "user": "Igor Skochinsky",
            "time": "Oct 7, 2013 at 15:26",
            "is_accepted": true,
            "comments": []
        }
    ]
}