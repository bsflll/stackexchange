{
    "title": "Cannot load libvulkan.so on Linux chroot running on Android while normal Android apps can load it",
    "link": "https://reverseengineering.stackexchange.com/questions/31577/cannot-load-libvulkan-so-on-linux-chroot-running-on-android-while-normal-android",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<h1>Environment</h1>\n<p>First I will give a quick summary of my environment</p>\n<p>Device: Samsung Galaxy M20 (m20lte)<br/>\nSoC: <a href=\"https://semiconductor.samsung.com/processor/mobile-processor/exynos-7-series-7904/\" rel=\"nofollow noreferrer\">Exynos 7904</a> (with Mali-G71 GPU)<br/>\nOS: Android 10 (Stock ROM with root using <a href=\"https://github.com/topjohnwu/Magisk/\" rel=\"nofollow noreferrer\">Magisk</a>)<br/>\nKernel: 4.4.177<br/>\nSELinux is disabled (set to permissive mode)<br/>\nVulkan API version: 1.1.108</p>\n<p>Chroot environment: Debian 11 (arm64) running on <a href=\"https://github.com/meefik/linuxdeploy\" rel=\"nofollow noreferrer\">Linux Deploy</a>, with full root access. Directories like <code>/dev</code>, <code>/proc</code>, <code>/data</code>, <code>/system</code>, <code>/sdcard</code> are mounted into the chroot.</p>\n<h1>Vulkan availability</h1>\n<p>I know this device support Vulkan API (Vulkan loader avaliable at <code>/system/lib64/libvulkan.so</code>).</p>\n<p>Normal Android apps can load and use Vulkan APIs without any problems. For example:</p>\n<ul>\n<li><a href=\"https://github.com/SaschaWillems/VulkanCapsViewer\" rel=\"nofollow noreferrer\">Vulkan Caps Viewer</a> can display Vulkan information on this device</li>\n<li>GeekBench 5, <code>Compute</code> section has an option to compute with GPU using Vulkan API, and it works well</li>\n</ul>\n<h1>Problem</h1>\n<p>I cannot load <code>libvulkan.so</code> from <code>/system/lib64/libvulkan.so</code> by running program in the chroot.</p>\n<p>For example, I created a simple c source (named <code>dlopen.c</code>):</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;dlfcn.h&gt;\n\nint main() {\n        void *handle = dlopen(\"libvulkan.so\", RTLD_LAZY);\n        if (!handle) {\n                printf(\"Cannot load libvulkan.so\\n\");\n        } else {\n                printf(\"Loaded libvulkan.so\\n\");\n        }\n\n        return 0;\n}\n</code></pre>\n<p>Compile it using gcc: <code>gcc dlopen.c -ldl -o dlopentest</code><br/>\nSetup the environment variable <code>LD_LIBRARY_PATH=/system/lib64/</code> or symlink <code>/system/lib64/libvulkan.so</code> to (folder in chroot) <code>/lib/aarch64-linux-gnu/libvulkan.so</code> and <code>/lib/aarch64-linux-gnu/libvulkan.so.1</code><br/>\nFinally run it using <code>./dlopentest</code>, the program always print <code>Cannot load libvulkan.so</code></p>\n<p>Using <code>strace</code>, but nothing weird found (<a href=\"https://gist.github.com/raspiduino/32a35cee634a4ef33208ec11485ecac6#file-strace1-txt\" rel=\"nofollow noreferrer\">log link</a>)</p>\n<p>I'm not sure about <code>/lib/aarch64-linux-gnu/libc.so</code>, since instead of being a symlink to <code>libc.so.6</code> or a real <code>.so</code> file, it's some kind of ld script. But replacing it with a symlink to <code>libc.so.6</code> makes no change.</p>\n<p><code>vulkaninfo</code> also reports an error:</p>\n<pre><code>ERROR at /build/vulkan-tools-3Ouhix/vulkan-tools-1.2.162.0+dfsg1/vulkaninfo/vulkaninfo.h:628: Failed to initialize: Vulkan loader is not installed, not found, or failed to load.\n</code></pre>\n<p><code>strace</code> result is pretty much the same as my <code>dlopentest</code>, so I won't include it here.</p>\n<h1>EDIT 1:</h1>\n<p>(actually I don't know what section to put this, so I put it here)</p>\n<p>Running <code>file</code> on <code>/system/lib64/libvulkan.so</code>:</p>\n<pre><code>/system/lib64/libvulkan.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[md5/uuid]=e749d3c10d92fcef9b84402783d311f8, stripped\n</code></pre>\n<p>It's <code>dynamically linked</code>, so I run <code>ldd</code> on it and notice the following line:</p>\n<pre><code>/system/lib64/libvulkan.so: /lib/aarch64-linux-gnu/libc.so: version `LIBC' not found (required by /system/lib64/libvulkan.so)\n/system/lib64/libvulkan.so: /lib/aarch64-linux-gnu/libdl.so: version `LIBC' not found (required by /system/lib64/libvulkan.so)\n</code></pre>\n<p>And other lines from <code>.so</code> libraries in <code>/system/lib64</code> claimed the same thing.</p>\n<p>So I check the <code>/system/lib64/libc.so</code>, and found that it's a symbolic link to <code>/apex/com.android.runtime/lib64/bionic/libc.so</code>.</p>\n<p>So I mounted <code>/apex/com.android.runtime</code> to chroot.</p>\n<p>After doing so, ldd found no more problem (<a href=\"https://gist.github.com/raspiduino/32a35cee634a4ef33208ec11485ecac6#file-ldd1-txt\" rel=\"nofollow noreferrer\">log link</a>)</p>\n<p>But, when I run the program:</p>\n<pre><code>root@localhost:~# ./dlopentest\nTrace/breakpoint trap\n</code></pre>\n<p>Running <code>strace</code> (<a href=\"https://gist.github.com/raspiduino/32a35cee634a4ef33208ec11485ecac6#file-strace2-txt\" rel=\"nofollow noreferrer\">log link</a>)</p>\n<p>Using <code>gdb</code>, I found that it was a trap signal from <code>/system/lib64/ld-android.so</code></p>\n<pre><code>Program received signal SIGTRAP, Trace/breakpoint trap.\n0x0000007fb7fef000 in rtld_db_dlactivity () from /system/lib64/ld-android.so\n</code></pre>\n<p>When I check that file:</p>\n<pre><code>root@localhost:~# file /system/lib64/ld-android.so\n/system/lib64/ld-android.so: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, BuildID[md5/uuid]=62f4de8cdef6f71d65c403ac59427c51, stripped\nroot@localhost:~# ldd /system/lib64/ld-android.so\n        statically linked\n</code></pre>\n<h1>Question</h1>\n<ul>\n<li>Why it does not work (why I cannot load <code>libvulkan.so</code> properly)?</li>\n<li>How to fix it?</li>\n</ul>\n<h1>Real purpose</h1>\n<p>I know this section might not related to the question, but I still want to include it, to avoid possible XY problem.</p>\n<p>I want to run <a href=\"https://warthunder.com/en\" rel=\"nofollow noreferrer\">War Thunder</a> (a game, and it supports x86_64 Linux). I run it on <a href=\"https://github.com/ptitSeb/box64\" rel=\"nofollow noreferrer\">box64</a> and it runs until report cannot initialize Vulkan. FYI, Vulkan is the only supported render backend for the game on Linux, so I can't use OpenGL or something.</p>\n<p>The game require the real libc (not Android one), so I can't run it on proot, and distro-proof on Termux is too complicated compared to Linux Deploy.</p>\n<p>Finally, thank you for reading this\nI just want to run War Thunder :)</p>\n</div>",
    "votes": "2",
    "answers": 0,
    "views": "559",
    "tags": [
        "android",
        "linux",
        "shared-object"
    ],
    "user": "raspiduino",
    "time": "Feb 23, 2023 at 18:35",
    "comments": [
        {
            "user": "raspiduino",
            "text": "<span class=\"comment-copy\">Ok, I think this crash because <code>/lib/aarch64-linux-gnu/libc.so.6</code> is loaded, then another libc <code>/system/lib64/libc.so</code> is loaded. I don't think libc can be loaded with multiple instances</span>",
            "time": null
        },
        {
            "user": "raspiduino",
            "text": "<span class=\"comment-copy\">Possible solution: 1) (unlikely) If we can call vulkan api from vulkan kernel driver without using Android libs, then write a simple vulkan loader than redirect the calls. 2) Write a \"Vulkan server\" that create an IPC (pipeline), read Vulkan commands from that pipeline, then calls to Android's libvulkan.so, then compile it using Android NDK. Then write a \"client\" libvulkan.so that communicate through the IPC to redirect the calls from program. Compile it using gcc in chroot.</span>",
            "time": null
        }
    ],
    "answers_data": []
}