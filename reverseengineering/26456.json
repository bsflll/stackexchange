{
    "title": "Correct way to understand local_ in ghidra disassembly",
    "link": "https://reverseengineering.stackexchange.com/questions/26456/correct-way-to-understand-local-in-ghidra-disassembly",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Attached is the part of a disassembled main from a x86 binary file, generated by ghidra.</p>\n<pre><code>                             **************************************************************\n                             *                          FUNCTION                          *\n                             **************************************************************\n                             undefined main(undefined1 param_1)\n             undefined         AL:1           &lt;RETURN&gt;                                XREF[1]:     0804835e(W)  \n             undefined1        Stack[0x4]:1   param_1                                 XREF[1]:     08048309(*)  \n             undefined4        EAX:4          str_in                                  XREF[1]:     0804835e(W)  \n             undefined4        Stack[0x0]:4   local_res0                              XREF[1]:     08048310(R)  \n             undefined4        Stack[-0x10]:4 local_10                                XREF[6]:     08048358(R), \n                                                                                                   08048363(W), \n                                                                                                   0804836d(R), \n                                                                                                   08048388(R), \n                                                                                                   08048393(W), \n                                                                                                   0804839d(R)  \n             undefined4        Stack[-0x14]:4 local_14                                XREF[2]:     0804831a(W), \n                                                                                                   08048366(R)  \n             undefined4        Stack[-0x18]:4 local_18                                XREF[2]:     08048321(W), \n                                                                                                   08048396(R)  \n             undefined4        Stack[-0x2c]:4 local_2c                                XREF[3]:     08048369(W), \n                                                                                                   08048399(W), \n                                                                                                   080483ac(W)  \n             undefined4        Stack[-0x30]:4 local_30                                XREF[12]:    08048328(*), \n                                                                                                   08048334(*), \n                                                                                                   08048340(*), \n                                                                                                   0804834c(*), \n                                                                                                   0804835b(*), \n                                                                                                   08048370(*), \n                                                                                                   0804837c(*), \n                                                                                                   0804838b(*), \n                                                                                                   080483a0(*), \n                                                                                                   080483b4(*), \n                                                                                                   080483c2(*), \n                                                                                                   080483d0(*)  \n                             main                                            XREF[2]:     Entry Point(*), \n                                                                                          _start:08048167(*)  \n        08048309 8d 4c 24 04     LEA        ECX=&gt;param_1,[ESP + 0x4]\n        0804830d 83 e4 f0        AND        ESP,0xfffffff0\n        08048310 ff 71 fc        PUSH       dword ptr [ECX + local_res0]\n        08048313 55              PUSH       EBP\n        08048314 89 e5           MOV        EBP,ESP\n        08048316 51              PUSH       ECX\n        08048317 83 ec 24        SUB        ESP,0x24\n        0804831a c7 45 f4        MOV        dword ptr [EBP + local_14],DAT_080a6b19          = 6Ah    j\n                 19 6b 0a 08\n        08048321 c7 45 f0        MOV        dword ptr [EBP + local_18],s_the_ripper_080a6b1e = \"the ripper\"\n                 1e 6b 0a 08\n</code></pre>\n<p>Same code from gdb</p>\n<pre><code>   0x08048309 &lt;+0&gt;: lea    ecx,[esp+0x4]\n   0x0804830d &lt;+4&gt;: and    esp,0xfffffff0\n   0x08048310 &lt;+7&gt;: push   DWORD PTR [ecx-0x4]\n   0x08048313 &lt;+10&gt;:    push   ebp\n   0x08048314 &lt;+11&gt;:    mov    ebp,esp\n   0x08048316 &lt;+13&gt;:    push   ecx\n   0x08048317 &lt;+14&gt;:    sub    esp,0x24\n=&gt; 0x0804831a &lt;+17&gt;:    mov    DWORD PTR [ebp-0xc],0x80a6b19\n</code></pre>\n<p>Why is ghidra changeing <code>[ebp-0xc]</code> to <code>[EBP + local_14]</code>.\nSimilar question I found is <a href=\"https://reverseengineering.stackexchange.com/questions/23540/ghidra-interpreting-stack-pointers-wrongly\">Ghidra interpreting stack pointers wrongly</a> but reading the answer, I'm not getting the meaning of <code>[EBP + local_14]</code> Here, is ghidra just renaming <code>-0xc</code> to a easily readable name like <code>local_14</code>? I'm not getting how to make sense of this exactly.</p>\n<p>In the function header, it is shown that <code>Stack[-0x10]:4 local_10</code>. I assume it means that <code>local_10</code> is 4 byte variable at Stack[-0x10], where Stack is the stack pointer upon entry to function. But why is it added to ebp. What's the meaning of that representation used by ghidra?</p>\n</div>",
    "votes": "4",
    "answers": 1,
    "views": "5k",
    "tags": [
        "disassembly",
        "binary-analysis",
        "x86",
        "gdb",
        "ghidra"
    ],
    "user": "Mah35h",
    "time": "Dec 6, 2020 at 16:52",
    "comments": [
        {
            "user": "rustyMagnet",
            "text": "<span class=\"comment-copy\">Before doing anything with Ghidra, I start to help Ghidra by telling it the return types of functions ( <code>int</code>, <code>void</code>, <code>char *</code>, etc ). Then I do the same for the function parameters.  Just this step alone starts to clear up the local variables.  Did you try that ?</span>",
            "time": null
        },
        {
            "user": "hairlessbear",
            "text": "<span class=\"comment-copy\">One thing you can do that may make this more obvious is to turn off the setting that causes Ghidra to use the <code>local_</code> variables directly in the assembly. You can do this via <code>Edit -&gt; Tool Options -&gt; Listing Fields -&gt; Operands Field -&gt; Markup Stack Variable References</code>. This will change the display to show the normal operands, with an arrow indicating what stack variable is being referenced.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Since local variables are usually placed on the stack in <code>x86</code> and <code>esp</code> register can change during function execution, it is more convenient to save the value of <code>esp</code> register on function entry and access data relatively to that value. <code>ebp</code> register is used for this purpose. So you will often see</p>\n<pre><code>push ebp\nmov ebp, esp\n</code></pre>\n<p>lines at the begining of functions. In the example you have provided it is the case - all local variables are accessed this way, through <code>ebp</code>.</p>\n<p>Now, there are two different naming conventions for local variables:</p>\n<ul>\n<li>first and more natural one: if <code>[ebp - xxx]</code> is accessed, it will be displayed as <code>[ebp + local_xxx]</code>. Here, <code>local_xxx = -xxx</code>, so for instance, <code>local_18 = -0x18</code>.</li>\n<li>second and less intuitive one makes use of the <code>esp</code> value at the beginning of a function. In your example, two dwords are pushed on the stack before <code>mov ebp, esp</code> line. It means, that if some local variable was called <code>local_xxx</code> in the first convention, in the second one it will be named <code>local_xxx+0x8</code>, for instance <code>local_18</code> in the first one will be <code>local_20</code> in the second one, used by Ghidra.</li>\n</ul>\n<p>Why do we add <code>0x8</code> in the second one? Because two dwords (<code>8</code> bytes) were pushed onto the stack before <code>esp</code> value was saved into <code>ebp</code> and in <code>x86</code> architecture stack \"grows downwards\", which means if you push something onto it, this value will be saved there and <code>esp</code> will be <em>decreased</em> accordingly (in this case, twice, by <code>4</code> bytes). So, in your particular example, you have the instruction</p>\n<pre><code>mov    DWORD PTR [ebp-0xc],0x80a6b19\n</code></pre>\n<p>which would be displayed as</p>\n<pre><code>mov    DWORD PTR [ebp+local_c],0x80a6b19\n</code></pre>\n<p>in the first convention and</p>\n<pre><code>mov    DWORD PTR [ebp+local_14],0x80a6b19\n</code></pre>\n<p>in the second one, implemented in Ghidra, since <code>0xc + 0x8 = 0x14</code>.</p>\n</div>",
            "votes": "9",
            "user": "bart1e",
            "time": "Dec 8, 2020 at 17:26",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Mah35h",
                    "text": "<span class=\"comment-copy\">Just to confirm. In the second convention, when it shows <code>ebp+local_14</code> , ebp actually mean the value of esp at the beginning of of the function call and not the value of ebp when the instruction is ran?</span>",
                    "time": null
                },
                {
                    "user": "bart1e",
                    "text": "<span class=\"comment-copy\">No, it is current ebp value (which is entry_esp-8).</span>",
                    "time": null
                },
                {
                    "user": "Mah35h",
                    "text": "<span class=\"comment-copy\">then value of local_14 should be -0xC right. Else it'll point to wrong memory location when added with ebp</span>",
                    "time": null
                },
                {
                    "user": "bart1e",
                    "text": "<span class=\"comment-copy\">Exactly. And that's why I called this convention \"less intuitive\".</span>",
                    "time": null
                }
            ]
        }
    ]
}