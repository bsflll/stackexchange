{
    "title": "How can I manually figure out stack variable/buffer sizes from stripped x86-64 disassembly?",
    "link": "https://reverseengineering.stackexchange.com/questions/31083/how-can-i-manually-figure-out-stack-variable-buffer-sizes-from-stripped-x86-64-d",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am looking at the following CTF challenge:</p>\n<pre><code> 0x56555779 &lt;+0&gt;:   lea    ecx,[esp+0x4]\n   0x5655577d &lt;+4&gt;: and    esp,0xfffffff0\n   0x56555780 &lt;+7&gt;: push   DWORD PTR [ecx-0x4]\n   0x56555783 &lt;+10&gt;:    push   ebp\n   0x56555784 &lt;+11&gt;:    mov    ebp,esp\n   0x56555786 &lt;+13&gt;:    push   ebx\n   0x56555787 &lt;+14&gt;:    push   ecx\n   0x56555788 &lt;+15&gt;:    sub    esp,0x40\n   0x5655578b &lt;+18&gt;:    call   0x56555600 &lt;__x86.get_pc_thunk.bx&gt;\n   0x56555790 &lt;+23&gt;:    add    ebx,0x1820\n   0x56555796 &lt;+29&gt;:    mov    eax,DWORD PTR [ebx+0x44]\n   0x5655579c &lt;+35&gt;:    mov    eax,DWORD PTR [eax]\n   0x5655579e &lt;+37&gt;:    push   0x0\n   0x565557a0 &lt;+39&gt;:    push   0x0\n   0x565557a2 &lt;+41&gt;:    push   0x2\n   0x565557a4 &lt;+43&gt;:    push   eax\n   0x565557a5 &lt;+44&gt;:    call   0x56555580 &lt;setvbuf@plt&gt;\n   0x565557aa &lt;+49&gt;:    add    esp,0x10\n=&gt; 0x565557ad &lt;+52&gt;:    mov    DWORD PTR [ebp-0xc],0x2\n   0x565557b4 &lt;+59&gt;:    mov    DWORD PTR [ebp-0x10],0x0\n   0x565557bb &lt;+66&gt;:    sub    esp,0xc\n   0x565557be &lt;+69&gt;:    lea    eax,[ebx-0x1620]\n   0x565557c4 &lt;+75&gt;:    push   eax\n   0x565557c5 &lt;+76&gt;:    call   0x56555550 &lt;puts@plt&gt;\n   0x565557ca &lt;+81&gt;:    add    esp,0x10\n   0x565557cd &lt;+84&gt;:    sub    esp,0xc\n   0x565557d0 &lt;+87&gt;:    lea    eax,[ebx-0x15b5]\n   0x565557d6 &lt;+93&gt;:    push   eax\n   0x565557d7 &lt;+94&gt;:    call   0x56555550 &lt;puts@plt&gt;\n   0x565557dc &lt;+99&gt;:    add    esp,0x10\n   0x565557df &lt;+102&gt;:   mov    eax,DWORD PTR [ebx+0x40]\n   0x565557e5 &lt;+108&gt;:   mov    eax,DWORD PTR [eax]\n   0x565557e7 &lt;+110&gt;:   sub    esp,0x4\n   0x565557ea &lt;+113&gt;:   push   eax\n   0x565557eb &lt;+114&gt;:   push   0x2b\n   0x565557ed &lt;+116&gt;:   lea    eax,[ebp-0x3b]\n   0x565557f0 &lt;+119&gt;:   push   eax\n   0x565557f1 &lt;+120&gt;:   call   0x56555530 &lt;fgets@plt&gt;\n   0x565557f6 &lt;+125&gt;:   add    esp,0x10\n   0x565557f9 &lt;+128&gt;:   sub    esp,0x8\n   0x565557fc &lt;+131&gt;:   lea    eax,[ebx-0x159f]\n   0x56555802 &lt;+137&gt;:   push   eax\n   0x56555803 &lt;+138&gt;:   lea    eax,[ebp-0x3b]\n   0x56555806 &lt;+141&gt;:   push   eax\n   0x56555807 &lt;+142&gt;:   call   0x56555510 &lt;strcmp@plt&gt;\n   0x5655580c &lt;+147&gt;:   add    esp,0x10\n   0x5655580f &lt;+150&gt;:   test   eax,eax\n   0x56555811 &lt;+152&gt;:   je     0x5655582f &lt;main+182&gt;\n   0x56555813 &lt;+154&gt;:   sub    esp,0xc\n   0x56555816 &lt;+157&gt;:   lea    eax,[ebx-0x1584]\n   0x5655581c &lt;+163&gt;:   push   eax\n   0x5655581d &lt;+164&gt;:   call   0x56555550 &lt;puts@plt&gt;\n   0x56555822 &lt;+169&gt;:   add    esp,0x10\n   0x56555825 &lt;+172&gt;:   sub    esp,0xc\n   0x56555828 &lt;+175&gt;:   push   0x0\n   0x5655582a &lt;+177&gt;:   call   0x56555560 &lt;exit@plt&gt;\n   0x5655582f &lt;+182&gt;:   sub    esp,0xc\n   0x56555832 &lt;+185&gt;:   lea    eax,[ebx-0x1564]\n   0x56555838 &lt;+191&gt;:   push   eax\n   0x56555839 &lt;+192&gt;:   call   0x56555550 &lt;puts@plt&gt;\n   0x5655583e &lt;+197&gt;:   add    esp,0x10\n   0x56555841 &lt;+200&gt;:   mov    eax,DWORD PTR [ebx+0x40]\n   0x56555847 &lt;+206&gt;:   mov    eax,DWORD PTR [eax]\n   0x56555849 &lt;+208&gt;:   sub    esp,0x4\n   0x5655584c &lt;+211&gt;:   push   eax\n   0x5655584d &lt;+212&gt;:   push   0x2b\n   0x5655584f &lt;+214&gt;:   lea    eax,[ebp-0x3b]\n   0x56555852 &lt;+217&gt;:   push   eax\n   0x56555853 &lt;+218&gt;:   call   0x56555530 &lt;fgets@plt&gt;\n   0x56555858 &lt;+223&gt;:   add    esp,0x10\n   0x5655585b &lt;+226&gt;:   sub    esp,0x8\n   0x5655585e &lt;+229&gt;:   lea    eax,[ebx-0x154d]\n   0x56555864 &lt;+235&gt;:   push   eax\n   0x56555865 &lt;+236&gt;:   lea    eax,[ebp-0x3b]\n   0x56555868 &lt;+239&gt;:   push   eax\n   0x56555869 &lt;+240&gt;:   call   0x56555510 &lt;strcmp@plt&gt;\n   0x5655586e &lt;+245&gt;:   add    esp,0x10\n   0x56555871 &lt;+248&gt;:   test   eax,eax\n   0x56555873 &lt;+250&gt;:   je     0x56555891 &lt;main+280&gt;\n   0x56555875 &lt;+252&gt;:   sub    esp,0xc\n   0x56555878 &lt;+255&gt;:   lea    eax,[ebx-0x1584]\n   0x5655587e &lt;+261&gt;:   push   eax\n   0x5655587f &lt;+262&gt;:   call   0x56555550 &lt;puts@plt&gt;\n   0x56555884 &lt;+267&gt;:   add    esp,0x10\n   0x56555887 &lt;+270&gt;:   sub    esp,0xc\n   0x5655588a &lt;+273&gt;:   push   0x0\n   0x5655588c &lt;+275&gt;:   call   0x56555560 &lt;exit@plt&gt;\n   0x56555891 &lt;+280&gt;:   sub    esp,0xc\n   0x56555894 &lt;+283&gt;:   lea    eax,[ebx-0x1534]\n   0x5655589a &lt;+289&gt;:   push   eax\n   0x5655589b &lt;+290&gt;:   call   0x56555550 &lt;puts@plt&gt;\n   0x565558a0 &lt;+295&gt;:   add    esp,0x10\n   0x565558a3 &lt;+298&gt;:   sub    esp,0xc\n   0x565558a6 &lt;+301&gt;:   lea    eax,[ebp-0x3b]\n   0x565558a9 &lt;+304&gt;:   push   eax\n   0x565558aa &lt;+305&gt;:   call   0x56555520 &lt;gets@plt&gt;\n   0x565558af &lt;+310&gt;:   add    esp,0x10\n   0x565558b2 &lt;+313&gt;:   cmp    DWORD PTR [ebp-0x10],0xdea110c8\n   0x565558b9 &lt;+320&gt;:   jne    0x565558c2 &lt;main+329&gt;\n   0x565558bb &lt;+322&gt;:   call   0x565556fd &lt;print_flag&gt;\n   0x565558c0 &lt;+327&gt;:   jmp    0x565558d4 &lt;main+347&gt;\n   0x565558c2 &lt;+329&gt;:   sub    esp,0xc\n   0x565558c5 &lt;+332&gt;:   lea    eax,[ebx-0x1584]\n   0x565558cb &lt;+338&gt;:   push   eax\n   0x565558cc &lt;+339&gt;:   call   0x56555550 &lt;puts@plt&gt;\n   0x565558d1 &lt;+344&gt;:   add    esp,0x10\n   0x565558d4 &lt;+347&gt;:   mov    eax,0x0\n   0x565558d9 &lt;+352&gt;:   lea    esp,[ebp-0x8]\n   0x565558dc &lt;+355&gt;:   pop    ecx\n   0x565558dd &lt;+356&gt;:   pop    ebx\n   0x565558de &lt;+357&gt;:   pop    ebp\n   0x565558df &lt;+358&gt;:   lea    esp,[ecx-0x4]\n   0x565558e2 &lt;+361&gt;:   ret    \nEnd of assembler dump.\n</code></pre>\n<p>Ghidra decompiler shows me this:</p>\n<pre><code>{\n  int iVar1;\n  char user_buf [43];\n  int overwrite_me;\n  undefined4 local_14;\n  undefined *local_10;\n  \n  local_10 = &amp;stack0x00000004;\n  setvbuf(stdout,(char *)0x2,0,0);\n  local_14 = 2;\n  overwrite_me = 0;\n  puts(\n        \"Stop! Who would cross the Bridge of Death must answer me these questions three, ere the other  side he see.\"\n        );\n  puts(\"What... is your name?\");\n  fgets(user_buf,0x2b,stdin);\n  iVar1 = strcmp(user_buf,\"Sir Lancelot of Camelot\\n\");\n  if (iVar1 != 0) {\n     puts(\"I don\\'t know that! Auuuuuuuugh!\");\n                            /* WARNING: Subroutine does not return */\n     exit(0);\n  }\n  puts(\"What... is your quest?\");\n  fgets(user_buf,0x2b,stdin);\n  iVar1 = strcmp(user_buf,\"To seek the Holy Grail.\\n\");\n  if (iVar1 != 0) {\n     puts(\"I don\\'t know that! Auuuuuuuugh!\");\n                            /* WARNING: Subroutine does not return */\n     exit(0);\n  }\n  puts(\"What... is my secret?\");\n  gets(user_buf);\n  if (overwrite_me == -0x215eef38) {\n     print_flag();\n  }\n  else {\n     puts(\"I don\\'t know that! Auuuuuuuugh!\");\n  }\n  return 0;\n}\n</code></pre>\n<p>Ok, some of those vars I obviously named, but the decompiler knows that there's an int, followed by a 43-byte char buffer, followed by an int up at the top of the function. How do decompilers and disassemblers learn this info? By looking at the disassembly in <code>gdb</code>, I do not know that the buffer is 43 bytes for example because there is a single <code>sub esp, 0x40</code> instruction, which overs all of that in one motion. However, I can infer the size based on these instructions:</p>\n<pre><code>   0x565557eb &lt;+114&gt;:   push   0x2b\n   0x565557ed &lt;+116&gt;:   lea    eax,[ebp-0x3b]\n</code></pre>\n<p>However, in some situations, it may not be that obvious.</p>\n<p>NOTE: I am not trying to solve this challenge, I've already solved it - this is a curiosity/educational question.</p>\n</div>",
    "votes": "3",
    "answers": 0,
    "views": "103",
    "tags": [
        "ida",
        "disassembly",
        "ghidra",
        "decompiler"
    ],
    "user": "the_endian",
    "time": "Nov 4, 2022 at 22:07",
    "comments": [
        {
            "user": "the_endian",
            "text": "<span class=\"comment-copy\">Thanks. I seem to be a master of \"big questions\", thats why I reverse. :)</span>",
            "time": null
        }
    ],
    "answers_data": []
}