{
    "title": "How to improve Ghidra decompilation of SSE instructions?",
    "link": "https://reverseengineering.stackexchange.com/questions/24974/how-to-improve-ghidra-decompilation-of-sse-instructions",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>In practicing Ghidra on a few standard library functions in some executable, I have generally had trouble getting good decompilation output where SSE registers are used as an optimization. I've tried searching for a variety of keyword combinations both here and on the rest of the internet but could not find anything relevant.</p>\n<p><em>The below examples are from x64 code without debug symbols, so function/struct/variable names are my doing. The type choices did not change/improve the demonstrated issues - but maybe I'm just doing it wrong. I also tried to keep enough context for readability, but I couldn't locate any guidelines this site has in that regard.</em></p>\n<ol>\n<li><p>When a 32 byte <code>std::string</code> is copied (as part of what looks like move construction) using two 128 bit SSE moves, the entire thing is decomposed into 4 byte chunks:</p>\n<p>My <code>std::string</code> data type definition for completeness (exported):</p>\n<pre><code>struct std_string {\n  char * data;\n  char * field_1;\n  ulonglong size;\n  ulonglong capacity;\n};\n</code></pre>\n<p>Disassembly:</p>\n<pre><code>                         **************************************************************\n                         *                          FUNCTION                          *\n                         **************************************************************\n                         std_string * __fastcall std_string_operator+(std_string \n         std_string *      RAX:8          &lt;RETURN&gt;\n         std_string *      RCX:8          thisOut\n         undefined8        RDX:8          thisIn\n         char *            R8:8           stringIn                                XREF[1]:     140106dcc(W)  \n         longlong          R8:8           size                                    XREF[1]:     140106dcc(W)  \n         undefined8        RAX:8          thisIn_                                 XREF[1]:     140106de6(W)  \n                         std_string_operator+\n   140106dc0 40 53           PUSH       RBX\n   140106dc2 48 83 ec 20     SUB        RSP,0x20\n   140106dc6 49 8b c0        MOV        RAX,stringIn\n   140106dc9 4c 8b ca        MOV        R9,thisIn\n   140106dcc 49 c7 c0        MOV        size,-0x1\n             ff ff ff ff\n   140106dd3 48 8b d9        MOV        RBX,thisOut\n                         LAB_140106dd6                                   XREF[1]:     140106dde(j)  \n   140106dd6 49 ff c0        INC        size\n   140106dd9 42 80 3c        CMP        byte ptr [RAX + size*0x1],0x0\n             00 00\n   140106dde 75 f6           JNZ        LAB_140106dd6\n   140106de0 48 8b d0        MOV        thisIn,RAX\n   140106de3 49 8b c9        MOV        thisOut,R9\n   140106de6 e8 75 fe        CALL       std_string_append                                std_string * std_string_append(s\n             ff ff\n   140106deb 33 c9           XOR        thisOut,thisOut\n   140106ded 48 89 4b 10     MOV        qword ptr [RBX + 0x10],thisOut\n   140106df1 48 89 4b 18     MOV        qword ptr [RBX + 0x18],thisOut\n   140106df5 0f 10 00        MOVUPS     XMM0,xmmword ptr [thisIn_]\n   140106df8 0f 11 03        MOVUPS     xmmword ptr [RBX],XMM0\n   140106dfb 0f 10 48 10     MOVUPS     XMM1,xmmword ptr [thisIn_ + 0x10]\n   140106dff 0f 11 4b 10     MOVUPS     xmmword ptr [RBX + 0x10],XMM1\n   140106e03 48 89 48 10     MOV        qword ptr [thisIn_ + 0x10],thisOut\n   140106e07 48 c7 40        MOV        qword ptr [thisIn_ + 0x18],0xf\n             18 0f 00 \n             00 00\n   140106e0f 88 08           MOV        byte ptr [thisIn_],thisOut\n   140106e11 48 8b c3        MOV        thisIn_,RBX\n   140106e14 48 83 c4 20     ADD        RSP,0x20\n   140106e18 5b              POP        RBX\n   140106e19 c3              RET\n</code></pre>\n<p>Decompilation:</p>\n<pre><code>std_string * std_string_operator+(std_string *thisOut,std_string *thisIn,char *stringIn)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  std_string *thisIn_;\n  longlong size;\n\n  size = -1;\n  do {\n    size = size + 1;\n  } while (stringIn[size] != '\\0');\n  thisIn_ = std_string_append(thisIn,stringIn,size);\n  thisOut-&gt;size = 0;\n  thisOut-&gt;capacity = 0;\n  uVar1 = *(undefined4 *)((longlong)&amp;thisIn_-&gt;data + 4);\n  uVar2 = *(undefined4 *)&amp;thisIn_-&gt;field_1;\n  uVar3 = *(undefined4 *)((longlong)&amp;thisIn_-&gt;field_1 + 4);\n  *(undefined4 *)&amp;thisOut-&gt;data = *(undefined4 *)&amp;thisIn_-&gt;data;\n  *(undefined4 *)((longlong)&amp;thisOut-&gt;data + 4) = uVar1;\n  *(undefined4 *)&amp;thisOut-&gt;field_1 = uVar2;\n  *(undefined4 *)((longlong)&amp;thisOut-&gt;field_1 + 4) = uVar3;\n  uVar1 = *(undefined4 *)((longlong)&amp;thisIn_-&gt;size + 4);\n  uVar2 = *(undefined4 *)&amp;thisIn_-&gt;capacity;\n  uVar3 = *(undefined4 *)((longlong)&amp;thisIn_-&gt;capacity + 4);\n  *(undefined4 *)&amp;thisOut-&gt;size = *(undefined4 *)&amp;thisIn_-&gt;size;\n  *(undefined4 *)((longlong)&amp;thisOut-&gt;size + 4) = uVar1;\n  *(undefined4 *)&amp;thisOut-&gt;capacity = uVar2;\n  *(undefined4 *)((longlong)&amp;thisOut-&gt;capacity + 4) = uVar3;\n  thisIn_-&gt;size = 0;\n  thisIn_-&gt;capacity = 0xf;\n  *(undefined *)&amp;thisIn_-&gt;data = 0;\n  return thisOut;\n}\n</code></pre>\n<p>I would understand copying the four fields of eight bytes, or (in some form or another) expressing two 128 or one 256 bit copy. I assume the above four byte chunks is how MOVUPS is encoded in Ghidra, but it doesn't seem very helpful to me at all. This kind of copy (via SSE) happens relatively often everywhere, so having 16 lines of noise every time is annoying.</p>\n<p>(Also, don't ask me about the funky function signature, I have no idea what the compiler was on about.)</p></li>\n</ol>\n<hr/>\n<ol start=\"2\">\n<li><p>A <code>PUNPCKLBW</code> used in memset (which here just fills <code>XMM0</code> by repeating each of the lower 8 bytes, effectively broadcasting the single byte to set to all 16 bytes of <code>XMM0</code>) blows up into dozens of lines of gibberish (which faithfully emulates the effect, I'm sure, but it's not helpful):</p>\n<p>Disassembly:</p>\n<pre><code>                     **************************************************************\n                     *                          FUNCTION                          *\n                     **************************************************************\n                     longlong * __fastcall memset(void * location, byte byteT\n     longlong *        RAX:8          &lt;RETURN&gt;\n     void *            RCX:8          location\n     byte              DL:1           byteToSet                               XREF[1]:     1411960a8(W)  \n     ulonglong         R8:8           count\n     undefined8        R9:8           inputByteRepeated8                      XREF[1]:     1411960a0(W)  \n     undefined2        DX:2           inputByteRepeated2                      XREF[1]:     1411960a8(W)  \n                     memset                                          XREF[518]:  [...]\n 141196090 4c 8b d9        MOV        R11,location\n 141196093 0f b6 d2        MOVZX      EDX,DL\n 141196096 49 b9 01        MOV        R9,0x101010101010101\n           01 01 01 \n           01 01 01 01\n 1411960a0 4c 0f af ca     IMUL       R9,RDX\n 1411960a4 49 83 f8 10     CMP        R8,0x10\n 1411960a8 0f 86 f2        JBE        LAB_1411961a0\n           00 00 00\n 1411960ae 66 49 0f        MOVQ       XMM0,R9\n           6e c1\n 1411960b3 66 0f 60 c0     PUNPCKLBW  XMM0,XMM0\n                      [...]\n</code></pre>\n<p>Decompilation:</p>\n<pre><code>longlong * memset(void *location,byte byteToSet,ulonglong count)\n{\n  // [...]\n  ushort inputByteRepeated2;\n  ulonglong inputByteRepeated8;\n  undefined4 uVar5;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  undefined auVar6 [13];\n\n  inputByteRepeated8 = (ulonglong)byteToSet * 0x101010101010101;\n  inputByteRepeated2 = (ushort)inputByteRepeated8;\n  _inputByteRepeated2 = (uint)inputByteRepeated8;\n  if (count &lt; 0x11) {\n    // [...]\n  }\n  auVar6[6] = SUB141(ZEXT814(inputByteRepeated8) &gt;&gt; 0x30,0);\n  auVar6 = ZEXT813(inputByteRepeated8);\n  register0x0000120c =\n       SUB164(CONCAT313(SUB163(CONCAT214(SUB162(CONCAT115(SUB161(ZEXT816(inputByteRepeated8) &gt;&gt; 0x38\n                                                                 ,0),\n                                                          CONCAT114(SUB151(ZEXT815(\n                                                  inputByteRepeated8) &gt;&gt; 0x38,0),\n                                                  ZEXT814(inputByteRepeated8))) &gt;&gt; 0x70,0),\n                                         CONCAT113(auVar6[6],auVar6)) &gt;&gt; 0x68,0),\n                        CONCAT112(auVar6[6],ZEXT812(inputByteRepeated8))) &gt;&gt; 0x60,0);\n  _auVar6 = CONCAT79(SUB167(CONCAT610(SUB166(CONCAT511(SUB165(CONCAT412(register0x0000120c,\n                                                                        CONCAT111(SUB131(auVar6 &gt;&gt; \n                                                  0x28,0),ZEXT811(inputByteRepeated8))) &gt;&gt; 0x58,0),\n                                                  CONCAT110(SUB121(ZEXT812(inputByteRepeated8) &gt;&gt;\n                                                                   0x28,0),\n                                                            (unkuint10)inputByteRepeated8)) &gt;&gt; 0x50,\n                                             0),\n                                      CONCAT19(SUB131(auVar6 &gt;&gt; 0x20,0),(unkuint9)inputByteRepeated8\n                                              )) &gt;&gt; 0x48,0),\n                     (unkuint9)inputByteRepeated8 &amp; 0xffffffffffffffff | 0 &lt;&lt; 0x40);\n  register0x00001208 = SUB168(_auVar6 &gt;&gt; 0x40,0);\n  _auVar6 = CONCAT115(SUB1611(CONCAT106(SUB1610(CONCAT97(SUB169(CONCAT88(register0x00001208,\n                                                                         (inputByteRepeated8 &gt;&gt; 0x18\n                                                                         ) &lt;&lt; 0x38) &gt;&gt; 0x38,0),\n                                                         ((uint7)inputByteRepeated8 &gt;&gt; 0x18) &lt;&lt; 0x30\n                                                        ) &gt;&gt; 0x30,0),\n                                        ((uint6)inputByteRepeated8 &gt;&gt; 0x10) &lt;&lt; 0x28) &gt;&gt; 0x28,0),\n                      ((uint5)inputByteRepeated8 &gt;&gt; 0x10) &lt;&lt; 0x20);\n  _auVar6 = CONCAT142(SUB1614(CONCAT133(SUB1613(CONCAT124(SUB1612(_auVar6 &gt;&gt; 0x20,0),\n                                                          (_inputByteRepeated2 &gt;&gt; 8) &lt;&lt; 0x18) &gt;&gt;\n                                                0x18,0),((uint3)inputByteRepeated8 &gt;&gt; 8) &lt;&lt; 0x10) &gt;&gt;\n                              0x10,0),inputByteRepeated2 &amp; 0xff | inputByteRepeated2 &lt;&lt; 8);\n  uVar7 = SUB164(_auVar6 &gt;&gt; 0x20,0);\n  uVar5 = SUB164(_auVar6,0);\n  uVar8 = SUB164(_auVar6 &gt;&gt; 0x40,0);\n\n  // [...]\n</code></pre>\n<p>The remaining decompilation then also uses these awkward separate 4-byte chunks whenever the code just does a <code>MOVAPS     xmmword ptr [location],XMM0</code> or similar. Took me a while to even recognize this entire function as <code>memcpy</code> as a result!</p></li>\n</ol>\n<hr/>\n<p><strong>How can I make the decompiled code more readable in these cases (or avoid the clutter in the first place)?</strong></p>\n<hr/>\n<p><sup>I'd tag this question with <code>SSE</code> if it already existed as a tag, but I'm reluctant to create it since I don't know this community well enough yet. And of course: Improvement suggestions welcome!</sup></p>\n</div>",
    "votes": "5",
    "answers": 1,
    "views": "3k",
    "tags": [
        "decompilation",
        "ghidra"
    ],
    "user": "NurTuring",
    "time": "May 11, 2020 at 0:10",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>One approach to deal with this would be Function Identification feature to automatically detect those functions and just rename them to <code>memcpy</code> accordingly. The issue is that, unlike IDA, Ghidra doesn't ship with a rich library of signatures, though unlike IDA it at least seems feasible to generate your own[0]</p>\n<p>You could look into <a href=\"https://blog.threatrack.de/2019/09/20/ghidra-fid-generator\" rel=\"nofollow noreferrer\">https://blog.threatrack.de/2019/09/20/ghidra-fid-generator</a> and the related github repos with the code that generate the signatures and the already generated signatures and see if those work for your case.</p>\n<p>[0] At least I personally never managed to figure out how this works with IDA</p>\n</div>",
            "votes": "1",
            "user": "Florian Magin",
            "time": "May 11, 2020 at 14:53",
            "is_accepted": false,
            "comments": [
                {
                    "user": "NurTuring",
                    "text": "<span class=\"comment-copy\">I appreciate the suggestion for improving my workflow - indeed, I was wondering how many times I'll have to reverse standard library functions in the future. I'm much more curious how to improve the actual decompilation results though. E.g. the string moving noise is really distracting when trying to figure out what some larger function does, is there something to be done about that?</span>",
                    "time": null
                },
                {
                    "user": "Florian Magin",
                    "text": "<span class=\"comment-copy\">Do you mean cases of an explicit <code>memcpy</code> being inlined or C++ initialization shenanigans? For the former there is some feature to declare part of a function as another function that has been inlined (can't quite remember how, might be worth a separate question). For the latter you might need separate scripts or plugins. In that case, could you edit your question with an example of the decompiled code vs the code you would imagine as an ideal result (optionally vs the actual source) ?</span>",
                    "time": null
                }
            ]
        }
    ]
}