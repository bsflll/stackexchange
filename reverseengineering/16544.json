{
    "title": "Detecting hardware breakpoints",
    "link": "https://reverseengineering.stackexchange.com/questions/16544/detecting-hardware-breakpoints",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Since <em>software breakpoints</em>, unlike <em>hardware breakpoints</em> , do change the code, it's relatively easy to write a program that performs a checksum on itself as an anti-debugger technique. Is it possible to do something similar with hardware breakpoints?</p>\n</div>",
    "votes": "8",
    "answers": 1,
    "views": "7k",
    "tags": [
        "anti-debugging",
        "breakpoint"
    ],
    "user": "Trey",
    "time": "Oct 14, 2017 at 2:31",
    "comments": [
        {
            "user": "blabb",
            "text": "<span class=\"comment-copy\">yes you can get the context and check /modify/  nullify the debug registers dr7 dr6 etc</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This is a really good question since this topic isn't as popular as anti-debugging techniques to detect software breakpoints. Since you didn't mention the architecture we have to keep in mind that Hardware Breakpoints, as its name hints, are depends on the hardware you're running on and thus the implementation of such breakpoints is differ between each architecture. Since we can't cover in this answer all the architectures, I'll write here in an assumption that we're talking about <a href=\"https://en.wikipedia.org/wiki/X86\" rel=\"noreferrer\">Intel's x86 architecture</a> on Windows.  </p>\n<p>In short, the answer is <strong>yes</strong>. There are basically two common ways to detect hardware breakpoints:</p>\n<ol>\n<li>Using thread's context to access Debug Registers</li>\n<li>Crafting a <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms680657(v=vs.85).aspx\" rel=\"noreferrer\">SEH</a> (Structured Exception Handling), then to cause an exception and access the debug registers  </li>\n</ol>\n<p>In order to understand each method we should understand first what Hardware Breakpoint is and (in short) how it works.  </p>\n<h2>Hardware Breakpoint</h2>\n<p>In <em>x86</em> architecture the debugger uses a set of Debug Registers in order to apply hardware breakpoints. There are 8 debug registers exists to control the debugging procedure, ranging from <em>DR0</em> to <em>DR7</em>. These registers are not accessible from <em>ring3</em> <a href=\"https://en.wikipedia.org/wiki/Protection_ring\" rel=\"noreferrer\">privileges</a> but only accessible from CPL0 (<em>Current Privilege Levels</em>, ring0). Thus, an attempt to read or write the debug registers when executing at any other privilege level causes a general protection fault. The debug registers allow the debugger to interrupt program execution and transfer the control to it when accessing memory to read or write. </p>\n<p><strong>x86 Debug Registers</strong></p>\n<ul>\n<li>DR0 - Linear breakpoint address 0</li>\n<li>DR1 - Linear breakpoint address 1</li>\n<li>DR2 - Linear breakpoint address 2</li>\n<li><p>DR3 - Linear breakpoint address 3</p></li>\n<li><p>DR4 - Reserved. Not defined by Intel</p></li>\n<li><p>DR5 - Reserved. Not defined by Intel</p></li>\n<li><p>DR6 - Breakpoint Status</p></li>\n<li>DR7 - Breakpoint control</li>\n</ul>\n<p>DR0-DR3 store a linear address of a breakpoint. The stored address can be the same as the physical address or it needs to be translated to the physical address. <em>DR6</em> indicates which breakpoint is activated. <em>DR7</em> defines the breakpoint activation mode by the access modes: <em>read</em>, <em>write</em>, or <em>execute</em>.</p>\n<h2>Detecting Hardware Breakpoints</h2>\n<p><strong>Method one - ThreadContext Win API</strong> </p>\n<p>The following example is based on an example from <a href=\"https://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide\" rel=\"noreferrer\">this</a> article from CodeProject. The example is commented to describe each piece of code:</p>\n<pre><code>bool IsHWBreakpointExists()\n{\n    // This structure is key to the function and is the \n    CONTEXT ctx;\n    ZeroMemory(&amp;ctx, sizeof(CONTEXT));\n\n    // The CONTEXT structure is an in/out parameter therefore we have\n    // to set the flags so Get/SetThreadContext knows what to set or get.   \n    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;\n\n    // Get a handle to our thread\n    HANDLE hThread = GetCurrentThread();\n    // Get the registers\n    if(GetThreadContext(hThread, &amp;ctx) == 0)\n        return false;   \n\n    if ((ctx.Dr0) || (ctx.Dr1) || (ctx.Dr2) || (ctx.Dr3)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n} \n</code></pre>\n<p><strong>Method 2 - SEH</strong><br/>\nThe SEH method of manipulating the debug registers is much more common and is easier to implement it in Assembly, as shown in the following example, again from CodeProject:</p>\n<pre><code>ClrHwBpHandler proto\n .safeseh ClrHwBpHandler\n\nClearHardwareBreakpoints proc\n     assume fs:nothing\n     push offset ClrHwBpHandler\n    push fs:[0]\n    mov dword ptr fs:[0], esp ; Setup SEH\n     xor eax, eax\n     div eax ; Cause an exception\n     pop dword ptr fs:[0] ; Execution continues here\n     add esp, 4\n     ret\nClearHardwareBreakpoints endp\n\nClrHwBpHandler proc \n     xor eax, eax\n    mov ecx, [esp + 0ch] ; This is a CONTEXT structure on the stack\n     mov dword ptr [ecx + 04h], eax ; Dr0\n     mov dword ptr [ecx + 08h], eax ; Dr1\n     mov dword ptr [ecx + 0ch], eax ; Dr2\n     mov dword ptr [ecx + 10h], eax ; Dr3\n     mov dword ptr [ecx + 14h], eax ; Dr6\n     mov dword ptr [ecx + 18h], eax ; Dr7\n     add dword ptr [ecx + 0b8h], 2 ; We add 2 to EIP to skip the div eax\n     ret\nClrHwBpHandler endp\n</code></pre>\n<h2>References:</h2>\n<ul>\n<li><a href=\"https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-system-programming-manual-325384.html\" rel=\"noreferrer\">IntelÂ® 64 and IA-32 Architectures Software Developer Manual: Vol 3</a></li>\n<li><a href=\"https://rads.stackoverflow.com/amzn/click/0387098240\" rel=\"noreferrer\">Identifying Malicious Code Through Reverse Engineering</a> </li>\n<li><a href=\"https://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide\" rel=\"noreferrer\">An Anti-Reverse Engineering Guide</a></li>\n<li><a href=\"https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software\" rel=\"noreferrer\">Anti Debugging Protection Techniques</a></li>\n</ul>\n</div>",
            "votes": "10",
            "user": "Megabeets",
            "time": "Oct 14, 2017 at 18:55",
            "is_accepted": true,
            "comments": []
        }
    ]
}