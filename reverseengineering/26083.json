{
    "title": "How to find the address (offset) of specific driver function",
    "link": "https://reverseengineering.stackexchange.com/questions/26083/how-to-find-the-address-offset-of-specific-driver-function",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am reversing Capcom driver and in IDA I have this list of functions:<br/>\n<a href=\"https://i.sstatic.net/B4wJ2.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/B4wJ2.png\"/></a></p>\n<p>I want to set breakpoint on the function <code>sub_10590</code> but I don't know what is the address of this function when I am doing <strong>live debugging</strong>.</p>\n<p>I set a breakpoint on the userland program before it calls <code>DeviceIoControl</code> and checked the driver object in WinDBG:</p>\n<pre><code>kd&gt; dt _DRIVER_OBJECT ffffe78a4b355810\nnt!_DRIVER_OBJECT\n   +0x000 Type             : 0n4\n   +0x002 Size             : 0n336\n   +0x008 DeviceObject     : 0xffffe78a`4be95850 _DEVICE_OBJECT\n   +0x010 Flags            : 0x12\n   +0x018 DriverStart      : 0xfffff80b`f90b0000 Void\n   +0x020 DriverSize       : 0xc00\n   +0x028 DriverSection    : 0xffffe78a`4d452e80 Void\n   +0x030 DriverExtension  : 0xffffe78a`4b355960 _DRIVER_EXTENSION\n   +0x038 DriverName       : _UNICODE_STRING \"\\Driver\\cfs\"\n   +0x048 HardwareDatabase : 0xfffff800`5a5ae8f8 _UNICODE_STRING \"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\"\n   +0x050 FastIoDispatch   : (null) \n   +0x058 DriverInit       : 0xfffff80b`f90b063c     long  +0\n   +0x060 DriverStartIo    : (null) \n   +0x068 DriverUnload     : 0xfffff80b`f90b047c     void  +0\n   +0x070 MajorFunction    : [28] 0xfffff80b`f90b04e4     long  +0\n</code></pre>\n<p>How can I find the address of this function? or its offset <code>cfs+&lt;what_is_the_offset&gt;</code>...</p>\n</div>",
    "votes": "2",
    "answers": 3,
    "views": "2k",
    "tags": [
        "windows",
        "debugging",
        "kernel"
    ],
    "user": "E235",
    "time": "Oct 8, 2020 at 7:57",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>A friend show me how to do it with IDA Python:</p>\n<pre><code>from idaapi import *\nhere() -get_imagebase()\n</code></pre>\n<p>And in WinDBG:</p>\n<pre><code>kd&gt; db cfs+0x590\nfffff80b`f90b0590  48 53 56 57 48 83 ec 20-48 8b 82 b8 00 00 00 48  HSVWH.. H......H\nfffff80b`f90b05a0  8b 7a 18 33 c9 89 4a 30-48 89 4a 38 80 38 0e 44  .z.3..J0H.J8.8.D\nfffff80b`f90b05b0  8b 48 10 44 8b 40 08 48-8b da 8b 50 18 74 09 c7  <a class=\"__cf_email__\" data-cfemail=\"99b7d1b7ddb7d9b7d1b7b7b7c9b7ed\" href=\"/cdn-cgi/l/email-protection\">[emailÂ protected]</a>..\nfffff80b`f90b05c0  43 30 02 00 00 c0 eb 5e-41 bb 44 20 01 aa 8b c1  C0.....^A.D ....\nfffff80b`f90b05d0  8b f1 41 3b d3 41 ba 44-30 01 aa 74 0f 41 3b d2  ..A;.A.D0..t.A;.\nfffff80b`f90b05e0  75 11 b8 08 00 00 00 8d-70 fc eb 07 be 04 00 00  u.......p.......\nfffff80b`f90b05f0  00 8b c6 44 3b c8 75 27-44 3b c6 75 22 41 3b d3  ...D;.u'D;.u\"A;.\nfffff80b`f90b0600  74 0a 41 3b d2 75 0e 48-8b 0f eb 02 8b 0f e8 11  t.A;.u.H........\n</code></pre>\n<p>Or you can just set the address <code>fffff80b`f90b0590</code> in the disassembly window.</p>\n</div>",
            "votes": "1",
            "user": "E235",
            "time": "Oct 8, 2020 at 8:02",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Your DriverEntry isGiven In Your dt output</p>\n<pre><code>+0x058 DriverInit       : 0xfffff80b`f90b063c     long  +0\n</code></pre>\n<p>The Load is Address is Available in the same output</p>\n<pre><code>+0x018 DriverStart      : 0xfffff80b`f90b0000 Void\n</code></pre>\n<p>given these 2 the RVA to Driver Entry is 0x63c</p>\n<p>find out what the Address Of Driver Entry is in IDA (most probably it will be 0x1063c )</p>\n<p>subtract 10590 from 1063c   == 0xac\nset a breakpoint in windbg using</p>\n<pre><code>bp  cfs!DriverEntry-0xAC  \n</code></pre>\n<p>which is same as what you answered</p>\n<pre><code>FFFFF80BF90B0590\n</code></pre>\n<p>disassembly usingradare2</p>\n<pre><code>[0x0001063c]&gt; s $$-0xac\n[0x00010590]&gt; af $$\n[0x00010590]&gt; pdf $$\n            ;-- fcn.00010590:\n            ;-- fcn.:\n/ (fcn) fcn.$$ 172\n|   fcn.$$ (int arg3, int arg4);\n|           ; arg int arg3 @ rdx\n|           ; arg int arg4 @ rcx\n|           ; DATA XREF from entry0 (0x10735)\n|           0x00010590      4853           push rbx\n|           0x00010592      56             push rsi\n|           0x00010593      57             push rdi\n|           0x00010594      4883ec20       sub rsp, 0x20\n|           0x00010598      488b82b80000.  mov rax, qword [rdx + 0xb8] ; [0xb8:8]=-1 ; 184 ; arg3\n|           0x0001059f      488b7a18       mov rdi, qword [rdx + 0x18] ; [0x18:8]=-1 ; 24 ; arg3\n|           0x000105a3      33c9           xor ecx, ecx\n|           0x000105a5      894a30         mov dword [rdx + 0x30], ecx ; arg4\n|           0x000105a8      48894a38       mov qword [rdx + 0x38], rcx ; arg4\n|           0x000105ac      80380e         cmp byte [rax], 0xe\n|           0x000105af      448b4810       mov r9d, dword [rax + 0x10] ; [0x10:4]=-1 ; 16\n|           0x000105b3      448b4008       mov r8d, dword [rax + 8]    ; [0x8:4]=-1 ; 8\n|           0x000105b7      488bda         mov rbx, rdx\n|           0x000105ba      8b5018         mov edx, dword [rax + 0x18] ; [0x18:4]=-1 ; 24\n|       ,=&lt; 0x000105bd      7409           je 0x105c8\n|       |   0x000105bf      c74330020000.  mov dword [rbx + 0x30], 0xc0000002 ; [0xc0000002:4]=-1\n|      ,==&lt; 0x000105c6      eb5e           jmp 0x10626\n|      ||   ; CODE XREF from fcn.$$ (0x105bd)\n|      |`-&gt; 0x000105c8      41bb442001aa   mov r11d, 0xaa012044\n|      |    0x000105ce      8bc1           mov eax, ecx                ; arg4\n|      |    0x000105d0      8bf1           mov esi, ecx                ; arg4\n|      |    0x000105d2      413bd3         cmp edx, r11d\n|      |    0x000105d5      41ba443001aa   mov r10d, 0xaa013044\n|      |,=&lt; 0x000105db      740f           je 0x105ec\n|      ||   0x000105dd      413bd2         cmp edx, r10d\n|     ,===&lt; 0x000105e0      7511           jne 0x105f3\n|     |||   0x000105e2      b808000000     mov eax, 8\n|     |||   0x000105e7      8d70fc         lea esi, [rax - 4]\n|    ,====&lt; 0x000105ea      eb07           jmp 0x105f3\n|    ||||   ; CODE XREF from fcn.$$ (0x105db)\n|    |||`-&gt; 0x000105ec      be04000000     mov esi, 4\n|    |||    0x000105f1      8bc6           mov eax, esi\n|    |||    ; CODE XREFS from fcn.$$ (0x105e0, 0x105ea)\n|    ``---&gt; 0x000105f3      443bc8         cmp r9d, eax\n|      |,=&lt; 0x000105f6      7527           jne 0x1061f\n|      ||   0x000105f8      443bc6         cmp r8d, esi\n|     ,===&lt; 0x000105fb      7522           jne 0x1061f\n|     |||   0x000105fd      413bd3         cmp edx, r11d\n|    ,====&lt; 0x00010600      740a           je 0x1060c\n|    ||||   0x00010602      413bd2         cmp edx, r10d\n|   ,=====&lt; 0x00010605      750e           jne 0x10615\n|   |||||   0x00010607      488b0f         mov rcx, qword [rdi]\n|  ,======&lt; 0x0001060a      eb02           jmp 0x1060e\n|  ||||||   ; CODE XREF from fcn.$$ (0x10600)\n|  ||`----&gt; 0x0001060c      8b0f           mov ecx, dword [rdi]\n|  || |||   ; CODE XREF from fcn.$$ (0x1060a)\n|  `------&gt; 0x0001060e      e811ffffff     call fcn.00010524\n|   | |||   0x00010613      8bc8           mov ecx, eax\n|   | |||   ; CODE XREF from fcn.$$ (0x10605)\n|   `-----&gt; 0x00010615      8bc6           mov eax, esi\n|     |||   0x00010617      890f           mov dword [rdi], ecx\n|     |||   0x00010619      48894338       mov qword [rbx + 0x38], rax\n|    ,====&lt; 0x0001061d      eb07           jmp 0x10626\n|    ||||   ; CODE XREFS from fcn.$$ (0x105f6, 0x105fb)\n|    |`-`-&gt; 0x0001061f      c743300d0000.  mov dword [rbx + 0x30], 0xc000000d ; [0xc000000d:4]=-1\n|    | |    ; CODE XREFS from fcn.$$ (0x105c6, 0x1061d)\n|    `-`--&gt; 0x00010626      33d2           xor edx, edx\n|           0x00010628      488bcb         mov rcx, rbx\n|           0x0001062b      ff15dffcffff   call qword sym.imp.ntoskrnl.exe_IofCompleteRequest ; [0x10310:8]=0xb2a reloc.ntoskrnl.exe_IofCompleteRequest ; \"*\\v\"\n|           0x00010631      8b4330         mov eax, dword [rbx + 0x30] ; [0x30:4]=-1 ; '0' ; 48\n|           0x00010634      4883c420       add rsp, 0x20\n|           0x00010638      5f             pop rdi\n|           0x00010639      5e             pop rsi\n|           0x0001063a      5b             pop rbx\n\\           0x0001063b      c3             ret\n[0x00010590]&gt;\n</code></pre>\n</div>",
            "votes": "0",
            "user": "blabb",
            "time": "Oct 8, 2020 at 17:54",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>What I tend to do is the following.</p>\n<ol>\n<li>Subtract the base address of the file you loaded in IDA from the address of the function you want to find, e.g: <code>0x140011011 - 0x140000000 = 0x11011</code>. Now you have the offset.</li>\n<li>In Windbg obtain the base address of the Capcom driver by doing the following: execute this command in windbg and wait a while: <code>!drvobj Capcom</code>. Eventually you'll get something like this:</li>\n</ol>\n<pre><code>Driver object (ffff8c858e479400) is for:\n \\Driver\\Capcom\n\nDriver Extension List: (id , addr)\n\nDevice Object list:\nffff8c858e47a060  \n</code></pre>\n<ol start=\"3\">\n<li>Retrieve the address contained between the first set of parentheses and add 0x18 to this address. The reason for this is that an object of type _DRIVER_OBJECT actually contains the driver base address of the driver it's assigned to, which happens to be located at offset 0x18. (This may vary depending on what version of Windows you're using so always verify this by typing this in Windbg and looking for the field named DriverStart. Command: <code>dt nt!_DRIVER_OBJECT</code>.) So in my case, I'll do: <code>0xFFFF8C858E479400 + 0x18 = 0xFFFF8C858E479418</code>.</li>\n<li>Input the address acquired in step 3 into your Windbg memory view and retrieve the address located at this address, for me this is <code>0xFFFFF80376790000</code>.</li>\n<li>Add the offset we obtained at step 1 to the base address we got at step 4: <code>0xFFFFF80376790000 + 0x11011 = 0xFFFFF803767A1011</code>.</li>\n</ol>\n<p>And there you have it, the function you were looking for is located at <code>0xFFFFF803767A1011</code>. You should be able to look at this function when inserting this address into your disassembly view.</p>\n</div>",
            "votes": "0",
            "user": "Teitoku42",
            "time": "Oct 8, 2020 at 20:14",
            "is_accepted": false,
            "comments": []
        }
    ]
}