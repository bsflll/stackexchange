{
    "title": "How to extract sound file from a small 1MB binary",
    "link": "https://reverseengineering.stackexchange.com/questions/27604/how-to-extract-sound-file-from-a-small-1mb-binary",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have a bluetooth speaker which announces interface events like \"connected\", \"powering off\". I want to silence these announcements. The way I thought of doing this is to get at the sound files that the speaker uses, and replacing/deleting that data.</p>\n<p>I had earlier <a href=\"https://reverseengineering.stackexchange.com/questions/27528/how-do-i-extract-the-firmware-from-this-bluetooth-speaker-board\">asked a question about extracting this data</a> and using the advise received, I've managed to successfully extract the memory of this speaker.</p>\n<p>I'm now trying to analyse the extracted binary and find the sound files. But I haven't been successful.</p>\n<hr/>\n<p>The extracted binary is here:\n<a href=\"https://drive.google.com/file/d/1e9yG8xMkZ331C2TOTOzo9Y93L4abxX9F/view?usp=sharing\" rel=\"nofollow noreferrer\">https://drive.google.com/file/d/1e9yG8xMkZ331C2TOTOzo9Y93L4abxX9F/view?usp=sharing</a></p>\n<p>The chip is <a href=\"https://static.chipdip.ru/lib/050/DOC007050537.pdf\" rel=\"nofollow noreferrer\">XT25F08B</a>. It's a 1 MB memory. I extracted the data over SPI0 and SPI3 interfaces multiple times (using an Arduino that i programmed for this purpose), and <code>diff</code> compared the outputs to ensure that I had the right data.</p>\n<p>Also running <code>strings</code> command on the binary shows a long history of device names that I recognize as various phones / computers I use to connect to the speaker. This adds to my confidence that the extracted data isn't corrupted.</p>\n<hr/>\n<p>Looking at the binary in binvis.io shows:</p>\n<p><a href=\"https://i.sstatic.net/3kepG.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/3kepG.png\"/></a></p>\n<p>There seem to be three chunks separated by unwritten memory.</p>\n<p>According to binwalk(<code>binwalk --disasm data.bin</code>), the middle chunk (43KB starting at offset 991232) is ARM thumb code.</p>\n<pre><code>DECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n991232        0xF2000         ARM executable code, 16-bit (Thumb), little endian, at least 2500 valid instructions\n</code></pre>\n<p>This chunk is actually filled with the device name history. I'm not sure why this would be ARM code, because the processor for the speaker is ATS2815 which is an integrated bluetooth audio processor, and <a href=\"http://www.lanzhi-tech.com/filedownload/99240\" rel=\"nofollow noreferrer\">it's datasheet</a> doesn't seem to indicate any type of relation to ARM architecture, but I'm not sure.</p>\n<p>Binwalk also thinks the last chunk (4KB starting at 1044480 and ending at the final binary address) contains ARM code about half way through.</p>\n<p>The first chunk though is totally opaque to me. See the entropy image (also binvis):</p>\n<p><a href=\"https://i.sstatic.net/fF50J.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/fF50J.png\"/></a></p>\n<p>Clearly the first chunk is either encrypted or compressed.\nThis is just a bluetooth speaker, what would you be protecting by encrypting though? Also the entropy isn't fully random, there are some subtle variations, indicating perhaps it's compressed. But I'm not sure.</p>\n<p>Running <code>binwalk -X data.bin</code> seems to indicate that almost every second byte is a raw deflate compression stream!</p>\n<pre><code>...\n41834         0xA36A          Raw deflate compression stream\n41837         0xA36D          Raw deflate compression stream\n41986         0xA402          Raw deflate compression stream\n42290         0xA532          Raw deflate compression stream\n42291         0xA533          Raw deflate compression stream\n42300         0xA53C          Raw deflate compression stream\n42510         0xA60E          Raw deflate compression stream\n42543         0xA62F          Raw deflate compression stream\n42758         0xA706          Raw deflate compression stream\n42789         0xA725          Raw deflate compression stream\n42920         0xA7A8          Raw deflate compression stream\n42948         0xA7C4          Raw deflate compression stream\n42967         0xA7D7          Raw deflate compression stream\n43867         0xAB5B          Raw deflate compression stream\n44226         0xACC2          Raw deflate compression stream\n...\n</code></pre>\n<p>And this goes on to pretty much till the last address. Does this mean that the whole file is compressed? Surely not, there are raw strings in the binary, so that can't be true.</p>\n<p>So maybe just the first chunk is compressed?\nBut I haven't been able to decompress either. I've tried multiple methods to do so.\ngunzip, unlzma, zlib-flate, unxz on both data.bin and an extracted-first-chunk-only bin.\nBut I end up with either \"File format not recognized\" or \"Invalid header check\" etc. errors.</p>\n<p>I also tried disassembling the middle and last chunks.\n<a href=\"https://onlinedisassembler.com/odaweb/K2AmuJIN\" rel=\"nofollow noreferrer\">https://onlinedisassembler.com/odaweb/K2AmuJIN</a>\n<a href=\"https://onlinedisassembler.com/odaweb/TcU2x8ZR\" rel=\"nofollow noreferrer\">https://onlinedisassembler.com/odaweb/TcU2x8ZR</a></p>\n<p>I chose arm as the architecture just to see, and you can see that the disassembly is peppered with \" instruction: 0x...\". Which likely means it's not the correct architecture and thus not the correct disassembly.</p>\n<hr/>\n<p>Where do I go from here? How do I penetrate the large opaque chunk of the binary. How do I decompress this? How do I disassemble the other chunks assuming they are code that the main processor loads.</p>\n<p>Am I missing something obvious?</p>\n<p><strong>More than anything else though I'd like to get the sound files that the speaker uses.\nI'm certain they are in this binary data here, since there is no other memory chip in the device, and the processor itself doesn't have enough ROM to keep such data.</strong></p>\n</div>",
    "votes": "4",
    "answers": 0,
    "views": "917",
    "tags": [
        "firmware",
        "firmware-analysis",
        "memory-dump",
        "flash"
    ],
    "user": "Capstone",
    "time": "May 4, 2021 at 13:40",
    "comments": [
        {
            "user": "genghiskhan",
            "text": "<span class=\"comment-copy\">One thing you can try is importing the firmware into Audacity as raw data (trying different PCM formats). If the audio exists uncompressed (and lossless), you'll be able to listen to the firmware! Here's a similar question I had a while back <a href=\"https://reverseengineering.stackexchange.com/questions/22435/csr-dfu-file-format\" title=\"csr dfu file format\">reverseengineering.stackexchange.com/questions/22435/â€¦</a></span>",
            "time": null
        },
        {
            "user": "Capstone",
            "text": "<span class=\"comment-copy\">Hah. That got me excited! I went ahead and tried it, no dice unfortunately.</span>",
            "time": null
        },
        {
            "user": "genghiskhan",
            "text": "<span class=\"comment-copy\">Too bad! Good luck on the project</span>",
            "time": null
        }
    ],
    "answers_data": []
}