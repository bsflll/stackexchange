{
    "title": "How does array indexing works at the assembly level?",
    "link": "https://reverseengineering.stackexchange.com/questions/18760/how-does-array-indexing-works-at-the-assembly-level",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Can anyone give me an example to understand how array indexing is working in assembly.</p>\n<p>For example, in C:</p>\n<pre><code>char s[1000]; \n\nfor (int = 0; i &lt; 5; i++)\n{\n  s[i]  = i;\n}\n</code></pre>\n<p>And, in x86 assembly:</p>\n<pre><code>add eax,edx\nmovzx eax, byte ptr [eax]\n</code></pre>\n</div>",
    "votes": "-3",
    "answers": 1,
    "views": "2k",
    "tags": [
        "disassembly",
        "assembly"
    ],
    "user": "ReverserT",
    "time": "Jul 11, 2018 at 16:53",
    "comments": [
        {
            "user": "perror",
            "text": "<span class=\"comment-copy\">For God sake! Learn about the wiki syntax and try to better proof read your question before hitting the \"Send\" button...</span>",
            "time": null
        },
        {
            "user": "Jongware",
            "text": "<span class=\"comment-copy\">First you want to know the <a href=\"https://reverseengineering.stackexchange.com/q/18710/2959\">C version of an array in assembly</a> and now the same in the opposite direction. Tempting to close-vote this as a mirror-duplicate of your earlier question. You accepted an answer ... but did you not understand it? Then you need to work on your assembly knowledge.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>First of all, here is a small example written in C:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define MAX_ROW 5\n#define MAX_COLUMN 10\n\nint main (void)\n{\n  int array[MAX_ROW][MAX_COLUMN];\n\n  for (int row = 0; row &lt; MAX_ROW; ++row)\n    for (int column = 0; column &lt; MAX_COLUMN; ++column)\n      array[row][column] = ((row - 1) * (column + 1)) &amp; ~row ;\n\n  for (int i = 0; i &lt; MAX_ROW; ++i)\n    fprintf (stdout, \"array[%1$d][%1$d] = %2$d\\n\", i, array[i][i]);\n\n  return EXIT_SUCCESS;\n}\n</code></pre>\n<p>I compiled it with:</p>\n<pre><code>$&gt; gcc -Wall -Wextra -std=c11 -Os -o sample sample.c\n</code></pre>\n<p>The resulting (amd64) assembly is as follow:</p>\n<pre><code>0000000000001050 &lt;main&gt;:\n    1050:       41 54                   push   %r12\n    1052:       55                      push   %rbp\n    1053:       83 c8 ff                or     $0xffffffff,%eax\n    1056:       53                      push   %rbx\n    1057:       41 b8 fe ff ff ff       mov    $0xfffffffe,%r8d\n    105d:       48 81 ec d0 00 00 00    sub    $0xd0,%rsp\n    1064:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\n    1069:       49 89 cc                mov    %rcx,%r12\n    106c:       44 89 c7                mov    %r8d,%edi\n    106f:       31 d2                   xor    %edx,%edx\n    1071:       29 c7                   sub    %eax,%edi\n    1073:       89 fe                   mov    %edi,%esi\n    1075:       41 89 f1                mov    %esi,%r9d\n    1078:       01 fe                   add    %edi,%esi\n    107a:       41 21 c1                and    %eax,%r9d\n    107d:       44 89 0c 91             mov    %r9d,(%rcx,%rdx,4)\n    1081:       48 ff c2                inc    %rdx\n    1084:       48 83 fa 0a             cmp    $0xa,%rdx\n    1088:       75 eb                   jne    1075 &lt;main+0x25&gt;\n    108a:       ff c8                   dec    %eax\n    108c:       48 83 c1 28             add    $0x28,%rcx\n    1090:       83 f8 fa                cmp    $0xfffffffa,%eax\n    1093:       75 d7                   jne    106c &lt;main+0x1c&gt;\n    1095:       48 8d 2d 68 0f 00 00    lea    0xf68(%rip),%rbp\n    109c:       31 db                   xor    %ebx,%ebx\n    109e:       48 6b c3 2c             imul   $0x2c,%rbx,%rax\n    10a2:       48 8b 3d 87 2f 00 00    mov    0x2f87(%rip),%rdi\n    10a9:       89 da                   mov    %ebx,%edx\n    10ab:       48 89 ee                mov    %rbp,%rsi\n    10ae:       48 ff c3                inc    %rbx\n    10b1:       41 8b 0c 04             mov    (%r12,%rax,1),%ecx\n    10b5:       31 c0                   xor    %eax,%eax\n    10b7:       e8 74 ff ff ff          callq  1030 &lt;fprintf@plt&gt;\n    10bc:       48 83 fb 05             cmp    $0x5,%rbx\n    10c0:       75 dc                   jne    109e &lt;main+0x4e&gt;\n    10c2:       48 81 c4 d0 00 00 00    add    $0xd0,%rsp\n    10c9:       31 c0                   xor    %eax,%eax\n    10cb:       5b                      pop    %rbx\n    10cc:       5d                      pop    %rbp\n    10cd:       41 5c                   pop    %r12\n    10cf:       c3                      retq   \n</code></pre>\n<p>If we take the time to look precisely at the whole assembly code, we can see that the interesting part is the following:</p>\n<pre><code>1064:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\n1069:       49 89 cc                mov    %rcx,%r12\n106c:       44 89 c7                mov    %r8d,%edi &lt;-----------------\\\n106f:       31 d2                   xor    %edx,%edx                   |\n1071:       29 c7                   sub    %eax,%edi                   |\n1073:       89 fe                   mov    %edi,%esi                   |\n1075:       41 89 f1                mov    %esi,%r9d &lt;-----------\\     |\n1078:       01 fe                   add    %edi,%esi             |     |\n107a:       41 21 c1                and    %eax,%r9d             |     |\n107d:       44 89 0c 91             mov    %r9d,(%rcx,%rdx,4)    |     |\n1081:       48 ff c2                inc    %rdx                  |     |\n1084:       48 83 fa 0a             cmp    $0xa,%rdx             |     |\n1088:       75 eb                   jne    1075 &lt;main+0x25&gt;------/     |\n108a:       ff c8                   dec    %eax                        |\n108c:       48 83 c1 28             add    $0x28,%rcx                  |\n1090:       83 f8 fa                cmp    $0xfffffffa,%eax            |\n1093:       75 d7                   jne    106c &lt;main+0x1c&gt; -----------/\n</code></pre>\n<p>It depict the double loop that initialize the example matrix where <code>rdx</code> is the <code>column</code> variable (it is compared to <code>0xa</code> which is 10 in decimal) and <code>eax</code> is the <code>row</code> variable (it is compared to <code>0xfffffffa</code> which is -6). For some reasons that we will see later, one index is increased and the other one is decreased, but both start from zero.</p>\n<p>Now, the access to the array is located here:</p>\n<pre><code>107d:       44 89 0c 91             mov    %r9d,(%rcx,%rdx,4)\n</code></pre>\n<p>Which would be translated into <code>mov [rcx + 4*rdx], r9d</code> in Intel format. Basically:</p>\n<ul>\n<li><code>rcx</code> is the base address of the current row.</li>\n<li><code>rdx</code> is the column index within the same row vector.</li>\n</ul>\n<p>Note that when we move to the next row, <code>rcx</code> is updated like that:</p>\n<pre><code>108c:       48 83 c1 28             add    $0x28,%rcx\n</code></pre>\n<p>Basically, it moves from the current row to the next one knowing that the row contains 10 items and each item is an <code>int</code> (4 bytes). So, 40 bytes in total which is 0x28 in hexadecimal.</p>\n<p>And, the very first initialization of <code>rcx</code> is given by:</p>\n<pre><code>1064:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\n</code></pre>\n<p>It clearly load the address of the <code>array</code> which is somewhere on the stack.</p>\n<p>Getting all together now!</p>\n<p>So, we have the <code>array</code> on the stack at <code>rsp+0x8</code> which is a contiguous memory area of size:</p>\n<pre><code>5 * 10 * 4 bytes (`rows * columns * sizeof(int)`) = 200 bytes = 0xc8 bytes\n</code></pre>\n<p>And, it is mapped as a sequence of rows of 40 bytes each. Each row gather 10 columns with cells of 4 bytes which can be depicted as follow:</p>\n<pre><code>---------------------------------------------------------------------------------\n ... | array[0][0] | array[0][1] | array[0][2] | array[0][3] | array[0][4] | ...\n---------------------------------------------------------------------------------\n</code></pre>\n<p>Of course, you can find more complex mapping when dealing with multi-dimensional arrays in C, this one is quite simple. Just for completude remember that in total generality the mapping of a multi-dimensional array in C looks usually like that:</p>\n<p><a href=\"https://i.sstatic.net/u3nfL.png\" rel=\"noreferrer\"><img alt=\"Matrix memory mapping in C\" src=\"https://i.sstatic.net/u3nfL.png\"/></a></p>\n<p>And, the structure of the assembly code will follow these constraints (slightly more complex but not so much once you understood the previous simple example).</p>\n</div>",
            "votes": "7",
            "user": "perror",
            "time": "Jul 11, 2018 at 18:48",
            "is_accepted": false,
            "comments": []
        }
    ]
}