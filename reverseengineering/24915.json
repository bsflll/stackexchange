{
    "title": "Some more questions related to C++ exceptions (catchHigh)",
    "link": "https://reverseengineering.stackexchange.com/questions/24915/some-more-questions-related-to-c-exceptions-catchhigh",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I've came up with the most convoluted example but still can't find the purpose of the <code>catchHigh</code> field. I find it that the right handler can be selected simply by looking at the tryblock map from start to end and comparing the ranges of the <code>tryLow</code> and <code>tryHigh</code> fields to the current state.</p>\n<p>I mean I understand that <code>catchHigh</code> is simply the max state that the catch handlers can reach (inclusive?) (from here ehdata.h:140:</p>\n<pre><code>__ehstate_t     catchHigh;          // Highest state index of any associated catch\n</code></pre>\n<p>) but I don't understand when this field can be actually useful.</p>\n<p>However it seems that this value is used by the CRT anyway (vs2019 - frame.cpp:693):</p>\n<pre><code>/////////////////////////////////////////////////////////////////////////////\n//\n// GetRangeOfTrysToCheck - determine which try blocks are of interest, given\n//   the current catch block nesting depth.  We only check the trys at a single\n//   depth.\n//\n// Returns:\n//      Address of first try block of interest is returned\n//      pStart and pEnd get the indices of the range in question\n//\nRENAME_EH_EXTERN(__FrameHandler3)::TryBlockMap::IteratorPair RENAME_EH_EXTERN(__FrameHandler3)::GetRangeOfTrysToCheck(\n    RENAME_EH_EXTERN(__FrameHandler3)::TryBlockMap &amp;TryBlockMap,\n    __ehstate_t                                    curState,\n    DispatcherContext                              * /*pDC*/,\n    FuncInfo                                       * pFuncInfo,\n    int                                            CatchDepth\n) {\n    TryBlockMapEntry *pEntry = FUNC_PTRYBLOCK(*pFuncInfo, 0);\n    unsigned start = FUNC_NTRYBLOCKS(*pFuncInfo);\n    unsigned end = start;\n    unsigned end1 = end;\n\n    while (CatchDepth &gt;= 0) {\n            _VCRT_VERIFY(start != -1);\n            start--;\n            if ( TBME_HIGH(pEntry[start]) &lt; curState &amp;&amp; curState &lt;= TBME_CATCHHIGH(pEntry[start])\n                    || (start == -1)\n            ) {\n                    CatchDepth--;\n                    end = end1;\n                    end1 = start;\n                    }\n            }\n\n    ++start; // We always overshoot by 1 (we may even wrap around)\n    _VCRT_VERIFY(end &lt;= FUNC_NTRYBLOCKS(*pFuncInfo) &amp;&amp; start &lt;= end);\n    auto iterStart = TryBlockMap::iterator(TryBlockMap, start);\n    auto iterEnd = TryBlockMap::iterator(TryBlockMap, end);\n\n    return TryBlockMap::IteratorPair(iterStart, iterEnd);\n}\n</code></pre>\n<p>Btw <code>TBME_HIGH</code> is tryHigh field and <code>TBME_CATCHHIGH</code> is the topic - catchHigh.</p>\n<p>However I can't seem to follow the above code - what I can do however is show you my example:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;Windows.h&gt;\n#include &lt;winnt.h&gt;\n#include &lt;malloc.h&gt;\nextern \"C\" void* _ReturnAddress(void);\nvoid f() {\n    if (!printf(\"\"))\n        throw 9;\n}\n\nstruct test {\n    test();\n    test(const test&amp;);\n    ~test();\n    test f1(int, test);\n    int a, b;\n} f(int, test) throw(int) {\n    test tmp;\n    f();\n    return tmp;\n}\n\nint printfproxy(size_t szbuffer, const char* format, ...)\n{\n    va_list lst;\n    va_start(lst, format);\n    char* tmp = (char*)_alloca(szbuffer);\n    int a = vsprintf(tmp, format, lst);\n    OutputDebugStringA(tmp);\n    return a;\n}\n\ntest test::f1(int, test a) throw(int) {\n    test tmp;\n    return tmp;\n}\n\ntest::test() : a((int)_ReturnAddress()), b(0) {\n    printfproxy(sizeof \"ctor test @ ffffffff\\n\", \"ctor test @ %X\\n\", a);\n}\n\n\ntest::test(const test&amp; arg) : a((int)_ReturnAddress()), b(arg.a)\n{\n    printfproxy(sizeof \"copy ctor test @ ffffffff\\n\", \"copy ctor test @ %X\\n\", a);\n}\n\ntest::~test() {\n    printfproxy(sizeof \"de ctor test @ ffffffff\\n\", \"de ctor test @ %X\\n\", a);\n}\n\nstruct test4 {\n    int a[3];\n} f4(int, struct test4 arg) throw(int) {\n    test4 tmp;\n    return tmp;\n}\n\nvoid main() {\n    test tmp;\n    test4 tmp2;\n    try {\n        test tmp, tmp3;\n        test4 tmp2;\n        try {\n            if (tmp.b == 0)\n#line 93\n                f(9, tmp).f1(9, tmp), f(7, tmp);\n            else\n                f(7, tmp), f(7, tmp), f4(7, tmp2);\n        }\n        catch (int) {\n            try {\n#line 99\n                printfproxy(sizeof \"handler 2147483647\"\"\\n\", \"handler %d\"\"\\n\", __LINE__); test tmphandler; f(7, tmp);\n            }\n            catch (int) {\n#line 102\n                printfproxy(sizeof \"handler 2147483647\"\"\\n\", \"handler %d\"\"\\n\", __LINE__);\n            }\n        }\n#line 106\n        if (tmp.b == 0)\n            f(9, tmp).f1(9, tmp), f(7, tmp);\n        else\n            f(7, tmp), f(7, tmp), f4(7, tmp2);\n    }\n#line 111\n    catch (int) { printfproxy(sizeof \"handler 2147483647\"\"\\n\", \"handler %d\"\"\\n\", __LINE__); }\n}\n</code></pre>\n<p>Here is the tryblockmap generated by the compiler:</p>\n<pre><code>stru_40C9F0     TryBlockMapEntry &lt;11, 12, 13, 1, offset stru_40C9C0&gt; ; offset loc_401554\n                TryBlockMapEntry &lt;4, 9, 13, 1, offset stru_40C9D0&gt; ; offset loc_4014FF\n                TryBlockMapEntry &lt;1, 18, 19, 1, offset stru_40C9E0&gt; ; offset loc_4015FD\n</code></pre>\n<p>And here is the point of first exception inside <code>main</code> function (at line 93):</p>\n<p><a href=\"https://i.sstatic.net/i806L.png\" rel=\"nofollow noreferrer\"><img alt=\"graph1\" src=\"https://i.sstatic.net/i806L.png\"/></a></p>\n<p>We see that at this point the state is 5 (state is represented by var_4 in ida).</p>\n<p><em>Mind the break-point - the actual exception happens at the call to <code>f</code> - few instructions later.</em></p>\n<p>So we look at the smallest range that fits - that is the second trymapentry (offset loc_4014FF). So we execute the handler at line 99:</p>\n<p><a href=\"https://i.sstatic.net/Suupj.png\" rel=\"nofollow noreferrer\"><img alt=\"graph\" src=\"https://i.sstatic.net/Suupj.png\"/></a></p>\n<p>Now there in the initial instructions, more specifically the call to <code>printfproxy</code> the state is still - the tryHigh of the previous step + 1 so 10. Then when we enter the call to <code>f</code> the state becomes 0xC (12). Now at this point when the exception occurs inside <code>f</code> the first trymapentry (offset loc_401554) is executed (line 102) for the same reason as before - it's the smallest range that fits the current state (note that the range is inclusive since:</p>\n<pre><code>typedef const struct _s_TryBlockMapEntry {\n    __ehstate_t     tryLow;             // Lowest state index of try\n    __ehstate_t     tryHigh;            // Highest state index of try\n</code></pre>\n<p>and so the 12 fits here at the end).</p>\n<p>Also funny thing to notice is that the appropriate trymapentry starts at state 11 and so if the exception occurred in the beginning where we established that the state is 10 the outermost handler will be executed (line 111) - however that is impossible since the compiler has determined that <code>printfproxy</code> can't throw.</p>\n<p>Anyway now let's execute another handler further:</p>\n<p><a href=\"https://i.sstatic.net/mRUwQ.png\" rel=\"nofollow noreferrer\"><img alt=\"graph3\" src=\"https://i.sstatic.net/mRUwQ.png\"/></a></p>\n<p>Here we continue execution at line 106 where another exception is about to occur. This time the state is set to 0xE (14). Which means it's time to execute the outermost handler (offset loc_4015FD @line 111)  because it's the only range that fits.</p>\n<p>My point is we never once reached a point where <code>catchHigh</code> was needed. We only used the idea of the smallest possible range that fits current state. My question is - could there be a situation where this field would be actually needed to determine the right handler?</p>\n<p>Note smallest possible range in my mind is if the range is contained in another range - that range. If I had to write an algorithm to find the right handler given state and tryblockmap I would do something like (pseudo-code using range for loop) and never use catchHigh:</p>\n<pre><code>findhandler(\n    state,\n    tryblockmap\n) {\n    int loweststate = INT_MIN, maxstate = INT_MAX;\n    auto handler = nullptr;\n    for (auto a : tryblockmap)\n        if (a.tryLow &lt;= state &amp;&amp; a.tryHigh &gt;= state) //if it fits\n            if (a.tryLow &gt; loweststate || a.tryHigh &lt; maxstate) //if it smaller range then previous handler\n                handler = a, loweststate = a.tryLow, maxstate = a.tryHigh;\n\n    return handler;\n}\n</code></pre>\n<p>Note - I'm using VC++6.0 SP5 PP5 to compile.</p>\n</div>",
    "votes": "0",
    "answers": 0,
    "views": "251",
    "tags": [
        "x86",
        "c++",
        "seh",
        "msvc"
    ],
    "user": "rec",
    "time": "May 4, 2020 at 19:50",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<span class=\"comment-copy\">Maybe try an example with several catches for the same try</span>",
            "time": null
        },
        {
            "user": "rec",
            "text": "<span class=\"comment-copy\">@IgorSkochinsky I tried and the ranges increases after each catch so still no purpose of the <code>catchHIgh</code> field although i understand now how it's used - it's just checked if a state is in the range of any of it's <code>catch</code> handlers and if it's so the handler owning those catches is excluded from the search.</span>",
            "time": null
        }
    ],
    "answers_data": []
}