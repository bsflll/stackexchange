{
    "title": "Reverse Engineer Float and Double Types in C++",
    "link": "https://reverseengineering.stackexchange.com/questions/9108/reverse-engineer-float-and-double-types-in-c",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I would like to get to the code that makes floats and doubles work. The reason why I'm trying is that I need to introduce a new floating point type defined by the military that is not supported natively by Microsoft.</p>\n<p>Has this been done before or is this even possible? If so, is there files that I can retrieve or steps to follow to do it myself?</p>\n</div>",
    "votes": "2",
    "answers": 2,
    "views": "798",
    "tags": [
        "c++",
        "float"
    ],
    "user": "CodeMonkeyV2",
    "time": "Jun 10, 2015 at 16:59",
    "comments": [
        {
            "user": "Yegor",
            "text": "<span class=\"comment-copy\">A software emulation of an FPU should be a good starting point.</span>",
            "time": null
        },
        {
            "user": "Guntram Blohm",
            "text": "<span class=\"comment-copy\">Open Watcom is a compiler that dates back (it wasn't open then) to when Intel CPUs didn't (neccessarily) have FPUs, so it comes with FPU emulation source. However, unless you are comfortable with the mathematical concepts (approximating sqrt with Newton; approximating trig functions with taylor expansions), much of what's happening will seem like magic to you.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<ol>\n<li><p><strong>For starters you can encode/decode the military format to IEEE 754</strong></p>\n<p>this way you can use <strong>FPU</strong> and standard math stuff so at start everything would work. The code would look like this:</p>\n<pre><code>    military fabs(military x) \n     {\n     double _x;\n     _x=military2double(x);\n     _x=fabs(_x);\n     return double2military(_x);\n     }\n</code></pre></li>\n<li><p><strong>convert functions to your format</strong></p>\n<p>so start rewriting math function one by one to handle military format natively</p>\n<pre><code>    military fabs(military x) \n     {\n     if (x&lt;0) x=-x;\n     return x;\n     }\n</code></pre>\n<p>the <code>military</code> should be a class from this point and you need to code the basic operators and functions into it so it handles as common variable  data type. Do not forget to optimize what you can for example <code>fabs</code> can be done by single bitwise <code>AND</code> mask out the mantissa sign bit unless your military format does not use two's complement.</p></li>\n</ol>\n<p>Here is how one of mine floating point number classes look like:</p>\n<pre><code>//---------------------------------------------------------------------------\nconst int _arbnum_max_siz=1&lt;&lt;18;            // mantisa limit [32bit words] 1&lt;&lt;18 = MByte\nconst int _arbnum_min_exp=-0x80000000;      // min exponent limit for base = 2\nconst int _arbnum_max_exp=+0x7FFFFFFD;      // max exponent limit for base = 2\nconst int _arbnum_nan_exp=+0x7FFFFFFE;      // not a number exponent constatn\nconst int _arbnum_inf_exp=+0x7FFFFFFF;      // infinity exponent constatn\n//---------------------------------------------------------------------------\nenum _arbnum_error_enum\n    {\n    _arbnum_error_AllOk=0,\n    _arbnum_error_NotEnoughMemory,          // memory allocation\n    _arbnum_error_CorruptedSignum,          // bad combination of sig,exp,siz,dat\n    _arbnum_error_ZeroSize,                 // unallocated number usage\n    _arbnum_error_UnexpectedCharInFormat,   // str()\n    _arbnum_error_TooBigNumber,             // str() dec num is bigger than expected\n    };\n//---------------------------------------------------------------------------\n\n// |-----|---------------------------|---------------|------|\n// | sig | MSB      mantisa      LSB |   exponent    | bits |\n// |-----|---------------------------|---------------|------|\n// | +1  | 0.(0      ...          0) | 2^0           |   0  | +zero\n// | -1  | 0.(0      ...          0) | 2^0           |   0  | -zero\n// |-----|---------------------------|---------------|------|\n// | +1  | 1.(dat[0] ... dat[siz-1]) | 2^exp         |   n  | +number\n// | -1  | 1.(dat[0] ... dat[siz-1]) | 2^exp         |   n  | -number\n// |-----|---------------------------|---------------|------|\n// | +1  | 1.0                       | 2^+0x7FFFFFFE |   1  | +infinity\n// | -1  | 1.0                       | 2^+0x7FFFFFFE |   1  | -infinity\n// |-----|---------------------------|---------------|------|\n//         ^                               ^             ^\n//         ^                               ^          used bits count in mantisa\n//         ^                          exponent of msb of dat[0]\n//         1. is included in mantisa dat[0] !!!\n//---------------------------------------------------------------------------\nclass arbnum\n    {\npublic:\n    ALU32 alu;\n    // dat is LSDW first ... MSDW last\n    DWORD *dat; int siz,exp,sig,bits;\n    arbnum()                { dat=NULL; siz=0; exp=1; sig=+1; bits=0; }\n    arbnum(int a)           { dat=NULL; siz=0; exp=1; sig=+1; bits=0; *this=a; }\n    arbnum(DWORD a)         { dat=NULL; siz=0; exp=1; sig=+1; bits=0; *this=a; }\n    arbnum(float a)         { dat=NULL; siz=0; exp=1; sig=+1; bits=0; *this=a; }\n    arbnum(double a)        { dat=NULL; siz=0; exp=1; sig=+1; bits=0; *this=a; }\n    arbnum(AnsiString a)    { dat=NULL; siz=0; exp=1; sig=+1; bits=0; *this=a; }\n    arbnum(arbnum&amp; a)       { dat=NULL; siz=0; exp=1; sig=+1; bits=0; *this=a; }\n    ~arbnum()               { _free(); }\n    arbnum* operator = (const arbnum *a) { *this=*a; return this; }\n    arbnum* operator = (const arbnum &amp;a) { _alloc(a.siz); for(int i=0;(i&lt;siz)&amp;&amp;(i&lt;a.siz);i++) dat[i]=a.dat[i]; exp=a.exp; sig=a.sig; bits=a.bits; return this; }\n    // error handling\n    void _error(int err)\n        {\n        err=1/0;\n        }\n    // memory management\n    void _free();\n    void _alloc(int _siz);\n    void _realloc(int _siz);\n    void _normalize(int _fbits=-1);\n    // export functions\n    AnsiString str(const char *cs=\"\");          // cs: \"5.3\" \".3\" \"5\" \"s5.3\" \" 5.3\" \"M.M\" b,d,h e\n    int        geti32();\n    DWORD      getu32();\n    float      getf32();\n    double     getf64();\n    // assign operators\n    arbnum operator = (int x);\n    arbnum operator = (DWORD x);\n    arbnum operator = (float x);\n    arbnum operator = (double x);\n    arbnum operator = (AnsiString x);           // nahra cislo zo stringu (+/-)dec/bin/hex(d/b/h) podla posledneho znaku\n    // arithmetic operators\n    arbnum operator + ();\n    arbnum operator - ();\n    arbnum operator ++ ();                      // ++x  return this+1\n    arbnum operator -- ();                      // --x  return this-1\n    arbnum operator ++ (int y);                 // x++  return this, and then this+1\n    arbnum operator -- (int y);                 // x--  return this, and then this-1\n    arbnum operator &lt;&lt; (int n);\n    arbnum operator &gt;&gt; (int n);\n    arbnum operator &lt;&lt;=(int n)          { this[0]=this[0]&lt;&lt;n; return *this; };\n    arbnum operator &gt;&gt;=(int n)          { this[0]=this[0]&gt;&gt;n; return *this; };\n    arbnum operator &amp; (const arbnum &amp;x);\n    arbnum operator | (const arbnum &amp;x);\n    arbnum operator ^ (const arbnum &amp;x);\n    arbnum operator + (const arbnum &amp;x);\n    arbnum operator - (const arbnum &amp;x);\n    arbnum operator * (const arbnum &amp;x);\n    arbnum operator / (const arbnum &amp;x);\n    arbnum operator % (const arbnum &amp;x);\n    arbnum operator &amp;=(const arbnum &amp;x) { this[0]=this[0]&amp;x; return *this; };\n    arbnum operator |=(const arbnum &amp;x) { this[0]=this[0]|x; return *this; };\n    arbnum operator ^=(const arbnum &amp;x) { this[0]=this[0]^x; return *this; };\n    arbnum operator +=(const arbnum &amp;x) { this[0]=this[0]+x; return *this; };\n    arbnum operator -=(const arbnum &amp;x) { this[0]=this[0]-x; return *this; };\n    arbnum operator *=(const arbnum &amp;x) { this[0]=this[0]*x; return *this; };\n    arbnum operator /=(const arbnum &amp;x) { this[0]=this[0]/x; return *this; };\n    arbnum operator %=(const arbnum &amp;x) { this[0]=this[0]%x; return *this; };\n    // bool operators\n    int operator !  (               ) { return   iszero();                       }\n    int operator &amp;&amp; (const arbnum &amp;x) { return ((isnonzero())&amp;&amp;(x.isnonzero())); }\n    int operator || (const arbnum &amp;x) { return ((isnonzero())||(x.isnonzero())); }\n    int operator == (const arbnum &amp;x);\n    int operator != (const arbnum &amp;x);\n    int operator &lt;  (const arbnum &amp;x);\n    int operator &gt;  (const arbnum &amp;x);\n    int operator &lt;= (const arbnum &amp;x);\n    int operator &gt;= (const arbnum &amp;x);\n    int  isnan();                               // ( this == nan )\n    int  isinf();                               // ( this == inf )\n    int  isone();                               // ( this == +1 )\n    int  iszero();                              // ( this == 0 )\n    int  isnonzero();                           // ( this != 0 )\n    int  isinteger();                           // ( this==integer(this))   ...-2,-1,0,+1,+2,...\n    int  isreal();                              // ( this!=integer(this))   12.3456\n    int  isfraction();                          // ( 1   &gt;     abs(this))   0.555 -0.789\n    // bit functions\n    void bitset(int e);                         // this|=2^e\n    void bitres(int e);                         // this&amp;=2^e        [ normalize! ]\n    void bitnot(int e);                         // this^=2^e        [ normalize! ]\n    int  bitget(int e);                         //      =this &amp; 2^e\n    int  bits2size(int n);                      // = num of DWORDs needed for n&gt;=0 bits\n    int  nibits();                              // = num of used integer bits (from number)\n    int  nfbits();                              // = num of used fractional bits (from number)\n    int  mibits();                              // = num of used integer bits (from mantisa)\n    int  mfbits();                              // = num of used fractional bits (from mantisa)\n    // low level arithmetics\n    void nan();                                 // this =+nan\n    void inf();                                 // this =+inf\n    void one();                                 // this =+1\n    void zero();                                // this =+0\n    void integer();                             // this = odreze desatinnu cast\n    void fraction();                            // this = odreze celu cast\n    void round();                               // this = zaokruhli podla 0.5\n    void floor();                               // this = zaokruhli nadol\n    void ceil ();                               // this = zaokruhli nahor\n    void overflow();                            // this = zaokruhli ak zistil pretecenie (????????????.FFFFFFFFFFFFFF??h     [****]\n    void shl(int n);                            // mantisa &lt;&lt;= n    [ normalize! ]\n    void shr(int n);                            // mantisa &gt;&gt;= n    [ normalize! ]\n    void inci();                                // this = sig (|this|+1)\n    void deci();                                // this = sig (|this|-1)\n    void incf();                                // this = sig (|this|+lsb)\n    void decf();                                // this = sig (|this|-lsb)\n    void add(const arbnum &amp;x,const arbnum &amp;y);  // this = |x|+|y|                    kazi sig !!! [ normalize! ]\n    void sub(const arbnum &amp;x,const arbnum &amp;y);  // this = |x|-|y|  ; |x|&gt;=|y|        kazi sig !!! [ normalize! ]\n    void mul(const arbnum &amp;x,const arbnum &amp;y);  // this = |x|*|y|                    kazi sig !!! [ normalize! ]\n    void _mul_karatsuba(DWORD *dst,DWORD *x,DWORD *y,int n);\n    void mul_karatsuba(const arbnum &amp;x,const arbnum &amp;y);\n    void mul_NTT(const arbnum &amp;x,const arbnum &amp;y);\n    void sqr(const arbnum &amp;x);                  // this = |x|*|x|                    kazi sig !!! [ normalize! ]\n    void sqr_NTT(const arbnum &amp;x);\n    void div(const arbnum &amp;x,const arbnum &amp;y,int acc=-1);   // this = |x|/|y|  ; y = &lt;0.5,1)     kazi sig !!! [ normalize! ]\n    void div_binary(const arbnum &amp;x,const arbnum &amp;y);\n    int  geq(const arbnum &amp;x,const arbnum &amp;y);  //      = |x|&gt;=|y| ; 0 &lt;, 1 &gt;, 2==\n    int int_log2(int x)\n        {\n        if (x&lt;=0) return 0;\n        int y=0,a=1;\n        for (;a&lt;=x;a&lt;&lt;=1,y++); y--;\n        return y;\n        }\n    // friend arithmetics\n    friend arbnum integer (const arbnum &amp;x);                    // = integer(x)\n    friend arbnum fraction(const arbnum &amp;x);                    // = fraction(x)\n    friend arbnum round   (const arbnum &amp;x);                    // = round(x);\n    friend arbnum floor   (const arbnum &amp;x);                    // = floor(x)\n    friend arbnum ceil    (const arbnum &amp;x);                    // = ceil(x)\n    friend arbnum abs     (const arbnum &amp;x);                    // = |x|\n    friend arbnum sqrt    (const arbnum &amp;x);                    // = |x|^0.5\n    friend arbnum exp2    (const arbnum &amp;x);                    // = 2^x\n    friend arbnum expe    (const arbnum &amp;x);                    // = e^x\n    friend arbnum exp10   (const arbnum &amp;x);                    // = 10^x\n    friend arbnum log2    (const arbnum &amp;x);                    // = log2(x)\n    friend arbnum loge    (const arbnum &amp;x);                    // = ln(x)\n    friend arbnum log10   (const arbnum &amp;x);                    // = log10(x)\n    friend arbnum powi    (const arbnum &amp;x,const arbnum &amp;y);    // = x^int(y)\n    friend arbnum powi    (const arbnum &amp;x,int y);              // = x^int(y)\n    friend arbnum pow     (const arbnum &amp;x,const arbnum &amp;y);    // = x^y\n    friend arbnum sin     (const arbnum &amp;x);                    // = sin(x)\n    friend arbnum cos     (const arbnum &amp;x);                    // = cos(x)\n    friend arbnum tan     (const arbnum &amp;x);                    // = tan(x)\n    friend arbnum cotan   (const arbnum &amp;x);                    // = cotan(x)\n    friend arbnum asin    (const arbnum &amp;x);                    // = asin(x)\n    friend arbnum acos    (const arbnum &amp;x);                    // = acos(x)\n    friend arbnum atan    (const arbnum &amp;x);                    // = atan(x)\n    friend arbnum acotan  (const arbnum &amp;x);                    // = acotan(x)\n    friend arbnum gcd     (arbnum x,arbnum y);                  // = gcd (int(|x|),int(|y|))  binary greatest common divisor\n    friend arbnum fact    (const DWORD &amp;x);                     // = x! = (x/2)!^2 * mul[ p(i)^e(i) ]\n    friend arbnum fact_aprox(const DWORD &amp;x);                   // ~ x!\n    };\n//---------------------------------------------------------------------------\n</code></pre>\n<p><strong>[notes]</strong></p>\n<p>Without more info about your target platform or military format it is impossible to decide which approach is better in respect to speed,accuracy. We need info like mantissa bits/format exponent bits/format, do you have <strong>FPU</strong> at disposal (and for which format), what float types you have natively at disposal etc.</p>\n</div>",
            "votes": "3",
            "user": "Spektre",
            "time": "Aug 7, 2016 at 11:02",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Spektre",
                    "text": "<span class=\"comment-copy\">@CodeMonkeyV2 finished editing. sorry some comments are not in English but the code should be straightforward enough anyway ...</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The <a href=\"http://en.wikipedia.org/wiki/IEEE_floating_point\" rel=\"nofollow\">IEEE 754</a> standard describes how the floating point representation works under the hood.</p>\n</div>",
            "votes": "1",
            "user": "Spl3en",
            "time": "Jun 10, 2015 at 20:46",
            "is_accepted": false,
            "comments": [
                {
                    "user": "CodeMonkeyV2",
                    "text": "<span class=\"comment-copy\">Sure, as a representation. What I need is the code that makes it work, what is happening behind the scenes. Like how Microsoft's std::string can be traced to view the code that makes it function.</span>",
                    "time": null
                },
                {
                    "user": "Spl3en",
                    "text": "<span class=\"comment-copy\">There is no such code in the modern OS, as it is implemented directly by the CPU.</span>",
                    "time": null
                }
            ]
        }
    ]
}