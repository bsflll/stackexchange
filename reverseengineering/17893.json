{
    "title": "How to convert pointer and offsets to array in IDA?",
    "link": "https://reverseengineering.stackexchange.com/questions/17893/how-to-convert-pointer-and-offsets-to-array-in-ida",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Here is an example of a subroutine as pseudocode in IDA:</p>\n<pre><code>HRESULT __stdcall func(PCWSTR name, PCWSTR command, BOOL folder, DWORD *pCode) {\n  _OWORD *v4;\n  __int128 v5, v12, v13;\n  __int64 v6;\n  HRESULT v11;\n  DWORD **v14;\n  PCWSTR v16, v17; BOOL v18; DWORD *v19;\n\n  v19 = pCode; v18 = folder; v17 = command; v16 = name;\n  v11 = 0x80004005;\n  *(_QWORD *)&amp;v12 = &amp;v11;\n  *((_QWORD *)&amp;v12 + 1) = &amp;v16;\n  *(_QWORD *)&amp;v13 = &amp;v17;\n  *((_QWORD *)&amp;v13 + 1) = &amp;v18;\n  v14 = &amp;v19;\n  v4 = (_OWORD *)sub_1800050B4(40i64); //contains malloc\n  if ( v4 ) {\n    v5 = v13;\n    *v4 = v12;\n    v6 = (__int64)v14;\n    v4[1] = v5;\n    *((_QWORD *)v4 + 4) = v6;\n  }\n  function(v4);\n}\n</code></pre>\n<p>It is easy to understand the pointer offsets with <code>v12</code> and <code>v13</code>. But some subroutines have many more variables which is not easy to follow. So can I convert that pointer offsets to an array? And why IDA shows so many local variables?</p>\n</div>",
    "votes": "0",
    "answers": 1,
    "views": "2k",
    "tags": [
        "ida",
        "disassembly"
    ],
    "user": "Biswapriyo",
    "time": "Apr 4, 2018 at 10:57",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>IDA deals with optimized assembler generated by the compiler. In this case compiler definitely combined several values into 128-bit registers and several stack locations. IDA doesn't know what it was initially, it can only guess. So it uses the stack locations and registers as if they are the variables in the source code. To understand it better you should read about 'Stack Frame'.</p>\n<p>As for making the array, you should change the type of v12 variable to <strong>void * [4]</strong>. This is done via selecting v12 and pressing Y.</p>\n</div>",
            "votes": "1",
            "user": "Anton Kukoba",
            "time": "Apr 4, 2018 at 12:50",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Biswapriyo",
                    "text": "<span class=\"comment-copy\">How did you get void* [4] ? Why not void* [2] ? When I use [4] IDA shows error \"New variable size is bigger than the old one\".</span>",
                    "time": null
                },
                {
                    "user": "Anton Kukoba",
                    "text": "<span class=\"comment-copy\">Yes the array will be bigger then initial tiny variable which IDA created. And it's ok. void* [2] may be correct too, if you're sure that there were two arrays in v12 and v13, not one big array of 4 elements which is placed in both stack location. My experience tells me that it looks like one big array. Anyway you'll be able to delete the function and decompile again if you did some mistake. It's eternal learning :)</span>",
                    "time": null
                },
                {
                    "user": "Biswapriyo",
                    "text": "<span class=\"comment-copy\">void* [4] combines all the variables. It is better than [2]. Should I have to do some trial and error?</span>",
                    "time": null
                },
                {
                    "user": "Anton Kukoba",
                    "text": "<span class=\"comment-copy\">nope, it's all the alternative representations of the data, IDA doesn't care.</span>",
                    "time": null
                }
            ]
        }
    ]
}