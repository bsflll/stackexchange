{
    "title": "How does this Is64BitOS pointer-arithmetic-based function work?",
    "link": "https://reverseengineering.stackexchange.com/questions/31379/how-does-this-is64bitos-pointer-arithmetic-based-function-work",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Reversed this function. It works. But stepping through I can't figure out how. Why does this work?</p>\n<pre><code>bool   _Is64BitOS(void) {\n    unsigned int version = *(unsigned int*)0x7FFE026C;\n    unsigned int address = version == 10 ? 0x7FFE0308 : 0x7FFE0300;\n    ILog(\"Running %u-bit system\\n\", *(void**)address ? 32 : 64);\n\n    return (*(void**)address ? false : true);\n};\n</code></pre>\n<p>Why do we find <code>0x0A</code> at <code>0x7FFE026C</code> on a 64 bit Windows install?</p>\n</div>",
    "votes": "3",
    "answers": 1,
    "views": "119",
    "tags": [
        "windows",
        "c++"
    ],
    "user": "Pulpo",
    "time": "Jan 10, 2023 at 7:49",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<span class=\"comment-copy\">Just to mention the obvious, there isn't much pointer arithmethic involved. It's just using hardcoded addresses -- in one case conditionally one address or another.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>\"Simple\", I want to respond, but it's somewhat involved.</p>\n<p>That region -- (<a href=\"https://msrc-blog.microsoft.com/2022/04/05/randomizing-the-kuser_shared_data-structure-on-windows/\" rel=\"nofollow noreferrer\">since newer Windows 10 versions read-only</a>) mapped into userspace of every program -- is known as <a href=\"https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi_x/kuser_shared_data/index.htm\" rel=\"nofollow noreferrer\">KUSER_SHARED_DATA</a>. You can find details about the offsets and there meaning <a href=\"http://terminus.rewolf.pl/terminus/structures/ntdll/_KUSER_SHARED_DATA_combined.html\" rel=\"nofollow noreferrer\">over here</a> (<em>beware, it's a bit dated!</em>).</p>\n<p>The first assignment to <code>version</code> merely reads <code>KUSER_SHARED_DATA::NtMajorVersion</code>. So to answer:</p>\n<blockquote>\n<p>Why do we find <code>0x0A</code> at <code>0x7FFE026C</code> on a 64 bit Windows install?</p>\n</blockquote>\n<p>... it's the major version of the Windows, 10 in decimal representation.</p>\n<p>Since we need an up-to-date view of what <code>KUSER_SHARED_DATA</code> looks we'll have a look at the official symbols from Windows 10 by starting WinDbg/WinDbgX on Windows 10, launching some 64-bit program from it (e.g. notepad.exe) and then running <code>dt nt!_KUSER_SHARED_DATA</code> to see the type definition.</p>\n<pre><code>0:000&gt; dt nt!_KUSER_SHARED_DATA\nntdll!_KUSER_SHARED_DATA\n   +0x000 TickCountLowDeprecated : Uint4B\n   +0x004 TickCountMultiplier : Uint4B\n   +0x008 InterruptTime    : _KSYSTEM_TIME\n   +0x014 SystemTime       : _KSYSTEM_TIME\n   +0x020 TimeZoneBias     : _KSYSTEM_TIME\n   +0x02c ImageNumberLow   : Uint2B\n   +0x02e ImageNumberHigh  : Uint2B\n   +0x030 NtSystemRoot     : [260] Wchar\n   +0x238 MaxStackTraceDepth : Uint4B\n   +0x23c CryptoExponent   : Uint4B\n   +0x240 TimeZoneId       : Uint4B\n   +0x244 LargePageMinimum : Uint4B\n   +0x248 AitSamplingValue : Uint4B\n   +0x24c AppCompatFlag    : Uint4B\n   +0x250 RNGSeedVersion   : Uint8B\n   +0x258 GlobalValidationRunlevel : Uint4B\n   +0x25c TimeZoneBiasStamp : Int4B\n   +0x260 NtBuildNumber    : Uint4B\n   +0x264 NtProductType    : _NT_PRODUCT_TYPE\n   +0x268 ProductTypeIsValid : UChar\n   +0x269 Reserved0        : [1] UChar\n   +0x26a NativeProcessorArchitecture : Uint2B\n   +0x26c NtMajorVersion   : Uint4B\n   +0x270 NtMinorVersion   : Uint4B\n   +0x274 ProcessorFeatures : [64] UChar\n   +0x2b4 Reserved1        : Uint4B\n   +0x2b8 Reserved3        : Uint4B\n   +0x2bc TimeSlip         : Uint4B\n   +0x2c0 AlternativeArchitecture : _ALTERNATIVE_ARCHITECTURE_TYPE\n   +0x2c4 BootId           : Uint4B\n   +0x2c8 SystemExpirationDate : _LARGE_INTEGER\n   +0x2d0 SuiteMask        : Uint4B\n   +0x2d4 KdDebuggerEnabled : UChar\n   +0x2d5 MitigationPolicies : UChar\n   +0x2d5 NXSupportPolicy  : Pos 0, 2 Bits\n   +0x2d5 SEHValidationPolicy : Pos 2, 2 Bits\n   +0x2d5 CurDirDevicesSkippedForDlls : Pos 4, 2 Bits\n   +0x2d5 Reserved         : Pos 6, 2 Bits\n   +0x2d6 CyclesPerYield   : Uint2B\n   +0x2d8 ActiveConsoleId  : Uint4B\n   +0x2dc DismountCount    : Uint4B\n   +0x2e0 ComPlusPackage   : Uint4B\n   +0x2e4 LastSystemRITEventTickCount : Uint4B\n   +0x2e8 NumberOfPhysicalPages : Uint4B\n   +0x2ec SafeBootMode     : UChar\n   +0x2ed VirtualizationFlags : UChar\n   +0x2ee Reserved12       : [2] UChar\n   +0x2f0 SharedDataFlags  : Uint4B\n   +0x2f0 DbgErrorPortPresent : Pos 0, 1 Bit\n   +0x2f0 DbgElevationEnabled : Pos 1, 1 Bit\n   +0x2f0 DbgVirtEnabled   : Pos 2, 1 Bit\n   +0x2f0 DbgInstallerDetectEnabled : Pos 3, 1 Bit\n   +0x2f0 DbgLkgEnabled    : Pos 4, 1 Bit\n   +0x2f0 DbgDynProcessorEnabled : Pos 5, 1 Bit\n   +0x2f0 DbgConsoleBrokerEnabled : Pos 6, 1 Bit\n   +0x2f0 DbgSecureBootEnabled : Pos 7, 1 Bit\n   +0x2f0 DbgMultiSessionSku : Pos 8, 1 Bit\n   +0x2f0 DbgMultiUsersInSessionSku : Pos 9, 1 Bit\n   +0x2f0 DbgStateSeparationEnabled : Pos 10, 1 Bit\n   +0x2f0 SpareBits        : Pos 11, 21 Bits\n   +0x2f4 DataFlagsPad     : [1] Uint4B\n   +0x2f8 TestRetInstruction : Uint8B\n   +0x300 QpcFrequency     : Int8B\n   +0x308 SystemCall       : Uint4B\n   +0x30c Reserved2        : Uint4B\n   +0x310 SystemCallPad    : [2] Uint8B\n   +0x320 TickCount        : _KSYSTEM_TIME\n   +0x320 TickCountQuad    : Uint8B\n   +0x320 ReservedTickCountOverlay : [3] Uint4B\n   +0x32c TickCountPad     : [1] Uint4B\n   +0x330 Cookie           : Uint4B\n   +0x334 CookiePad        : [1] Uint4B\n   +0x338 ConsoleSessionForegroundProcessId : Int8B\n   +0x340 TimeUpdateLock   : Uint8B\n   +0x348 BaselineSystemTimeQpc : Uint8B\n   +0x350 BaselineInterruptTimeQpc : Uint8B\n   +0x358 QpcSystemTimeIncrement : Uint8B\n   +0x360 QpcInterruptTimeIncrement : Uint8B\n   +0x368 QpcSystemTimeIncrementShift : UChar\n   +0x369 QpcInterruptTimeIncrementShift : UChar\n   +0x36a UnparkedProcessorCount : Uint2B\n   +0x36c EnclaveFeatureMask : [4] Uint4B\n   +0x37c TelemetryCoverageRound : Uint4B\n   +0x380 UserModeGlobalLogger : [16] Uint2B\n   +0x3a0 ImageFileExecutionOptions : Uint4B\n   +0x3a4 LangGenerationCount : Uint4B\n   +0x3a8 Reserved4        : Uint8B\n   +0x3b0 InterruptTimeBias : Uint8B\n   +0x3b8 QpcBias          : Uint8B\n   +0x3c0 ActiveProcessorCount : Uint4B\n   +0x3c4 ActiveGroupCount : UChar\n   +0x3c5 Reserved9        : UChar\n   +0x3c6 QpcData          : Uint2B\n   +0x3c6 QpcBypassEnabled : UChar\n   +0x3c7 QpcShift         : UChar\n   +0x3c8 TimeZoneBiasEffectiveStart : _LARGE_INTEGER\n   +0x3d0 TimeZoneBiasEffectiveEnd : _LARGE_INTEGER\n   +0x3d8 XState           : _XSTATE_CONFIGURATION\n   +0x710 FeatureConfigurationChangeStamp : _KSYSTEM_TIME\n   +0x71c Spare            : Uint4B\n</code></pre>\n<p>(if we used <code>dt -r2 nt!_KUSER_SHARED_DATA 0x000000007ffe0000</code> -- assuming we're <em>not</em> on 64-bit ARM where the <code>KUSER_SHARED_DATA</code> is no longer at a fixed address -- we can see the \"decoded\" contents of this structure)</p>\n<p>By comparing this output with the one from Terminus (link above) we can see that we seem to be looking for <code>KUSER_SHARED_DATA::SystemCall</code> (in newer versions <code>SystemCallPad</code> as per Terminus, but the symbols call it <code>SystemCall</code> nevertheless). When we follow the logic from the function it appears as if it tries to dereference the given address, picked based on Windows 10 or not, as a pointer. The goal seems to be to figure out (from any given process) if that value is 0 or not. And that seems to be an indicator for whether or not we're on 32-bit.</p>\n<p><code>KUSER_SHARED_DATA</code> has all sorts of useful applications, one is to quickly determine the <em>true</em> Windows version with resorting to NT native function calls or having to specify in a manifest that your application is compatible with the Windows version it's running on.</p>\n<p>That said, it's always a certain risk to reach into OS structures like that and relying on a given layout. Microsoft seems to be aware that this is being used by third parties, enough so to have kept the address fixed but making the region read-only in newer Windows versions (article linked above).</p>\n<ul>\n<li><a href=\"https://osm.hpi.de/wrk/2007/08/getting-os-information-the-kuser_shared_data-structure/\" rel=\"nofollow noreferrer\">Older article</a>, including details on how to query system time</li>\n</ul>\n</div>",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "Feb 8, 2024 at 16:50",
            "is_accepted": true,
            "comments": []
        }
    ]
}