{
    "title": "Delphi mt38 CRC (Tricore 1766 Arch)",
    "link": "https://reverseengineering.stackexchange.com/questions/26281/delphi-mt38-crc-tricore-1766-arch",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I want to calculate CRC32 for Delphi mt38 and found the below assembly algorithm and converted it to C. It seems that this algorithm is defined for n = 256 or 1024. I want to calculate CRC32 for n = 1638400 and expect to get CRC32 = 0xFB6568AF for input data = {0}, but it  doesn't give the expected answer. How can I calculate it?\nThank you in advance.</p>\n<p>The assembly algorithm:</p>\n<pre><code>CheckSum:                               ; CODE XREF: sub_CDBA6\n            movh.a          a15, #@HIS(CKS_loop_count)\n            lea             a15, [a15]@LOS(CKS_loop_count)\n            ld.b            d15, [a15]0\n            jz16            d15, loc_CE256\n            mov32           d14, #0x100\n            j16             loc_CE25A\n; ---------------------------------------------------------------------------\n\nloc_CE256:                              ; CODE XREF: CheckSum\n            mov32           d14, #0x400\n\nloc_CE25A:                              ; CODE XREF: CheckSum\n            mov16           d13, #0\n            movh.a          a14, #@HIS(table_address)\n            lea             a14, [a14]@LOS(table_address)\n            j16             loc_CE2FA\n; ---------------------------------------------------------------------------\n\nloc_CE266:                              ; CODE XREF: CheckSum:loc_CE2FA\n            movh.a          a15, #@HIS(DATA_address)\n            ld32.a          a7, [a15]@LOS(DATA_address)\n            ld16.bu         d10, [a7]\n            ld32.w          d12, dword_D0000D34\n            ld32.w          d11, dword_D0000D30\n            jlt.u           d12, d11, loc_CE286\n            call32          sub_7FCC0\n            add16           d11, d2\n            jlt.u           d12, d11, loc_CE2A8\n\nloc_CE286:                              ; CODE XREF: CheckSum+36\n            mov.u           d6, #0xFFFF\n            ld32.w          d15, CRC_value\n            sh32            d7, d15, #-8\n            addih           d6, d6, #0xFF\n            and16           d7, d6\n            xor16           d15, d10\n            and32           d15, d15, #0xFF\n            addsc16.a       a15, a14, d15, #2\n            ld16.w          d15, [a15]\n            xor16           d15, d7\n            st32.w          CRC_value, d15\nloc_CE2A8:                              ; CODE XREF: CheckSum+40\n            movh.a          a15, #@HIS(DATA_address)\n            ld32.a          a7, [a15]@LOS(DATA_address)\n            add16.a         a7, #1\n            lea             a15, [a15]@LOS(DATA_address)\n            st16.a          [a15], a7\n            ld32.w          d15, dword_D0000D34\n            add16           d15, #1\n            st32.w          dword_D0000D34, d15\n            ld32.w          d7, dword_D0000D26\n            jlt.u           d15, d7, loc_CE2F8\n            ld32.w          d15, CRC_value\n            movh.a          a15, #@HIS(CRC_Variable)\n            st32.w          [a15]@LOS(CRC_Variable), d15\n            mov16           d15, #1\n            st32.b          take_CKS_var, d15\n            movh.a          a15, #@HIS(CKS_loop_count)\n            lea             a15, [a15]@LOS(CKS_loop_count)\n            ld.b            d15, [a15]0\n            jnz16           d15, loc_CE2FE\n            mov16           d15, #1\n            movh.a          a15, #@HIS(CKS_loop_count)\n            lea             a15, [a15]@LOS(CKS_loop_count)\n            st16.b          [a15], d15\n            ret16\n; ---------------------------------------------------------------------------\n\nloc_CE2F8:                              ; CODE XREF: CheckSum+84\n            add16           d13, #1\n\nloc_CE2FA:                              ; CODE XREF: CheckSum+22\n            jlt.u           d13, d14, loc_CE266\n\nloc_CE2FE:                              ; CODE XREF: CheckSum+A6\n            ret16\n; End of function CheckSum\n</code></pre>\n<p>The converted C algorithm:</p>\n<pre><code>uint32_t crc32(uint32_t n, uint32_t *data) {\n    uint32_t i = 0;\n    uint32_t ch;\n    crc = 0xFFFFFFFF;\n    while (i &lt; n) {\n        ch = data[i];\n        crc = ((crc &gt;&gt; 8) &amp; 0xFFFFFF) ^\n              *(crc32_table + ((((crc ^ ch) &amp; 0xFF) &lt;&lt; 2) &amp; 0xFF));\n        i++;\n    }\n    return crc;\n}\n</code></pre>\n</div>",
    "votes": "1",
    "answers": 0,
    "views": "237",
    "tags": [
        "disassembly",
        "c",
        "static-analysis",
        "crc"
    ],
    "user": "bahar",
    "time": "Nov 11, 2020 at 11:43",
    "comments": [],
    "answers_data": []
}