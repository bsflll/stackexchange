{
    "title": "Wrapping usercall from Hex-Rays",
    "link": "https://reverseengineering.stackexchange.com/questions/11081/wrapping-usercall-from-hex-rays",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to call a function generated by Hex-Rays by injecting a DLL, but have so far only managed to crash the process.</p>\n<p>This is the code generated by Hex-Rays</p>\n<pre><code>int __usercall sub_54C3A0@&lt;eax&gt;(int a1@&lt;esi&gt;, void *a2@&lt;ecx&gt;)\n{\n  char *v2; // eax@1\n  char *v3; // edx@1\n  char v4; // cl@2\n  int result; // eax@4\n  char v6[84]; // [sp+0h] [bp-58h]@1\n\n  sub_432BA0(a2);\n  dword_81D7CC = 1;\n  sub_432B40(\"xxx_\");\n  v2 = (char *)sub_431620(55);\n  v3 = (char *)(v6 - v2);\n  do\n  {\n    v4 = *v2;\n    v2[(_DWORD)v3] = *v2;\n    ++v2;\n  }\n  while ( v4 );\n  sub_4330E0(*(_DWORD *)v6);\n  sub_437270();\n  dword_81D7CC = 0;\n  result = 0;\n  if ( v6[0] )\n  {\n    dword_81DAE0 = 0;\n    if ( sub_54C480(100, a1) || dword_81DAE0 || sub_54C480(75, a1) || dword_81DAE0 || sub_54C480(50, a1) )\n      result = 1;\n  }\n  return result;\n}\n</code></pre>\n<p>And this is my code</p>\n<pre><code>static DWORD hook_address = 0x54C3A0;\n__declspec(naked) int hook()\n{\n    __asm {\n        push esi // a1\n        push ecx // a2\n        call hook_address\n        retn 4\n    }\n}\n</code></pre>\n<p>What would the correct wrapper look like, and why?</p>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "1k",
    "tags": [
        "ida",
        "assembly",
        "hexrays"
    ],
    "user": "Magnus von Wachenfeldt",
    "time": "Dec 16, 2015 at 17:12",
    "comments": [
        {
            "user": "0xec",
            "text": "<span class=\"comment-copy\">It should be <code>mov esi, a1</code> , <code>mov ecx, a2</code>. Note that <code>usercall</code> is not actually any calling convention. It is a way of representing unknown/custom calling conventions. See <i><a href=\"http://stackoverflow.com/questions/8832139/hooking-usercall-with-inline-asm\">this</a></i> answer.</span>",
            "time": null
        },
        {
            "user": "Magnus von Wachenfeldt",
            "text": "<span class=\"comment-copy\">I tried that, still get access violation.</span>",
            "time": null
        },
        {
            "user": "rev",
            "text": "<span class=\"comment-copy\">Do it like this: <code>mov esi, a1</code>, <code>mov ecx, a2</code>, <code>call hook_address</code>, <code>ret</code>. Using <code>retn 4</code> clears 4 bytes from the stack, but usercalls don't need it because their arguments are in registers, not in the stack.</span>",
            "time": null
        },
        {
            "user": "Magnus von Wachenfeldt",
            "text": "<span class=\"comment-copy\">That worked. Also, the address was wrong all the time. After running the program from IDA the addresses updated. No wonder I got access violations all over the place.</span>",
            "time": null
        },
        {
            "user": "tmr232",
            "text": "<span class=\"comment-copy\">@AcidShout can you write your comment as an answer so that this question can be marked answered, and also help others in future?</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Your hook is wrong because <code>retn 4</code> is for <code>__stdcall</code>s, not <code>__usercall</code>s, and because you must move arguments to registers, not push them. Do it like this:</p>\n<pre><code>mov esi, a1\nmov ecx, a2\ncall hook_address\nret\n</code></pre>\n<p><code>retn 4</code> would clean 4 bytes from the stack, but you didn't push anything, so it's not correct, which is why you use <code>ret</code> instead.</p>\n</div>",
            "votes": "4",
            "user": "rev",
            "time": "Oct 13, 2015 at 13:05",
            "is_accepted": false,
            "comments": []
        }
    ]
}