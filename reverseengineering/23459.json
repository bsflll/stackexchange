{
    "title": "How to reason about this rotating XOR problem?",
    "link": "https://reverseengineering.stackexchange.com/questions/23459/how-to-reason-about-this-rotating-xor-problem",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Disclaimer: I'm not asking for the solution to this problem, but for you to point out the particular areas or techniques of reverse engineering that I need to improve at in order to solve this problem myself.</p>\n<p>The code in question comes from the game \"Sourcery,\" it's basically a CTF inside a game. The game doesn't give you the ability to debug or modify the code whatsoever, so the problem to solve here is to find an input that will make <code>verify_code</code> return 1.</p>\n<p>So far I had the idea of trying to brute force the solution, i.e. trying all possible codes until I find one that works. The range of acceptable characters for the code is all printable ascii chars, and we need to figure out 16 chars, which seems like it would take too much time to brute force unless you were able to reduce the character range.</p>\n<p>The thing that is making this hard for me to mentally analyze is that it seems like if you change one character, it can change the effect that successive characters have on the execution path. </p>\n<p>Any ideas how to approach this?</p>\n<pre><code>; int verify_code(char *code)\nverify_code:\n    push esi\n    push ebp\n    mov ebp, esp\n    sub esp, 8\n\n    push dword [ebp + 12]\n    call strlen\n    cmp eax, 16\n; the code must be 16 characters long.\n    jne .bad\n\n    mov esi, [ebp + 12]\n    mov edx, 0xfa\n\n    mov al, [esi]\n    rol edx, 5\n    xor dl, al\n    add dl, 0xab\n\n    mov al, [esi+1]\n    rol edx, 3\n    xor dl, al\n    add dl, 0x45\n\n    mov al, [esi+2]\n    rol edx, 1\n    xor dl, al\n    add dl, 0x12\n\n    mov al, [esi+3]\n    rol edx, 9\n    xor dl, al\n    add dl, 0xcd\n\n    mov cl, dl\n    and cl, 15\n    add cl, 'a'\n    cmp [esi+4], cl\n    jne .bad\n\n    rol edx, 12\n    xor dl, cl\n    add dl, 0x87\n    mov cl, dl\n    and cl, 15\n    add cl, 'a'\n    cmp [esi+5], cl\n    jne .bad\n\n    rol edx, 3\n    xor dl, cl\n    add dl, 0xef\n    mov cl, dl\n    and cl, 15\n    add cl, 'C'\n    cmp [esi+6], cl\n    jne .bad\n\n    rol edx, 1\n    xor dl, cl\n    add dl, 0x10\n    mov cl, dl\n    and cl, 15\n    add cl, 'f'\n    cmp [esi+7], cl\n    jne .bad\n\n    rol edx, 13\n    xor dl, cl\n    add dl, 0x9a\n    mov cl, dl\n    and cl, 15\n    add cl, 'e'\n    cmp [esi+8], cl\n    jne .bad\n\n    rol edx, 9\n    xor dl, cl\n    add dl, 0xa8\n    mov cl, dl\n    and cl, 15\n    add cl, 'D'\n    cmp [esi+9], cl\n    jne .bad\n\n    rol edx, 7\n    xor dl, cl\n    add dl, 0xca\n    mov cl, dl\n    and cl, 15\n    add cl, 'D'\n    cmp [esi+10], cl\n    jne .bad\n\n    rol edx, 2\n    xor dl, cl\n    add dl, 0x91\n    mov cl, dl\n    and cl, 15\n    add cl, 'c'\n    cmp [esi+11], cl\n    jne .bad\n\n    rol edx, 5\n    xor dl, cl\n    add dl, 0x86\n    mov cl, dl\n    and cl, 15\n    add cl, 'A'\n    cmp [esi+12], cl\n    jne .bad\n\n    rol edx, 6\n    xor dl, cl\n    add dl, 0xf1\n    mov cl, dl\n    and cl, 15\n    add cl, 'e'\n    cmp [esi+13], cl\n    jne .bad\n\n    rol edx, 3\n    xor dl, cl\n    add dl, 0x1f\n    mov cl, dl\n    and cl, 15\n    add cl, 'B'\n    cmp [esi+14], cl\n    jne .bad\n\n    rol edx, 4\n    xor dl, cl\n    add dl, 0x90\n    mov cl, dl\n    and cl, 15\n    add cl, 'f'\n    cmp [esi+15], cl\n    jne .bad\n\n    mov al, 1\n    mov esp, ebp\n    pop ebp\n    pop esi\n    ret 4\n\n.bad:\n    xor al, al\n    mov esp, ebp\n    pop ebp\n    pop esi\n    ret 4\n</code></pre>\n</div>",
    "votes": "-1",
    "answers": 3,
    "views": "308",
    "tags": [
        "cryptography"
    ],
    "user": "P. Private",
    "time": "Mar 18, 2020 at 0:50",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>if the ctf does not give you the ability to debug<br/>\nlift it to something else and emulate<br/>\nbasically rol() is not reversible per se<br/>\nyou may have to bit wrangle with this </p>\n<p>here is a python lifted manipulation of first character   </p>\n<pre><code>#rol copy paste from https://gist.github.com/trietptm/5cd60ed6add5adad6a34098ce255949a\nmax_bits =16\nrol = lambda val, r_bits, max_bits: \\\n    (val &lt;&lt; r_bits%max_bits) &amp; (2**max_bits-1) | \\\n    ((val &amp; (2**max_bits-1)) &gt;&gt; (max_bits-(r_bits%max_bits)))\n\n#========================start of emul=================\ninput = \"abcdefghijklmnop\"              # 16 long char*\nesi= input                              # mov esi, [ebp + 12]\nedx=0xfa                                # mov edx, 0xfa\nal=esi[0:1]                             # mov al, [esi] ==&gt; 'a = 0x61 ==&gt; 97'\nedx = rol(edx,5,max_bits)               # rol edx, 5    ==&gt;  0x1f40\ndl  = ( (edx &amp; 0x000000ff) ^ ord(al))   # xor dl,al     ==&gt;  0x1f21\nedx = (edx &amp; 0xffffff00) | dl  + 0xab   # add dl, 0xab  ==&gt;  0x1fcc\nprint (hex(edx))   \n</code></pre>\n<p>or you can use  debugger like ollydbg,x64dbg etc and assemble this inside and single step through this \nor use emulators like unicorn after converting this mnemonic into suitable hex \nwith say keystone </p>\n<p>here is a python confirmation (basically a rol ,5 on a 32bit just appends 5 0x0 at the end )</p>\n<pre><code>C:\\&gt;python -c \"print(hex((int(bin(0xfa)+'00000',2)^ord('a'))+0xab))\"\n0x1fcc\n</code></pre>\n<p>with this block you are constrained to an input range of only {a,b,c,..p}</p>\n<pre><code>mov cl, dl    (assuming dl spans {0...255}\nand cl, 15    (dl &amp; 0x0f willl span {0x0..0xf}\nadd cl, 'a'   {adding 0x0 to 0x61 will make it constrained to a..a+15 ==&gt;\n a to p and 5 the charecter must be the result of first 4 charecters manipulated result } \ncmp [esi+4], cl\n</code></pre>\n</div>",
            "votes": "1",
            "user": "blabb",
            "time": "Mar 18, 2020 at 12:35",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<ul>\n<li>If the above code can be assembled into object code, the code can be emulated</li>\n<li>If the above code can be assembled into object code and then linked into a stand-alone executable, you can analyze it however you like</li>\n</ul>\n<p>I'm not good at or interested in trying to perform computations like these mentally or tracing them out on paper, so if I was in this kind of situation I would first try to wrangle this code into a form that can be assembled into a stand-alone executable (for example, there needs to be a ‘_start’ or ‘main’). If this can be done, symbolic execution coupled with an SMT solver can be used to find solutions automatically (angr). From my perspective, successfully creating a binary executable out of this code is the ideal solution.</p>\n<p>An alternative approach is emulation. After having assembled the above code using the Keystone engine, analysis can be performed via <a href=\"https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/sample_x86.py\" rel=\"nofollow noreferrer\">Unicorn</a> or the <a href=\"https://github.com/qilingframework/qiling\" rel=\"nofollow noreferrer\">Qiling framework</a>. </p>\n<ul>\n<li><a href=\"http://www.keystone-engine.org/\" rel=\"nofollow noreferrer\">Keystone tutorial</a></li>\n<li>a somewhat related question, in which Keystone and Unicorn were used to assemble and analyze some object code: <a href=\"https://reverseengineering.stackexchange.com/questions/22931/is-there-a-handy-assembly-to-mock-app-conversion-tool\">Is there a handy assembly to mock app conversion tool?</a></li>\n</ul>\n</div>",
            "votes": "1",
            "user": "julian",
            "time": "Mar 19, 2020 at 12:42",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>After looking over the assembly source again, I realized that the last 12 characters of the code depended completely on the values of the first 4. Because of this, you can generate the last 12 characters from the first 4. The code can be lifted (as suggested by other answers) with some small modifications to the code to perform writes instead of cmp+jne.\nNote: The encryption method is basically a Feistel cipher.</p>\n<p>Below is the modified lifted code I used to generate the flag:</p>\n<pre><code>section .text\n    global _start\n_start:\n    call generate_code\n    mov edx, 16     ;message length\n    mov ecx, msg    ;message to write\n    mov ebx, 1      ;file descriptor (stdout)\n    mov eax, 4      ;system call number (sys_write)\n    int 0x80        ;syscall\n    jmp _done\n_done:\n    mov eax, 1      ;system call number (sys_exit)\n    int 0x80        ;syscall\n    \ngenerate_code:\n    push esi\n    push ebp\n    mov ebp, esp\n\n    mov esi, msg\n    mov edx, 0xfa\n\n    mov al, [esi]\n    rol edx, 5\n    xor dl, al\n    add dl, 0xab\n    \n    mov al, [esi+1]\n    rol edx, 3\n    xor dl, al\n    add dl, 0x45\n\n    mov al, [esi+2]\n    rol edx, 1\n    xor dl, al\n    add dl, 0x12\n\n    mov al, [esi+3]\n    rol edx, 9\n    xor dl, al\n    add dl, 0xcd\n\n    mov cl, dl\n    and cl, 15\n    add cl, 'a'\n    mov [esi+4], cl\n\n    rol edx, 12\n    xor dl, cl\n    add dl, 0x87\n    mov cl, dl\n    and cl, 15\n    add cl, 'a'\n    mov [esi+5], cl\n\n    rol edx, 3\n    xor dl, cl\n    add dl, 0xef\n    mov cl, dl\n    and cl, 15\n    add cl, 'C'\n    mov [esi+6], cl\n\n    rol edx, 1\n    xor dl, cl\n    add dl, 0x10\n    mov cl, dl\n    and cl, 15\n    add cl, 'f'\n    mov [esi+7], cl\n\n    rol edx, 13\n    xor dl, cl\n    add dl, 0x9a\n    mov cl, dl\n    and cl, 15\n    add cl, 'e'\n    mov [esi+8], cl\n\n    rol edx, 9\n    xor dl, cl\n    add dl, 0xa8\n    mov cl, dl\n    and cl, 15\n    add cl, 'D'\n    mov [esi+9], cl\n\n    rol edx, 7\n    xor dl, cl\n    add dl, 0xca\n    mov cl, dl\n    and cl, 15\n    add cl, 'D'\n    mov [esi+10], cl\n\n    rol edx, 2\n    xor dl, cl\n    add dl, 0x91\n    mov cl, dl\n    and cl, 15\n    add cl, 'c'\n    mov [esi+11], cl\n\n    rol edx, 5\n    xor dl, cl\n    add dl, 0x86\n    mov cl, dl\n    and cl, 15\n    add cl, 'A'\n    mov [esi+12], cl\n\n    rol edx, 6\n    xor dl, cl\n    add dl, 0xf1\n    mov cl, dl\n    and cl, 15\n    add cl, 'e'\n    mov [esi+13], cl\n\n    rol edx, 3\n    xor dl, cl\n    add dl, 0x1f\n    mov cl, dl\n    and cl, 15\n    add cl, 'B'\n    mov [esi+14], cl\n\n    rol edx, 4\n    xor dl, cl\n    add dl, 0x90\n    mov cl, dl\n    and cl, 15\n    add cl, 'f'\n    mov [esi+15], cl\n\n    mov al, 1\n    mov esp, ebp\n    pop ebp\n    pop esi\n    ret\n    \nsection .data\n    msg db  '0000000000000000', 16\n</code></pre>\n</div>",
            "votes": "1",
            "user": "P. Private",
            "time": "Mar 21, 2021 at 20:19",
            "is_accepted": true,
            "comments": [
                {
                    "user": "julian",
                    "text": "<span class=\"comment-copy\">why was the code removed?</span>",
                    "time": null
                },
                {
                    "user": "P. Private",
                    "text": "<span class=\"comment-copy\">Added it back for posterity.</span>",
                    "time": null
                }
            ]
        }
    ]
}