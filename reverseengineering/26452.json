{
    "title": "Encoding of 64-bit double",
    "link": "https://reverseengineering.stackexchange.com/questions/26452/encoding-of-64-bit-double",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm in the process of reverse engineering a USB driver, and I'm having problems finding a way to decode the binary representation of double values. The values don't seem to be encoded in IEEE-754 format.</p>\n<p>Do you have any suggestions on how these values should be decoded? Below, I included a couple of example double values and their corresponding binary representation.</p>\n<p>Thanks for your help!</p>\n<pre><code>1.0: 0000 0000 0000 0000 0000 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n2.0: 0000 0000 0000 0000 0000 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n3.0: 0000 0000 0000 0000 0000 1100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n4.0: 0000 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n5.0: 0000 0000 0000 0000 0001 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n\n-1.0: 1111 1111 1111 1111 1111 1100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n-2.0: 1111 1111 1111 1111 1111 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n-3.0: 1111 1111 1111 1111 1111 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n-4.0: 1111 1111 1111 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n-5.0: 1111 1111 1111 1111 1110 1100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n\n-0.1: 1111 1111 1111 1111 1111 1111 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010 \n-1.1: 1111 1111 1111 1111 1111 1011 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010 \n-2.2: 1111 1111 1111 1111 1111 0111 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100 \n-3.3: 1111 1111 1111 1111 1111 0010 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101 \n-4.4: 1111 1111 1111 1111 1110 1110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111 \n-5.5: 1111 1111 1111 1111 1110 1010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\n1.1: 0000 0000 0000 0000 0000 0100 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 \n1.2: 0000 0000 0000 0000 0000 0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 \n1.3: 0000 0000 0000 0000 0000 0101 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 \n1.4: 0000 0000 0000 0000 0000 0101 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 \n1.5: 0000 0000 0000 0000 0000 0110 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n1.6: 0000 0000 0000 0000 0000 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 \n1.7: 0000 0000 0000 0000 0000 0110 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 \n1.8: 0000 0000 0000 0000 0000 0111 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 \n1.9: 0000 0000 0000 0000 0000 0111 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 \n\n-9999.0: 1111 1111 0110 0011 1100 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 \n</code></pre>\n</div>",
    "votes": "0",
    "answers": 1,
    "views": "65",
    "tags": [
        "encodings",
        "usb",
        "float"
    ],
    "user": "Rune",
    "time": "Dec 6, 2020 at 10:40",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This appears to be a fixed-point (rather than a floating-point) format.</p>\n<p>If you treat the 64-bit values as signed integers and divide by 4398046511104.0, you will get the decimal values you show.</p>\n<p>e.g. the following will print -9999</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nint main()\n{\n    int64_t x = 0xFF63C40000000000LL;\n\n    double y = x / 4398046511104.0;\n\n    std::cout &lt;&lt; y &lt;&lt; std::endl;\n}\n</code></pre>\n</div>",
            "votes": "3",
            "user": "Ian Cook",
            "time": "Dec 6, 2020 at 12:20",
            "is_accepted": true,
            "comments": []
        }
    ]
}