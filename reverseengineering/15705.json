{
    "title": "Reverse engineering unknown RS232/UART binary protocol",
    "link": "https://reverseengineering.stackexchange.com/questions/15705/reverse-engineering-unknown-rs232-uart-binary-protocol",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<h1>Background story</h1>\n<p>For couple of days I'm trying to crack the protocol used the old medical device, in order to collect data for a research in an automated way.</p>\n<p>The device in question is <strong>Novametrix CO2SMO Plus</strong>, model <strong>8100</strong>. Manufacturer of this device was bought, long time ago, by Respironics and than Respironcis was bought by Philips. Their website doesn't exists for last 12-14 years and archived copy doesn't have any useful information. Since device was designed before 2000 there's no software over the Internet - it was distributed on floppy disks so as software updates.</p>\n<p>Device is very similar to model 7100, which was released ~3 years prior to the 8100. Devices mainly differ in software - the one in 8100 is much more sophisticated.</p>\n<h1>Physical layer</h1>\n<p>At first I stared from obvious things like determining physical layer of the connection - that went easy, since <a href=\"http://www.frankshospitalworkshop.com/equipment/documents/pulse_oximeter/service_manuals/Novametrix_8100_-_Service_manual.pdf\" rel=\"nofollow noreferrer\">service manual</a> actually lists all signals in DB25, located on the back of the device. </p>\n<p>At the beginning I hoped 8100 will use similar, well documented by manufacturer, ASCII protocol (called <code>NOVACOM1</code>) as 7100 used. Unfortunately it's not the case. My device uses newer protocol called <code>NOVACOM3</code> - there's zero information about it in the Internet; it seems like <code>NOVACOM2</code> was never released.</p>\n<p>I don't own oscilloscope (and I don't have an access to electronics labs on my college), so I determined baudrate of the port just observing the traffic with different baudrates with debugging mode enabled on device (more on that later). With high confidence I can say it's 9600 8N1 (like in previous model).</p>\n<p>Device uses <a href=\"http://www.nxp.com/products/microcontrollers-and-processors/more-processors/coldfire-plus-coldfire-32-bit-mcus/68k-processors-legacy/m683xx/32-bit-microcontroller:MC68332\" rel=\"nofollow noreferrer\">NXP MC68332 MCU</a>, which according to the data sheet is a rugged 32 bit core with quite a few subunits useful in an automotive applications. It also seems to be a secure one - since I have almost no experience in EE I quickly dismissed any possibilities to attempt of physically attacking the CPU.</p>\n<h1>PC software</h1>\n<p>According to the service manual, manufacturer had developed PC software used for communication with the device - <em>\"CO2SMO Plus! for Windows\"</em>. Unfortunately it was sold as a separate package and it's nowhere to be found now.</p>\n<h1>Diagnostic protocol</h1>\n<p>The device has two Novametrix protocols - <code>NOVACOM3</code> and <code>SATDIAG</code>. Since diagnostic protocols are usually simpler I started from the later one:</p>\n<ul>\n<li>SATDIAG streams data continuously</li>\n<li>Protocol, besides sending data to the computer, contains some unknown upload mode for firmware update (probably some XMODEM or so... I don't have firmeware blob, so obviously I didn't played with this)</li>\n<li>After analysis I can say with high confidence each packet begins with <code>0x00</code> and ends with <code>0x0A</code> (LF)</li>\n<li>Protocol streams packets few times a second (I didn't conducted any measurements on that, but it's 15-20/s)</li>\n<li>Device alternates between sending 9 and 25 bytes (including 2B of header and footer) packets</li>\n<li>Every few of seconds 41 bytes packet is transmitted </li>\n<li>Most probably no checksum is used (the same payloads contain different last byte, I also calculated popular checksums for few)</li>\n<li>Protocol seems to be aimed strictly for collecting performance data, some sort of resources usage or represents unknown internal state -  changes in measurements aren't causing any notable changes in packets. I also tried manually searching for numbers similar to these displayed by the device - no luck.</li>\n</ul>\n<p>In summary <code>SATDIAG</code> seems to be more like a debugger dumping some performance metrics or resources usage.</p>\n<h1>Control protocol</h1>\n<p>Next I started playing with the protocol used to talk to the PC software - NOVACOM3:</p>\n<ul>\n<li>The protocol follows request-response pattern</li>\n<li>In order to display live waveforms protocol has to contain continuous mode which just streams data without additional queries: <em>that is what I want to get</em></li>\n<li>By sending different characters I determined that <code>0x00</code> marks end of the packet. There's no signs of any character marking beginning the the packets.</li>\n<li>It looks like device expects (some?) packets to be 8 bytes (including trailing <code>NULL-BYTE</code>) long - while sending different lengths terminated by <code>0x00</code> I see for 8 bytes device is consistent with replying with 2 bytes.</li>\n<li>Seems to have no checksum - I've got different 2 bytes responses with the same first byte and different 2nd</li>\n<li>Response packets seems to have no length defined</li>\n<li>Sending multiple <code>0x00</code> seems to \"zero\" the device input buffer - while I was playing with determining length sending 3-4 <code>0x00</code> was causing device to behave consistently.</li>\n<li>Sending multiple <code>0x00</code> generates no response</li>\n<li>Protocol may have some blocks of commands: while I started scanning by sending 1 byte + <code>0x00</code> I've got no response for 7 bytes after each of the bytes: <code>0x10</code>, <code>0x30</code>, <code>0x50</code>, <code>0x70</code>, <code>0x90</code>, <code>0xb0</code>, <code>0xd0</code>, <code>0xf0</code></li>\n<li>All responses which I was able to get were 2 bytes or 4 bytes (and the longer ones seem to be 2 packets actually). Each packet was started with <code>0x2A</code></li>\n<li>The only responses o was able to get were: <code>{0x2A, 0xA0}</code>, <code>{0x2A, 0xA1}</code>, <code>{0x2A, 0x80}</code></li>\n<li>The packet <code>{0x2A, 0x80}</code> may actually be some sort of ACK, since a lot of times I had to wait for second packet for a 1-1.5s when responses were 4 bytes long.</li>\n<li><code>0x20</code> (space) / <code>0x40</code> (@) / <code>0x60</code> seems to be a white character - sending it followed by 0x00 leads to no response. These characters are also very common in SATDIAG.  It's a little bit suspicious that they're spaced so evenly 20-40-60. Now while writing this I think it might be some connection with the ranges described few points before (10-30-50-70-90-...)</li>\n</ul>\n<h1>I'm stucked...</h1>\n<p>I wasn't able to force device to start streaming - if I would manage to do that figuring out parameters shouldn't be that hard, since I have the display on the unit and I know which parameters to expect. Until than... I have no idea how to progress further. I also tried contacting Philips division which bought the company - no response whatsoever.</p>\n<p>Any ideas?</p>\n</div>",
    "votes": "3",
    "answers": 0,
    "views": "2k",
    "tags": [
        "hardware",
        "embedded",
        "serial-communication",
        "protocol"
    ],
    "user": "kiler129",
    "time": "Jun 28, 2017 at 5:03",
    "comments": [
        {
            "user": "Igor Skochinsky",
            "text": "<span class=\"comment-copy\">are the flash chips soldered or socketed? I would suggest dumping them to extract the firmware, from which you can RE the protocol details.</span>",
            "time": null
        },
        {
            "user": "kiler129",
            "text": "<span class=\"comment-copy\">@IgorSkochinsky: I just opened the device. Besides the fact it's built like a tank everything is in sockets (even polyfuses!). It has two 2Mbit AT29C020-12JC memory chips, and according to ten service manual they're both occupied by the software. However I have no idea how to read them (without breaking the bank) nor how to analyze the software for this CPU.</span>",
            "time": null
        },
        {
            "user": "Antonio Quevedo",
            "text": "<span class=\"comment-copy\">I found out your question while searching for the CO2SMO protocol. In the next few days, I will try and run it with the original software, while running a serial data logger in the computer. Then I will check the results, and maybe we can crack the protocol together. Cheers Antonio</span>",
            "time": null
        }
    ],
    "answers_data": []
}