{
    "title": "Nested Structures in IDA",
    "link": "https://reverseengineering.stackexchange.com/questions/20069/nested-structures-in-ida",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm trying to figure out how to explore structs in IDA, and getting stuck on the basics. I wrote a very basic test app;</p>\n<pre><code>int main() {\n    const int kBits = 1024;\n    const int kExp = 3;\n\n    RSA *rsa = RSA_generate_key(kBits, kExp, 0, 0);\n    RSA_print_fp(stdout, rsa, 0);\n\n    RSA_free(rsa);\n    return 0;\n}\n</code></pre>\n<p>Then I imported the OpenSSL headers, so IDA now understands what <code>RSA*</code> and <code>BIGNUM*</code> are. <code>BIGNUM</code> is actually pointing to <a href=\"https://github.com/openssl/openssl/blob/367ace6870e9cbc8fe21dff2ffe4673a98ea42f8/crypto/bn/bn_lcl.h#L218\" rel=\"nofollow noreferrer\"><code>bignum_st</code></a> which is referenced from RSA, which is <a href=\"https://github.com/openssl/openssl/blob/39c44eee7fd89ce13e805873e1c43bd8e488a93f/crypto/rsa/rsa_locl.h#L28\" rel=\"nofollow noreferrer\"><code>rsa_st</code></a>.</p>\n<p>Then, dropped a breakpoint in the pseudocode view;\n<a href=\"https://i.sstatic.net/WPheF.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/WPheF.png\"/></a></p>\n<p>Now, if I hover over <code>v3</code>, I see it's parsing the struct. So I want to do something like grab the value of <code>rsa-&gt;d-&gt;dmax</code>, but there doesn't seem to be a way to do this? I can't seem to find a way to access <code>v3</code> by name in IDAPython, nor can I seem to 'walk' the structure to get to the int that lives at <code>dmax</code>. Is there some way to do this?</p>\n</div>",
    "votes": "5",
    "answers": 3,
    "views": "1k",
    "tags": [
        "ida",
        "debugging",
        "idapython",
        "linux",
        "hexrays"
    ],
    "user": "XeroxDucati",
    "time": "Jan 18, 2023 at 8:13",
    "comments": [
        {
            "user": "Biswapriyo",
            "text": "<span class=\"comment-copy\">Your code works as usual but it raises exception code in IDA+windbg. Can you share the compiled Windows binary?</span>",
            "time": null
        },
        {
            "user": "Pororo",
            "text": "<span class=\"comment-copy\">Can I assume what you want to do is to dump the value of <code>v3-&gt;d-&gt;dmax</code> upon reaching this breakpoint?</span>",
            "time": null
        },
        {
            "user": "XeroxDucati",
            "text": "<span class=\"comment-copy\">@Pororo yes, exactly!</span>",
            "time": null
        },
        {
            "user": "XeroxDucati",
            "text": "<span class=\"comment-copy\">@Biswapriyo I can't imagine it would work in windows.. I'm doing this under Linux (CentOS 7 if it matters)</span>",
            "time": null
        },
        {
            "user": "Jane",
            "text": "<span class=\"comment-copy\">for some reason I thought this was the writing stack exchange, anyway -  +1 good question! will follow this.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>My knowledge of the IDAPython API isn't the most complete, but what I would do is</p>\n<ol>\n<li>Read the source (or look in IDA) to find the location (byte offsets) of <code>d</code> in <code>rsa_st</code> and <code>dmax</code> in <code>bignum_st</code>. This is easy since the members of the structures above <code>d</code> and <code>dmax</code> are pointers or int types.</li>\n<li>Inspect the disassembly just before the call and determine the location of <code>v3</code> -\nfrom the pseudocode it appears to be stored in the stack. If you are lucky, pressing tab while your cursor is on <code>v3</code> will take you to some mov operation in disassembly.</li>\n<li>When the breakpoint is hit, use a combination of <code>idc.get_reg_value</code> and <code>idc.get_bytes</code> commands (see <a href=\"https://www.hex-rays.com/products/ida/support/idadoc/162.shtml\" rel=\"nofollow noreferrer\">https://www.hex-rays.com/products/ida/support/idadoc/162.shtml</a>), using the result from step 2 as a starting point.</li>\n</ol>\n</div>",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "Jan 18, 2023 at 10:17",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Here are the steps:</p>\n<ol>\n<li>Set breakpoint. Run the local debugger with <kbd>F9</kbd>. Open Debugger dropdown menu form menu bar and choose \"Take memory snapshot\". Here is the screenshot:</li>\n</ol>\n<p><a href=\"https://i.sstatic.net/pDPZG.png\" rel=\"nofollow noreferrer\"><img alt=\"Take_Memory_Snapshot\" src=\"https://i.sstatic.net/pDPZG.png\"/></a></p>\n<ol start=\"2\">\n<li>Double click on the variables that you want to know (here the <code>RSA*</code> pointer). IDA will take you to the stack view (aka. IDA View-RIP). Do not move the cursor otherwise you will get different value. Press <kbd>N</kbd> to name the variable in that stack view. \"Rename address\" window will pop-up. Here is the screenshot:</li>\n</ol>\n<p><a href=\"https://i.sstatic.net/JdOnz.png\" rel=\"nofollow noreferrer\"><img alt=\"Enter_Variable_Name\" src=\"https://i.sstatic.net/JdOnz.png\"/></a></p>\n<ol start=\"3\">\n<li>After naming the variable in that stack view, press <kbd>Y</kbd> to add the data type i.e. structure type. For this case it will be <code>RSA</code>, not the pointer because all stack variables placed linearly. Here is the screenshot:</li>\n</ol>\n<p><a href=\"https://i.sstatic.net/Ae3y8.png\" rel=\"nofollow noreferrer\"><img alt=\"Enter_Data_type\" src=\"https://i.sstatic.net/Ae3y8.png\"/></a></p>\n<p>Now you can see all the struct members value.</p>\n</div>",
            "votes": "0",
            "user": "Biswapriyo",
            "time": "Dec 8, 2018 at 5:05",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>\"Setting a breakpoint\" suggests that you are doing dynamic analysis. Assuming that and assuming this happens on a real system, may I suggest an alternative route for Linux, based on my other assumption that you are linking OpenSSL dynamically?</p>\n<p>When on Linux (and a number of other unixoid systems) you can guide <a href=\"https://man7.org/linux/man-pages/man8/ld.so.8.html\" rel=\"nofollow noreferrer\">the dynamic linker/loader</a> to override a function. If you know Windows and DLLs it could probably be compared a little to DLL placement attacks, but it is more flexible and requires less effort.</p>\n<p>NB: Obviously <em>this</em> approach doesn't teach you how about dealing with structs in IDA, but I think it is a very powerful technique to keep in mind. Because it is an alternative approach that doesn't satisfy your constraint of wanting to learn more about dealing with structs in IDA, I am making this a CW.</p>\n<p>There are some components for this approach:</p>\n<ol>\n<li>you need a \"wrapper\" shared object, let's call it <code>mock_openssl_rsagenkey.so</code>, exporting <code>RSA_generate_key()</code> with a binary compatible signature to that from the original OpenSSL shared object (something like <code>libcrypto.so</code>)</li>\n<li>you need to tell <code>ld.so</code> via environment variable to preload <code>mock_openssl_rsagenkey.so</code> (see below)</li>\n</ol>\n<p><code>ld.so</code> will take care -- when resolving symbols -- that the preloaded ones take precedence. This is how one of the modes of operation <a href=\"https://linux.die.net/man/3/efence\" rel=\"nofollow noreferrer\">for eFence is implemented (look for <code>LD_PRELOAD</code>, the man page also lists the exported symbols)</a>.</p>\n<p>So now your only remaining task would be to turn up the correct prototype <a href=\"https://www.openssl.org/docs/man1.1.1/man3/RSA_generate_key.html\" rel=\"nofollow noreferrer\">for <code>RSA_generate_key</code></a> from the <code>libcrypto.so</code> that your binary uses (try <code>ldd ./your_binary</code> to list dependencies) and write the wrapper <code>.so</code>, using <a href=\"https://man7.org/linux/man-pages/man3/dlopen.3.html\" rel=\"nofollow noreferrer\"><code>dlopen()</code></a> and <a href=\"https://man7.org/linux/man-pages/man3/dlsym.3.html\" rel=\"nofollow noreferrer\"><code>dlsym()</code></a> to locate the <em>original</em> <code>RSA_generate_key</code> symbols from the <em>actual</em> <code>libcrypto.so</code></p>\n<hr/>\n<h3>Full example</h3>\n<h4><code>main.c</code></h4>\n<p>This is approximately the program you created and are analyzing.</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;openssl/rsa.h&gt;\n\nint main(int argc, char const ** argv, char const** envp)\n{\n    int const kBits = 1024;\n    int const kExp = 3;\n\n    RSA *rsa = RSA_generate_key(kBits, kExp, 0, 0);\n    RSA_print_fp(stdout, rsa, 0);\n\n    RSA_free(rsa);\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<h4><code>mock_openssl.c</code></h4>\n<p>This is the wrapper shared object, which we'll load with <code>LD_PRELOAD</code>.</p>\n<pre><code>#include &lt;dlfcn.h&gt;\n#include &lt;openssl/rsa.h&gt;\n\ntypedef RSA* (*RSA_generate_key_t)(int, unsigned long, void (*)(int, int, void *), void *);\nstatic RSA_generate_key_t real_RSA_generate_key = 0;\nstatic void* libcrypto = 0;\n\nstatic void init() __attribute__((constructor));\nstatic void fini() __attribute__((destructor));\n\nvoid init()\n{\n    if (!libcrypto)\n    {\n        libcrypto = dlopen(\"libcrypto.so.3\", RTLD_NOW);\n        if (!libcrypto)\n        {\n            libcrypto = dlopen(\"libcrypto.so\", RTLD_NOW);\n        }\n        fprintf(stderr, \"Loaded libcrypto: %p\\n\", libcrypto);\n        if (libcrypto)\n        {\n            real_RSA_generate_key = (RSA_generate_key_t)dlsym(libcrypto, \"RSA_generate_key\");\n        }\n        fprintf(stderr, \"\\tRSA_generate_key == %p\\n\", (void*)real_RSA_generate_key);\n    }\n}\n\nvoid fini()\n{\n    if (libcrypto)\n    {\n        dlclose(libcrypto);\n        libcrypto = 0;\n        real_RSA_generate_key = 0;\n    }\n}\n\nRSA* RSA_generate_key(int bits, unsigned long e, void (*callback)(int, int, void *), void *cb_arg)\n{\n    if (!real_RSA_generate_key)\n    {\n        fprintf(stderr, \"FATAL: Have no function pointer for original RSA_generate_key()\\n\");\n        return 0;\n    }\n    fprintf(stderr, \"Calling real_RSA_generate_key(%i, %lu, %p, %p)\\n\", bits, e, callback, cb_arg);\n    RSA* ret = real_RSA_generate_key(bits, e, callback, cb_arg);\n    /* do something with ret here */\n    if (ret)\n    {\n        fprintf(stderr, \"Returned RSA key: %p ... I can do what I want with it ... MUHAHAHA!\\n\", ret);\n    }\n    return ret;\n}\n</code></pre>\n<p>Explanation:</p>\n<ul>\n<li><code>RSA_generate_key_t</code> parrots the prototype of the original function as <code>typedef</code></li>\n<li><code>real_RSA_generate_key</code> is going to hold the function pointer retrieved from the real <code>libcrypto.so</code></li>\n<li><code>libcrypto</code> is going to hold the handle to the loaded <code>libcrypto.so</code></li>\n<li><code>init()</code> -- declared as constructor -- will run when <em>our</em> wrapper <code>.so</code> gets loaded\n<ul>\n<li>it attempts to load <code>libcrypto.so.3</code></li>\n<li>failing that, attempts to load <code>libcrypto.so</code></li>\n<li>if successful in either of the preceding steps, it uses <code>dlsym()</code> to fetch the address of the real <code>RSA_generate_key</code> and stores it in <code>real_RSA_generate_key</code></li>\n<li>... also outputs the steps, something like:\n<pre><code>Loaded libcrypto: 0x7f9ad86e3700\n        RSA_generate_key == 0x7f9ad8478b50\n</code></pre>\n</li>\n</ul>\n</li>\n<li><code>finit()</code> -- declared as destructor -- will run when our wrapper <code>.so</code> gets unloaded</li>\n<li><code>RSA_generate_key()</code> is our wrapper to the original function and will be called in place of the one from <code>libcrypto.so</code> by a program that preloads this <code>.so</code></li>\n</ul>\n<h4><code>GNUmakefile</code></h4>\n<p>The GNU <code>make</code> recipes to build our stuff.</p>\n<pre><code>CC:=gcc\nCFLAGS:=$(strip -Wno-deprecated-declarations $(CFLAGS))\nall: bin so\nbin: your_binary\nso: mock_openssl_rsagenkey.so\n\nbin: LDLIBS=-lcrypto\n\nyour_binary: main.c\n        $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@\n\nso: CFLAGS=-shared -fPIC\nso: LDFLAGS=-Wl,-soname,libcrypto.so\nso: LDLIBS=-ldl\n\nmock_openssl_rsagenkey.so: mock_openssl.c\n        $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@\n\n.PHONY: all so bin\n</code></pre>\n<h4>Steps</h4>\n<ol>\n<li>write each of the above with the name I gave in the subsection titles into a file</li>\n<li>run <code>make</code> (on Debian/Ubuntu you may want to install <code>build-essential</code>, for other systems consult your documentation)</li>\n<li>invoke, e.g. with this <code>env LD_PRELOAD=./mock_openssl_rsagenkey.so ./your_binary</code></li>\n</ol>\n<h5>Output (excerpt)</h5>\n<pre><code>$ LD_PRELOAD=./mock_openssl_rsagenkey.so ./your_binary\nLoaded libcrypto: 0x7f9ad86e3700\n        RSA_generate_key == 0x7f9ad8478b50\nCalling real_RSA_generate_key(1024, 3, (nil), (nil))\nReturned RSA key: 0x55d1bfc40c10 ... I can do what I want with it ... MUHAHAHA!\nRSA Private-Key: (1024 bit, 2 primes)\nmodulus:\n    00:d2:85:86:68:fb:1f:b0:92:c7:dd:09:08:7a:39:\n    21:7e:74:27:36:08:23:0d:1f:6c:7a:ec:47:5d:fc:\n    27:c9:95:c2:a4:e1:9f:99:1b:3f:d9:f8:88:65:30:\n    93:c6:7d:2b:31:9b:b1:cb:5c:5a:b8:7a:20:c0:4b:\n    63:25:c4:3a:30:c3:81:16:56:28:ac:f7:74:93:6b:\n    93:64:db:c9:d5:0f:64:f8:15:b4:0d:18:1d:86:c1:\n    60:4b:5a:2f:2f:b7:fb:90:03:13:d5:be:1e:05:05:\n    0e:91:54:79:5b:58:2f:02:de:0a:1f:ef:06:a4:0a:\n    28:e4:55:3f:31:9d:a9:26:53\npublicExponent: 3 (0x3)\nprivateExponent:\n...\n</code></pre>\n<p>Explanation:</p>\n<ul>\n<li>Lines 1..2 are from <code>init()</code></li>\n<li>Lines 3..4 are from <code>RSA_generate_key()</code> in our wrapper <code>.so</code>\n<ul>\n<li><strong>NB:</strong> this shows you have full access to all the arguments! While it may be a little more intricate to do, it would also clearly be possible to wrap the callback mechanism provided by OpenSSL into our own, e.g.:\n<ul>\n<li>prior to calling <code>real_ RSA_generate_key()</code>, allocate a struct holding original <code>callback</code> pointer and <code>cb_arg</code></li>\n<li>pass our own callback function\n<ul>\n<li>inside our callback function unwrap the struct and pass arguments to the original callback if and as needed</li>\n</ul>\n</li>\n<li>after <code>real_ RSA_generate_key()</code> clean up the allocated struct</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>The above as Base64-encoded <code>.tar.xz</code> file for convenience:</p>\n<pre><code>/Td6WFoAAATm1rRGAgAhARwAAAAQz1jM4Cf/BCJdACOThvK+tJ2QH6+woi2u3zkiEOlUoV1cX9AZ\n+FC3A1WH7iUCMxAdurFVdxDDlniCFn58+KgLrhSGdLxvJiWTMjuOBhIYwKHirauzr5++28b5NTbw\n5OiW8LJArEPs+IWgu/EuT61aIKGLFonGy9apeCHMMEzdN9wUILkS5CNSFe5L1gKJCeVZ2PTWGqzA\nyu0nBvlpA0e7H81rA/msgoO1us3mbbQkkYuZ0lOkt5t5qn8H7c7oZe/gip3oyXmFlfJsscG2OmjK\nKmKWZbFLgb3EQuM0929MRGATHYCl5McORvugai2AeHPJRTLVTKrZC2rYj9buuEY5PH6ufW1b8NT1\nklXJkPU0gfOhGsEVcYQUMmp56aXGqzp6kq6xhAcIH+U+oEbbZBAC9QSSyFMH40nmRrPUOfIHnwhn\no/QclEtbierPsRwJMLjXS5uuz7IP1zxdOtshXJUDfmkXhj7/AIOCoLJ1PTWOIW4wq54yFSokdBUA\nlbzUk/VluIqyIx0D81HMRU2qJuptH2c28ij92+c7nHcH7M+WncwXoUPSZL2M31SUvS7DsFQkgqbM\nbeWSW2XgnV9vSKGomuCUY5vT671UD7hYddEuoR+vtJdEnEXENHfIu6rmK/3Zg9UwzYrHIMvkxm9B\nl1rxP+4C3x3Sy4qBzBup44Q7p62bVMG3CiSD2ZCkktQgeQFyPklGJLw3KriMexMoLc4eSA0EwfhU\nrr33b6n5uW3JN3pJ8IfwRW+KXS+DI0wnroLCGHdwzfXDhFPSMTaeFL4oICzQoX6gyPjLWRPciwZR\ng/2fZp9xA25j/6YP1M8i8eUcckB3Z2ispYtTsDa+D2osEcK4JAtHaDCJ/6gH3wSIJh3Dx5upaHz1\n0wQDQkS4T4O3Igf7B4wigAHWSHIih8Cl9bN8L36S5ZC58o3VeMgsLpLUkcRhf0bl6dhD113rJkqO\nG5GTlyp13YB7U2pynt9EY4TfVqCj7NvEAXHpt67MmNSqwl4c6Eslm/XplS0gTzKbP1tZo70AvkYO\noks0eYGhmE6HmcwwolqNJ3UQWkmPeUrBA5WHILHDvS3fhZkuoRgSJ+swyez8oKtOo5Y6sxGH1yDH\n0Bt5SeDmk6wErTqUb+YTDKQw1wMzY3DdeUSOny6PJumC/D9HBwmIehhDB7YxMVaQ2jcW02//bngq\nJ+zcjmBbjvKhMSOcCBVAPD7EAYyB6uerSAg4DrpsUkyYAw8+49lYe6STGKpy8OOt4OXah6WnG8/E\nGsbYlHm1RfJuMIgfYRU0+O+//xipV/q5EF/FzaQoDYuV2mPsx6TvYAganEUh78E4P9+GXBC8FsPE\nZjUrahpKmyLFm9zVmN0l3BYa20EpXmujuePO/51T3TZlxgcf5fjV87vF7BBmj8vcaVe+U02IcB1M\nZ6OAl1cAAAAAtSETkCuEMZwAAb4IgFAAAJJ1AFKxxGf7AgAAAAAEWVo=\n</code></pre>\n<hr/>\n<h3>Telling <code>ld.so</code> to preload the wrapper <code>.so</code></h3>\n<p>Bash and some other shells will be contend to do it with:</p>\n<pre><code>LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so ./your_binary\n</code></pre>\n<p>but the more portable way is:</p>\n<pre><code>env LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so ./your_binary\n</code></pre>\n<p>which uses <code>/usr/bin/env</code> -- instead of relying on a shell-builtin facility 00 to set the environment variable for a single invocation.</p>\n<p>Obviously you could also at the prompt (<code>$ </code> signifies it!) to:</p>\n<pre><code>$ export LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so\n$ ./your_binary\n</code></pre>\n<p>or on some less comfortable (or older) shells:</p>\n<pre><code>$ LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so\n$ export LD_PRELOAD\n$ ./your_binary\n</code></pre>\n<p>Last, but not least, you could create a little wrapper script, which we'll name <code>your_binary.sh</code> based on <code>your_binary</code>:</p>\n<pre><code>#!/usr/bin/env bash\nexport LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so\nexec \"${0%.sh}\" \"$@\"\n</code></pre>\n<ul>\n<li><code>#!/usr/bin/env bash</code> is the most portable hashbang, compared to hardcoding the path to a particular <code>bash</code> binary</li>\n<li><code>export LD_PRELOAD=/path/to/your/mock_openssl_rsagenkey.so</code> exports <code>LD_PRELOAD</code> as environment variable with the shown value</li>\n<li><code>exec \"${0%.sh}\" \"$@\"</code>:\n<ul>\n<li><code>\"${0%.sh}\"</code> strips the <code>.sh</code> suffix, yielding the name without it</li>\n<li><code>\"$@\"</code> expanding to the quoted arguments passed to our script (e.g. <code>\"$1\" \"$2\"</code> ...)</li>\n<li><code>exec</code> isn't strictly necessary here, but I prefer it for these small wrapper scripts; it replaces the current shell with the given command</li>\n</ul>\n</li>\n</ul>\n</div>",
            "votes": "0",
            "user": "2 revs0xC0000022L",
            "time": "Jan 18, 2023 at 10:23",
            "is_accepted": false,
            "comments": []
        }
    ]
}