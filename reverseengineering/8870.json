{
    "title": "Extracting arguments from IDA",
    "link": "https://reverseengineering.stackexchange.com/questions/8870/extracting-arguments-from-ida",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Let's say I have the following function in IDA:</p>\n<pre><code>int __usercall function&lt;eax&gt;(char* message&lt;ebp&gt;, unsigned int count&lt;edi&gt;)\n</code></pre>\n<p>What's the fastest way to extract the argument information using IDAPython, such that I get the following:</p>\n<pre><code>[['char*', 'message', 'ebp'],['unsigned int','count','edi']]\n</code></pre>\n<p>Not that it also needs to handle situations like:</p>\n<pre><code>void *__usercall sub_4508B0@&lt;rax&gt;(void *(__usercall *function)@&lt;rax&gt;(int one@&lt;eax&gt;)@&lt;rax&gt;);\n</code></pre>\n<p>Which should give me something along the lines of:</p>\n<pre><code>[['void * ...', 'function', 'rax']]\n</code></pre>\n</div>",
    "votes": "10",
    "answers": 2,
    "views": "6k",
    "tags": [
        "ida",
        "disassembly",
        "idapython",
        "python"
    ],
    "user": "Zach Riggle",
    "time": "May 12, 2015 at 7:32",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I received an answer from HexRays support which has a solution which does not rely on parsing the C string retrieved by <code>GetType(ea)</code>.</p>\n<p>Let's imagine we start with a function prototype:</p>\n<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)\n</code></pre>\n<p>That's from an ELF file, x86 abi; stuff is passed on the stack.</p>\n<p>Then, I can do the following:</p>\n<pre><code>Python&gt;from idaapi import *\nPython&gt;tif = tinfo_t()\nPython&gt;get_tinfo2(here(), tif)\nTrue\nPython&gt;funcdata = func_type_data_t()\nPython&gt;tif.get_func_details(funcdata)\nTrue\nPython&gt;funcdata.size()\n3\nPython&gt;for i in xrange(funcdata.size()):\nPython&gt;    print \"Arg %d: %s (of type %s, and of location: %s)\" % (i, funcdata[i].name, print_tinfo('', 0, 0, PRTYPE_1LINE, funcdata[i].type, '', ''), funcdata[i].argloc.atype())\nPython&gt;\nArg 0: argc (of type int, and of location: 1)\nArg 1: argv (of type const char **, and of location: 1)\nArg 2: envp (of type const char **, and of location: 1)\n</code></pre>\n<p>Note that it tells me the location type is <code>1</code>, which corresponds\nto 'stack':\n<a href=\"https://www.hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\">https://www.hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html</a></p>\n<p>Now, let's assume I change the prototype to this:</p>\n<pre><code>.text:0804ABA1 ; int __usercall main@&lt;eip&gt;(int argc@&lt;eax&gt;, const char **argv@&lt;esp&gt;, const char **envp@&lt;edx&gt;)\n</code></pre>\n<p>Then:</p>\n<pre><code>Python&gt;get_tinfo2(here(), tif)\nTrue\nPython&gt;tif.get_func_details(funcdata)\nTrue\nPython&gt;for i in xrange(funcdata.size()):\nPython&gt;    print \"Arg %d: %s (of type %s, and of location: %s)\" % (i, funcdata[i].name, print_tinfo('', 0, 0, PRTYPE_1LINE, funcdata[i].type, '', ''), funcdata[i].argloc.atype())\nPython&gt;\nArg 0: argc (of type int, and of location: 3)\nArg 1: argv (of type const char **, and of location: 3)\nArg 2: envp (of type const char **, and of location: 3)\n</code></pre>\n<p>Argument location type is <code>3</code> now, which corresponds to 'inside\nregister'.</p>\n<p>(Then, I would have to use <code>reg1()</code> to retrieve the actual\nregister number to know <em>what</em> register the argument is\npassed in)</p>\n<p>Credit goes to Arnaud of Hex Rays.</p>\n</div>",
            "votes": "15",
            "user": "Zach Riggle",
            "time": "May 12, 2015 at 16:28",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Using the minsc plugin at <a href=\"https://github.com/arizvisa/ida-minsc/tree/persistence-refactor\" rel=\"nofollow noreferrer\">https://github.com/arizvisa/ida-minsc</a>, you can access information about a function (address, or <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/classfunc__t-members.html\" rel=\"nofollow noreferrer\"><code>func_t</code></a>) or its prototype (<a href=\"https://hex-rays.com/products/ida/support/sdkdoc/classtinfo__t-members.html\" rel=\"nofollow noreferrer\"><code>tinfo_t</code></a>) using the <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type\" rel=\"nofollow noreferrer\"><code>function.type</code></a> namespace.</p>\n<p><em>Disclaimer: I maintain the ida-minsc plugin.</em></p>\n<p>In this namespace are <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-argument\" rel=\"nofollow noreferrer\"><code>function.type.argument</code></a> (for a single parameter), which is aliased as <code>function.arg</code>, or <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-arguments\" rel=\"nofollow noreferrer\"><code>function.type.arguments</code></a> (for all parameters), which is aliased as <code>function.args</code>. For the result of a prototype, there is also the <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-result\" rel=\"nofollow noreferrer\"><code>function.type.result</code></a> namespace, which is aliased as <code>function.result</code>. These namespaces include 3 classes of functions that can be used to fetch or modify their target.</p>\n<h1>Types</h1>\n<p>The <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-argument\" rel=\"nofollow noreferrer\"><code>function.type.arg</code></a> and <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-arguments\" rel=\"nofollow noreferrer\"><code>function.type.args</code></a> namespaces can be used as a function to interact with the type of a parameter for a prototype.</p>\n<pre><code>Python&gt;func.t()\n__int64 __fastcall(char *Handle, __int64, __int64)\n\n# Get type of first parameter (0).\nPython&gt;func.arg(idc.here(), 0)\nchar *\n\n# Return a list containing the type used for each of the parameters\nPython&gt;func.args(idc.here())\n[char *, __int64, __int64]\n\n# Return the type of result, and then change it to void. Each of\n# these return their previous value if you change your mind.\nPython&gt;func.result()\n__int64\n\nPython&gt;func.result('void')\n__int64\n\n# Show the type being changed.\nPython&gt;func.t()\nvoid __fastcall(char *Handle, __int64, __int64)\n</code></pre>\n<p><em>Something worth noting about <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-type-arguments\" rel=\"nofollow noreferrer\"><code>function.type.args</code></a> is that it has the ability to change the number of function arguments depending on the length of its parameter.</em></p>\n<h1>Names</h1>\n<p>The next class of functions would be to interact with the parameter names. These are handled by the <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.argument.name\" rel=\"nofollow noreferrer\"><code>function.type.argument.name</code></a> and <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.arguments.names\" rel=\"nofollow noreferrer\"><code>function.type.arguments.names</code></a>.</p>\n<p><em>It is worth nothing that <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.arguments.names\" rel=\"nofollow noreferrer\"><code>function.type.arguments.names</code></a> does not affect the number of function parameters. Therefore it can also be used to erase all of the names associated with a function in case you only want IDA to propagate the types (rather than the parameter names). This can be combined with <a href=\"https://arizvisa.github.io/ida-minsc/tagging.html\" rel=\"nofollow noreferrer\">tags</a> to identify the changes that have been mistakenly propagated.</em></p>\n<pre><code>Python&gt;h = idc.here()\nPython&gt;func.t()\n__int64 __fastcall(char *Handle, __int64, __int64)\n\nPython&gt;func.tag('__typeinfo__')\n'void __fastcall NtUserGetProcessDpiAwarenessContext(char *Handle, __int64, __int64)' \n\n# Return the name of the first argument.\nPython&gt;func.arg.name(idc.here(), 0)\n'Handle'\n\n# Return all the names for each parameter. As opposed to using the\n# address, this acts directly on the tinfo_t for the function.\nPython&gt;func.args.names(func.type(h()))\n['Handle', '', '']\n\n# Change the name for all of the parameters for the current function.\nPython&gt;func.args.names('a b c'.split(' '))\n['Handle', '', '']\n\n# Render the full function prototype (extracting it from a tag).\nPython&gt;func.tag('__typeinfo__')\n'void __fastcall NtUserGetProcessDpiAwarenessContext(char *a, __int64 b, __int64 c)'\n\n# Remove each parameter name from the function prototype.\nPython&gt;func.t()\nvoid __fastcall(char *a, __int64 b, __int64 c)\n\nPython&gt;func.args.names([])\n['a', 'b', 'c']\n\nPython&gt;func.t()\nvoid __fastcall(char *, __int64, __int64)\n</code></pre>\n<h1>Storage</h1>\n<p>The final class of functions is for accessing the storage being used for a parameter. This is exposed via the <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.argument.storage\" rel=\"nofollow noreferrer\"><code>function.type.argument.storage</code></a> and <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.arguments.storage\" rel=\"nofollow noreferrer\"><code>function.type.arguments.storage</code></a> functions. The storage can be returned in multiple ways depending on how the prototype is defined. The most general case is a register (<a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\"><code>ALOC_REG1</code></a>) or storage location relative to the stack pointer (<a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\"><code>ALOC_STACK</code></a>). Another way is via a phrase, being an offset relative to a register (<a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\"><code>ALOC_RREL</code></a>). Some other ways are a static address (<a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\"><code>ALOC_STATIC</code></a>), a list of contiguous registers (<a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\"><code>ALOC_REG2</code></a>), or a dictionary (<a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group___a_l_o_c__.html\" rel=\"nofollow noreferrer\"><code>ALOC_DIST</code></a>)</p>\n<pre><code>Python&gt;func.t()\n__int64 __usercall@&lt;rax&gt;(unsigned int@&lt;ecx&gt;, unsigned int@&lt;edx&gt;, unsigned int@&lt;r8d&gt;, unsigned int@&lt;r9d&gt;, int, unsigned int, unsigned int)\n\nPython&gt;func.convention() == idaapi.CM_CC_SPECIAL\nTrue\n\n# Get the storage location for the 3rd parameter (2) and the result.\nPython&gt;func.arg.storage(2), func.result.storage()\n(&lt;class 'register_t' index=8 dtype=dt_dword name='r8d' position=0+32&gt;, &lt;class 'register_t' index=0 dtype=dt_qword name='rax' position=0+64&gt;) \n\n# Stringify all of the storage locations for the prototype.\nPython&gt;[\"{!s}\".format(x) for x in func.args.storage()]\n['%ecx', '%edx', '%r8d', '%r9d', 'location_t(offset=0x20, size=4)', 'location_t(offset=0x28, size=4)', 'location_t(offset=0x30, size=4)'] \n\n# Translate the location relative to the current stack pointer.\nPython&gt;func.arg.storage(5)\nlocation_t(offset=0x28, size=4)\n\nPython&gt;ins.reg.esp\n&lt;class 'register_t' index=4 dtype=dt_dword name='esp' position=0+32&gt;\n\nPython&gt;func.arg.storage(5) + ins.reg.esp\nlocation_t(offset=0xffffc404, size=4)\n</code></pre>\n<h1>Spoiled</h1>\n<p>If you need to access the spoiled registers of a prototype, you can accomplish this with the <a href=\"https://github.com/arizvisa/ida-minsc/blob/persistence-refactor/base/function.py#L3834\" rel=\"nofollow noreferrer\"><code>function.type.spoiled</code></a> function.</p>\n<pre><code>Python&gt;func.t()\n__int64 __usercall@&lt;rax&gt;(unsigned int@&lt;ecx&gt;, unsigned int@&lt;edx&gt;, unsigned int@&lt;r8d&gt;, unsigned int@&lt;r9d&gt;, int, unsigned int, unsigned int)\n\n# Verify there are no spoiled registers, then assign some by name or symbol.\nPython&gt;func.t.spoiled()\n[]\n\nPython&gt;func.t.spoiled(['eax', ins.reg.rsi])\n[]\n\nPython&gt;func.t()\n__int64 __usercall __spoils&lt;eax,rsi&gt;@&lt;rax&gt;(unsigned int@&lt;ecx&gt;, unsigned int@&lt;edx&gt;, unsigned int@&lt;r8d&gt;, unsigned int@&lt;r9d&gt;, int, unsigned int, unsigned int)\n\n# Clear the spoiled registers from the prototype.\nPython&gt;func.t.spoiled([])\n[]\n\nPython&gt;func.t()\n__int64 __usercall __spoils&lt;&gt;@&lt;rax&gt;(unsigned int@&lt;ecx&gt;, unsigned int@&lt;edx&gt;, unsigned int@&lt;r8d&gt;, unsigned int@&lt;r9d&gt;, int, unsigned int, unsigned int)\n\n# Remove the spoiled attribute entirely.\nPython&gt;func.t.spoiled(None)\n[&lt;class 'register_t' index=0 dtype=dt_dword name='eax' position=0+32&gt;, &lt;class 'register_t' index=6 dtype=dt_qword name='rsi' position=0+64&gt;]\n\nPython&gt;func.t()\n__int64 __usercall@&lt;rax&gt;(unsigned int@&lt;ecx&gt;, unsigned int@&lt;edx&gt;, unsigned int@&lt;r8d&gt;, unsigned int@&lt;r9d&gt;, int, unsigned int, unsigned int)\n</code></pre>\n<h1>Combined</h1>\n<p>Combining all of these together can be done individually or by using the <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.type.arguments.iterate\" rel=\"nofollow noreferrer\"><code>function.type.arguments.iterate</code></a> function.</p>\n<pre><code>Python&gt;for type, name, storage in zip(func.args(), func.args.names(), func.args.storage()):\nPython&gt; print([\"{!s}\".format(type), name, \"{:s}\".format(storage)])\nPython&gt;\n['unsigned int', '', 'ecx']\n['unsigned int', '', 'edx']\n['unsigned int', '', 'r8d']\n['unsigned int', '', 'r9d']\n['int', '', '0x20+4']\n['unsigned int', '', '0x28+4']\n['unsigned int', '', '0x30+4']\n\nPython&gt;for index, (name, type, storage) in enumerate(func.args.iterate()):\nPython&gt; print(index, [\"{!s}\".format(item) for item in [type, name, storage]])\nPython&gt;\n0 ['unsigned int', '', '%ecx']\n1 ['unsigned int', '', '%edx']\n2 ['unsigned int', '', '%r8d']\n3 ['unsigned int', '', '%r9d']\n4 ['int', '', 'location_t(offset=0x20, size=4)']\n5 ['unsigned int', '', 'location_t(offset=0x28, size=4)']\n6 ['unsigned int', '', 'location_t(offset=0x30, size=4)'] \n</code></pre>\n</div>",
            "votes": "0",
            "user": "Ali Rizvi-Santiago",
            "time": "Jul 22, 2024 at 17:38",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Ali Rizvi-Santiago",
                    "text": "<span class=\"comment-copy\">(Sorry for the advert on your q, ebeip90).</span>",
                    "time": null
                }
            ]
        }
    ]
}