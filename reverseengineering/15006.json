{
    "title": "Approach to extract useful information from binary file",
    "link": "https://reverseengineering.stackexchange.com/questions/15006/approach-to-extract-useful-information-from-binary-file",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The purpose of this question is to gain an understanding of the concepts behind reverse engineering and to understand what approaches may be taken to extract useful information from a binary file.</p>\n<p>I've obtained an .hex file. Then I've converted it to a binary file using <code>hex2bin</code>:</p>\n<pre><code>./hex2bin firmware.hex\n</code></pre>\n<p>Then I've searched for some readable strings:</p>\n<pre><code>strings firmaware.bin\n...\nWATT\nMODE \nTEMP \nMEMORY\n MODE \n STRENGTH\n  MIN \nSOFT\nNORM\nHARD\n MAX \nBLUETOOTH\n   ON    \n   OFF   \n   LED   \nSTEALTH\n OFF  \n  ON  \n  TODAY\n...\n</code></pre>\n<p>I've also tried to run <code>binwalk</code>, but the output is blank:</p>\n<pre><code>    binwalk firmware.bin \n\n    DECIMAL       HEXADECIMAL     DESCRIPTION\n    --------------------------------------------------------------------------------\n</code></pre>\n<p>First question: why is the output is blank?</p>\n<p>I've also tried to check the entropy to guess if the file is encrypted or compressed.</p>\n<pre><code>binwalk -E firmware.bin\n</code></pre>\n<p><a href=\"https://i.sstatic.net/WYvtS.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.sstatic.net/WYvtS.png\"/></a></p>\n<p>As suggested in another answer, I proceeded to use radare2 in order to find the original ARM code (I'm totally new to this tool); in particular I want to extract all the functions used in this file:</p>\n<pre><code>radare2 -A -arm -b 32 firmware.bin \n[x] Analyze all flags starting with sym. and entry0 (aa)\n[x] Analyze len bytes of instructions for references (aar)\n[x] Analyze function calls (aac)\n[ ] [*] Use -AA or aaaa to perform additional experimental analysis.\n[x] Constructing a function name for fcn.* and sym.func.* functions (aan))\n -- Step through your seek history with the commands 'u' (undo) and 'U' (redo)\n[0x00000000]&gt; aa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n[0x00000000]&gt; afl\n0x00000000    1 10           fcn.00000000\n0x0000000a    3 108          fcn.0000000a\n0x00000142    1 3            fcn.00000142\n0x00000c02    1 2            fcn.00000c02\n0x00002b0f    1 41           fcn.00002b0f\n0x00004319    1 8            fcn.00004319\n0x00004321    1 67           fcn.00004321\n0x000055f0    1 3            fcn.000055f0\n0x000059f0    1 11           fcn.000059f0\n0x00005b0e    1 3            fcn.00005b0e\n0x00006971    1 49           fcn.00006971\n0x00006c9a    1 7            fcn.00006c9a\n0x00007020    6 353  -&gt; 356  fcn.00007020\n0x00007663    5 70   -&gt; 100  fcn.00007663\n0x000082d3    1 110          fcn.000082d3\n0x0000886b    3 56           fcn.0000886b\n0x00009360   43 783  -&gt; 716  fcn.00009360\n0x0000990e    3 28   -&gt; 34   fcn.0000990e\n0x0000b7f0    7 230  -&gt; 238  fcn.0000b7f0\n0x0000c130    2 40           fcn.0000c130\n0x0000e00c    9 393  -&gt; 239  fcn.0000e00c\n0x0000e017    9 382  -&gt; 228  fcn.0000e017\n</code></pre>\n<p>Question two: these functions are used in the .bin file (so in the original source code), am I correct?</p>\n<p>Question three: How can I extract the data where the strings found are used?</p>\n<p>Question four: What useful information can be extracted from this file?</p>\n<p>At this point I am stuck. I'm a newcomer, so I would like to learn how to approach a situation in which I don't get useful information from a tool (like <code>binwalk</code>). So, if someone could suggest to me what steps should be taken in order to extract useful information (by this I mean pointing out concepts to understand, where to find information, useful resources, books and so on), and I would greatly appreciate it. If someone could show me how to proceed with this file, that would be great, so I can see directly some results and proceed with my study.</p>\n<p>Thanks in advance.</p>\n<p>Here is the file: <a href=\"http://www.3fvape.com/images/3fvape-blog-img/20150806-4384-xcubeII-upgrade/SMOK_X_CUBE_II_firmware_v1.07.hex\" rel=\"noreferrer\">http://www.3fvape.com/images/3fvape-blog-img/20150806-4384-xcubeII-upgrade/SMOK_X_CUBE_II_firmware_v1.07.hex</a> \nThe source file is in intel 32 bit .hex format and is for ARM Cortex-M0.</p>\n</div>",
    "votes": "18",
    "answers": 1,
    "views": "24k",
    "tags": [
        "binary-analysis",
        "firmware",
        "arm",
        "hex",
        "binary"
    ],
    "user": "Light123",
    "time": "Mar 25, 2017 at 4:00",
    "comments": [
        {
            "user": "Sandeep Singh",
            "text": "<span class=\"comment-copy\">how to locate the part of firmware code stores the device password ?</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<h3>General Prerequisites</h3>\n<p>When analyzing binaries, it is important to be able to put what is observed into context. For example, how can CPU instructions be differentiated from data in a binary with a non-standard format? This requires some background knowledge of computer systems in general. I would argue that before any attempt at reverse engineering firmware is made, at least basic familiarity with the following concepts is required:</p>\n<ul>\n<li><p><strong>Computer architecture / computer system organization</strong></p>\n<ul>\n<li>CPU design and function (e.g. registers, the instruction pointer, memory access)</li>\n<li>memory and the memory hierarchy </li>\n<li>instruction sets, assembly, opcodes, addressing modes, syntax, mnemonics</li>\n<li>information representation (binary, hex, endianness)</li>\n</ul></li>\n<li><p><strong>Operating system concepts</strong></p>\n<ul>\n<li>Virtual memory</li>\n<li>usermode vs kernelmode, the kernel, the kernel interface (system calls)</li>\n<li>process layout in memory - stack, heap, data, instructions</li>\n<li>executable formats</li>\n<li>application binary interfaces</li>\n<li>program entry points</li>\n</ul></li>\n<li><p><strong>source code to object code transformation</strong></p>\n<ul>\n<li>compilation, assembly, linking</li>\n<li>C/C++ programming</li>\n<li>Assembly programming</li>\n<li>source-to-assembly construct correlation (e.g. recognition of loop, switch constructs in assembly)</li>\n<li>disassembly vs decompilation</li>\n</ul></li>\n</ul>\n<p>My advice is the following:</p>\n<ul>\n<li>read as much as you can: technical specifications, assembly/disassembly, answers to firmware RE questions, research papers, tutorials, blogs, textbooks, manual pages</li>\n<li>emulate/copy the methodologies employed and approaches taken by pros</li>\n<li>gain experience as quickly as possible: look at and experiment with many different types of files (executables, image files, compressed files, firmware, etc.), program in assembly to get a feel for it, disassemble many executables</li>\n</ul>\n<h3>Firmware RE Resources</h3>\n<p>\"<a href=\"http://hexblog.com/files/recon%202010%20Skochinsky.pdf\" rel=\"noreferrer\">Intro to Embedded Reverse Engineering \nfor PC reversers</a>\" by Igor Skochinsky provides an overview of what is involved in reversing firmware, and in \"<a href=\"https://media.blackhat.com/us-13/US-13-Zaddach-Workshop-on-Embedded-Devices-Security-and-Firmware-Reverse-Engineering-Slides.pdf\" rel=\"noreferrer\">Embedded Devices Security: Firmware Reverse Engineering</a>\" Jonas Zaddach and Andrei Costin outline a general methodology for reversing firmware beginning on slide 31.</p>\n<p>Look at answers given by pros:</p>\n<ul>\n<li><a href=\"https://reverseengineering.stackexchange.com/users/1408/devttys0?tab=answers\">devttys0</a></li>\n<li><a href=\"https://reverseengineering.stackexchange.com/users/12325/ebux?tab=answers\">ebux</a></li>\n<li><a href=\"https://reverseengineering.stackexchange.com/users/60/igor-skochinsky?tab=answers\">Igor Skochinsky</a></li>\n<li><a href=\"https://reverseengineering.stackexchange.com/users/4212/6equj5?tab=answers\">6EQUJ5</a></li>\n</ul>\n<p>These may be useful or interesting:</p>\n<p><a href=\"http://www.devttys0.com/blog/\" rel=\"noreferrer\">devttys0's blog</a></p>\n<p><a href=\"http://ea.github.io/\" rel=\"noreferrer\">ea's blog</a></p>\n<p><a href=\"http://igorsk.blogspot.com/\" rel=\"noreferrer\">Igor's blog</a></p>\n<p><a href=\"http://firmware.re/\" rel=\"noreferrer\">firmware.re</a></p>\n<p><a href=\"http://blog.ioactive.com/\" rel=\"noreferrer\">IOActive Labs Research blog</a></p>\n<p><a href=\"https://sviehb.wordpress.com/\" rel=\"noreferrer\">sviehb's blog</a></p>\n<p>Embedded systems often use MIPS or ARM processors, and by extension MIPS or ARM instruction sets. This means that being familiar with MIPS and ARM assembly will be very helpful when analyzing firmware for these systems.</p>\n<h1>Analyzing the binary</h1>\n<h2>Part 1: Identification of the target device's architecture</h2>\n<p>We cannot rely on hearsay to obtain the information required to analyze the firmware. Validity of information about the firmware must be proven by using empirical evidence. It is not enough to have a binary blob from a second-hand source and a processor name from a different question.</p>\n<h3>1. Identify the target device</h3>\n<p>Fortunately in this case it is easy to at least get the device name: SMOK X Cube II. When the vendor's <a href=\"http://www.smoktech.com/support/upgrade/toolsandfirmware\" rel=\"noreferrer\">firmware and tools support page</a> is examined it turns out that there is a real device with that name. The .hex file is bundled with an upgrade tool from <a href=\"http://www.nuvoton.com/hq/?__locale=en\" rel=\"noreferrer\">Taiwanese semiconductor manufacturer Nuvoton</a> called \"<a href=\"http://www.smoktech.com/support/upgrade/toolsandfirmware/ispxcubeii\" rel=\"noreferrer\">NuMicro ISP Programming Tool</a>\":</p>\n<pre><code>~/firmware/e-cig/XCUBE II upgrading tool $ file *\nconfig.ini:                                            ASCII text, with CRLF line terminators\nNuMicro ISP Programming Tool.exe:                      PE32 executable (GUI) Intel 80386, for MS Windows\nNuMicro ISP Programming Tool User's Guide.pdf:         PDF document, version 1.5\nXCUBE II-VIVI-52 (160616)V.1.098(checksum=0x28F9).hex: ASCII text, with CRLF line terminators\n</code></pre>\n<p>This hex file is straight from the manufacturer of the device processor rather than from a second-hand source. It is also a newer version - v1.098 rather than v1.07. I decided to analyze the older firmware version (v1.07) since this is the version of the binary in the question.</p>\n<p><a href=\"https://i.sstatic.net/zKRh9.png\" rel=\"noreferrer\"><img alt=\"Upgrade tool pic 1\" src=\"https://i.sstatic.net/zKRh9.png\"/></a></p>\n<h3>2. Identify the processor</h3>\n<p>There are some interesting things in the pictures used to describe the upgrade process: the name <strong>NuMicro</strong> and the acronym <strong>ISP</strong> in the tool name, the term <strong>DataFlash</strong>,  a reference to something called <strong>APROM</strong>, and most importantly, the part number: <strong>NUC220LE3AN</strong>. What \"part\" is this a number for? <a href=\"http://www.nuvoton.com/hq/products/microcontrollers/arm-cortex-m0-mcus/nuc120-122-123-220-usb-series/nuc220le3an/?__locale=en\" rel=\"noreferrer\">A Nuvoton-developed microcontroller</a> based on ARM's Cortex-M0 processor.</p>\n<h3>3. Identify the instruction set architecture</h3>\n<p>Nuvoton is kind enough freely share technical documentation for the NuMicro NUC220 series, including the <a href=\"http://www.nuvoton.com/resource-files/DS_NUC200_220%28AN%29_EN_Rev1.00.pdf\" rel=\"noreferrer\">datasheet</a> and the <a href=\"http://www.nuvoton.com/resource-files/TRM_NUC200_220%28AN%29_Series_EN_V1.02.pdf\" rel=\"noreferrer\">technical reference manual</a>, in addition to various software tools and training materials (click on the \"Resources\" tab at the top of the NUC220LE3AN product page).</p>\n<p>From the datasheet, Section 1: \"General Description\", page 7 (emphasis mine):</p>\n<blockquote>\n<p>The NuMicro NUC200 Series <strong>32-bit microcontrollers</strong> is embedded with the newest ARM® Cortex™-M0  core with a cost equivalent to traditional 8-bit MCU for industrial control and applications requiring rich communication interfaces. The NuMicro NUC200 Series includes NUC200 and NUC220 product lines. </p>\n</blockquote>\n<p>Is this enough information to conclude that the code in the firmware binary consist of 32-bit ARM instructions? <strong>No, it is not</strong>. Let us look closely at the functional description of the processor (Chapter 6: Functional Description, section 1: ARM Cortex-M0 Core, page 48):</p>\n<p><a href=\"https://i.sstatic.net/nKdiK.png\" rel=\"noreferrer\"><img alt=\"Processor functional description\" src=\"https://i.sstatic.net/nKdiK.png\"/></a>\n<a href=\"https://i.sstatic.net/GYpKJ.png\" rel=\"noreferrer\"><img alt=\"Processor instruction set\" src=\"https://i.sstatic.net/GYpKJ.png\"/></a></p>\n<p>Let us take special note of the following information:</p>\n<ul>\n<li><blockquote>\n<p>The  processor can  execute  Thumb  code  and  is  compatible  with  other Cortex®-M profile  processor. </p>\n</blockquote></li>\n<li><blockquote>\n<p>ARMv6-M Thumb® instruction set</p>\n</blockquote></li>\n<li><blockquote>\n<p>Thumb-2 technology</p>\n</blockquote></li>\n</ul>\n<p>Note that the processor is an ARM Cortex-M0 Core and not ARM Cortex-M0+ Core, which has a different instruction set.</p>\n<p>From ARM's <a href=\"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0432c/CHDCICDF.html\" rel=\"noreferrer\">Cortex-M0 technical reference manual</a>:</p>\n<blockquote>\n<p>The processor implements the ARMv6-M Thumb instruction set, including a number of 32-bit instructions that use Thumb-2 technology. The ARMv6-M instruction set comprises:</p>\n<ul>\n<li><p>all of the 16-bit Thumb instructions from ARMv7-M excluding CBZ, CBNZ and IT</p></li>\n<li><p>the 32-bit Thumb instructions BL, DMB, DSB, ISB, MRS and MSR.</p></li>\n</ul>\n</blockquote>\n<p>What is \"Thumb code\" and the \"Thumb instruction set\"?</p>\n<p>From \"<a href=\"http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb\" rel=\"noreferrer\">Introduction to ARM thumb</a>\" by Joe Lemieux (emphasis mine):</p>\n<blockquote>\n<p>The Thumb instruction set consists of <strong>16-bit instructions</strong> that act as\n  a compact shorthand for a subset of the 32-bit instructions of the\n  standard ARM. Every Thumb instruction could instead be executed via\n  the equivalent 32-bit ARM instruction. However, not all ARM\n  instructions are available in the Thumb subset; for example, there's\n  no way to access status or coprocessor registers. Also, some functions\n  that can be accomplished in a single ARM instruction can only be\n  simulated with a sequence of Thumb instructions.</p>\n<p>At this point, you may ask why have two instruction sets in the same\n  CPU? But really the ARM contains only one instruction set: the 32-bit\n  set. When it's operating in the Thumb state, the processor simply\n  expands the smaller shorthand instructions fetched from memory into\n  their 32-bit equivalents.</p>\n<p>The difference between two equivalent instructions lies in how the\n  instructions are fetched and interpreted prior to execution, not in\n  how they function. <strong>Since the expansion from 16-bit to 32-bit\n  instruction is accomplished via dedicated hardware within the chip, it\n  doesn't slow execution even a bit. But the narrower 16-bit\n  instructions do offer memory advantages.</strong></p>\n<p>The Thumb instruction set provides most of the functionality required\n  in a typical application. Arithmetic and logical operations,\n  load/store data movements, and conditional and unconditional branches\n  are supported. <strong>Based upon the available instruction set, any code\n  written in C could be executed successfully in Thumb state.</strong> However,\n  device drivers and exception handlers must often be written at least\n  partly in ARM state.</p>\n</blockquote>\n<p>Here is a good explanation from SO: <a href=\"https://stackoverflow.com/questions/28669905/arm-thumb-and-thumb-2-instructions-confusion/28670713#28670713\">ARM, Thumb and Thumb 2 instructions confusion</a></p>\n<p>From the <a href=\"https://www.scss.tcd.ie/~waldroj/3d1/arm_arm.pdf\" rel=\"noreferrer\">ARMv6-M Architecture Reference Manual</a>, Chapter A5:The Thumb Instruction Set Encoding, section 1: Thumb instruction set encoding, page 82:</p>\n<p><a href=\"https://i.sstatic.net/xJOrU.png\" rel=\"noreferrer\"><img alt=\"Thumb instruction set encoding\" src=\"https://i.sstatic.net/xJOrU.png\"/></a></p>\n<p>Additionally:</p>\n<blockquote>\n<p>The NuMicro NUC200 Series only supports little-endian data format.</p>\n</blockquote>\n<p><a href=\"https://i.sstatic.net/H5dKc.png\" rel=\"noreferrer\"><img alt=\"System memory map\" src=\"https://i.sstatic.net/H5dKc.png\"/></a></p>\n<p>To summarize: the code in the firmware binary will consist of little-endian 16-bit ARM Thumb instructions plus a few 32-bit Thumb2 instructions to be executed by a 32-bit ARM Cortex-M0 processor implementing the ARM 16-bit Thumb instruction set with support for Thumb2. </p>\n<h3>4. Identify the device's memory layout</h3>\n<p>Access to the technical reference manual allows us to determine what APROM and ISP are. From Chapter 6: Functional Description, section 4.4.1: Flash Memory Organization, page 191:</p>\n<blockquote>\n<p>The NuMicro NUC200 Series flash memory consists of program memory (APROM), Data Flash, ISP loader program memory (LDROM), and user configuration. Program memory is main memory for  user  applications and called  APROM. User  can write their application to APROM and set system to boot from APROM.</p>\n<p>ISP  loader  program  memory  is  designed  for  a  loader  to  implement In-System-Programming function.  LDROM  is  independent  to  APROM  and system  can  also  be  set  to  boot  from  LDROM. Therefore, user can user LDROM to avoid system boot fail when code of APROM was corrupted.</p>\n</blockquote>\n<p>And from Chapter 6: Functional Description, section 4.4.5: In-System-Programming (ISP), page 199:</p>\n<blockquote>\n<p>ISP provides the ability to update system firmware on board. Various peripheral interfaces let ISP loader in LDROM to receive new program code easily. The most common method to perform ISP is  via  UART  along  with  the ISP  loader in  LDROM.  General  speaking,  PC  transfers  the  new APROM  code  through  serial  port.  Then ISP  loader receives  it  and  re-programs  into  APROM through ISP commands.</p>\n</blockquote>\n<p>According to the information in the <code>config.ini</code> file bundled with the NuMicro ISP Programming Tool, flash memory size of the APROM segment is 128 KB:</p>\n<pre><code>$ cat config.ini | grep NUC200LE3AN -B2 -A3\n\n[0x00020000]\nNAME_STRING = NUC200LE3AN\nRAM_SIZE = 16\nFLASH_SIZE = 128\n</code></pre>\n<p>Here is a diagram of the flash memory address map:</p>\n<p><a href=\"https://i.sstatic.net/okKY3.png\" rel=\"noreferrer\"><img alt=\"flash memory address map\" src=\"https://i.sstatic.net/okKY3.png\"/></a></p>\n<p>We know that the space from 0x0000_0000 to 0x0001_FFFF = 131071 bytes, which is 128 KB, and this is the region to which the binary from the hex file will be flashed to using the upgrade tool. Above that there is a block of memory from 0x0002_0000 to 0x0010_000 which is labeled \"Reserved for Further Used\". The size of this \"Reserved\" space is 0x0010_0000 - 0x0002_0000 = 0xE0000, or 917504 bytes. This is almost 1 megabyte of reserved space. The 128 KB reserved for APROM makes up 12.5% of the address space between 0x0000_0000 and 0x0010_0000, but is represented as being larger than the ~1 MB \"Reserved\" block. This is very strange. There is also no documentation of this reserved block anywhere in the technical reference manual that I could find. If one had physical access to the device, perhaps the contents of flash memory could be dumped and analyzed to find out what lies in this region.</p>\n<p>Since the firmware binary is written to space in flash memory reserved for user applications, it seems unlikely that the firmware binary contains kernel code, bootloader code or a filesystem. This is different from router firmware, which tends to at the very least contain kernel code.</p>\n<h2>Part 2: Direct analysis of the binary</h2>\n<p>Quick recap of what we know at this point:</p>\n<ul>\n<li>The device name - SMOK X Cube II </li>\n<li>The processor - A NuMicro NUC220LE3AN processor, based on an ARM Cortex-M0 Core processor</li>\n<li>The instruction set architecture - little-endian ARM-v6 M 16-bit Thumb</li>\n<li>The location in flash memory to which the firmware will be written - the 128KB APROM region for user applications (in other words, not the kernel)</li>\n<li>NuMicro is a Taiwan-based company. We will see why this is potentially relevant shortly.</li>\n<li>The entropy plot generated by <code>binwalk</code>  included in the question reveals that there are no encrypted or compressed regions in the firmware</li>\n<li>Based on information included in the question, there exist ASCII strings embedded in the file that appear to be related to the functionality of the device </li>\n</ul>\n<p>Potential complications:</p>\n<ul>\n<li>firmware binaries do not have a standard format like executable binaries do</li>\n<li>Data may be intermingled with code/instructions within the binary. If this is the case, it is possible that data such as strings will be disassembled as instructions, resulting in an incorrect representation of the firmware's code</li>\n</ul>\n<h3>Preliminary analysis</h3>\n<p><strong>1. <code>strings</code> and <code>hexdump</code></strong></p>\n<p>The output of strings can be used to quick heuristic in determining if the firmware is encrypted/compressed. If there are no strings in the output, it is a good indicator that the entire file is obfuscated somehow. <code>hexdump</code> with the -C argument can be used to provide some context for the strings i.e. where in the binary they are relative to code and relative to each other. In other words, are the strings packed together in a single block, or are they scattered throughout the binary? The answer can provide clues about the layout of the firmware.</p>\n<p>Using <code>hexump</code>, we see that the ASCII strings are intermingled with what might be code:</p>\n<pre><code>00002ed0  01 21 1b 20 fd f7 6e fe  21 46 38 6a 09 f0 16 fd  |.!. ..n.!F8j....|\n00002ee0  64 21 09 f0 13 fd 08 46  0a 21 09 f0 0f fd 10 30  |d!.....F.!.....0|\n00002ef0  14 21 48 43 42 19 01 21  25 20 fd f7 5b fe 73 e0  |.!HCB..!% ..[.s.|\n00002f00  68 e2 88 e0 57 41 54 54  0a 00 00 00 4d 4f 44 45  |h...WATT....MODE|\n00002f10  0a 00 00 00 7c db 00 00  88 db 00 00 54 45 4d 50  |....|.......TEMP|\n00002f20  0a 00 00 00 4d 45 4d 4f  52 59 0a 00 20 4d 4f 44  |....MEMORY.. MOD|\n00002f30  45 20 0a 00 ac 01 00 20  53 54 52 45 4e 47 54 48  |E ..... STRENGTH|\n00002f40  0a 00 00 00 3c 0b 00 20  20 4d 49 4e 20 0a 00 00  |....&lt;..  MIN ...|\n00002f50  53 4f 46 54 0a 00 00 00  4e 4f 52 4d 0a 00 00 00  |SOFT....NORM....|\n00002f60  48 41 52 44 0a 00 00 00  20 4d 41 58 20 0a 00 00  |HARD.... MAX ...|\n00002f70  ea cf 00 00 42 4c 55 45  54 4f 4f 54 48 0a 00 00  |....BLUETOOTH...|\n00002f80  20 20 20 4f 4e 20 20 20  20 0a 00 00 20 20 20 4f  |   ON    ...   O|\n00002f90  46 46 20 20 20 0a 00 00  ea d0 00 00 20 20 20 4c  |FF   .......   L|\n00002fa0  45 44 20 20 20 0a 00 00  6a d1 00 00 53 54 45 41  |ED   ...j...STEA|\n00002fb0  4c 54 48 0a 00 00 00 00  20 4f 46 46 20 20 0a 00  |LTH..... OFF  ..|\n00002fc0  20 20 4f 4e 20 20 0a 00  20 20 54 4f 44 41 59 20  |  ON  ..  TODAY |\n00002fd0  20 0a 00 00 80 96 98 00  f6 e1 00 00 83 e5 00 00  | ...............|\n00002fe0  a0 86 01 00 10 27 00 00  21 46 38 6a 09 f0 8e fc  |.....'..!F8j....|\n00002ff0  0a 21 09 f0 8b fc 10 31  14 20 41 43 4a 19 01 21  |.!.....1. ACJ..!|\n</code></pre>\n<p>another group of ASCII strings elsewhere in the binary:</p>\n<pre><code>00004f70  84 e0 04 f0 40 fe 00 28  13 d0 00 20 03 f0 ec ff  |....@..(... ....|\n00004f80  1e 49 80 31 08 69 88 61  35 4a 90 42 00 d3 8c 61  |.I.1.i.a5J.B...a|\n00004f90  88 69 08 62 33 48 06 23  04 22 00 90 19 46 00 20  |.i.b3H.#.\"...F. |\n00004fa0  62 e0 6b e0 20 43 48 45  43 4b 20 20 0a 00 00 00  |b.k. CHECK  ....|\n00004fb0  41 54 4f 4d 49 5a 45 52  0a 00 00 00 f6 e0 00 00  |ATOMIZER........|\n00004fc0  28 03 00 20 ac 01 00 20  7a e0 00 00 20 20 43 48  |(.. ... z...  CH|\n00004fd0  45 43 4b 20 20 0a 00 00  10 4b 00 00 ba e0 00 00  |ECK  ....K......|\n00004fe0  44 4f 4e 27 54 0a 00 00  41 42 55 53 45 0a 00 00  |DON'T...ABUSE...|\n00004ff0  50 52 4f 54 45 43 54 53  21 0a 00 00 3c 0b 00 20  |PROTECTS!...&lt;.. |\n00005000  20 57 41 54 54 20 0a 00  2c 2f 00 00 60 ea 00 00  | WATT ..,/..`...|\n00005010  36 e1 00 00 2d 53 48 4f  52 54 2d 20 0a 00 00 00  |6...-SHORT- ....|\n00005020  b2 eb 00 00 88 13 00 00  20 53 48 4f 52 54 20 20  |........ SHORT  |\n00005030  0a 00 00 00 81 0b 00 00  49 53 20 4e 45 57 0a 00  |........IS NEW..|\n00005040  43 4f 49 4c 3f 20 0a 00  59 0a 00 00 4e 0a 00 00  |COIL? ..Y...N...|\n00005050  7c db 00 00 88 db 00 00  dc 05 00 00 a0 db 00 00  ||...............|\n00005060  0f 27 00 00 94 db 00 00  fb f7 e0 fd 28 46 fd f7  |.'..........(F..|\n00005070  a1 f8 fb f7 f0 fe 07 20  fd f7 08 fb af 20 fb f7  |....... ..... ..|\n00005080  2f ff 00 20 fb f7 30 ff  38 bd ff 49 08 60 70 47  |/.. ..0.8..I.`pG|\n00005090  fe 49 88 72 70 47 fd 48  80 7a 70 47 10 b5 13 24  |.I.rpG.H.zpG...$|\n</code></pre>\n<p>more ASCII strings elsewhere:</p>\n<pre><code>00005490  44 2f 00 00 34 0c 00 20  a0 db 00 00 88 db 00 00  |D/..4.. ........|\n000054a0  94 db 00 00 7c db 00 00  ea d5 00 00 36 0a 00 00  |....|.......6...|\n000054b0  2e 0a 00 00 50 4f 57 45  52 0a 00 00 20 4f 46 46  |....POWER... OFF|\n000054c0  20 0a 00 00 20 20 4f 4e  20 0a 00 00 e7 03 00 00  | ...  ON .......|\n000054d0  0f 27 00 00 9f 86 01 00  33 08 00 00 5f db 00 00  |.'......3..._...|\n000054e0  fb f7 a4 fb fd 49 20 68  07 f0 10 fa 7d 27 08 46  |.....I h....}'.F|\n000054f0  ff 00 39 46 07 f0 0a fa  f9 4e 00 01 80 19 01 22  |..9F.....N.....\"|\n</code></pre>\n<p>There are several more such clusters of ASCII strings in different parts of the file. Some of the ASCII strings are mentioned in the <a href=\"http://7xjcby.com2.z0.glb.qiniucdn.com/file/14649402661940c5xxzme3pi4quxr.png\" rel=\"noreferrer\">product manual</a>:</p>\n<p><a href=\"https://i.sstatic.net/Sr1Ox.png\" rel=\"noreferrer\"><img alt=\"strings in product manual\" src=\"https://i.sstatic.net/Sr1Ox.png\"/></a></p>\n<p>However, many of the ASCII strings in the binary are not mentioned in the manual, such as these:</p>\n<pre><code>00009d00  21 b0 f0 bd 00 01 00 50  00 ff 01 00 b4 ed 00 00  |!......P........|\n00009d10  43 12 67 00 45 52 52 4f  52 3a 20 20 20 0a 00 00  |C.g.ERROR:   ...|\n00009d20  4e 4f 20 53 45 43 52 45  54 0a 00 00 2d 4b 45 59  |NO SECRET...-KEY|\n00009d30  21 20 20 20 20 0a 00 00  ef 48 00 68 c0 07 c0 0f  |!    ....H.h....|\n</code></pre>\n<p>Visualization of the binary also shows that byte sequences that fall within the <a href=\"http://www.asciitable.com/\" rel=\"noreferrer\">ASCII range</a> are scattered throughout the binary (blue is ASCII):</p>\n<p><a href=\"https://i.sstatic.net/9yJuK.png\" rel=\"noreferrer\"><img alt=\"binary visualization by byteclass\" src=\"https://i.sstatic.net/9yJuK.png\"/></a></p>\n<p><strong>2. Taking the locale the firmware was developed in into consideration</strong></p>\n<p>The firmware, the upgrade tool and the microcontroller are all developed by Nuvoton, a Taiwanese company. Perhaps there are sequences of traditional Chinese characters in the binary as well.</p>\n<p>By default, <code>strings</code> searches for ASCII character sequences and the -C option for <code>hexdump</code> prints bytes within the ASII range as ASCII characters. But what if there are <a href=\"https://docs.python.org/3/howto/unicode.html\" rel=\"noreferrer\">Unicode</a>-encoded strings in the binary in addition to ASCII-encoded strings? Radare2 can be used to search for strings in the hex file directly, rather than relying on the output of a different tool (<a href=\"https://www.suse.com/communities/blog/making-sense-hexdump/\" rel=\"noreferrer\">hexdump is pretty flexible</a> but it is faster to use radare2). To search for strings, the <a href=\"https://github.com/pwntester/cheatsheets/blob/master/radare2.md\" rel=\"noreferrer\"><code>izz</code></a> commands will be used to search for strings throughout the binary:</p>\n<pre><code>$ r2 ihex://SMOK_X_CUBE_II_firmware_v1.07.hex\n -- I am Pentium of Borg. Division is futile. You will be approximated.\n[0x00000000]&gt; izz\nDo you want to print 1444 lines? (y/N)   &lt;--- enter \"y\", obviously\n</code></pre>\n<p>This has some potentially interesting results:</p>\n<pre><code>vaddr=0x0000aa95 paddr=0x0000aa95 ordinal=1093 sz=28 len=13 section=unknown type=wide string=h(胐恇ԇӕ栠だi(胐⁇ԇ\nvaddr=0x0000aab5 paddr=0x0000aab5 ordinal=1094 sz=54 len=26 section=unknown type=wide string=i(胐ⱇ潩ᄆHhШ⣐ࡉ⡀ѡ⣠ũड蠅⡃灡h(胐\nvaddr=0x0000aaef paddr=0x0000aaef ordinal=1095 sz=10 len=4 section=unknown type=wide string=Hh̨⣐\nvaddr=0x0000ab07 paddr=0x0000ab07 ordinal=1096 sz=62 len=30 section=unknown type=wide string=h(胐ᄆ탕HhШ棐칩ࡉ桀ѡ棠ũड蠅桃灡i(胐༂웕Hh̨棐\nvaddr=0x0000ab53 paddr=0x0000ab53 ordinal=1097 sz=70 len=34 section=unknown type=wide string=i(胐삵汍쁨ԇǐ栠だh(胐ꁇԇ˕栠끠h(胐恇ԇӕ栠だi(胐⁇ԇ\nvaddr=0x0000ab9d paddr=0x0000ab9d ordinal=1098 sz=58 len=28 section=unknown type=wide string=i(胐ⱇ潩ᄆ꧕HhШ⣐ꡩࡉ⡀ѡ⣠ũड蠅⡃灡h(胐ꈂཌ\nvaddr=0x0000abd7 paddr=0x0000abd7 ordinal=1099 sz=10 len=4 section=unknown type=wide string=Hh̨⣐\nvaddr=0x0000abef paddr=0x0000abef ordinal=1100 sz=62 len=30 section=unknown type=wide string=h(胐ᄆ雕HhШ棐鑩ࡉ桀ѡ棠ũड蠅桃灡i(胐༂賕Hh̨棐\nvaddr=0x0000ac3b paddr=0x0000ac3b ordinal=1101 sz=22 len=10 section=unknown type=wide string=i(胐袽腈ཨሢᄅ腃\n</code></pre>\n<p>I cannot read these characters, so I do not know what language they are from. Maybe it is just gibberish.</p>\n<p><strong>3. Using a hex editor</strong></p>\n<p>A <a href=\"http://home.gna.org/bless/\" rel=\"noreferrer\">hex editor with a GUI</a> can be used to quickly search for patterns in the data. For example, the byte <code>0A</code> looks like it is used as a terminating character for ASCII strings:</p>\n<p><a href=\"https://i.sstatic.net/QUDZQ.png\" rel=\"noreferrer\"><img alt=\"0A ASCII string terminating character\" src=\"https://i.sstatic.net/QUDZQ.png\"/></a></p>\n<h3>Disassembly</h3>\n<p>So how should the binary be disassembled using r2? Are any there any special arguments or commands for 16-bit ARM Thumb instructions + some 32-bit Thumb2 instructions? </p>\n<p>From <a href=\"https://github.com/radare/radare2/issues/3433\" rel=\"noreferrer\">How to disassemble to ARM UAL?</a>:</p>\n<blockquote>\n<p>-b16 is asumed for thumb, not because the instruction size or the register size. Its an exception to make things simpler. Because its\n  just a mode of the cpu.</p>\n<p>-b16 sets thumb2 mode in capstone disassembler (as well as in gnu). Thumb2 contains 2 byte and 4 byte instruction lengths. Thumb was only\n  2. But thumb and thumb2 are binarynl compatible, so it makes sense to use thumb2 here, unless the cpu doesnt supports it.</p>\n<p>From what i understand from ual is that this ist just a syntax, and\n  this symtax should be ready in capstone.</p>\n<p>Capstone knows nothing about code or data. It just disassembles.</p>\n</blockquote>\n<p>In order to properly disassemble the file, it is critical that the correct architecture is specified:</p>\n<blockquote>\n<p>-b bits     force asm.bits (16, 32, 64)</p>\n</blockquote>\n<p>For this firmware binary, <code>-b 16</code> should be used, <strong>not <code>-b 32</code></strong>: </p>\n<p><code>$ r2 -a arm -b 16 ihex://SMOK_X_CUBE_II_firmware_v1.07.hex</code> </p>\n<p>If <code>-b 32</code> is used, the result is quite a bit of byte sequences r2 reads as invalid due to misalignment:\n<a href=\"https://i.sstatic.net/nibzc.png\" rel=\"noreferrer\"><img alt=\"invalid disassembly\" src=\"https://i.sstatic.net/nibzc.png\"/></a></p>\n<p>For reference, here is disassembly beginning at the same offset, <code>0x1e8</code>, with proper 16-bit alignment:</p>\n<p><a href=\"https://i.sstatic.net/yx854.png\" rel=\"noreferrer\"><img alt=\"less invalid disassembly\" src=\"https://i.sstatic.net/yx854.png\"/></a></p>\n<p>Obviously this is totally different.</p>\n<p>To analyze the disassembled code, one must be familiar with the ARM Thumb instruction set and assembly, and probably ARM more generally (CPU design, registers, etc.). A good starting point appears to be the <a href=\"https://azeria-labs.com/writing-arm-assembly-part-1/\" rel=\"noreferrer\">Azeria Labs series of tutorials</a> . </p>\n<h3>Additional Considerations</h3>\n<ul>\n<li>The ISP upgrade tool is a MS Windows PE32 executable binary. This can be reverse engineered to determine how the flashing process takes place.</li>\n<li>Physical access to the microcontroller could be useful. The entire contents of flash memory could be dumped and analyzed. This would also enable one to see exactly how everything is laid out in flash memory</li>\n<li>if known good blocks of code can be isolated, it my be possible to decompile it</li>\n</ul>\n<h1>Conclusion</h1>\n<p>Hopefully the approach used here proves useful for your future firmware RE endeavors. Analyzing firmware poses its own set of challenges because of the close relationship between it and it the hardware it is designed to be embedded in. Since the design and architecture of the device determines the layout and content of firmware, firmware sometimes cannot be reversed without access to the device, or at the very least knowing the instruction set architecture of the device.</p>\n</div>",
            "votes": "35",
            "user": "julian",
            "time": "Oct 11, 2018 at 0:08",
            "is_accepted": true,
            "comments": []
        }
    ]
}