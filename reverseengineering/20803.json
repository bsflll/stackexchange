{
    "title": "How to use windbg to view assembly code of kernel function?",
    "link": "https://reverseengineering.stackexchange.com/questions/20803/how-to-use-windbg-to-view-assembly-code-of-kernel-function",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am using windbg for local kernel debugging. I want to view the disassembly of a kernel function (eg. AuxKlibQueryModuleInformation). I am not familiar with kernel debugging. Please help me do this.</p>\n</div>",
    "votes": "3",
    "answers": 1,
    "views": "1k",
    "tags": [
        "windbg",
        "kernel"
    ],
    "user": "Kyi Soe Thin",
    "time": "Mar 8, 2019 at 14:10",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>1) you should be aware local kernel debugging is not actual kernel debugging<br/>\n2) i hope you have enabled /debug on switch in bcdecdit prior to using local kernel debugging feature<br/>\n3) i hope you are aware a third party app is available which does not require setting /debug on switch    </p>\n<p>sysinternals <a href=\"https://docs.microsoft.com/en-us/sysinternals/downloads/livekd\" rel=\"nofollow noreferrer\">livekd</a> </p>\n<p>i hope you have properly set the symbol path for downloading symbols using one of the recommended methods like setting an environment variable _NT_SYMBOL_PATH</p>\n<p>usage is simple just run <strong>windbg -&gt;file-&gt;kernel debugging-&gt; local</strong></p>\n<p>or from a command line  <strong>windbg -kl</strong></p>\n<p>issue <strong>.reload /f</strong> so that windbg downloads the required symbol files aka pdbs to the directory you have already set up in _NT_SYMBOL_PATH</p>\n<p>now you can examine symbols which you need using <code>x</code> command</p>\n<pre><code>x *!*aux*     \n</code></pre>\n<p>here x is the command<br/>\nthe * before ! (called bang in windbg )  is a wildcard for module name<br/>\nthe * after  ! (called bang in windbg ) is wildcard for partial symbol name    matches</p>\n<p>and windbg will show you all the matches for that partially looked up symbols as below </p>\n<pre><code>kd&gt; x *!*auxklib*\n81f35962          hidusb!AuxKlibGetBugCheckData (&lt;no parameter info&gt;)\n81f38dfe          hidusb!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)\n81f38dac          hidusb!AuxKlibInitialize (&lt;no parameter info&gt;)\n81f45bc0          HIDCLASS!AuxKlibGetBugCheckData (&lt;no parameter info&gt;)\n81f4ace6          HIDCLASS!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n81f4ac94          HIDCLASS!AuxKlibInitialize (&lt;no parameter info&gt;)\n81f5a696          kbdhid!AuxKlibGetBugCheckData (&lt;no parameter info&gt;)\n81f5dfcc          kbdhid!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n81f5df7a          kbdhid!AuxKlibInitialize (&lt;no parameter info&gt;)\n81f66612          mouhid!AuxKlibGetBugCheckData (&lt;no parameter info&gt;)\n81f69e52          mouhid!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n81f69e00          mouhid!AuxKlibInitialize (&lt;no parameter info&gt;)\n88c66ff6          Wdf01000!AuxKlibGetBugCheckData (&lt;no parameter info&gt;)\n88c79686          Wdf01000!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n88c79634          Wdf01000!AuxKlibInitialize (&lt;no parameter info&gt;)\n88c8b418          WDFLDR!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n88c8b3c6          WDFLDR!AuxKlibInitialize (&lt;no parameter info&gt;)\n8957e926          cdrom!AuxKlibGetBugCheckData (&lt;no parameter info&gt;)\n8958949c          cdrom!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)\n&lt;&lt;&lt;&lt;&lt;\n8958944b          cdrom!AuxKlibInitialize (&lt;no parameter info&gt;)\n8f5af972          i8042prt!AuxKlibGetBugCheckData (&lt;no parameter info&gt;)\n8f5b51ae          i8042prt!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)\n8f5b515d          i8042prt!AuxKlibInitialize (&lt;no parameter info&gt;)\n8f5c291c          kbdclass!AuxKlibGetBugCheckData (&lt;no parameter info&gt;)\n8f5c701a          kbdclass!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)\n8f5c6fc8          kbdclass!AuxKlibInitialize (&lt;no parameter info&gt;)\n8f5d46b0          mouclass!AuxKlibGetBugCheckData (&lt;no parameter info&gt;)\n8f5d8da4          mouclass!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)\n8f5d8d52          mouclass!AuxKlibInitialize (&lt;no parameter info&gt;)\n903f4420          igdkmd32!AuxKlibGetImageExportDirectory (&lt;no parameter info&gt;)\n903f43ca          igdkmd32!AuxKlibGetBugCheckData (&lt;no parameter info&gt;)\n907169cc          igdkmd32!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)\n90716980          igdkmd32!AuxKlibInitialize (&lt;no parameter info&gt;)\n9aafd0df          srv2!AuxKlibQueryModuleInformation (&lt;no parameter info&gt;)           \n9aafd08e          srv2!AuxKlibInitialize (&lt;no parameter info&gt;)\nkd&gt;\n</code></pre>\n<p>since AuxKlibQueryModuleInformation is implemented in many modules then it must be some sort of wrapper to some function which needs to be ascertained by disassembling each function possibly a system call </p>\n<p>the <strong>uf /c</strong> command can disassemble a complete function and shows which child functions are called </p>\n<p>if you are using a recent windbg then you can write a javascript to disassemble each function and grep for a common call in all the functions </p>\n<p>here is a sample javascript that you can improvise </p>\n<pre><code>function exec ( cmdstr ) {\n    return host.namespace.Debugger.Utility.Control.ExecuteCommand( cmdstr );\n}\nfunction log( instr ){\n    host.diagnostics.debugLog( instr + \"\\n\" );\n}\nfunction auximpl() {\n    var auxkqmi = exec( \"x /0 *!*auxklibquerymod*\" )\n    for ( var line of auxkqmi ) {\n        disfun = exec( \"uf /c \" + line )\n        curline = \"\"\n        for ( var a of disfun ) {\n            if( ! ( a.includes( \"Zw\" ) ) ) { \n                curline = a \n            }\n            else {\n                log( a + \"\\t@\\t\" + curline  ) \n                var pstart = (curline.lastIndexOf(\"(\") + 1 )\n                var pend = pstart + 8\n                var prevstr = \"ub \" + curline.substring( pstart,pend  ) + \" l1\"\n                var nextstr = \"u  \" + curline.substring( pstart,pend  ) + \" l1\" \n                var previnst = exec ( prevstr )\n                var nextinst = exec ( nextstr )\n                for ( var [b,c] of [previnst , nextinst] ) {\n                    log ( b )\n                    log ( c )\n                }\n            }\n        }        \n    } \n}\n</code></pre>\n<p>results will be as follows</p>\n<pre><code>kd&gt; dx @$scriptContents.auximpl()\n    call to nt!ZwQuerySystemInformation (8286623c)  @     Wdf01000!AuxKlibQueryModuleInformation+0x8c (87218712):\nWdf01000!AuxKlibQueryModuleInformation+0x8a:\n87218710 6a0b            push    0Bh\nWdf01000!AuxKlibQueryModuleInformation+0x8c:\n87218712 ff15b8722087    call    dword ptr [Wdf01000!_imp__ZwQuerySystemInformation (872072b8)]\n    call to nt!ZwQuerySystemInformation (8286623c)  @     WDFLDR!AuxKlibQueryModuleInformation+0x8c (8722a4a4):\nWDFLDR!AuxKlibQueryModuleInformation+0x8a:\n8722a4a2 6a0b            push    0Bh\nWDFLDR!AuxKlibQueryModuleInformation+0x8c:\n8722a4a4 ff157c802287    call    dword ptr [WDFLDR!_imp__ZwQuerySystemInformation (8722807c)]\n    call to nt!ZwQuerySystemInformation (8286623c)  @     cdrom!AuxKlibQueryModuleInformation+0x8c (87ad1528):\ncdrom!AuxKlibQueryModuleInformation+0x8a:\n87ad1526 6a0b            push    0Bh\ncdrom!AuxKlibQueryModuleInformation+0x8c:\n87ad1528 ff150871ac87    call    dword ptr [cdrom!_imp__ZwQuerySystemInformation (87ac7108)]\n    call to nt!ZwQuerySystemInformation (8286623c)  @     i8042prt!AuxKlibQueryModuleInformation+0x8c (8d4d323a):\ni8042prt!AuxKlibQueryModuleInformation+0x8a:\n8d4d3238 6a0b            push    0Bh\ni8042prt!AuxKlibQueryModuleInformation+0x8c:\n8d4d323a ff1574e14c8d    call    dword ptr [i8042prt!_imp__ZwQuerySystemInformation (8d4ce174)]\n    call to nt!ZwQuerySystemInformation (8286623c)  @     kbdclass!AuxKlibQueryModuleInformation+0x8c (8d4e50a6):\nkbdclass!AuxKlibQueryModuleInformation+0x8a:\n8d4e50a4 6a0b            push    0Bh\nkbdclass!AuxKlibQueryModuleInformation+0x8c:\n8d4e50a6 ff152c114e8d    call    dword ptr [kbdclass!_imp__ZwQuerySystemInformation (8d4e112c)]\n    call to nt!ZwQuerySystemInformation (8286623c)  @     mouclass!AuxKlibQueryModuleInformation+0x8c (8d4f1e30):\nmouclass!AuxKlibQueryModuleInformation+0x8a:\n8d4f1e2e 6a0b            push    0Bh\nmouclass!AuxKlibQueryModuleInformation+0x8c:\n8d4f1e30 ff1524e14e8d    call    dword ptr [mouclass!_imp__ZwQuerySystemInformation (8d4ee124)]\n    call to nt!ZwQuerySystemInformation (8286623c)  @     srv2!AuxKlibQueryModuleInformation+0x8c (90d1c16b):\nsrv2!AuxKlibQueryModuleInformation+0x8a:\n90d1c169 6a0b            push    0Bh\nsrv2!AuxKlibQueryModuleInformation+0x8c:\n90d1c16b ff150c63d190    call    dword ptr [srv2!_imp__ZwQuerySystemInformation (90d1630c)]\n@$scriptContents.auximpl()\n</code></pre>\n</div>",
            "votes": "3",
            "user": "blabb",
            "time": "Mar 7, 2019 at 17:24",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Biswapriyo",
                    "text": "<span class=\"comment-copy\">May you explain the #1 about \"live\" kernel debugging vs memory dump.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">debugging a physical machine needs a two computer setup or a physical machine and a vm  (two machine ) with live kernel debugging you can step through , set break points , edit memory , etc with local kernel debugging you are inspecting a state of a local machine it does not require two machines the data may be stale if you have a session that you started 5 hours ago and you have created ten other process in the local machine in the mean while local kernel debugging wont show the processes that were created after you started local kernel debugging etc etc etc</span>",
                    "time": null
                },
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">Would not call livekd a third-party app, considering that Winternals (the company) was bought by Microsoft in 2006 and Mark Russinovich is a technical fellow at Microsoft.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">well subsidiary , sister / daughter concern , ancillary , whatever  the point is it is still delivered as sysinternals product and not  © microsoft ® corporation</span>",
                    "time": null
                }
            ]
        }
    ]
}