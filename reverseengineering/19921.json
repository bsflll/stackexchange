{
    "title": "Writing ELF headers in Radare?",
    "link": "https://reverseengineering.stackexchange.com/questions/19921/writing-elf-headers-in-radare",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Reading <a href=\"https://blog.k3170makan.com/2018/09/introduction-to-elf-format-elf-header.html\" rel=\"noreferrer\">Keith Makan's, <em>\"Introduction to the ELF Format : The ELF Header\"</em></a>, he modifies <code>e_entry</code>,</p>\n<blockquote>\n<p>The <code>e_entry</code> field lists the offset in the file where the program should start executing.Normally it points to your _start method (of course if you compiled it with the usual stuff). You can point the e_entry anywhere you like, as an example I'm going to show that you can call a function that would other wise be impossible under normal execution.</p>\n</blockquote>\n<p>Also documented in <a href=\"https://linux.die.net/man/5/elf\" rel=\"noreferrer\"><code>man 5 elf</code></a>, I'm wondering if Radare has any functionality to rewrite ELF-specific headers or if writing the bits manually is the current way to do this? For example, I know it'll show the entry point with <code>ie</code>.</p>\n</div>",
    "votes": "7",
    "answers": 2,
    "views": "3k",
    "tags": [
        "radare2",
        "elf"
    ],
    "user": "Evan Carroll",
    "time": "Nov 19, 2018 at 22:14",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<span class=\"comment-copy\">You absolutely want to do this with radare2? If not, have a look at the bfd project (used by binutils).</span>",
            "time": null
        },
        {
            "user": "Evan Carroll",
            "text": "<span class=\"comment-copy\">@0xC0000022L I'm not sure there is a way to do this, generally speaking I assume that Radare can't do something, and then I ask and I find out it can (a huge value of this site). I assume it can only parse ELF. If it can only parse ELF, I think a workaround is a great contribution because I'm pretty spankin new to RE, and I'm sure others are testing the waters just like me. If Radare grows the ability later, I will just come back and mark the newer answer as chosen.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Yes, obviously you can. radare2 has built-in features to handle binary headers. This including reading, parsing and modifying the headers of the binary. And this is not different for <code>elf</code> or <code>pe</code> files, it will work great with both.</p>\n<h2>TL;DR</h2>\n<pre><code>$ ./example.elf\n[*] you ran this binary!\n\n$ r2 -w -nn example.elf\n[0x00000000]&gt; .pf.elf_header.entry=0x0000063a\n[0x00000000]&gt; q\n\n$ ./example.elf\n[*] wow how did you manage to call this?\n</code></pre>\n<hr/>\n<h2>Creating our test file</h2>\n<p>As described in the article you linked in your question, it is easy to create a binary with a function that should never be executed under regular circumstances. Here's the exact code that was used in the linked article:</p>\n<pre><code>$ cat example.c\n\n#include &lt;stdio.h&gt;\n\n\nvoid never_call (void) {\n    printf (\"[*] wow how did you manage to call this?\\n\");\n    return;\n}\n\nint main (int argc, char **argv) {\n    printf (\"[*] you ran this binary!\\n\");\n    return 0;\n}\n</code></pre>\n<p>As you can see, the function <code>never_call</code> would, well... never be called. The program would execute the entrypoint which would execute the <code>main</code> function and will return.</p>\n<p>Now let's compile it using the command line used in the article, and execute the program:</p>\n<pre><code>$ gcc -Wall -o example.elf example.c\n$ ./example.elf\n[*] you ran this binary!\n</code></pre>\n<p>As we said, only <code>main()</code> was executed. Now let's open the binary in radare2 to see the magic happens.</p>\n<hr/>\n<h2>radare2 time!</h2>\n<p><strong>Finding the address of the function</strong> </p>\n<p>As you requested, we want to modify the entry point of the binary by modifying the pointed address in the elf header to be our <code>never_call</code> function. So first, we need to find the address of <code>never_call</code> in the binary.</p>\n<pre><code>$ r2 example.elf\n[0x00000530]&gt; f~never_call\n0x0000063a 19 sym.never_call\n</code></pre>\n<p>We can see that the function <code>never_call</code> is at address <em>0x0000063a</em>. As you probably know by now, the <code>f</code> command is used to list the <a href=\"https://radare.gitbooks.io/radare2book/basic_commands/flags.html\" rel=\"noreferrer\">flags</a> that was marked by radare2, this including symbols as functions names. Then, we used <code>~</code> which is r2's internal <em>grep</em> and grepped for the relevant function.</p>\n<p><strong>Parsing the ELF Header</strong> </p>\n<p>First, we need to seek to address <code>0</code> using <code>s 0</code> and then and only then we can parse the header with a new command <code>pf</code>. The command <code>pf</code> is used to print formatted data such as structures, enums, and types. Let's load the format definition for <code>elf64</code> using <code>pfo elf64</code> and use the <code>pf.</code> command to list the format definitions:</p>\n<pre><code>[0x00002400]&gt; s 0        # Seek to pos 0 in the binary\n\n[0x00000000]&gt; pfo elf64  # Load a Format Definition File for elf\n\n[0x00000000]&gt; pf.\npf.elf_header [16]z[2]E[2]Exqqqxwwwwww ident (elf_type)type (elf_machine)machine version entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\n\npf.elf_phdr [4]E[4]Eqqqqqq (elf_p_type)type (elf_p_flags)flags offset vaddr paddr filesz memsz align\n\npf.elf_shdr x[4]E[8]Eqqqxxqq name (elf_s_type)type (elf_s_flags_64)flags addr offset size link info addralign entsize\n</code></pre>\n<p>One of the loaded definitions is the <code>elf_header</code> which holds the structure for the elf64 header. We can print the header like this:</p>\n<pre><code>[0x00000000]&gt; pf.elf_header\n     ident : 0x00000000 = .ELF...\n      type : 0x00000010 = type (enum elf_type) = 0x3 ; ET_DYN\n   machine : 0x00000012 = machine (enum elf_machine) = 0x3e ; EM_AMD64\n   version : 0x00000014 = 0x00000001\n     entry : 0x00000018 = (qword)0x0000000000000530\n     phoff : 0x00000020 = (qword)0x0000000000000040\n     shoff : 0x00000028 = (qword)0x0000000000001948\n     flags : 0x00000030 = 0x00000000\n    ehsize : 0x00000034 = 0x0040\n phentsize : 0x00000036 = 0x0038\n     phnum : 0x00000038 = 0x0009\n shentsize : 0x0000003a = 0x0040\n     shnum : 0x0000003c = 0x001d\n  shstrndx : 0x0000003e = 0x001c\n</code></pre>\n<p>As you can see, radare2 printed the elf64 header in a readable format so now we can see that <code>entry</code>, at 0x18, points to <code>0x530</code> which is our original entrypoint function. We can verify it by using <code>ie</code>, a radare2 command to print the entrypooint:</p>\n<pre><code>[0x00000000]&gt; ie\n[Entrypoints]\nvaddr=0x00000530 paddr=0x00000530 baddr=0x00000000 laddr=0x00000000 haddr=0x00000018 hvaddr=0x00000018 type=program\n</code></pre>\n<p>Indeed, you can see that the entry point is 0x530 and the <code>haddr</code>, which is the header address, is 0x18.</p>\n<p><strong>Modifying the entry point</strong></p>\n<p>In order to modify this entry, we would need to open the file in writing mode. We can simply execute <code>oo+</code> from our current session in order to re-open the file in write mode, or use the <code>-w</code> argument to <code>radare2</code>.</p>\n<p>Then, we can simply use the <code>pf</code> command to write to the parsed structure the address of <code>never_call</code> function.</p>\n<pre><code>[0x00000000]&gt; oo+\n[0x00000000]&gt; pf.elf_header.entry=0x0000063a\nwv8 0x0000063a @ 0x00000018\n</code></pre>\n<p>This printed us a radare2 command to execute which will modify this address in the header. We can either execute it ourselves or use the <code>.</code> command to \"interpret the output of the command as r2 commands\".</p>\n<p>So instead of executing <code>wv8 ...</code>, we will simply do:</p>\n<pre><code>[0x00000000]&gt; .pf.elf_header.entry=0x0000063a\n</code></pre>\n<p>And now <code>entry</code> should be overridden with 0x63a which is our <code>never_call</code> function.</p>\n<pre><code>[0x00000000]&gt; pf.elf_header\n     ident : 0x00000000 = .ELF...\n      type : 0x00000010 = type (enum elf_type) = 0x3 ; ET_DYN\n   machine : 0x00000012 = machine (enum elf_machine) = 0x3e ; EM_AMD64\n   version : 0x00000014 = 0x00000001\n     entry : 0x00000018 = (qword)0x000000000000063a\n     phoff : 0x00000020 = (qword)0x0000000000000040\n     shoff : 0x00000028 = (qword)0x0000000000001948\n     flags : 0x00000030 = 0x00000000\n    ehsize : 0x00000034 = 0x0040\n phentsize : 0x00000036 = 0x0038\n     phnum : 0x00000038 = 0x0009\n shentsize : 0x0000003a = 0x0040\n     shnum : 0x0000003c = 0x001d\n  shstrndx : 0x0000003e = 0x001c\n\n[0x00000000]&gt; pf.elf_header.entry\n     entry : 0x00000018 = (qword)0x000000000000063a\n</code></pre>\n<p><strong>Executing</strong></p>\n<p>Great! We can now exit radare and execute the program.</p>\n<pre><code>$ ./example.elf\n[*] wow how did you manage to call this?\n</code></pre>\n<hr/>\n<h2>Last words</h2>\n<p>This long answer explained every step in the way but can really be narrowed to a simple command <code>.pf.elf_header.entry=0x0000063a</code> which sets the <code>entry</code> in the elf header to be the desired address. In the <strong>TL;DR</strong> version I demonstrated the use of <code>-w</code> to open the binary in <code>write-mode</code> and the use of <code>-nn</code> to load the binary structure (<code>pfo elf64</code>, etc...). So simply, opening radare2 like this <code>r2 -w -nn example.elf</code> and executing <code>.pf.elf_header.entry=&lt;address&gt;</code> would solve your problem.</p>\n<p>Don't be afraid to ask how to do things in radare2. Although it is quite a scary framework, it is really powerful and with proper knowledge, can do much more things than seems like at first.</p>\n<h2>Read more</h2>\n<ul>\n<li>radare.today | <a href=\"http://radare.today/posts/parsing-a-fileformat-with-radare2/\" rel=\"noreferrer\">Parsing a fileformat with radare2</a></li>\n<li>r2book | <a href=\"https://radare.gitbooks.io/radare2book/analysis/types.html\" rel=\"noreferrer\">Types</a></li>\n</ul>\n</div>",
            "votes": "15",
            "user": "Evan Carroll",
            "time": "Nov 21, 2018 at 6:34",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Evan Carroll",
                    "text": "<span class=\"comment-copy\">Wow, this is really cool. From the UI standpoint, it would be nice if the <code>.pf.elf_header.entry=0x0000063a</code> didn't write to <code>$$</code> but to <code>@ 0</code>. Got it right the second time though.</span>",
                    "time": null
                },
                {
                    "user": "Evan Carroll",
                    "text": "<span class=\"comment-copy\">I just used this to answer another question on the site, thanks again for answering all my questions on re.se. I'll keep them coming. =) <a href=\"https://reverseengineering.stackexchange.com/a/19936/22669\">reverseengineering.stackexchange.com/a/19936/22669</a></span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><em>I don't think this feature is supported according to the <a href=\"https://github.com/radare/radare2/search?q=%22e_entry%22\" rel=\"nofollow noreferrer\">source code</a>.</em>\nEdit: I was wrong, sorry about that.</p>\n<p>However, if you really need a library/tool to do that, I recommend <a href=\"https://github.com/lief-project/LIEF\" rel=\"nofollow noreferrer\">LIEF</a>.</p>\n</div>",
            "votes": "2",
            "user": "wisk",
            "time": "Nov 20, 2018 at 19:43",
            "is_accepted": false,
            "comments": []
        }
    ]
}