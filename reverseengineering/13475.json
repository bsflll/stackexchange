{
    "title": "How can I determine if a piece of code is an encryption algorithm?",
    "link": "https://reverseengineering.stackexchange.com/questions/13475/how-can-i-determine-if-a-piece-of-code-is-an-encryption-algorithm",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to reverse engineer a malware, and came across a piece of code that I suspect is an encryption/decryption procedure, however I do not know for sure. I can recognize that it extracts its payload from it's own <code>.rsrc</code> section.\n I scanned this algorithm with <a href=\"http://www.hexblog.com/?p=27\" rel=\"nofollow\">FindCrypt</a> and <a href=\"https://bitbucket.org/daniel_plohmann/simplifire.idascope\" rel=\"nofollow\">IDAScope</a>, Both plugins failed identifying it as a cryptographic algorithm.</p>\n<p>I am not familiar with cryptographic algorithms. What are some good indications of code being an encryption or decryption algorithm, and what indications rule it out?</p>\n<p>The extraction algorithm is(generated by IDA):</p>\n<pre><code>int __stdcall sub_9001320(int a1, unsigned int a2, int a3)\n{\n// a1 = a3 = 0x09003000\n// a2 = 0x7600\n\n\n\n  int result; // eax@2\n  char v4; // al@23\n  unsigned int l; // [sp+4h] [bp-4Ch]@33\n  unsigned int k; // [sp+10h] [bp-40h]@19\n  unsigned int v7; // [sp+14h] [bp-3Ch]@19\n  int v8; // [sp+18h] [bp-38h]@40\n  signed int j; // [sp+1Ch] [bp-34h]@13\n  unsigned int v10; // [sp+20h] [bp-30h]@5\n  unsigned int i; // [sp+24h] [bp-2Ch]@5\n  unsigned int v12; // [sp+28h] [bp-28h]@5\n  unsigned int v13; // [sp+2Ch] [bp-24h]@5\n  signed int v14; // [sp+30h] [bp-20h]@13\n  unsigned int v15; // [sp+34h] [bp-1Ch]@5\n  unsigned int v16; // [sp+38h] [bp-18h]@5\n  unsigned __int8 v17; // [sp+3Fh] [bp-11h]@5\n  signed int v18; // [sp+40h] [bp-10h]@5\n  _DWORD *lpAddress; // [sp+44h] [bp-Ch]@11\n  unsigned int v20; // [sp+48h] [bp-8h]@13\n  unsigned int v21; // [sp+4Ch] [bp-4h]@16\n\n  if ( a2 &gt; 0xC )\n  {\n    if ( *(_DWORD *)a1 == 1083581807 )\n    {\n      v16 = sub_9001300(a1);\n      v18 = 12;\n      v17 = 0;\n      v15 = 9;\n      v12 = 256;\n      v13 = 256;\n      v10 = 8 * a2 - 96;\n      for ( i = 9; v10 &gt;= i; v10 -= i )\n      {\n        if ( i != 12 &amp;&amp; v13 == 1 &lt;&lt; i )\n          ++i;\n        ++v13;\n      }\n      lpAddress = VirtualAlloc(0, 0xC000u, 0x1000u, 4u);\n      if ( lpAddress )\n      {\n        v20 = 0;\n        v14 = 256;\n        for ( j = 0; j &lt;= 255; ++j )\n        {\n          lpAddress[3 * j] = 0;\n          lpAddress[3 * j + 2] = 0;\n          lpAddress[3 * j + 1] = 1;\n        }\n        v21 = 0;\n        while ( v21 &lt; v16 &amp;&amp; v12 &lt; v13 )\n        {\n          v7 = 0;\n          for ( k = 0; k &lt; v15; ++k )\n          {\n            if ( (1 &lt;&lt; (7 - (v17 + 8 * v18) % 8)) &amp; *(_BYTE *)(a1 + (v17 + 8 * v18) / 8) )\n              v7 |= 1 &lt;&lt; k;\n            v4 = (v17 + 1) % 8;\n            v17 = (v17 + 1) % 8;\n            if ( !v4 )\n              ++v18;\n          }\n          if ( v7 &gt; 0xFF )\n          {\n            if ( v20 &lt; 0xF00 &amp;&amp; v7 &gt; v20 + 255 )\n              return 0;\n            if ( v21 + lpAddress[3 * v7 + 1] &gt; v16 )\n              return 0;\n            for ( l = 0; l &lt; lpAddress[3 * v7 + 1]; ++l )\n              *(_BYTE *)(a3 + l + v21) = *(_BYTE *)(a3 + l + lpAddress[3 * v7]);\n          }\n          else\n          {\n            *(_BYTE *)(v21 + a3) = v7;\n          }\n          if ( v20 == 3840 )\n          {\n            if ( (unsigned int)++v14 &gt;&gt; 12 )\n              v14 = 256;\n          }\n          if ( v20 &gt;= 0xF00 )\n          {\n            v8 = v14 - 1;\n            if ( v14 == 256 )\n              v8 = 4095;\n          }\n          else\n          {\n            v8 = v20 + v14;\n          }\n          lpAddress[3 * v8] = v21;\n          lpAddress[3 * v8 + 1] = lpAddress[3 * v7 + 1] + 1;\n          lpAddress[3 * v8 + 2] = 0;\n          if ( v20 &lt; 0xF00 )\n            ++v20;\n          v21 = v21 + lpAddress[3 * v8 + 1] - 1;\n          ++v12;\n          if ( v15 &lt; 0xC &amp;&amp; 1 &lt;&lt; v15 == v12 )\n            ++v15;\n        }\n        if ( v21 &gt;= v16 )\n        {\n          // sub_9001000 is only called onece and always return 0\n          if ( *(_DWORD *)(a1 + 8) == sub_9001000(a3, v16) )\n          {\n            VirtualFree(lpAddress, 0, 0x8000u);\n            result = 0;\n          }\n          else\n          {\n            result = 0;\n          }\n        }\n        else\n        {\n          result = 0;\n        }\n      }\n      else\n      {\n        result = 0;\n      }\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\n\n\nint __stdcall sub_9001300(int a1)\n{\n  int result; // eax@2\n\n  if ( *(_DWORD *)a1 == 1083581807 )\n    result = *(_DWORD *)(a1 + 4);\n  else\n    result = 0;\n  return result;\n}\n</code></pre>\n<p>File info:\n     file format pei-i386</p>\n<pre><code>Sections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         00001000  09001000  09001000  00001000  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .rdata        00001000  09002000  09002000  00002000  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  2 .rsrc         00005000  09003000  09003000  00003000  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  3 .reloc        00001000  09008000  09008000  00008000  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n</code></pre>\n</div>",
    "votes": "3",
    "answers": 1,
    "views": "604",
    "tags": [
        "malware",
        "unpacking",
        "encryption",
        "decryption",
        "encodings"
    ],
    "user": "JACK M",
    "time": "Sep 9, 2016 at 21:50",
    "comments": [
        {
            "user": "ebux",
            "text": "<span class=\"comment-copy\">It seems to be a compression algorithm and not a cryptographic one.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><strong>TL;DR:</strong> What we have here is probably not an encryption algorithm, it is more likely a decompression loop, by the look of it. It simply does not do anything that could be considered even remotely similar to encryption.</p>\n<p>Encryption algorithms are divided into two classes. First is a <a href=\"https://en.wikipedia.org/wiki/Stream_cipher\" rel=\"noreferrer\">stream cipher</a>. From wikipedia:</p>\n<blockquote>\n<p>A stream cipher is a symmetric key cipher where plaintext digits are combined with a pseudorandom cipher digit stream (keystream). In a stream cipher each plaintext digit is encrypted one at a time with the corresponding digit of the keystream, to give a digit of the ciphertext stream. Since encryption of each digit is dependent on the current state of the cipher, it is also known as state cipher. In practice, a digit is typically a bit and the combining operation an exclusive-or (XOR).</p>\n</blockquote>\n<p>Second is a <a href=\"https://en.wikipedia.org/wiki/Block_cipher\" rel=\"noreferrer\">block cypher</a>. From wikipedia:</p>\n<blockquote>\n<p>In cryptography, a block cipher is a deterministic algorithm operating on fixed-length groups of bits, called blocks, with an unvarying transformation that is specified by a symmetric key. Block ciphers operate as important elementary components in the design of many cryptographic protocols, and are widely used to implement encryption of bulk data.</p>\n<p>The modern design of block ciphers is based on the concept of an iterated product cipher. In his seminal 1949 publication, Communication Theory of Secrecy Systems, Claude Shannon analyzed product ciphers and suggested them as a means of effectively improving security by combining simple operations such as substitutions and permutations.<a href=\"https://en.wikipedia.org/wiki/Stream_cipher\" rel=\"noreferrer\">1</a> Iterated product ciphers carry out encryption in multiple rounds, each of which uses a different subkey derived from the original key. One widespread implementation of such ciphers, named a Feistel network after Horst Feistel, is notably implemented in the DES cipher.<a href=\"https://en.wikipedia.org/wiki/Block_cipher\" rel=\"noreferrer\">2</a> Many other realizations of block ciphers, such as the AES, are classified as substitution-permutation networks.</p>\n</blockquote>\n<p>What we have here is probably not an encryption algorithm. It simply does not do anything that could be considered even remotely similar to encryption. Some of the things that are often found in encryption algorithms but are missing here (not a complete list but just the first few things I came up with):</p>\n<ol>\n<li>There's no pseudo-random stream generated based on an internal state and seed like in stream ciphers</li>\n<li>no sequential character combination of generated stream with input buffer using a XOR (or any other operation).</li>\n<li>No block structure - a sequence executed multiple times on each nicely chunked portion of the input message.</li>\n<li>no long and complex permutation (and no permutation table).</li>\n<li>No multiple iterations of a permutation code common to block ciphers.</li>\n<li>no key sequence initialization (used in both stream and block ciphers).</li>\n<li>Not enough substitutions over either input message or stream/state.</li>\n</ol>\n<p>Encryption algorithms are usually long (and one might say ugly). Usually structured and meticulous on performing operations on all bytes in long repeated sequences. You'll often see multiple iterations of a fixed length performing a single or few operations.</p>\n<p>This is more resembling a compression/decompression algorithm, as sequences of bytes are copied on certain conditions, while bytes are constructed into the decompressed buffer on others.</p>\n<p>Lets go over the code and see:</p>\n<pre><code>int __stdcall sub_9001320(int a1, unsigned int a2, int a3)\n{\n// a1 = a3 = 0x09003000\n// a2 = 0x7600\n\n  int result; // eax@2\n  char v4; // al@23\n  unsigned int l; // [sp+4h] [bp-4Ch]@33\n  unsigned int k; // [sp+10h] [bp-40h]@19\n  unsigned int v7; // [sp+14h] [bp-3Ch]@19\n  int v8; // [sp+18h] [bp-38h]@40\n  signed int j; // [sp+1Ch] [bp-34h]@13\n  unsigned int v10; // [sp+20h] [bp-30h]@5\n  unsigned int i; // [sp+24h] [bp-2Ch]@5\n  unsigned int v12; // [sp+28h] [bp-28h]@5\n  unsigned int v13; // [sp+2Ch] [bp-24h]@5\n  signed int v14; // [sp+30h] [bp-20h]@13\n  unsigned int v15; // [sp+34h] [bp-1Ch]@5\n  unsigned int v16; // [sp+38h] [bp-18h]@5\n  unsigned __int8 v17; // [sp+3Fh] [bp-11h]@5\n  signed int v18; // [sp+40h] [bp-10h]@5\n  _DWORD *lpAddress; // [sp+44h] [bp-Ch]@11\n  unsigned int v20; // [sp+48h] [bp-8h]@13\n  unsigned int v21; // [sp+4Ch] [bp-4h]@16\n</code></pre>\n<p>Function definiton</p>\n<pre><code>  if ( a2 &gt; 0xC )\n  {\n</code></pre>\n<p>Assert a certain length is at least 96 bytes. Although there are some block ciphers accepting this as block size, it's not too common and most widely accepted block ciphers do not support this block size.</p>\n<pre><code>    if ( *(_DWORD *)a1 == 1083581807 )\n    {\n</code></pre>\n<p>Assert certain first bytes of buffer are fixed, this just looks odd without context.</p>\n<pre><code>      v16 = sub_9001300(a1);\n</code></pre>\n<p>Set <code>v16</code> to second dword of input buffer</p>\n<pre><code>      v18 = 12;\n      v17 = 0;\n      v15 = 9;\n      v12 = 256;\n      v13 = 256;\n      v10 = 8 * a2 - 96;\n</code></pre>\n<p>Some more variable initializations</p>\n<pre><code>      for ( i = 9; v10 &gt;= i; v10 -= i )\n      {\n        if ( i != 12 &amp;&amp; v13 == 1 &lt;&lt; i )\n          ++i;\n        ++v13;\n      }\n</code></pre>\n<p>Increase <code>v13</code> according to original length. Without going too much into specifics here, this doesn't look like any cipher seed/initialization.</p>\n<pre><code>      lpAddress = VirtualAlloc(0, 0xC000u, 0x1000u, 4u);\n      if ( lpAddress )\n      {\n</code></pre>\n<p>Allocate a hardcoded length buffer to work on as temporary data</p>\n<pre><code>        v20 = 0;\n        v14 = 256;\n        for ( j = 0; j &lt;= 255; ++j )\n        {\n          lpAddress[3 * j] = 0;\n          lpAddress[3 * j + 2] = 0;\n          lpAddress[3 * j + 1] = 1;\n        }\n</code></pre>\n<p>Initialize said buffer, 2/3 with 0s, 1/3 with 1s. this is probably a boolean buffer.</p>\n<pre><code>        v21 = 0;\n        while ( v21 &lt; v16 &amp;&amp; v12 &lt; v13 )\n        {\n</code></pre>\n<p>Loop <code>v16</code> times. remember <code>v16</code> is user supplied as the second dword in provided buffer. The second dword after the magic is probably a length.</p>\n<pre><code>          v7 = 0;\n          for ( k = 0; k &lt; v15; ++k )\n          {\n</code></pre>\n<p>Another loop, this time for 9 iterations. This means we have 9 iterations for each character in the guessed length parameter. Most block ciphers will have more iterations, and those won't be per character. Most stream ciphers will not process data but instead generate a stream of bytes to XOR with. We don't see a XOR here either.</p>\n<pre><code>            if ( (1 &lt;&lt; (7 - (v17 + 8 * v18) % 8)) &amp; *(_BYTE *)(a1 + (v17 + 8 * v18) / 8) )\n              v7 |= 1 &lt;&lt; k;\n</code></pre>\n<p>Bits are only added to <code>v7</code>, also not productive for any type of encryption algorithm.</p>\n<pre><code>            v4 = (v17 + 1) % 8;\n            v17 = (v17 + 1) % 8;\n</code></pre>\n<p>These two are byte-sized counters.</p>\n<pre><code>            if ( !v4 )\n              ++v18;\n          }\n</code></pre>\n<p>Increase another counter, used for determining how many bits in <code>v7</code> will be set. This entire loop decides which bits of <code>v7</code> will be set, depending on a fixed sequence and wether certain bits of the input buffer are</p>\n<pre><code>          if ( v7 &gt; 0xFF )\n          {\n            if ( v20 &lt; 0xF00 &amp;&amp; v7 &gt; v20 + 255 )\n              return 0;\n            if ( v21 + lpAddress[3 * v7 + 1] &gt; v16 )\n              return 0;\n            for ( l = 0; l &lt; lpAddress[3 * v7 + 1]; ++l )\n              *(_BYTE *)(a3 + l + v21) = *(_BYTE *)(a3 + l + lpAddress[3 * v7]);\n          }\n</code></pre>\n<p>If <code>v7</code> is above 0xff do some sanity (and return on invalid state/data) and then copy a sequence of bytes until a null terminator is reached from a3 to a3, at offsets determined by the value of <code>lpAddress</code> at a specific offset determined by <code>v7</code>.</p>\n<pre><code>          else\n          {\n            *(_BYTE *)(v21 + a3) = v7;\n          }\n</code></pre>\n<p>if <code>v7</code> is below or equal to 255, simply assign it in specified location.</p>\n<pre><code>          if ( v20 == 3840 )\n          {\n            if ( (unsigned int)++v14 &gt;&gt; 12 )\n              v14 = 256;\n          }\n          if ( v20 &gt;= 0xF00 )\n          {\n            v8 = v14 - 1;\n            if ( v14 == 256 )\n              v8 = 4095;\n          }\n          else\n          {\n            v8 = v20 + v14;\n          }\n</code></pre>\n<p>Reset values of <code>v8</code> and <code>v4</code> based on values of offset variables, namely <code>v20</code> and themselves.</p>\n<pre><code>          lpAddress[3 * v8] = v21;\n          lpAddress[3 * v8 + 1] = lpAddress[3 * v7 + 1] + 1;\n          lpAddress[3 * v8 + 2] = 0;\n</code></pre>\n<p>Set a few other values in <code>lpAddress</code> based hardcoded values (0) and a copy of a single value.</p>\n<pre><code>          if ( v20 &lt; 0xF00 )\n            ++v20;\n          v21 = v21 + lpAddress[3 * v8 + 1] - 1;\n          ++v12;\n          if ( v15 &lt; 0xC &amp;&amp; 1 &lt;&lt; v15 == v12 )\n            ++v15;\n        }\n</code></pre>\n<p>Some more counter update based on input and reset of overflows.</p>\n<pre><code>        if ( v21 &gt;= v16 )\n        {\n          // sub_9001000 is only called onece and always return 0\n          if ( *(_DWORD *)(a1 + 8) == sub_9001000(a3, v16) )\n          {\n            VirtualFree(lpAddress, 0, 0x8000u);\n            result = 0;\n          }\n          else\n          {\n            result = 0;\n          }\n        }\n        else\n        {\n          result = 0;\n        }\n      }\n      else\n      {\n        result = 0;\n      }\n    }\n    else\n    {\n      result = 0;\n    }\n  }\n  else\n  {\n    result = 0;\n  }\n  return result;\n}\n</code></pre>\n<p>In case of any invalid input, return 0</p>\n<pre><code>int __stdcall sub_9001300(int a1)\n{\n  int result; // eax@2\n\n  if ( *(_DWORD *)a1 == 1083581807 )\n    result = *(_DWORD *)(a1 + 4);\n  else\n    result = 0;\n  return result;\n}\n</code></pre>\n<p>Assert buffer starts with a hardcoded dword (which we already know is the case because of a previous if statement) and return the value in the second dword.</p>\n</div>",
            "votes": "11",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": [
                {
                    "user": "John Greene",
                    "text": "<span class=\"comment-copy\">Not even a modicum of P-box or S-box, much less rotate instruction sequence.</span>",
                    "time": null
                }
            ]
        }
    ]
}