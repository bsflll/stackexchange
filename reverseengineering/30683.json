{
    "title": "Need help decoding bytes to number",
    "link": "https://reverseengineering.stackexchange.com/questions/30683/need-help-decoding-bytes-to-number",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I've got a really really old file format from an accounting software, late '70s, DOS, QBasic or QuickBasic. Source code is lost, only .exe file remaining, file needs emulator.</p>\n<p>The file formate seems to be mainly nullterminated strings and unsigned values, usually 2 bytes / 16 bits in Little Endian notation.</p>\n<p>I have received some data and can read most of it, but there's a really strange encoding for the transaction value. I've collected all the data and posted it in a Google Sheet:\n<a href=\"https://docs.google.com/spreadsheets/d/1hV2cvtVP7YEMxwiEizNZYO89JF_zFhzJbUl9WqWTmx8/edit?usp=sharing\" rel=\"nofollow noreferrer\">https://docs.google.com/spreadsheets/d/1hV2cvtVP7YEMxwiEizNZYO89JF_zFhzJbUl9WqWTmx8/edit?usp=sharing</a> (no sign-in required).</p>\n<p>I have tried to decode the number.</p>\n<ul>\n<li>It's probably 8bytes/64bits, so the table contains the columns Y-AF for the bytes 0 to 7 (bits 0 to 63).</li>\n<li>These are the only datasets I know the values for.</li>\n<li>The expected value is noted in columns B and AM.</li>\n<li>Converted values are in Columns AI-AL (int8 BE / int8 LE / uint8 BE / uint8 LE), but none of those make any real sense to me</li>\n<li>Values are also plotted, see \"Graphs\" Tab</li>\n</ul>\n<p>I have decoded the last byte (byte 7, column AF) and somewhat matched it with the expected value, IF the first (leftmost) bit is a 1.\nThe (java) formula then is:</p>\n<pre><code>        final byte lastByte = s.Byte7;\n        final byte testByte = (byte) (lastByte &amp; 0b01111111);\n        if (testByte == lastByte) continue; // does not start with 1-bit\n\n        final double result = Math.pow(2, testByte - 1);\n</code></pre>\n<p>So in other words, if we have the byte 7 and lose its leading 1, it's <code>v = 2^(byte7-1)</code>.\nThis brings exact results for all values being of <code>2^x</code>. Any other values are close, but I assume the other bytes need to be taken into account then, too.</p>\n<p>Haven't gotten further yet. Perhaps it's an old standard of storing floating point values, but I've never seen this before, and it looks like it has nothing to do with the IEEE floating point numbers of Java, because I tried all conversions (LE/BE, bytes2float/double, signed/unsigned, exponential and logarithmic conversions).</p>\n<p>I'll try Base64 and other not-8-bits-per-byte strategies next.</p>\n<p>I'll post a bounty of 200 ASAP. (<strong>Update:</strong> A bounty of 100, as I'm new to this site and only have 101 reputation yet... sorry)</p>\n<p><strong>Update:</strong> Looks like this is simply the old <a href=\"https://en.wikipedia.org/wiki/Microsoft_Binary_Format\" rel=\"nofollow noreferrer\">Microsoft Binary Format</a>. Now I'll write some converting algorithm to read it in Java.</p>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "112",
    "tags": [
        "binary-analysis",
        "binary-format",
        "unknown-data"
    ],
    "user": "JayC667",
    "time": "Jul 23, 2022 at 9:09",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Okay, I finally managed to convert it.</p>\n<p>Usually a byte-wise conversion is way better than what I did here, but result are OK so far, and basically it's all the same anyway.</p>\n<p>And yes, I'm not taking care of <em>infinity</em> or <em>NaN</em> or all the other exceptional values.</p>\n<pre><code>static public double fromMBF64(final byte[] msbin) {\n    if (msbin == null) throw new IllegalArgumentException(\"msbin can not be null.\");\n    if (msbin.length != 8) throw new IllegalArgumentException(\"msbin has wrong size. Expected 8 bytes, but got \" + msbin.length + \" instead.\");\n\n    final int expBiased = JcUMath.toUnsigned(msbin[0]) - 128 - 1;\n    final double exp = Math.pow(2, expBiased);\n    final int sign = JcBits.testBit(msbin, 8) ? -1 : 1;\n    double mantisse = 1;\n    for (int i = 0; i &lt; 55; i++) {\n        final int pos = 9 + i;\n        final boolean isSet = JcBits.testBit(msbin, pos);\n        if (!isSet) continue;\n\n        final double expVal = Math.pow(2, i + 1);\n        final double off = 1 / expVal;\n        mantisse += off;\n    }\n    return sign * exp * mantisse;\n}\n</code></pre>\n<p>along with the utility functions</p>\n<pre><code>static public long toUnsigned(final int pValue, final long pMaxValue) {\n    if (pValue &gt;= 0) return pValue;\n    return pValue + (2 * pMaxValue + 2);\n}\nstatic public short toUnsigned(final byte pValue) {\n    return (short) toUnsigned(pValue, Byte.MAX_VALUE);\n}\n\nstatic public boolean testBit(final long pVariable, final int pTestPosition) {\n    final long pattern = 1L &lt;&lt; pTestPosition;\n    return (pVariable &amp; pattern) != 0;\n}\nstatic public boolean testBit(final byte[] pBytes, final int pIndex) {\n    final int arrIndex = pIndex / 8;\n    final byte b = pBytes[arrIndex];\n    final int bit = 7 - pIndex % 8;\n    return testBit(b, bit);\n}\n</code></pre>\n<p><em>Note</em> that the bytes have to be in Big Endian order. So if you're reading Little Endian, simply reverse the <code>byte[]</code>:</p>\n<pre><code>static public byte[] reverse(final byte[] pArray, final int pOffset, final int pLength) {\n    if (pArray == null) return null;\n    if (pLength &lt; 1) return new byte[0];\n\n    final byte[] ret = new byte[pLength];\n    for (int i = 0; i &lt; pLength; i++) {\n        final byte t = pArray[pOffset + pLength - i - 1];\n        ret[i] = t;\n    }\n    return ret;\n}\nstatic public byte[] reverse(final byte... pArray) {\n    if (pArray == null) return null;\n    return reverse(pArray, 0, pArray.length);\n}\n</code></pre>\n<p>When I find the time I'll create a bit-shifting-based conversion, similar to this: <a href=\"https://gist.github.com/pmachapman/05094e12d0711745e3fd7093f7ab67cf\" rel=\"nofollow noreferrer\">https://gist.github.com/pmachapman/05094e12d0711745e3fd7093f7ab67cf</a>, and post it in here.</p>\n</div>",
            "votes": "2",
            "user": "JayC667",
            "time": "Jul 25, 2022 at 10:09",
            "is_accepted": false,
            "comments": []
        }
    ]
}