{
    "title": "idapython - Get Xrefs to a stack variable",
    "link": "https://reverseengineering.stackexchange.com/questions/16055/idapython-get-xrefs-to-a-stack-variable",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to write an IDAPython script that will return a list of references to a local stack-frame variable. However, I couldn't find any API that does so.</p>\n<p>What I am trying to achieve is a code like:\n<code>xrefs = get_variable_references('arg_4')</code> that will return the results corresponding with the GUI's results:</p>\n<p><a href=\"https://i.sstatic.net/TB4B7.png\" rel=\"noreferrer\"><img alt=\"GUI's results\" src=\"https://i.sstatic.net/TB4B7.png\"/></a></p>\n<p>Thanks in advance.</p>\n</div>",
    "votes": "8",
    "answers": 3,
    "views": "5k",
    "tags": [
        "ida",
        "disassembly",
        "idapython",
        "disassemblers",
        "idapro-sdk"
    ],
    "user": "Aviv",
    "time": "Aug 10, 2017 at 15:17",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>There is one function that does this: <code>build_stkvar_xrefs</code>, defined in C++ but exposed via the Python SWIG bindings. IDA builds stack xrefs dynamically when you ask for it. In order to use the function, it requires a little bit of setup.</p>\n<p>You'll need to use a few functions to get what you need:</p>\n<ul>\n<li><code>get_func(ea)</code>: retrieves the <code>func_t</code> structure for the function at <code>ea</code></li>\n<li><code>get_frame(func_t foo)</code>: returns the <code>struct_t</code> structure for the\nfunction frame specified by <code>foo</code></li>\n<li><code>DecodeInstruction(ea)</code>: returns the <code>inst_t</code> representing instruction at <code>ea</code></li>\n<li><code>get_stkvar(op_t op, sval_t v)</code>: <code>op</code> is a reference to an instruction, <code>v</code> is the immediate value in the operand. Usually you just use <code>op.addr</code>. It returns a tuple, <code>(member_t, val)</code>. <code>member_t</code> is a pointer to the stack variable, which is what we need. <code>val</code> is the same value as the <code>soff</code> field in the <code>member_t</code> for the stack var. More on this later.</li>\n<li><code>xreflist_t()</code>: creates a new <code>xreflist</code> of <code>xreflist_entry_t</code></li>\n<li><code>build_stkvar_xrefs(xreflist_t xrefs, func_t func, member_t member)</code>: fills xrefs with <code>xreflist_entry_t</code>'s that represent the stack var xrefs given by <code>member</code> in <code>func</code>.</li>\n<li><code>struct_t.get_member(x)</code>: You can use this method to iterate all stack variables in a frame to retrieve all <code>member_t</code>'s. If you want to build xrefs for all stack variables, this is usually easier.</li>\n</ul>\n<p>Here's an example of how this all ties together:</p>\n<pre><code># 0x4012d0 is the function address\n# 0x4012dc is an instruction address referencing\n# a stack variable. It looks like:\n# mov [ebp - 4], ecx\n\npFunc = get_func(0x4012d0)\npFrame = get_frame(pFunc)\ninst = DecodeInstruction(0x4012dc)\nop = inst[0] #first operand references stack var\npMember, val = get_stkvar(op, op.addr)\nxrefs = xreflist_t()\nbuild_stkvar_xrefs(xrefs, pFunc, pMember)\nfor xref in xrefs:\n    print hex(xref.ea) #print xref address\n\n# Contrived member dictionary example.\ndictMem = dict()\nx = 0\nwhile(x &lt; pFrame.memqty):\n    dictMem[GetMemberName(pFrame.id, pFrame.get_member(x).soff)] = pFrame.get_member(x)\n    x = x+1\n# given var name you can now use the\n# dictionary to grab the member_t to pass\n# to build_stkvar_xrefs\npMem = dictMem[\"var_4\"]\nxrefs = xreflist_t()\nbuild_stkvar_xrefs(xrefs, pFunc, pMem)\nfor xref in xrefs:\n    print hex(xref.ea) #print xrefs to var_4\n</code></pre>\n<p><code>soff</code> isn't a stack offset. I think it means \"structure offset\", and it's an offset into the frame structure so you can retrieve other bits of information. You'll need this field to use other stack variable related functions such as: SetMemberType, SetMemberName, GetMemberName, DelStrucMember, etc. </p>\n<p>So, for a simple on the fly variable name to xref lookup, you can do something like:</p>\n<pre><code>def get_stack_xrefs(func_ea, var_name):\n    pFunc = get_func(func_ea)\n    pFrame = get_frame(pFunc)\n    pMember = None\n    result = []\n    while(x &lt; pFrame.memqty):\n        if GetMemberName(pFrame.id, pFrame.get_member(x).soff) == var_name:\n           pMember = pFrame.get_member(x)\n           break; \n        x = x+1\n    if pMember: \n        xrefs = xreflist_t()\n        build_stkvar_xrefs(xrefs, pFunc, pMember)\n        for each in xrefs:\n            result.append(each.ea)\n    return result\n</code></pre>\n<p>If you want more information on these functions, I recommend taking a look at the following modules from the IDA SDK documentation (in no particular order):</p>\n<ul>\n<li>funcs.hpp</li>\n<li>frame.hpp</li>\n<li>struct.hpp</li>\n</ul>\n<p>Reference: <a href=\"https://www.hex-rays.com/products/ida/support/sdkdoc/files.html\" rel=\"noreferrer\">https://www.hex-rays.com/products/ida/support/sdkdoc/files.html</a></p>\n</div>",
            "votes": "7",
            "user": "mayahustle",
            "time": "Aug 15, 2017 at 21:30",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><em>TL;DR: There's no simple API to achieve this, code is at the end of the answer or <a href=\"https://gist.github.com/nirizr/fe0ce9948b3db05555da42bbfe0e5a1e\" rel=\"nofollow noreferrer\">here</a>.</em></p>\n<p>As far as I know, there is no easy way to get the references to stack structure. It seems like calling <code>idautils.XrefsTo(sid)</code> where <code>sid</code> is the frame id (retrieved using <code>idc.GetFrame</code>) should work, however I couldn't get it to yield any result in my attempts.</p>\n<p>Instead, however, you could walk over the function's instructions and calculate the offsets into the stack manually whenever a stack reference operand is encountered.</p>\n<p>I created a <a href=\"https://gist.github.com/nirizr/fe0ce9948b3db05555da42bbfe0e5a1e\" rel=\"nofollow noreferrer\">gist snippet</a> to show just that, and although I think it's quite self-explanatory I'll go over it briefly here.</p>\n<p>First, we'll need a mapping of stack offsets to arguments, this is taken care of by the <code>find_stack_members</code> function, which uses the <code>idc.GetFrame</code> API function mentioned above to get the structure ID for the stack of a specific function. Then, it uses <code>idautils.StructMembers</code> API to iterate over the stack variables.</p>\n<p>One interesting piece of logic in the <code>find_stack_members</code> function is that it uses the <code>&lt;space&gt;r</code> member name as the base of the stack (where the stack is once the function is entered), this is used later in <code>find_stack_xrefs</code> to calculate the stack offset of a variable based on the current stack delta and the operand immediate value.</p>\n<p>The <code>find_stack_xrefs</code> function iterates over the instructions in the given function, and skips any instruction but those with a operand defined to reference the stack (note that arguments that reference the stack but aren't defined as such by either IDA's auto-analysis or manually will not be treated and hence will not count as a cross-reference).</p>\n<p>If a stack offset operand exists in the instrcution, the <code>find_stack_xrefs</code> function will proceed to calculate it's offset using the stack's base offset (previously retrieved by <code>find_stack_members</code>), the current stack delta (calculated by IDA and available using the API <code>idc.GetSpd</code>) and the immediate taken from the Operand structure.</p>\n<p>For convenience, I'm also including the code here:</p>\n<pre><code>import idc, idaapi, idautils, ida_xref\n\ndef find_stack_members(func_ea):\n    members = {}\n    base = None\n    frame = idc.GetFrame(func_ea)\n    for frame_member in idautils.StructMembers(frame):\n        member_offset, member_name, _ = frame_member\n        members[member_offset] = member_name\n        if member_name == ' r':\n            base = member_offset\n    if not base:\n        raise ValueError(\"Failed identifying the stack's base address using the return address hidden stack member\")\n    return members, base\n\ndef find_stack_xrefs(func_offset):\n    func_ea = ida_funcs.get_func(func_offset).startEA\n    members, stack_base = find_stack_members(func_ea)\n    for func_item in FuncItems(func_ea):\n        flags = idc.GetFlags(ea)\n        stkvar = 0 if idc.isStkvar0(flags) else 1 if idc.isStkvar1(flags) else None\n        if not stkvar:\n            continue\n        ida_ua.decode_insn(func_item)\n        op = ida_ua.cmd.Operands[stkvar]\n        stack_offset = op.addr + idc.GetSpd(func_item) + stack_base\n        member = members[stack_offset]\n        print(\"At offset {:x} stack member {} is referenced by operand number {}\".format(func_item, member, stkvar))\n\nif __name__ == \"__main__\":\n    find_stack_xrefs(idc.ScreenEA())\n</code></pre>\n</div>",
            "votes": "6",
            "user": "NirIzr",
            "time": "Oct 17, 2017 at 11:00",
            "is_accepted": false,
            "comments": [
                {
                    "user": "KulaGGin",
                    "text": "<span class=\"comment-copy\">This code doesn't work: it's outdated, it has multiple bugs and the algorithm is simply wrong. Don't anyone use it. I'll give you just a few examples: <code>flags = idc.GetFlags(ea)</code> is just wrong, there is no <code>ea</code> variable in this script. Meaning this code never actually worked. The <code>idc.GetSpd(func_item)</code> call is again wrong: <code>GetSpd</code> takes past-the-end address, not the address of the current instruction.</span>",
                    "time": null
                },
                {
                    "user": "KulaGGin",
                    "text": "<span class=\"comment-copy\">And even after you supply a proper argument for <code>GetSpd</code>, the formula <code>op.addr + idc.GetSpd(func_item) + stack_base</code> is still wrong. The <code>GetSpd</code> gets the difference between the initial and current values of ESP and doesn't help to determine which stack variable is referenced and on what offset. For example, I have instruction <code>mov     [rbp+0F0h+var_18], rax</code> at address <code>0x14001242A</code>. <code>var_18</code> is at offset 0x18 respectively. The past-the-end address is <code>0x140012431</code>, so I do idc.GetSpd(0x140012431), and get <code>-0x118</code>.</span>",
                    "time": null
                },
                {
                    "user": "KulaGGin",
                    "text": "<span class=\"comment-copy\">Then formula: <code>op.addr + idc.GetSpd(func_item) + stack_base</code> turns into: <code>0x14001242A + (-0x118) + 0x118</code>, which equals to <code>0x14001242A</code>, which is the instruction address, not the stack offset. Which makes this answer completely wrong. If you want a working solution, check out the accepted answer by @mayahustle.</span>",
                    "time": null
                },
                {
                    "user": "NirIzr",
                    "text": "<span class=\"comment-copy\">@KulaGGin Thanks for catching my errors! It's been a while and I'm not sure I tested the code. It was meant as a thought process snippet more than as a working solution. Thanks for pointing it out!</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Disclaimer: I maintain the ida-minsc plugin.</p>\n<p>Using the minsc plugin at <a href=\"https://github.com/arizvisa/ida-minsc/tree/persistence-refactor\" rel=\"nofollow noreferrer\">https://github.com/arizvisa/ida-minsc</a>, you can do something like the following. For demonstration, we start out by disassembling the current instruction containing a stack operand. (We'd normally plug in an address, by giving it a parameter).</p>\n<pre><code>Python&gt;db.disasm()\n'1c00feb4f: movzx eax, [rbp+57h+var_C8]'\n</code></pre>\n<p>Next we'll just display the operands for the current instruction in case we want to verify that the operand is definitely using the stack segment. This is using <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.ops\" rel=\"nofollow noreferrer\"><code>instruction.ops</code></a>.</p>\n<pre><code>Python&gt;ins.ops()\n(&lt;class 'register_t' index=0 dtype=dt_dword name='eax' position=0+32&gt;, SegmentOffsetBaseIndexScale(segment=%ss, offset=-0x71, base=%rbp, index=None, scale=1))\n</code></pre>\n<p>We want the stack variable pointed to by the second operand, so we can use <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op_stackvar\" rel=\"nofollow noreferrer\"><code>instruction.op_stack</code></a> for this. This gives us a frame member of type <a href=\"https://arizvisa.github.io/ida-minsc/modules/structure.html#member-t\" rel=\"nofollow noreferrer\"><code>member_t</code></a>. If the operand is a structure path (as opposed to a stack variable), we could also use <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op_structure\" rel=\"nofollow noreferrer\"><code>instruction.op_structure</code></a> to get a regular structure member. For the record, both actually have the same effect when reading the operand (and only differ when modifying an operand).</p>\n<pre><code>Python&gt;ins.op_stack(1)\n&lt;member '$ F1C0077F18.var_C8' index=6 offset=-0xd0 size=+0x1 typeinfo='char'&gt;\n</code></pre>\n<p>Next, we want the references to that frame member. We can snag these using the <a href=\"https://arizvisa.github.io/ida-minsc/modules/structure.html#structure.member_t.refs\" rel=\"nofollow noreferrer\"><code>member_t.refs()</code></a> method.</p>\n<pre><code>Python&gt;ins.op_stack(1).refs()\n[opref_t(address=0x1c00fe9ae, opnum=0, access=access_t(w)), opref_t(address=0x1c00fea14, opnum=1, access=access_t(r)), opref_t(address=0x1c00feaed, opnum=1, access=access_t(r)), opref_t(address=0x1c00feb4f, opnum=1, access=access_t(r))]\n</code></pre>\n<p>Finally, we can iterate through the references that we snagged, disassemble the address, and then get the stack variable for those.</p>\n<pre><code>Python&gt;for ref in ins.op_stack(1).refs():\nPython&gt; print(ins.op_stack(ref))\nPython&gt; print(db.disasm(ref))\n\n&lt;member '$ F1C0077F18.var_C8' index=6 offset=-0xd0 size=+0x1 typeinfo='char'&gt;\n1c00fe9ae: mov [rbp+57h+var_C8], 1\n&lt;member '$ F1C0077F18.var_C8' index=6 offset=-0xd0 size=+0x1 typeinfo='char'&gt;\n1c00fea14: movzx eax, [rbp+57h+var_C8]\n&lt;member '$ F1C0077F18.var_C8' index=6 offset=-0xd0 size=+0x1 typeinfo='char'&gt;\n1c00feaed: movzx eax, [rbp+57h+var_C8]\n&lt;member '$ F1C0077F18.var_C8' index=6 offset=-0xd0 size=+0x1 typeinfo='char'&gt;\n1c00feb4f: movzx eax, [rbp+57h+var_C8]\n</code></pre>\n<p>If you want to grab them from an arbitrary frame member, you can grab the frame using <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function-frame\" rel=\"nofollow noreferrer\"><code>function.frame(ea)</code></a>. Once the frame structure has been fetched, we can use the <a href=\"https://arizvisa.github.io/ida-minsc/modules/structure.html#structure.members_t\" rel=\"nofollow noreferrer\"><code>members_t</code></a> attribute to access individual or multiple members.</p>\n<pre><code>Python&gt;func.frame()\n&lt;class 'structure' name='$ F1C0077F18' offset=-0x120 size=0x128&gt;.\n\nPython&gt;func.frame().members\n&lt;class 'structure' name='$ F1C0077F18' offset=-0x120 size=0x128&gt;\n     -120+0x28                                             [None, 40]\n[0]   -f8+0x8                  PLARGE_INTEGER 'Timeout'    (&lt;class 'type'&gt;, 8)\n[1]   -f0+0x8          PEVENT_DATA_DESCRIPTOR 'var_E8'     (&lt;class 'type'&gt;, 8)\n[2]   -e8+0x4                             int 'var_E0'     (&lt;class 'int'&gt;, 4)\n[3]   -e4+0x4                             int 'var_DC'     (&lt;class 'int'&gt;, 4)\n[4]   -e0+0x4                             int 'var_D8'     (&lt;class 'int'&gt;, 4)\n      -dc+0x4                                              [None, 4]\n...\n      -20+0x8                                              [None, 8]\n[18]  -18+0x1                            char 'var_10'     (&lt;class 'int'&gt;, 1)\n      -17+0xf                                              [None, 15]\n[19]   -8+0x8                         char[8] ' s'         [(&lt;class 'int'&gt;, 1), 8]\n[20]    0+0x8                         char[8] ' r'         [(&lt;class 'int'&gt;, 1), 8]\n</code></pre>\n<p>We only want references for members that are typed (and not an argument), so we can start out by listing the results using the <a href=\"https://arizvisa.github.io/ida-minsc/modules/structure.html#structure.members_t.list\" rel=\"nofollow noreferrer\"><code>members_t.list</code></a> method and <a href=\"https://arizvisa.github.io/ida-minsc/matching.html\" rel=\"nofollow noreferrer\">filtering</a> the results for the purpose of verifying things prior to collecting everything.</p>\n<pre><code>Python&gt;func.frame().members.list(typed=True, args=False)\n[ 0] -f8:+0x8                 PLARGE_INTEGER 'Timeout'    (&lt;class 'type'&gt;, 8)                                                      (flag=35500400,dt_type=30000000)\n[ 1] -f0:+0x8         PEVENT_DATA_DESCRIPTOR 'var_E8'     (&lt;class 'type'&gt;, 8)                                                      (flag=35500400,dt_type=30000000)\n[ 7] -cc:+0x10                          GUID 'ActivityId' &lt;class 'structure' name='_GUID' offset=-0xcc size=0x10&gt;                  (flag=60000400,dt_type=60000000,typeid=ff00000000003840)\n[ 8] -b8:+0x10 struct _EVENT_DATA_DESCRIPTOR 'var_B0'     &lt;class 'structure' name='_EVENT_DATA_DESCRIPTOR' offset=-0xb8 size=0x10&gt; (flag=60000400,dt_type=60000000,typeid=ff0000000000df8c)\n[11] -88:+0x10 struct _EVENT_DATA_DESCRIPTOR 'var_80'     &lt;class 'structure' name='_EVENT_DATA_DESCRIPTOR' offset=-0x88 size=0x10&gt; (flag=60000400,dt_type=60000000,typeid=ff0000000000df8c)\n[14] -58:+0x10 struct _EVENT_DATA_DESCRIPTOR 'var_50'     &lt;class 'structure' name='_EVENT_DATA_DESCRIPTOR' offset=-0x58 size=0x10&gt; (flag=60000400,dt_type=60000000,typeid=ff0000000000df8c)\n</code></pre>\n<p>Now we can iterate through all the results, skip any references that aren't writing to the variable by checking its reference, and outputting a disassembly of the basic-block (using <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.block\" rel=\"nofollow noreferrer\"><code>function.block</code></a> that contains it.</p>\n<pre><code>Python&gt;for m in func.frame().members(typed=True, args=False):\nPython&gt;  for ref in m.refs():\nPython&gt;    if 'w' not in ref: continue\nPython&gt;    print(func.block(ref), ref)\nPython&gt;    print(db.disasm(func.block(ref)))\nPython&gt;    print()\nPython&gt;\n\nbounds_t(left=0x1c0077f55, right=0x1c0077f79) opref_t(address=0x1c0077f69, opnum=0, access=access_t(w))\n1c0077f55: mov rcx, qword ptr cs:WPP_MAIN_CB.Queue\n1c0077f5c: lea rax, WPP_887fffb207bc3747f0ee19f0a3430899_Traceguids\n1c0077f63: mov r9d, 0Ah\n1c0077f69: mov [rsp+110h+Timeout], rax\n1c0077f6e: mov dl, 4\n1c0077f70: lea r8d, [r9+5]\n1c0077f74: call WPP_RECORDER_SF_\n\nopref_t(address=0x1c00fea47, opnum=0, access=access_t(w))\nbounds_t(left=0x1c00fea14, right=0x1c00fea51) opref_t(address=0x1c00fea47, opnum=0, access=access_t(w))\n1c00fea14: movzx eax, [rbp+57h+var_C8]\n1c00fea18: lea r8, [rbp+57h+ActivityId]\n1c00fea1c: mov [rsp+110h+var_E0], eax\n1c00fea20: lea rdx, dword_1C0213D87\n1c00fea27: lea rax, [rsp+110h+var_E0]\n1c00fea2c: mov [rbp+57h+var_88], 4\n1c00fea34: mov [rbp+57h+var_90], rax\n1c00fea38: xor r9d, r9d\n1c00fea3b: lea rax, [rbp+57h+var_B0]\n1c00fea3f: mov rcx, rdi\n1c00fea42: mov [rsp+110h+var_E8], rax\n1c00fea47: mov dword ptr [rsp+110h+Timeout], r13d\n1c00fea4c: call _tlgWriteTransfer_EtwWriteTransfer\n\n...\n\nopref_t(address=0x1c0077fca, opnum=0, access=access_t(w))\nbounds_t(left=0x1c0077fb4, right=0x1c0077fd8) opref_t(address=0x1c0077fca, opnum=0, access=access_t(w))\n1c0077fb4: cmp cs:bool InputTraceLogging::Perf::s_userCritLoggingEnabled, r14b\n1c0077fbb: lea rdi, dword_1C0246A60\n1c0077fc2: mov esi, 6\n1c0077fc7: xorps xmm0, xmm0\n1c0077fca: movups xmmword ptr [rbp+57h+ActivityId.Data1], xmm0\n1c0077fce: lea r13d, [rsi-3]\n1c0077fd2: jnz loc_1C00FE9AE\n</code></pre>\n</div>",
            "votes": "0",
            "user": "Ali Rizvi-Santiago",
            "time": "Jul 20, 2024 at 23:13",
            "is_accepted": false,
            "comments": []
        }
    ]
}