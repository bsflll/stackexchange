{
    "title": "Radare2 Find command line arguments and location in stack",
    "link": "https://reverseengineering.stackexchange.com/questions/18085/radare2-find-command-line-arguments-and-location-in-stack",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This might have a simple solution but I can't find it anywhere.</p>\n<pre><code>$&gt; ./be1 11 AAAAA\n</code></pre>\n<p>With <code>gdb</code>, finding <code>argv[]</code> and <code>argc</code> is simple:</p>\n<pre><code>(gdb) print argv[0]@argc\n$7 = {0xbffff872 \"be1\", 0xbffff89a \"11\", 0xbffff89d \"AAAAA\"}\n</code></pre>\n<p>But, how can we do this with radare2 ?</p>\n</div>",
    "votes": "7",
    "answers": 2,
    "views": "2k",
    "tags": [
        "binary-analysis",
        "radare2"
    ],
    "user": "Corey",
    "time": "Apr 25, 2018 at 15:51",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>radare2 currently doesn't <a href=\"https://radare.gitbooks.io/radare2book/content/basic_commands/flags.html\" rel=\"noreferrer\">flags</a> <code>argv</code> and <code>argc</code>. Yet, it shouldn't be something complicated to implement.</p>\n<p>Although these arguments are not flagged by radare2, they can be easily be visible to us by inspecting the registers. Let's do it step by step.</p>\n<p>Assume we have the following program:</p>\n<pre><code>$ cat example.c\n\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n\n   printf( \"argv[1]: %s\\n\", argv[1]);\n\n   return 0;\n}\n</code></pre>\n<p>All the program is doing is to print the first argument given to it. Simple as that.</p>\n<p>Let's compile it in <code>gcc</code> and open it in debug-mode with <code>radare2</code> using the <code>-d</code> flag, and pass an argument to it:</p>\n<pre><code>$ gcc example.c -o example.elf\n$ r2 -d example.elf ABCDEFGH\nProcess with PID 104 started...\n= attach 104 104\nbin.baddr 0x00400000\nUsing 0x400000\nasm.bits 64\n -- Nothing to see here. Move along.\n[0x7f3c8f000c30]&gt; \n</code></pre>\n<p>Let's quickly analyze the program using <code>aa</code>:</p>\n<pre><code>[0x7f3c8f000c30]&gt; aa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n</code></pre>\n<p>Now, let's execute the program until we reach <code>main()</code>. We can do this by setting a breakpoint at <code>main</code> using <code>db main</code> and continue the execution until the program reaches the breakpoint using <code>dc</code>. <strong>Or</strong>, we can simply use <code>dcu [addr]</code> -- a very nice command that will continue the execution until a specific address.</p>\n<pre><code>[0x7f3c8f000c30]&gt; dcu main\nContinue until 0x00400526 using 1 bpsize\nhit breakpoint at: 400526\n</code></pre>\n<p>radare2 stopped the execution of the program at <code>main</code>. Great! Let's move on and print the function:</p>\n<pre><code>[0x00400526]&gt; pdf\n            ;-- main:\n            ;-- rax:\n            ;-- rip:\n╭ (fcn) sym.main 51\n│   sym.main ();\n│           ; var int local_10h @ rbp-0x10\n│           ; var int local_4h @ rbp-0x4\n│           ; DATA XREF from 0x0040044d (entry0)\n│           0x00400526      55             push rbp\n│           0x00400527      4889e5         mov rbp, rsp\n│           0x0040052a      4883ec10       sub rsp, 0x10\n│           0x0040052e      897dfc         mov dword [local_4h], edi\n│           0x00400531      488975f0       mov qword [local_10h], rsi\n│           0x00400535      488b45f0       mov rax, qword [local_10h]\n│           0x00400539      4883c008       add rax, 8\n│           0x0040053d      488b00         mov rax, qword [rax]\n│           0x00400540      4889c6         mov rsi, rax\n│           0x00400543      bfe4054000     mov edi, str.argv_1_:__s    ; 0x4005e4 ; \"argv[1]: %s\\n\"\n│           0x00400548      b800000000     mov eax, 0\n│           0x0040054d      e8aefeffff     call sym.imp.printf         ; int printf(const char *format)\n│           0x00400552      b800000000     mov eax, 0\n│           0x00400557      c9             leave\n╰           0x00400558      c3             ret\n</code></pre>\n<p>As you may know, in a GCC compiled program, at <code>main</code>'s entry, <code>edi</code> will hold <code>argc</code> and <code>rsi</code> (a pointer on the stack) will hold <code>argv</code>.</p>\n<p>We can print their addresses like this:</p>\n<pre><code>[0x00400526]&gt; dr rsi\n0x7ffff02302b8\n[0x00400526]&gt; dr edi\n0x00000002\n</code></pre>\n<p>So the value of <code>argc</code> (<code>edi</code>) is <code>0x2</code> which is expected since the arguments are the file name and \"ABCDEFGH\". The address of the pointer <code>argv</code> (<code>rsi</code>) is <code>0x7ffff02302b8</code>. In order to print the content of <code>* argv</code> (<code>rsi</code>) we can simply use the following command:</p>\n<pre><code>[0x00400526]&gt; psb @ [rsi]\n0x7ffff02304b7 ./example.elf\n0x7ffff02304c4 ABCDEFGH\n0x7ffff02304cd SHELL=/bin/bash\n0x7ffff02304dd TERM=xterm-256color\n0x7ffff02304f1 OLDPWD=&lt;truncated&gt;\n0x7ffff023050e USER=beet\n0x7ffff0230518 NAME=&lt;truncated&gt;\n</code></pre>\n<p><code>psb</code> is used to <strong>p</strong>rint <strong>s</strong>trings in the current <strong>b</strong>lock. Since at this point we know that <code>argc</code> equals 2, we can ignore anything that is beneath the second line of the output.</p>\n<p>radare2 also offers you a register telescoping using <code>drr</code>. This way you can easily see where <code>rsi</code> is pointing to:</p>\n<pre><code>[0x00400526]&gt; drr~rsi\n   rsi 0x00007ffff1a56ab8  rsi stack R W 0x7ffff1a56cb7 --&gt;  stack R W 0x6c706d6178652f2e (./example.elf) --&gt;  ascii\n</code></pre>\n<p>As you can see, <code>rsi</code> value is <code>0x7ffff1a56ab8</code> which is pointing to an address on the stack (<code>0x7ffff1a56cb7</code>) that contains an ascii string \"./example.elf\".<br/>\n<em><code>~</code> is radare's internal grep</em>.</p>\n<p>Please consider open an <a href=\"https://github.com/radare/radare2/issues/new\" rel=\"noreferrer\">issue</a> to ask for this feature, or even better, implement it and send a pull-request.</p>\n</div>",
            "votes": "7",
            "user": "Megabeets",
            "time": "Apr 25, 2018 at 7:32",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Corey",
                    "text": "<span class=\"comment-copy\">Wow, thanks this is everything I wanted and much much more. Thanks again!</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>the info command holds all the args passed to radare2  and you can use the internal grep too to find it </p>\n<pre><code>:\\&gt;radare2 -Q -c \"i~ref\" -d cmdlnargs.exe firstarg secarg thirdarg\nSpawned new process with pid 6032, tid = 3196\nr_sys_pid_to_path: Cannot get module filename.= attach 6032 3196\nbin.baddr 0x01330000\nUsing 0x1330000\nSpawned new process with pid 872, tid = 2512\nr_sys_pid_to_path: Cannot get module filename.asm.bits 32\nreferer  dbg://cmdlnargs.exe firstarg secarg thirdarg\n</code></pre>\n<p>the same command performed inside radare instead of shell </p>\n<pre><code>:\\&gt;radare2 -d cmdlnargs.exe firstarg secarg thirdarg\nSpawned new process with pid 5356, tid = 2704\nr_sys_pid_to_path: Cannot get module filename.= attach 5356 2704\nbin.baddr 0x01330000\nUsing 0x1330000\nSpawned new process with pid 5296, tid = 6036\nr_sys_pid_to_path: Cannot get module filename.asm.bits 32\n -- Are you still there?\n[0x779d70d8]&gt; i~ref\nreferer  dbg://cmdlnargs.exe firstarg secarg thirdarg\n[0x779d70d8]&gt; q\nDo you want to quit? (Y/n) y\nDo you want to kill the process? (Y/n) y\n\n:\\&gt;\n</code></pre>\n</div>",
            "votes": "1",
            "user": "blabb",
            "time": "Apr 25, 2018 at 21:33",
            "is_accepted": false,
            "comments": []
        }
    ]
}