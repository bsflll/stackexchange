{
    "title": "Tool/parser for symbol tables produced with objdump -t to be used with IDA / Ghidra?",
    "link": "https://reverseengineering.stackexchange.com/questions/27530/tool-parser-for-symbol-tables-produced-with-objdump-t-to-be-used-with-ida-ghi",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Working with a binary (arm64) file that seems to be some sort of a broken ELF file. The header data is missing and for some reason it contains a symbol table in a format that to me seem to be equal to the output when running <code>objdump -t &lt;filename.elf&gt;</code> on a valid ELF, concatenated after all the code.</p>\n<p>(To avoid misunderstandings; if I run mentioned command on a different, valid ELF, I get a symbol table output in the format below, and it's a symbol table in this format that I find inside the broken ELF.)</p>\n<p>However, neither IDA pro nor Ghidra manage to utilize this information, so for now the only way I've managed to use some of this to my advantage is to write a (IDA)python script and parse it \"manually\" to add functions, function names, etc based on the content of the symbol table.</p>\n<p>This procedure works to some extent but it's not that great (probably due to my limited experience with writing good IDA-python parsers). It got me wondering if there maybe exist some other tool for this already?</p>\n<p>I'm not very experienced with IDA or Ghidra, so it could be one/both of them have a feature to load symbol tables in this format, but if so, I've overlooked that at least.</p>\n<p>Here's a small excerpt from the symbol-table data included in the broken ELF (just changed some of the names). As mentioned, the format is equal to what you get when running <code>objdump -t randomfile.elf &gt; table.txt</code> on a valid ELF file.</p>\n<pre><code>randomfile.elf:     file format elf64-littleaarch64\n\nSYMBOL TABLE:\n0000000010c00000 l    d  .text  0000000000000000 .text\n0000000010e2a550 l    d  __ex_table 0000000000000000 __ex_table\n0000000010e2a570 l    d  .text.unlikely 0000000000000000 .text.unlikely\n0000000010e2a5a0 l    d  .data  0000000000000000 .data\n0000000010ebf380 l    d  .got.plt   0000000000000000 .got.plt\n0000000010ebf398 l    d  .module    0000000000000000 .module\n0000000010ebf740 l    d  .bss   0000000000000000 .bss\n0000000000000000 l    d  .debug_info    0000000000000000 .debug_info\n0000000000000000 l    d  .debug_abbrev  0000000000000000 .debug_abbrev\n0000000000000000 l    d  .debug_loc 0000000000000000 .debug_loc\n0000000000000000 l    d  .debug_aranges 0000000000000000 .debug_aranges\n0000000000000000 l    d  .debug_line    0000000000000000 .debug_line\n0000000000000000 l    d  .debug_str 0000000000000000 .debug_str\n0000000000000000 l    d  .comment   0000000000000000 .comment\n0000000000000000 l    d  .debug_frame   0000000000000000 .debug_frame\n0000000000000000 l    d  .debug_ranges  0000000000000000 .debug_ranges\n0000000000000000 l    df *ABS*  0000000000000000 init.o\n0000000000002000 l       *ABS*  0000000000000000 STACK_SIZE\n0000000010c00034 l       .text  0000000000000000 init_start\n0000000010c00024 l       .text  0000000000000000 fw_magic\n0000000010c00328 l       .text  0000000000000000 feature_init\n0000000010c00370 l       .text  0000000000000000 subfeature_init\n0000000010c001d4 l       .text  0000000000000000 twee_init\n.\n.\n.\n0000000010d541a0 g     F .text  0000000000000004 memset\n0000000010e5e510 g     O .data  0000000000000080 acFont_ASCII\n0000000010c2bd5c g     F .text  0000000000000004 get_curve\n0000000010c29d24 g     F .text  0000000000000118 inject_mem\n</code></pre>\n<p>Based on an older version of the ELF file that I found, which contains both headers and a \"proper\" symbol table (proper as in I can run <code>objdump</code>, <code>readelf</code> etc on the file without errors), I've started on \"reconstructing\" a header for the broken ELF - basically copying the header from the older ELF version and adjusting the load address, etc. It's far from 100% correct, but it seems to make things a bit easier for me since IDA pro is analyzing the file automatically. Ghidra, on the other hand, doesn't manage to load the ELF at all if I include my partial ELF-header.</p>\n<p>If I also could either load the symbol table from the broken ELF - <em>as is</em> - in IDA with some feature, that'd be great. Even better if there is a way to incorporate the symbol table in some other format into the ELF so that IDA/Ghidra automatically manage to use this information while analyzing.</p>\n<p>Might be this is a far fetched dream, but worth a shot. For all I know there could be some existing feature for this.</p>\n</div>",
    "votes": "2",
    "answers": 0,
    "views": "684",
    "tags": [
        "ida",
        "ghidra",
        "elf",
        "symbols",
        "objdump"
    ],
    "user": "blubbafett",
    "time": "Apr 22, 2021 at 17:29",
    "comments": [
        {
            "user": "Orwellophile",
            "text": "<span class=\"comment-copy\">This is really just a side note, but <code>tinycc</code> produces .elf files when compiling Windows applications.  The resultant code is perfectly normal, and I've never looked at the intermediate format of the .elf files -- they certainly wouldn't be obliged to be compliant with (say) Linux .elf files - though they may be, Fabrice Bellard can certainly do whatever he likes.:)</span>",
            "time": null
        }
    ],
    "answers_data": []
}