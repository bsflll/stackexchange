{
    "title": "On SPARC, what happens when a branch is placed in the branch-delay slot of another branch?",
    "link": "https://reverseengineering.stackexchange.com/questions/1962/on-sparc-what-happens-when-a-branch-is-placed-in-the-branch-delay-slot-of-anoth",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Our team recently had to look at <a href=\"http://www.sparc.com/standards/V8.pdf\" rel=\"nofollow\">SPARC assembly specifications</a>, the problem is that I do not have a SPARC processor to try things on it (I should set up a simulator or get one of these old Sparc station on my desk... I know).</p>\n<p>Somehow, the <code>ba</code> (branch always) instruction puzzled me because it is a <a href=\"http://en.wikibooks.org/wiki/SPARC_Assembly/SPARC_Details#Delayed_Branch\" rel=\"nofollow\">delayed branch execution</a> instruction. This mean that the instruction located just <strong>after</strong> the <code>ba</code> get executed before the jump occurs.</p>\n<p>One of my colleague raised a very interesting question, what does occur in this case:</p>\n<pre><code>0x804b38 ba 0x805a10\n0x804b3c ba 0x806844\n...\n0x805a10 add %r3, %r2, %r5\n...\n0x806844 sub %r3, %r5, %r2\n...\n</code></pre>\n<p>Our guess, following the specifications, is that the run should behave like this:</p>\n<pre><code>0x805a10 add %r3, %r2, %r5\n0x806844 sub %r3, %r5, %r2\n0x806848 ...\n</code></pre>\n<p>Which means that you can probably jump and pick up one instruction inside a block of others and run to the next <code>ba</code>... I wonder what the CFG would look like.</p>\n<p>Whatever, it was the \"<em>simple</em>\" case, what if we have dynamic jumps (the <code>jmp</code> instruction is like a <code>ba</code> but based on the address stored in the given register):</p>\n<pre><code>0x804b38 jmp %r3\n0x804b3c jmp %r0\n...\n(%r3)    change %r0\n...\n</code></pre>\n<p>Would it be a good way to mislead a static-analyzer ? Or, is there a way to have an easy computation to guess what it is doing ?</p>\n</div>",
    "votes": "4",
    "answers": 1,
    "views": "788",
    "tags": [
        "obfuscation",
        "binary-analysis",
        "sparc"
    ],
    "user": "perror",
    "time": "Apr 30, 2013 at 15:36",
    "comments": [
        {
            "user": "0xC0000022L",
            "text": "<span class=\"comment-copy\">do you have more code, e.g. a full binary? I have a SPARC to try it on ;)</span>",
            "time": null
        },
        {
            "user": "perror",
            "text": "<span class=\"comment-copy\">Sorry, I just speculate based on the specifications... :-/ I need to get a sparc and a complete build chain quickly. I have to try.</span>",
            "time": null
        },
        {
            "user": "Mellowcandle",
            "text": "<span class=\"comment-copy\">@0xC0000022L I deleted my comment, I didn't read the question till the end...</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p><strong>I edited the whole example a little so that it would better match the question.</strong></p>\n<p>My SPARC assembly fu is weak, but what I did was write a little \"Hello world\" with a twist (or one could say with jumps/<code>goto</code>s) in C and use <code>gcc -S</code> to translate it to assembly. I have a SPARC on which I am running it, details:</p>\n<pre><code>$ isainfo -v\n64-bit sparcv9 applications\n        vis2 vis\n32-bit sparc applications\n        vis2 vis v8plus div32 mul32\n</code></pre>\n<p><strong>NB:</strong> <code>b</code> is the same as <code>jmp</code>, it's just a different mnemonic for the same thing, really. One takes an immediate value (<code>b</code>), the other a register (<code>jmp</code>).</p>\n<p>It turns out that what <a href=\"http://en.wikibooks.org/wiki/SPARC_Assembly/SPARC_Details#Delayed_Branch\" rel=\"nofollow noreferrer\">the link</a> you gave is true for GCC:</p>\n<blockquote>\n<p>Notice that the last instruction executes before the jump takes place,\n  not after the subroutine returns. This first instruction after a jump\n  is called a delay slot. It is common practice to fill the delay slot\n  with a special operation that performs no task, called a no-operation,\n  or <code>nop</code>.</p>\n</blockquote>\n<h1>Real life test</h1>\n<p>I reckon we need to do this with and without debugger, because it's not clear whether it might behave differently under a debugger. So the code should output something readable so we can see what kind of effect our tinkering has ;)</p>\n<h2>C code</h2>\n<pre><code>#include &lt;stdio.h&gt;\n\nint foo(int argc)\n{\n        switch(argc)\n        {\n        case 0:\n        case 1:\n                goto a1;\n        case 2:\n                return 3;\n        case 4:\n                goto a2;\n        case 5:\n                return -1;\n        default:\n                goto a4;\n        }\na1:     return 1;\na2:     return 2;\na4:     return 4;\n}\n\nint main(int argc, char** argv)\n{\n        printf(\"Hello world: %i\\n\", foo(argc));\n        return foo(argc);\n}\n</code></pre>\n<p>This gives me plenty of branch instructions to play around with the idea raised in the question.</p>\n<h2>Assembly created by <code>gcc -S</code></h2>\n<p>Here's the assembly before I tinkered with it:</p>\n<pre><code>        .file   \"test.c\"\n        .section        \".text\"\n        .align 4\n        .global foo\n        .type   foo, #function\n        .proc   04\nfoo:\n        !#PROLOGUE# 0\n        save    %sp, -120, %sp\n        !#PROLOGUE# 1\n        st      %i0, [%fp+68]\n        ld      [%fp+68], %g1\n        cmp     %g1, 5\n        bgu     .LL11\n        nop\n        ld      [%fp+68], %g1\n        sll     %g1, 2, %i5\n        sethi   %hi(.LL12), %g1\n        or      %g1, %lo(.LL12), %g1\n        ld      [%i5+%g1], %g1\n        jmp     %g1\n         nop\n.LL6:\n        mov     3, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL9:\n        mov     -1, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL5:\n        mov     1, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL8:\n        mov     2, %g1\n        st      %g1, [%fp-20]\n        b       .LL1\n         nop\n.LL11:\n        mov     4, %g1\n        st      %g1, [%fp-20]\n.LL1:\n        ld      [%fp-20], %i0\n        ret\n        restore\n        .align 4\n        .align 4\n.LL12:\n        .word   .LL5\n        .word   .LL5\n        .word   .LL6\n        .word   .LL11\n        .word   .LL8\n        .word   .LL9\n        .size   foo, .-foo\n        .section        \".rodata\"\n        .align 8\n.LLC0:\n        .asciz  \"Hello world: %i\\n\"\n        .section        \".text\"\n        .align 4\n        .global main\n        .type   main, #function\n        .proc   04\nmain:\n        !#PROLOGUE# 0\n        save    %sp, -112, %sp\n        !#PROLOGUE# 1\n        st      %i0, [%fp+68]\n        st      %i1, [%fp+72]\n        ld      [%fp+68], %o0\n        call    foo, 0\n         nop\n        mov     %o0, %o5\n        sethi   %hi(.LLC0), %g1\n        or      %g1, %lo(.LLC0), %o0\n        mov     %o5, %o1\n        call    printf, 0\n         nop\n        ld      [%fp+68], %o0\n        call    foo, 0\n         nop\n        mov     %o0, %g1\n        mov     %g1, %i0\n        ret\n        restore\n        .size   main, .-main\n        .ident  \"GCC: (GNU) 3.4.3 (csl-sol210-3_4-branch+sol_rpath)\"\n</code></pre>\n<p>I'll concentrate on modifying the result of <code>foo()</code>, so I won't repeat all of the assembly code again but instead only bits and pieces.</p>\n<p>btw: GCC created the extra indentation for the <code>nop</code> instructions, but it makes it easy to spot them, of course.</p>\n<h2>Steps to get from C to executable with tinkering involved</h2>\n<p>Here are the steps to get to the modified program.</p>\n<ul>\n<li>use <code>gcc -S test.c</code> to get a <code>test.s</code> file</li>\n<li>modify the <code>test.s</code></li>\n<li>Assemble it with <code>gas -o test.o test.s</code></li>\n<li>Link with GCC using <code>gcc -o test test.o</code></li>\n</ul>\n<h2>Modifications to the assembly code</h2>\n<p>First, I felt compelled to \"optimize\" the instructions in <code>LL6</code>, <code>LL9</code>, <code>LL5</code>, <code>LL8</code>, <code>LL11</code> and <code>LL1</code> like this:</p>\n<pre><code>.LL6:\n        mov     3, %i0\n        b       .LL1\n         nop\n.LL9:\n        mov     -1, %i0\n        b       .LL1\n         nop\n.LL5:\n        mov     1, %i0\n        b       .LL1\n         nop\n.LL8:\n        mov     2, %i0\n        b       .LL1\n         nop\n.LL11:\n        mov     4, %i0\n.LL1:\n        ret\n        restore\n</code></pre>\n<p>It should be clear that if your colleague is right, we should be able to substitute the <code>nop</code> instructions for a <code>mov ..., %i0</code> to see something other than the expected value.</p>\n<p>I called my modified assembly file <code>modified.s</code> so as to not confuse myself ;)</p>\n<h3>Verifying my \"optimizations\"</h3>\n<p>First test is with my \"optimizations only\". I wrote a little test script:</p>\n<pre><code>#!/usr/bin/env bash\nfor i in optimized test; do\n        echo -n \"$i: \"; ./$i\n        echo -n \"$i: \"; ./$i a1\n        echo -n \"$i: \"; ./$i a1 a2\n        echo -n \"$i: \"; ./$i a1 a2 a3\ndone\n</code></pre>\n<p>The binaries are called <code>optimized</code> (my \"optimizations\" from above) and <code>test</code> (plain assembly created by GCC from C code).</p>\n<p><strong>Results:</strong></p>\n<pre><code>$ ./runtest\noptimized: Hello world: 1\noptimized: Hello world: 3\noptimized: Hello world: 4\noptimized: Hello world: 2\ntest: Hello world: 1\ntest: Hello world: 3\ntest: Hello world: 4\ntest: Hello world: 2\n</code></pre>\n<p>So my \"optimizations\" seem to be just fine. Now let's tinker a little.</p>\n<h3>Tinkering with the instructions which modify the program counter</h3>\n<p>The claim is that anything past a <code>jmp</code> (i.e. <code>b</code>) will get executed <em>before</em> the jump itself. We have several labels with jumps, so let's replace the <code>nop</code> in each with something that changes the value inside <code>%i0</code> and thus the return value of <code>foo()</code>.</p>\n<p><strong>The changes:</strong></p>\n<pre><code>.LL6:\n        mov     3, %i0\n        b       .LL1\n        mov     30, %i0\n.LL9:\n        mov     -1, %i0\n        b       .LL1\n        mov     42, %i0\n.LL5:\n        mov     1, %i0\n        b       .LL1\n        mov     10, %i0\n.LL8:\n        mov     2, %i0\n        b       .LL1\n        mov     20, %i0\n.LL11:\n        mov     4, %i0\n.LL1:\n        ret\n        restore\n</code></pre>\n<p>So except for return code <code>-1</code> (which becomes <code>42</code>) and <code>4</code> (which stays the same) everything should now return the original value times ten.</p>\n<p>Let's see the results (I added <code>modified</code> to the list of items in my <code>for</code> loop):</p>\n<pre><code>$ ./runtest\noptimized: Hello world: 1\noptimized: Hello world: 3\noptimized: Hello world: 4\noptimized: Hello world: 2\ntest: Hello world: 1\ntest: Hello world: 3\ntest: Hello world: 4\ntest: Hello world: 2\nmodified: Hello world: 10\nmodified: Hello world: 30\nmodified: Hello world: 4\nmodified: Hello world: 20\n</code></pre>\n<h1>A change that is as close to your example as I can get it</h1>\n<pre><code>        mov     39, %i0\n        jmp     %g1\n        b       .LL11\n        b       .LL1\n.LL6:\n        mov     37, %i0\n        b       .LL1\n        mov     30, %i0\n[...]\n.LL11:\n        mov     4, %i0\n.LL1:\n        ret\n        restore\n</code></pre>\n<p>Amending the test script, here's the output:</p>\n<pre><code>$ ./runtest\noptimized: Hello world: 1\noptimized: Hello world: 3\noptimized: Hello world: 4\noptimized: Hello world: 2\ntest: Hello world: 1\ntest: Hello world: 3\ntest: Hello world: 4\ntest: Hello world: 2\nmodified: Hello world: 10\nmodified: Hello world: 30\nmodified: Hello world: 4\nmodified: Hello world: 20\nquestion: Hello world: 4\nquestion: Hello world: 4\nquestion: Hello world: 4\nquestion: Hello world: 4\n</code></pre>\n<p>Baffling!</p>\n<h1>Result</h1>\n<p>You can play tricks on the reverse engineer's mind with this - no doubt. I learned something new and that alone was worth it.</p>\n<p>Here's the situation</p>\n<pre><code>jmp     %g1\nb       .LL11 ; &lt;-- this is the branch taken\nb       .LL1\nmov     37, %i0 ; &lt;-- but this gets executed first (at least in GDB)\n</code></pre>\n<p>Now I don't know whether this is true for all SPARC machines, but certainly for the one I was using for my tests (specs at the top)</p>\n<h1>Conclusion</h1>\n<p>Yes, this can certainly be used to trick the unwitting reverse engineer and perhaps the disassembler (static analysis tool). It's basically an opaque predicate. I.e. the outcome is clear at compile time, but it looks like it's dynamic.</p>\n<p>It's difficult to see how good different disassemblers cope, given that I only have IDA Pro and <code>objdump</code> available here. My educated guess would be that they cope the same as with other <a href=\"http://en.wikipedia.org/wiki/Opaque_predicate\" rel=\"nofollow noreferrer\">opaque predicates</a>, i.e. sometimes they'll get fooled, sometimes they'll be surprisingly smart. So whether or not this is a suitable obfuscation method remains unsolved.</p>\n<h2>Bonus information</h2>\n<p>As opposed to prior to the edit, IDA seems to be mildly confused by the new code, watch this graph view:</p>\n<p><img alt=\"IDA slightly confused\" src=\"https://i.sstatic.net/1Ybgl.png\"/>\n<a href=\"https://i.sstatic.net/jDzvg.png\" rel=\"nofollow noreferrer\">click here for full size image</a> (<a href=\"https://i.sstatic.net/jDzvg.png\" rel=\"nofollow noreferrer\">previous version</a>)</p>\n<h2>Little GDB session</h2>\n<p><code>0x106CC</code> is the <code>mov 39, %i0</code> instruction, found via IDA.</p>\n<pre><code>$ gdb -q ./question\n(no debugging symbols found)\n(gdb) b *0x106CC\nBreakpoint 1 at 0x106cc\n(gdb) run a1\nStarting program: /export/home/builder/test/question a1\n[New LWP 1]\n[New LWP 2]\n[LWP 2 exited]\n[New LWP 2]\n(no debugging symbols found)\n(no debugging symbols found)\n\nBreakpoint 1, 0x000106cc in foo ()\n(gdb) disp/i $pc\n1: x/i $pc\n0x106cc &lt;foo+44&gt;:       mov  0x27, %i0\n(gdb) si\n0x000106d0 in foo ()\n1: x/i $pc\n0x106d0 &lt;foo+48&gt;:       jmp  %g1\n0x106d4 &lt;foo+52&gt;:       b  0x1070c &lt;foo+108&gt;\n0x106d8 &lt;foo+56&gt;:       b  0x10710 &lt;foo+112&gt;\n0x106dc &lt;foo+60&gt;:       mov  0x25, %i0\n(gdb)\n0x000106d4 in foo ()\n1: x/i $pc\n0x106d4 &lt;foo+52&gt;:       b  0x1070c &lt;foo+108&gt;\n0x106d8 &lt;foo+56&gt;:       b  0x10710 &lt;foo+112&gt;\n0x106dc &lt;foo+60&gt;:       mov  0x25, %i0\n(gdb)\n0x000106dc in foo ()\n1: x/i $pc\n0x106dc &lt;foo+60&gt;:       mov  0x25, %i0\n(gdb)\n0x0001070c in foo ()\n1: x/i $pc\n0x1070c &lt;foo+108&gt;:      mov  4, %i0\n(gdb)\n0x00010710 in foo ()\n1: x/i $pc\n0x10710 &lt;foo+112&gt;:      ret\n0x10714 &lt;foo+116&gt;:      restore\n(gdb)\n</code></pre>\n<p>So according to GDB we are executing the <code>mov 37, %i0</code> before the branching. This seems to suggest to me that even when you chain multiple branch instructions, the first thing to be executed is whatever comes after the last one in the chain.</p>\n</div>",
            "votes": "8",
            "user": "perror",
            "time": "Apr 30, 2013 at 7:37",
            "is_accepted": true,
            "comments": [
                {
                    "user": "0xC0000022L",
                    "text": "<span class=\"comment-copy\">@perror: concerning your edit (thanks!), have a <a href=\"http://userscripts.org/scripts/show/111973\" rel=\"nofollow noreferrer\">look at this user script</a>, I've been using it for a while now.</span>",
                    "time": null
                },
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">You compare this to an <i>opaque predicate</i>, but it only fuzz the structure of the CFG. I don't think it breaks the analyzer at a semantic level (except if you do not know what a <code>jmp</code> is suppose to do in SPARC). Or maybe I did miss something ?</span>",
                    "time": null
                }
            ]
        }
    ]
}