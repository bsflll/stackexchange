{
    "title": "Restoring original stack variable in IDA Pro?",
    "link": "https://reverseengineering.stackexchange.com/questions/27875/restoring-original-stack-variable-in-ida-pro",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I would like to convert an instruction like:<br/>\n<code>lea     ecx, [esp+150h+var_13E+2]</code><br/>\nto:<br/>\n<code>lea     ecx, [esp+14h]</code><br/>\nI know it's possible to do this with the key <code>K</code>. But I'm writing an IDAPython plugin that needs an automatic conversion of instructions like the one above.</p>\n<p>Edit:\nAre there any idaapi functions to do this?</p>\n</div>",
    "votes": "1",
    "answers": 2,
    "views": "71",
    "tags": [
        "ida",
        "idapython",
        "ida-plugin"
    ],
    "user": "Žiga Šumenjak",
    "time": "Jun 22, 2021 at 12:17",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<pre><code>idaapi.op_seg(idc.get_screen_ea(), -1)\nidaapi.op_stkvar(idc.get_screen_ea(), -1)\n</code></pre>\n</div>",
            "votes": "1",
            "user": "0xC0000022L",
            "time": "Jun 22, 2021 at 15:06",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Disclaimer: <em>I am the author of the ida-minsc plugin (which aims to make idapython not suck) at <a href=\"https://github.com/arizvisa/ida-minsc/tree/persistence-refactor\" rel=\"nofollow noreferrer\">https://github.com/arizvisa/ida-minsc</a></em></p>\n<p>Using minsc, toggling the representation of an operand between hexadecimal or a frame variable can be done with <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op_hexadecimal\" rel=\"nofollow noreferrer\"><code>instruction.op_hexadecimal</code></a> or <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op_stackvar\" rel=\"nofollow noreferrer\"><code>instruction.op_stack</code></a>. These functions act on a single operand and take an address and an operand number.</p>\n<pre><code>Python&gt;db.disasm()\n'401304: lea ecx, [esp+14h]'\n\nPython&gt;ins.op_stack(h(), 1)\n&lt;member '$ F4012D0.var_284' index=5 offset=-0x288 size=+0x4 typeinfo='LPDWORD'&gt;\n\nPython&gt;db.disasm()\n'401304: lea ecx, [esp+298h+var_284]'\n\nPython&gt;ins.op_hex(1)\n0x14\n\nPython&gt;db.disasm()\n'401304: lea ecx, [esp+14h]'    \n</code></pre>\n<p>Selecting these instructions within a function can then be done with the <a href=\"https://arizvisa.github.io/ida-minsc/modules/function.html#function.chunks.register\" rel=\"nofollow noreferrer\"><code>function.register</code></a> function. Despite the semantics of Intel's <code>lea</code> instruction having the effect of doing SIB arithmetic and storing the result to a register, this can be treated as a load instruction using the <code>%esp</code> register. This should be parallel to the <code>o_mem</code> and <code>o_displ</code> operand types documented in the SDK as <a href=\"https://hex-rays.com/products/ida/support/sdkdoc/group__o__.html\" rel=\"nofollow noreferrer\">Operand types</a>.</p>\n<pre><code>Python&gt;for ref in func.register('esp', load=True):\nPython&gt; print(db.disasm(ref))\nPython&gt;\n401304: lea ecx, [esp+14h]\n</code></pre>\n<p>However, it's pretty likely that we'd also want instructions that write to the <code>%esp</code> register as well. To enumerate both loads and stores depending on the <code>%esp</code> register (and eventually change the operand), we can chain them together using <code>itertools.chain</code>...essentially ORing them.</p>\n<pre><code>Python&gt;for ref in itertools.chain(func.register(ins.reg.esp, store=True), func.register(ins.reg.esp, load=True)):\nPython&gt; print(db.disasm(ref))\nPython&gt;\n\n40177f: mov dword ptr [esp+8], offset ConnectionHandler(x)\n401787: mov dword ptr [esp+4], 0\n40178f: mov dword ptr [esp], 0\n...\n4017a9: mov [esp], eax\n401304: lea ecx, [esp+14h]\n</code></pre>\n<p>If you're not in a function (which makes no sense for frame variables), you can also use the <a href=\"https://github.com/arizvisa/ida-minsc/blob/persistence-refactor/base/instruction.py#L274\" rel=\"nofollow noreferrer\"><code>instruction.ops_register</code></a> function to filter an instruction's operands. By combining this with the <a href=\"https://arizvisa.github.io/ida-minsc/modules/database.html#database-address\" rel=\"nofollow noreferrer\"><code>database.address</code></a> function, you can do a similar selection on any number of instructions that interact with registers in a particular way.</p>\n<pre><code>Python&gt;for ea in db.a(function.chunk()):\nPython&gt; for ref in ins.ops_register(ea, ins.reg.esp, write=True, store=False):\nPython&gt;  print([ins.op_repr(ref), db.disasm(ref)])\nPython&gt;\n\n['esp', '4012d4: sub esp, 294h']\n['esp', '4012da: and esp, 0FFFFFFF0h']\n['esp', '401466: sub esp, 8']\n...\n['esp', '401714: sub esp, 4']\n['esp', '40173a: sub esp, 4']\n['esp', '40174e: sub esp, 4']\n['esp', '40179b: sub esp, 18h']\n['esp', '4017b1: sub esp, 4']\n</code></pre>\n<p>These results can then be combined with the <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op_stackvar\" rel=\"nofollow noreferrer\"><code>instruction.op_stack</code></a> function. The following python changes everything to a stack variable, outputs the reference, the result, and a disassembly of the modified instruction (for the purpose of demonstrating all of the available input types and their usage).</p>\n<pre><code>Python&gt;for ref in itertools.chain(func.register(ins.reg.esp, store=True), func.register(ins.reg.esp, load=True)):\nPython&gt; lvar = ins.op_stack(ref)\nPython&gt; print(ref, lvar)\nPython&gt; print(db.disasm(ref))\nPython&gt;\n\nopref_t(address=0x40176d, opnum=0, access=access_t(&amp;w)) &lt;member '$ F4012D0.arg_C' index=24 offset=0x10 size=+0x4 typeinfo='DWORD'&gt;\n40176d: mov [esp-4+arg_C], 0\nopref_t(address=0x40177b, opnum=0, access=access_t(&amp;w)) &lt;member '$ F4012D0.envp' index=23 offset=0xc size=+0x4 typeinfo='const char**'&gt;\n40177b: mov [esp-4+envp], eax\nopref_t(address=0x40177f, opnum=0, access=access_t(&amp;w)) &lt;member '$ F4012D0.argv' index=22 offset=0x8 size=+0x4 typeinfo='const char**'&gt;\n40177f: mov [esp-4+argv], offset ConnectionHandler(x)\n...\nopref_t(address=0x401787, opnum=0, access=access_t(&amp;w)) &lt;member '$ F4012D0.argc' index=21 offset=0x4 size=+0x4 typeinfo='int'&gt;\n401787: mov [esp-4+argc], 0\nopref_t(address=0x401304, opnum=1, access=access_t(&amp;r)) &lt;member '$ F4012D0.var_284' index=5 offset=-0x288 size=+0x4 typeinfo='LPDWORD'&gt;\n401304: lea ecx, [esp+298h+var_284]\n</code></pre>\n<p>Similarly, it can also be combined with the <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op_hexadecimal\" rel=\"nofollow noreferrer\"><code>instruction.op_hex</code></a> function, or really any of the <a href=\"https://arizvisa.github.io/ida-minsc/modules/instruction.html#instruction.op\" rel=\"nofollow noreferrer\"><code>instruction.op_*</code></a> functions.</p>\n<pre><code>Python&gt;for ref in itertools.chain(func.register(ins.reg.esp, store=True), func.register(ins.reg.esp, load=True)):\nPython&gt; discarded = ins.op_hex(ref)\nPython&gt; print(db.disasm(ref))\n\n40176d: mov dword ptr [esp+10h], 0\n40177b: mov [esp+0Ch], eax\n40177f: mov dword ptr [esp+8], offset ConnectionHandler(x)\n...\n401787: mov dword ptr [esp+4], 0\n40178f: mov dword ptr [esp], 0\n4017a9: mov [esp], eax\n401304: lea ecx, [esp+14h]\n</code></pre>\n</div>",
            "votes": "1",
            "user": "Ali Rizvi-Santiago",
            "time": "Aug 12, 2024 at 18:27",
            "is_accepted": false,
            "comments": []
        }
    ]
}