{
    "title": "Format of data in the .code/.text section",
    "link": "https://reverseengineering.stackexchange.com/questions/29140/format-of-data-in-the-code-text-section",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm attempting to dissect/disassemble a windows PE file under Linux using objdump.  On surface analysis, the .code section was disassembled to :</p>\n<pre><code>tmp.exe:     file format pei-i386\n\n\nDisassembly of section CODE:\n\n00401000 &lt;CODE&gt;:\n  401000:       04 10                   add    $0x10,%al\n  401002:       40                      inc    %eax\n  401003:       00 03                   add    %al,(%ebx)\n  401005:       07                      pop    %es\n  401006:       42                      inc    %edx\n  401007:       6f                      outsl  %ds:(%esi),(%dx)\n  401008:       6f                      outsl  %ds:(%esi),(%dx)\n  401009:       6c                      insb   (%dx),%es:(%edi)\n  40100a:       65                      gs\n  40100b:       61                      popa\n  40100c:       6e                      outsb  %ds:(%esi),(%dx)\n  40100d:       01 00                   add    %eax,(%eax)\n  40100f:       00 00                   add    %al,(%eax)\n  401011:       00 01                   add    %al,(%ecx)\n  401013:       00 00                   add    %al,(%eax)\n  401015:       00 00                   add    %al,(%eax)\n  ...\n</code></pre>\n<p>Then I looked at the entry point which was 0x45e534, which\nended up within an opcode:</p>\n<pre><code>\n  45e52f:       00 dc                   add    %bl,%ah\n  45e531:       e2 45                   loop   0x45e578\n  45e533:       00 55 8b                add    %dl,-0x75(%ebp)\n  45e536:       ec                      in     (%dx),%al\n  45e537:       83 c4 f0                add    $0xfffffff0,%esp\n  45e53a:       b8 04 e3 45 00          mov    $0x45e304,%eax\n  45e53f:       e8 e0 84 fa ff          call   0x406a24\n</code></pre>\n<p>Which, I feel is very wrong; but since my understanding of assembly is lacking, I could be wrong.</p>\n<p>So having read [1] and the chapter on Disassembly in \"Practical Malware Analysis\", I realized that there could be data in the .text (or in this case, CODE) section.  So I took a gander at the\nhex dump on the file and came across at the beginning of\nthe code section:</p>\n<pre><code>0000400: 0410 4000 0307 426f 6f6c 6561 6e01 0000  <a class=\"__cf_email__\" data-cfemail=\"a58b8be58b8b8be7cacac9c0c4cb\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>...\n0000410: 0000 0100 0000 0010 4000 0546 616c 7365  <a class=\"__cf_email__\" data-cfemail=\"af8181818181818181ef8181e9cec3dcca\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>\n0000420: 0454 7275 658d 4000 2c10 4000 0204 4368  .True.@.,<a class=\"__cf_email__\" data-cfemail=\"8fa1cfa1a1a1cce7\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>\n0000430: 6172 0100 0000 00ff 0000 0090 4010 4000  ar..........@.@.\n0000440: 0107 496e 7465 6765 7204 0000 0080 ffff  ..Integer.......\n0000450: ff7f 8bc0 5810 4000 0104 4279 7465 0100  <a class=\"__cf_email__\" data-cfemail=\"b49a9a9a9aec9af49a9a9af6cdc0d1\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>..\n0000460: 0000 00ff 0000 0090 6c10 4000 0104 576f  <a class=\"__cf_email__\" data-cfemail=\"be9090909090909090d290fe909090e9d1\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>\n0000470: 7264 0300 0000 00ff ff00 0090 8010 4000  rd............@.\n0000480: 0108 4361 7264 696e 616c 0500 0000 00ff  ..Cardinal......\n0000490: ffff ff90 9810 4000 0a06 5374 7269 6e67  <a class=\"__cf_email__\" data-cfemail=\"654b4b4b4b4b4b254b4b4b3611170c0b02\" href=\"/cdn-cgi/l/email-protection\">[email protected]</a>\n...\n\n</code></pre>\n<p>This lead me to believe that there is definitely DATA in the code section [but, again, I could be wrong].</p>\n<p>My question is (even given [1]), is it possible to figure out what the format of the DATA is in that part of the binary?</p>\n<p>With my limited understanding, I'm guessing it's a structure of some sort <em>or</em> possibly a long list of DB/DW but (again, I could be wrong).</p>\n<p>For instance, the very first set:</p>\n<pre><code>0410 4000 0307 426f 6f6c 6561 6e01 00 00..\n\n</code></pre>\n<p>Could the above be translated to something like (in assembly)</p>\n<pre><code>   DB 0x00401004\n   DB 0x0703\n   DB \"Boolean\"\n   ...\n</code></pre>\n<p>I tried to look for the opcode DB in [2] but couldn't find it, so I'm wondering if I'm barking up the wrong tree.</p>\n<p>Any help/pointers appreciated</p>\n<p>:ewong</p>\n<p>[1] - <a href=\"https://reverseengineering.stackexchange.com/questions/16498/how-do-reverse-engineers-commonly-detect-the-format-of-binary-data\">How do reverse engineers commonly detect the format of binary data?</a></p>\n<p>[2] - <a href=\"http://mathemainzel.info/files/x86asmref.html\" rel=\"nofollow noreferrer\">http://mathemainzel.info/files/x86asmref.html</a></p>\n</div>",
    "votes": "0",
    "answers": 2,
    "views": "377",
    "tags": [
        "disassembly",
        "malware",
        "static-analysis"
    ],
    "user": "ewokx",
    "time": "Aug 16, 2021 at 10:09",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>objdump disassembles linearly, it does not do control flow, so you may get gibberish in return. Use</p>\n<pre><code>objdump -f \n</code></pre>\n<p>to get the entry point, and use that address as <code>--start-address</code> argument.</p>\n<p>Be aware — since it is linear, it will disassemble from this address till the end of the binary or end of the code section, so you may need to provide a <code>--stop-address</code>, too, if you don't want a seemingly endless spew.</p>\n<pre><code>:\\&gt;f:\\mingw\\bin\\objdump.exe -f .\\getinst.exe\n\n.\\getinst.exe:     file format pei-i386\narchitecture: i386, flags 0x0000012f:\nHAS_RELOC, EXEC_P, HAS_LINENO, HAS_DEBUG, HAS_LOCALS, D_PAGED\nstart address 0x00404ee3 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n</code></pre>\n<p>Disassembling some bytes from a specific address:</p>\n<pre><code>:\\&gt;f:\\mingw\\bin\\objdump.exe -d --start-address 0x00404ee3 --stop-address 0x00404f00 .\\getinst.exe\n\n.\\getinst.exe:     file format pei-i386\n\n\nDisassembly of section .text:\n\n00404ee3 &lt;.text+0x3ee3&gt;:\n  404ee3:       e8 0a 07 00 00          call   0x4055f2\n  404ee8:       e9 74 fe ff ff          jmp    0x404d61\n  404eed:       8b 4d f4                mov    -0xc(%ebp),%ecx\n  404ef0:       64 89 0d 00 00 00 00    mov    %ecx,%fs:0x0\n  404ef7:       59                      pop    %ecx\n  404ef8:       5f                      pop    %edi\n  404ef9:       5f                      pop    %edi\n  404efa:       5e                      pop    %esi\n  404efb:       5b                      pop    %ebx\n  404efc:       8b e5                   mov    %ebp,%esp\n  404efe:       5d                      pop    %ebp\n  404eff:       51                      push   %ecx\n</code></pre>\n<p>If you notice, the instruction at <code>0x404eed</code> may never be executed as there is a hard-coded <code>jmp</code> which will divert the control flow, so all disassembly after the jmp might be gibberish and useless.</p>\n<p>You may <code>need</code> to provide <code>0x404d61</code> as <code>--start-address</code> for following the flow as below:</p>\n<pre><code>:\\&gt;f:\\mingw\\bin\\objdump.exe -d --start-address 0x404d61 --stop-address 0x404d80 .\\getinst.exe\n\n.\\getinst.exe:     file format pei-i386\n\n\nDisassembly of section .text:\n\n00404d61 &lt;.text+0x3d61&gt;:\n  404d61:       6a 14                   push   $0x14\n  404d63:       68 b0 9c 42 00          push   $0x429cb0\n  404d68:       e8 53 0b 00 00          call   0x4058c0\n  404d6d:       6a 01                   push   $0x1\n  404d6f:       e8 d9 02 00 00          call   0x40504d\n  404d74:       59                      pop    %ecx\n  404d75:       84 c0                   test   %al,%al\n  404d77:       0f 84 50 01 00 00       je     0x404ecd\n  404d7d:       32 db                   xor    %bl,%bl\n  404d7f:       88                      .byte 0x88\n</code></pre>\n<p>If you notice, you may still see gibberish at <code>0x404d7d</code>. That is because the provided stop-address is insufficient to decode the bytes into a sensible instruction.</p>\n<pre><code>:\\&gt;f:\\mingw\\bin\\objdump.exe -M intel -d --start-address 0x404d7d --stop-address 0x404d8b .\\getinst.exe\n\n.\\getinst.exe:     file format pei-i386\n\n\nDisassembly of section .text:\n\n00404d7d &lt;.text+0x3d7d&gt;:\n  404d7d:       32 db                   xor    bl,bl\n  404d7f:       88 5d e7                mov    BYTE PTR [ebp-0x19],bl\n  404d82:       83 65 fc 00             and    DWORD PTR [ebp-0x4],0x0\n  404d86:       e8 90 02 00 00          call   0x40501b\n</code></pre>\n<p>Edit</p>\n<pre><code>db = define byte like  size(1)  \"\\xff\"   \ndw = define word like  size(2)  \"\\xff\\xff\"  \ndd = define dword like size(4)  \"\\xff\\xff\\xff\\xff\"     \ndq = define qword like size(8)  \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"  \n</code></pre>\n</div>",
            "votes": "1",
            "user": "MarianD",
            "time": "Aug 16, 2021 at 18:27",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Delphi executables store read only data such as RTTI (Run time type information) at the start of CODE section. <code>objdump</code> can’t know that it’s not really code so it tries to disassemble it as instructions and you get nonsense.</p>\n</div>",
            "votes": "0",
            "user": "Igor Skochinsky",
            "time": "Aug 18, 2021 at 20:16",
            "is_accepted": false,
            "comments": []
        }
    ]
}