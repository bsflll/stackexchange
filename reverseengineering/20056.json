{
    "title": "IDA does not create Vtbl structs for child classes loaded from PDB",
    "link": "https://reverseengineering.stackexchange.com/questions/20056/ida-does-not-create-vtbl-structs-for-child-classes-loaded-from-pdb",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm decompiling a MFC 4.0 application, and now loaded the <code>MFCS42.PDB</code> from the MFC 4.2 source into IDA 7.0 (not having the MFC 4.0 source) to make it create the appropriate structs representing the many MFC classes and virtual function tables.</p>\n<p>However, IDA seems to only create <code>*Vtbl</code> structs for the very base classes, like <code>CObject</code>, not for child classes like <code>CCmdTarget</code>, which looks as follows:</p>\n<pre><code>struct CObjectVtbl // totally correct\n{\n    CRuntimeClass *(__thiscall *GetRuntimeClass)(CObject *this);\n    void (__thiscall *~CObject)(CObject *this);\n    void (__thiscall *Serialize)(CObject *this, CArchive *);\n    void (__thiscall *AssertValid)(CObject *this);\n    void (__thiscall *Dump)(CObject *this, CDumpContext *);\n};\nstruct __cppobj CObject // totally correct\n{\n    CObjectVtbl *vfptr;\n};\n\nstruct __cppobj CCmdTarget : CObject // wrong, makes it have only a CObject vftable\n{\n    int m_dwRef;\n    IUnknown *m_pOuterUnknown;\n    unsigned int m_xInnerUnknown;\n    CCmdTarget::XDispatch m_xDispatch;\n    int m_bResultExpected;\n    CCmdTarget::XConnPtContainer m_xConnPtContainer;\n    AFX_MODULE_STATE *m_pModuleState;\n};\n</code></pre>\n<p>In effect, this results in missing new virtual functions of <code>CCmdTarget</code>, as it only references the <code>CObjectVtbl</code> by inheriting from <code>CObject</code>, but <code>CCmdTarget</code> has 7 more methods.</p>\n<p>I previously hand-crafted these structures (which is tedious as you can guess), and it should actually look more like this:</p>\n<pre><code>// CObject and CObjectVtbl same as above\n\nstruct CCmdTargetVtbl : CObjectVtbl // inherit to keep base methods\n{\n    BOOL (__thiscall *OnCmdMsg)(CCmdTarget *this, UINT nID, int nCode, void *pExtra, void *pHandlerInfo);\n    void (__thiscall *OnFinalRelease)(CCmdTarget *this);\n    AFX_MSGMAP *(__thiscall *GetMessageMap)(CCmdTarget *this);\n    int field_20; // Don't know names yet\n    int field_24;\n    int field_28;\n    int field_2C;\n};\nstruct CCmdTargetMembers // member struct to reuse it in child classes\n{\n    int m_dwRef;\n    IUnknown *m_pOuterUnknown;\n    unsigned int m_xInnerUnknown;\n    CCmdTarget::XDispatch m_xDispatch;\n    int m_bResultExpected;\n    CCmdTarget::XConnPtContainer m_xConnPtContainer;\n    AFX_MODULE_STATE *m_pModuleState;\n};\nstruct CCmdTarget\n{\n    CCmdTargetVtbl *vfptr;\n    CCmdTargetMembers members;\n};\n</code></pre>\n<p>Only this way, accessing virtual functions on child classes makes sense as their vftables are known. A sample hexrays decompilation shows that it does not make much sense with only the base vftables available:</p>\n<p><strong>Decompilation with child vftables:</strong></p>\n<pre><code>int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n    int nReturnCode; // esi MAPDST\n    CWinApp *pWinApp; // edi\n    CWinThreadVtbl *pThread; // ebx\n\n    nReturnCode = -1;\n    pWinApp = (CWinApp *)CBumperApp::instance;\n    if ( AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nShowCmd) )\n    {\n        pThread = &amp;pWinApp-&gt;vftable-&gt;CWinThread;\n        if ( pWinApp-&gt;vftable-&gt;InitApplication(pWinApp) )\n        {\n            if ( pThread-&gt;InitInstance((CWinThread *)pWinApp) )\n            {\n                nReturnCode = pThread-&gt;Run((CWinThread *)pWinApp);\n            }\n[...]\n</code></pre>\n<p><strong>Decompilation without child vftables:</strong></p>\n<pre><code>int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n    int nReturnCode; // esi MAPDST\n    CWinApp *pWinApp; // edi\n    CObjectVtbl *pThread; // ebx\n\n    nReturnCode = -1;\n    pWinApp = CBumperApp::instance;\n    if ( AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nShowCmd) )\n    {\n        pThread = pWinApp-&gt;vfptr;\n        if ( pWinApp-&gt;vfptr[5].GetRuntimeClass(pWinApp) ) // nonsense\n        {\n            if ( (pThread[2].Serialize)(pWinApp) ) // nonsense\n            {\n                nReturnCode = (pThread[2].AssertValid)(pWinApp); // nonsense\n            }\n[...]\n</code></pre>\n<p>Is there any way to get IDA to load the vftables for child classes from the PDB and create all required structs? Or is this not yet possible in IDA 7.0?</p>\n<p>To my knowledge, the PDB should have that info. Is there a tool to look into the PDB file to see if it indeed has this info?</p>\n</div>",
    "votes": "3",
    "answers": 1,
    "views": "2k",
    "tags": [
        "ida",
        "virtual-functions",
        "pdb"
    ],
    "user": "Ray",
    "time": "Dec 6, 2018 at 7:56",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>As far as I know, everything you've said is 100% correct. I've experienced the same issues. In fact, I was working on this exact problem in the background when a friend sent me a link to this post.</p>\n<p>There are actually three related issues here. First, prior to IDA 7.2, IDA's type system did not have a concept of a virtual function table per se. Meaning, although you can create a structure with a bunch of function pointers in it, IDA did not have a mechanism for changing the type of the VTable pointer in a derived object. \"Derivation\" meant simply that everything from the base class was included literally at offset 0. Fortunately, IDA 7.2 does understand the concept of VTables in inheritance. There is <a href=\"https://www.hex-rays.com/products/ida/support/idadoc/1691.shtml\" rel=\"noreferrer\">a bit of documentation</a> on Hex-Rays' website. The end of that page summarizes the rules:</p>\n<blockquote>\n<ul>\n<li>VFT pointer must have the \"__vftable\" name</li>\n<li>VFT type must follow the \"CLASSNAME_vtbl\" pattern</li>\n<li>For multiple inheritance use \"CLASSNAME_%04X_vtbl\" as the VFT type name\n  where %04X corresponds to the offset of the vft pointer in CLASSNAME\n  in the case if the offset is not zero</li>\n</ul>\n</blockquote>\n<p>The second issue is that the PDB plugin currently does not take advantage of these recent changes to the type system. I.e., it does not generate VTable type/class VTable member names according to the rules above.</p>\n<p>The third issue is that the PDB file format is, frankly, a nightmare. You can view the contents of a PDB with the \"dia2dump\" sample that comes with Visual Studio (in the \"DIA SDK\" directory), however, be forewarned that the output is often wrong, misleading, or missing important information. The handling of virtual function information is especially terrible. I haven't completed my investigations, but one thing I've learned so far is that only base classes have <a href=\"https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/vtable?view=vs-2017\" rel=\"noreferrer\"><code>SymTagVTable</code> symbols</a>. I.e., for a class <code>B</code> that derives from another class <code>A</code> with a VTable, only <code>A</code> will have a <code>SymTagVTable</code> symbol, not <code>B</code>. This is even true if <code>B</code> defines additional virtual functions that were not defined in <code>A</code>. And currently, the PDB plugin only creates VTables if the class has a <code>SymTagVTable</code> symbol, hence the behavior that you are seeing. Instead, you have to iterate through the member functions of <code>B</code> and check whether they are virtual using the <a href=\"https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/idiasymbol-get-virtual?view=vs-2017\" rel=\"noreferrer\"><code>get_virtual</code> method</a> -- which, by the way, is something that dia2dump does not do. I'm still investigating how all of this works for multiple inheritance.</p>\n<p>In short, the solution to your problem -- and my problem -- lies in modifying the IDA 7.2 PDB plugin (which comes with the SDK) to:</p>\n<ol>\n<li>Recover VTable information for derived classes, including the multiple inheritance scenario</li>\n<li>Name the VTable structure types in a suitable way based on the class names (and displacement offset in the case of multiple inheritance)</li>\n<li>Use the new features in <code>typeinf.hpp</code> to mark the VTable pointer with attribute <code>TAFLD_VFTABLE</code>, and the VTable structure itself with attribute <code>TAUDT_VFTABLE</code>.</li>\n</ol>\n<p>Again, this is what I am also currently working on.</p>\n</div>",
            "votes": "7",
            "user": "Rolf Rolles",
            "time": "Dec 5, 2018 at 21:06",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Ray",
                    "text": "<span class=\"comment-copy\">This is a great coverage of what is new in IDA 7.2 on CPP / OOP things. I already quickly read about it, but did not realize it already starts here. I'm not eligible to update to 7.2 at this time, but I'm looking forward to do so in the future, and try to at least name my structures and fields in a way to match their new pattern for now, maybe via a script.</span>",
                    "time": null
                }
            ]
        }
    ]
}