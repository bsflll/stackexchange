{
    "title": "Understanding RE output of a simple C++ program",
    "link": "https://reverseengineering.stackexchange.com/questions/22086/understanding-re-output-of-a-simple-c-program",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to learn RE and I decided to explore this field by reverse engineering a simple C++ program, which I post here:</p>\n<p><strong>SIMPLE C++ PROGRAM</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int value;\n    std::cout &lt;&lt; \"Hello Word\";\n    std::cin &gt;&gt; value;\n\n    return 0;\n}\n</code></pre>\n<p>I compiled it using MSVC compiler (VS 2017, x86 build). I wanted to understand the assembly language behind it.</p>\n<p>For RE I use Ghidra tool. I am currently focused only on understanding the assembly part, rather than Decompiled part, because that one makes less sense to me at the moment, but mayber if I understand the Assembly part, I would be able to decode the decompiled output.</p>\n<p><strong>ASSEMBLY OUTPUT:</strong></p>\n<pre><code>                     //\n                     // .text \n                     // ram: 00401000-00401f9a\n                     //\n                     **************************************************************\n                     *                          FUNCTION                          *\n                     **************************************************************\n                     int __cdecl main(void)\n     int               EAX:4          &lt;RETURN&gt;\n     int               EAX:4          value                                   XREF[1]:     00401032(W)  \n     char *            Stack[-0x8]:4  hello_string                            XREF[2]:     0040100d(W), \n                                                                                           0040102b(R)  \n     undefined1        Stack[-0xc]:1  local_c                                 XREF[1]:     00401021(*)  \n                     .text$mn                                        XREF[3]:     0040012c(*), 00400204(*), \n                     main                                                         __scrt_common_main_seh:00401500(\n00401000 55              PUSH       EBP\n00401001 8b ec           MOV        EBP,ESP\n00401003 83 ec 08        SUB        ESP,0x8\n00401006 a1 04 30        MOV        EAX,[___security_cookie]                         = BB40E64Eh\n         40 00\n0040100b 33 c5           XOR        EAX,EBP\n0040100d 89 45 fc        MOV        dword ptr [EBP + hello_string],EAX\n00401010 8b 0d 54        MOV        ECX,dword ptr [-&gt;MSVCP140.DLL::std::cout]        = 000027ec\n         20 40 00\n00401016 e8 25 00        CALL       std::operator&lt;&lt;&lt;struct_std::char_traits&lt;char&gt;_&gt;  basic_ostream&lt;char,struct_std::c\n         00 00\n0040101b 8b 0d 4c        MOV        ECX,dword ptr [-&gt;MSVCP140.DLL::std::cin]         = 0000284a\n         20 40 00\n00401021 8d 45 f8        LEA        EAX=&gt;local_c,[EBP + -0x8]\n00401024 50              PUSH       EAX\n00401025 ff 15 34        CALL       dword ptr [-&gt;MSVCP140.DLL::std::basic_istream&lt;\n         20 40 00\n0040102b 8b 4d fc        MOV        ECX,dword ptr [EBP + hello_string]\n0040102e 33 c0           XOR        EAX,EAX\n00401030 33 cd           XOR        ECX,EBP\n00401032 e8 fe 02        CALL       @__security_check_cookie@4                       undefined @__security_check_cook\n         00 00\n00401037 8b e5           MOV        ESP,EBP\n00401039 5d              POP        EBP\n0040103a c3              RET\n</code></pre>\n<p>I am trying to follow the assembly code line by line. I understand some basics of the registers mentioned there and stack allocation, but I get lost during the <code>dword ptr MOV</code> instructions and then that <code>CALL</code> instruction.</p>\n<p>if anyone could please elaborate to me what is happening actually there, I will start to better understand how to approach assembly code when doing RE tasks.</p>\n</div>",
    "votes": "2",
    "answers": 4,
    "views": "1k",
    "tags": [
        "assembly",
        "c++"
    ],
    "user": "Rebegin",
    "time": "Sep 9, 2019 at 12:36",
    "comments": [
        {
            "user": "blabb",
            "text": "<span class=\"comment-copy\">what command line did you pass to msvc cl.exe ? do you use a project ?  and built it with default ? or did you copy paste correctly there appears to be some thing amiss in the paste</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>The first two lines are function prologue and you will see them at the beginning of almost every function:</p>\n<pre><code>PUSH       EBP\nMOV        EBP,ESP\n</code></pre>\n<p>They basically save the current <code>EBP</code> value and then store current <code>ESP</code> into <code>EBP</code>, so that the local variables and function arguments can be accessed via <code>EBP</code> (<code>ESP</code> has to change when you allocate the memory on the stack). In this case, function arguments passed via the stack will be accessed by <code>[RBP + offset]</code> while local variables by <code>[RBP - offset]</code>.</p>\n<p>The next line is about memory allocation - function reserves <code>8</code> bytes for its own use:</p>\n<pre><code>SUB        ESP,0x8\n</code></pre>\n<p>In the next three lines, there is a protection against <a href=\"https://en.wikipedia.org/wiki/Buffer_overflow\" rel=\"nofollow noreferrer\">buffer overflow</a>.</p>\n<pre><code>MOV        EAX,[___security_cookie]\nXOR        EAX,EBP\nMOV        dword ptr [EBP + hello_string],EAX\n</code></pre>\n<p>Here <code>[EBP + hello_string]</code> contains a random value when <a href=\"https://en.wikipedia.org/wiki/Address_space_layout_randomization\" rel=\"nofollow noreferrer\">ASLR</a> is turned on. The value stored there will likely be different during each program execution and that will make it hard for potential attacker to predict it - if he fails to, it will be detected later on in the line with <code>CALL @__security_check_cookie@4</code>. </p>\n<p>It's important to note here, that the local variable (offset) that you named <code>hello_string</code> doesn't have anything in common with the \"Hello Word\" string - it's there only for preventing exploits.</p>\n<p>Now, let's skip the next two lines for a moment - we'll come back to them later on.</p>\n<p>So, now we have:</p>\n<pre><code>MOV        ECX,dword ptr [-&gt;MSVCP140.DLL::std::cin]\nLEA        EAX=&gt;local_c,[EBP + -0x8]\nPUSH       EAX\nCALL       dword ptr [-&gt;MSVCP140.DLL::std::basic_istream&lt;\n</code></pre>\n<p>The first line passes the global <code>cin</code> object as a first parameter to the operator function. It's because it is the <code>__thiscall</code> convention which (<a href=\"https://docs.microsoft.com/en-us/cpp/cpp/thiscall?view=vs-2019\" rel=\"nofollow noreferrer\">source</a>)</p>\n<blockquote>\n<p>is the default calling convention used by C++ member functions that do not use variable arguments [...] with the <strong>this</strong> pointer being passed via register ECX, and not on the stack, on the x86 architecture. </p>\n</blockquote>\n<p>Then, the pointer to the local variable <code>value</code> is passed and the <code>&gt;&gt;</code> operator member function of <code>cin</code> is being called.</p>\n<p>The remaining lines:</p>\n<pre><code>MOV        ECX,dword ptr [EBP + hello_string]\nXOR        EAX,EAX\nXOR        ECX,EBP\nCALL       @__security_check_cookie@4       \nMOV        ESP,EBP\nPOP        EBP\n</code></pre>\n<p>set <code>EAX</code> (which will contain function return value) to <code>0</code>, then checks whether a buffer overflow occured and then restores the <code>ESP</code> value before allocating space for local variables and the <code>EBP</code> value from the beginning of the function (<code>EBP</code> has to be preserved, otherwise other functions could change it and then <code>ESP</code> would be changed to the wrong value).</p>\n<p>There are two lines not analysed yet:</p>\n<pre><code>MOV        ECX,dword ptr [-&gt;MSVCP140.DLL::std::cout]\nCALL       std::operator&lt;&lt;&lt;struct_std::char_tra\n</code></pre>\n<p>They are problematic for two reasons:</p>\n<ol>\n<li>The second argument to the <code>&lt;&lt;</code> is not being passed (though it's required).</li>\n<li>As you may notice, contrary to the <code>cin</code> case, non-member function is being called, so the first argument should have been passed via stack and not as in the <code>__thiscall</code> convention:\n\n<ol>\n<li><code>&gt;&gt;</code> for (<code>cin</code>, <code>int</code>) is member function: <a href=\"https://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt\" rel=\"nofollow noreferrer\">source</a></li>\n<li><code>&lt;&lt;</code> for (<code>cout</code>, <code>const char*</code>) is non-member function: <a href=\"https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt\" rel=\"nofollow noreferrer\">source</a>.</li>\n</ol></li>\n</ol>\n<p>As you can see in the disassembly posted by @blabb, these two arguments are indeed passed via the stack, while in yours - only one is passed and not by the stack. </p>\n<p>So, it seems that this code doesn't work - it doesn't even reference the string you want to be printed.</p>\n</div>",
            "votes": "1",
            "user": "bart1e",
            "time": "Sep 14, 2019 at 20:16",
            "is_accepted": true,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I think that in this case, <code>hello_string</code> is, in fact, referring to the security cookie storage location. </p>\n<p>in <code>0040100d</code> the stack cookie is saved to the stack. You can <a href=\"https://reverseengineering.stackexchange.com/questions/16241/what-could-be-the-purpose-of-xoring-esp-with-a-global-variable-stack-canary-pr\">Read more here</a> </p>\n</div>",
            "votes": "0",
            "user": "macro_controller",
            "time": "Sep 9, 2019 at 15:41",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>It looks there's something wrong with your code, it looks like there's no parameter for the operator&lt;&lt;.</p>\n<p>Can you try to add either a '\\n' on the string or use <code>&lt;&lt; std::endl</code> and see if the generated code is different?</p>\n</div>",
            "votes": "0",
            "user": "wisk",
            "time": "Sep 10, 2019 at 3:39",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>By default __security_cookie <strong><a href=\"https://docs.microsoft.com/en-us/cpp/preprocessor/strict-gs-check?view=vs-2019\" rel=\"nofollow noreferrer\">is not enabled for all functions</a></strong><br/>\nmsvc vs 2017 does not insert __security_check for the code in question<br/>\neither with optimizations or without optimizations  </p>\n<p>i had to force it with #pragma </p>\n<p>source , commandline for compiling and disassembly as below</p>\n<p>source </p>\n<pre><code>:/&gt;dir /b si*\nsimp.cpp\n\n:/&gt;type simp.cpp\n#include &lt;iostream&gt;\n#pragma strict_gs_check(on) &lt;&lt;&lt; had to force stricter security checks\nint main() {\n    int value;\n    std::cout &lt;&lt; \"Hello Word\";\n    std::cin &gt;&gt; value;\n    return 0;\n}\n</code></pre>\n<p>\\compiled and linked with </p>\n<pre><code>:/&gt;cl /Zi /W4 /analyze /Od /GS /EHsc simp.cpp /link /release\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.16.27025.1 for x86\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nsimp.cpp\nMicrosoft (R) Incremental Linker Version 14.16.27025.1\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n/out:simp.exe\n/debug\n/release\nsimp.obj\n\n:/&gt;simp.exe\nHello Word\n\np\n</code></pre>\n<p>disassembly </p>\n<pre><code>:/&gt;cdb -c \"uf simp!main;q\" simp.exe | awk \"/Reading/,/quit/\"\n0:000&gt; cdb: Reading initial command 'uf simp!main;q'\nsimp!main:\n013a1190 55              push    ebp\n013a1191 8bec            mov     ebp,esp\n013a1193 83ec08          sub     esp,8\n013a1196 a16c904201      mov     eax,dword ptr [simp!__security_cookie (0142906c)]\n013a119b 33c5            xor     eax,ebp\n013a119d 8945fc          mov     dword ptr [ebp-4],eax\n013a11a0 68f0214101      push    offset simp!__xt_z+0x10 (014121f0)\n013a11a5 6830ab4201      push    offset simp!std::cout (0142ab30)\n013a11aa e861010000      call    simp!std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (013a1310)\n013a11af 83c408          add     esp,8\n013a11b2 8d45f8          lea     eax,[ebp-8]\n013a11b5 50              push    eax\n013a11b6 b9b8aa4201      mov     ecx,offset simp!std::cin (0142aab8)\n013a11bb e8b0280000      call    simp!std::basic_istream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&gt;&gt; (013a3a70)\n013a11c0 33c0            xor     eax,eax\n013a11c2 8b4dfc          mov     ecx,dword ptr [ebp-4]\n013a11c5 33cd            xor     ecx,ebp\n013a11c7 e8e63a0200      call    simp!__security_check_cookie (013c4cb2)\n013a11cc 8be5            mov     esp,ebp\n013a11ce 5d              pop     ebp\n013a11cf c3              ret\nquit:\n</code></pre>\n</div>",
            "votes": "0",
            "user": "blabb",
            "time": "Sep 10, 2019 at 7:58",
            "is_accepted": false,
            "comments": []
        }
    ]
}