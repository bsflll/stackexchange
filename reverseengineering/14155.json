{
    "title": "C++ to assembly, GCC vs CL",
    "link": "https://reverseengineering.stackexchange.com/questions/14155/c-to-assembly-gcc-vs-cl",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have following C++ code:</p>\n<pre><code>int main(){\n\n  int a = 1;\n  double d = 1.2;\n\n  return 0;\n}\n</code></pre>\n<p>and get the following assembly using GCC 6.2 -m32:</p>\n<pre><code>main:\n        lea     ecx, [esp+4]\n        and     esp, -8\n        push    DWORD PTR [ecx-4]\n        push    ebp\n        mov     ebp, esp\n        push    ecx\n        sub     esp, 20\n        mov     DWORD PTR [ebp-12], 1\n        fld     QWORD PTR .LC0\n        fstp    QWORD PTR [ebp-24]\n        mov     eax, 0\n        add     esp, 20\n        pop     ecx\n        pop     ebp\n        lea     esp, [ecx-4]\n        ret\n.LC0:\n        .long   858993459\n        .long   1072902963\n</code></pre>\n<p>and using MS CL 19:</p>\n<pre><code>_d$ = -12                                         ; size = 8\n_a$ = -4                                                ; size = 4\n_main   PROC\n        push     ebp\n        mov      ebp, esp\n        sub      esp, 12              ; 0000000cH\n        mov      DWORD PTR _a$[ebp], 1\n        movsd    xmm0, QWORD PTR __real@3ff3333333333333\n        movsd    QWORD PTR _d$[ebp], xmm0\n        xor      eax, eax\n        mov      esp, ebp\n        pop      ebp\n        ret      0\n_main   ENDP\n</code></pre>\n<p>I have several questions.</p>\n<ol>\n<li><p>what's  mean first three lines in GCC version?</p>\n<p><code>lea     ecx, [esp+4]</code></p>\n<p><code>and     esp, -8</code></p>\n<p><code>push    DWORD PTR [ecx-4]</code></p></li>\n<li><p>MS CL version allocates 12 bytes, 4 for int and 8 for double: </p>\n<p><code>sub      esp, 12  // that's great.</code></p>\n<p>But why GCC allocates 24?</p>\n<p><code>push ecx</code></p>\n<p><code>sub esp, 20</code></p></li>\n</ol>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "850",
    "tags": [
        "disassembly",
        "assembly",
        "c++",
        "disassemblers",
        "gcc"
    ],
    "user": "Person.Junkie",
    "time": "Dec 12, 2016 at 22:01",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Given that you didn't specify any optimization flag and used -m32, GCC performed no optimization on your code. The -m32 flag specifies the generation of a 32 bit code for a compiler configured to generate 64 bit code by default. In 32 bit mode, even with optimizations activated, GCC will generate a sub-optimal code given that the only way to do floating point computations in 32 bit mode on Intel machines is through <a href=\"https://en.wikipedia.org/wiki/X87\" rel=\"nofollow noreferrer\">x87</a> instructions. If you remove the -m32 flag and add -O3 (third level of optimization in GCC) you'll obtain the following assembly code (quite similar to the one generated by Microsoft's CL) :</p>\n<pre><code>.LC1:\n        .string \"%d %lf\\n\"\n        .section   .text.startup,\"ax\",@progbits\n        .p2align 4,,15\n        .globl  main\n        .type   main, @function\nmain:\n.LFB0:\n        .cfi_startproc\n        subq    $8, %rsp\n        .cfi_def_cfa_offset 16\n        movl    $1, %esi\n        movl    $.LC1, %edi\n        movsd   .LC0(%rip), %xmm0\n        movl    $1, %eax\n        call    printf\n        xorl    %eax, %eax\n        addq    $8, %rsp\n        .cfi_def_cfa_offset 8\n        ret\n        .cfi_endproc\n.LFE0:\n        .size   main, .-main\n        .section   .rodata.cst8,\"aM\",@progbits,8\n        .align 8\n.LC0:\n        .long   858993459\n        .long   1072902963 \n</code></pre>\n<p><strong>Note :</strong> I added a <strong>printf</strong> to the code because if the GCC optimization pass sees no use of the two variables, they will be removed (dead code elimination). I invite you to check out my post on the subject of optimized vs. non optimized code (<a href=\"https://reverseengineering.stackexchange.com/questions/4011/assembly-code-gcc-optimized-vs-not\">Assembly Code - GCC optimized vs not</a>).</p>\n<p>You can also notice that CL used an <em>XMM</em> register to store the 64 bit <em>double</em> element stored in .LC0. <em>XMM</em> registers are part of the SSE (Streaming SIMD Extensions) instruction set used mainly for floating point scalar &amp; vector operations. Its implementation is much cleaner and faster than the x87 instruction set. </p>\n<p>Q1 :</p>\n<pre><code>lea     ecx, [esp+4]      //load the content of [esp + 4] into ecx\nand     esp, -8           //align the stack pointer to 8 bytes (same as esp &amp; ~7)\npush    DWORD PTR [ecx-4] //push the content of [ecx - 4] on the stack \n\n[ecx - 4] = [[esp + 4] - 4]\n</code></pre>\n<p>Let's suppose the stack is in this state : </p>\n<pre><code>     |       main      |\n     |      return     |\n     |      address @  |\n     +-----------------+  &lt;--- esp + 4 ---&gt; ecx\n     |    some value   |\n     +-----------------+  &lt;--- esp = ebp\n</code></pre>\n<p>The first instruction puts the existing stack content (main return address @) in ecx. It is equivalent to this :</p>\n<pre><code>mov ecx, esp\nsub ecx, 4\nmov ecx, [ecx]\n</code></pre>\n<p>You can see that the lea instruction does in one take what these instructions do in three takes.</p>\n<p>The second instruction aligns esp on an 8 byte boundary. What that means is that the lower 3 order bits of the address pointed by esp will be 0. Memory accesses are faster on Intel machines when aligned on a power of 2 boundary.</p>\n<p>The third instruction changes the state of the stack to the following :</p>\n<pre><code>     |         @       |\n     +-----------------+  &lt;--- esp + 4 ---&gt; ecx\n     |    some value   |\n     +-----------------+  &lt;--- ebp\n     |       @ - 4     |  \n     +-----------------+  &lt;--- esp\n</code></pre>\n<p>Therefore, when the main function is done, it will return to @ - 4.</p>\n<p>Q2 :</p>\n<p>Let's reason mathematically :</p>\n<pre><code>         We have : EBP = ESP0 \n         push ecx implies ESP1 = ESP0 - 4 \n         then : ESP2 = ESP1 - 20 \n         therefore : ESP0 = ESP2 - 24\n         mov DWORD PTR [ebp-12], 1 implies x = EBP - 12 = ESP0 - 12\n         We know that ESP0 = ESP2 - 24\n         Therefore x = ESP2 - 24 - 12 = ESP2 - 36\n         fstp    QWORD PTR [ebp-24] implies y = EBP - 24 = ESP0 - 24\n         Therefore y = ESP2 - 24 - 24 = ESP2 - 48\n</code></pre>\n<p>Now, from this demonstration we extracted the location of the integer <em>x = ESP2 - 36</em>, and the location of the double <em>y = ESP2 - 48</em>.\nTo compute the distance between both variables, we subtract y from x and obtain the following : <em>x - y = ESP2 - 36 - ESP2 + 48 = 48 - 36 = 12</em>. And that's the amount of bytes used by GCC for storing both of your 32 bit/4 byte and 64 bit/8 byte variables.  </p>\n</div>",
            "votes": "4",
            "user": "Community",
            "time": "Apr 13, 2017 at 12:49",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Person.Junkie",
                    "text": "<span class=\"comment-copy\">Thanks, why we have this three lines in GCC 32-bit mode and don't have in 64-bit mode. What is the purpose of this three lines?</span>",
                    "time": null
                },
                {
                    "user": "yaspr",
                    "text": "<span class=\"comment-copy\">Check the Q1 update</span>",
                    "time": null
                }
            ]
        }
    ]
}