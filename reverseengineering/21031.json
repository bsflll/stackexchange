{
    "title": "windbg - What is the relation between the VAD (!vad), the PTEs (!pte), and loaded modules and sections (lm and !dh)?",
    "link": "https://reverseengineering.stackexchange.com/questions/21031/windbg-what-is-the-relation-between-the-vad-vad-the-ptes-pte-and-loade",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>[cross-posted (but closed the original) from <a href=\"https://stackoverflow.com/q/55438806/254959]\">https://stackoverflow.com/q/55438806/254959]</a></p>\n<p>I'm trying to gain a better understanding on Windows process memory, and have some gaps with regards to the relationship between the VAD tree, the PTEs and loaded modules.</p>\n<p>The output below are captured from a kernel debugging session, but in the context of a simple process which runs a simple compiled \"hello world\" C program.</p>\n<ol>\n<li>When I do an <code>lm</code>, there are many modules listed, but when I do a !vad, I only see 5 mapped in (my own process binary and 4 other Windows DLLs).</li>\n</ol>\n<pre><code>kd&gt; lm\nstart             end                 module name\n00007ffd`ea8f0000 00007ffd`ea91b000   vertdll    (deferred)             \n00007ffd`ea920000 00007ffd`eab00000   ntdll      (pdb symbols)          C:\\ProgramData\\Dbg\\sym\\ntdll.pdb\\13B64B553003FA22AB7CCD36A3A5431F1\\ntdll.pdb\nfffff416`a3800000 fffff416`a3b94000   win32kfull   (deferred)             \nfffff416`a3ba0000 fffff416`a3db2000   win32kbase   (deferred)             \nfffff416`a3dc0000 fffff416`a3dca000   TSDDD      (deferred)             \nfffff416`a3dd0000 fffff416`a3e11000   cdd        (deferred)             \nfffff416`a4290000 fffff416`a4307000   win32k     (deferred)             \nfffff800`a5c01000 fffff800`a64d3000   nt         (pdb symbols)          C:\\ProgramData\\Dbg\\sym\\ntkrnlmp.pdb\\31C51B7D1C2545A88F69E13FC73E68941\\ntkrnlmp.pdb\nfffff800`a64d3000 fffff800`a6552000   hal        (deferred)             \nfffff800`a6600000 fffff800`a6647000   kd_02_8086   (deferred)             \n...\nfffff80b`85960000 fffff80b`8597c000   disk       (deferred)             \n...\n</code></pre>\n<pre><code>kd&gt; !vad\nVAD           Level     Start       End Commit\nffff8908f102b0c0  4     7ffe0     7ffe0      1 Private      READONLY           \nffff8908ef465290  3     7ffe1     7ffef     -1 Private      READONLY           \nffff8908f169f100  4   fb63c20   fb63d1f      6 Private      READWRITE          \nffff8908ef4c86e0  2   fb63e00   fb63fff      3 Private      READWRITE          \nffff8908ef17e3b0  3  2e38e030  2e38e03f      0 Mapped       READWRITE          Pagefile section, shared commit 0x10\nffff8908ef592280  4  2e38e040  2e38e046      1 Private      READWRITE          \nffff8908f1873410  1  2e38e050  2e38e068      0 Mapped       READONLY           Pagefile section, shared commit 0x19\nffff8908ef106a00  3  2e38e070  2e38e073      0 Mapped       READONLY           Pagefile section, shared commit 0x4\nffff8908f19eea10  2  2e38e080  2e38e080      0 Mapped       READONLY           Pagefile section, shared commit 0x1\nffff8908f0fba340  3  2e38e090  2e38e090      1 Private      READWRITE          \nffff8908f0fdc980  0  2e38e0a0  2e3900a0      1 Private      READWRITE          \nffff8908ef215060  3  2e390130  2e39022f     17 Private      READWRITE          \nffff8908ef084860  2  2e390230  2e3902f4      0 Mapped       READONLY           \\Windows\\System32\\locale.nls\nffff8908f14e3e90  3 7ff67f9a0 7ff67fa9f      0 Mapped       READONLY           Pagefile section, shared commit 0x5\nffff8908ef3025c0  1 7ff67faa0 7ff67fac2      0 Mapped       READONLY           Pagefile section, shared commit 0x23\nffff8908f0ef7c70  4 7ff67fe30 7ff67fe51      3 Mapped  Exe  EXECUTE_WRITECOPY  \\Users\\user\\Desktop\\test\\x64\\Release\\test.exe\nffff8908ef6ad770  3 7ffde5240 7ffde52c7      5 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\apphelp.dll\nffff8908ef1bcf70  4 7ffde7470 7ffde76d5      8 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\KernelBase.dll\nffff8908f16717a0  2 7ffde9270 7ffde931d      5 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\kernel32.dll\nffff8908f0e50c30  3 7ffdea920 7ffdeaaff     12 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\ntdll.dll\n</code></pre>\n<p>When I <code>!pte</code> and even <code>db</code> on one of the modules that is not in the <code>!vad</code> output (specifically, the <code>disk</code> module), it is a valid, mapped-in address, and I can even read its content.</p>\n<pre><code>kd&gt; !pte fffff80b`85960000\n                                           VA fffff80b85960000\nPXE at FFFFFB7DBEDF6F80    PPE at FFFFFB7DBEDF0170    PDE at FFFFFB7DBE02E160    PTE at FFFFFB7C05C2CB00\ncontains 0000000001109063  contains 0A0000007E55D863  contains 0A00000002A81863  contains 890000007D044963\npfn 1109      ---DA--KWEV  pfn 7e55d     ---DA--KWEV  pfn 2a81      ---DA--KWEV  pfn 7d044     -G-DA--KW-V\n</code></pre>\n<pre><code>kd&gt; db fffff80b`85960000\nfffff80b`85960000  4d 5a 90 00 03 00 00 00-04 00 00 00 ff ff 00 00  MZ..............\nfffff80b`85960010  b8 00 00 00 00 00 00 00-40 00 00 00 00 00 00 00  ........@.......\nfffff80b`85960020  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\nfffff80b`85960030  00 00 00 00 00 00 00 00-00 00 00 00 d8 00 00 00  ................\nfffff80b`85960040  0e 1f ba 0e 00 b4 09 cd-21 b8 01 4c cd 21 54 68  ........!..L.!Th\nfffff80b`85960050  69 73 20 70 72 6f 67 72-61 6d 20 63 61 6e 6e 6f  is program canno\nfffff80b`85960060  74 20 62 65 20 72 75 6e-20 69 6e 20 44 4f 53 20  t be run in DOS \nfffff80b`85960070  6d 6f 64 65 2e 0d 0d 0a-24 00 00 00 00 00 00 00  mode....$.......\n</code></pre>\n<p>Why then, does <code>!vad</code> not contain this entry?</p>\n<ol start=\"2\">\n<li>When I <code>!dh</code> on one of the loaded PEs, e.g., the EXE for my own process, I can see that it consists of different sections with different memory access protection.</li>\n</ol>\n<pre><code>kd&gt; !dh 7ff67fe30000\n\nFile Type: EXECUTABLE IMAGE\nFILE HEADER VALUES\n    8664 machine (X64)\n       6 number of sections\n5CA04653 time date stamp Sat Mar 30 21:47:15 2019\n\n       0 file pointer to symbol table\n       0 number of symbols\n      F0 size of optional header\n      22 characteristics\n            Executable\n            App can handle &gt;2gb addresses\n\n...\n\nSECTION HEADER #1\n   .text name\n   10FA0 virtual size\n    1000 virtual address\n   11000 size of raw data\n...\n60000020 flags\n         Code\n         (no align specified)\n         Execute Read\n\nSECTION HEADER #2\n  .rdata name\n    96F6 virtual size\n   12000 virtual address\n    9800 size of raw data\n   11400 file pointer to raw data\n...\n40000040 flags\n         Initialized Data\n         (no align specified)\n         Read Only\n\n...\n\nSECTION HEADER #6\n  .reloc name\n     614 virtual size\n   21000 virtual address\n     800 size of raw data\n...\n42000040 flags\n         Initialized Data\n         Discardable\n         (no align specified)\n         Read Only\n</code></pre>\n<p>And, according to the Windows Internals book,</p>\n<blockquote>\n<p>There is one VAD for each virtually contiguous range of not-free virtual addresses that all have the <strong>same characteristics (reserved versus committed versus mapped, memory access protection</strong>, and so on).</p>\n</blockquote>\n<p>So I would expect that each loaded module would be represented by a few VAD entries, for each section with different memory access protection.</p>\n<p>But <code>!vad</code> shows each loaded module as a single entry with the permission <code>EXECUTE_WRITECOPY</code>.</p>\n<pre><code>kd&gt; !vad\nVAD           Level     Start       End Commit\n...\nffff8908f0ef7c70  4 7ff67fe30 7ff67fe51      3 Mapped  Exe  EXECUTE_WRITECOPY  \\Users\\user\\Desktop\\test\\x64\\Release\\test.exe\nffff8908ef6ad770  3 7ffde5240 7ffde52c7      5 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\apphelp.dll\nffff8908ef1bcf70  4 7ffde7470 7ffde76d5      8 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\KernelBase.dll\nffff8908f16717a0  2 7ffde9270 7ffde931d      5 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\kernel32.dll\nffff8908f0e50c30  3 7ffdea920 7ffdeaaff     12 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\ntdll.dll\n</code></pre>\n<p>Why is that so?</p>\n<ol start=\"3\">\n<li>In that case, how can I have a complete picture of the memory pages that are accessible by a process, and their associated memory access protection? Initially, I thought of relying on <code>!vad</code> output, but seems like it doesn't give a complete picture? Does it mean that I should iterate through and run <code>!pte</code> on every multiple of 0x1000 from 0x0 to 0xFFFFFFFFFFFFFFFF?</li>\n</ol>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "2k",
    "tags": [
        "windows",
        "windbg",
        "kernel"
    ],
    "user": "Pie Faced",
    "time": "Apr 3, 2019 at 14:21",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>when you are in kd session lm displays both kernelmode modules and user mode modules</p>\n<p>use lm u to display only usermode modules </p>\n<p>this will be consistent with the !vad display </p>\n<p>kernel mode modules aren't associated with a single process and as such they are not a part of processes virtual address descriptor table </p>\n<p>obviously you can get the pte for any virtual address and obviously you can read from any virtual address </p>\n<p>iirc the versus is the qualifier in the Quote  the image VADS all will have MEM_IMAGE as their type and they would be contiguous\nyou cant split them to their individual sections from !vad </p>\n<p>you need to be in usermode and do !vadump for the specific image in the specific process</p>\n<p>a single CONTIGOUS MEM_IMAGE vad </p>\n<pre><code>0: kd&gt; !vad ffffde04de1b7d90\nVAD           Level     Start       End Commit\nffffde04de1b7d90  0 7ffdb7c80 7ffdb7e6c     21 Mapped  Exe  EXECUTE_WRITECOPY  \\Windows\\System32\\ntdll.dll\n\nTotal VADs: 1, average level: 1, maximum depth: 0\nTotal private commit: 0x15 pages (84 KB)\nTotal shared commit:  0 pages (0 KB)\n</code></pre>\n<p>I attached this process to a local windbg in the target </p>\n<p>the split for this vad </p>\n<pre><code>BaseAddress:       00007ffdb7c80000  &lt;&lt; + \nRegionSize:        0000000000001000  &lt;&lt;  ====\nState:             00001000  MEM_COMMIT\nProtect:           00000002  PAGE_READONLY\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7c81000 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; + \nRegionSize:        0000000000117000 &lt;&lt; ====\nState:             00001000  MEM_COMMIT\nProtect:           00000020  PAGE_EXECUTE_READ\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7d98000 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\nRegionSize:        0000000000047000\nState:             00001000  MEM_COMMIT\nProtect:           00000002  PAGE_READONLY\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7ddf000\nRegionSize:        0000000000001000\nState:             00001000  MEM_COMMIT\nProtect:           00000004  PAGE_READWRITE\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7de0000\nRegionSize:        0000000000002000\nState:             00001000  MEM_COMMIT\nProtect:           00000008  PAGE_WRITECOPY\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7de2000\nRegionSize:        0000000000008000\nState:             00001000  MEM_COMMIT\nProtect:           00000004  PAGE_READWRITE\nType:              01000000  MEM_IMAGE\n\nBaseAddress:       00007ffdb7dea000  &lt;&lt;&lt;&lt; + \nRegionSize:        0000000000083000  &lt;&lt;&lt;  =====      ((00007ffdb7e6d000 - page size) / pagesize)  = vad end  7ffdb7e6c\nState:             00001000  MEM_COMMIT\nProtect:           00000002  PAGE_READONLY\nType:              01000000  MEM_IMAGE\n</code></pre>\n<p>the lm in usermode </p>\n<pre><code>0:001&gt; lm m ntdll\nBrowse full module list\nstart             end                 module name\n00007ffd`b7c80000 00007ffd`b7e6d000   ntdll     \n</code></pre>\n<p>you can do !dh here and add look at the virtual address  each virtual address will match \n!vadumps entry and  will show what different protections are applied </p>\n<p>read about VirtualAlloc and Virtual Protect </p>\n<p>you can allot a very big memory and change protections for page sizes inbetween them \nthe big allocation is equivalent for vad  while !vadump in usermode will show the virtualprotected state </p>\n<p>a process can access only the usermode virtual addresses it cannot access the kernel mode addresses it need a mechanism to do that (syscalls do that work)  </p>\n</div>",
            "votes": "2",
            "user": "blabb",
            "time": "Apr 3, 2019 at 21:19",
            "is_accepted": true,
            "comments": []
        }
    ]
}