{
    "title": "How can I find the buffer of CryptGenRandom?",
    "link": "https://reverseengineering.stackexchange.com/questions/32166/how-can-i-find-the-buffer-of-cryptgenrandom",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I am trying to analyze the <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom\" rel=\"nofollow noreferrer\">CryptGenRandom</a> algorithm on my Windows 10 laptop.</p>\n<p>According to Niels Ferguson's <a href=\"https://aka.ms/win10rng\" rel=\"nofollow noreferrer\">Whitepaper</a> called 'The Windows 10 random number generation infrastructure', the CryptGenRandom algorithm uses a buffer for small requests:</p>\n<blockquote>\n<p>All PRNGs in the system are SP800-90 <code>AES_CTR_DRBG</code> with 256-bit security strength using the <code>df()</code> function for seeding and re-seeding (see SP 800-90 for details). (…) The Basic PRNGs are not used directly, but rather through a wrapping layer that adds several features.</p>\n<ul>\n<li>A small buffer of random bytes to improve performance for small requests.</li>\n<li>A lock to support multi-threading.</li>\n<li><code>A</code> seed version.</li>\n</ul>\n<p>(…) The buffering is straightforward. There is a small buffer (currently 128 bytes). If a request for random bytes is 128 bytes or larger, it is generated directly from <code>AES_CTR_DRGB</code>. If it is smaller than 128 bytes it is taken from the buffer. The buffer is re-filled from the <code>AES_CTR_DRBG</code> whenever it runs empty. So, if the buffer contains 4 bytes and the request is for 8 bytes, the 4 bytes are taken from the buffer, the buffer is refilled with 128 bytes, and the first 4 bytes of the refilled buffer are used to complete the request, leaving 124 bytes in the buffer.</p>\n</blockquote>\n<p>I would like to know if it is possible to locate and access this buffer.</p>\n<p>To achieve this, I located the <code>Advapi32.dll</code> file in my windows/system32 folder. The <code>CryptGenRandom</code> algorithm is defined in this file. I decompiled this file with Ghidra. However, I am very unexperienced with Ghidra and did not manage to find the buffer. Below you can see the entry function with renamed parameters:</p>\n<pre class=\"lang-c prettyprint-override\"><code>    /* WARNING: Function: _guard_dispatch_icall replaced with injection: guard_dispatch_icall */\n    /* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n    \n    ulonglong entry(undefined8 hProv,int dwLen,longlong pbBuffer)\n    \n    {\n      byte bVar1;\n      int iVar2;\n      undefined4 extraout_var;\n      uint *puVar3;\n      undefined1 *puVar4;\n      uint uVar5;\n      uint *puVar6;\n      uint uVar7;\n      \n      if (dwLen == 1) {\n        FUN_18001d464(hProv,1);\n      }\n      uVar7 = 0;\n      if (dwLen == 1) {\n        uVar5 = 0;\n        puVar4 = &amp;DAT_1800a1008;\n        do {\n          iVar2 = RtlInitializeCriticalSection(*(undefined8 *)(puVar4 + -8));\n          if (iVar2 &lt; 0) {\n            iVar2 = FUN_180015850();\n            return CONCAT44(extraout_var,iVar2) &amp; 0xffffffffffffff00;\n          }\n          *puVar4 = 1;\n          uVar5 = uVar5 + 1;\n          puVar4 = puVar4 + 0x10;\n        } while (uVar5 &lt; 4);\n        _DAT_1800a44d4 = 1;\n      }\n      uVar5 = 1 &lt;&lt; ((byte)dwLen &amp; 0x1f);\n      puVar6 = &amp;DAT_1800a43c8;\n      bVar1 = 1;\n      puVar3 = &amp;DAT_18006a738;\n      do {\n        if (((*puVar3 &amp; uVar5) != 0) &amp;&amp;\n           ((dwLen != 0 || (((*puVar6 &amp; 2) != 0 &amp;&amp; ((pbBuffer == 0 || ((int)*puVar3 &lt; 0)))))))) {\n          bVar1 = (**(code **)(puVar3 + -2))(hProv,dwLen,pbBuffer);\n          if (bVar1 == 0) goto LAB_18002d198;\n          (&amp;DAT_1800a43c8)[(int)uVar7] = *puVar6 | uVar5;\n        }\n        uVar7 = uVar7 + 1;\n        puVar3 = puVar3 + 4;\n        puVar6 = puVar6 + 1;\n      } while (uVar7 &lt; 8);\n      if (bVar1 == 0) {\n    LAB_18002d198:\n        if (dwLen != 1) goto LAB_18001577c;\n      }\n      else {\n    LAB_18001577c:\n        if ((dwLen != 0) || (pbBuffer != 0)) goto LAB_180015785;\n      }\n      FUN_180015850();\n    LAB_180015785:\n      return (ulonglong)bVar1;\n    }\n</code></pre>\n<p>Since <code>dwLen</code> is the number of requested bytes, I would expect there to be a statement that checks whether this number is at most the number of available random bytes in the buffer. But I see no such statement. Also, <code>pbBuffer</code> is a different buffer than the one I am looking for.</p>\n<p>I hope that someone can point me in the right direction!</p>\n</div>",
    "votes": "2",
    "answers": 2,
    "views": "282",
    "tags": [
        "ida",
        "disassembly",
        "windows",
        "binary-analysis",
        "ghidra"
    ],
    "user": "Riemann",
    "time": "Aug 18, 2023 at 13:22",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This is not a ghidra answer but done using windbg\nAssuming You Have Code as below</p>\n<pre><code>#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#pragma comment(lib, \"Advapi32.lib\")\nvoid hexdump(byte *inbuf, DWORD count)\n{\n    DWORD j = 0;\n    while (j &lt; count)\n    {\n        for (DWORD i = j; i &lt; j + 16; i++)\n        {\n            printf(\"%02x \", inbuf[i]);\n        }\n        printf(\"\\n\");\n        j = j + 16;\n    }\n}\nint main(void)\n{\n    HCRYPTPROV hCryptProv = NULL;\n    byte buff[0x200] = {0};\n    DWORD count = 0x30;\n    BOOL res = CryptAcquireContextA(&amp;hCryptProv, \"MyKeyContainer\", NULL, PROV_RSA_FULL, 0);\n    if (res)\n    {\n        res = CryptGenRandom(hCryptProv, count, buff);\n        if (res)\n        {\n            hexdump(buff, count);\n        }\n    }\n    CryptReleaseContext(hCryptProv, 0);\n}\n</code></pre>\n<p>you can employ memory Breakpoint to find who is writing to your buffer and just corelate with your ghidra/ida disassembly.</p>\n<p>the buffers are Actually Created in Heap and the pointers to them are Written in\nbcryptprimitives!g_AesStatesTable</p>\n<pre><code>0:000&gt; lsa .\n    21:     DWORD count = 0x30;\n    22:     BOOL res = CryptAcquireContextA(&amp;hCryptProv, \"MyKeyContainer\", NULL, PROV_RSA_FULL, 0);\n    23:     if (res)\n    24:     {\n&gt;   25:         res = CryptGenRandom(hCryptProv, count, buff); &lt;--------------\n    26:         if (res)\n    27:         {\n    28:             hexdump(buff, count);\n    29:         }\n    30:     }\n0:000&gt; ba w1 buff\n0:000&gt; g\nBreakpoint 0 hit\nntdll!memcpy+0x144:\n00007ffe`988d4044 0f100411        movups  xmm0,xmmword ptr [rcx+rdx] ds:0000027d`a4dbc500=25fc4b9c5d3ddad46e5610a21eff9e1f\n0:000&gt; k\n # Child-SP          RetAddr           Call Site\n00 000000d0`1b6ff648 00007ffe`96815400 ntdll!memcpy+0x144\n01 000000d0`1b6ff650 00007ffe`9681513c bcryptprimitives!AesRNGState_generate+0x190\n02 000000d0`1b6ff700 00007ffe`9586101d bcryptprimitives!ProcessPrng+0x12c\n03 000000d0`1b6ff7b0 00007ffe`94f054f7 CRYPTBASE!SystemFunction036+0xd\n04 000000d0`1b6ff7e0 00007ffe`958416b2 rsaenh!CPGenRandom+0x27\n05 000000d0`1b6ff810 00007ff6`f72a110f CRYPTSP!CryptGenRandom+0x42\n06 000000d0`1b6ff840 00007ff6`f72a14d4 crypt!main+0x7f [crypt.cpp @ 25] &lt;-----------\n07 (Inline Function) --------`-------- crypt!invoke_main+0x22 \n08 000000d0`1b6ffaa0 00007ffe`968a7614 crypt!__scrt_common_main_seh+0x10c \n09 000000d0`1b6ffae0 00007ffe`988826f1 KERNEL32!BaseThreadInitThunk+0x14\n0a 000000d0`1b6ffb10 00000000`00000000 ntdll!RtlUserThreadStart+0x21\n0:000&gt; ub . \nntdll!memcpy+0x126:\n00007ffe`988d4026 0f2959e0        movaps  xmmword ptr [rcx-20h],xmm3\n00007ffe`988d402a 0f28c4          movaps  xmm0,xmm4\n00007ffe`988d402d 75d1            jne     ntdll!memcpy+0x100 (00007ffe`988d4000)\n00007ffe`988d402f 4d8bc8          mov     r9,r8\n00007ffe`988d4032 49c1e904        shr     r9,4\n00007ffe`988d4036 7419            je      ntdll!memcpy+0x151 (00007ffe`988d4051)\n00007ffe`988d4038 0f1f840000000000 nop     dword ptr [rax+rax]\n00007ffe`988d4040 0f2941f0        movaps  xmmword ptr [rcx-10h],xmm0 &lt;------------- \nthis triggered the write breakpoint\n0:000&gt; r rcx\nrcx=000000d01b6ff890\n0:000&gt; ? xmm0\nEvaluate expression: 5380964661682152702 = 4aad06d9`a87ea4fe &lt;----------- \nthis is being copied from api buffer to codes buff\n\n0:000&gt; db bcryptprimitives!g_AesStatesTable l2\n00007ffe`9687b8e0  60 c0 db a4 7d 02 00 00-00 00 00 00 00 00 00 00  `...}...........\n\n0:000&gt; db poi(bcryptprimitives!g_AesStatesTable) l4\n0000027d`a4dbc060  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0000027d`a4dbc070  f0 c3 db a4 7d 02 00 00-90 c2 db a4 7d 02 00 00  ....}.......}...\n\n0:000&gt; db poi(poi(bcryptprimitives!g_AesStatesTable)+10) l120\n0000027d`a4dbc3f0  30 01 00 00 00 00 00 00-00 00 00 00 00 00 00 00  0...............\n0000027d`a4dbc400  dd 1e e5 f2 c9 ec e9 b5-70 2e 3b c6 da e1 f9 59  ........p.;....Y\n0000027d`a4dbc410  f7 7d 2c 07 2d 57 ae e0-c8 5c 31 05 08 9a 10 9f  .},.-W...\\1.....\n0000027d`a4dbc420  bc 83 0c 3b 8f 11 ee 03-b0 8a 9a 7e 0e f5 c5 cd  ...;.......~....\n0000027d`a4dbc430  da 4f 77 48 92 54 98 57-12 17 ed 2b af 97 1e 88  .OwH.T.W...+.... &lt;-------\n0000027d`a4dbc440  03 00 00 00 00 00 00 00-01 00 00 00 00 00 00 00  ................\n0000027d`a4dbc450  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0000027d`a4dbc460  80 00 00 00 00 00 00 00-39 00 00 00 00 00 00 00  ........9.......\n0000027d`a4dbc470  ff ff ff ff ff ff ff ff-fe ff ff ff 01 00 00 00  ................\n0000027d`a4dbc480  c8 2d 00 00 00 00 00 00-00 00 00 00 00 00 00 00  .-..............\n0000027d`a4dbc490  d0 07 00 02 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0000027d`a4dbc4a0  01 20 b5 34 61 da 46 2a-20 ab 63 2a 90 28 cb 36  . .4a.F* .c*.(.6\n0000027d`a4dbc4b0  51 4a dc 28 50 b5 a4 97-78 b8 13 33 e3 3c 5a 24  QJ.(P...x..3.&lt;Z$\n0000027d`a4dbc4c0  e4 6c 8d 70 7a 19 5d 5e-71 15 78 95 4b 9b 61 f2  .l.pz.]^q.x.K.a.\n0000027d`a4dbc4d0  0f 8e 0d 32 5b 39 1a 53-6b 2a 0e 47 ae e1 2a 47  ...2[9.Sk*.G..*G\n0000027d`a4dbc4e0  37 d4 d7 78 01 de 34 d8-f4 27 fe bf fb 2b 07 7a  7..x..4..'...+.z\n0000027d`a4dbc4f0  fe a4 7e a8 d9 06 ad 4a-4a 70 8a c3 57 53 54 e9  ..~....JJp..WST. &lt;-------\n0000027d`a4dbc500  1f 9e ff 1e a2 10 56 6e-d4 da 3d 5d 9c 4b fc 25  ......Vn..=].K.% &lt;--------\n</code></pre>\n<p>you need to catch this buffer before it is wiped off after memcpy\nusing SymCryptWipeAsm</p>\n<pre><code>0:000&gt; db buff\n000000d0`1b6ff880  fe a4 7e a8 d9 06 ad 4a-4a 70 8a c3 57 53 54 e9  ..~....JJp..WST.\n000000d0`1b6ff890  1f 9e ff 1e a2 10 56 6e-d4 da 3d 5d 9c 4b fc 25  ......Vn..=].K.%\n000000d0`1b6ff8a0  da 4f 77 48 92 54 98 57-12 17 ed 2b af 97 1e 88  .OwH.T.W...+....\n000000d0`1b6ff8b0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n000000d0`1b6ff8c0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n000000d0`1b6ff8d0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n000000d0`1b6ff8e0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n000000d0`1b6ff8f0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n</code></pre>\n<p>the pertinent disassembly / decompilation in ghidra is as follows</p>\n<pre><code>in bool AesRNGState_generate(byte *param_1,byte *buff,dword dwLen)\n\n if (uVar10 &lt; 0x80) {\n    uVar2 = *(ulonglong *)(param_1 + 0x70);\n    puVar1 = (ulonglong *)(param_1 + 0x70);\n    uVar9 = uVar10;\n    if (uVar2 != 0) {\n      if (uVar2 &lt;= uVar10) {\n        uVar9 = uVar2;\n      }\n      memcpy(local_80,param_1 + (uVar2 - uVar9) + 0xb0,uVar9);\n      SymCryptWipeAsm(param_1 + ((*puVar1 + 0xb0) - uVar9),(dword)uVar9);\n      *puVar1 = *puVar1 - uVar9;\n      local_80 = pbVar8 + uVar9;\n      uVar9 = uVar10 - uVar9;\n    }\n    if (uVar9 != 0) {\n      SymCryptRngAesGenerate(param_1 + 0x10,param_1 + 0xb0,0x80);\n      *puVar1 = 0x80;\n      memcpy(local_80,param_1 + (0x130 - uVar9),uVar9);\n      SymCryptWipeAsm(param_1 + ((*puVar1 + 0xb0) - uVar9),(dword)uVar9);\n      *puVar1 = ~(ulonglong)((uint)((uVar10 - 1 ^ uVar10) &gt;&gt; 1) &amp; 0xf) &amp; *puVar1 - uVar9;\n    }\n  }\n  else {\n    SymCryptRngAesGenerate(param_1 + 0x10,buff,dwLen);\n  }\n</code></pre>\n</div>",
            "votes": "1",
            "user": "blabb",
            "time": "Aug 17, 2023 at 4:13",
            "is_accepted": true,
            "comments": [
                {
                    "user": "Riemann",
                    "text": "<span class=\"comment-copy\">In my Ghidra decompiler, the function AesRNGState_generate is not defined and probably is one of the FUN_1800 functions. How can I change this and find out which one is the actual function?</span>",
                    "time": null
                },
                {
                    "user": "Riemann",
                    "text": "<span class=\"comment-copy\">And I can not open <code>Bcryptprimitives.dll</code> in Ida at all, but firstly I could… I don’t know what changed</span>",
                    "time": null
                },
                {
                    "user": "Riemann",
                    "text": "<span class=\"comment-copy\">However, that doesn't matter if I can access the buffer with windbg as you specified</span>",
                    "time": null
                }
            ]
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>This seems to be a simple exercise in following the stubs/imports in different DLLs.\nThis is the flow that I see</p>\n<pre><code>CRYPTSP!CryptGenRandom -&gt; rsaenh!CPGenRandom -&gt; CRYPTBASE!SystemFunction036(on my machine atleast) -&gt; bcryptPrimitives!ProcessPrng \n</code></pre>\n<p><code>bcryptPrimitives!ProcessPrng</code> has the most code. On opening this with any disassembler of choice we can see that <code>AesRNGState_generate</code> is called and additionally involves <code>g_AesStatesTable</code>/<code>g_rootAesRngState</code> and further eventually <code>bcryptPrimitives!SymCryptRngAesReseed</code> is called which looks like.</p>\n<pre class=\"lang-c prettyprint-override\"><code>__int64 __fastcall SymCryptRngAesReseed(__int64 a1, void *a2, size_t a3)\n{\n  __int64 result; // rax\n  __int64 v5[6]; // [rsp+20h] [rbp-48h] BYREF\n\n  if ( a3 - 32 &gt; 0x20 )\n    return 209715368i64;\n  SymCryptRngAesDf(a2, a3);\n  SymCryptRngAesUpdate(a1, v5, 0i64);\n  result = 0i64;\n  *(_QWORD *)(a1 + 64) = 1i64;\n  memset(v5, 0, sizeof(v5));\n  return result;\n}\n</code></pre>\n<p>This is IDA output - I assume that Ghidra's would be similar. <code>SymCryptRngAesDf</code> is the <code>df</code> function that you mention probably.</p>\n</div>",
            "votes": "1",
            "user": "sudhackar",
            "time": "Aug 17, 2023 at 8:07",
            "is_accepted": false,
            "comments": [
                {
                    "user": "Riemann",
                    "text": "<span class=\"comment-copy\">Thank you for your answer! I could not even find the first import in Ghidra, because in the Entry function of advapi32.dll it says <code>bVar1 = (**(code **)(puVar3 + -2))(param_1,param_2,param_3);</code> and I had no idea which function this referred to.</span>",
                    "time": null
                },
                {
                    "user": "Riemann",
                    "text": "<span class=\"comment-copy\">Wouldn't reseed only be called when the PRNG is reseeded? That should happen not nearly as often as calling the buffer. So then the buffer might be at a different place than inside SymCryptRngAesReseed.</span>",
                    "time": null
                },
                {
                    "user": "Riemann",
                    "text": "<span class=\"comment-copy\">So basically, the call to the buffer could be anywhere along the flow that you specified…</span>",
                    "time": null
                },
                {
                    "user": "sudhackar",
                    "text": "<span class=\"comment-copy\">Some version of SymCrypt is open source at <a href=\"https://github.com/microsoft/SymCrypt\" rel=\"nofollow noreferrer\">github.com/microsoft/SymCrypt</a>. Please read the documentation. Also as I mentioned <code>g_AesStatesTable</code>/<code>g_rootAesRngState</code> are responsible to maintain state - you should look into those.</span>",
                    "time": null
                }
            ]
        }
    ]
}