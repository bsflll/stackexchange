{
    "title": "What is the structure of the Stack in a minidump?",
    "link": "https://reverseengineering.stackexchange.com/questions/28058/what-is-the-structure-of-the-stack-in-a-minidump",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I'm currently using Python3.9 in Linux to obtain the necessary information from a minidump file.  I used WinDBG on my windows system to check whether the information I got was right.</p>\n<p>While [1], [2] and [3] have helped, there are still some holes that aren't covered.  The purpose of this is to create a script that can disect the minidump.   I've managed to get the ThreadList, MemoryList, MemoryInfoList and moduleList.  But I'm missing the stack\ninformation, which seems to be within the MINIDUMP_THREAD info's Stack field as shown below:</p>\n<pre><code>typedef struct _MINIDUMP_THREAD {\n  ULONG32                      ThreadId;\n  ULONG32                      SuspendCount;\n  ULONG32                      PriorityClass;\n  ULONG32                      Priority;\n  ULONG64                      Teb;\n  MINIDUMP_MEMORY_DESCRIPTOR   Stack;\n  MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;\n} MINIDUMP_THREAD, *PMINIDUMP_THREAD;\n</code></pre>\n<p>It's a MINIDUMP_MEMORY_DESCRIPTOR which has the following structure:</p>\n<pre><code>typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {\n  ULONG64                      StartOfMemoryRange;\n  MINIDUMP_LOCATION_DESCRIPTOR Memory;\n} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;\n</code></pre>\n<p>The Memory field has the following structure:</p>\n<pre><code>typedef struct _MINIDUMP_LOCATION_DESCRIPTOR {\n  ULONG32 DataSize;\n  RVA     Rva;\n} MINIDUMP_LOCATION_DESCRIPTOR;\n</code></pre>\n<p>So all in all, the Stack.Rva contains the relative virtual address in the minidump file.</p>\n<p>Going to that address, I see 'stuff' but at this point in the documentation, there's no indication of what structure is stored there.   I thought it'd be a STACKFRAME structure (was grasping at straws) which is given as:</p>\n<pre><code>typedef struct _tagSTACKFRAME {\n  ADDRESS AddrPC;\n  ADDRESS AddrReturn;\n  ADDRESS AddrFrame;\n  ADDRESS AddrStack;\n  PVOID   FuncTableEntry;\n  DWORD   Params[4];\n  BOOL    Far;\n  BOOL    Virtual;\n  DWORD   Reserved[3];\n  KDHELP  KdHelp;\n  ADDRESS AddrBStore;\n} STACKFRAME, *LPSTACKFRAME;\n</code></pre>\n<p>But looking at the hex values, it doesn't make sense:</p>\n<pre><code>00 00 00 00 D1 F8 AF 77 29 16 6B 77 C8 01 00 00\n00 00 00 00 00 00 00 00 D0 87 C0 BD E0 60 85 00\nc8 01 00 00 28 c1 39 00 24 00 00 00 01 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 2B 00 2B 00\n87 02 21 00 00 00 00 00 AC BF 39 00 AB F0 6A 77\n...\n\n</code></pre>\n<p>That would mean AddrPC = {Offset: 00 00 00 00,\nSegment: D1 F8 AF 77,\nMode: 29}</p>\n<p>So I figured I'd cheat by running Windbg on this crashdump\nfile to find the corresponding info; but I don't see how the above\nhex dump can be translated to the following:</p>\n<pre><code>00 0039bf98 776b1629 000001c8 00000000 00000000 ntdll!NtWaitForSingleObject+0x15\n01 0039c004 75491194 000001c8 ffffffff 00000000 KERNELBASE!WaitForSingleObjectEx+0x98\n02 0039c01c 75491148 000001c8 ffffffff 00000000 kernel32!WaitForSingleObjectExtImplementation+0x75\n03 0039c030 5a581e3a 000001c8 ffffffff 00000000 kernel32!WatiForSingleObject+0x12\n...\n</code></pre>\n<p>While I can see some of the info from windbg's call stack, the information isn't a contiguous set of info.</p>\n<p>Unfortunately, my understanding of C++/C is limited at best so I couldn't grasp the information as given in [5]</p>\n<p>Might anyone have suggestion on how to reverse engineer the structure of what's at this address?</p>\n<p>I know it's some sort of structure that includes a list of stackframes; but the documentation at [1] doesn't specify what kind of structure.  I'm guessing there's a header and some array of structure.  Unfortunately, I haven't found (yet) documentation that shows a map of a minidump (akin to [4]).  Something like this would make my understanding easier.</p>\n<p><code>*Addendum:*</code></p>\n<p>Having worked on this on and off, I still haven't figured it out despite @blabb's help.  I went and took a look at [6] which points out the Stack structure for X86.  Having lost my original dump file, I used a new dump file.  I used a minidump_stackwalker binary that came up with the following:  (The rva of the crashing thread was 0x0141ff - binary dump follows)</p>\n<pre><code>\nCrash reason:  EXCEPTION_ACCESS_VIOLATION_READ\nCrash address: 0x8\n\nThread 0 (crashed)\n 0  k.dll + 0x310bf3f\n    eip = 0x5d42bf3f   esp = 0x0053bea0   ebp = 0x0053bf74   ebx = 0x0053bed0\n    esi = 0x00a1b000   edi = 0x0053bf98   eax = 0x00000008   ecx = 0x00000004\n    edx = 0x0053bfb0   efl = 0x00210287\n    Found by: given as instruction pointer in context\n 1  k.dll + 0x310bc3b\n    eip = 0x5d42bc3c   esp = 0x0053bf7c   ebp = 0x0053bfd8\n    Found by: previous frame's frame pointer\n 2  k.dll + 0x311e7b3\n    eip = 0x5d43e7b4   esp = 0x0053bfe0   ebp = 0x0053c004\n    Found by: previous frame's frame pointer\n 3  k.dll + 0x3280958\n    eip = 0x5d5a0959   esp = 0x0053c00c   ebp = 0x0053c064\n    Found by: previous frame's frame pointer\n...\n</code></pre>\n<p>binary dump at 0x0141ff:</p>\n<pre><code>000141f0h: FC EC 23 00 00 00 00 AC 03 00 00 34 7B 03 00 8B\n00014200h: 55 18 8B 45 0C FF 24 8D CC 4A D7 5D C7 44 24 14\n00014210h: 00 00 00 00 8D 4E 10 89 4C 24 0C 8B 56 10 89 54\n00014220h: 24 10 8D 54 24 0C 89 56 10 8B 00 89 44 24 04 8B\n00014230h: 07 89 44 24 38 89 4c 24 30 89 54 24 34 c7 44 24\n...\n</code></pre>\n<p>From what I gathered from [6], since this is a x86 binary,\nI assumed [possibly wrongly] that it'd be using the\nstack structure as given by [6] and not [7].</p>\n<p>That would mean the context_flags starts at 0x000141ff which gives me 8B 55 18 8B.  From the comments in [6], this context_flag means this stack is a MD_CONTEXT_X86_ALL.  So after using the following script:</p>\n<pre><code>#!/bin/env python\n\nimport os\nimport sys\n\n\n\nhdrs_x86 = {\n    \"context_flags\": 4,\n    \"dr0\": 4,\n    \"dr1\": 4,\n    \"dr2\": 4,\n    \"dr3\": 4,\n    \"dr6\": 4,\n    \"dr7\": 4,\n    \"fs_control_word\": 4,\n    \"fs_status_word\": 4,\n    \"fs_tag_word\": 4,\n    \"fs_error_offset\": 4,\n    \"fs_error_selector\": 4,\n    \"fs_data_offset\": 4,\n    \"fs_data_selector\": 4,\n    \"fs_register_area\": (1, 80),\n    \"fs_cr0_npx_state\": 4,\n    \"gs\": 4,\n    \"fs\": 4,\n    \"es\": 4,\n    \"edi\": 4,\n    \"esi\": 4,\n    \"ebx\": 4,\n    \"edx\": 4,\n    \"ecx\": 4,\n    \"eax\": 4,\n    \"ebp\": 4,\n    \"eip\": 4,\n    \"cs\": 4,\n    \"eflags\": 4,\n    \"esp\": 4,\n    \"ss\": 4,\n    \"extended_registers\": (1, 80)\n}\n\nhdrs_x64 = {\n    \"p1_home\": 8,\n    \"p2_home\": 8,\n    \"p3_home\": 8,\n    \"p4_home\": 8,\n    \"p5_home\": 8,\n    \"p6_home\": 8,\n    \"context_flags\": 4,\n    \"mx_csr\": 4,\n    \"cs\": 2,\n    \"ds\": 2,\n    \"es\": 2,\n    \"fs\": 2,\n    \"gs\": 2,\n    \"ss\": 2,\n    \"eflags\": 4,\n    \"dr0\": 8,\n    \"dr1\": 8,\n    \"dr2\": 8,\n    \"dr3\": 8,\n    \"dr6\": 8,\n    \"dr7\": 8,\n    \"rax\": 8,\n    \"rcx\": 8,\n    \"rdx\": 8,\n    \"rbx\": 8,\n    \"rsp\": 8,\n\n    \"rsp\": 8,\n    \"rbp\": 8,\n    \"rsi\": 8,\n    \"rdi\": 8,\n    \"r8\": 8,\n    \"r9\": 8,\n    \"r10\": 8,\n    \"r11\": 8,\n    \"r12\": 8,\n    \"r13\": 8,\n    \"r14\": 8,\n    \"r15\": 8,\n    \"rip\": 8\n}\n\nMDCTXX86 = 0x00010000\nMDCTXX86_CONTROL = MDCTXX86 | 0x00000001\nMDCTXX86_INTEGER = MDCTXX86 | 0x00000002\nMDCTXX86_SEGMENTS = MDCTXX86 | 0x00000004\nMDCTXX86_FLOATING_POINT = MDCTXX86 | 0x00000008\nMDCTXX86_DEBUG_REGISTERS = MDCTXX86 | 0x00000010\nMDCTXX86_EXTENDED_REGISTERS = MDCTXX86 | 0x00000020\nMDCTXX86_XSTATE = MDCTXX86 | 0x00000040\n\nMDCTXX86_FULL = MDCTXX86_CONTROL | MDCTXX86_INTEGER | MDCTXX86_SEGMENTS\n\nALL_P1 = MDCTXX86_FULL | MDCTXX86_FLOATING_POINT \nALL_P2 = MDCTXX86_DEBUG_REGISTERS | MDCTXX86_EXTENDED_REGISTERS\nMDCTXX86_ALL = ALL_P1 | ALL_P2 \n\n\ndef rev_item(in_bytes, no_rev=False):\n    tmp = [x for x in in_bytes]\n    if not no_rev:\n        tmp.reverse()\n    retval = []\n    for item in tmp:\n        hv = hex(item).replace(\"0x\", \"\")\n        if len(hv) &lt; 2:\n            hv = \"0\" + hv\n        retval.append(hv)\n    return retval\n\n\ndef is_dr(in_ctx, in_item):\n    return in_ctx is not None and \\\n        in_item in [\"dr0\", \"dr1\", \"dr2\", \"dr3\", \"dr6\", \"dr7\"] and \\\n        in_ctx &amp; MDCTXX86_DEBUG_REGISTERS &gt; 0\n\n\ndef is_seg(in_ctx, in_item):\n    return in_ctx is not None and \\\n        in_item in [\"gs\", \"fs\", \"es\", \"ds\"] and \\\n        in_ctx &amp; MDCTXX86_SEGMENTS\n\n\ndef is_int(in_ctx, in_item):\n    return in_ctx is not None and \\\n        in_item in [\"edi\", \"esi\", \"ebx\", \"edx\", \"ecx\", \"eax\"] and \\\n        in_ctx &amp; MDCTXX86_INTEGER\n\n\ndef is_fp(in_ctx, in_item):\n    return in_ctx is not None and \\\n        in_item.startswith(\"fs_\") and \\\n        in_ctx &amp; MDCTXX86_FLOATING_POINT\n\n\ndef is_control(in_ctx, in_item):\n    return in_ctx is not None and \\\n        in_item in [\"ebp\", \"eip\", \"cs\", \"eflags\", \"esp\", \"ss\"] and \\\n        in_ctx &amp; MDCTXX86_CONTROL\n\n\ndef is_ext_reg(in_ctx, in_item):\n    return in_ctx is not None and \\\n        in_item in ['extended_registers'] and \\\n        in_ctx &amp; MDCTXX86_EXTENDED_REGISTERS\n\n\ndef check_for_ctx(in_ctx, in_item):\n    retval = False\n    for itemfn in [is_dr, is_seg, is_int, is_fp,\n                   is_control, is_ext_reg]:\n        retval = itemfn(in_ctx, in_item)\n        if retval:\n            break\n\n    return retval\n\n\nres = []\nres2 = []\n\nhdrv = {}\n\nhdrs = hdrs_x86\n\nwith open(\"e:\\\\test.dmp\", 'rb') as fp:\n    addr = 0x141ff\n    fp.seek(addr)\n    ctx = None\n    for item, item_rl in hdrs.items():\n        read_len = item_rl\n        add_item = False\n\n        if isinstance(item_rl, tuple):\n            vr = []\n            read_len = item_rl[0]\n            for i in range(item_rl[1]):\n                tmp = fp.read(read_len)\n                tmph = tmp.hex().replace(\"0x\", \"\")\n                vr.append(tmph)\n            read_len = item_rl[1]\n        else:\n            v = fp.read(item_rl)\n            vr = rev_item(v, no_rev=True)\n            if item == \"context_flags\":\n                ctx = int(\"\".join(vr), 16)\n\n        if check_for_ctx(ctx, item):\n            if item not in hdrv:\n                hdrv[item] = vr\n        addr += read_len\n\nfor item, iteminfo in hdrv.items():\n    print(item, \"\".join(iteminfo))\n</code></pre>\n<p>It displays</p>\n<pre><code>dr0 450cff24\ndr1 8dcc4ad7\ndr2 5dc74424\ndr3 14000000\ndr6 008d4e10\ndr7 894c240c\nfs_control_word 8b561089\nfs_status_word 5424108d\nfs_tag_word 54240c89\nfs_error_offset 56108b00\nfs_error_selector 89442404\nfs_data_offset 8b078944\nfs_data_selector 2438894c\nfs_register_area 243089542434c744242c00000000894c24248d442438895c24288d4c2424894e108d4c242c31ff515056e89a6adfff83c40c84c074178d4424186a09ff74243050e813aedfff83c40c8b7c24188b4424\nfs_cr0_npx_state 248b4c24\ngs 2889088b\nfs 4424308b\nes 4c243489\nedi 08897c24\nesi 1485ffb3\nebx 010f841a\nedx 0300008d\necx 4424148b\neax 54240489\nebp d1c1f91f\neip 6a005152\ncs e9de0200\neflags 000fbe00\nesp e94d0100\nss 00c74424\nextended_registers 14000000008d4e10894c240c8b5610895424108d54240c8956108b00894424048b0789442438894c243089542434c744242c00000000894c24248d442438895c24288d4c2424894e108d4c242c31ff51\n\n</code></pre>\n<p>But this doesn't make any sense as it doesn't even bear any resemblance to what's given in the results.  Like I got <code>d1c1f91f</code> as the EBP, but it's actually <code>0x0053BF74</code>\nErgo, I've misunderstood this whole thing.</p>\n<p><code>*Additional Addendum*</code>:\nThe addendum was wrong on two points.</p>\n<ol>\n<li>I was barking up the wrong tree. I mistook the <code>minidump Memory info</code> list as where the stack was.</li>\n<li>I was working on the same minidump.  Just was confused with\nwhat section I was working on.</li>\n</ol>\n<p>I've opted to keep the Addendum section and not delete it. (Along the lines of 1000 ways of not doing something.)</p>\n<p>Any help greatly appreciated,</p>\n<p>:ewong</p>\n<p>[1] - <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/\" rel=\"nofollow noreferrer\">https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/</a></p>\n<p>[2] - <a href=\"https://github.com/utds3lab/sigpath/blob/master/scripts/minidump.py\" rel=\"nofollow noreferrer\">https://github.com/utds3lab/sigpath/blob/master/scripts/minidump.py</a></p>\n<p>[3] - <a href=\"https://github.com/libyal/libmdmp/blob/main/documentation/Minidump%20%28MDMP%29%20format.asciidoc#thread_information_stream\" rel=\"nofollow noreferrer\">https://github.com/libyal/libmdmp/blob/main/documentation/Minidump%20%28MDMP%29%20format.asciidoc#thread_information_stream</a></p>\n<p>[4] - <a href=\"https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Portable_Executable_32_bit_Structure_in_SVG_fixed.svg/1920px-Portable_Executable_32_bit_Structure_in_SVG_fixed.svg.png\" rel=\"nofollow noreferrer\">https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Portable_Executable_32_bit_Structure_in_SVG_fixed.svg/1920px-Portable_Executable_32_bit_Structure_in_SVG_fixed.svg.png</a></p>\n<p>[5] - <a href=\"https://chromium.googlesource.com/breakpad/breakpad/+/refs/heads/main/src/client/minidump_file_writer.cc\" rel=\"nofollow noreferrer\">https://chromium.googlesource.com/breakpad/breakpad/+/refs/heads/main/src/client/minidump_file_writer.cc</a></p>\n<p>[6] - <a href=\"https://github.com/google/breakpad/blob/main/src/google_breakpad/common/minidump_cpu_x86.h\" rel=\"nofollow noreferrer\">https://github.com/google/breakpad/blob/main/src/google_breakpad/common/minidump_cpu_x86.h</a></p>\n<p>[7] - <a href=\"https://github.com/google/breakpad/blob/main/src/google_breakpad/common/minidump_cpu_amd64.h\" rel=\"nofollow noreferrer\">https://github.com/google/breakpad/blob/main/src/google_breakpad/common/minidump_cpu_amd64.h</a></p>\n</div>",
    "votes": "2",
    "answers": 1,
    "views": "348",
    "tags": [
        "windbg",
        "stack"
    ],
    "user": "ewokx",
    "time": "Sep 28, 2021 at 8:04",
    "comments": [
        {
            "user": "blabb",
            "text": "<span class=\"comment-copy\">i can't check now but is this 64 bit ? if yes then ADDRESS is ADDRESS64 so it is DWORD64 word and address_mode from your windbg k result versus raw dump i can see the 1c8 77 6b correctly visually please check for bitness and try</span>",
            "time": null
        },
        {
            "user": "ewokx",
            "text": "<span class=\"comment-copy\">@blabb yes this is 64bit.  Though the application is a 32bit version (dunno if this makes a difference).  so it is Address64.   Thanks.  That makes a bit more sense.</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>the rva does not seem to point to _tagSTACKFRAME64  the size appears to be different\n0x108 versus 0x4d0</p>\n<p>is there a specific reason to use dbghelp ?</p>\n<p>outputstacktrace from dbgeng is not acceptable?</p>\n<p><a href=\"https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/idiaenumstackframes?view=vs-2019\" rel=\"nofollow noreferrer\">have you looked at the com interfaces of DIA_SDK for an alternative</a></p>\n<p>checked an arbitrary dump for sizeof(_tagStackFrame) versus size in dump using code below</p>\n<pre><code>#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;dbghelp.h&gt;\n#pragma comment(lib, \"dbghelp.lib\")\nint main(void)\n{\n    HANDLE hFile = NULL;\n    hFile = CreateFileA(\n        \"tdump.dmp\", GENERIC_READ, 0, NULL, OPEN_EXISTING,\n        FILE_ATTRIBUTE_NORMAL, NULL);\n    if (hFile != INVALID_HANDLE_VALUE)\n    {\n        printf(\"file handle is %p\\n\", hFile);\n        HANDLE hMapFile = NULL;\n        hMapFile = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);\n        if (hMapFile != NULL)\n        {\n            printf(\"file Map handle is %p\\n\", hMapFile);\n            LPVOID lpMapAddress = NULL;\n            lpMapAddress = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);\n            if (lpMapAddress != NULL)\n            {\n                printf(\"view of map file is %p\\n\", lpMapAddress);\n                PMINIDUMP_DIRECTORY dudir = NULL;\n                PVOID strptr = NULL;\n                ULONG ssiz = 0;\n                BOOL res = FALSE;\n                res = MiniDumpReadDumpStream(lpMapAddress, 3, &amp;dudir, &amp;strptr, &amp;ssiz);\n                if (res &amp;&amp; strptr != NULL)\n                {\n                    PMINIDUMP_THREAD_LIST tlist = (PMINIDUMP_THREAD_LIST)strptr;\n                    for (ULONG32 i = 0; i &lt; tlist-&gt;NumberOfThreads; i++)\n                    {\n                        ULONG64 dsiz = tlist-&gt;Threads[i].ThreadContext.DataSize;\n                        ULONG64 rva = tlist-&gt;Threads[i].ThreadContext.Rva;\n                        ULONG64 memsta = tlist-&gt;Threads[i].Stack.StartOfMemoryRange;\n                        ULONG64 memsiz = tlist-&gt;Threads[i].Stack.Memory.DataSize;\n                        ULONG64 memrva = tlist-&gt;Threads[i].Stack.Memory.Rva;\n                        printf(\"look in debugger %I64x\\t%I64x\\t%I64x\\t%I64x\\t%I64x\\n\",\n                               dsiz, rva, memsta, memsiz, memrva);\n                    }\n                    _tagSTACKFRAME64 tsf = {0};\n                    printf(\"%zx\\n\", sizeof(tsf));\n                }\n                UnmapViewOfFile(lpMapAddress);\n                CloseHandle(hMapFile);\n                CloseHandle(hFile);\n            }\n        }\n    }\n    return 0;\n} \n</code></pre>\n<p>compiled and executed</p>\n<pre><code>cl /Zi /W4 /analyze:autolog- /Od /EHsc /nologo dumpdis.cpp /link /release\ndumpdis.cpp\n\ndumpdis.exe\nfile handle is 000000000000009C\nfile Map handle is 00000000000000A0\nview of map file is 0000029D96410000\nlook in debugger 4d0    2076    dce012edb0      1250    0\nlook in debugger 4d0    2546    dce01af858      7a8     0\nlook in debugger 4d0    2a16    dce047fa68      598     0\nlook in debugger 4d0    2ee6    dce04ffb48      4b8     0\n108\n</code></pre>\n<p>here is stack frame using GetScope from dbgeng IDebugSymbols<br/>\ncode below is a windbg extension a dll but you can make standalone exe with   dbgeng (see samples in windbg sdk )</p>\n<p>code</p>\n<pre><code>#include &lt;engextcpp.cpp&gt;\n#define bufsiz 0x2000\nclass EXT_CLASS : public ExtExtension\n{\npublic:\n    EXT_COMMAND_METHOD(gscope);\n};\nEXT_DECLARE_GLOBALS();\nEXT_COMMAND(gscope, \"\", \"\")\n{\n    PULONG64 ip = 0;\n    DEBUG_STACK_FRAME sfr = {0};\n    BYTE scont[bufsiz] = {0};\n    HRESULT hr = m_Symbols-&gt;GetScope(ip, &amp;sfr, &amp;scont, bufsiz);\n    if (hr == S_OK)\n    {\n        Out(\"insptr\\t=\\t%I64x\\n\", ip);\n        Out(\"instof\\t=\\t%I64x\\n\", sfr.InstructionOffset);\n        Out(\"retoff\\t=\\t%I64x\\n\", sfr.ReturnOffset);\n        Out(\"fraoff\\t=\\t%I64x\\n\", sfr.FrameOffset);\n        Out(\"staoff\\t=\\t%I64x\\n\", sfr.StackOffset);\n        Out(\"ftentr\\t=\\t%I64x\\n\", sfr.FuncTableEntry);\n        Out(\"parone\\t=\\t%I64x\\n\", sfr.Params[0]);\n        Out(\"partwo\\t=\\t%I64x\\n\", sfr.Params[1]);\n        Out(\"partre\\t=\\t%I64x\\n\", sfr.Params[2]);\n        Out(\"parfor\\t=\\t%I64x\\n\", sfr.Params[3]);\n        Out(\"resone\\t=\\t%I64x\\n\", sfr.Reserved[0]);\n        Out(\"virtua\\t=\\t%I64x\\n\", sfr.Virtual);\n        Out(\"franum\\t=\\t%I64x\\n\", sfr.FrameNumber);\n    }\n}\n</code></pre>\n<p>compiled &amp; linked with</p>\n<pre><code>cat complink.bat\ncl /LD /nologo /W4 /Ox  /Zi /EHsc /I\"C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\inc\" %1.cpp /link /EXPORT:DebugExtensionInitialize /Export:%1 /Export:help /RELEASE\n</code></pre>\n<p>executed !gscope and kb1 for comparison</p>\n<pre><code>cdb -c \".load gscope;!gscope;kb1;q\" -z ..\\dumsta\\tdump.dmp |awk \"/Reading/,/quit/\"     \n0:000&gt; cdb: Reading initial command '.load gscope;!gscope;kb1;q'\ninsptr  =       0\ninstof  =       7ffe652f108c\nretoff  =       7ffe652f444f\nfraoff  =       dce012ede0\nstaoff  =       dce012edb0\nftentr  =       0\nparone  =       dce0245000\npartwo  =       7ffe6534d4b0\npartre  =       7ffe6534d4b0\nparfor  =       7ffe6534d4b0\nresone  =       0\nvirtua  =       1\nfranum  =       0\nRetAddr           : Args to Child                                                           : Call Site      \n00007ffe`652f444f : 000000dc`e0245000 00007ffe`6534d4b0 00007ffe`6534d4b0 00007ffe`6534d4b0 : ntdll!LdrpDoDebuggerBreak+0x30\nquit:\n</code></pre>\n</div>",
            "votes": "1",
            "user": "blabb",
            "time": "Jul 29, 2021 at 18:17",
            "is_accepted": true,
            "comments": [
                {
                    "user": "ewokx",
                    "text": "<span class=\"comment-copy\">The reason why I use dbhlp is because that it's the only documentation I find that allows me to understand minidumps.  As I've only just started understanding this, I'm not familiar with dbgeng.  Now that you've pointed it out, it looks like the DEBUG_STACK_FRAME might be it though the ULONG64 addresses seem to be a bit long.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">added a snippet to fetch stack using GetScope  fromdbgeng IDebugSymbols  also issued kb1 inwindbg to compare DEBUG_STACK_FRAME With extension's output take a look</span>",
                    "time": null
                },
                {
                    "user": "ewokx",
                    "text": "<span class=\"comment-copy\">sorry for the delay @blabb,  just wanted to mention that I've been working on this problem on and off.  I don't have VS so I can't compile that code.</span>",
                    "time": null
                },
                {
                    "user": "blabb",
                    "text": "<span class=\"comment-copy\">what are you using clang? mingw? cygwin? why not add those details in your query. anyway dbgeng doesnt need vs</span>",
                    "time": null
                },
                {
                    "user": "ewokx",
                    "text": "<span class=\"comment-copy\">I'm sorry.  I screwed up and have realized I mistaken this crash dump as universal and that Microsoft's documentation was universal.  Apparently it isn't as I should actually be looking at Google's Breakpad code which is what most likely created this dump.  I'm so sorry.</span>",
                    "time": null
                }
            ]
        }
    ]
}