{
    "title": "What is SCARE (Side-Channel Attacks Reverse-Engineering)?",
    "link": "https://reverseengineering.stackexchange.com/questions/1897/what-is-scare-side-channel-attacks-reverse-engineering",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>When reversing smart-cards, the <a href=\"http://en.wikipedia.org/wiki/Side_channel_attack\" rel=\"nofollow\">side-channel attacks</a> are known to be quite effective on hardware. But, what is it, and can it be used in software reverse-engineering and how?</p>\n</div>",
    "votes": "5",
    "answers": 1,
    "views": "1k",
    "tags": [
        "hardware",
        "physical-attacks",
        "smartcards"
    ],
    "user": "perror",
    "time": "May 10, 2013 at 15:05",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>A '<em>side-channel attack</em>' define any technique that will consider unintended and/or indirect information channels to reach his goal. It has been first defined in smart-card cryptography to describe attacks which are using unintentional information leak from the embedded chip on the card and that can be used in retrieval of keys and data. For example, it may be used by monitoring:</p>\n<ul>\n<li><p><strong>Execution Time</strong> (Timing attack): To distinguish which operations has been performed and guess, for example, which branch of the code has been selected (and, thus, the value of the test).</p>\n</li>\n<li><p><strong>Power Consumption</strong> (Power monitoring attack): To distinguish precisely what sequence of instructions has been performed and be able to recompose the values of the variables. Note that there exist several techniques of analysis using the same input but with slightly different way of analyzing it. For example, we can list: <em>Single Power Analysis</em> (SPA), <em>Differential Power Analysis</em> (DPA), <em>High-order Differential Power Analysis</em> (HO-DPA), <em>Template Attacks</em>, ...</p>\n</li>\n<li><p><strong>Electromagnetic Radiation</strong> (Electromagnetic attacks): Closely related to power consumption, but can also provide information that are not found in power consumption especially on RFID or NFC chips.</p>\n</li>\n</ul>\n<p>If you're more interested in learning how to leverage this information then I'd suggest to start by reading <a href=\"https://rads.stackoverflow.com/amzn/click/com/1441940391\" rel=\"nofollow noreferrer\">Power Analysis Attacks</a>. Don't get 'scared' away by the fact that the book is about smart cards. Most of the information also applies 1-to-1 on 'normal' (SoC) embedded devices.</p>\n<p>Forgot to mention there's an open source platform called <a href=\"http://sourceforge.net/projects/opensca/\" rel=\"nofollow noreferrer\">OpenSCA</a> and some open source hardware called FOBOS (Flexible Open-source BOard for Side-channel) for which I can't seem to find a proper link from home.</p>\n<h2>Application to Software Reverse-engineering</h2>\n<p>Speaking about the application of side-channel attacks in software reverse engineering now, it is more or less any attacks that will rely on using unintended or indirect information leakage. The best recent example is this <a href=\"http://shell-storm.org/blog/A-binary-analysis-count-me-if-you-can/\" rel=\"nofollow noreferrer\">post</a> from <a href=\"https://twitter.com/JonathanSalwan\" rel=\"nofollow noreferrer\">Jonathan Salwan</a> describing how he guessed the password of a crackme just by counting the number of instructions executed on various inputs with <a href=\"http://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool\" rel=\"nofollow noreferrer\">Pin</a>.</p>\n<p>More broadly, this technique has been used since long in software reverse-engineering without naming it, or could have improved many analysis. The basic idea is to first consider that if a piece of software is too obscure to understand it quickly, we can consider it as a black-box and think about using a side-channels technique to guess the enclosed data through a guided trial and error technique.</p>\n<p>The list of side-channels available in software reverse-engineering is much longer than the one we have in hardware. Because it enclose the previous list and add some new channels such as (non exhaustive list):</p>\n<ul>\n<li><p><strong>Instruction Count</strong>: Allow to identify different behaviors depending on the input.</p>\n</li>\n<li><p><strong>Read/Write Count</strong>: Same as above, with more possibilities to identify patterns because it includes also instruction read.</p>\n</li>\n<li><p><strong>Raised Interrupt Count</strong>: Depending on what type of interrupt is raised, when and how, you might identify different behaviors and be able to determined the good path to your goal.</p>\n</li>\n<li><p><strong>Accessed Instruction Addresses</strong>: Allow to rebuild the parts of the program that are active at a precise moment.</p>\n</li>\n<li><p><strong>Accessed Memory Addresses</strong>: Allow to rebuild data pattern or complex data-structure stored or accessed in memory (eg. in the heap).</p>\n</li>\n</ul>\n<p>This list is far from being exhaustive, but basically tools such as Valgrind VM or others can be used to perform such analysis and quickly deduce information about the behavior of a given program, thus speeding up the reverse-engineering.</p>\n<h2>Obfuscation and Possible Counter-measures</h2>\n<p>Trying to build a software which will be resistant to such attacks will borrow also a lot from the smart-card industry. But, not only. Here are a few tricks, I could think of (but far from being complete about all we can find).</p>\n<h3>Armoring Program Branches</h3>\n<p>The instruction count is extremely efficient to detect which branch has been taken in code like this:</p>\n<pre><code>if (value)\n   ret = foo();\nelse \n   ret = bar();\n</code></pre>\n<p>With <code>foo()</code> and <code>bar()</code> having different instruction count.</p>\n<p>This can be defeated by executing <code>foo()</code> and <code>bar()</code> whatever <code>value</code> is and deciding afterward what is the value of <code>ret</code>.</p>\n<pre><code>tmp_foo = foo();\ntmp_bar = bar();\nif (value)\n  ret = tmp_foo;\nelse\n  ret = tmp_bar;\n</code></pre>\n<p>This technique render your program much more difficult to guess from a side-channel attack, but also much less efficient. One has to find a proper trade-off.</p>\n<h3>Countering Timing Attacks</h3>\n<p>Timing attacks are extremely easy to perform and difficult to workaround because <code>sleep()</code> cannot be an option (too easy to detect in a code and, anyway you cannot assume a specific speed for the processor). The programmer has to identify the execution time of each branch of his program and to <em>balance</em> each branch with extra non-useful operations which are of the same computational power than the ones from the other branchs. The point being to render each branch indistinguishable from the others only based on the execution time.</p>\n<h3>Threading Madness</h3>\n<p>Another way to dilute the side-channel is to massively multi-thread your program. Imagine that each branch of your program is executed in a separate thread, and one variable tell in which thread the current program really is (if possible in a cryptic manner). Then side-channel analysis will be much more difficult to perform.</p>\n<h2>Conclusion and Further Research</h2>\n<p>Side-channel attacks has been widely under-estimated for software reverse-engineering, it can drastically speed-up the reverse of many programs. But, in the same time, obfuscation techniques exists and have to be developed specifically targeting software reverse-engineering. So, don't be surprised if you see more and more novelties related to this field.</p>\n</div>",
            "votes": "6",
            "user": "Community",
            "time": "Jun 17, 2020 at 9:54",
            "is_accepted": true,
            "comments": [
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">Unfortunately, the Wikipedia article is just wrong and confusing. First of all, we shouldn't confuse fault injection and side-channel attacks, then DPA (Differential Power Analysis) is not even mentioned, but it seems to be the more used attack nowadays. And, finally, after reading this wikipedia article, I still don't see what are the mathematics used to reveal new data. Citing a few tutorials could also help.</span>",
                    "time": null
                },
                {
                    "user": "ixje",
                    "text": "<span class=\"comment-copy\">I admit not reading the whole wiki article because I thought the information you asked for was mentioned at the start. I still strongly recommend the DPA book I mentioned. It describes the math as well. After that you can try finding papers presented at conferences like <a href=\"http://www.iacr.org/workshops/ches/\" rel=\"nofollow noreferrer\">CHES</a> for more advanced attacks. If you want a free introduction to some side channel analysis distinguishers you can read chapter 3.7 of this paper <a href=\"http://www.ru.nl/publish/pages/578936/principal_component_analysis_and_sca_-_jip_hogenboom.pdf\" rel=\"nofollow noreferrer\">Principal Component analysis and SCA</a></span>",
                    "time": null
                },
                {
                    "user": "perror",
                    "text": "<span class=\"comment-copy\">In fact, I did not criticize your contribution at all (the book seems extremely interesting), but the Wikipedia article which is more an itemized list with no real definition (and, moreover, they classify fault injection as a side-channel attack which is wrong).</span>",
                    "time": null
                },
                {
                    "user": "mikeazo",
                    "text": "<span class=\"comment-copy\">For any looking for the Principal Component Analysis and SCA paper justsome mentioned (link is now broken), try here: <a href=\"http://www.ru.nl/publish/pages/769526/principal_component_analysis_and_sca_-_jip_hogenboom.pdf\" rel=\"nofollow noreferrer\">ru.nl/publish/pages/769526/…</a></span>",
                    "time": null
                }
            ]
        }
    ]
}