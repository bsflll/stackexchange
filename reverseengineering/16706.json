{
    "title": "What causes the need for NOP sleds?",
    "link": "https://reverseengineering.stackexchange.com/questions/16706/what-causes-the-need-for-nop-sleds",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>So when taking a simple scenario and exploiting a stack buffer overflow in which I can execute code on the stack, my payload simply is:</p>\n<pre><code>NOP Sled -&gt; Shellcode -&gt; Padding -&gt; New RET Address (Pointing to the NOP Sled)\n</code></pre>\n<p>What I get is that we need to have a memory address included in the shellcode which points somewhere into the NOP Sled, which we need because we \"can't be sure\" what the return address is.</p>\n<p>Why can't we be sure?</p>\n<p>Could it be simple things such as argv[0] being different, eg. on one system the file might be \"/vuln\" and on another \"/home/user/vuln\" and for this reason the stack is already different?\nDo environment Variables play a role? What else is involved?</p>\n<p>Basically my question is: Which factors lead to the stack being different every time we execute / executing the vuln program on another machine?</p>\n</div>",
    "votes": "14",
    "answers": 2,
    "views": "4k",
    "tags": [
        "memory",
        "buffer-overflow",
        "security"
    ],
    "user": "L. Heldt",
    "time": "Nov 4, 2017 at 12:57",
    "comments": [],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>On modern systems the most obvious culprit is probably address space layout randomization, but stack frame layout variablity was problematic for exploit development even before ASLR became widely implemented. This was alluded to in AlephOne's venerable \"Smashing the Stack for Fun and Profit\":</p>\n<ul>\n<li><blockquote>\n<p>The problem we are faced when trying to overflow the buffer of another\n  program is trying to figure out at what address the buffer (and thus our\n  code) will be.  The answer is that for every program the stack will\n  start at the same address.  Most programs do not push more than a few hundred or a few thousand bytes into the stack at any one time.  Therefore by knowing where the stack starts we can try to guess where the buffer we are trying to overflow will be.</p>\n</blockquote></li>\n<li><blockquote>\n<p>Trying to guess the\n  offset even while knowing where the beginning of the stack lives is nearly\n  impossible.  We would need at best a hundred tries, and at worst a couple of thousand.  The problem is we need to guess <em>exactly</em> where the address of our code will start.  If we are off by one byte more or less we will just get a segmentation violation or a invalid instruction.  One way to increase our chances is to pad the front of our overflow buffer with NOP instructions.</p>\n</blockquote></li>\n</ul>\n<p>So this is an issue even without ASLR enabled. Reasons for this involve the following (as far as I know):</p>\n<ul>\n<li>compilers/compiler toolchains and the ABI</li>\n<li>the runtime environment</li>\n</ul>\n<h1>Compilers, the ABI and Stack Frame Layout</h1>\n<p>Interestingly, the code that manages the runtime stack is generated by the compiler and the compiler cannot know what the absolute positions of stack frames during program runtime will be:</p>\n<blockquote>\n<p>While the location of a stack frame cannot be predicted at compile time (the compiler cannot in general tell what other frames may already be on the stack), the offsets of objects within a frame usually can be statically determined. Moreover, the compiler can arrange (in the calling sequence or prologue) for a particular register, known as the frame pointer to always point to a known location within the frame of the current subroutine. Code that needs to access a local variable within\n  the current frame, or an argument near the top of the calling frame, can do so by adding a predetermined offset to the value in the frame pointer.<sup>1</sup></p>\n</blockquote>\n<p>The way in which memory is allocated and deallocated for stack frames can vary across compilers, as well as different versions of the same compiler toolchain. Why this might be the case is alluded to in the <a href=\"https://refspecs.linuxfoundation.org/elf/abi386-4.pdf\" rel=\"noreferrer\">System V i386 Architecture Processor Supplement</a> (page 36):</p>\n<ol>\n<li><blockquote>\n<p>The stack is word aligned. Although the architecture does not require any alignment of the stack, software convention and the operating system\n  requires that the stack be aligned on a word boundary.</p>\n</blockquote>\n<p>By default, GCC aligns the stack to a 16-byte boundary on i386 machines (x86):</p>\n<blockquote>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.5.3/gcc/i386-and-x86_002d64-Options.html\" rel=\"noreferrer\"><code>-mpreferred-stack-boundary=num</code></a><br/>\n  Attempt to keep the stack boundary aligned to a 2 raised to <code>num</code> byte boundary. If <code>-mpreferred-stack-boundary</code> is not specified, the default is 4 (16 bytes or 128 bits).</p>\n</blockquote>\n<p>This means that even if a local variable or argument to a function is 4 bytes in length (such as  an<code>int</code>), at least 16 bytes of space will be allocated on the stack frame for that function. Since this is a command line argument for <code>gcc</code>, it goes without saying that this can be changed.</p></li>\n<li><blockquote>\n<p>Other areas depend on the compiler and the code being compiled. The standard calling sequence does not define a maximum stack frame size, nor does it restrict how a language system uses the ‘‘unspecified’’ area of the standard stack frame.</p>\n</blockquote>\n<p>This \"unspecified\" area of a stack frame includes all of the frame except for the return address and the saved base pointer of the previous frame:</p>\n<p><a href=\"https://i.sstatic.net/qBX1N.png\" rel=\"noreferrer\"><img alt=\"SYS V i386 standard stack frame\" src=\"https://i.sstatic.net/qBX1N.png\"/></a></p>\n<p>The data written to this area can include saved registers, local variables, temporaries, and arguments to the next function<sup>2</sup>. GCC will allocate memory required to store this data in a frame <em>plus</em> space required to maintain stack alignment to the boundary specified when the binary was compiled:</p>\n<p><a href=\"https://i.sstatic.net/ZsNJf.png\" rel=\"noreferrer\"><img alt=\"x86 stack frame layout\" src=\"https://i.sstatic.net/ZsNJf.png\"/></a></p></li>\n</ol>\n<p>Here is how all of this ties together:</p>\n<ol>\n<li><p>It cannot be determined prior to run time what the absolute virtual memory addresses of data on the stack will be, so indirect addressing is used instead (using <code>%ebp</code> and <code>%esp</code> to calculate offsets, for example). However, to control EIP an absolute memory address of executable instructions must be written to EIP. So now one must figure out what this address is without having absolute addresses to work with when disassembling the binary</p></li>\n<li><p>The precise layout of a stack frame, and by extension the runtime stack, is determined by the compiler used to create the binary one seeks to exploit. </p>\n<ul>\n<li>This means that the amount of space allocated to variables such as buffers depends at the very least on the boundary to which the compiler aligns stack frames (4 bytes? 8 bytes? 16 bytes? and so on). </li>\n<li>This can lead to \"slack space\" in stack frames to which no values associated with local variables are written (contains garbage data). </li>\n<li>In addition to this, the compiler also determines in what order variables are laid out within the stack frame. </li>\n<li>Compilation with optimization can have adverse effects on calling conventions specified in the architecture-specific ABI and how stack frames are laid out</li>\n<li>Compilation with stack protection will further influence how data is arranged within stack frame by the compiler</li>\n</ul></li>\n</ol>\n<p>In sum, the offset between the buffer being overflowed and the target return address location can vary based on compiler toolchain (GCC, TCC, MSVC, etc), compiler version (3.x, 4.x etc) and the particular options used to compile the binary (alignment value, optimization level, stack protection, etc):</p>\n<blockquote>\n<p>The exact distance between the return address and the start of the [buffer] can change due to different compiler versions and different optimization flags. As long as the start of the buffer is aligned with DWORDs on the stack, this mutability can be accounted for by simply repeating the return address many times. This way, at least one of the instances will overwrite the return address, even if it has shifted around due to compiler optimizations.<sup>3</sup></p>\n</blockquote>\n<h1>The Runtime Environment</h1>\n<p>It has been <a href=\"https://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it/17775966#17775966\">suggested elsewhere</a> that stack layout indeterminicy can be caused by environmental variables and program arguments:</p>\n<blockquote>\n<p>Exploit development can lead to serious headaches if you don't adequately account for factors that introduce non-determinism into the debugging process. In particular, the stack addresses in the debugger may not match the addresses during normal execution. This artifact occurs because the operating system loader places both environment variables and program arguments before the beginning of the stack</p>\n</blockquote>\n<p>This makes sense if we look at how the stack is laid out in virtual memory:\n<a href=\"https://i.sstatic.net/DMGgA.png\" rel=\"noreferrer\"><img alt=\"The Linux Programming Interface, page 119\" src=\"https://i.sstatic.net/DMGgA.png\"/></a></p>\n<p>If there are differences across executions in the environment or arguments, the location of the base of the stack may change as well.</p>\n<p>To show that this is not simply idle speculation, we can look at a concrete example. First, we disable ASLR like so:</p>\n<p><code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></p>\n<p>Then we write a quick program in C:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint test(int a, int b)\n{\n        printf(\"%p\\n\", &amp;a);\n        return a*a + b*b;\n}\n\nint main(void)\n{\n        return test(3, 5);\n}\n</code></pre>\n<p>When compiled and then run a few times with steadily increasing argument lengths, it is observed that the position on the stack of one of the local variables changes to lower and lower in virtual memory:</p>\n<pre><code>$ gcc -m32 simple.c -o simple\n$ ./simple \n0xffffd210\n$ ./simple AAAAAAAA\n0xffffd200\n$ ./simple AAAAAAAAAAAAAAAA\n0xffffd200\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1f0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1f0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1e0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1e0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1d0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1d0\n$ ./simple AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n0xffffd1c0\n</code></pre>\n<p>This indicates that changing the sizes of the arguments passed to <code>execve</code> also changes the position of the runtime stack in virtual memory. The weakness of this extremely trivial example is that it does not accurately reflect the complexity of real-world programs or capture how the runtime stack changes throughout execution of more complex processes. </p>\n<p>An additional variable influencing the layout of the runtime stack is whether the binary is dynamically linked or not. If it is dynamically linked, process startup is handled by <code>glibc</code>. <a href=\"http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html\" rel=\"noreferrer\">On x86 Linux systems the C runtime library function call sequence looks similar to this</a>: \n<a href=\"https://i.sstatic.net/suPwc.png\" rel=\"noreferrer\"><img alt=\"x86 Linux Program Startup\" src=\"https://i.sstatic.net/suPwc.png\"/></a></p>\n<p>This will depend on what version of <code>glibc</code> the binary is linked against, and the runtime environment will vary across machines. This means that the function call sequence during process startup will vary across systems as well.</p>\n<hr/>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://www.win.tue.nl/~aeb/linux/hh/hh-10.html\" rel=\"noreferrer\">https://www.win.tue.nl/~aeb/linux/hh/hh-10.html</a></li>\n<li><a href=\"https://www.win.tue.nl/~aeb/linux/hh/bof-eng.txt\" rel=\"noreferrer\">https://www.win.tue.nl/~aeb/linux/hh/bof-eng.txt</a></li>\n<li><a href=\"https://0xax.gitbooks.io/linux-insides/content/Misc/program_startup.html\" rel=\"noreferrer\">https://0xax.gitbooks.io/linux-insides/content/Misc/program_startup.html</a></li>\n</ul>\n<hr/>\n<p><sub>1. Scott, Michael L. <em>Programming Language Pragmatics</em>. 3rd ed. Page 117</sub></p>\n<p><sub>2. Bryant, O'Hallaron. <em>Computer Systems: A Programmer's Perspective</em>. 2nd ed. Page 220</sub></p>\n<p><sub>3. Erickson, Jon. <em>Hacking: The Art of Exploitation</em>. 2nd ed. Page 136</sub></p>\n</div>",
            "votes": "11",
            "user": "julian",
            "time": "Nov 5, 2017 at 23:16",
            "is_accepted": false,
            "comments": []
        },
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>As you mentioned, many things can leave you with a different memory layout than the one you expect: </p>\n<ul>\n<li>The name of the binary is one.</li>\n<li>The environment variables the binary gets is another one.</li>\n<li>If it's being debugged (related to the previous point)</li>\n<li>Security measures such as stack cookies</li>\n<li>Etc</li>\n</ul>\n<p>Using hardcoded addresses pointing to the stack as the address that will be taken by <code>EIP</code> is the wrong approach. That's how it was done in the early days. Sketchy approach and no DEP/NX in place.</p>\n<p>A more stable approach is that instead of jumping to the middle of the stack, you can directly jump to code that will get executed. There are different techniques to do so such as <a href=\"http://phrack.org/issues/58/4.html\" rel=\"nofollow noreferrer\">return-to-libc/library</a> or <a href=\"https://en.wikipedia.org/wiki/Return-oriented_programming\" rel=\"nofollow noreferrer\">ROP</a>.</p>\n<p>Another simpler approach is checking where your registers point in the moment when the overflow happens (actually, when the segfault is triggered). Imagine that <code>ESP</code> points to 0x12345678. If you have control of the contents of 0x12345678 at the moment of the segfault in a stable way, you can just use the address of a <code>JMP ESP</code>-kind instruction as what will be taken by <code>EIP</code>.</p>\n<ul>\n<li>Why is this approach better?</li>\n</ul>\n<p>Because you are certain that the binary itself or the libraries that get loaded (therefore, their instructions) when the binary is executed will always be stored in the same address. (1) </p>\n<p>Long story short, the motto goes by... \"If your exploit contains <code>NOP</code>s, you are doing something wrong!\". </p>\n<p>To answer the question in your title, there is no need for NOP sleds.</p>\n<ol>\n<li>As far as there's no ASLR or module re-base.</li>\n</ol>\n</div>",
            "votes": "1",
            "user": "newlog",
            "time": "Nov 4, 2017 at 17:21",
            "is_accepted": false,
            "comments": []
        }
    ]
}