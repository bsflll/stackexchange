{
    "title": "objdump -T gives Invalid Operation on MIPS .so",
    "link": "https://reverseengineering.stackexchange.com/questions/17196/objdump-t-gives-invalid-operation-on-mips-so",
    "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>I have a MIPS .so file that I'm trying to reverse.  Binary Ninja (too cheap for IDA) finds no symbols, and neither does <code>objdump -T</code>, instead giving \"Invalid Operation\":</p>\n<pre><code>% mips-linux-gnu-objdump -x libinet.so\n\nlibinet.so:     file format elf32-tradbigmips\nlibinet.so\narchitecture: mips:isa32r2, flags 0x00000140:\nDYNAMIC, D_PAGED\nstart address 0x000040f0\n\nProgram Header:\n0x70000000 off    0x000000f4 vaddr 0x000000f4 paddr 0x000000f4 align 2**2\n         filesz 0x00000018 memsz 0x00000018 flags r--\n    LOAD off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**16\n         filesz 0x00013454 memsz 0x00013454 flags r-x\n    LOAD off    0x00014000 vaddr 0x00024000 paddr 0x00024000 align 2**16\n         filesz 0x000006c0 memsz 0x00000d6c flags rw-\n DYNAMIC off    0x0000010c vaddr 0x0000010c paddr 0x0000010c align 2**2\n         filesz 0x00000108 memsz 0x00000108 flags rwx\n   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4\n         filesz 0x00000000 memsz 0x00000000 flags rw-\n    NULL off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**2\n         filesz 0x00000000 memsz 0x00000000 flags ---\nprivate flags = 74001007: [abi=O32] [mips32r2] [mips16] [not 32bitmode] [noreorder] [PIC] [CPIC]\n\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\nSYMBOL TABLE:\nno symbols\n\n\n% mips-linux-gnu-objdump -T libinet.so\nmips-linux-gnu-objdump: libinet.so: Invalid operation\nlibinet.so:     file format elf32-tradbigmips\n</code></pre>\n<p>Anyone know why this would happen?  Are there any better tools to explore the ELF metadata to see if there's something unusual about this shared object?</p>\n<p><strong>Edit</strong> Some more results:</p>\n<pre><code>% file libinet.so \nlibinet.so: ELF 32-bit MSB shared object, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, corrupted section header size\n% readelf -SW ./libinet.so \n\nThere are no sections in this file.\n</code></pre>\n</div>",
    "votes": "1",
    "answers": 1,
    "views": "2k",
    "tags": [
        "file-format",
        "elf"
    ],
    "user": "David",
    "time": "Jan 15, 2018 at 4:06",
    "comments": [
        {
            "user": "julian",
            "text": "<span class=\"comment-copy\">look at the sections using <code>readelf -SW &lt;binary&gt;</code>. Run <code>file</code> against it. etc</span>",
            "time": null
        }
    ],
    "answers_data": [
        {
            "content": "<div class=\"s-prose js-post-body\" itemprop=\"text\">\n<p>Alas, BFD-based tools like <code>gdb</code> or <code>objdump</code> <a href=\"https://github.com/BR903/ELFkickers/tree/master/sstrip\" rel=\"nofollow noreferrer\">can't handle ELF files without a section table</a>. However, Linux and other OSes using ELFs do not actually require a file to have section table to be executable, only the segment table (Program headers) are enough. However, <code>readelf</code> does not use BFD and so can display ELF details even without section table. For example:</p>\n<pre><code>&gt;readelf -SW sample.elf\nThere are no sections in this file.\n</code></pre>\n<p>but:</p>\n<pre><code>&gt;readelf -ed sample.elf\nELF Header:\n  Magic:   7f 45 4c 46 01 02 01 00 00 00 00 00 00 00 00 00 \n  Class:                             ELF32\n  Data:                              2's complement, big endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           MIPS R3000\n  Version:                           0x1\n  Entry point address:               0x405110\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          0 (bytes into file)\n  Flags:                             0x50001007, noreorder, pic, cpic, o32, mips32\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         7\n  Size of section headers:           0 (bytes)\n  Number of section headers:         0\n  Section header string table index: 0\n\nThere are no sections in this file.\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  PHDR           0x000034 0x00400034 0x00400034 0x000e0 0x000e0 R E 0x4\n  INTERP         0x000114 0x00400114 0x00400114 0x00014 0x00014 R   0x1\n      [Requesting program interpreter: /lib/ld-uClibc.so.0]\n  REGINFO        0x000128 0x00400128 0x00400128 0x00018 0x00018 R   0x4\n  LOAD           0x000000 0x00400000 0x00400000 0x5d86c 0x5d86c R E 0x1000\n  LOAD           0x05e000 0x10000000 0x10000000 0x01f64 0x055c4 RW  0x1000\n  DYNAMIC        0x000140 0x00400140 0x00400140 0x04f36 0x04f36 RWE 0x4\n  GNU_EH_FRAME   0x05d850 0x0045d850 0x0045d850 0x0001c 0x0001c R   0x4\n\nDynamic section at offset 0x140 contains 26 entries:\n  Tag        Type                         Name/Value\n 0x00000001 (NEEDED)                     Shared library: [libcrypt.so.0]\n 0x00000001 (NEEDED)                     Shared library: [libm.so.0]\n 0x00000001 (NEEDED)                     Shared library: [libnbu.so]\n 0x00000001 (NEEDED)                     Shared library: [libnbd.so]\n 0x00000001 (NEEDED)                     Shared library: [libc.so.0]\n 0x0000000c (INIT)                       0x405088\n 0x0000000d (FINI)                       0x4557b0\n 0x00000004 (HASH)                       0x400238\n 0x00000005 (STRTAB)                     0x403868\n 0x00000006 (SYMTAB)                     0x401398\n 0x0000000a (STRSZ)                      6158 (bytes)\n 0x0000000b (SYMENT)                     16 (bytes)\n 0x70000016 (MIPS_RLD_MAP)               0x10001630\n 0x00000015 (DEBUG)                      0x0\n 0x00000003 (PLTGOT)                     0x10001640\n 0x00000011 (REL)                        0x405078\n 0x00000012 (RELSZ)                      16 (bytes)\n 0x00000013 (RELENT)                     8 (bytes)\n 0x70000001 (MIPS_RLD_VERSION)           1\n 0x70000005 (MIPS_FLAGS)                 NOTPOT\n 0x70000006 (MIPS_BASE_ADDRESS)          0x400000\n 0x7000000a (MIPS_LOCAL_GOTNO)           13\n 0x70000011 (MIPS_SYMTABNO)              589\n 0x70000012 (MIPS_UNREFEXTNO)            35\n 0x70000013 (MIPS_GOTSYM)                0x11\n 0x00000000 (NULL)                       0x0\n</code></pre>\n<p>As you can see, it does have a proper dynamic table with <code>DT_SYMTAB</code> entry necessary to resolve symbols. However, <code>readelf</code> lacks a disassembler so we will have to use <code>objdump</code> after all, just without relying on the section table. First, let's extract the first <code>LOAD</code> segment (it has \"(R)ead (E)execute\" flags so likely to contain code) into a separate file:</p>\n<blockquote>\n<p>dd if=sample.elf bs=1 skip=0 count=383084 of=text.bin</p>\n</blockquote>\n<p>(unfortunately <code>dd</code> only accepts decimal values). </p>\n<p>P.S. In fact, since the segment starts at 0, you could have skipped this step and disassembled the input file directly. However, this is not always the case. so may be useful for other files.</p>\n<p>Now we can disassemble it with <code>objdump</code> as raw binary:</p>\n<pre><code>mips-linux-gnu-objdump -b binary -D -m mips:isa32r2 --adjust-vma=0x00400000 --start-address=0x405110  -EB text.bin \n</code></pre>\n<p>Breakdown of the options:</p>\n<ul>\n<li><code>b binary</code>: treat input as raw binary</li>\n<li><code>-D</code>: disassemble everything as code (necessary for raw binaries since they don't have sections or other metadata)</li>\n<li><code>-m mips:isa32r2</code> : treat code as MIPS32r2 instructions</li>\n<li><code>--adjust-vma=0x00400000</code> : assume that binary is loaded at <code>0x00400000</code> (<code>VirtAddr</code> column from the <code>readelf</code> program headers dump).</li>\n<li><code>--start-address=0x405110</code>:  start disassembly at 0x405110 (\"Entry point address\" from the header dump)</li>\n<li><code>-EB</code>: instructions are big-endian (as hinted by <code>readelf</code>).</li>\n</ul>\n<p>The result looks like:</p>\n<pre><code>Disassembly of section .data:\n\n00405110 &lt;.data+0x5110&gt;:\n  405110:       04100001        bltzal  zero,0x405118\n  405114:       00000000        nop\n  405118:       3c1c0fc0        lui     gp,0xfc0\n  40511c:       279c4518        addiu   gp,gp,17688\n  405120:       039fe021        addu    gp,gp,ra\n  405124:       0000f821        move    ra,zero\n  405128:       8fa40000        lw      a0,0(sp)\n  40512c:       27a50004        addiu   a1,sp,4\n  405130:       24860001        addiu   a2,a0,1\n  405134:       00063080        sll     a2,a2,0x2\n  405138:       00c53020        add     a2,a2,a1\n  40513c:       8f87861c        lw      a3,-31204(gp)\n  405140:       27bdffe8        addiu   sp,sp,-24\n  405144:       8f82829c        lw      v0,-32100(gp)\n  405148:       00000000        nop\n  40514c:       afa20010        sw      v0,16(sp)\n  405150:       8f998114        lw      t9,-32492(gp)\n  405154:       00000000        nop\n  405158:       0320f809        jalr    t9\n  40515c:       00000000        nop\n  405160:       27bd0018        addiu   sp,sp,24\n  405164:       1000ffff        b       0x405164\n  405168:       00000000        nop\n</code></pre>\n<p>Don't pay attention to <code>.data</code>, that's just the default name when <code>objdump</code>  has no other information.</p>\n<p>Making sense of the disassembly is left as an exercise to the reader :)</p>\n<hr/>\n<p><strong>EDIT</strong></p>\n<p>I forgot <code>readelf</code> options. In fact, the manpage mentions:</p>\n<hr/>\n<p><strong>-D</strong><br/>\n<strong>--use-dynamic</strong></p>\n<p>When displaying symbols, this option makes readelf use the symbol table in the file's dynamic section, rather than the one in the symbols section. </p>\n<hr/>\n<p>And indeed, <code>readelf -Ds sample.elf</code> shows nice output:</p>\n<pre><code>Symbol table for image:\n  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n   58   0: 00455690     0 FUNC    GLOBAL DEFAULT UND execvp\n  384   1: 00454c90     0 FUNC    GLOBAL DEFAULT UND getpgrp\n   68   3: 00455640     0 FUNC    GLOBAL DEFAULT UND open\n  123   3: 004554a0     0 FUNC    GLOBAL DEFAULT UND socketpair\n  513   3: 0044a298     0 FUNC    GLOBAL DEFAULT bad xdr_dirpath\n  120   4: 004554b0     0 FUNC    GLOBAL DEFAULT UND strftime\n  373   4: 00454ce0     0 FUNC    GLOBAL DEFAULT UND strrchr\n  572   4: 00454730     0 FUNC    GLOBAL DEFAULT UND waitpid\n</code></pre>\n</div>",
            "votes": "2",
            "user": "Igor Skochinsky",
            "time": "Jan 15, 2018 at 19:53",
            "is_accepted": true,
            "comments": [
                {
                    "user": "David",
                    "text": "<span class=\"comment-copy\">What kind of compilation options/steps lead to an ELF file lacking a section table?  Is there any way to dump the contents of DT_SYMTAB to read the mappings from symbol -&gt; function?</span>",
                    "time": null
                },
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">I think some toolchains default to no section table to save space, but I don’t know the details. In theory readelf has all the information needed to dump the symtab, I’m not sure why it’s not doing it (probably nobody got around implementing it). it has the same format as the standard elf .symtab, so you just need to map the virtual address back to the file offset using the program headers.</span>",
                    "time": null
                },
                {
                    "user": "Igor Skochinsky",
                    "text": "<span class=\"comment-copy\">@David see edit.</span>",
                    "time": null
                }
            ]
        }
    ]
}